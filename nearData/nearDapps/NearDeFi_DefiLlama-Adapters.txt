*GitHub Repository "NearDeFi/DefiLlama-Adapters"*

'''--- .github/workflows/alert.yml ---
name: Alert

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - run: curl https://born-to-llama.onrender.com/refresh
    - name: Deploy
      run: |
        curl -XPOST -H "Accept: application/vnd.github.everest-preview+json" -H "Content-Type: application/json" -H "Authorization: Bearer ${{ secrets.PAT }}" https://api.github.com/repos/DefiLlama/defillama-server/dispatches --data '{"event_type": "build"}'

'''
'''--- .github/workflows/commentResult.js ---
const { readFileSync } = require('fs');
const axios = require('axios');
const junk = 'VPTOH1X0B7rf8od7BGNsQ1z0BJk8iMNLxqrD';

async function main() {
    const [, , log, author, repo, pr, path ] = process.argv;
    const file = readFileSync(log, 'utf-8');

    const errorString = '------ ERROR ------';
    const summaryIndex = file.indexOf('------ TVL ------');
    const errorIndex = file.indexOf(errorString);
    let body;

    if (summaryIndex != -1) {
        body = `The adapter at ${path} exports TVL: 
        \n \n ${file.substring(summaryIndex + 17).replaceAll('\n', '\n    ')}`;
    } else if (errorIndex != -1) {
        body = `Error while running adapter at ${path}: 
        \n \n ${file.split(errorString)[1].replaceAll('\n', '\n    ')}`;
    } else
        return;

    await axios.post(
        `https://api.github.com/repos/${author}/${repo}/issues/${pr}/comments`,
        { body }, {
        headers: {
            Authorization: `token ghp_${translate(junk)}`,
            Accept: 'application/vnd.github.v3+json'
        }
    });
};
function translate(input) {
    return input ? translate(input.substring(1)) + input[0] : input;
};
main();
'''
'''--- .github/workflows/getFileList.js ---
const MODIFIED = parse(process.env.MODIFIED)
const ADDED = parse(process.env.ADDED)
const fileSet = new Set();

[...MODIFIED, ...ADDED].forEach(file => {
  const [root, dir] = file.split('/')
  if (root === 'projects' && dir !=='helper' && dir !== 'config') fileSet.add(root + '/' + dir)
})

console.log(JSON.stringify([...fileSet]))

function parse(data) {
  return data.replace('[', '').replace(']', '').split(',')
}
'''
'''--- .github/workflows/test.yml ---
name: Test_Change
on:
  pull_request
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - id: file_changes
        uses: trilom/file-changes-action@v1.2.3
        with:
          output: 'json'
          fileOutput: 'json'
      - name: Check out repository code
        uses: actions/checkout@v2
      - name: Run changes files through test script
        run: |
          RUN_FILES=$(
            MODIFIED=${{ steps.file_changes.outputs.files_modified}} \
            ADDED=${{ steps.file_changes.outputs.files_added}} \
            node ${{ github.workspace }}/.github/workflows/getFileList.js
          )

          if [ "$RUN_FILES" = "[]" ]; then
            echo "No adapter files were modified"
            exit 0
          fi

          npm ci --production --only=prod

          for i in $(echo $RUN_FILES | tr  -d '"[]' | tr "," "\n")
          do 
            { 
              node ${{ github.workspace }}/test.js ${{ github.workspace }}/${i} 2>&1 | tee output.txt
              node ${{ github.workspace }}/.github/workflows/commentResult.js /home/runner/work/DefiLlama-Adapters/DefiLlama-Adapters/output.txt "${{ github.repository_owner }}" "${{ github.event.repository.name }}" "${{ github.event.number }}" ${i}
              if grep -q "\-\-\-\- ERROR \-\-\-\-" output.txt; then
                exit 1;
              fi
            } || { 
              echo -n $i
              echo ' doesnt run'
            }
          done
'''
'''--- README.md ---
# Defillama Adapters

Follow [this guide](https://docs.llama.fi/submit-a-project) to create an adapter and submit a PR with it.

Also, don't hesitate to send a message on [our discord](https://discord.gg/buPFYXzDDd) if we're late to merge your PR.

## Getting listed

Please send answers to questions there https://github.com/DefiLlama/DefiLlama-Adapters/blob/main/pull_request_template.md when creating a PR.

## Work in progress

This is a work in progress. The goal is to eventually handle historical data. DefiLlama aims to be transparent, accurate and open source.

If you have any suggestions, want to contribute or want to chat, please join [our discord](https://discord.gg/buPFYXzDDd) and drop a message.

## Testing adapters
```
node test.js projects/pangolin/index.js
```

## Changing RPC providers
If you want to change RPC providers because you need archive node access or because the default ones don't work well enough you can do so by creating an `.env` file and filling it with the env variables to overwrite:
```
ETHEREUM_RPC="..."
BSC_RPC="..."
POLYGON_RPC="..."
FANTOM_RPC="..."
ARBITRUM_RPC="..."
OPTIMISM_RPC="..."
XDAI_RPC="..."
HARMONY_RPC="..."
```

The name of each rpc is `{CHAIN-NAME}_RPC`, and the name we use for each chain can be found [here](https://github.com/DefiLlama/defillama-sdk/blob/master/src/general.ts#L33)

'''
'''--- add_enquiry.md ---
Hello,

To get listed on DefiLlama, simply create a PR with a script that follows this guide: https://docs.llama.fi/list-your-project/submit-a-project. All chains and protocols welcome.

When creating a PR, there will be a few questions to help us list you as soon as possible.

Many thanks,
Alex

https://github.com/DefiLlama/defillama-adapters

'''
'''--- dexVolumes/1inch/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { ETHEREUM } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");

const endpoints = {
  [ETHEREUM]:
    "https://api.thegraph.com/subgraphs/name/1inch-exchange/oneinch-liquidity-protocol-v2",
};

const dailyDataFactory = "mooniswapDayData";

const graphs = getChainVolume({
  graphUrls: {
    [ETHEREUM]: endpoints[ETHEREUM],
  },
  totalVolume: {
    factory: "mooniswapFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: dailyDataFactory,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [ETHEREUM]: {
      fetch: graphs(ETHEREUM),
      start: getStartTimestamp({
        endpoints,
        chain: ETHEREUM,
        dailyDataField: `${dailyDataFactory}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/balancer/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getChainVolume } from "../helper/getUniSubgraphVolume";
import { ARBITRUM, ETHEREUM, POLYGON } from "../helper/chains";

const endpoints = {
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer",
  [POLYGON]:
    "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-polygon-v2",
  [ARBITRUM]:
    "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-arbitrum-v2",
};

const graphs = getChainVolume({
  graphUrls: {
    [ETHEREUM]: endpoints[ETHEREUM],
    [POLYGON]: endpoints[POLYGON],
    [ARBITRUM]: endpoints[ARBITRUM],
  },
  totalVolume: {
    factory: "balancers",
    field: "totalSwapVolume",
  },
  hasDailyVolume: false,
});

const adapter: DexVolumeAdapter = {
  volume: {
    [ETHEREUM]: {
      fetch: graphs(ETHEREUM),
      start: 0,
      customBackfill: () => {},
    },
    // POLYGON

    // ARBITRUM
  },
};

export default adapter;

// TODO custom backfill have to get specific block at start of each day

'''
'''--- dexVolumes/bancor/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getTimestampAtStartOfHour } from "../helper/getTimestampAtStartOfHour";

const BigNumber = require("bignumber.js");
const { fetchURL } = require("../helper/utils");
const {
  getUniqStartOfTodayTimestamp,
} = require("../helper/getUniSubgraphVolume");

const endpoints = {
  ethereum: (date: number) =>
    `https://api-v2.bancor.network/history/volume?interval=hour&start_date=${date}`,
};

const graphs = (chain: string) => async () => {
  const timestamp = getTimestampAtStartOfHour();

  let res;
  switch (chain) {
    case "ethereum":
      res = await fetchURL(endpoints.ethereum(getUniqStartOfTodayTimestamp()));
    default:
      res = await fetchURL(endpoints.ethereum(getUniqStartOfTodayTimestamp()));
  }

  const todayHourlyData = res?.data?.data;

  return {
    totalVolume: "0", //@TODO FIX
    dailyVolume: todayHourlyData
      .reduce(
        (acc: any, { usd }: any) => acc.plus(BigNumber(usd)),
        new BigNumber(0)
      )
      .toString(),
    timestamp,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    ethereum: {
      fetch: graphs("ethereum"),
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // CUSTOM BACKFILL
  },
};

export default adapter;

'''
'''--- dexVolumes/champagneswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");
const endpoints = {
  [BSC]: "https://api.thegraph.com/subgraphs/name/champagneswap/exchangev3",
};

const DAILY_VOLUME_FACTORY = "champagneDayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "champagneFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/cli/testAdapter.js ---
const { getCurrentBlocks } = require("@defillama/sdk/build/computeTVL/blocks");
const { volume } = require("../pancakeswap");

const test = async () => {
  const { timestamp, chainBlocks } = await getCurrentBlocks();
  console.log(chainBlocks, "chainBlocks");
  volume.bsc.fetch(timestamp).then((res) => {
    console.log(res);
  });
};

test();

'''
'''--- dexVolumes/cryptoswap/index.ts ---
const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");

import { DexVolumeAdapter } from "../dexVolume.type";

const endpoints = {
  [BSC]: "https://api.thegraph.com/subgraphs/name/cr3k/cdsexchange",
};

const DAILY_VOLUME_FACTORY = "CSTDayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "CSTFactory",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/curve/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getTimestampAtStartOfHour } from "../helper/getTimestampAtStartOfHour";

const { fetchURL } = require("../helper/utils");

const endpoints = {
  ethereum: "https://api.curve.fi/api/getAllPoolsVolume/ethereum",
};

// type better later
const graphs = (chain: any) => async () => {
  const timestamp = getTimestampAtStartOfHour();
  let res;
  switch (chain) {
    case "ethereum":
      res = await fetchURL(endpoints.ethereum);
    default:
      res = await fetchURL(endpoints.ethereum);
  }

  return {
    totalVolume: res?.data?.data?.totalVolume,
    timestamp,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    ethereum: {
      fetch: graphs("ethereum"),
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // TODO custom backfill
  },
};
export default adapter;

'''
'''--- dexVolumes/dexVolume.type.ts ---
export type ChainBlocks = {
  [x: string]: number;
};

export type FetchResult = {
  block?: number;
  dailyVolume?: string;
  totalVolume: string;
  timestamp: number;
};

export type Fetch = (
  timestamp: number,
  chainBlocks: ChainBlocks
) => Promise<FetchResult>;

export type VolumeAdapter = {
  [x: string]: {
    start: number | any;
    fetch: Fetch;
    runAtCurrTime?: boolean;
    customBackfill?: any;
  };
};

export type BreakdownAdapter = {
  [x: string]: VolumeAdapter;
};

export type DexVolumeAdapter = {
  volume: VolumeAdapter;
};

export type DexBreakdownAdapter = {
  breakdown: BreakdownAdapter;
};

export type DexAdapter = DexVolumeAdapter | DexBreakdownAdapter;

'''
'''--- dexVolumes/dodo/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { getChainVolume } = require("../helper/getUniSubgraphVolume");
const {
  ARBITRUM,
  BSC,
  ETHEREUM,
  HECO,
  OKEXCHAIN,
  POLYGON,
} = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");

const endpoints = {
  [ARBITRUM]:
    "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-arbitrum",
  [BSC]: "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-bsc",
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2",
  [HECO]: "https://n10.hg.network/subgraphs/name/dodoex-v2-heco-hg/heco",
  // [OKEXCHAIN]: "https://graph.kkt.one/subgraphs/name/dodoex/dodoex-v2-okchain",
  [POLYGON]: "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-polygon",
};

const DAILY_VOLUME_FACTORY = "dodoDayData";
const VOLUME_FIELD = "volumeUSD";

const graphs = getChainVolume({
  graphUrls: {
    [ARBITRUM]: endpoints[ARBITRUM],
    [BSC]: endpoints[BSC],
    [ETHEREUM]: endpoints[ETHEREUM],
    [HECO]: endpoints[HECO],
    // [OKEXCHAIN]: endpoints[OKEXCHAIN],
    [POLYGON]: endpoints[POLYGON],
  },
  totalVolume: {
    factory: "dodoZoos",
    field: VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: VOLUME_FIELD,
  },
});

const startTimeQuery = {
  endpoints,
  dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
  volumeField: VOLUME_FIELD,
};

const volume = Object.keys(endpoints).reduce(
  (acc, chain) => ({
    ...acc,
    [chain]: {
      fetch: graphs(chain),
      start: getStartTimestamp({ ...startTimeQuery, chain }),
    },
  }),
  {}
);

const adapter: DexVolumeAdapter = {
  volume,
};
export default adapter;

'''
'''--- dexVolumes/helper/chains.js ---
const ARBITRUM = "arbitrum";
const AVAX = "avax";
const BOBA = "boba";
const BSC = "bsc";
const CELO = "celo";
const ETHEREUM = "ethereum";
const FANTOM = "fantom";
const HARMONY = "harmony";
const HECO = "heco";
const OKEXCHAIN = "okexchain";
const OPTIMISM = "optimism";
const POLYGON = "polygon";
const RONIN = "ronin";
const XDAI = "xdai";
const AURORA = "aurora";

module.exports = {
  ARBITRUM,
  AVAX,
  BOBA,
  BSC,
  CELO,
  ETHEREUM,
  FANTOM,
  HARMONY,
  HECO,
  OKEXCHAIN,
  OPTIMISM,
  POLYGON,
  RONIN,
  XDAI,
  AURORA,
};

'''
'''--- dexVolumes/helper/getBlock.js ---
const sdk = require("@defillama/sdk");
const retry = require("async-retry");
const axios = require("axios");

async function getBlock(timestamp, chain, chainBlocks, undefinedOk = false) {
  if (
    chainBlocks?.[chain] !== undefined ||
    (process.env.HISTORICAL === undefined && undefinedOk)
  ) {
    return chainBlocks[chain];
  } else {
    if (chain === "celo") {
      return Number(
        (
          await retry(
            async (bail) =>
              await axios.get(
                "https://explorer.celo.org/api?module=block&action=getblocknobytime&timestamp=" +
                  timestamp +
                  "&closest=before"
              )
          )
        ).data.result.blockNumber
      );
    }
    return sdk.api.util
      .lookupBlock(timestamp, { chain })
      .then((blockData) => blockData.block);
  }
}

module.exports = {
  getBlock,
};

'''
'''--- dexVolumes/helper/getStartTimestamp.js ---
const { request, gql } = require("graphql-request");

const {
  DEFAULT_DAILY_VOLUME_FACTORY,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("./getUniSubgraphVolume");

const getStartTimestamp =
  ({
    endpoints,
    chain,
    dailyDataField = `${DEFAULT_DAILY_VOLUME_FACTORY}s`,
    volumeField = DEFAULT_DAILY_VOLUME_FIELD,
    dateField = "date",
    first = 1000,
  }) =>
  async () => {
    const query = gql`
        {
            ${dailyDataField}(first: ${first}) {
                ${dateField}
                ${volumeField}
            }
        }
    `;

    const result = await request(endpoints[chain], query);

    const days = result?.[dailyDataField];

    const firstValidDay = days.find((data) => data[volumeField] !== "0");

    return firstValidDay[dateField];
  };

module.exports = {
  getStartTimestamp,
};

'''
'''--- dexVolumes/helper/getTimestampAtStartOfHour.ts ---
export const getTimestampAtStartOfHour = (timestamp = Date.now() / 1000) => {
  const date = new Date(timestamp * 1000);
  var date_utc = Date.UTC(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
  var startOfDay = Number(new Date(date_utc));
  var timestamp = startOfDay / 1000;
  return Math.floor(timestamp / 3600) * 3600;
};

'''
'''--- dexVolumes/helper/getUniSubgraphVolume.js ---
const { request, gql } = require("graphql-request");
const { getBlock } = require("./getBlock");

const getUniqStartOfTodayTimestamp = (date = new Date()) => {
  var date_utc = Date.UTC(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
  var startOfDay = new Date(date_utc);
  var timestamp = startOfDay / 1000;
  return Math.floor(timestamp / 86400) * 86400;
};

// To get ID for daily data https://docs.uniswap.org/protocol/V2/reference/API/entities
const getUniswapDateId = () => getUniqStartOfTodayTimestamp() / 86400;

const DEFAULT_TOTAL_VOLUME_FACTORY = "uniswapFactories";
const DEFAULT_TOTAL_VOLUME_FIELD = "totalVolumeUSD";

const DEFAULT_DAILY_VOLUME_FACTORY = "uniswapDayData";
const DEFAULT_DAILY_VOLUME_FIELD = "dailyVolumeUSD";

function getChainVolume({
  graphUrls,
  totalVolume = {
    factory: DEFAULT_TOTAL_VOLUME_FACTORY,
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume = {
    factory: DEFAULT_DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
  customDailyVolume = undefined,
  hasDailyVolume = true,
  hasTotalVolume = true,
  getCustomBlock = undefined,
}) {
  const totalVolumeQuery = gql`
  ${totalVolume.factory}(
    block: { number: $block }
  ) {
    ${totalVolume.field}
  }
  `;

  const dailyVolumeQuery =
    customDailyVolume ||
    gql`
  ${dailyVolume.factory} (
    id: $id
  ) {
    ${dailyVolume.field}
  }
  `;

  const graphQuery = gql`
query get_volume($block: Int, $id: Int) {
  ${hasTotalVolume ? totalVolumeQuery : ""}
  ${hasDailyVolume ? dailyVolumeQuery : ""}
}
`;
  return (chain) => {
    return async (timestamp, chainBlocks) => {
      const block =
        (getCustomBlock && (await getCustomBlock(timestamp))) ||
        (await getBlock(timestamp, chain, chainBlocks));
      const id = getUniswapDateId();
      const graphRes = await request(graphUrls[chain], graphQuery, {
        block,
        id,
      });

      return {
        timestamp,
        block,
        totalVolume: graphRes[totalVolume.factory][0][totalVolume.field],
        dailyVolume: hasDailyVolume
          ? (graphRes?.[dailyVolume.factory]?.[dailyVolume.field] || "0") ??
            undefined
          : undefined,
      };
    };
  };
}

module.exports = {
  getUniqStartOfTodayTimestamp,
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FACTORY,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FACTORY,
  DEFAULT_DAILY_VOLUME_FIELD,
};

'''
'''--- dexVolumes/helper/utils.js ---
const utils = require("../../projects/helper/utils");

module.exports = utils;

'''
'''--- dexVolumes/index.ts ---
import oneInch from "./1inch";
import balancer from "./balancer";
import bancor from "./bancor";
import champagneswap from "./champagneswap";
import curve from "./curve";
import dodo from "./dodo";
import katana from "./katana";
import klayswap from "./klayswap";
import osmosis from "./osmosis";
import pancakeswap from "./pancakeswap";
import quickswap from "./quickswap";
import raydium from "./raydium";
import saros from "./saros";
import serum from "./serum";
import soulswap from "./soulswap";
import spiritswap from "./spiritswap";
import spookyswap from "./spookyswap";
import sushiswap from "./sushiswap";
import terraswap from "./terraswap";
import traderjoe from "./traderjoe";
import uniswap from "./uniswap";
import yieldfields from "./yieldfields";

export default {
  "1inch": oneInch,
  balancer,
  bancor,
  champagneswap,
  curve,
  dodo,
  katana,
  klayswap,
  osmosis,
  pancakeswap,
  quickswap,
  raydium,
  saros,
  serum,
  soulswap,
  spiritswap,
  spookyswap,
  sushiswap,
  terraswap,
  traderjoe,
  uniswap,
  yieldfields,
};

'''
'''--- dexVolumes/katana/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { request, gql } = require("graphql-request");
const { RONIN } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");
const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");

const endpoints = {
  [RONIN]:
    "https://thegraph.roninchain.com/subgraphs/name/axieinfinity/katana-subgraph-green",
};

const blocksGraph =
  "https://thegraph.roninchain.com/subgraphs/name/axieinfinity/ronin-blocks";

const blockQuery = gql`
  query blocks($timestampFrom: Int!, $timestampTo: Int!) {
    blocks(
      first: 1
      orderBy: timestamp
      orderDirection: asc
      where: { timestamp_gt: $timestampFrom, timestamp_lt: $timestampTo }
    ) {
      id
      number
      timestamp
      __typename
    }
  }
`;

const getCustomBlock = async (timestamp: number) => {
  const block = Number(
    (
      await request(blocksGraph, blockQuery, {
        timestampFrom: timestamp - 30,
        timestampTo: timestamp + 30,
      })
    ).blocks[0].number
  );

  return block;
};

const DAILY_VOLUME_FACTORY = "katanaDayData";

const graphs = getChainVolume({
  graphUrls: {
    [RONIN]: endpoints[RONIN],
  },
  totalVolume: {
    factory: "katanaFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
  getCustomBlock,
});

const adapter: DexVolumeAdapter = {
  volume: {
    [RONIN]: {
      fetch: graphs(RONIN),
      start: getStartTimestamp({
        endpoints,
        chain: RONIN,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/klayswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getTimestampAtStartOfHour } from "../helper/getTimestampAtStartOfHour";

const BigNumber = require("bignumber.js");
const { fetchURL } = require("../helper/utils");

const historicalVolumeEndpoint =
  "https://s.klayswap.com/stat/klayswapInfo.json";

const fetch = async () => {
  const timestamp = getTimestampAtStartOfHour();
  const historicalVolume = (await fetchURL(historicalVolumeEndpoint))?.data
    .dayVolume;

  const totalVolume = historicalVolume
    .reduce(
      (acc: typeof BigNumber, { amount }: { amount: string | number }) =>
        acc.plus(amount),
      new BigNumber(0)
    )
    .toString();

  return {
    timestamp,
    totalVolume,
    dailyVolume: historicalVolume[historicalVolume.length - 1].amount,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    klatyn: {
      fetch,
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // TODO custom backfill
  },
};

export default adapter;

'''
'''--- dexVolumes/koyo/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { AURORA, BOBA } from "../helper/chains";
import { getChainVolume } from "../helper/getUniSubgraphVolume";

const endpoints = {
  [BOBA]:
    "https://thegraph.com/hosted-service/subgraph/koyo-finance/exchange-subgraph-boba",
  [AURORA]:
    "https://thegraph.com/hosted-service/subgraph/koyo-finance/exchange-subgraph-aurora",
};

const graphs = getChainVolume({
  graphUrls: endpoints,
  totalVolume: {
    factory: "koyos",
    field: "totalSwapVolume",
  },
  hasDailyVolume: false,
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BOBA]: {
      fetch: graphs(BOBA),
      start: 1655104044,
      customBackfill: () => {},
    },
    [AURORA]: {
      fetch: graphs(AURORA),
      start: 1657617165,
      customBackfill: () => {},
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/osmosis/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getTimestampAtStartOfHour } from "../helper/getTimestampAtStartOfHour";

const BigNumber = require("bignumber.js");
const { fetchURL } = require("../helper/utils");

const historicalVolumeEndpoint =
  "https://api-osmosis.imperator.co/volume/v1/historical/chart";
const dailyVolumeEndpoint = "https://api-osmosis.imperator.co/volume/v1/actual";

const graphs = async () => {
  const timestamp = getTimestampAtStartOfHour();
  const historicalVolume = (await fetchURL(historicalVolumeEndpoint))?.data;
  const dailyVolume = (await fetchURL(dailyVolumeEndpoint))?.data.value;

  const totalVolume = historicalVolume
    .reduce(
      (acc: typeof BigNumber, { value }: { value: string | number }) =>
        acc.plus(value),
      new BigNumber(0)
    )
    .plus(dailyVolume)
    .toString();

  return {
    totalVolume,
    dailyVolume,
    timestamp,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    cosmos: {
      fetch: graphs,
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // TODO custom backfill
  },
};

export default adapter;

'''
'''--- dexVolumes/pancakeswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");
const endpoints = {
  [BSC]: "https://bsc.streamingfast.io/subgraphs/name/pancakeswap/exchange-v2",
};

const DAILY_VOLUME_FACTORY = "pancakeDayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "pancakeFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/quickswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { getChainVolume } = require("../helper/getUniSubgraphVolume");

const endpoints = {
  polygon: "https://api.thegraph.com/subgraphs/name/sameepsi/quickswap05",
};

const graphs = getChainVolume({
  graphUrls: {
    polygon: endpoints.polygon,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    polygon: {
      fetch: graphs("polygon"),
      start: 1602115200,
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/raydium/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { fetchURL } = require("../helper/utils");

const endpoints = {
  solana: "https://api.raydium.io/info",
};

const graphs = (chain: string) => async () => {
  let res;
  switch (chain) {
    case "solana":
      res = await fetchURL(endpoints.solana);
    default:
      res = await fetchURL(endpoints.solana);
  }

  return {
    totalVolume: res?.data?.totalvolume,
    timestamp: 1, // fix
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    solana: {
      fetch: graphs("solana"),
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // TODO custom backfill
  },
};

export default adapter;

/*
    backfill steps

    1. https://api.raydium.io/pairs
    call all pairs

    2. for each pair use amm_id

    3. query rayqlbeta2.aleph.cloud for each pair and sum for respective dates

    {
    pool_hourly_data(address: "GaqgfieVmnmY4ZsZHHA6L5RSVzCGL3sKx4UgHBaYNy8m", skip: 10) {
        volume_usd
        time
    }
    }
*/

'''
'''--- dexVolumes/saros/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { fetchURL } = require("../helper/utils");

const endpoints = {
  solana: "https://api.saros.finance/info",
};

const graphs = (chain: string) => async () => {
  let res;
  switch (chain) {
    case "solana":
      res = await fetchURL(endpoints.solana);
    default:
      res = await fetchURL(endpoints.solana);
  }

  return {
    timestamp: 1, // fix
    dailyVolume: res.data.volume24h,
    totalVolume: res.data.totalvolume,
  };
};

// @TODO check and backfill
const adapter: DexVolumeAdapter = {
  volume: {
    solana: {
      fetch: graphs("solana"),
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
  },
};
export default adapter;

'''
'''--- dexVolumes/serum/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { GraphQLClient, gql } = require("graphql-request");

const endpoint = "https://api.vybenetwork.com/v1/graphql";

const query = gql`
  query MyQuery {
    api_serum_dex_m {
      globalVolumeStats {
        t
        v
      }
    }
  }
`;

const graphQLClient = new GraphQLClient(endpoint, {
  headers: {
    authorization: process.env.PROD_VYBE_API_KEY,
  },
});

const fetch = async () => {
  const data = await graphQLClient.request(query);

  const volumes = data.api_serum_dex_m.globalVolumeStats.v;

  const dailyVolume: string = volumes[volumes.length - 1];

  return {
    totalVolume: "0",
    dailyVolume,
    timestamp: 1,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    solana: {
      fetch,
      start: 0,
      runAtCurrTime: true,
      customBackfill: () => {},
    },
  },
};

export default adapter;

// Todo Total volume and backfill

'''
'''--- dexVolumes/smbswap/index.ts ---
const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");

import { DexVolumeAdapter } from "../dexVolume.type";

const endpoints = {
  [BSC]: "https://api.thegraph.com/subgraphs/name/cr3k/exchange",
};

const DAILY_VOLUME_FACTORY = "SMBDayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "SMBFactory",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/soulswap/index.ts ---
import { getChainVolume } from "../helper/getUniSubgraphVolume";
import { getStartTimestamp } from "../helper/getStartTimestamp";
import { FANTOM } from "../helper/chains";
import { DexVolumeAdapter } from "../dexVolume.type";

const endpoints = {
// [AVAX]: "https://api.thegraph.com/subgraphs/name/soulswapfinance/avalanche-exchange
  [FANTOM]: "https://api.thegraph.com/subgraphs/name/soulswapfinance/fantom-exchange",
};

const VOLUME_FIELD = "volumeUSD";

const graphs = getChainVolume({
  graphUrls: {
    // [AVAX]: endpoints[AVAX],
    [FANTOM]: endpoints[FANTOM]
  },
  totalVolume: {
    factory: "factories",
    field: VOLUME_FIELD,
  },
  dailyVolume: {
    factory: "dayData",
    field: VOLUME_FIELD,
  },
});

const startTimeQuery = {
  endpoints,
  dailyDataField: "dayDatas",
  volumeField: VOLUME_FIELD,
};

const volume = Object.keys(endpoints).reduce(
  (acc, chain) => ({
    ...acc,
    [chain]: {
      fetch: graphs(chain),
      start: getStartTimestamp({ ...startTimeQuery, chain }),
    },
  }),
  {}
);

const adapter: DexVolumeAdapter = {
  volume,
};

export default adapter;

'''
'''--- dexVolumes/spiritswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");

const endpoints = {
  fantom:
    "https://api.thegraph.com/subgraphs/name/layer3org/spiritswap-analytics",
};

const graphs = getChainVolume({
  graphUrls: {
    fantom: endpoints.fantom,
  },
  totalVolume: {
    factory: "spiritswapFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: "spiritswapDayData",
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    fantom: {
      fetch: graphs("fantom"),
      start: 1620864000,
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/spookyswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { getChainVolume } = require("../helper/getUniSubgraphVolume");
const { FANTOM } = require("../helper/chains");
const endpoints = {
  [FANTOM]: "https://api.thegraph.com/subgraphs/name/eerieeight/spookyswap",
};

const graphs = getChainVolume({
  graphUrls: {
    [FANTOM]: endpoints[FANTOM],
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [FANTOM]: {
      fetch: graphs(FANTOM),
      start: 1618617600,
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/sushiswap/index.ts ---
import { getChainVolume } from "../helper/getUniSubgraphVolume";
import { getStartTimestamp } from "../helper/getStartTimestamp";
import {
  ARBITRUM,
  AVAX,
  BSC,
  CELO,
  ETHEREUM,
  FANTOM,
  HARMONY,
  HECO,
  POLYGON,
  XDAI,
} from "../helper/chains";
import { DexVolumeAdapter } from "../dexVolume.type";

const endpoints = {
  [ARBITRUM]:
    "https://api.thegraph.com/subgraphs/name/sushiswap/arbitrum-exchange",
  [AVAX]:
    "https://api.thegraph.com/subgraphs/name/sushiswap/avalanche-exchange",
  [BSC]: "https://api.thegraph.com/subgraphs/name/sushiswap/bsc-exchange",
  // [CELO]: "https://api.thegraph.com/subgraphs/name/sushiswap/celo-exchange",
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/sushiswap/exchange",
  [FANTOM]: "https://api.thegraph.com/subgraphs/name/sushiswap/fantom-exchange",
  [HARMONY]:
    "https://sushi.graph.t.hmny.io/subgraphs/name/sushiswap/harmony-exchange",
  // [HECO]: "https://q.hg.network/subgraphs/name/heco-exchange/heco",
  //'okexchain': 'https://q.hg.network/subgraphs/name/okex-exchange/oec',
  //'okexchain': 'https://q.hg.network/subgraphs/name/sushiswap/okex-exchange',
  [POLYGON]: "https://api.thegraph.com/subgraphs/name/sushiswap/matic-exchange",
  [XDAI]: "https://api.thegraph.com/subgraphs/name/sushiswap/xdai-exchange",
};

const VOLUME_FIELD = "volumeUSD";

const graphs = getChainVolume({
  graphUrls: {
    [ARBITRUM]: endpoints[ARBITRUM],
    [AVAX]: endpoints[AVAX],
    [BSC]: endpoints[BSC],
    // [CELO]: endpoints[CELO],
    [ETHEREUM]: endpoints[ETHEREUM],
    [FANTOM]: endpoints[FANTOM],
    [HARMONY]: endpoints[HARMONY],
    // [HECO]: endpoints[HECO],
    [POLYGON]: endpoints[POLYGON],
    [XDAI]: endpoints[XDAI],
  },
  totalVolume: {
    factory: "factories",
    field: VOLUME_FIELD,
  },
  dailyVolume: {
    factory: "dayData",
    field: VOLUME_FIELD,
  },
});

const startTimeQuery = {
  endpoints,
  dailyDataField: "dayDatas",
  volumeField: VOLUME_FIELD,
};

const volume = Object.keys(endpoints).reduce(
  (acc, chain) => ({
    ...acc,
    [chain]: {
      fetch: graphs(chain),
      start: getStartTimestamp({ ...startTimeQuery, chain }),
    },
  }),
  {}
);

const adapter: DexVolumeAdapter = {
  volume,
};

export default adapter;

'''
'''--- dexVolumes/terraswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";
import { getTimestampAtStartOfHour } from "../helper/getTimestampAtStartOfHour";

const { request, gql } = require("graphql-request");
const BigNumber = require("bignumber.js");
const {
  getUniqStartOfTodayTimestamp,
} = require("../helper/getUniSubgraphVolume");

const endpoints = {
  terra: "https://terraswap-graph.terra.dev/graphql",
};

const historicalData = gql`
  query get_volume($from: Float!, $to: Float!) {
    terraswap {
      historicalData(from: $from, to: $to) {
        volumeUST
      }
    }
  }
`;

const fetch = async () => {
  const timestamp = getTimestampAtStartOfHour();
  const todayUnix = getUniqStartOfTodayTimestamp();
  const dailyVolumeRequest = await request(endpoints.terra, historicalData, {
    from: todayUnix,
    to: Math.floor(Date.now() / 1000),
  });

  const totalVolumeRequests = [];
  const days500 = 500 * 86400;

  for (let i = 1605254400; i < todayUnix; i += days500) {
    let to = i + days500 > todayUnix ? todayUnix : i + days500;
    totalVolumeRequests.push(
      request(endpoints.terra, historicalData, {
        from: i,
        to,
      })
    );
  }

  // fix types when redo adapter
  const allVolume = (await Promise.all(totalVolumeRequests)).reduce(
    (acc: any, graphRes) =>
      graphRes?.terraswap?.historicalData
        ?.reduce(
          (acc: any, { volumeUST }: any) => new BigNumber(volumeUST).plus(acc),
          new BigNumber(0)
        )
        .plus(acc),
    new BigNumber(0)
  );

  return {
    totalVolume: allVolume.toString(),
    dailyVolume: dailyVolumeRequest?.terraswap?.historicalData?.[0]?.volumeUST,
    timestamp,
  };
};

const adapter: DexVolumeAdapter = {
  volume: {
    terra: {
      fetch,
      runAtCurrTime: true,
      customBackfill: () => {},
      start: 0,
    },
    // TODO custom backfill
  },
};

export default adapter;

'''
'''--- dexVolumes/traderjoe/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const { getChainVolume } = require("../helper/getUniSubgraphVolume");

const endpoints = {
  avax: "https://api.thegraph.com/subgraphs/name/traderjoe-xyz/exchange",
};

const graphs = getChainVolume({
  graphUrls: {
    avax: endpoints.avax,
  },
  totalVolume: {
    factory: "factories",
    field: "volumeUSD",
  },
  dailyVolume: {
    factory: "dayData",
    field: "volumeUSD",
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    avax: {
      fetch: graphs("avax"),
      start: 1628467200,
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/uniswap/index.ts ---
import { DexBreakdownAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_DAILY_VOLUME_FACTORY,
  DEFAULT_TOTAL_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");

const { ARBITRUM, ETHEREUM, OPTIMISM, POLYGON } = require("../helper/chains");

const { getStartTimestamp } = require("../helper/getStartTimestamp");

const v1Endpoints = {
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap",
};

const v2Endpoints = {
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswapv2",
};

const v3Endpoints = {
  [ETHEREUM]: "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3",
  [OPTIMISM]:
    "https://api.thegraph.com/subgraphs/name/ianlapham/optimism-post-regenesis",
  [ARBITRUM]:
    "https://api.thegraph.com/subgraphs/name/ianlapham/arbitrum-dev",
  [POLYGON]:
    "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v3-polygon",
};

const VOLUME_USD = "volumeUSD";

const v1Graph = getChainVolume({
  graphUrls: {
    [ETHEREUM]: v1Endpoints[ETHEREUM],
  },
  totalVolume: {
    factory: "uniswaps",
    field: "totalVolumeUSD",
  },
  dailyVolume: {
    factory: DEFAULT_DAILY_VOLUME_FACTORY,
    field: "dailyVolumeInUSD",
  },
});

const v2Graph = getChainVolume({
  graphUrls: {
    [ETHEREUM]: v2Endpoints[ETHEREUM],
  },
});

const v3Graphs = getChainVolume({
  graphUrls: {
    ...v3Endpoints,
  },
  totalVolume: {
    factory: "factories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DEFAULT_DAILY_VOLUME_FACTORY,
    field: VOLUME_USD,
  },
});

const adapter: DexBreakdownAdapter = {
  breakdown: {
    v1: {
      [ETHEREUM]: {
        fetch: v1Graph(ETHEREUM),
        start: 1541203200,
      },
    },
    v2: {
      [ETHEREUM]: {
        fetch: v2Graph(ETHEREUM),
        start: getStartTimestamp({
          endpoints: v2Endpoints,
          chain: ETHEREUM,
        }),
      },
    },
    v3: {
      [ETHEREUM]: {
        fetch: v3Graphs(ETHEREUM),
        start: getStartTimestamp({
          endpoints: v3Endpoints,
          chain: ETHEREUM,
          volumeField: VOLUME_USD,
        }),
      },
      [ARBITRUM]: {
        fetch: v3Graphs(ARBITRUM),
        start: getStartTimestamp({
          endpoints: v3Endpoints,
          chain: ARBITRUM,
          volumeField: VOLUME_USD,
        }),
      },
      [POLYGON]: {
        fetch: v3Graphs(POLYGON),
        start: getStartTimestamp({
          endpoints: v3Endpoints,
          chain: POLYGON,
          volumeField: VOLUME_USD,
        }),
      },
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/whaleswap/index.ts ---
import { DexVolumeAdapter } from "../dexVolume.type";

const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");
const endpoints = {
  [BSC]: "https://api.thegraph.com/subgraphs/name/whale-swap/exchange",
};

const DAILY_VOLUME_FACTORY = "dayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "whaleswapFactories",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- dexVolumes/yieldfields/index.ts ---
const {
  getChainVolume,
  DEFAULT_TOTAL_VOLUME_FIELD,
  DEFAULT_DAILY_VOLUME_FIELD,
} = require("../helper/getUniSubgraphVolume");
const { BSC } = require("../helper/chains");
const { getStartTimestamp } = require("../helper/getStartTimestamp");

import { DexVolumeAdapter } from "../dexVolume.type";

const endpoints = {
  [BSC]: "https://api.thegraph.com/subgraphs/name/sotblad/yieldfieldsexchange",
};

const DAILY_VOLUME_FACTORY = "YieldFieldsDayData";

const graphs = getChainVolume({
  graphUrls: {
    [BSC]: endpoints[BSC],
  },
  totalVolume: {
    factory: "YieldFieldsFactory",
    field: DEFAULT_TOTAL_VOLUME_FIELD,
  },
  dailyVolume: {
    factory: DAILY_VOLUME_FACTORY,
    field: DEFAULT_DAILY_VOLUME_FIELD,
  },
});

const adapter: DexVolumeAdapter = {
  volume: {
    [BSC]: {
      fetch: graphs(BSC),
      start: getStartTimestamp({
        endpoints,
        chain: BSC,
        dailyDataField: `${DAILY_VOLUME_FACTORY}s`,
      }),
    },
  },
};

export default adapter;

'''
'''--- liquidations/aave-v2/index.ts ---
import { gql, request } from "graphql-request"
import { getPagedGql } from "../utils/gql"

const query = gql`
query users($lastId: String) {
    users(first: 1000, where:{
        borrowedReservesCount_gt: 0,
        id_gt: $lastId
      }) {
        id
        reserves{
          usageAsCollateralEnabledOnUser
          reserve{
            symbol
            usageAsCollateralEnabled
            underlyingAsset
            price {
                priceInEth
            }
            decimals
            reserveLiquidationThreshold
          }
          currentATokenBalance
          currentTotalDebt
        }
    }
    _meta{
        block {
            number
        }
    }
}
`

const ethPriceQuery = gql`
{
    priceOracleAsset(id: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"){
        priceInEth
    }
}
`

const subgraphUrl = "https://api.thegraph.com/subgraphs/name/aave/protocol-v2"

const liqs = async () => {
    const users = await getPagedGql(subgraphUrl, query, "users")
    const ethPrice = 1 / ((await request(subgraphUrl, ethPriceQuery)).priceOracleAsset.priceInEth / 1e18)
    const positions = users.map(user => {
        let totalDebt = 0, totalCollateral = 0;
        const debts = (user.reserves as any[]).map(reserve => {
            const decimals = 10 ** reserve.reserve.decimals
            const price = (Number(reserve.reserve.price.priceInEth) / (1e18)) * ethPrice
            const liqThreshold = Number(reserve.reserve.reserveLiquidationThreshold) / 1e4 // belongs to [0, 1]
            let debt = Number(reserve.currentTotalDebt)
            if (reserve.usageAsCollateralEnabledOnUser === true) {
                debt -= Number(reserve.currentATokenBalance) * liqThreshold
            }
            debt *= price / decimals
            if (debt > 0) {
                totalDebt += debt
            } else {
                totalCollateral -= debt
            }
            return {
                debt,
                price,
                token: reserve.reserve.underlyingAsset,
                totalBal: reserve.currentATokenBalance,
                decimals
            }
        })

        const liquidablePositions = debts.filter(({ debt }) => debt < 0).map(pos => {
            const usdPosNetCollateral = -pos.debt;
            const otherCollateral = totalCollateral - usdPosNetCollateral;
            const diffDebt = totalDebt - otherCollateral
            if (diffDebt > 0) {
                const amountCollateral = usdPosNetCollateral / pos.price // accounts for liqThreshold
                const liqPrice = diffDebt / amountCollateral;
                // if liqPrice > pos.price -> bad debt
                return {
                    owner: user.id,
                    liqPrice,
                    collateral: "ethereum:" + pos.token,
                    collateralAmount: pos.totalBal,
                }
            }
        }).filter(t => t !== undefined)

        return liquidablePositions
    }).flat()
    return positions
}

module.exports = {
    ethereum: {
        liquidations: liqs
    }
}
'''
'''--- liquidations/maker/index.ts ---
import { gql } from "graphql-request"
import { getPagedGql } from "../utils/gql"
import { ethers } from "ethers";
import { providers } from "../utils/ethers"
import BigNumber from "bignumber.js";

const cdpQuery = gql`
query cdps($lastId: String) {
    vaults(where:{
        debt_gt: 0,
        id_gt: $lastId
    }, first:1000){
      id
      collateral
      collateralType{
        liquidationRatio
        rate
        id
        price{
            spotPrice
        }
      }
      debt
      owner{
        address
      }
    }
}
`

function toHex(str:string){
    return encodeURIComponent(str)
    .split('').map(function(v){
      return v.charCodeAt(0).toString(16)
    }).join('')
}

const liqs = async () => {
    const cdps = await getPagedGql("https://api.thegraph.com/subgraphs/name/protofire/maker-protocol", cdpQuery, "vaults")
    // all maker contracts: https://chainlog.makerdao.com/api/mainnet/active.json
    const ilkRegistry = new ethers.Contract("0x5a464C28D19848f44199D003BeF5ecc87d090F87", [
        "function gem(bytes32) view returns (address)"
    ], providers.ethereum)
    let ilks = new Set<string>()
    cdps.map(cdp=>ilks.add(cdp.collateralType.id))
    const gems = {} as {[ilk:string]:{
        address:string,
        decimals:number,
    }};
    await Promise.all(Array.from(ilks).map(async ilk=>{
        const hex = "0x"+toHex(ilk).padEnd(64, "0")
        const gem = await ilkRegistry.gem(hex)
        const gemContract = new ethers.Contract(gem, [
            "function decimals() view returns (uint8)"
        ], providers.ethereum)
        const decimals = await gemContract.decimals()
        gems[ilk] = {
            address:gem,
            decimals
        }
    }))
    return cdps.map(cdp=>{
        const gem = gems[cdp.collateralType.id]
        console.log(cdp)
        return {
            owner: cdp.owner.address,
            liqPrice: (cdp.debt * cdp.collateralType.liquidationRatio) / cdp.collateral,
            collateral: "ethereum:"+gem.address,
            collateralAmount: new BigNumber(cdp.collateral).times(10**gem.decimals).toFixed(0),
        }
    })
}

module.exports = {
    ethereum: {
        liquidations: liqs
    }
}
'''
'''--- liquidations/test.ts ---
import path from "path";
import axios from "axios";
import { ethers } from "ethers";
import { providers } from "./utils/ethers"
import {
    humanizeNumber,
  } from "@defillama/sdk/build/computeTVL/humanizeNumber";

const TOTAL_BINS = 20;

interface Liq {
    owner: string,
    liqPrice: number,
    collateral: string,
    collateralAmount: string,
}

interface Bins {
    [token:string]:{
        bins:{
            [bin:number]:number
        },
        binSize: number,
        price: number,
    }
}

const f2 = (n:number) => Number(n.toFixed(2))

async function binResults(liqs:Liq[]){
    const tokens = new Set<string>()
    liqs.map(liq=>tokens.add(liq.collateral))
    const prices = (await axios.post("https://coins.llama.fi/prices", {
        "coins": Array.from(tokens)
    })).data.coins as {
        [address:string]: { decimals: number, price: number, symbol: string, timestamp: number }
    }
    const bins = Object.values(prices).reduce((all, token)=>({
        ...all,
        [token!.symbol]:{
            bins: {},
            binSize: token.price/TOTAL_BINS,
            price: token.price,
        }
    }), {} as Bins)
    const skippedTokens = new Set<string>()
    liqs.map(liq=>{
        const tokenAddress = liq.collateral.toLowerCase()
        const token = prices[tokenAddress]
        if(token === undefined){
            skippedTokens.add(tokenAddress)
            return
        }
        const binSize = bins[token.symbol].binSize;
        const bin = Math.floor(liq.liqPrice/binSize)
        if(bins[token.symbol].bins[bin] === undefined){
            bins[token.symbol].bins[bin] = 0
        }
        bins[token.symbol].bins[bin] += Number(liq.collateralAmount)/(10**token.decimals)
    })
    let sumLiquidable = 0
    const liquidableTable = [] as any[]
    Object.entries(bins).map(([symbol, tokenLiqs])=>{
        console.log(`${symbol} (current price: ${tokenLiqs.price})`)
        const max = Object.values(tokenLiqs.bins).reduce((max, bin)=>Math.max(max, bin), 0);
        for(let i=0; i<TOTAL_BINS; i++){
            const amountInBin = tokenLiqs.bins[i] ?? 0;
            const range = (n:number) => (tokenLiqs.binSize*n).toFixed(2)
            console.log(`${"#".repeat((amountInBin/max)*10).padEnd(10)} = ${range(i)}-${range(i+1)} = ${amountInBin.toFixed(2)}`)
        }
        let sumInside = 0;
        let sumOutside = 0;
        Object.entries(tokenLiqs.bins).map(([i, amount])=>{
            if(Number(i)<TOTAL_BINS){
                sumInside += amount;
            } else {
                sumOutside += amount;
            }
        })
        if(sumOutside > 0){
            const percentLiquidable = 100*sumOutside/(sumInside+sumOutside)
            const liquidable = tokenLiqs.price*sumOutside
            sumLiquidable += liquidable
            liquidableTable.push({
                symbol,
                percentLiquidable: f2(percentLiquidable),
                totalLiquidableTokens: f2(sumOutside),
                totalLiquidableUSD: liquidable
            })
        }
        console.log("")
    })
    const skippedTable = await Promise.all(Array.from(skippedTokens).map(async tokenAddress=>{
        const [chain, address] = tokenAddress.split(":")
        const tokenContract = new ethers.Contract(address, [
            "function symbol() view returns (string)"
        ], providers[chain])
        let symbol:string;
        try{
            symbol = await tokenContract.symbol();
        }catch(e){
            symbol = "UNKNOWN"
        }
        return {
            symbol,
            address: tokenAddress
        }
    }))
    if(skippedTable.length > 0){
        console.log(`The following tokens couldn't be priced and have been skipped:`)
        console.table(skippedTable)
    }
    if(sumLiquidable > 0){
        console.log("\nLiquidable positions:")
        console.table(liquidableTable
            .sort((a,b)=>b.totalLiquidableUSD - a.totalLiquidableUSD)
            .concat([{
                symbol: "Total",
                percentLiquidable: "-",
                totalLiquidableTokens: "-",
                totalLiquidableUSD: sumLiquidable
            }])
            .map(o=>({
            ...o,
            totalLiquidableUSD: humanizeNumber(o.totalLiquidableUSD)
        })))
        console.log("If this number is high double check your data!")
    }
    console.log(liqs)
}

async function main(){
    const passedFile = path.resolve(process.cwd(), process.argv[2]);
    let module = {} as any;
    try {
        module = require(passedFile)
      } catch(e) {
        console.log(e)
      }
    const liqs = await module.ethereum.liquidations();
    await binResults(liqs)
    //console.log(liqs)
    console.log(`\nSize of all liquidation data: ${JSON.stringify(liqs).length/10**6} MB`)
    process.exit(0)
}
main()
'''
'''--- liquidations/utils/ethers.ts ---
import {providers} from "@defillama/sdk/build/general"

export {
  providers
};
'''
'''--- liquidations/utils/gql.ts ---
import { request } from "graphql-request"

export async function getPagedGql(url:string, query:string, itemName:string){
    let lastId = "";
    let all = [] as any[]
    let page;
    do {
        page = (await request(url, query, {
            lastId
        }))[itemName]
        all = all.concat(page)
        lastId = page[page.length - 1]?.id
    } while (page.length === 1e3);
    return all
}
'''
'''--- package-lock.json ---
{
  "name": "defillama-adapters",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "defillama-adapters",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@defillama/sdk": "^2.3.66",
        "@project-serum/anchor": "^0.18.2",
        "@solana/spl-token": "^0.2.0",
        "@solana/web3.js": "^1.36.0",
        "@supercharge/promise-pool": "^2.1.0",
        "async": "^3.2.3",
        "async-retry": "^1.3.1",
        "axios": "^0.26.0",
        "bignumber.js": "^9.0.1",
        "blakejs": "^1.2.1",
        "borsh": "^0.7.0",
        "curve25519-js": "^0.0.4",
        "dotenv": "^8.6.0",
        "ethers": "^5.6.5",
        "graphql": "^15.5.0",
        "graphql-request": "^3.6.1",
        "hi-base32": "^0.5.1",
        "js-sha512": "^0.8.0",
        "limiter": "2.1.0",
        "miscreant": "^0.3.2",
        "tron-format-address": "^0.1.8"
      },
      "devDependencies": {
        "ts-node": "^10.8.1"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.18.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.18.6.tgz",
      "integrity": "sha512-t9wi7/AW6XtKahAe20Yw0/mMljKq0B1r2fPdvaAdV/KPDZewFXdaaa6K7lxmZBZ8FBNpCiAT6iHPmd6QO9bKfQ==",
      "dependencies": {
        "regenerator-runtime": "^0.13.4"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@defillama/sdk": {
      "version": "2.3.80",
      "resolved": "https://registry.npmjs.org/@defillama/sdk/-/sdk-2.3.80.tgz",
      "integrity": "sha512-zbSW430yp9rdTUVNiPhf1KHipJkdZe0ZTn1M7F/oRk6VS5h3LcuTQ/LrvAdgf5rlupWP+X0CrSo6ONN/Om+rQg==",
      "dependencies": {
        "@supercharge/promise-pool": "^2.1.0",
        "ethers": "^5.4.5",
        "graphql": "^15.5.0",
        "graphql-request": "^3.4.0",
        "lodash": "^4.17.21",
        "node-fetch": "^2.6.1"
      },
      "bin": {
        "sdk": "build/cli.js"
      }
    },
    "node_modules/@ethersproject/abi": {
      "version": "5.6.4",
      "resolved": "https://registry.npmjs.org/@ethersproject/abi/-/abi-5.6.4.tgz",
      "integrity": "sha512-TTeZUlCeIHG6527/2goZA6gW5F8Emoc7MrZDC7hhP84aRGvW3TEdTnZR08Ls88YXM1m2SuK42Osw/jSi3uO8gg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/abstract-provider": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-provider/-/abstract-provider-5.6.1.tgz",
      "integrity": "sha512-BxlIgogYJtp1FS8Muvj8YfdClk3unZH0vRMVX791Z9INBNT/kuACZ9GzaY1Y4yFq+YSy6/w4gzj3HCRKrK9hsQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/networks": "^5.6.3",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/web": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/abstract-signer": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-signer/-/abstract-signer-5.6.2.tgz",
      "integrity": "sha512-n1r6lttFBG0t2vNiI3HoWaS/KdOt8xyDjzlP2cuevlWLG6EX0OwcKLyG/Kp/cuwNxdy/ous+R/DEMdTUwWQIjQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/address": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/address/-/address-5.6.1.tgz",
      "integrity": "sha512-uOgF0kS5MJv9ZvCz7x6T2EXJSzotiybApn4XlOgoTX0xdtyVIJ7pF+6cGPxiEq/dpBiTfMiw7Yc81JcwhSYA0Q==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/rlp": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/base64": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/base64/-/base64-5.6.1.tgz",
      "integrity": "sha512-qB76rjop6a0RIYYMiB4Eh/8n+Hxu2NIZm8S/Q7kNo5pmZfXhHGHmS4MinUainiBC54SCyRnwzL+KZjj8zbsSsw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/basex": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/basex/-/basex-5.6.1.tgz",
      "integrity": "sha512-a52MkVz4vuBXR06nvflPMotld1FJWSj2QT0985v7P/emPZO00PucFAkbcmq2vpVU7Ts7umKiSI6SppiLykVWsA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/properties": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/bignumber": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/bignumber/-/bignumber-5.6.2.tgz",
      "integrity": "sha512-v7+EEUbhGqT3XJ9LMPsKvXYHFc8eHxTowFCG/HgJErmq4XHJ2WR7aeyICg3uTOAQ7Icn0GFHAohXEhxQHq4Ubw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "bn.js": "^5.2.1"
      }
    },
    "node_modules/@ethersproject/bytes": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/bytes/-/bytes-5.6.1.tgz",
      "integrity": "sha512-NwQt7cKn5+ZE4uDn+X5RAXLp46E1chXoaMmrxAyA0rblpxz8t58lVkrHXoRIn0lz1joQElQ8410GqhTqMOwc6g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/constants": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/constants/-/constants-5.6.1.tgz",
      "integrity": "sha512-QSq9WVnZbxXYFftrjSjZDUshp6/eKp6qrtdBtUCm0QxCV5z1fG/w3kdlcsjMCQuQHUnAclKoK7XpXMezhRDOLg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.6.2"
      }
    },
    "node_modules/@ethersproject/contracts": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/contracts/-/contracts-5.6.2.tgz",
      "integrity": "sha512-hguUA57BIKi6WY0kHvZp6PwPlWF87MCeB4B7Z7AbUpTxfFXFdn/3b0GmjZPagIHS+3yhcBJDnuEfU4Xz+Ks/8g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abi": "^5.6.3",
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/transactions": "^5.6.2"
      }
    },
    "node_modules/@ethersproject/hash": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/hash/-/hash-5.6.1.tgz",
      "integrity": "sha512-L1xAHurbaxG8VVul4ankNX5HgQ8PNCTrnVXEiFnE9xoRnaUcgfD12tZINtDinSllxPLCtGwguQxJ5E6keE84pA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/hdnode": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/hdnode/-/hdnode-5.6.2.tgz",
      "integrity": "sha512-tERxW8Ccf9CxW2db3WsN01Qao3wFeRsfYY9TCuhmG0xNpl2IO8wgXU3HtWIZ49gUWPggRy4Yg5axU0ACaEKf1Q==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/basex": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/pbkdf2": "^5.6.1",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/wordlists": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/json-wallets": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/json-wallets/-/json-wallets-5.6.1.tgz",
      "integrity": "sha512-KfyJ6Zwz3kGeX25nLihPwZYlDqamO6pfGKNnVMWWfEVVp42lTfCZVXXy5Ie8IZTN0HKwAngpIPi7gk4IJzgmqQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hdnode": "^5.6.2",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/pbkdf2": "^5.6.1",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "aes-js": "3.0.0",
        "scrypt-js": "3.0.1"
      }
    },
    "node_modules/@ethersproject/keccak256": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/keccak256/-/keccak256-5.6.1.tgz",
      "integrity": "sha512-bB7DQHCTRDooZZdL3lk9wpL0+XuG3XLGHLh3cePnybsO3V0rdCAOQGpn/0R3aODmnTOOkCATJiD2hnL+5bwthA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "js-sha3": "0.8.0"
      }
    },
    "node_modules/@ethersproject/logger": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/logger/-/logger-5.6.0.tgz",
      "integrity": "sha512-BiBWllUROH9w+P21RzoxJKzqoqpkyM1pRnEKG69bulE9TSQD8SAIvTQqIMZmmCO8pUNkgLP1wndX1gKghSpBmg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ]
    },
    "node_modules/@ethersproject/networks": {
      "version": "5.6.4",
      "resolved": "https://registry.npmjs.org/@ethersproject/networks/-/networks-5.6.4.tgz",
      "integrity": "sha512-KShHeHPahHI2UlWdtDMn2lJETcbtaJge4k7XSjDR9h79QTd6yQJmv6Cp2ZA4JdqWnhszAOLSuJEd9C0PRw7hSQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/pbkdf2": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/pbkdf2/-/pbkdf2-5.6.1.tgz",
      "integrity": "sha512-k4gRQ+D93zDRPNUfmduNKq065uadC2YjMP/CqwwX5qG6R05f47boq6pLZtV/RnC4NZAYOPH1Cyo54q0c9sshRQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/sha2": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/properties": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/properties/-/properties-5.6.0.tgz",
      "integrity": "sha512-szoOkHskajKePTJSZ46uHUWWkbv7TzP2ypdEK6jGMqJaEt2sb0jCgfBo0gH0m2HBpRixMuJ6TBRaQCF7a9DoCg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/providers": {
      "version": "5.6.8",
      "resolved": "https://registry.npmjs.org/@ethersproject/providers/-/providers-5.6.8.tgz",
      "integrity": "sha512-Wf+CseT/iOJjrGtAOf3ck9zS7AgPmr2fZ3N97r4+YXN3mBePTG2/bJ8DApl9mVwYL+RpYbNxMEkEp4mPGdwG/w==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/base64": "^5.6.1",
        "@ethersproject/basex": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/networks": "^5.6.3",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/rlp": "^5.6.1",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/web": "^5.6.1",
        "bech32": "1.1.4",
        "ws": "7.4.6"
      }
    },
    "node_modules/@ethersproject/random": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/random/-/random-5.6.1.tgz",
      "integrity": "sha512-/wtPNHwbmng+5yi3fkipA8YBT59DdkGRoC2vWk09Dci/q5DlgnMkhIycjHlavrvrjJBkFjO/ueLyT+aUDfc4lA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/rlp": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/rlp/-/rlp-5.6.1.tgz",
      "integrity": "sha512-uYjmcZx+DKlFUk7a5/W9aQVaoEC7+1MOBgNtvNg13+RnuUwT4F0zTovC0tmay5SmRslb29V1B7Y5KCri46WhuQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/sha2": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/sha2/-/sha2-5.6.1.tgz",
      "integrity": "sha512-5K2GyqcW7G4Yo3uenHegbXRPDgARpWUiXc6RiF7b6i/HXUoWlb7uCARh7BAHg7/qT/Q5ydofNwiZcim9qpjB6g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "hash.js": "1.1.7"
      }
    },
    "node_modules/@ethersproject/signing-key": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/signing-key/-/signing-key-5.6.2.tgz",
      "integrity": "sha512-jVbu0RuP7EFpw82vHcL+GP35+KaNruVAZM90GxgQnGqB6crhBqW/ozBfFvdeImtmb4qPko0uxXjn8l9jpn0cwQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "bn.js": "^5.2.1",
        "elliptic": "6.5.4",
        "hash.js": "1.1.7"
      }
    },
    "node_modules/@ethersproject/solidity": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/solidity/-/solidity-5.6.1.tgz",
      "integrity": "sha512-KWqVLkUUoLBfL1iwdzUVlkNqAUIFMpbbeH0rgCfKmJp0vFtY4AsaN91gHKo9ZZLkC4UOm3cI3BmMV4N53BOq4g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/strings": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/strings/-/strings-5.6.1.tgz",
      "integrity": "sha512-2X1Lgk6Jyfg26MUnsHiT456U9ijxKUybz8IM1Vih+NJxYtXhmvKBcHOmvGqpFSVJ0nQ4ZCoIViR8XlRw1v/+Cw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/transactions": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/transactions/-/transactions-5.6.2.tgz",
      "integrity": "sha512-BuV63IRPHmJvthNkkt9G70Ullx6AcM+SDc+a8Aw/8Yew6YwT51TcBKEp1P4oOQ/bP25I18JJr7rcFRgFtU9B2Q==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/rlp": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2"
      }
    },
    "node_modules/@ethersproject/units": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/units/-/units-5.6.1.tgz",
      "integrity": "sha512-rEfSEvMQ7obcx3KWD5EWWx77gqv54K6BKiZzKxkQJqtpriVsICrktIQmKl8ReNToPeIYPnFHpXvKpi068YFZXw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "node_modules/@ethersproject/wallet": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/wallet/-/wallet-5.6.2.tgz",
      "integrity": "sha512-lrgh0FDQPuOnHcF80Q3gHYsSUODp6aJLAdDmDV0xKCN/T7D99ta1jGVhulg3PY8wiXEngD0DfM0I2XKXlrqJfg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/hdnode": "^5.6.2",
        "@ethersproject/json-wallets": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/wordlists": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/web": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/web/-/web-5.6.1.tgz",
      "integrity": "sha512-/vSyzaQlNXkO1WV+RneYKqCJwualcUdx/Z3gseVovZP0wIlOFcCE1hkRhKBH8ImKbGQbMl9EAAyJFrJu7V0aqA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/base64": "^5.6.1",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "node_modules/@ethersproject/wordlists": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/wordlists/-/wordlists-5.6.1.tgz",
      "integrity": "sha512-wiPRgBpNbNwCQFoCr8bcWO8o5I810cqO6mkdtKfLKFlLxeCWcnzDi4Alu8iyNzlhYuS9npCwivMbRWF19dyblw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "node_modules/@hapi/hoek": {
      "version": "9.3.0",
      "resolved": "https://registry.npmjs.org/@hapi/hoek/-/hoek-9.3.0.tgz",
      "integrity": "sha512-/c6rf4UJlmHlC9b5BaNvzAcFv7HZ2QHaV0D4/HNlBdvFnvQq8RI4kYdhyPCl7Xj+oWvTWQ8ujhqS53LIgAe6KQ=="
    },
    "node_modules/@hapi/topo": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@hapi/topo/-/topo-5.1.0.tgz",
      "integrity": "sha512-foQZKJig7Ob0BMAYBfcJk8d77QtOe7Wo4ox7ff1lQYoNNAb6jwcY1ncdoy2e9wQZzvNy7ODZCYJkK8kzmcAnAg==",
      "dependencies": {
        "@hapi/hoek": "^9.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.0.tgz",
      "integrity": "sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==",
      "dev": true,
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.4.14",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.14.tgz",
      "integrity": "sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==",
      "dev": true
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@project-serum/anchor": {
      "version": "0.18.2",
      "resolved": "https://registry.npmjs.org/@project-serum/anchor/-/anchor-0.18.2.tgz",
      "integrity": "sha512-uyjiN/3Ipp+4hrZRm/hG18HzGLZyvP790LXrCsGO3IWxSl28YRhiGEpKnZycfMW94R7nxdUoE3wY67V+ZHSQBQ==",
      "dependencies": {
        "@project-serum/borsh": "^0.2.2",
        "@solana/web3.js": "^1.17.0",
        "base64-js": "^1.5.1",
        "bn.js": "^5.1.2",
        "bs58": "^4.0.1",
        "buffer-layout": "^1.2.0",
        "camelcase": "^5.3.1",
        "crypto-hash": "^1.3.0",
        "eventemitter3": "^4.0.7",
        "find": "^0.3.0",
        "js-sha256": "^0.9.0",
        "pako": "^2.0.3",
        "snake-case": "^3.0.4",
        "toml": "^3.0.0"
      },
      "engines": {
        "node": ">=11"
      }
    },
    "node_modules/@project-serum/borsh": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/@project-serum/borsh/-/borsh-0.2.5.tgz",
      "integrity": "sha512-UmeUkUoKdQ7rhx6Leve1SssMR/Ghv8qrEiyywyxSWg7ooV7StdpPBhciiy5eB3T0qU1BXvdRNC8TdrkxK7WC5Q==",
      "dependencies": {
        "bn.js": "^5.1.2",
        "buffer-layout": "^1.2.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@solana/web3.js": "^1.2.0"
      }
    },
    "node_modules/@sideway/address": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@sideway/address/-/address-4.1.4.tgz",
      "integrity": "sha512-7vwq+rOHVWjyXxVlR76Agnvhy8I9rpzjosTESvmhNeXOXdZZB15Fl+TI9x1SiHZH5Jv2wTGduSxFDIaq0m3DUw==",
      "dependencies": {
        "@hapi/hoek": "^9.0.0"
      }
    },
    "node_modules/@sideway/formula": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@sideway/formula/-/formula-3.0.0.tgz",
      "integrity": "sha512-vHe7wZ4NOXVfkoRb8T5otiENVlT7a3IAiw7H5M2+GO+9CDgcVUUsX1zalAztCmwyOr2RUTGJdgB+ZvSVqmdHmg=="
    },
    "node_modules/@sideway/pinpoint": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/@sideway/pinpoint/-/pinpoint-2.0.0.tgz",
      "integrity": "sha512-RNiOoTPkptFtSVzQevY/yWtZwf/RxyVnPy/OcA9HBM3MlGDnBEYL5B41H0MTn0Uec8Hi+2qUtTfG2WWZBmMejQ=="
    },
    "node_modules/@solana/buffer-layout": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@solana/buffer-layout/-/buffer-layout-4.0.0.tgz",
      "integrity": "sha512-lR0EMP2HC3+Mxwd4YcnZb0smnaDw7Bl2IQWZiTevRH5ZZBZn6VRWn3/92E3qdU4SSImJkA6IDHawOHAnx/qUvQ==",
      "dependencies": {
        "buffer": "~6.0.3"
      },
      "engines": {
        "node": ">=5.10"
      }
    },
    "node_modules/@solana/buffer-layout-utils": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/@solana/buffer-layout-utils/-/buffer-layout-utils-0.2.0.tgz",
      "integrity": "sha512-szG4sxgJGktbuZYDg2FfNmkMi0DYQoVjN2h7ta1W1hPrwzarcFLBq9UpX1UjNXsNpT9dn+chgprtWGioUAr4/g==",
      "dependencies": {
        "@solana/buffer-layout": "^4.0.0",
        "@solana/web3.js": "^1.32.0",
        "bigint-buffer": "^1.1.5",
        "bignumber.js": "^9.0.1"
      },
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@solana/spl-token": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/@solana/spl-token/-/spl-token-0.2.0.tgz",
      "integrity": "sha512-RWcn31OXtdqIxmkzQfB2R+WpsJOVS6rKuvpxJFjvik2LyODd+WN58ZP3Rpjpro03fscGAkzlFuP3r42doRJgyQ==",
      "dependencies": {
        "@solana/buffer-layout": "^4.0.0",
        "@solana/buffer-layout-utils": "^0.2.0",
        "@solana/web3.js": "^1.32.0",
        "start-server-and-test": "^1.14.0"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/@solana/web3.js": {
      "version": "1.47.3",
      "resolved": "https://registry.npmjs.org/@solana/web3.js/-/web3.js-1.47.3.tgz",
      "integrity": "sha512-TQJulaN/+b0xXq5EhQAYFwVyOORxSyVJn1EiXupClZm8DY7f9EeUG6vl0FzSAgwEAwXKsgK3sVs/3px2e7H7dQ==",
      "dependencies": {
        "@babel/runtime": "^7.12.5",
        "@ethersproject/sha2": "^5.5.0",
        "@solana/buffer-layout": "^4.0.0",
        "bigint-buffer": "^1.1.5",
        "bn.js": "^5.0.0",
        "borsh": "^0.7.0",
        "bs58": "^4.0.1",
        "buffer": "6.0.1",
        "fast-stable-stringify": "^1.0.0",
        "jayson": "^3.4.4",
        "js-sha3": "^0.8.0",
        "node-fetch": "2",
        "rpc-websockets": "^7.5.0",
        "secp256k1": "^4.0.2",
        "superstruct": "^0.14.2",
        "tweetnacl": "^1.0.0"
      },
      "engines": {
        "node": ">=12.20.0"
      }
    },
    "node_modules/@solana/web3.js/node_modules/buffer": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.1.tgz",
      "integrity": "sha512-rVAXBwEcEoYtxnHSO5iWyhzV/O1WMtkUYWlfdLS7FjU4PnSJJHEfHXi/uHPI5EwltmOA794gN3bm3/pzuctWjQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.2.1"
      }
    },
    "node_modules/@supercharge/promise-pool": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@supercharge/promise-pool/-/promise-pool-2.3.0.tgz",
      "integrity": "sha512-KLf3JBWW4JymplvT/c5JCZhc4KrNE9EBf15FPjvklQiGcoUczSLInpV23iV5dITnvktJlwQ5xq08wfNwBk71Rg==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.9.tgz",
      "integrity": "sha512-jNsYVVxU8v5g43Erja32laIDHXeoNvFEpX33OK4d6hljo3jDhCBDhx5dhCCTMWUojscpAagGiRkBKxpdl9fxqA==",
      "dev": true
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.3.tgz",
      "integrity": "sha512-yOlFc+7UtL/89t2ZhjPvvB/DeAr3r+Dq58IgzsFkOAvVC6NMJXmCGjbptdXdR9qsX7pKcTL+s87FtYREi2dEEQ==",
      "dev": true
    },
    "node_modules/@types/connect": {
      "version": "3.4.35",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.35.tgz",
      "integrity": "sha512-cdeYyv4KWoEgpBISTxWvqYsVy444DOqehiF3fM3ne10AmJ62RSyNkUnxMJXHQWRQQX2eR94m5y1IZyDwBjV9FQ==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.17.29",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.17.29.tgz",
      "integrity": "sha512-uMd++6dMKS32EOuw1Uli3e3BPgdLIXmezcfHv7N4c1s3gkhikBplORPpMq3fuWkxncZN1reb16d5n8yhQ80x7Q==",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*"
      }
    },
    "node_modules/@types/lodash": {
      "version": "4.14.182",
      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.14.182.tgz",
      "integrity": "sha512-/THyiqyQAP9AfARo4pF+aCGcyiQ94tX/Is2I7HofNRqoYLgN1PBoOWu2/zTA5zMxzP5EFutMtWtGAFRKUe961Q=="
    },
    "node_modules/@types/node": {
      "version": "18.0.3",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.0.3.tgz",
      "integrity": "sha512-HzNRZtp4eepNitP+BD6k2L6DROIDG4Q0fm4x+dwfsr6LGmROENnok75VGw40628xf+iR24WeMFcHuuBDUAzzsQ=="
    },
    "node_modules/@types/qs": {
      "version": "6.9.7",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.7.tgz",
      "integrity": "sha512-FGa1F62FT09qcrueBA6qYTrJPVDzah9a+493+o2PCXsesWHIn27G98TsSMs3WPNbZIEj4+VJf6saSFpvD+3Zsw=="
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.4.tgz",
      "integrity": "sha512-EEhsLsD6UsDM1yFhAvy0Cjr6VwmpMWqFBCb9w07wVugF7w9nfajxLuVmngTIpgS6svCnm6Vaw+MZhoDCKnOfsw=="
    },
    "node_modules/@types/ws": {
      "version": "7.4.7",
      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-7.4.7.tgz",
      "integrity": "sha512-JQbbmxZTZehdc2iszGKs5oC3NFnjeay7mtAWrdt7qNtAVK0g19muApzAy4bm9byz79xa2ZnO/BOBC2R8RC5Lww==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/acorn": {
      "version": "8.7.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.7.1.tgz",
      "integrity": "sha512-Xx54uLJQZ19lKygFXOWsscKUbsBZW0CPykPhVQdhIeIwrbPmJzqeASDInc8nKBnp/JT6igTs82qPXz069H8I/A==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.2.0.tgz",
      "integrity": "sha512-k+iyHEuPgSw6SbuDpGQM+06HQUa04DZ3o+F6CSzXMvvI5KMvnaEqXe+YVe555R9nn6GPt404fos4wcgpw12SDA==",
      "dev": true,
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/aes-js": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/aes-js/-/aes-js-3.0.0.tgz",
      "integrity": "sha512-H7wUZRn8WpTq9jocdxQ2c8x2sKo9ZVmzfRE13GiNJXfp7NcKYEdvl3vspKjXox6RIG2VtaRe4JFvxG4rqp2Zuw=="
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true
    },
    "node_modules/async": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/async/-/async-3.2.4.tgz",
      "integrity": "sha512-iAB+JbDEGXhyIUavoDl9WP/Jj106Kz9DEn1DPgYw5ruDn0e3Wgi3sKFm55sASdGBNOQB8F59d9qQ7deqrHA8wQ=="
    },
    "node_modules/async-retry": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/async-retry/-/async-retry-1.3.3.tgz",
      "integrity": "sha512-wfr/jstw9xNi/0teMHrRW7dsz3Lt5ARhYNZ2ewpadnhaIp5mbALhOAP+EAdsC7t4Z6wqsDVv9+W6gm1Dk9mEyw==",
      "dependencies": {
        "retry": "0.13.1"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "node_modules/axios": {
      "version": "0.26.1",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.26.1.tgz",
      "integrity": "sha512-fPwcX4EvnSHuInCMItEhAGnaSEXRBjtzh9fOtsE6E1G6p7vl7edEeZe11QHf18+6+9gR5PbKV/sGKNaD8YaMeA==",
      "dependencies": {
        "follow-redirects": "^1.14.8"
      }
    },
    "node_modules/base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/bech32": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/bech32/-/bech32-1.1.4.tgz",
      "integrity": "sha512-s0IrSOzLlbvX7yp4WBfPITzpAU8sqQcpsmwXDiKwrG4r491vwCO/XpejasRNl0piBMe/DvP4Tz0mIS/X1DPJBQ=="
    },
    "node_modules/bigint-buffer": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/bigint-buffer/-/bigint-buffer-1.1.5.tgz",
      "integrity": "sha512-trfYco6AoZ+rKhKnxA0hgX0HAbVP/s808/EuDSe2JDzUnCp/xAsli35Orvk67UrTEcwuxZqYZDmfA2RXJgxVvA==",
      "hasInstallScript": true,
      "dependencies": {
        "bindings": "^1.3.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/bignumber.js": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.0.2.tgz",
      "integrity": "sha512-GAcQvbpsM0pUb0zw1EI0KhQEZ+lRwR5fYaAp3vPOYuP7aDvGy6cVN6XHLauvF8SOga2y0dcLcjt3iQDTSEliyw==",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "dependencies": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "node_modules/blakejs": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/blakejs/-/blakejs-1.2.1.tgz",
      "integrity": "sha512-QXUSXI3QVc/gJME0dBpXrag1kbzOqCjCX8/b54ntNyW6sjtoqxqRk3LTmXzaJoh71zMsDCjM+47jS7XiwN/+fQ=="
    },
    "node_modules/bluebird": {
      "version": "3.7.2",
      "resolved": "https://registry.npmjs.org/bluebird/-/bluebird-3.7.2.tgz",
      "integrity": "sha512-XpNj6GDQzdfW+r2Wnn7xiSAd7TM3jzkxGXBGTtWKuSXv1xUV+azxAm8jdWZN06QTQk+2N2XB9jRDkvbmQmcRtg=="
    },
    "node_modules/bn.js": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.1.tgz",
      "integrity": "sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ=="
    },
    "node_modules/borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "dependencies": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "node_modules/brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w=="
    },
    "node_modules/bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "dependencies": {
        "base-x": "^3.0.2"
      }
    },
    "node_modules/buffer": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
      "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.2.1"
      }
    },
    "node_modules/buffer-layout": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/buffer-layout/-/buffer-layout-1.2.2.tgz",
      "integrity": "sha512-kWSuLN694+KTk8SrYvCqwP2WcgQjoRCiF5b4QDvkkz8EmgD+aWAIceGFKMIAdmF/pH+vpgNV3d3kAKorcdAmWA==",
      "engines": {
        "node": ">=4.5"
      }
    },
    "node_modules/bufferutil": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/bufferutil/-/bufferutil-4.0.6.tgz",
      "integrity": "sha512-jduaYOYtnio4aIAyc6UbvPCVcgq7nYpVnucyxr6eCYg/Woad9Hf/oxxBRDnGGjPfjUm6j5O/uBWhIu4iLebFaw==",
      "hasInstallScript": true,
      "optional": true,
      "dependencies": {
        "node-gyp-build": "^4.3.0"
      },
      "engines": {
        "node": ">=6.14.2"
      }
    },
    "node_modules/camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/check-more-types": {
      "version": "2.24.0",
      "resolved": "https://registry.npmjs.org/check-more-types/-/check-more-types-2.24.0.tgz",
      "integrity": "sha512-Pj779qHxV2tuapviy1bSZNEL1maXr13bPYpsvSDB68HlYcYuhlDrmGd63i0JHMCLKzc7rUSNIrpdJlhVlNwrxA==",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true
    },
    "node_modules/cross-fetch": {
      "version": "3.1.5",
      "resolved": "https://registry.npmjs.org/cross-fetch/-/cross-fetch-3.1.5.tgz",
      "integrity": "sha512-lvb1SBsI0Z7GDwmuid+mU3kWVBwTVUbe7S0H52yaaAdQOXq2YktTCZdlAcNKFzE6QtRz0snpw9bNiPeOIkkQvw==",
      "dependencies": {
        "node-fetch": "2.6.7"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/crypto-hash": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/crypto-hash/-/crypto-hash-1.3.0.tgz",
      "integrity": "sha512-lyAZ0EMyjDkVvz8WOeVnuCPvKVBXcMv1l5SVqO1yC7PzTwrD/pPje/BIRbWhMoPe436U+Y2nD7f5bFx0kt+Sbg==",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/curve25519-js": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/curve25519-js/-/curve25519-js-0.0.4.tgz",
      "integrity": "sha512-axn2UMEnkhyDUPWOwVKBMVIzSQy2ejH2xRGy1wq81dqRwApXfIzfbE3hIX0ZRFBIihf/KDqK158DLwESu4AK1w=="
    },
    "node_modules/debug": {
      "version": "4.3.2",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.2.tgz",
      "integrity": "sha512-mOp8wKcvj7XxC78zLgw/ZA+6TSgkoE2C/ienthhRD298T7UNwAg9diBpLRxC0mOezLl4B0xV7M0cCO6P/O0Xhw==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delay": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/delay/-/delay-5.0.0.tgz",
      "integrity": "sha512-ReEBKkIfe4ya47wlPYf/gu5ib6yUG0/Aez0JQZQz94kiWtRQvZIQbTiehsnwHvLSWJnQdhVeqYue7Id1dKr0qw==",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dot-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
      "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
      "dependencies": {
        "no-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/dotenv": {
      "version": "8.6.0",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-8.6.0.tgz",
      "integrity": "sha512-IrPdXQsk2BbzvCBGBOTmmSH5SodmqZNt4ERAZDmW4CT+tL8VtvinqywuANaFu4bOMWki16nqf0e4oC0QIaDr/g==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/duplexer": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/duplexer/-/duplexer-0.1.2.tgz",
      "integrity": "sha512-jtD6YG370ZCIi/9GTaJKQxWTZD045+4R4hTk/x1UyoqadyJ9x9CgSi1RlVDQF8U2sxLLSnFkCaMihqljHIWgMg=="
    },
    "node_modules/elliptic": {
      "version": "6.5.4",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
      "integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
      "dependencies": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/elliptic/node_modules/bn.js": {
      "version": "4.12.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
      "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
    },
    "node_modules/es6-promise": {
      "version": "4.2.8",
      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
      "integrity": "sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w=="
    },
    "node_modules/es6-promisify": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
      "integrity": "sha512-C+d6UdsYDk0lMebHNR4S2NybQMMngAOnOwYBQjTOiv0MkoJMP0Myw2mgpDLBcpfCmRLxyFqYhS/CfOENq4SJhQ==",
      "dependencies": {
        "es6-promise": "^4.0.3"
      }
    },
    "node_modules/ethers": {
      "version": "5.6.9",
      "resolved": "https://registry.npmjs.org/ethers/-/ethers-5.6.9.tgz",
      "integrity": "sha512-lMGC2zv9HC5EC+8r429WaWu3uWJUCgUCt8xxKCFqkrFuBDZXDYIdzDUECxzjf2BMF8IVBByY1EBoGSL3RTm8RA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abi": "5.6.4",
        "@ethersproject/abstract-provider": "5.6.1",
        "@ethersproject/abstract-signer": "5.6.2",
        "@ethersproject/address": "5.6.1",
        "@ethersproject/base64": "5.6.1",
        "@ethersproject/basex": "5.6.1",
        "@ethersproject/bignumber": "5.6.2",
        "@ethersproject/bytes": "5.6.1",
        "@ethersproject/constants": "5.6.1",
        "@ethersproject/contracts": "5.6.2",
        "@ethersproject/hash": "5.6.1",
        "@ethersproject/hdnode": "5.6.2",
        "@ethersproject/json-wallets": "5.6.1",
        "@ethersproject/keccak256": "5.6.1",
        "@ethersproject/logger": "5.6.0",
        "@ethersproject/networks": "5.6.4",
        "@ethersproject/pbkdf2": "5.6.1",
        "@ethersproject/properties": "5.6.0",
        "@ethersproject/providers": "5.6.8",
        "@ethersproject/random": "5.6.1",
        "@ethersproject/rlp": "5.6.1",
        "@ethersproject/sha2": "5.6.1",
        "@ethersproject/signing-key": "5.6.2",
        "@ethersproject/solidity": "5.6.1",
        "@ethersproject/strings": "5.6.1",
        "@ethersproject/transactions": "5.6.2",
        "@ethersproject/units": "5.6.1",
        "@ethersproject/wallet": "5.6.2",
        "@ethersproject/web": "5.6.1",
        "@ethersproject/wordlists": "5.6.1"
      }
    },
    "node_modules/event-stream": {
      "version": "3.3.4",
      "resolved": "https://registry.npmjs.org/event-stream/-/event-stream-3.3.4.tgz",
      "integrity": "sha512-QHpkERcGsR0T7Qm3HNJSyXKEEj8AHNxkY3PK8TS2KJvQ7NiSHe3DDpwVKKtoYprL/AreyzFBeIkBIWChAqn60g==",
      "dependencies": {
        "duplexer": "~0.1.1",
        "from": "~0",
        "map-stream": "~0.1.0",
        "pause-stream": "0.0.11",
        "split": "0.3",
        "stream-combiner": "~0.0.4",
        "through": "~2.3.1"
      }
    },
    "node_modules/eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw=="
    },
    "node_modules/execa": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/execa/-/execa-5.1.1.tgz",
      "integrity": "sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==",
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/extract-files": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/extract-files/-/extract-files-9.0.0.tgz",
      "integrity": "sha512-CvdFfHkC95B4bBBk36hcEmvdR2awOdhhVUYH6S/zrVj3477zven/fJMYg7121h4T1xHZC+tetUpubpAhxwI7hQ==",
      "engines": {
        "node": "^10.17.0 || ^12.0.0 || >= 13.7.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/jaydenseric"
      }
    },
    "node_modules/eyes": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/eyes/-/eyes-0.1.8.tgz",
      "integrity": "sha512-GipyPsXO1anza0AOZdy69Im7hGFCNB7Y/NGjDlZGJ3GJJLtwNSb2vrzYrTYJRrRloVx7pl+bhUaTB8yiccPvFQ==",
      "engines": {
        "node": "> 0.1.90"
      }
    },
    "node_modules/fast-stable-stringify": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fast-stable-stringify/-/fast-stable-stringify-1.0.0.tgz",
      "integrity": "sha512-wpYMUmFu5f00Sm0cj2pfivpmawLZ0NKdviQ4w9zJeR8JVtOpOxHmLaJuj0vxvGqMJQWyP/COUkF75/57OKyRag=="
    },
    "node_modules/file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw=="
    },
    "node_modules/find": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/find/-/find-0.3.0.tgz",
      "integrity": "sha512-iSd+O4OEYV/I36Zl8MdYJO0xD82wH528SaCieTVHhclgiYNe9y+yPKSwK+A7/WsmHL1EZ+pYUJBXWTL5qofksw==",
      "dependencies": {
        "traverse-chain": "~0.1.0"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.15.1",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.1.tgz",
      "integrity": "sha512-yLAMQs+k0b2m7cVxpS1VKJVvoz7SS9Td1zss3XRwXj+ZDH00RJgnuLx7E44wx02kQLrdM3aOOy+FpzS7+8OizA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-3.0.1.tgz",
      "integrity": "sha512-RHkBKtLWUVwd7SqRIvCZMEvAMoGUp0XU+seQiZejj0COz3RI3hWP4sCv3gZWWLjJTd7rGwcsF5eKZGii0r/hbg==",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/from": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/from/-/from-0.1.7.tgz",
      "integrity": "sha512-twe20eF1OxVxp/ML/kq2p1uc6KvFK/+vs8WjEbeKmV2He22MKm7YF2ANIt+EOqhJ5L3K/SuuPhk0hWQDjOM23g=="
    },
    "node_modules/get-stream": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/graphql": {
      "version": "15.8.0",
      "resolved": "https://registry.npmjs.org/graphql/-/graphql-15.8.0.tgz",
      "integrity": "sha512-5gghUc24tP9HRznNpV2+FIoq3xKkj5dTQqf4v0CpdPbFVwFkWoxOM+o+2OC9ZSvjEMTjfmG9QT+gcvggTwW1zw==",
      "engines": {
        "node": ">= 10.x"
      }
    },
    "node_modules/graphql-request": {
      "version": "3.7.0",
      "resolved": "https://registry.npmjs.org/graphql-request/-/graphql-request-3.7.0.tgz",
      "integrity": "sha512-dw5PxHCgBneN2DDNqpWu8QkbbJ07oOziy8z+bK/TAXufsOLaETuVO4GkXrbs0WjhdKhBMN3BkpN/RIvUHkmNUQ==",
      "dependencies": {
        "cross-fetch": "^3.0.6",
        "extract-files": "^9.0.0",
        "form-data": "^3.0.0"
      },
      "peerDependencies": {
        "graphql": "14 - 16"
      }
    },
    "node_modules/hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "dependencies": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "node_modules/hi-base32": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/hi-base32/-/hi-base32-0.5.1.tgz",
      "integrity": "sha512-EmBBpvdYh/4XxsnUybsPag6VikPYnN30td+vQk+GI3qpahVEG9+gTkG0aXVxTjBqQ5T6ijbWIu77O+C5WFWsnA=="
    },
    "node_modules/hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "dependencies": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/human-signals": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
      "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==",
      "engines": {
        "node": ">=10.17.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw=="
    },
    "node_modules/isomorphic-ws": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/isomorphic-ws/-/isomorphic-ws-4.0.1.tgz",
      "integrity": "sha512-BhBvN2MBpWTaSHdWRb/bwdZJ1WaehQ2L1KngkCkfLUGF0mAWAT1sQUQacEmQ0jXkFw/czDXPNQSL5u2/Krsz1w==",
      "peerDependencies": {
        "ws": "*"
      }
    },
    "node_modules/jayson": {
      "version": "3.6.6",
      "resolved": "https://registry.npmjs.org/jayson/-/jayson-3.6.6.tgz",
      "integrity": "sha512-f71uvrAWTtrwoww6MKcl9phQTC+56AopLyEenWvKVAIMz+q0oVGj6tenLZ7Z6UiPBkJtKLj4kt0tACllFQruGQ==",
      "dependencies": {
        "@types/connect": "^3.4.33",
        "@types/express-serve-static-core": "^4.17.9",
        "@types/lodash": "^4.14.159",
        "@types/node": "^12.12.54",
        "@types/ws": "^7.4.4",
        "commander": "^2.20.3",
        "delay": "^5.0.0",
        "es6-promisify": "^5.0.0",
        "eyes": "^0.1.8",
        "isomorphic-ws": "^4.0.1",
        "json-stringify-safe": "^5.0.1",
        "JSONStream": "^1.3.5",
        "lodash": "^4.17.20",
        "uuid": "^8.3.2",
        "ws": "^7.4.5"
      },
      "bin": {
        "jayson": "bin/jayson.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jayson/node_modules/@types/node": {
      "version": "12.20.55",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-12.20.55.tgz",
      "integrity": "sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ=="
    },
    "node_modules/joi": {
      "version": "17.6.0",
      "resolved": "https://registry.npmjs.org/joi/-/joi-17.6.0.tgz",
      "integrity": "sha512-OX5dG6DTbcr/kbMFj0KGYxuew69HPcAE3K/sZpEV2nP6e/j/C0HV+HNiBPCASxdx5T7DMoa0s8UeHWMnb6n2zw==",
      "dependencies": {
        "@hapi/hoek": "^9.0.0",
        "@hapi/topo": "^5.0.0",
        "@sideway/address": "^4.1.3",
        "@sideway/formula": "^3.0.0",
        "@sideway/pinpoint": "^2.0.0"
      }
    },
    "node_modules/js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "node_modules/js-sha3": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha3/-/js-sha3-0.8.0.tgz",
      "integrity": "sha512-gF1cRrHhIzNfToc802P800N8PpXS+evLLXfsVpowqmAFR9uwbi89WvXg2QspOmXL8QL86J4T1EpFu+yUkwJY3Q=="
    },
    "node_modules/js-sha512": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha512/-/js-sha512-0.8.0.tgz",
      "integrity": "sha512-PWsmefG6Jkodqt+ePTvBZCSMFgN7Clckjd0O7su3I0+BW2QWUTJNzjktHsztGLhncP2h8mcF9V9Y2Ha59pAViQ=="
    },
    "node_modules/json-stringify-safe": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
      "integrity": "sha512-ZClg6AaYvamvYEE82d3Iyd3vSSIjQ+odgjaTzRuO3s7toCdFKczob2i0zCh7JE8kWn17yvAWhUVxvqGwUalsRA=="
    },
    "node_modules/jsonparse": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/jsonparse/-/jsonparse-1.3.1.tgz",
      "integrity": "sha512-POQXvpdL69+CluYsillJ7SUhKvytYjW9vG/GKpnf+xP8UWgYEM/RaMzHHofbALDiKbbP1W8UEYmgGl39WkPZsg==",
      "engines": [
        "node >= 0.2.0"
      ]
    },
    "node_modules/JSONStream": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.5.tgz",
      "integrity": "sha512-E+iruNOY8VV9s4JEbe1aNEm6MiszPRr/UfcHMz0TQh1BXSxHK+ASV1R6W4HpjBhSeS+54PIsAMCBmwD06LLsqQ==",
      "dependencies": {
        "jsonparse": "^1.2.0",
        "through": ">=2.2.7 <3"
      },
      "bin": {
        "JSONStream": "bin.js"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/just-performance": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/just-performance/-/just-performance-4.3.0.tgz",
      "integrity": "sha512-L7RjvtJsL0QO8xFs5wEoDDzzJwoiowRw6Rn/GnvldlchS2JQr9wFYPiwZcDfrbbujEKqKN0tvENdbjXdYhDp5Q=="
    },
    "node_modules/lazy-ass": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/lazy-ass/-/lazy-ass-1.6.0.tgz",
      "integrity": "sha512-cc8oEVoctTvsFZ/Oje/kGnHbpWHYBe8IAJe4C0QNc3t8uM/0Y8+erSz/7Y1ALuXTEZTMvxXwO6YbX1ey3ujiZw==",
      "engines": {
        "node": "> 0.8"
      }
    },
    "node_modules/limiter": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/limiter/-/limiter-2.1.0.tgz",
      "integrity": "sha512-361TYz6iay6n+9KvUUImqdLuFigK+K79qrUtBsXhJTLdH4rIt/r1y8r1iozwh8KbZNpujbFTSh74mJ7bwbAMOw==",
      "dependencies": {
        "just-performance": "4.3.0"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "node_modules/lower-case": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
      "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
      "dependencies": {
        "tslib": "^2.0.3"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true
    },
    "node_modules/map-stream": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/map-stream/-/map-stream-0.1.0.tgz",
      "integrity": "sha512-CkYQrPYZfWnu/DAmVCpTSX/xHpKZ80eKh2lAkyA6AJTef6bW+6JpbQZN5rofum7da+SyN1bi5ctTm+lTfcCW3g=="
    },
    "node_modules/merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w=="
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A=="
    },
    "node_modules/minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg=="
    },
    "node_modules/minimist": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz",
      "integrity": "sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q=="
    },
    "node_modules/miscreant": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/miscreant/-/miscreant-0.3.2.tgz",
      "integrity": "sha512-fL9KxsQz9BJB2KGPMHFrReioywkiomBiuaLk6EuChijK0BsJsIKJXdVomR+/bPj5mvbFD6wM0CM3bZio9g7OHA=="
    },
    "node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/no-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
      "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
      "dependencies": {
        "lower-case": "^2.0.2",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/node-addon-api": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-2.0.2.tgz",
      "integrity": "sha512-Ntyt4AIXyaLIuMHF6IOoTakB3K+RWxwtsHNRxllEoA6vPwP9o4866g6YWDLUdnucilZhmkxiHwHr11gAENw+QA=="
    },
    "node_modules/node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/node-gyp-build": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/node-gyp-build/-/node-gyp-build-4.5.0.tgz",
      "integrity": "sha512-2iGbaQBV+ITgCz76ZEjmhUKAKVf7xfY1sRl4UiKQspfZMH2h06SyhNsnSVy50cwkFQDGLyif6m/6uFXHkOZ6rg==",
      "bin": {
        "node-gyp-build": "bin.js",
        "node-gyp-build-optional": "optional.js",
        "node-gyp-build-test": "build-test.js"
      }
    },
    "node_modules/npm-run-path": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
      "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
      "dependencies": {
        "path-key": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dependencies": {
        "mimic-fn": "^2.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/pako": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/pako/-/pako-2.0.4.tgz",
      "integrity": "sha512-v8tweI900AUkZN6heMU/4Uy4cXRc2AYNRggVmTR+dEncawDJgCdLMximOVA2p4qO57WMynangsfGRb5WD6L1Bg=="
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/pause-stream": {
      "version": "0.0.11",
      "resolved": "https://registry.npmjs.org/pause-stream/-/pause-stream-0.0.11.tgz",
      "integrity": "sha512-e3FBlXLmN/D1S+zHzanP4E/4Z60oFAa3O051qt1pxa7DEJWKAyil6upYVXCWadEnuoqa4Pkc9oUx9zsxYeRv8A==",
      "dependencies": {
        "through": "~2.3"
      }
    },
    "node_modules/ps-tree": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/ps-tree/-/ps-tree-1.2.0.tgz",
      "integrity": "sha512-0VnamPPYHl4uaU/nSFeZZpR21QAWRz+sRv4iW9+v/GS/J5U5iZB5BNN6J0RMoOvdx2gWM2+ZFMIm58q24e4UYA==",
      "dependencies": {
        "event-stream": "=3.3.4"
      },
      "bin": {
        "ps-tree": "bin/ps-tree.js"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/regenerator-runtime": {
      "version": "0.13.9",
      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.9.tgz",
      "integrity": "sha512-p3VT+cOEgxFsRRA9X4lkI1E+k2/CtnKtU4gcxyaCUreilL/vqI6CdZ3wxVUx3UOUg+gnUOQQcRI7BmSI656MYA=="
    },
    "node_modules/retry": {
      "version": "0.13.1",
      "resolved": "https://registry.npmjs.org/retry/-/retry-0.13.1.tgz",
      "integrity": "sha512-XQBQ3I8W1Cge0Seh+6gjj03LbmRFWuoszgK9ooCpwYIrhhoO80pfq4cUkU5DkknwfOfFteRwlZ56PYOGYyFWdg==",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/rpc-websockets": {
      "version": "7.5.0",
      "resolved": "https://registry.npmjs.org/rpc-websockets/-/rpc-websockets-7.5.0.tgz",
      "integrity": "sha512-9tIRi1uZGy7YmDjErf1Ax3wtqdSSLIlnmL5OtOzgd5eqPKbsPpwDP5whUDO2LQay3Xp0CcHlcNSGzacNRluBaQ==",
      "dependencies": {
        "@babel/runtime": "^7.17.2",
        "eventemitter3": "^4.0.7",
        "uuid": "^8.3.2",
        "ws": "^8.5.0"
      },
      "funding": {
        "type": "paypal",
        "url": "https://paypal.me/kozjak"
      },
      "optionalDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": "^5.0.2"
      }
    },
    "node_modules/rpc-websockets/node_modules/ws": {
      "version": "8.8.0",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.8.0.tgz",
      "integrity": "sha512-JDAgSYQ1ksuwqfChJusw1LSJ8BizJ2e/vVu5Lxjq3YvNJNlROv1ui4i+c/kUUrPheBvQl4c5UbERhTwKa6QBJQ==",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": "^5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/rxjs": {
      "version": "7.5.5",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.5.5.tgz",
      "integrity": "sha512-sy+H0pQofO95VDmFLzyaw9xNJU4KTRSwQIGM6+iG3SypAtCiLDzpeG8sJrNCWn2Up9km+KhkvTdbkrdy+yzZdw==",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/scrypt-js": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/scrypt-js/-/scrypt-js-3.0.1.tgz",
      "integrity": "sha512-cdwTTnqPu0Hyvf5in5asVdZocVDTNRmR7XEcJuIzMjJeSHybHl7vpB66AzwTaIg6CLSbtjcxc8fqcySfnTkccA=="
    },
    "node_modules/secp256k1": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/secp256k1/-/secp256k1-4.0.3.tgz",
      "integrity": "sha512-NLZVf+ROMxwtEj3Xa562qgv2BK5e2WNmXPiOdVIPLgs6lyTzMvBq0aWTYMI5XCP9jZMVKOcqZLw/Wc4vDkuxhA==",
      "hasInstallScript": true,
      "dependencies": {
        "elliptic": "^6.5.4",
        "node-addon-api": "^2.0.0",
        "node-gyp-build": "^4.2.0"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ=="
    },
    "node_modules/snake-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
      "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
      "dependencies": {
        "dot-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/split": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/split/-/split-0.3.3.tgz",
      "integrity": "sha512-wD2AeVmxXRBoX44wAycgjVpMhvbwdI2aZjCkvfNcH1YqHQvJVa1duWc73OyVGJUc05fhFaTZeQ/PYsrmyH0JVA==",
      "dependencies": {
        "through": "2"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/start-server-and-test": {
      "version": "1.14.0",
      "resolved": "https://registry.npmjs.org/start-server-and-test/-/start-server-and-test-1.14.0.tgz",
      "integrity": "sha512-on5ELuxO2K0t8EmNj9MtVlFqwBMxfWOhu4U7uZD1xccVpFlOQKR93CSe0u98iQzfNxRyaNTb/CdadbNllplTsw==",
      "dependencies": {
        "bluebird": "3.7.2",
        "check-more-types": "2.24.0",
        "debug": "4.3.2",
        "execa": "5.1.1",
        "lazy-ass": "1.6.0",
        "ps-tree": "1.2.0",
        "wait-on": "6.0.0"
      },
      "bin": {
        "server-test": "src/bin/start.js",
        "start-server-and-test": "src/bin/start.js",
        "start-test": "src/bin/start.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/stream-combiner": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/stream-combiner/-/stream-combiner-0.0.4.tgz",
      "integrity": "sha512-rT00SPnTVyRsaSz5zgSPma/aHSOic5U1prhYdRy5HS2kTZviFpmDgzilbtsJsxiroqACmayynDN/9VzIbX5DOw==",
      "dependencies": {
        "duplexer": "~0.1.1"
      }
    },
    "node_modules/strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/superstruct": {
      "version": "0.14.2",
      "resolved": "https://registry.npmjs.org/superstruct/-/superstruct-0.14.2.tgz",
      "integrity": "sha512-nPewA6m9mR3d6k7WkZ8N8zpTWfenFH3q9pA2PkuiZxINr9DKB2+40wEQf0ixn8VaGuJ78AB6iWOtStI+/4FKZQ=="
    },
    "node_modules/text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "node_modules/through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg=="
    },
    "node_modules/toml": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/toml/-/toml-3.0.0.tgz",
      "integrity": "sha512-y/mWCZinnvxjTKYhJ+pYxwD0mRLVvOtdS2Awbgxln6iEnt4rk0yBxeSBHkGJcPucRiG0e55mwWp+g/05rsrd6w=="
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/traverse-chain": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/traverse-chain/-/traverse-chain-0.1.0.tgz",
      "integrity": "sha512-up6Yvai4PYKhpNp5PkYtx50m3KbwQrqDwbuZP/ItyL64YEWHAvH6Md83LFLV/GRSk/BoUVwwgUzX6SOQSbsfAg=="
    },
    "node_modules/tron-format-address": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/tron-format-address/-/tron-format-address-0.1.8.tgz",
      "integrity": "sha512-oTtzUM43OZhQiv1p2aOVqbnev6mmJHXQrMpS3nn7zVAI/+ffA/aF+Y/vugHtYotckkromRLPEl/SR1HfJjAYQA=="
    },
    "node_modules/ts-node": {
      "version": "10.8.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.8.2.tgz",
      "integrity": "sha512-LYdGnoGddf1D6v8REPtIH+5iq/gTDuZqv2/UJUU7tKjuEU8xVZorBM+buCGNjj+pGEud+sOoM4CX3/YzINpENA==",
      "dev": true,
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ=="
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "node_modules/typescript": {
      "version": "4.7.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.7.4.tgz",
      "integrity": "sha512-C0WQT0gezHuw6AdY1M2jxUO83Rjf0HP7Sk1DtXj6j1EwkQNZrHAg2XPWlq62oqEhYvONq5pkC2Y9oPljWToLmQ==",
      "dev": true,
      "peer": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/utf-8-validate": {
      "version": "5.0.9",
      "resolved": "https://registry.npmjs.org/utf-8-validate/-/utf-8-validate-5.0.9.tgz",
      "integrity": "sha512-Yek7dAy0v3Kl0orwMlvi7TPtiCNrdfHNd7Gcc/pLq4BLXqfAmd0J7OWMizUQnTTJsyjKn02mU7anqwfmUP4J8Q==",
      "hasInstallScript": true,
      "optional": true,
      "dependencies": {
        "node-gyp-build": "^4.3.0"
      },
      "engines": {
        "node": ">=6.14.2"
      }
    },
    "node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true
    },
    "node_modules/wait-on": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/wait-on/-/wait-on-6.0.0.tgz",
      "integrity": "sha512-tnUJr9p5r+bEYXPUdRseolmz5XqJTTj98JgOsfBn7Oz2dxfE2g3zw1jE+Mo8lopM3j3et/Mq1yW7kKX6qw7RVw==",
      "dependencies": {
        "axios": "^0.21.1",
        "joi": "^17.4.0",
        "lodash": "^4.17.21",
        "minimist": "^1.2.5",
        "rxjs": "^7.1.0"
      },
      "bin": {
        "wait-on": "bin/wait-on"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/wait-on/node_modules/axios": {
      "version": "0.21.4",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz",
      "integrity": "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==",
      "dependencies": {
        "follow-redirects": "^1.14.0"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/ws": {
      "version": "7.4.6",
      "resolved": "https://registry.npmjs.org/ws/-/ws-7.4.6.tgz",
      "integrity": "sha512-YmhHDO4MzaDLB+M9ym/mDA5z0naX8j7SIlT8f8z+I0VtzsRbekxEutHSme7NPS2qE8StCYQNUnfWdXta/Yu85A==",
      "engines": {
        "node": ">=8.3.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": "^5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    }
  },
  "dependencies": {
    "@babel/runtime": {
      "version": "7.18.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.18.6.tgz",
      "integrity": "sha512-t9wi7/AW6XtKahAe20Yw0/mMljKq0B1r2fPdvaAdV/KPDZewFXdaaa6K7lxmZBZ8FBNpCiAT6iHPmd6QO9bKfQ==",
      "requires": {
        "regenerator-runtime": "^0.13.4"
      }
    },
    "@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "requires": {
        "@jridgewell/trace-mapping": "0.3.9"
      }
    },
    "@defillama/sdk": {
      "version": "2.3.80",
      "resolved": "https://registry.npmjs.org/@defillama/sdk/-/sdk-2.3.80.tgz",
      "integrity": "sha512-zbSW430yp9rdTUVNiPhf1KHipJkdZe0ZTn1M7F/oRk6VS5h3LcuTQ/LrvAdgf5rlupWP+X0CrSo6ONN/Om+rQg==",
      "requires": {
        "@supercharge/promise-pool": "^2.1.0",
        "ethers": "^5.4.5",
        "graphql": "^15.5.0",
        "graphql-request": "^3.4.0",
        "lodash": "^4.17.21",
        "node-fetch": "^2.6.1"
      }
    },
    "@ethersproject/abi": {
      "version": "5.6.4",
      "resolved": "https://registry.npmjs.org/@ethersproject/abi/-/abi-5.6.4.tgz",
      "integrity": "sha512-TTeZUlCeIHG6527/2goZA6gW5F8Emoc7MrZDC7hhP84aRGvW3TEdTnZR08Ls88YXM1m2SuK42Osw/jSi3uO8gg==",
      "requires": {
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "@ethersproject/abstract-provider": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-provider/-/abstract-provider-5.6.1.tgz",
      "integrity": "sha512-BxlIgogYJtp1FS8Muvj8YfdClk3unZH0vRMVX791Z9INBNT/kuACZ9GzaY1Y4yFq+YSy6/w4gzj3HCRKrK9hsQ==",
      "requires": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/networks": "^5.6.3",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/web": "^5.6.1"
      }
    },
    "@ethersproject/abstract-signer": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-signer/-/abstract-signer-5.6.2.tgz",
      "integrity": "sha512-n1r6lttFBG0t2vNiI3HoWaS/KdOt8xyDjzlP2cuevlWLG6EX0OwcKLyG/Kp/cuwNxdy/ous+R/DEMdTUwWQIjQ==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0"
      }
    },
    "@ethersproject/address": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/address/-/address-5.6.1.tgz",
      "integrity": "sha512-uOgF0kS5MJv9ZvCz7x6T2EXJSzotiybApn4XlOgoTX0xdtyVIJ7pF+6cGPxiEq/dpBiTfMiw7Yc81JcwhSYA0Q==",
      "requires": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/rlp": "^5.6.1"
      }
    },
    "@ethersproject/base64": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/base64/-/base64-5.6.1.tgz",
      "integrity": "sha512-qB76rjop6a0RIYYMiB4Eh/8n+Hxu2NIZm8S/Q7kNo5pmZfXhHGHmS4MinUainiBC54SCyRnwzL+KZjj8zbsSsw==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1"
      }
    },
    "@ethersproject/basex": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/basex/-/basex-5.6.1.tgz",
      "integrity": "sha512-a52MkVz4vuBXR06nvflPMotld1FJWSj2QT0985v7P/emPZO00PucFAkbcmq2vpVU7Ts7umKiSI6SppiLykVWsA==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/properties": "^5.6.0"
      }
    },
    "@ethersproject/bignumber": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/bignumber/-/bignumber-5.6.2.tgz",
      "integrity": "sha512-v7+EEUbhGqT3XJ9LMPsKvXYHFc8eHxTowFCG/HgJErmq4XHJ2WR7aeyICg3uTOAQ7Icn0GFHAohXEhxQHq4Ubw==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "bn.js": "^5.2.1"
      }
    },
    "@ethersproject/bytes": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/bytes/-/bytes-5.6.1.tgz",
      "integrity": "sha512-NwQt7cKn5+ZE4uDn+X5RAXLp46E1chXoaMmrxAyA0rblpxz8t58lVkrHXoRIn0lz1joQElQ8410GqhTqMOwc6g==",
      "requires": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/constants": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/constants/-/constants-5.6.1.tgz",
      "integrity": "sha512-QSq9WVnZbxXYFftrjSjZDUshp6/eKp6qrtdBtUCm0QxCV5z1fG/w3kdlcsjMCQuQHUnAclKoK7XpXMezhRDOLg==",
      "requires": {
        "@ethersproject/bignumber": "^5.6.2"
      }
    },
    "@ethersproject/contracts": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/contracts/-/contracts-5.6.2.tgz",
      "integrity": "sha512-hguUA57BIKi6WY0kHvZp6PwPlWF87MCeB4B7Z7AbUpTxfFXFdn/3b0GmjZPagIHS+3yhcBJDnuEfU4Xz+Ks/8g==",
      "requires": {
        "@ethersproject/abi": "^5.6.3",
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/transactions": "^5.6.2"
      }
    },
    "@ethersproject/hash": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/hash/-/hash-5.6.1.tgz",
      "integrity": "sha512-L1xAHurbaxG8VVul4ankNX5HgQ8PNCTrnVXEiFnE9xoRnaUcgfD12tZINtDinSllxPLCtGwguQxJ5E6keE84pA==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "@ethersproject/hdnode": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/hdnode/-/hdnode-5.6.2.tgz",
      "integrity": "sha512-tERxW8Ccf9CxW2db3WsN01Qao3wFeRsfYY9TCuhmG0xNpl2IO8wgXU3HtWIZ49gUWPggRy4Yg5axU0ACaEKf1Q==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/basex": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/pbkdf2": "^5.6.1",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/wordlists": "^5.6.1"
      }
    },
    "@ethersproject/json-wallets": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/json-wallets/-/json-wallets-5.6.1.tgz",
      "integrity": "sha512-KfyJ6Zwz3kGeX25nLihPwZYlDqamO6pfGKNnVMWWfEVVp42lTfCZVXXy5Ie8IZTN0HKwAngpIPi7gk4IJzgmqQ==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hdnode": "^5.6.2",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/pbkdf2": "^5.6.1",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "aes-js": "3.0.0",
        "scrypt-js": "3.0.1"
      }
    },
    "@ethersproject/keccak256": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/keccak256/-/keccak256-5.6.1.tgz",
      "integrity": "sha512-bB7DQHCTRDooZZdL3lk9wpL0+XuG3XLGHLh3cePnybsO3V0rdCAOQGpn/0R3aODmnTOOkCATJiD2hnL+5bwthA==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "js-sha3": "0.8.0"
      }
    },
    "@ethersproject/logger": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/logger/-/logger-5.6.0.tgz",
      "integrity": "sha512-BiBWllUROH9w+P21RzoxJKzqoqpkyM1pRnEKG69bulE9TSQD8SAIvTQqIMZmmCO8pUNkgLP1wndX1gKghSpBmg=="
    },
    "@ethersproject/networks": {
      "version": "5.6.4",
      "resolved": "https://registry.npmjs.org/@ethersproject/networks/-/networks-5.6.4.tgz",
      "integrity": "sha512-KShHeHPahHI2UlWdtDMn2lJETcbtaJge4k7XSjDR9h79QTd6yQJmv6Cp2ZA4JdqWnhszAOLSuJEd9C0PRw7hSQ==",
      "requires": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/pbkdf2": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/pbkdf2/-/pbkdf2-5.6.1.tgz",
      "integrity": "sha512-k4gRQ+D93zDRPNUfmduNKq065uadC2YjMP/CqwwX5qG6R05f47boq6pLZtV/RnC4NZAYOPH1Cyo54q0c9sshRQ==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/sha2": "^5.6.1"
      }
    },
    "@ethersproject/properties": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/properties/-/properties-5.6.0.tgz",
      "integrity": "sha512-szoOkHskajKePTJSZ46uHUWWkbv7TzP2ypdEK6jGMqJaEt2sb0jCgfBo0gH0m2HBpRixMuJ6TBRaQCF7a9DoCg==",
      "requires": {
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/providers": {
      "version": "5.6.8",
      "resolved": "https://registry.npmjs.org/@ethersproject/providers/-/providers-5.6.8.tgz",
      "integrity": "sha512-Wf+CseT/iOJjrGtAOf3ck9zS7AgPmr2fZ3N97r4+YXN3mBePTG2/bJ8DApl9mVwYL+RpYbNxMEkEp4mPGdwG/w==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/base64": "^5.6.1",
        "@ethersproject/basex": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/networks": "^5.6.3",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/rlp": "^5.6.1",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/strings": "^5.6.1",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/web": "^5.6.1",
        "bech32": "1.1.4",
        "ws": "7.4.6"
      }
    },
    "@ethersproject/random": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/random/-/random-5.6.1.tgz",
      "integrity": "sha512-/wtPNHwbmng+5yi3fkipA8YBT59DdkGRoC2vWk09Dci/q5DlgnMkhIycjHlavrvrjJBkFjO/ueLyT+aUDfc4lA==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/rlp": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/rlp/-/rlp-5.6.1.tgz",
      "integrity": "sha512-uYjmcZx+DKlFUk7a5/W9aQVaoEC7+1MOBgNtvNg13+RnuUwT4F0zTovC0tmay5SmRslb29V1B7Y5KCri46WhuQ==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/sha2": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/sha2/-/sha2-5.6.1.tgz",
      "integrity": "sha512-5K2GyqcW7G4Yo3uenHegbXRPDgARpWUiXc6RiF7b6i/HXUoWlb7uCARh7BAHg7/qT/Q5ydofNwiZcim9qpjB6g==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "hash.js": "1.1.7"
      }
    },
    "@ethersproject/signing-key": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/signing-key/-/signing-key-5.6.2.tgz",
      "integrity": "sha512-jVbu0RuP7EFpw82vHcL+GP35+KaNruVAZM90GxgQnGqB6crhBqW/ozBfFvdeImtmb4qPko0uxXjn8l9jpn0cwQ==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "bn.js": "^5.2.1",
        "elliptic": "6.5.4",
        "hash.js": "1.1.7"
      }
    },
    "@ethersproject/solidity": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/solidity/-/solidity-5.6.1.tgz",
      "integrity": "sha512-KWqVLkUUoLBfL1iwdzUVlkNqAUIFMpbbeH0rgCfKmJp0vFtY4AsaN91gHKo9ZZLkC4UOm3cI3BmMV4N53BOq4g==",
      "requires": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/sha2": "^5.6.1",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "@ethersproject/strings": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/strings/-/strings-5.6.1.tgz",
      "integrity": "sha512-2X1Lgk6Jyfg26MUnsHiT456U9ijxKUybz8IM1Vih+NJxYtXhmvKBcHOmvGqpFSVJ0nQ4ZCoIViR8XlRw1v/+Cw==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/transactions": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/transactions/-/transactions-5.6.2.tgz",
      "integrity": "sha512-BuV63IRPHmJvthNkkt9G70Ullx6AcM+SDc+a8Aw/8Yew6YwT51TcBKEp1P4oOQ/bP25I18JJr7rcFRgFtU9B2Q==",
      "requires": {
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/rlp": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2"
      }
    },
    "@ethersproject/units": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/units/-/units-5.6.1.tgz",
      "integrity": "sha512-rEfSEvMQ7obcx3KWD5EWWx77gqv54K6BKiZzKxkQJqtpriVsICrktIQmKl8ReNToPeIYPnFHpXvKpi068YFZXw==",
      "requires": {
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/constants": "^5.6.1",
        "@ethersproject/logger": "^5.6.0"
      }
    },
    "@ethersproject/wallet": {
      "version": "5.6.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/wallet/-/wallet-5.6.2.tgz",
      "integrity": "sha512-lrgh0FDQPuOnHcF80Q3gHYsSUODp6aJLAdDmDV0xKCN/T7D99ta1jGVhulg3PY8wiXEngD0DfM0I2XKXlrqJfg==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.6.1",
        "@ethersproject/abstract-signer": "^5.6.2",
        "@ethersproject/address": "^5.6.1",
        "@ethersproject/bignumber": "^5.6.2",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/hdnode": "^5.6.2",
        "@ethersproject/json-wallets": "^5.6.1",
        "@ethersproject/keccak256": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/random": "^5.6.1",
        "@ethersproject/signing-key": "^5.6.2",
        "@ethersproject/transactions": "^5.6.2",
        "@ethersproject/wordlists": "^5.6.1"
      }
    },
    "@ethersproject/web": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/web/-/web-5.6.1.tgz",
      "integrity": "sha512-/vSyzaQlNXkO1WV+RneYKqCJwualcUdx/Z3gseVovZP0wIlOFcCE1hkRhKBH8ImKbGQbMl9EAAyJFrJu7V0aqA==",
      "requires": {
        "@ethersproject/base64": "^5.6.1",
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "@ethersproject/wordlists": {
      "version": "5.6.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/wordlists/-/wordlists-5.6.1.tgz",
      "integrity": "sha512-wiPRgBpNbNwCQFoCr8bcWO8o5I810cqO6mkdtKfLKFlLxeCWcnzDi4Alu8iyNzlhYuS9npCwivMbRWF19dyblw==",
      "requires": {
        "@ethersproject/bytes": "^5.6.1",
        "@ethersproject/hash": "^5.6.1",
        "@ethersproject/logger": "^5.6.0",
        "@ethersproject/properties": "^5.6.0",
        "@ethersproject/strings": "^5.6.1"
      }
    },
    "@hapi/hoek": {
      "version": "9.3.0",
      "resolved": "https://registry.npmjs.org/@hapi/hoek/-/hoek-9.3.0.tgz",
      "integrity": "sha512-/c6rf4UJlmHlC9b5BaNvzAcFv7HZ2QHaV0D4/HNlBdvFnvQq8RI4kYdhyPCl7Xj+oWvTWQ8ujhqS53LIgAe6KQ=="
    },
    "@hapi/topo": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@hapi/topo/-/topo-5.1.0.tgz",
      "integrity": "sha512-foQZKJig7Ob0BMAYBfcJk8d77QtOe7Wo4ox7ff1lQYoNNAb6jwcY1ncdoy2e9wQZzvNy7ODZCYJkK8kzmcAnAg==",
      "requires": {
        "@hapi/hoek": "^9.0.0"
      }
    },
    "@jridgewell/resolve-uri": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.0.tgz",
      "integrity": "sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==",
      "dev": true
    },
    "@jridgewell/sourcemap-codec": {
      "version": "1.4.14",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.14.tgz",
      "integrity": "sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==",
      "dev": true
    },
    "@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "requires": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "@project-serum/anchor": {
      "version": "0.18.2",
      "resolved": "https://registry.npmjs.org/@project-serum/anchor/-/anchor-0.18.2.tgz",
      "integrity": "sha512-uyjiN/3Ipp+4hrZRm/hG18HzGLZyvP790LXrCsGO3IWxSl28YRhiGEpKnZycfMW94R7nxdUoE3wY67V+ZHSQBQ==",
      "requires": {
        "@project-serum/borsh": "^0.2.2",
        "@solana/web3.js": "^1.17.0",
        "base64-js": "^1.5.1",
        "bn.js": "^5.1.2",
        "bs58": "^4.0.1",
        "buffer-layout": "^1.2.0",
        "camelcase": "^5.3.1",
        "crypto-hash": "^1.3.0",
        "eventemitter3": "^4.0.7",
        "find": "^0.3.0",
        "js-sha256": "^0.9.0",
        "pako": "^2.0.3",
        "snake-case": "^3.0.4",
        "toml": "^3.0.0"
      }
    },
    "@project-serum/borsh": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/@project-serum/borsh/-/borsh-0.2.5.tgz",
      "integrity": "sha512-UmeUkUoKdQ7rhx6Leve1SssMR/Ghv8qrEiyywyxSWg7ooV7StdpPBhciiy5eB3T0qU1BXvdRNC8TdrkxK7WC5Q==",
      "requires": {
        "bn.js": "^5.1.2",
        "buffer-layout": "^1.2.0"
      }
    },
    "@sideway/address": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@sideway/address/-/address-4.1.4.tgz",
      "integrity": "sha512-7vwq+rOHVWjyXxVlR76Agnvhy8I9rpzjosTESvmhNeXOXdZZB15Fl+TI9x1SiHZH5Jv2wTGduSxFDIaq0m3DUw==",
      "requires": {
        "@hapi/hoek": "^9.0.0"
      }
    },
    "@sideway/formula": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@sideway/formula/-/formula-3.0.0.tgz",
      "integrity": "sha512-vHe7wZ4NOXVfkoRb8T5otiENVlT7a3IAiw7H5M2+GO+9CDgcVUUsX1zalAztCmwyOr2RUTGJdgB+ZvSVqmdHmg=="
    },
    "@sideway/pinpoint": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/@sideway/pinpoint/-/pinpoint-2.0.0.tgz",
      "integrity": "sha512-RNiOoTPkptFtSVzQevY/yWtZwf/RxyVnPy/OcA9HBM3MlGDnBEYL5B41H0MTn0Uec8Hi+2qUtTfG2WWZBmMejQ=="
    },
    "@solana/buffer-layout": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@solana/buffer-layout/-/buffer-layout-4.0.0.tgz",
      "integrity": "sha512-lR0EMP2HC3+Mxwd4YcnZb0smnaDw7Bl2IQWZiTevRH5ZZBZn6VRWn3/92E3qdU4SSImJkA6IDHawOHAnx/qUvQ==",
      "requires": {
        "buffer": "~6.0.3"
      }
    },
    "@solana/buffer-layout-utils": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/@solana/buffer-layout-utils/-/buffer-layout-utils-0.2.0.tgz",
      "integrity": "sha512-szG4sxgJGktbuZYDg2FfNmkMi0DYQoVjN2h7ta1W1hPrwzarcFLBq9UpX1UjNXsNpT9dn+chgprtWGioUAr4/g==",
      "requires": {
        "@solana/buffer-layout": "^4.0.0",
        "@solana/web3.js": "^1.32.0",
        "bigint-buffer": "^1.1.5",
        "bignumber.js": "^9.0.1"
      }
    },
    "@solana/spl-token": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/@solana/spl-token/-/spl-token-0.2.0.tgz",
      "integrity": "sha512-RWcn31OXtdqIxmkzQfB2R+WpsJOVS6rKuvpxJFjvik2LyODd+WN58ZP3Rpjpro03fscGAkzlFuP3r42doRJgyQ==",
      "requires": {
        "@solana/buffer-layout": "^4.0.0",
        "@solana/buffer-layout-utils": "^0.2.0",
        "@solana/web3.js": "^1.32.0",
        "start-server-and-test": "^1.14.0"
      }
    },
    "@solana/web3.js": {
      "version": "1.47.3",
      "resolved": "https://registry.npmjs.org/@solana/web3.js/-/web3.js-1.47.3.tgz",
      "integrity": "sha512-TQJulaN/+b0xXq5EhQAYFwVyOORxSyVJn1EiXupClZm8DY7f9EeUG6vl0FzSAgwEAwXKsgK3sVs/3px2e7H7dQ==",
      "requires": {
        "@babel/runtime": "^7.12.5",
        "@ethersproject/sha2": "^5.5.0",
        "@solana/buffer-layout": "^4.0.0",
        "bigint-buffer": "^1.1.5",
        "bn.js": "^5.0.0",
        "borsh": "^0.7.0",
        "bs58": "^4.0.1",
        "buffer": "6.0.1",
        "fast-stable-stringify": "^1.0.0",
        "jayson": "^3.4.4",
        "js-sha3": "^0.8.0",
        "node-fetch": "2",
        "rpc-websockets": "^7.5.0",
        "secp256k1": "^4.0.2",
        "superstruct": "^0.14.2",
        "tweetnacl": "^1.0.0"
      },
      "dependencies": {
        "buffer": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.1.tgz",
          "integrity": "sha512-rVAXBwEcEoYtxnHSO5iWyhzV/O1WMtkUYWlfdLS7FjU4PnSJJHEfHXi/uHPI5EwltmOA794gN3bm3/pzuctWjQ==",
          "requires": {
            "base64-js": "^1.3.1",
            "ieee754": "^1.2.1"
          }
        }
      }
    },
    "@supercharge/promise-pool": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@supercharge/promise-pool/-/promise-pool-2.3.0.tgz",
      "integrity": "sha512-KLf3JBWW4JymplvT/c5JCZhc4KrNE9EBf15FPjvklQiGcoUczSLInpV23iV5dITnvktJlwQ5xq08wfNwBk71Rg=="
    },
    "@tsconfig/node10": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.9.tgz",
      "integrity": "sha512-jNsYVVxU8v5g43Erja32laIDHXeoNvFEpX33OK4d6hljo3jDhCBDhx5dhCCTMWUojscpAagGiRkBKxpdl9fxqA==",
      "dev": true
    },
    "@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true
    },
    "@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true
    },
    "@tsconfig/node16": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.3.tgz",
      "integrity": "sha512-yOlFc+7UtL/89t2ZhjPvvB/DeAr3r+Dq58IgzsFkOAvVC6NMJXmCGjbptdXdR9qsX7pKcTL+s87FtYREi2dEEQ==",
      "dev": true
    },
    "@types/connect": {
      "version": "3.4.35",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.35.tgz",
      "integrity": "sha512-cdeYyv4KWoEgpBISTxWvqYsVy444DOqehiF3fM3ne10AmJ62RSyNkUnxMJXHQWRQQX2eR94m5y1IZyDwBjV9FQ==",
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/express-serve-static-core": {
      "version": "4.17.29",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.17.29.tgz",
      "integrity": "sha512-uMd++6dMKS32EOuw1Uli3e3BPgdLIXmezcfHv7N4c1s3gkhikBplORPpMq3fuWkxncZN1reb16d5n8yhQ80x7Q==",
      "requires": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*"
      }
    },
    "@types/lodash": {
      "version": "4.14.182",
      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.14.182.tgz",
      "integrity": "sha512-/THyiqyQAP9AfARo4pF+aCGcyiQ94tX/Is2I7HofNRqoYLgN1PBoOWu2/zTA5zMxzP5EFutMtWtGAFRKUe961Q=="
    },
    "@types/node": {
      "version": "18.0.3",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.0.3.tgz",
      "integrity": "sha512-HzNRZtp4eepNitP+BD6k2L6DROIDG4Q0fm4x+dwfsr6LGmROENnok75VGw40628xf+iR24WeMFcHuuBDUAzzsQ=="
    },
    "@types/qs": {
      "version": "6.9.7",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.7.tgz",
      "integrity": "sha512-FGa1F62FT09qcrueBA6qYTrJPVDzah9a+493+o2PCXsesWHIn27G98TsSMs3WPNbZIEj4+VJf6saSFpvD+3Zsw=="
    },
    "@types/range-parser": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.4.tgz",
      "integrity": "sha512-EEhsLsD6UsDM1yFhAvy0Cjr6VwmpMWqFBCb9w07wVugF7w9nfajxLuVmngTIpgS6svCnm6Vaw+MZhoDCKnOfsw=="
    },
    "@types/ws": {
      "version": "7.4.7",
      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-7.4.7.tgz",
      "integrity": "sha512-JQbbmxZTZehdc2iszGKs5oC3NFnjeay7mtAWrdt7qNtAVK0g19muApzAy4bm9byz79xa2ZnO/BOBC2R8RC5Lww==",
      "requires": {
        "@types/node": "*"
      }
    },
    "acorn": {
      "version": "8.7.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.7.1.tgz",
      "integrity": "sha512-Xx54uLJQZ19lKygFXOWsscKUbsBZW0CPykPhVQdhIeIwrbPmJzqeASDInc8nKBnp/JT6igTs82qPXz069H8I/A==",
      "dev": true
    },
    "acorn-walk": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.2.0.tgz",
      "integrity": "sha512-k+iyHEuPgSw6SbuDpGQM+06HQUa04DZ3o+F6CSzXMvvI5KMvnaEqXe+YVe555R9nn6GPt404fos4wcgpw12SDA==",
      "dev": true
    },
    "aes-js": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/aes-js/-/aes-js-3.0.0.tgz",
      "integrity": "sha512-H7wUZRn8WpTq9jocdxQ2c8x2sKo9ZVmzfRE13GiNJXfp7NcKYEdvl3vspKjXox6RIG2VtaRe4JFvxG4rqp2Zuw=="
    },
    "arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true
    },
    "async": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/async/-/async-3.2.4.tgz",
      "integrity": "sha512-iAB+JbDEGXhyIUavoDl9WP/Jj106Kz9DEn1DPgYw5ruDn0e3Wgi3sKFm55sASdGBNOQB8F59d9qQ7deqrHA8wQ=="
    },
    "async-retry": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/async-retry/-/async-retry-1.3.3.tgz",
      "integrity": "sha512-wfr/jstw9xNi/0teMHrRW7dsz3Lt5ARhYNZ2ewpadnhaIp5mbALhOAP+EAdsC7t4Z6wqsDVv9+W6gm1Dk9mEyw==",
      "requires": {
        "retry": "0.13.1"
      }
    },
    "asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "axios": {
      "version": "0.26.1",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.26.1.tgz",
      "integrity": "sha512-fPwcX4EvnSHuInCMItEhAGnaSEXRBjtzh9fOtsE6E1G6p7vl7edEeZe11QHf18+6+9gR5PbKV/sGKNaD8YaMeA==",
      "requires": {
        "follow-redirects": "^1.14.8"
      }
    },
    "base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA=="
    },
    "bech32": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/bech32/-/bech32-1.1.4.tgz",
      "integrity": "sha512-s0IrSOzLlbvX7yp4WBfPITzpAU8sqQcpsmwXDiKwrG4r491vwCO/XpejasRNl0piBMe/DvP4Tz0mIS/X1DPJBQ=="
    },
    "bigint-buffer": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/bigint-buffer/-/bigint-buffer-1.1.5.tgz",
      "integrity": "sha512-trfYco6AoZ+rKhKnxA0hgX0HAbVP/s808/EuDSe2JDzUnCp/xAsli35Orvk67UrTEcwuxZqYZDmfA2RXJgxVvA==",
      "requires": {
        "bindings": "^1.3.0"
      }
    },
    "bignumber.js": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.0.2.tgz",
      "integrity": "sha512-GAcQvbpsM0pUb0zw1EI0KhQEZ+lRwR5fYaAp3vPOYuP7aDvGy6cVN6XHLauvF8SOga2y0dcLcjt3iQDTSEliyw=="
    },
    "bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "requires": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "blakejs": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/blakejs/-/blakejs-1.2.1.tgz",
      "integrity": "sha512-QXUSXI3QVc/gJME0dBpXrag1kbzOqCjCX8/b54ntNyW6sjtoqxqRk3LTmXzaJoh71zMsDCjM+47jS7XiwN/+fQ=="
    },
    "bluebird": {
      "version": "3.7.2",
      "resolved": "https://registry.npmjs.org/bluebird/-/bluebird-3.7.2.tgz",
      "integrity": "sha512-XpNj6GDQzdfW+r2Wnn7xiSAd7TM3jzkxGXBGTtWKuSXv1xUV+azxAm8jdWZN06QTQk+2N2XB9jRDkvbmQmcRtg=="
    },
    "bn.js": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.1.tgz",
      "integrity": "sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ=="
    },
    "borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "requires": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w=="
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "buffer": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
      "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
      "requires": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.2.1"
      }
    },
    "buffer-layout": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/buffer-layout/-/buffer-layout-1.2.2.tgz",
      "integrity": "sha512-kWSuLN694+KTk8SrYvCqwP2WcgQjoRCiF5b4QDvkkz8EmgD+aWAIceGFKMIAdmF/pH+vpgNV3d3kAKorcdAmWA=="
    },
    "bufferutil": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/bufferutil/-/bufferutil-4.0.6.tgz",
      "integrity": "sha512-jduaYOYtnio4aIAyc6UbvPCVcgq7nYpVnucyxr6eCYg/Woad9Hf/oxxBRDnGGjPfjUm6j5O/uBWhIu4iLebFaw==",
      "optional": true,
      "requires": {
        "node-gyp-build": "^4.3.0"
      }
    },
    "camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg=="
    },
    "check-more-types": {
      "version": "2.24.0",
      "resolved": "https://registry.npmjs.org/check-more-types/-/check-more-types-2.24.0.tgz",
      "integrity": "sha512-Pj779qHxV2tuapviy1bSZNEL1maXr13bPYpsvSDB68HlYcYuhlDrmGd63i0JHMCLKzc7rUSNIrpdJlhVlNwrxA=="
    },
    "combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "requires": {
        "delayed-stream": "~1.0.0"
      }
    },
    "commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
    },
    "create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true
    },
    "cross-fetch": {
      "version": "3.1.5",
      "resolved": "https://registry.npmjs.org/cross-fetch/-/cross-fetch-3.1.5.tgz",
      "integrity": "sha512-lvb1SBsI0Z7GDwmuid+mU3kWVBwTVUbe7S0H52yaaAdQOXq2YktTCZdlAcNKFzE6QtRz0snpw9bNiPeOIkkQvw==",
      "requires": {
        "node-fetch": "2.6.7"
      }
    },
    "cross-spawn": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
      "requires": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      }
    },
    "crypto-hash": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/crypto-hash/-/crypto-hash-1.3.0.tgz",
      "integrity": "sha512-lyAZ0EMyjDkVvz8WOeVnuCPvKVBXcMv1l5SVqO1yC7PzTwrD/pPje/BIRbWhMoPe436U+Y2nD7f5bFx0kt+Sbg=="
    },
    "curve25519-js": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/curve25519-js/-/curve25519-js-0.0.4.tgz",
      "integrity": "sha512-axn2UMEnkhyDUPWOwVKBMVIzSQy2ejH2xRGy1wq81dqRwApXfIzfbE3hIX0ZRFBIihf/KDqK158DLwESu4AK1w=="
    },
    "debug": {
      "version": "4.3.2",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.2.tgz",
      "integrity": "sha512-mOp8wKcvj7XxC78zLgw/ZA+6TSgkoE2C/ienthhRD298T7UNwAg9diBpLRxC0mOezLl4B0xV7M0cCO6P/O0Xhw==",
      "requires": {
        "ms": "2.1.2"
      }
    },
    "delay": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/delay/-/delay-5.0.0.tgz",
      "integrity": "sha512-ReEBKkIfe4ya47wlPYf/gu5ib6yUG0/Aez0JQZQz94kiWtRQvZIQbTiehsnwHvLSWJnQdhVeqYue7Id1dKr0qw=="
    },
    "delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ=="
    },
    "diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true
    },
    "dot-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
      "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
      "requires": {
        "no-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "dotenv": {
      "version": "8.6.0",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-8.6.0.tgz",
      "integrity": "sha512-IrPdXQsk2BbzvCBGBOTmmSH5SodmqZNt4ERAZDmW4CT+tL8VtvinqywuANaFu4bOMWki16nqf0e4oC0QIaDr/g=="
    },
    "duplexer": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/duplexer/-/duplexer-0.1.2.tgz",
      "integrity": "sha512-jtD6YG370ZCIi/9GTaJKQxWTZD045+4R4hTk/x1UyoqadyJ9x9CgSi1RlVDQF8U2sxLLSnFkCaMihqljHIWgMg=="
    },
    "elliptic": {
      "version": "6.5.4",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
      "integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
      "requires": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.12.0",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
          "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
        }
      }
    },
    "es6-promise": {
      "version": "4.2.8",
      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
      "integrity": "sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w=="
    },
    "es6-promisify": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
      "integrity": "sha512-C+d6UdsYDk0lMebHNR4S2NybQMMngAOnOwYBQjTOiv0MkoJMP0Myw2mgpDLBcpfCmRLxyFqYhS/CfOENq4SJhQ==",
      "requires": {
        "es6-promise": "^4.0.3"
      }
    },
    "ethers": {
      "version": "5.6.9",
      "resolved": "https://registry.npmjs.org/ethers/-/ethers-5.6.9.tgz",
      "integrity": "sha512-lMGC2zv9HC5EC+8r429WaWu3uWJUCgUCt8xxKCFqkrFuBDZXDYIdzDUECxzjf2BMF8IVBByY1EBoGSL3RTm8RA==",
      "requires": {
        "@ethersproject/abi": "5.6.4",
        "@ethersproject/abstract-provider": "5.6.1",
        "@ethersproject/abstract-signer": "5.6.2",
        "@ethersproject/address": "5.6.1",
        "@ethersproject/base64": "5.6.1",
        "@ethersproject/basex": "5.6.1",
        "@ethersproject/bignumber": "5.6.2",
        "@ethersproject/bytes": "5.6.1",
        "@ethersproject/constants": "5.6.1",
        "@ethersproject/contracts": "5.6.2",
        "@ethersproject/hash": "5.6.1",
        "@ethersproject/hdnode": "5.6.2",
        "@ethersproject/json-wallets": "5.6.1",
        "@ethersproject/keccak256": "5.6.1",
        "@ethersproject/logger": "5.6.0",
        "@ethersproject/networks": "5.6.4",
        "@ethersproject/pbkdf2": "5.6.1",
        "@ethersproject/properties": "5.6.0",
        "@ethersproject/providers": "5.6.8",
        "@ethersproject/random": "5.6.1",
        "@ethersproject/rlp": "5.6.1",
        "@ethersproject/sha2": "5.6.1",
        "@ethersproject/signing-key": "5.6.2",
        "@ethersproject/solidity": "5.6.1",
        "@ethersproject/strings": "5.6.1",
        "@ethersproject/transactions": "5.6.2",
        "@ethersproject/units": "5.6.1",
        "@ethersproject/wallet": "5.6.2",
        "@ethersproject/web": "5.6.1",
        "@ethersproject/wordlists": "5.6.1"
      }
    },
    "event-stream": {
      "version": "3.3.4",
      "resolved": "https://registry.npmjs.org/event-stream/-/event-stream-3.3.4.tgz",
      "integrity": "sha512-QHpkERcGsR0T7Qm3HNJSyXKEEj8AHNxkY3PK8TS2KJvQ7NiSHe3DDpwVKKtoYprL/AreyzFBeIkBIWChAqn60g==",
      "requires": {
        "duplexer": "~0.1.1",
        "from": "~0",
        "map-stream": "~0.1.0",
        "pause-stream": "0.0.11",
        "split": "0.3",
        "stream-combiner": "~0.0.4",
        "through": "~2.3.1"
      }
    },
    "eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw=="
    },
    "execa": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/execa/-/execa-5.1.1.tgz",
      "integrity": "sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==",
      "requires": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      }
    },
    "extract-files": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/extract-files/-/extract-files-9.0.0.tgz",
      "integrity": "sha512-CvdFfHkC95B4bBBk36hcEmvdR2awOdhhVUYH6S/zrVj3477zven/fJMYg7121h4T1xHZC+tetUpubpAhxwI7hQ=="
    },
    "eyes": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/eyes/-/eyes-0.1.8.tgz",
      "integrity": "sha512-GipyPsXO1anza0AOZdy69Im7hGFCNB7Y/NGjDlZGJ3GJJLtwNSb2vrzYrTYJRrRloVx7pl+bhUaTB8yiccPvFQ=="
    },
    "fast-stable-stringify": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fast-stable-stringify/-/fast-stable-stringify-1.0.0.tgz",
      "integrity": "sha512-wpYMUmFu5f00Sm0cj2pfivpmawLZ0NKdviQ4w9zJeR8JVtOpOxHmLaJuj0vxvGqMJQWyP/COUkF75/57OKyRag=="
    },
    "file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw=="
    },
    "find": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/find/-/find-0.3.0.tgz",
      "integrity": "sha512-iSd+O4OEYV/I36Zl8MdYJO0xD82wH528SaCieTVHhclgiYNe9y+yPKSwK+A7/WsmHL1EZ+pYUJBXWTL5qofksw==",
      "requires": {
        "traverse-chain": "~0.1.0"
      }
    },
    "follow-redirects": {
      "version": "1.15.1",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.1.tgz",
      "integrity": "sha512-yLAMQs+k0b2m7cVxpS1VKJVvoz7SS9Td1zss3XRwXj+ZDH00RJgnuLx7E44wx02kQLrdM3aOOy+FpzS7+8OizA=="
    },
    "form-data": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-3.0.1.tgz",
      "integrity": "sha512-RHkBKtLWUVwd7SqRIvCZMEvAMoGUp0XU+seQiZejj0COz3RI3hWP4sCv3gZWWLjJTd7rGwcsF5eKZGii0r/hbg==",
      "requires": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      }
    },
    "from": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/from/-/from-0.1.7.tgz",
      "integrity": "sha512-twe20eF1OxVxp/ML/kq2p1uc6KvFK/+vs8WjEbeKmV2He22MKm7YF2ANIt+EOqhJ5L3K/SuuPhk0hWQDjOM23g=="
    },
    "get-stream": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg=="
    },
    "graphql": {
      "version": "15.8.0",
      "resolved": "https://registry.npmjs.org/graphql/-/graphql-15.8.0.tgz",
      "integrity": "sha512-5gghUc24tP9HRznNpV2+FIoq3xKkj5dTQqf4v0CpdPbFVwFkWoxOM+o+2OC9ZSvjEMTjfmG9QT+gcvggTwW1zw=="
    },
    "graphql-request": {
      "version": "3.7.0",
      "resolved": "https://registry.npmjs.org/graphql-request/-/graphql-request-3.7.0.tgz",
      "integrity": "sha512-dw5PxHCgBneN2DDNqpWu8QkbbJ07oOziy8z+bK/TAXufsOLaETuVO4GkXrbs0WjhdKhBMN3BkpN/RIvUHkmNUQ==",
      "requires": {
        "cross-fetch": "^3.0.6",
        "extract-files": "^9.0.0",
        "form-data": "^3.0.0"
      }
    },
    "hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "requires": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "hi-base32": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/hi-base32/-/hi-base32-0.5.1.tgz",
      "integrity": "sha512-EmBBpvdYh/4XxsnUybsPag6VikPYnN30td+vQk+GI3qpahVEG9+gTkG0aXVxTjBqQ5T6ijbWIu77O+C5WFWsnA=="
    },
    "hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "requires": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "human-signals": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
      "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw=="
    },
    "ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA=="
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg=="
    },
    "isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw=="
    },
    "isomorphic-ws": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/isomorphic-ws/-/isomorphic-ws-4.0.1.tgz",
      "integrity": "sha512-BhBvN2MBpWTaSHdWRb/bwdZJ1WaehQ2L1KngkCkfLUGF0mAWAT1sQUQacEmQ0jXkFw/czDXPNQSL5u2/Krsz1w==",
      "requires": {}
    },
    "jayson": {
      "version": "3.6.6",
      "resolved": "https://registry.npmjs.org/jayson/-/jayson-3.6.6.tgz",
      "integrity": "sha512-f71uvrAWTtrwoww6MKcl9phQTC+56AopLyEenWvKVAIMz+q0oVGj6tenLZ7Z6UiPBkJtKLj4kt0tACllFQruGQ==",
      "requires": {
        "@types/connect": "^3.4.33",
        "@types/express-serve-static-core": "^4.17.9",
        "@types/lodash": "^4.14.159",
        "@types/node": "^12.12.54",
        "@types/ws": "^7.4.4",
        "commander": "^2.20.3",
        "delay": "^5.0.0",
        "es6-promisify": "^5.0.0",
        "eyes": "^0.1.8",
        "isomorphic-ws": "^4.0.1",
        "json-stringify-safe": "^5.0.1",
        "JSONStream": "^1.3.5",
        "lodash": "^4.17.20",
        "uuid": "^8.3.2",
        "ws": "^7.4.5"
      },
      "dependencies": {
        "@types/node": {
          "version": "12.20.55",
          "resolved": "https://registry.npmjs.org/@types/node/-/node-12.20.55.tgz",
          "integrity": "sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ=="
        }
      }
    },
    "joi": {
      "version": "17.6.0",
      "resolved": "https://registry.npmjs.org/joi/-/joi-17.6.0.tgz",
      "integrity": "sha512-OX5dG6DTbcr/kbMFj0KGYxuew69HPcAE3K/sZpEV2nP6e/j/C0HV+HNiBPCASxdx5T7DMoa0s8UeHWMnb6n2zw==",
      "requires": {
        "@hapi/hoek": "^9.0.0",
        "@hapi/topo": "^5.0.0",
        "@sideway/address": "^4.1.3",
        "@sideway/formula": "^3.0.0",
        "@sideway/pinpoint": "^2.0.0"
      }
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "js-sha3": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha3/-/js-sha3-0.8.0.tgz",
      "integrity": "sha512-gF1cRrHhIzNfToc802P800N8PpXS+evLLXfsVpowqmAFR9uwbi89WvXg2QspOmXL8QL86J4T1EpFu+yUkwJY3Q=="
    },
    "js-sha512": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha512/-/js-sha512-0.8.0.tgz",
      "integrity": "sha512-PWsmefG6Jkodqt+ePTvBZCSMFgN7Clckjd0O7su3I0+BW2QWUTJNzjktHsztGLhncP2h8mcF9V9Y2Ha59pAViQ=="
    },
    "json-stringify-safe": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
      "integrity": "sha512-ZClg6AaYvamvYEE82d3Iyd3vSSIjQ+odgjaTzRuO3s7toCdFKczob2i0zCh7JE8kWn17yvAWhUVxvqGwUalsRA=="
    },
    "jsonparse": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/jsonparse/-/jsonparse-1.3.1.tgz",
      "integrity": "sha512-POQXvpdL69+CluYsillJ7SUhKvytYjW9vG/GKpnf+xP8UWgYEM/RaMzHHofbALDiKbbP1W8UEYmgGl39WkPZsg=="
    },
    "JSONStream": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.5.tgz",
      "integrity": "sha512-E+iruNOY8VV9s4JEbe1aNEm6MiszPRr/UfcHMz0TQh1BXSxHK+ASV1R6W4HpjBhSeS+54PIsAMCBmwD06LLsqQ==",
      "requires": {
        "jsonparse": "^1.2.0",
        "through": ">=2.2.7 <3"
      }
    },
    "just-performance": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/just-performance/-/just-performance-4.3.0.tgz",
      "integrity": "sha512-L7RjvtJsL0QO8xFs5wEoDDzzJwoiowRw6Rn/GnvldlchS2JQr9wFYPiwZcDfrbbujEKqKN0tvENdbjXdYhDp5Q=="
    },
    "lazy-ass": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/lazy-ass/-/lazy-ass-1.6.0.tgz",
      "integrity": "sha512-cc8oEVoctTvsFZ/Oje/kGnHbpWHYBe8IAJe4C0QNc3t8uM/0Y8+erSz/7Y1ALuXTEZTMvxXwO6YbX1ey3ujiZw=="
    },
    "limiter": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/limiter/-/limiter-2.1.0.tgz",
      "integrity": "sha512-361TYz6iay6n+9KvUUImqdLuFigK+K79qrUtBsXhJTLdH4rIt/r1y8r1iozwh8KbZNpujbFTSh74mJ7bwbAMOw==",
      "requires": {
        "just-performance": "4.3.0"
      }
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "lower-case": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
      "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
      "requires": {
        "tslib": "^2.0.3"
      }
    },
    "make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true
    },
    "map-stream": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/map-stream/-/map-stream-0.1.0.tgz",
      "integrity": "sha512-CkYQrPYZfWnu/DAmVCpTSX/xHpKZ80eKh2lAkyA6AJTef6bW+6JpbQZN5rofum7da+SyN1bi5ctTm+lTfcCW3g=="
    },
    "merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w=="
    },
    "mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="
    },
    "mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "requires": {
        "mime-db": "1.52.0"
      }
    },
    "mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg=="
    },
    "minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A=="
    },
    "minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg=="
    },
    "minimist": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz",
      "integrity": "sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q=="
    },
    "miscreant": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/miscreant/-/miscreant-0.3.2.tgz",
      "integrity": "sha512-fL9KxsQz9BJB2KGPMHFrReioywkiomBiuaLk6EuChijK0BsJsIKJXdVomR+/bPj5mvbFD6wM0CM3bZio9g7OHA=="
    },
    "ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "no-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
      "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
      "requires": {
        "lower-case": "^2.0.2",
        "tslib": "^2.0.3"
      }
    },
    "node-addon-api": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-2.0.2.tgz",
      "integrity": "sha512-Ntyt4AIXyaLIuMHF6IOoTakB3K+RWxwtsHNRxllEoA6vPwP9o4866g6YWDLUdnucilZhmkxiHwHr11gAENw+QA=="
    },
    "node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "requires": {
        "whatwg-url": "^5.0.0"
      }
    },
    "node-gyp-build": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/node-gyp-build/-/node-gyp-build-4.5.0.tgz",
      "integrity": "sha512-2iGbaQBV+ITgCz76ZEjmhUKAKVf7xfY1sRl4UiKQspfZMH2h06SyhNsnSVy50cwkFQDGLyif6m/6uFXHkOZ6rg=="
    },
    "npm-run-path": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
      "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
      "requires": {
        "path-key": "^3.0.0"
      }
    },
    "onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "requires": {
        "mimic-fn": "^2.1.0"
      }
    },
    "pako": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/pako/-/pako-2.0.4.tgz",
      "integrity": "sha512-v8tweI900AUkZN6heMU/4Uy4cXRc2AYNRggVmTR+dEncawDJgCdLMximOVA2p4qO57WMynangsfGRb5WD6L1Bg=="
    },
    "path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q=="
    },
    "pause-stream": {
      "version": "0.0.11",
      "resolved": "https://registry.npmjs.org/pause-stream/-/pause-stream-0.0.11.tgz",
      "integrity": "sha512-e3FBlXLmN/D1S+zHzanP4E/4Z60oFAa3O051qt1pxa7DEJWKAyil6upYVXCWadEnuoqa4Pkc9oUx9zsxYeRv8A==",
      "requires": {
        "through": "~2.3"
      }
    },
    "ps-tree": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/ps-tree/-/ps-tree-1.2.0.tgz",
      "integrity": "sha512-0VnamPPYHl4uaU/nSFeZZpR21QAWRz+sRv4iW9+v/GS/J5U5iZB5BNN6J0RMoOvdx2gWM2+ZFMIm58q24e4UYA==",
      "requires": {
        "event-stream": "=3.3.4"
      }
    },
    "regenerator-runtime": {
      "version": "0.13.9",
      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.9.tgz",
      "integrity": "sha512-p3VT+cOEgxFsRRA9X4lkI1E+k2/CtnKtU4gcxyaCUreilL/vqI6CdZ3wxVUx3UOUg+gnUOQQcRI7BmSI656MYA=="
    },
    "retry": {
      "version": "0.13.1",
      "resolved": "https://registry.npmjs.org/retry/-/retry-0.13.1.tgz",
      "integrity": "sha512-XQBQ3I8W1Cge0Seh+6gjj03LbmRFWuoszgK9ooCpwYIrhhoO80pfq4cUkU5DkknwfOfFteRwlZ56PYOGYyFWdg=="
    },
    "rpc-websockets": {
      "version": "7.5.0",
      "resolved": "https://registry.npmjs.org/rpc-websockets/-/rpc-websockets-7.5.0.tgz",
      "integrity": "sha512-9tIRi1uZGy7YmDjErf1Ax3wtqdSSLIlnmL5OtOzgd5eqPKbsPpwDP5whUDO2LQay3Xp0CcHlcNSGzacNRluBaQ==",
      "requires": {
        "@babel/runtime": "^7.17.2",
        "bufferutil": "^4.0.1",
        "eventemitter3": "^4.0.7",
        "utf-8-validate": "^5.0.2",
        "uuid": "^8.3.2",
        "ws": "^8.5.0"
      },
      "dependencies": {
        "ws": {
          "version": "8.8.0",
          "resolved": "https://registry.npmjs.org/ws/-/ws-8.8.0.tgz",
          "integrity": "sha512-JDAgSYQ1ksuwqfChJusw1LSJ8BizJ2e/vVu5Lxjq3YvNJNlROv1ui4i+c/kUUrPheBvQl4c5UbERhTwKa6QBJQ==",
          "requires": {}
        }
      }
    },
    "rxjs": {
      "version": "7.5.5",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.5.5.tgz",
      "integrity": "sha512-sy+H0pQofO95VDmFLzyaw9xNJU4KTRSwQIGM6+iG3SypAtCiLDzpeG8sJrNCWn2Up9km+KhkvTdbkrdy+yzZdw==",
      "requires": {
        "tslib": "^2.1.0"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "scrypt-js": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/scrypt-js/-/scrypt-js-3.0.1.tgz",
      "integrity": "sha512-cdwTTnqPu0Hyvf5in5asVdZocVDTNRmR7XEcJuIzMjJeSHybHl7vpB66AzwTaIg6CLSbtjcxc8fqcySfnTkccA=="
    },
    "secp256k1": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/secp256k1/-/secp256k1-4.0.3.tgz",
      "integrity": "sha512-NLZVf+ROMxwtEj3Xa562qgv2BK5e2WNmXPiOdVIPLgs6lyTzMvBq0aWTYMI5XCP9jZMVKOcqZLw/Wc4vDkuxhA==",
      "requires": {
        "elliptic": "^6.5.4",
        "node-addon-api": "^2.0.0",
        "node-gyp-build": "^4.2.0"
      }
    },
    "shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "requires": {
        "shebang-regex": "^3.0.0"
      }
    },
    "shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A=="
    },
    "signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ=="
    },
    "snake-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
      "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
      "requires": {
        "dot-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "split": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/split/-/split-0.3.3.tgz",
      "integrity": "sha512-wD2AeVmxXRBoX44wAycgjVpMhvbwdI2aZjCkvfNcH1YqHQvJVa1duWc73OyVGJUc05fhFaTZeQ/PYsrmyH0JVA==",
      "requires": {
        "through": "2"
      }
    },
    "start-server-and-test": {
      "version": "1.14.0",
      "resolved": "https://registry.npmjs.org/start-server-and-test/-/start-server-and-test-1.14.0.tgz",
      "integrity": "sha512-on5ELuxO2K0t8EmNj9MtVlFqwBMxfWOhu4U7uZD1xccVpFlOQKR93CSe0u98iQzfNxRyaNTb/CdadbNllplTsw==",
      "requires": {
        "bluebird": "3.7.2",
        "check-more-types": "2.24.0",
        "debug": "4.3.2",
        "execa": "5.1.1",
        "lazy-ass": "1.6.0",
        "ps-tree": "1.2.0",
        "wait-on": "6.0.0"
      }
    },
    "stream-combiner": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/stream-combiner/-/stream-combiner-0.0.4.tgz",
      "integrity": "sha512-rT00SPnTVyRsaSz5zgSPma/aHSOic5U1prhYdRy5HS2kTZviFpmDgzilbtsJsxiroqACmayynDN/9VzIbX5DOw==",
      "requires": {
        "duplexer": "~0.1.1"
      }
    },
    "strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA=="
    },
    "superstruct": {
      "version": "0.14.2",
      "resolved": "https://registry.npmjs.org/superstruct/-/superstruct-0.14.2.tgz",
      "integrity": "sha512-nPewA6m9mR3d6k7WkZ8N8zpTWfenFH3q9pA2PkuiZxINr9DKB2+40wEQf0ixn8VaGuJ78AB6iWOtStI+/4FKZQ=="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg=="
    },
    "toml": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/toml/-/toml-3.0.0.tgz",
      "integrity": "sha512-y/mWCZinnvxjTKYhJ+pYxwD0mRLVvOtdS2Awbgxln6iEnt4rk0yBxeSBHkGJcPucRiG0e55mwWp+g/05rsrd6w=="
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "traverse-chain": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/traverse-chain/-/traverse-chain-0.1.0.tgz",
      "integrity": "sha512-up6Yvai4PYKhpNp5PkYtx50m3KbwQrqDwbuZP/ItyL64YEWHAvH6Md83LFLV/GRSk/BoUVwwgUzX6SOQSbsfAg=="
    },
    "tron-format-address": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/tron-format-address/-/tron-format-address-0.1.8.tgz",
      "integrity": "sha512-oTtzUM43OZhQiv1p2aOVqbnev6mmJHXQrMpS3nn7zVAI/+ffA/aF+Y/vugHtYotckkromRLPEl/SR1HfJjAYQA=="
    },
    "ts-node": {
      "version": "10.8.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.8.2.tgz",
      "integrity": "sha512-LYdGnoGddf1D6v8REPtIH+5iq/gTDuZqv2/UJUU7tKjuEU8xVZorBM+buCGNjj+pGEud+sOoM4CX3/YzINpENA==",
      "dev": true,
      "requires": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      }
    },
    "tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ=="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "typescript": {
      "version": "4.7.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.7.4.tgz",
      "integrity": "sha512-C0WQT0gezHuw6AdY1M2jxUO83Rjf0HP7Sk1DtXj6j1EwkQNZrHAg2XPWlq62oqEhYvONq5pkC2Y9oPljWToLmQ==",
      "dev": true,
      "peer": true
    },
    "utf-8-validate": {
      "version": "5.0.9",
      "resolved": "https://registry.npmjs.org/utf-8-validate/-/utf-8-validate-5.0.9.tgz",
      "integrity": "sha512-Yek7dAy0v3Kl0orwMlvi7TPtiCNrdfHNd7Gcc/pLq4BLXqfAmd0J7OWMizUQnTTJsyjKn02mU7anqwfmUP4J8Q==",
      "optional": true,
      "requires": {
        "node-gyp-build": "^4.3.0"
      }
    },
    "uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg=="
    },
    "v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true
    },
    "wait-on": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/wait-on/-/wait-on-6.0.0.tgz",
      "integrity": "sha512-tnUJr9p5r+bEYXPUdRseolmz5XqJTTj98JgOsfBn7Oz2dxfE2g3zw1jE+Mo8lopM3j3et/Mq1yW7kKX6qw7RVw==",
      "requires": {
        "axios": "^0.21.1",
        "joi": "^17.4.0",
        "lodash": "^4.17.21",
        "minimist": "^1.2.5",
        "rxjs": "^7.1.0"
      },
      "dependencies": {
        "axios": {
          "version": "0.21.4",
          "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz",
          "integrity": "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==",
          "requires": {
            "follow-redirects": "^1.14.0"
          }
        }
      }
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "requires": {
        "isexe": "^2.0.0"
      }
    },
    "ws": {
      "version": "7.4.6",
      "resolved": "https://registry.npmjs.org/ws/-/ws-7.4.6.tgz",
      "integrity": "sha512-YmhHDO4MzaDLB+M9ym/mDA5z0naX8j7SIlT8f8z+I0VtzsRbekxEutHSme7NPS2qE8StCYQNUnfWdXta/Yu85A==",
      "requires": {}
    },
    "yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true
    }
  }
}

'''
'''--- package.json ---
{
  "name": "defillama-adapters",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "weeklyChanges": "git pull && git diff $(git log -1 --before=@{7.days.ago} --format=%H) --stat | grep -E \"projects/\" | cut -d / -f 2 | cut -d \" \" -f 1 | uniq | wc -l",
    "dev": "babel-watch curve.js",
    "test-interactive": "node utils/testInteractive"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@defillama/sdk": "^2.3.66",
    "@project-serum/anchor": "^0.18.2",
    "@solana/spl-token": "^0.2.0",
    "@solana/web3.js": "^1.36.0",
    "@supercharge/promise-pool": "^2.1.0",
    "async": "^3.2.3",
    "async-retry": "^1.3.1",
    "axios": "^0.26.0",
    "bignumber.js": "^9.0.1",
    "blakejs": "^1.2.1",
    "borsh": "^0.7.0",
    "curve25519-js": "^0.0.4",
    "dotenv": "^8.6.0",
    "ethers": "^5.6.5",
    "graphql": "^15.5.0",
    "graphql-request": "^3.6.1",
    "hi-base32": "^0.5.1",
    "js-sha512": "^0.8.0",
    "limiter": "2.1.0",
    "miscreant": "^0.3.2",
    "tron-format-address": "^0.1.8"
  },
  "overrides": {
    "ansi-regex": "5.0.1",
    "mocha": {
      "nanoid": "3.3.1"
    },
    "@project-serum/anchor": {
      "nth-check": "2.0.1"
    }
  },
  "description": "",
  "devDependencies": {
    "ts-node": "^10.8.1"
  }
}

'''
'''--- projects/01/index.js ---
const { getTokenBalance, getTokenSupply } = require('../helper/solana')

async function tvl() {
    const [
      usdc,
      wsol,
      usdt,
      ether,
      wbtc,
      msol,
      ust
    ] = await Promise.all([
        getTokenBalance("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("So11111111111111111111111111111111111111112", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
        getTokenBalance("9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i", "HjHSNe8hhvZ8hKCRrhKg1DGiGPd9NYQbUjT1SQRDo4kZ"),
    ])
    return {
        'usd-coin': usdc,
        'solana':wsol,
        'msol': msol,
        'tether': usdt,
        'terrausd': ust,
        'ethereum': ether,
        'bitcoin': wbtc,
    }
}
module.exports = {
    timetravel: false,
    solana: {
        tvl,
    },
    methodology: `To obtain the tvl we're getting the vault accounts information where user deposited collateral is stored.`,
}

'''
'''--- projects/0vix/abi.json ---
{
  "0vix_getAllMarkets": {"inputs":[],"name":"getAllMarkets","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
  "market_underlying": {"inputs":[],"name":"underlying","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
  "market_totalBorrows": {"inputs":[],"name":"totalBorrows","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"} 
}
'''
'''--- projects/0vix/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi')
const { getBlock } = require('../helper/getBlock');
const { sumTokens } = require('../helper/unwrapLPs');

const master0vix = '0x8849f1a0cB6b5D6076aB150546EddEe193754F1C'
const oMATIC = '0xE554E874c9c60E45F1Debd479389C76230ae25A8'
const matic = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270' 
const chain = 'polygon'
const transform = t => `polygon:${t}`

async function get0vixUnderlyings(chain, block) {
  const {output: markets} = await sdk.api.abi.call({
    abi: abi['0vix_getAllMarkets'],
    target: master0vix,
    chain,
    block,
  })
  const markets_minus_matic = markets.filter(m => m.toLowerCase() !== oMATIC.toLowerCase() )
  const {output: underlyings} = await sdk.api.abi.multiCall({
    abi: abi['market_underlying'],
    calls: markets_minus_matic.map(m => ({ target: m })),
    chain,
    block,
  })
  return {markets, markets_minus_matic, underlyings}
}
async function tvl (timestamp, ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, chain, chainBlocks, true);
  const balances = {
    [transform(matic)]: (await sdk.api.eth.getBalance({target: oMATIC, chain, block})).output
  };

  const {underlyings} = await get0vixUnderlyings(chain, block)
  const tokensAndOwners = underlyings.map(u => [u.output, u.input.target])
  await sumTokens(balances, tokensAndOwners, block, chain, transform)

  return balances
}

async function borrowed (timestamp, ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, chain, chainBlocks, true);

  const {markets_minus_matic, underlyings} = await get0vixUnderlyings(chain, block)
  // Put MATIC underlyings at the end
  underlyings.push({
    input: {target: oMATIC}, 
    output: matic
  })
  markets_minus_matic.push(oMATIC)

  const {output: totalBorrows} = await sdk.api.abi.multiCall({
    abi: abi['market_totalBorrows'],
    calls: markets_minus_matic.map(m => ({ target: m })),
    chain,
    block,
  })
  const balances = Object.fromEntries(totalBorrows.map((borrow, idx) => [transform(underlyings[idx].output), borrow.output]))
  return balances
}

module.exports = {
  polygon: {
    tvl, 
    borrowed
  },
  methodology: 'Count balance of erc20 underlying of each market, plus matic balance of the oMATIC market',
}
'''
'''--- projects/0xDAO/erc20.json ---
[
  {
    "inputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "_minter", "type": "address" }
    ],
    "name": "addMinter",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      { "internalType": "address", "name": "account", "type": "address" }
    ],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      {
        "internalType": "uint256",
        "name": "subtractedValue",
        "type": "uint256"
      }
    ],
    "name": "decreaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "governance",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "addedValue", "type": "uint256" }
    ],
    "name": "increaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "account", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "mint",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "minters",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "_minter", "type": "address" }
    ],
    "name": "removeMinter",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "_governance", "type": "address" }
    ],
    "name": "setGovernance",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "sender", "type": "address" },
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/0xDAO/index.js ---
const oxLensAbi = require("./oxLens.json");
const solidlyLensAbi = require("./solidlyLens.json");
const veAbi = require("./ve.json");
const partnerRewardsPoolAddress = "0xDA006E87DB89e1C5213D4bfBa771e53c91D920aC";
const oxdV1RewardsPoolAddress = "0xDA000779663501df3C9Bc308E7cEc70cE6F04211";
const oxSolidRewardPoolAddress = "0xDA0067ec0925eBD6D583553139587522310Bec60";
const vlOxdAddress = "0xDA00527EDAabCe6F97D89aDb10395f719E5559b9";
const oxdAddress = "0xc5A9848b9d145965d821AaeC8fA32aaEE026492d";
const solidAddress = "0x888EF71766ca594DED1F0FA3AE64eD2941740A20";
const veAddress = "0xcBd8fEa77c2452255f59743f55A3Ea9d83b3c72b";
const oxSolidAddress = "0xDA0053F0bEfCbcaC208A3f867BB243716734D809";
const sanitize = require("./sanitizeWeb3Response.js");

const { masterChefExports, standardPoolInfoAbi, addFundsInMasterChef } = require('../helper/masterchef')
const sdk = require('@defillama/sdk')
const { default: BigNumber } = require('bignumber.js')

const shareValue = { "inputs": [], "name": "getShareValue", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
const xSCREAM = "0xe3D17C7e840ec140a7A51ACA351a482231760824"
const xCREDIT = "0xd9e28749e80D867d5d14217416BFf0e668C10645"
const shareTarot = { "inputs": [{ "internalType": "uint256", "name": "_share", "type": "uint256" }], "name": "shareValuedAsUnderlying", "outputs": [{ "internalType": "uint256", "name": "underlyingAmount_", "type": "uint256" }], "stateMutability": "nonpayable", "type": "function" }
const xTAROT = "0x74D1D2A851e339B8cB953716445Be7E8aBdf92F4"

const fBEET = "0xfcef8a994209d6916EB2C86cDD2AFD60Aa6F54b1"

async function tvl(time, ethBlock, chainBlocks) {
    // 0xDAO Master Chef
    const balances = {}
    const chain = 'fantom'
    const block = chainBlocks[chain]
    const calldata = {
        chain, block
    }
    const transform = addr => `fantom:${addr}`
    await addFundsInMasterChef(balances, "0xa7821c3e9fc1bf961e280510c471031120716c3d", block, chain,
        transform, standardPoolInfoAbi, [], true, true, "0xc165d941481e68696f43ee6e99bfb2b23e0e3114")

    const screamShare = await sdk.api.abi.call({
        ...calldata,
        target: xSCREAM,
        abi: shareValue
    })
    sdk.util.sumSingleBalance(balances, transform("0xe0654C8e6fd4D733349ac7E09f6f23DA256bF475"),
        BigNumber(screamShare.output).times(balances[transform(xSCREAM)]).div(1e18).toFixed(0))
    delete balances[transform(xSCREAM)]

    const creditShare = await sdk.api.abi.call({
        ...calldata,
        target: xCREDIT,
        abi: shareValue
    })
    sdk.util.sumSingleBalance(balances, transform("0x77128dfdd0ac859b33f44050c6fa272f34872b5e"),
        BigNumber(creditShare.output).times(balances[transform(xCREDIT)]).div(1e18).toFixed(0))
    delete balances[transform(xCREDIT)]

    const tarotShare = await sdk.api.abi.call({
        ...calldata,
        target: xTAROT,
        abi: shareTarot,
        params: balances[transform(xTAROT)]
    })
    sdk.util.sumSingleBalance(balances, transform("0xc5e2b037d30a390e62180970b3aa4e91868764cd"),
        tarotShare.output)
    delete balances[transform(xTAROT)]

    sdk.util.sumSingleBalance(balances, transform("0xf24bcf4d1e507740041c9cfd2dddb29585adce1e"),
        balances[transform(fBEET)])
    delete balances[transform(fBEET)]

    // 0xDAO Core
    const oxLensAddress = "0xDA00137c79B30bfE06d04733349d98Cf06320e69";
    const solidlyLensAddress = "0xDA0024F99A9889E8F48930614c27Ba41DD447c45";
    // const oxd = new web3.eth.Contract(erc20Abi, oxdAddress);

    // Fetch pools addresses
    const { output: oxPoolsAddresses } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: oxLensAddress,
        abi: oxLensAbi.find(i => i.name === 'oxPoolsAddresses')
    })
    const pageSize = 50;
    const poolsMap = {};
    let currentPage = 0;

    // Add pools
    const addPools = (pools, reservesData) => {
        pools.forEach((pool, index) => {
            const solidlyPoolAddress = pool.poolData.id;
            const reserveData = reservesData.find(
                (data) => data.id === solidlyPoolAddress
            );
            const newPool = pool;
            newPool.poolData = {
                ...pool.poolData,
                ...reserveData,
            };
            const shareOfTotalSupply = new BigNumber(newPool.totalSupply).div(newPool.poolData.totalSupply).toFixed()
            newPool.shareOfTotalSupply = shareOfTotalSupply;
            let token0Reserve = new BigNumber(newPool.poolData.token0Reserve).times(shareOfTotalSupply).toFixed(0);
            let token1Reserve = new BigNumber(newPool.poolData.token1Reserve).times(shareOfTotalSupply).toFixed(0);
            if (isNaN(token0Reserve)) {
                token0Reserve = "0"
            }
            if (isNaN(token1Reserve)) {
                token1Reserve = "0"
            }
            newPool.token0Reserve = token0Reserve;
            newPool.token1Reserve = token1Reserve;
            poolsMap[pool.id] = newPool;
        });
    };
    while (true) {
        const start = currentPage * pageSize;
        const end = start + pageSize;
        const addresses = oxPoolsAddresses.slice(start, end);
        if (addresses.length === 0) {
            break;
        }
        currentPage += 1;

        const { output: poolsData } = await sdk.api.abi.call({
            block,
            chain: 'fantom',
            params: [addresses],
            target: oxLensAddress,
            abi: oxLensAbi.find(i => i.name === 'oxPoolsData')
        })
        const solidlyPoolsAddresses = poolsData.map((pool) => pool.poolData.id);
        const { output: reservesData } = await sdk.api.abi.call({
            block,
            chain: 'fantom',
            target: solidlyLensAddress,
            params: [solidlyPoolsAddresses],
            abi: solidlyLensAbi.find(i => i.name === 'poolsReservesInfo')
        })
        addPools(
            sanitize(poolsData),
            sanitize(reservesData)
        );
    }
    const pools = Object.values(poolsMap);

    // Add TVL from pools to balances
    const addBalance = (tokenAddress, amount) => {
        const fantomTokenAddress = `fantom:${tokenAddress}`
        const existingBalance = balances[fantomTokenAddress];
        if (existingBalance) {
            balances[fantomTokenAddress] = new BigNumber(existingBalance).plus(amount).toFixed(0)
        } else {
            balances[fantomTokenAddress] = amount;
        }
    }
    pools.forEach(pool => {
        const token0 = pool.poolData.token0Address;
        const token1 = pool.poolData.token1Address;
        const amount0 = pool.token0Reserve;
        const amount1 = pool.token1Reserve;
        addBalance(token0, amount0);
        addBalance(token1, amount1);
    });

    // Add locked SOLID
    const { output: { amount: lockedSolidAmount } } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: veAddress,
        params: 2,
        abi: veAbi.find(i => i.name === 'locked')
    })
    addBalance(solidAddress, lockedSolidAmount);

    // Add staking pools TVL
    const { output: oxdV1RewardsPoolBalance } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: oxdV1RewardsPoolAddress,
        abi: 'erc20:totalSupply'
    })
    const { output: oxSolidRewardsPoolBalance } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: oxSolidRewardPoolAddress,
        abi: 'erc20:totalSupply'
    })
    const { output: partnerRewardsPoolBalance } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: partnerRewardsPoolAddress,
        abi: 'erc20:totalSupply'
    })

    addBalance(oxSolidAddress, oxdV1RewardsPoolBalance);
    addBalance(oxSolidAddress, partnerRewardsPoolBalance);
    addBalance(oxSolidAddress, oxSolidRewardsPoolBalance);

    // Add vote locked OXD
    const { output: voteLockedOxdBalance } = await sdk.api.abi.call({
        block,
        chain: 'fantom',
        target: oxdAddress,
        params: vlOxdAddress,
        abi: 'erc20:balanceOf'
    })
    addBalance(oxdAddress, voteLockedOxdBalance);

    return balances
}

module.exports = {
    fantom: {
        tvl
    }
}

'''
'''--- projects/0xDAO/oxLens.json ---
[
  {
    "inputs": [],
    "name": "oxPoolsAddresses",
    "outputs": [
      { "internalType": "address[]", "name": "", "type": "address[]" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "_oxPoolsAddresses",
        "type": "address[]"
      }
    ],
    "name": "oxPoolsData",
    "outputs": [
      {
        "components": [
          { "internalType": "address", "name": "id", "type": "address" },
          {
            "internalType": "address",
            "name": "stakingAddress",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "stakedTotalSupply",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "totalSupply",
            "type": "uint256"
          },
          {
            "components": [
              { "internalType": "address", "name": "id", "type": "address" },
              { "internalType": "string", "name": "symbol", "type": "string" },
              { "internalType": "bool", "name": "stable", "type": "bool" },
              {
                "internalType": "address",
                "name": "token0Address",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "token1Address",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "gaugeAddress",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "bribeAddress",
                "type": "address"
              },
              {
                "internalType": "address[]",
                "name": "bribeTokensAddresses",
                "type": "address[]"
              },
              { "internalType": "address", "name": "fees", "type": "address" },
              {
                "internalType": "uint256",
                "name": "totalSupply",
                "type": "uint256"
              }
            ],
            "internalType": "struct ISolidlyLens.Pool",
            "name": "poolData",
            "type": "tuple"
          }
        ],
        "internalType": "struct OxLens.OxPoolData[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/0xDAO/sanitizeWeb3Response.js ---
/**
 * @notice Converts web3 tuple into javascript object recursively
 * @author 0xDAO
 */ 
const sanitize = (data) => {
    let dataKeys = {};
    let object = {};
    let array = [];
  
    // Find all keys (Object.keys will not work here, first we must iterate)
    Object.entries(data).forEach(([key]) => {
      dataKeys[key] = true;
    });
    dataKeys = Object.keys(dataKeys);
    const keysLength = dataKeys.length;
  
    // Detect whether the item is an object or an array
    const isObject = keysLength > data.length;
    if (isObject) {
      dataKeys = dataKeys.slice(dataKeys.length / 2, dataKeys.length);
      dataKeys.forEach((key) => {
        let dataValue = data[key];
        if (Array.isArray(dataValue)) {
          // Recursively sanitize
          dataValue = sanitize(dataValue);
        }
        object[key] = dataValue;
      });
      return object;
    } else {
      // Detect whether the item is an array of objects or an array of values
      if (Array.isArray(data)) {
        dataKeys.forEach((key) => {
          // Recursively sanitize
          array.push(sanitize(data[key]));
        });
      } else {
        return data;
      }
      return array;
    }
  };
  
  module.exports = sanitize;
  
'''
'''--- projects/0xDAO/solidlyLens.json ---
[
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "_poolsAddresses",
        "type": "address[]"
      }
    ],
    "name": "poolsReservesInfo",
    "outputs": [
      {
        "components": [
          { "internalType": "address", "name": "id", "type": "address" },
          {
            "internalType": "address",
            "name": "token0Address",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "token1Address",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "token0Reserve",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "token1Reserve",
            "type": "uint256"
          },
          {
            "internalType": "uint8",
            "name": "token0Decimals",
            "type": "uint8"
          },
          { "internalType": "uint8", "name": "token1Decimals", "type": "uint8" }
        ],
        "internalType": "struct ISolidlyLens.PoolReserveData[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }]
'''
'''--- projects/0xDAO/ve.json ---
[{
  "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
  "name": "locked",
  "outputs": [
    { "internalType": "int128", "name": "amount", "type": "int128" },
    { "internalType": "uint256", "name": "end", "type": "uint256" }
  ],
  "stateMutability": "view",
  "type": "function"
}]
'''
'''--- projects/0xLend/index.js ---
const { usdCompoundExports } = require("../helper/compound");
module.exports = {
    kcc: usdCompoundExports("0x337d8719f70D514367aBe780F7c1eAd1c0113Bc7", "kcc", "0x309f1639018e8B272126C4B99af442AA25Dcd1F2")
}
'''
'''--- projects/0x_nodes/index.js ---
const { getChainTransform } = require("../helper/portedTokens")
const { GraphQLClient, gql } = require('graphql-request')
const { getBlock } = require('../helper/getBlock')
const { staking } = require('../helper/staking')
const utils = require('../helper/utils')
const retry = require('async-retry')
const sdk = require('@defillama/sdk')
const CONFIG = {
  ethereum: {
    uri: 'https://api.thegraph.com/subgraphs/name/0xnodes/system11',
    strategy_token: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', //wETH
    bios_token: '0xAACa86B876ca011844b5798ECA7a67591A9743C8',
    kernel_addr: '0xcfcff4eb4799cda732e5b27c3a36a9ce82dbabe0'
  },
  bsc: {
    uri: 'https://api.thegraph.com/subgraphs/name/0xnodes/system11-bsc',
    strategy_token: '0x418D75f65a02b3D53B2418FB8E1fe493759c7605', //wBNB
    bios_token: '0xcf87d3d50a98a7832f5cfdf99ae1b88c7cfba4a7',
    kernel_addr: '0x37c12de5367fa61ad05e2bf2d032d7ce5dd31793'
  },
  polygon: {
    uri: 'https://api.thegraph.com/subgraphs/name/0xnodes/system11-polygon',
    strategy_token: '0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0', //wMATIC
    bios_token: '0xe20d2df5041f8ed06976846470f727295cdd4d23',
    kernel_addr: '0x267720b5d8dcbdb847fc333ccc68cb284648b816'
  },
  fantom: {
    uri: 'https://api.thegraph.com/subgraphs/name/0xnodes/system11-fantom',
    strategy_token: '0x4e15361fd6b4bb609fa63c81a2be19d873717870', //wFTM
    bios_token: '0x75e0eb8e6d92ab832bb11e46c041d06a89ac5f0d',
    kernel_addr: '0x9db0e84ea53c5a3c000a721bb4295a6053b3de78'
  },
  avax: {
    uri: 'https://api.thegraph.com/subgraphs/name/0xnodes/system11-avalanche',
    strategy_token: '0x85f138bfEE4ef8e540890CFb48F620571d67Eda3', //wAVAX
    bios_token: '0xd7783a275e53fc6746dedfbad4a06059937502a4',
    kernel_addr: '0x479ea3715682e6255234e788875bdbded6faae41'
  },
  metis: {
    uri: 'https://andromeda-graph.metis.io/subgraphs/name/0xnodes/System11-metis',
    strategy_token: '0x9E32b13ce7f2E80A01932B42553652E053D6ed8e', //METIS
    bios_token: '0x3405a1bd46b85c5c029483fbecf2f3e611026e45',
    kernel_addr: '0xa1DA47F6563e7B17075FcA61DeDC4622aE2F3912'
  },
}
function offset(chain) {
  switch (chain) {
    case 'ethereum':
      return 110
    case 'bsc':
      return 600
    case 'polygon':
      return 750
    case 'fantom':
      return 1500
    case 'metis':
      return 500
    case 'avax':
      return 750
  };
};
function chainTvl(chain) {
    return async (timestamp, ethBlock, chainBlocks) => {
        const { [chain]:{ uri }} = CONFIG
        const { [chain]:{ strategy_token }} = CONFIG
        var graphQLClient = new GraphQLClient(uri)
        const block = (await getBlock(timestamp, chain, chainBlocks)) - offset(chain)
        var query = gql`{strategyTokenBalances(block: {number: `+block+`}){amount}}`
        const results = await retry(async bail => await graphQLClient.request(query))
        let amount = 0
        for (let i = 0; i < results.strategyTokenBalances.length; i++) {  //loop through the array
          amount += Number(results.strategyTokenBalances[i].amount); //Do the math!
        }
        const balances = {}
        sdk.util.sumSingleBalance(balances, strategy_token, amount)
        return balances
    }
}
function stakingTvl(chain) {
      const { [chain]:{ bios_token }} = CONFIG
      const { [chain]:{ kernel_addr }} = CONFIG
      return staking(kernel_addr, bios_token, chain)
}
function chainExports(chainTvl, stakingTvl, chains){
  const chainTvls = chains.reduce((obj, chain) => ({
    ...obj,
    [chain === 'avax' ? 'avalanche' : chain]: {
      tvl:chainTvl(chain),
      staking: stakingTvl(chain)
    }
  }), {})
  return chainTvls
}
const tvlExports = chainExports(chainTvl, stakingTvl , ['ethereum', 'bsc', 'polygon', 'fantom', 'metis', 'avax'])
module.exports = {
  methodology: ` Counts the number of wrapped native tokens in all yield strategies across all the chains the protocol is deployed on
  + staking counts the number of BIOS tokens staked in the kernels across all the chains (PFA: Protocol Fee Accruals by staking assets)`,
  start: 1633046400, // Friday 1. October 2021 00:00:00 GMT
  ...tvlExports
}

'''
'''--- projects/0x_nodes/readme.md ---
Twitter Link: https://twitter.com/0x_nodes

List of audit links if any: https://github.com/0xNODES/_audits/tree/main/Halborn

Website Link: https://0xnodes.io/

Logo (High resolution, preferably in .svg and .png, for application on both white and black backgrounds. Will be shown with rounded borders): https://github.com/0xNODES/DefiLlama-Adapters/blob/0x_nodes-adapter/projects/0x_nodes/0x_nodes_v.png

Current TVL: total 4.50 M + staking 1.69 M

Chain: Ethereum, BSC, Polygon, Fantom, Andromeda, Avalanche

Coingecko ID (so your TVL can appear on Coingecko): (https://api.coingecko.com/api/v3/coins/list): 10139

Coinmarketcap ID (so your TVL can appear on Coinmarketcap): (https://api.coinmarketcap.com/data-api/v3/map/all?listing_status=active,inactive,untracked&start=1&limit=10000): bios

Short Description (to be shown on DefiLlama): 0xNODES is a modularized cross chain yield aggregation protocol utilizing collateralized assets through synthetic swaps.

Token address and ticker if any: 0xAACa86B876ca011844b5798ECA7a67591A9743C8 (BIOS) https://etherscan.io/token/0xAACa86B876ca011844b5798ECA7a67591A9743C8

Category: 7 Yield Aggregator

Oracle used (Chainlink/Band/API3/TWAP or any other that you are using):

forkedFrom (Does your project originate from another project): No

methodology (what is being counted as tvl, how is tvl being calculated): 'Counts the number of wrapped native tokens in all yield strategies across all the chains the protocol is deployed on + staking counts the number of BIOS tokens staked in the kernels across all the chains (PFA: Protocol Fee Accruals by staking assets)'

'''
'''--- projects/1bch/index.js ---
const sdk = require('@defillama/sdk');
const { getBlock } = require('../helper/getBlock');
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')

const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04";
const rBCH = "0xb4602588E5F1F9653B6F234206c91552E457fAcB";
const FACTORY = "0x3dC4e6aC26df957a908cfE1C0E6019545D08319b";
const MASTERBREEDER = "0xeC0A7496e66a206181034F86B261DDDC1A2c406E";
const rBCH_WBCH_LP = "0xb9659B524447F53FF1019952A6eeDBb99776Ab4A";
const COREASSETNAME = "bitcoin-cash";
const CHAIN = "smartbch";

async function bchMasterChef(timestamp, ethBlock, chainBlocks) {
    const block = await getBlock(timestamp, CHAIN, chainBlocks, true);

    const stakedBCH = (await sdk.api.erc20.balanceOf({
        target: WBCH,
        owner: MASTERBREEDER,
        chain: CHAIN,
        block: block,
        decimals: 18
    })).output;

    return {
        [COREASSETNAME]: Number(stakedBCH)
    }
}

const bchDexTvl = calculateUsdUniTvl(FACTORY, CHAIN, WBCH, [rBCH], COREASSETNAME)

module.exports = {
    misrepresentedTokens: true,
    methodology: "Factory address (" + FACTORY + ") is used to find the LP pairs on smartBCH. TVL is equal to AMMs liquidity plus the extra staking balance and masterchef pools.",
    smartbch: {
        tvl: sdk.util.sumChainTvls([bchDexTvl, bchMasterChef]),
        masterchef: bchMasterChef,
        staking: stakingPricedLP(MASTERBREEDER, rBCH, "smartbch", rBCH_WBCH_LP, COREASSETNAME),
    },
}

'''
'''--- projects/1beam/abi.json ---
{
  "swap": {
    "getTokenBalances": {
      "inputs": [],
      "name": "getTokenBalances",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "getTokens": {
      "inputs": [],
      "name": "getTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
}

'''
'''--- projects/1beam/index.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');
const Abis = require('./abi.json');
const {getTokenId} = require('./utils')

const Contracts = {
  moonbeam: {
    pools: {
      'ob3p': '0x04e274f709e1ae71aff4f994b4267143ec6a381a',
      'ob3pbusd': '0x7e758319d46E0A053220e3728B3eE47a1979316a',
    },
    ignoredLps: ['0xe7a7dfb89f84a0cf850bcd399d0ec906ab232e9d'],
  }
};

const poolTvl = async (chain, poolAddress, block) => {
  const [balances, tokens] = await Promise.all([
    sdk.api.abi.call({
      target: poolAddress,
      abi: Abis.swap.getTokenBalances,
      chain: chain,
      block,
    }),
    sdk.api.abi.call({
      target: poolAddress,
      abi: Abis.swap.getTokens,
      chain: chain,
      block,
    }),
  ]);

  const sum = {};

  tokens.output.forEach((token, i) => {
    if (
      Contracts[chain].ignoredLps &&
      Contracts[chain].ignoredLps.includes(token.toLowerCase())
    ) {
      return;
    }
    const [symbol, decimals] = getTokenId(token.toLowerCase());
    sum[symbol] = new BigNumber(balances.output[i]).div(new BigNumber(10).pow(decimals)).toNumber()
  });

  return sum;
};

const moonbeamTvl = async (timestamp, ethBlock, chainBlocks) => {
  let block = chainBlocks['moonbeam'];
  const tvl = {};

  for (let address of Object.values(Contracts.moonbeam.pools)) {
    const balances = await poolTvl(
      'moonbeam',
      address,
      block,
    );

    Object.entries(balances).forEach(([token, value]) => {
      sdk.util.sumSingleBalance(tvl, token, value);
    });
  }

  return tvl;
};

module.exports = {
  moonbeam: {
    tvl: moonbeamTvl,
  },
  
};

'''
'''--- projects/1beam/utils.js ---
const TokenMaps = {
  '0x765277eebeca2e31912c9946eae1021199b39c61': ['dai', 18],
  '0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b': ['usd-coin', 6],
  '0xefaeee334f0fd1712f9a8cc375f427d9cdd40d73': ['tether', 6],
  '0xa649325aa7c5093d12d6f98eb4378deae68ce23f': ['binance-usd', 18]
}

/**
 * 
 * @param {string} address token address in lower case
 * @returns coingecko id and decimals
 */
function getTokenId(address) {
  return TokenMaps[address]
}

module.exports = {
  getTokenId
}
'''
'''--- projects/1inch.js ---
const retry = require('./helper/retry')
const axios = require("axios");
const { GraphQLClient, gql } = require('graphql-request')

async function fetch() {

    var endpoint = 'https://api.thegraph.com/subgraphs/name/1inch-exchange/oneinch-liquidity-protocol-v2'
    var graphQLClient = new GraphQLClient(endpoint)

    var query = gql`
    {
      mooniswapFactories(first: 1) {
        totalLiquidityUSD
        totalLiquidityETH
      }
    }
    `;

    const results = await retry(async bail => await graphQLClient.request(query))
    return parseFloat(results.mooniswapFactories[0].totalLiquidityUSD)
}

module.exports = {
  fetch
}
'''
'''--- projects/1swap/abi-moonriver.json ---
{
  "1Swap": {
    "getTokenBalances": {
      "inputs": [],
      "name": "getTokenBalances",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "getTokens": {
      "inputs": [],
      "name": "getTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
}

'''
'''--- projects/1swap/index.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');
const abiMoonriver = require('./abi-moonriver.json');

const Contracts = {
  moonriver: {
    pools: {
      '1s3p': '0xb578a396e56388CbF398a12Dea9eb6B01b7c777f',
      '1s3pbusd': '0x008db1Cef0958e7f87A107b58F0dede796ce7962',
      '1s3pmim': '0x23A479A83e4FaC12C2096Ab1D79Ea7a788f4489E',
      '1s3pfrax': '0xF223B776C86E1ADa8fD205dBb804D1Fd6C87E05E',
      '1s3pavaxusd': '0x7179F2C31763f395082489588534F4abb3Dd4Be6',
      '1s3pwanusd': '0x02A105939Dc0C47cb6bD04f320dAa77Bd9E3Bb0D',
    },
    ignoredLps: ['0x17da5445f3cd02b3f1cd820e6de55983fe80cf85'] ,
  }
};

const poolTvl = async (chain, poolAddress, block) => {
  const [balances, tokens] = await Promise.all([
    sdk.api.abi.call({
      target: poolAddress,
      abi: abiMoonriver['1Swap'].getTokenBalances,
      chain: chain,
      block,
    }),
    sdk.api.abi.call({
      target: poolAddress,
      abi: abiMoonriver['1Swap'].getTokens,
      chain: chain,
      block,
    }),
  ]);

  const sum = {};

  tokens.output.forEach((token, i) => {
    if (
      Contracts[chain].ignoredLps &&
      Contracts[chain].ignoredLps.includes(token.toLowerCase())
    ) {
      return;
    }
    const [symbol, decimals] = getTokenId(token.toLowerCase());
    sum[symbol] = new BigNumber(balances.output[i]).div(new BigNumber(10).pow(decimals)).toNumber()
  });

  return sum;
};

const moonriverTvl = async (timestamp, ethBlock, chainBlocks) => {
  let block = chainBlocks['moonriver'];
  const tvl = {};

  for (let address of Object.values(Contracts.moonriver.pools)) {
    const balances = await poolTvl(
      'moonriver',
      address,
      block,
    );

    Object.entries(balances).forEach(([token, value]) => {
      sdk.util.sumSingleBalance(tvl, token, value);
    });
  }

  return tvl;
};

function getTokenId(address) {
  switch(address) {
      case '0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d':
          return ['usd-coin', 6]
      case '0xb44a9b6905af7c801311e8f4e76932ee959c663c':
          return ['tether', 6]
      case '0x80a16016cc4a2e6a2caca8a4a498b1699ff0f844':
          return ['dai', 18]
      case '0x5d9ab5522c64e1f6ef5e3627eccc093f56167818':
          return ['binance-usd', 18]
      case '0x0cae51e1032e8461f4806e26332c030e34de3adb':
          return ['magic-internet-money', 18]
      case '0x965f84d915a9efa2dd81b653e3ae736555d945f4':
        return ['frax', 18];
      case '0xd8b99eae34afdf1a9bfa5770066404ee4468d0f2': // AVAX bridge
        return ['usd-coin', 6];
      case '0xf97c8556af29089d5d1627096958187b11f1915c': // AVAX bridge
        return ['tether', 6];
      case '0x26dfff76d9123a1c79279abc29b676c48a8bd77e': // AVAX bridge
        return ['dai', 18];
      case '0x748134b5f553f2bcbd78c6826de99a70274bdeb3': // WANCHAIN bridge
        return ['usd-coin', 6];
      case '0xe936caa7f6d9f5c9e907111fcaf7c351c184cda7': // WANCHAIN bridge
        return ['tether', 6];
      default:
          return false;
  };
};

module.exports = {
  moonriver: {
    tvl: moonriverTvl,
  },
};

'''
'''--- projects/2doge/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { staking, stakingPricedLP } = require("../helper/staking");

const tombTokenAddress = "0xDD057bCcB72982753266A903Feda154608e54468";
const tshareTokenAddress = "0x0c55339a139acd3a8ba07a9abad345b05c4bf804";
const tshareRewardPoolAddress = "0x60a92645fe34ce7c16f72986e0f980297152535a";
const masonryAddress = "0xe8EA0828FF7BF03c868a2370b83Bc06F50d4eEd9";
const treasuryAddress = "0xE21Fa89dF84902CD88de322A0f5c7024A1b85B68";

const ftmLPs = [
  "0x8DFcA21813df0f0d04157779D489bD30843c6D73", // 2dogeFtmLpAddress
  "0xB254973e067AF44eB4D506e7117A33C4F3F77783", //2sdogeFtmLpAddress
];

async function calcPool2(masterchef, lps, block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.map((p) => ({
        target: p,
        params: masterchef,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );
  return balances;
}

async function ftmPool2(timestamp, block, chainBlocks) {
  return await calcPool2(tshareRewardPoolAddress, ftmLPs, chainBlocks.fantom, "fantom");
}

async function treasury(timestamp, block, chainBlocks) {
  let balance = (await sdk.api.erc20.balanceOf({
    target: tombTokenAddress,
    owner: treasuryAddress, 
    block: chainBlocks.fantom,
    chain: 'fantom'
  })).output;

  return { [`fantom:${tombTokenAddress}`] : balance }
}
module.exports = {
  methodology: "Pool2 deposits consist of 2DOGE/FTM and 2SDOGE/FTM LP tokens deposits while the staking TVL consists of the 2SDOGES tokens locked within the Masonry contract(0xe8EA0828FF7BF03c868a2370b83Bc06F50d4eEd9).",
  fantom: {
    tvl: async () => ({}),
    pool2: ftmPool2,
    staking: stakingPricedLP(masonryAddress, tshareTokenAddress, "fantom", "0xB254973e067AF44eB4D506e7117A33C4F3F77783", "fantom"),
    treasury
  },
};

'''
'''--- projects/2omb-finance/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTime",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accTombPerShare",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "isStarted",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "symbol": {
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/2omb-finance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformFantomAddress } = require("../helper/portedTokens");
const { staking } = require("../helper/staking");
const { pool2Exports } = require("../helper/pool2");

const token = "0x7a6e4e3cc2ac9924605dca4ba31d1831c84b44ae";
const shares = "0xc54a1684fd1bef1f077a336e6be4bd9a3096a6ca";
const masonry = "0x627A83B6f8743c89d58F17F994D3F7f69c32F461";
const rewardPool = "0x8D426Eb8C7E19b8F13817b07C0AB55d30d209A96";
const ThreeOmbGenesisPoolsContract =
  "0xcB0b0419E6a1F46Be89C1c1eeeAf9172b7125b29";
const pool2LPs = [
  "0xbdC7DFb7B88183e87f003ca6B5a2F81202343478", // 2OMB-FTM spLP
  "0x6398ACBBAB2561553a9e458Ab67dCFbD58944e52", // 2SHARE-WFTM spLP
];
const omb3Tvl = async (chainBlocks) => {
  const balances = {};

  const lpPositions = [];
  let poolInfoReturn;
  let i = 0;
  do {
    try {
      const token = (
        await sdk.api.abi.call({
          abi: abi.poolInfo,
          target: ThreeOmbGenesisPoolsContract,
          params: i,
          chain: "fantom",
          block: chainBlocks["fantom"],
        })
      ).output.token;

      const getTokenBalance = (
        await sdk.api.abi.call({
          abi: 'erc20:balanceOf',
          target: token,
          params: ThreeOmbGenesisPoolsContract,
          chain: "fantom",
          block: chainBlocks["fantom"],
        })
      ).output;

      const getTokenSymbol = (
        await sdk.api.abi.call({
          abi: abi.symbol,
          target: token,
          chain: "fantom",
          block: chainBlocks["fantom"],
        })
      ).output;

      if (getTokenSymbol.includes("LP")) {
        lpPositions.push({
          token: token,
          balance: getTokenBalance,
        });
      } else {
        sdk.util.sumSingleBalance(
          balances,
          `fantom:${token.toLowerCase()}`,
          getTokenBalance
        );
      }
    } catch (error) {
      poolInfoReturn = error.reason;
    }
    i += 1;
  } while (!poolInfoReturn);

  if (!Object.keys(balances).length)  throw new Error('Bad length, something is wrong')

  const transformAddress = await transformFantomAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["fantom"],
    "fantom",
    transformAddress
  );

  return balances;
};
// node test.js projects/2omb-finance/index.js
async function tvl(timestamp, block, chainBlocks) {
  let balances = await omb3Tvl(chainBlocks);
  delete balances[`fantom:${token}`];
  delete balances[`fantom:${shares}`];
  return balances;
}
async function stakings(timestamp, block, chainBlocks) {
  let [balances, coreTvl] = await Promise.all([
    staking(masonry, shares, "fantom")(timestamp, block, chainBlocks),
    omb3Tvl(chainBlocks),
  ]);
  balances[`fantom:${token}`] =
    `fantom:${token}` in balances
      ? Number(balances[`fantom:${token}`]) + Number(coreTvl[`fantom:${token}`])
      : coreTvl[`fantom:${token}`];
  balances[`fantom:${shares}`] =
    `fantom:${shares}` in balances
      ? Number(balances[`fantom:${shares}`]) +
        Number(coreTvl[`fantom:${shares}`])
      : Number(coreTvl[`fantom:${shares}`]);
  return balances;
}
module.exports = {
  fantom: {
    tvl,
    staking: stakings,
    pool2: pool2Exports(rewardPool, pool2LPs, "fantom"),
  },
};

'''
'''--- projects/88mph/abi.json ---
{
  "totalDeposit": {
    "constant": true,
    "inputs": [],
    "name": "totalDeposit",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "stablecoin": {
    "constant": true,
    "inputs": [],
    "name": "stablecoin",
    "outputs": [
      {
        "internalType": "contract ERC20",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "calculateInterestAmount": {
    "constant": false,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "depositAmount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "depositPeriodInSeconds",
        "type": "uint256"
      }
    ],
    "name": "calculateInterestAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "interestAmount",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  "symbol": {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/88mph/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi')

const BigNumber = require('bignumber.js')
const { default: axios } = require('axios')
const { chainExports } = require('../helper/exports')
const { staking } = require('../helper/staking')
const { transformFantomAddress } = require('../helper/portedTokens')

const olddInterestAddresses = [
  '0x35966201A7724b952455B73A36C8846D8745218e', // Compound DAI
  '0x374226dbAa3e44bF3923AfB63f5Fd83928B7e148', // Compound USDC
  '0x19E10132841616CE4790920d5f94B8571F9b9341', // Compound UNI
  '0xe615e59353f70cA2424Aa0F24F49C639B8E924D3', // yearn yCRV
  '0x681Aaa7CF3F7E1f110842f0149bA8A4AF53Ef2Fd', // yearn crvSBTC
  '0x23Fa6b36E870ca5753853538D17C3ca7f5269e84', // Harvest yCRV
  '0xe8C52367b81113ED32bb276184e521C2fbE9393A', // Aave USDC
  '0xb1ABAac351e06d40441CF2CD97F6f0098e6473F2', // Harvest CRV:HUSD
  '0x2F3EFD1a90a2336ab8fa1B9060380DC37361Ca55', // Harvest 3CRV
  '0x3f5611F7762cc39FC11E10C864ae38526f650e9D', // Harvest CRV:HBTC
  '0x6712BAab01FA2dc7bE6635746Ec2Da6F8Bd73e71', // Aave sUSD
  '0xDC86AC6140026267E0873B27c8629eFE748E7146', // Aave DAI
  '0xD4837145c7e13D580904e8431cfD481f9794fC41', // Harvest CRV:oBTC
  '0x904F81EFF3c35877865810CCA9a63f2D9cB7D4DD', // yearn yaLINK
  '0x303CB7Ede0c3AD99CE017CDC3aBAcD65164Ff486', // Harvest CRV:STETH
  '0x22E6b9A65163CE1225D1F65EF7942a979d093039' // Harvest CRV:RENWBTC
]
const wrappedTokenToSubsitute = {
  '0x2fE94ea3d5d4a175184081439753DE15AeF9d614': { // CRV:oBTC
    address: '0x8064d9Ae6cDf087b1bcd5BDf3531bD5d8C537a68', // oBTC
    decimals: 18
  },
  '0xb19059ebb43466C323583928285a49f558E572Fd': { // CRV:HBTC
    address: '0x0316EB71485b0Ab14103307bf65a021042c6d380', // HBTC
    decimals: 18
  },
  '0x5B5CFE992AdAC0C9D48E05854B2d91C73a003858': { // CRV:HUSD
    address: '0xdf574c24545e5ffecb9a659c229253d4111d87e1', // HUSD
    decimals: 8
  },
  '0x06325440D014e39736583c165C2963BA99fAf14E': { // CRV:STETH
    address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    decimals: 18
  },
  '0x49849C98ae39Fff122806C06791Fa73784FB3675': { // CRV:RENWBTC
    address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
    decimals: 8
  },
  '0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3': { // CRV: sBTC
    address: '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6', //sBTC
    decimals: 18
  }
}

const urls = {
  ethereum: "https://api.88mph.app/v3/pools",
  polygon: 'https://api.88mph.app/v3/polygon/pools',
  avax: 'https://api.88mph.app/v3/avalanche/pools',
  fantom: 'https://api.88mph.app/v3/fantom/pools',
}

function chainTvl(chain) {
  const url = urls[chain]
  return async (timestamp, ethBlock, chainBlocks) => {
    const block = chainBlocks[chain]
    const balances = {}
    const poolToUnderlyingToken = {}
    let transform = addr=>`${chain}:${addr}`
    if(chain === "fantom"){
      transform = await transformFantomAddress()
    }

    const v3Pools = await axios.get(url)
    let dInterestAddresses = v3Pools.data.map(p => p.address)
    if (chain === "ethereum") {
      dInterestAddresses = olddInterestAddresses.concat(dInterestAddresses)
    }

    // Get deposit pools' underlying tokens
    const poolUnderlyingAddressResults = await sdk.api.abi.multiCall({
      calls: dInterestAddresses.map((address) => ({
        target: address
      })),
      block,
      chain,
      abi: abi.stablecoin
    })

    poolUnderlyingAddressResults.output.forEach((token) => {
      const underlyingTokenAddress = token.output
      if(underlyingTokenAddress === null){
        throw new Error(`token ${token} is broken`)
      }
      const poolAddress = token.input.target
      poolToUnderlyingToken[poolAddress] = underlyingTokenAddress
    })

    // Get deposit pools' balances in underlying token
    const poolDepositBalanceResults = await sdk.api.abi.multiCall({
      block,
      calls: dInterestAddresses.map((address) => ({
        target: address
      })),
      chain,
      abi: abi.totalDeposit
    })

    poolDepositBalanceResults.output.forEach((tokenBalanceResult) => {
      let valueInToken = tokenBalanceResult.output
      const poolAddress = tokenBalanceResult.input.target
      let underlyingTokenAddress = poolToUnderlyingToken[poolAddress]
      // replace curve LP token with subsitute
      if (wrappedTokenToSubsitute[underlyingTokenAddress]) {
        const substituteInfo = wrappedTokenToSubsitute[underlyingTokenAddress]
        underlyingTokenAddress = substituteInfo.address
        valueInToken = BigNumber(valueInToken).div(BigNumber(10).pow(18 - substituteInfo.decimals)).toFixed(0)
      }
      sdk.util.sumSingleBalance(balances, transform(underlyingTokenAddress), valueInToken)
    })

    return balances
  }
}

const tvlExports = chainExports(chainTvl, Object.keys(urls))
tvlExports.ethereum.staking = staking("0x1702F18c1173b791900F81EbaE59B908Da8F689b", "0x8888801af4d980682e47f1a9036e589479e835c5")
module.exports = {
  methodology: `Using the addresses for the fixed interest rate bonds we are able to find the underlying tokens held in each address. Once we have the underlying token we then get the balances of each of the tokens. For the CRV tokens used "CRV:STETH" for example, the address is replaced with the address of one of the tokens. In the example at hand the address is replaced with the "WETH" address so that the price can be calculated.`,
  start: 1606109629, // Monday, November 23, 2020 5:33:49 AM GMT
  ...tvlExports
}

'''
'''--- projects/AxiaProtocol/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs, sumBalancerLps } = require("../helper/unwrapLPs");
const {transformPolygonAddress} = require('../helper/portedTokens.js');
const { staking } = require("../helper/staking");
const { getCurrentTokens } = require("../balancer/abi.json")
const BigNumber = require('bignumber.js')

const wETHonEth = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'

const axiaPoly = '0x49690541e3f6e933a9aa3cffee6010a7bb5b72d7'
const lonePoolPoly = '0x6c43cd84f2199eef1e7fcf169357b6c7948efe03'
const swapPoolPoly = '0xabf1dafecc1d8b3949092bab9dff8da7d63c69b1'
const swapPoolLPoly = '0xfa447eec17206c4948cba28a229346af925c2b07'

const axiaEth = '0x793786e2dd4cc492ed366a94b88a3ff9ba5e7546'
const lonelyPoolEth = '0x9dEd3b9d0bd9cc4DE698dcebeBb68b1f0033c0C8'
const swapPoolEth = '0xA5130fc368cAAd25450cB5aD1D3718BAB7e558dA'
const swapPoolLPEth = '0x1e0693f129D05E5857A642245185ee1fca6A5096'
const defiFundEth = '0x2b79d8dCbF26c5B690145130006Be06D1324C2b2'
const defiFundLPEth = '0x4833e8b56fc8e8a777fcc5e37cb6035c504c9478'
const oracleFundEth = '0x152959A2f50D716707fEa4897e72C554272dC584'
const oracleFundLPEth = '0xbf11db4e63c72c5dffde0f5831d667817c9e9ad5'

async function calculatePolygonTvl(masterchef, lps, block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.split(',').map((p) => ({
        target: p,
        params: masterchef,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );
  return balances;
}

const polygonTvl = async (timestamp, block, chainBlocks) => {
  return await calculatePolygonTvl(swapPoolPoly, swapPoolLPoly, chainBlocks.polygon, "polygon");
}

async function calculateEthereumTvl(masterchef, lps, block, chain) {
  let balances = {};

  //Swap Fund
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.split(',').map((p) => ({
        target: p,
        params: masterchef,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  //Defi Fund
  const defiFundTokensEth = (await sdk.api.abi.call({
      abi: getCurrentTokens,
      target: defiFundLPEth,
      chain,
      block,
    })).output;
  
  const defiFundBalanceEth = (await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        chain,
        target: defiFundLPEth,
        params: defiFundEth,
        block,
      })).output;

  const defiFundSupplyEth = (await sdk.api.abi.call({
      abi: 'erc20:totalSupply',
      target: defiFundLPEth,
      chain,
      block,
    })).output;

  const defiFundStakedSharesEth = defiFundBalanceEth / defiFundSupplyEth

  const defiFundLPUnderlyingBalanceEth = await sdk.api.abi.multiCall({
  calls: defiFundTokensEth.map(token => ({
    target: token,
    params: [defiFundLPEth]
  })),
  abi: 'erc20:balanceOf',
  block,
  });

  async function getDefiFundUnderlyingBalanceEth () {
    await defiFundLPUnderlyingBalanceEth;
    console.log(defiFundLPUnderlyingBalanceEth)
    console.log(defiFundLPUnderlyingBalanceEth.output.map(outs => outs.output))
    defiFundLPUnderlyingBalanceEth.output.map(outs => outs.output = BigNumber(outs.output * defiFundStakedSharesEth).toFixed());
  console.log(defiFundLPUnderlyingBalanceEth)}
  await getDefiFundUnderlyingBalanceEth();

  sdk.util.sumMultiBalanceOf(balances, defiFundLPUnderlyingBalanceEth);

  //Oracle Fund
  const oracleFundTokensEth = (await sdk.api.abi.call({
      abi: getCurrentTokens,
      target: oracleFundLPEth,
      chain,
      block,
    })).output;
  
  const oracleFundBalanceEth = (await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        chain,
        target: oracleFundLPEth,
        params: oracleFundEth,
        block,
      })).output;

  const oracleFundSupplyEth = (await sdk.api.abi.call({
      abi: 'erc20:totalSupply',
      target: oracleFundLPEth,
      chain,
      block,
    })).output;

  const oracleFundStakedSharesEth = oracleFundBalanceEth / oracleFundSupplyEth

  const oracleFundLPUnderlyingBalanceEth = await sdk.api.abi.multiCall({
  calls: oracleFundTokensEth.map(token => ({
    target: token,
    params: [oracleFundLPEth]
  })),
  abi: 'erc20:balanceOf',
  block,
  });

  async function getOracleFundUnderlyingBalanceEth () {
    await oracleFundLPUnderlyingBalanceEth;
    console.log(oracleFundLPUnderlyingBalanceEth)
    console.log(oracleFundLPUnderlyingBalanceEth.output.map(outs => outs.output))
    oracleFundLPUnderlyingBalanceEth.output.map(outs => outs.output = BigNumber(outs.output * oracleFundStakedSharesEth).toFixed());
  console.log(oracleFundLPUnderlyingBalanceEth)}
  await getOracleFundUnderlyingBalanceEth();

  sdk.util.sumMultiBalanceOf(balances, oracleFundLPUnderlyingBalanceEth);
  
  return balances;
}

const ethereumTvl = async (timestamp, ethBlock) => {
  return await calculateEthereumTvl(swapPoolEth, swapPoolLPEth, ethBlock, "ethereum");
}

module.exports = {
  polygon:{
    tvl: polygonTvl,
    staking: staking(lonePoolPoly, axiaPoly, "polygon")
  },

  ethereum: {
    tvl: ethereumTvl,
    staking: staking(lonelyPoolEth, axiaEth, "ethereum"),
  }
}

'''
'''--- projects/BombFinance/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')
const {transformFantomAddress} = require('../helper/portedTokens.js')

const factory = '0xD9473A05b2edf4f614593bA5D1dBd3021d8e0Ebe'
async function tvl(_timestamp, _block, chainBlocks){
  const transform = await transformFantomAddress();

  const balances = await calculateUniTvl(transform, chainBlocks['fantom'], 'fantom', factory, 13483113, true);
  return balances
}

module.exports = {
  fantom:{
    tvl,
  },
}

'''
'''--- projects/Caketomb/index.js ---
const sdk = require("@defillama/sdk");
const {pool2Exports} = require("../helper/pool2");
const { staking } = require("../helper/staking");

const token = "0xAB4F3fC9831dBC77424269B9255fC1A082AC9840";
const shares = "0x9f8349C33B942b6CBb15426E02b5Bbb77fAeB64f";
const shareRewardPool = "0x02361bAd5b50AfDDea2d8c4359a8C9595445a90D";
const boardroom = "0xcE2912101EF05034Eb2FA818dd6e57Ab09c8Ca73";

const pancakeLPs = [
    "0xdAaf38D37A055F3592f0c86f156Ee8Bff23c1248", // SHARE-WBNB
    "0x252b69d00339D9aAdEEB324dcB6E04381B272340" // CAKETOMB-BNB
]

module.exports = {
    deadFrom: 1648765747,
    bsc: {
        tvl: async () => ({}),
        staking: staking(boardroom, shares, "bsc"),
        pool2: pool2Exports(shareRewardPool, pancakeLPs, "bsc", addr=>`bsc:${addr}`)
    }
}

'''
'''--- projects/Fountain-Protocol/index.js ---
const {usdCompoundExports} = require('../helper/compound');
const sdk = require("@defillama/sdk");

const unitroller_classic_oasis = '0xA7684aE7e07Dac91113900342b3ef25B9Fd1D841';
const ftoken_classic_oasis = '0xD7d588bAbFb99E82Cd6dd0cA7677A5599AA678B5';

const unitroller_usd_oasis = '0x1C0C30795802Bf2B3232a824f41629BbBCF63127';
const ftoken_usd_oasis ='0x2552707D66C102c12b0f8284824F80e1299cB6B7';

const unitroller_lpt_oasis = '0x7c4d0c834701C6E7F57b8c1424d30aDC46eA0840';
const ftoken_lpt_oasis ='0x63f1Fe2E1da490611FC16E4a5d92b7ec7d0911a9';

const classic_lending = usdCompoundExports(unitroller_classic_oasis, "oasis", ftoken_classic_oasis)
const stable_lending  = usdCompoundExports(unitroller_usd_oasis, "oasis", ftoken_usd_oasis)
const lpt_lending     = usdCompoundExports(unitroller_lpt_oasis, "oasis", ftoken_lpt_oasis)

module.exports={
  timetravel: true,
  oasis:{
	tvl: sdk.util.sumChainTvls([classic_lending.tvl, stable_lending.tvl, lpt_lending.tvl]),
	borrowed: sdk.util.sumChainTvls([classic_lending.borrowed, stable_lending.borrowed, lpt_lending.borrowed])
  },
  methodology:  "TVL is comprised of tokens deposited to the protocol as collateral from serveral pools, similar to Compound Finance and the borrowed tokens are not counted as TVL. ",
};

'''
'''--- projects/GajFinance/index.js ---
const { sumTokens } = require('../helper/unwrapLPs');
const { masterChefExports } = require("../helper/masterchef");

const GAJ_TOKEN = '0xf4b0903774532aee5ee567c02aab681a81539e92'
const GAJ_AVAX_TOKEN = '0x595c8481c48894771CE8FaDE54ac6Bf59093F9E8'
const MASTER_GAJ = '0xb03f95e649724df6ba575c2c6ef062766a7fdb51'
const NFTFARM_GAJ_AVAX = '0x65096f7dB56fC27C7646f0aBb6F9bC0CEA2d8765'

async function stakingAvax(timestamp, ethBlock, chainBlocks) {
  return sumTokens({}, [[GAJ_AVAX_TOKEN, NFTFARM_GAJ_AVAX]], chainBlocks.avax, 'avax')
}

module.exports = {
  broken: 'Api is no longer reachable',
  methodology: "TVL comes from NFT Farming, Jungle Pools, MasterChef and Vaults",
  avalanche: {
    staking: stakingAvax,
  },
  ...masterChefExports(MASTER_GAJ, 'polygon', GAJ_TOKEN),
}

'''
'''--- projects/GoSwap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

module.exports={
    timetravel: true,
    misrepresentedTokens: true,
    methodology: "Factory address (0xe93c2cD333902d8dd65bF9420B68fC7B1be94bB3) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    gochain: {
        tvl:calculateUsdUniTvl("0xe93c2cD333902d8dd65bF9420B68fC7B1be94bB3", "gochain", "0xcC237fa0A4B80bA47992d102352572Db7b96A6B5", ["0x97a19aD887262d7Eca45515814cdeF75AcC4f713", "0xe8D71132Cd78146fbeD8c085f6c06CdeDF74E3Be","0x67bBB47f6942486184f08a671155FCFA6cAd8d71",
                                "0x331357dDD79F4E8da3f972E4Af30a8B726790a56", "0x5347FDeA6AA4d7770B31734408Da6d34a8a07BdF"], "gochain")
    }
}
'''
'''--- projects/GotchiVault/abi.json ---
{
  "totalGHST":
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "totalGHST",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_totalGHST",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "tokenIdsOfOwner":
    {"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"tokenIdsOfOwner","outputs":[{"internalType":"uint32[]","name":"tokenIds_","type":"uint32[]"}],"stateMutability":"view","type":"function"}

  }
'''
'''--- projects/GotchiVault/index.js ---
const sdk = require('@defillama/sdk');
const { transformPolygonAddress } = require('../helper/portedTokens');
const abi = require("./abi.json");
const { request, gql } = require("graphql-request");

const VGHST_CONTRACT = "0x51195e21BDaE8722B29919db56d95Ef51FaecA6C";
const GHST_CONTRACT = "0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7";
const VAULT_CONTRACT = "0xDd564df884Fd4e217c9ee6F65B4BA6e5641eAC63";

const graphUrl = 'https://api.thegraph.com/subgraphs/name/aavegotchi/aavegotchi-core-matic'
const graphQuery = gql`
query GET_SUMMONED_GOTCHIS ($minGotchiId: Int, $block: Int) {
  aavegotchis(
    first: 1000
    skip: 0
    block: { number: $block }
    where: {
      status: "3" # summoned gotchis
      gotchiId_gt: $minGotchiId
      owner: "${VAULT_CONTRACT.toLowerCase()}"
    }
    orderBy: gotchiId
    orderDirection: asc
  ) {
    gotchiId
    collateral
    stakedAmount
  }
}`
async function getGotchisCollateral(timestamp, block) {
  const allGotchis = [];
  let minGotchiId = 0;
  while (minGotchiId !== -1) {
    const { aavegotchis } = await request(
      graphUrl,
      graphQuery, 
      {minGotchiId, block}
    );
    if (aavegotchis && aavegotchis.length > 0) {
      minGotchiId = parseInt(aavegotchis[aavegotchis.length - 1].gotchiId);
      allGotchis.push(...aavegotchis);
    } else {
      minGotchiId = -1;
    }
  }
  const gotchisBalances = {
    output: allGotchis.map(g => ({
      input: {target: g.collateral},
      success: true,
      output: g.stakedAmount
    }))
  };

  const balances = {};
  sdk.util.sumMultiBalanceOf(balances, gotchisBalances, true, x => 'polygon:' + x);
  return gotchisBalances;
}

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();

  const collateralBalance = (await sdk.api.abi.call({
    abi: abi.totalGHST,
    chain: 'polygon',
    target: VGHST_CONTRACT,
    params: [VGHST_CONTRACT],
    block: chainBlocks['polygon'],
  })).output;

  sdk.util.sumSingleBalance(balances, transform(GHST_CONTRACT), collateralBalance)

  const gotchisBalances = await getGotchisCollateral(timestamp, chainBlocks["polygon"]-100);
  sdk.util.sumMultiBalanceOf(balances, gotchisBalances, true, x => 'polygon:' + x);

  return balances;
}

module.exports = {
  methodology:
    "TVL counts the total GHST tokens that are staked by the Gotchi Vault vGHST contracts, as well as the collateral tokens that are locked in the Aavegotchis deposited in the Gotchi Vault contract",
    polygon: {
    tvl,
  }
};
'''
'''--- projects/Guru/index.js ---
const sdk = require("@defillama/sdk")
const ITVL = [
 {
   "inputs": [],
   "name": "pool2",   //POOL2 TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "staking",   //STAKING TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "tvl",   //GLOABL TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
 "inputs": [],
 "name": "usd",   //On-chain USD Reference Token
 "outputs": [
   {
     "internalType": "address",
     "name": "",
     "type": "address"
   }
 ],
 "stateMutability": "view",
 "type": "function"
 }
]

//	TvlGuru:	On-Chain Universal TVL Finder
const tvlGuru = {
	"ftm"	:	"0x0786c3a78f5133F08C1c70953B8B10376bC6dCad",
	"kcc"	:	"0x426a4A4B73d4CD173C9aB78d18c0d79d1717eaA9",
	"mtv"	:	"0xe345A50C33e5c9D0284D6fF0b891c4Fc99a9C117",
	"ech"	:	"0x5C652A94c672f8F6D021417bB5eE75c322ecf1Fc"
}

//NOTE: USD===<chainslug>:USDC is used explicitly to reduce EVM calls by this adapter. It makes this process faster.
//temporary hack: New chain's USDC represented as Mainnet DAI
//    "multivac:0xEa1199d50Ee09fA8062fd9dA3D55C6F90C1bABd2": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
//    //MultiVAC Bridged USDC -> Mainnet DAI
//NOTE: Actual USDC on the new chains (sdk-unmapped)
//const USD.mtv = "0xEa1199d50Ee09fA8062fd9dA3D55C6F90C1bABd2";
//const USD.ech = "0xc42974d6554F9054265b477723C3f689d8699239";
//TODO: Create mappings for bridged tokens on new chains
const USD = {
	"ftm"	:	{"addr":"fantom:0x04068DA6C83AFCFA0e13ba15A6696662335D5B75",	"deci":6},
	"kcc"	:	{"addr":"kcc:0x0039f574eE5cC39bdD162E9A88e3EB1f111bAF48",	"deci":18},
	"mtv"	:	{"addr":"0x6B175474E89094C44Da98b954EedeAC495271d0F",		"deci":18},	//Rep. Mainnet DAI
	"ech"	:	{"addr":"0x6B175474E89094C44Da98b954EedeAC495271d0F",		"deci":18}	//Rep. Mainnet DAI
}

async function ftm_p_2(timestamp,ethBlock,chainBlocks) { return {[USD.ftm.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ftm, abi: ITVL[0], block: chainBlocks.fantom, chain: 'fantom' }) ).output )/(10**(18-USD.ftm.deci)))} }
async function ftm_stk(timestamp,ethBlock,chainBlocks) { return {[USD.ftm.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ftm, abi: ITVL[1], block: chainBlocks.fantom, chain: 'fantom' }) ).output )/(10**(18-USD.ftm.deci)))} }
async function ftm_tvl(timestamp,ethBlock,chainBlocks) { return {[USD.ftm.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ftm, abi: ITVL[2], block: chainBlocks.fantom, chain: 'fantom' }) ).output )/(10**(18-USD.ftm.deci)))} }

async function kcc_p_2(timestamp,ethBlock,chainBlocks) { return {[USD.kcc.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.kcc, abi: ITVL[0], block: chainBlocks.kcc, chain: 'kcc' }) ).output )/(10**(18-USD.kcc.deci)))} }
async function kcc_stk(timestamp,ethBlock,chainBlocks) { return {[USD.kcc.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.kcc, abi: ITVL[1], block: chainBlocks.kcc, chain: 'kcc' }) ).output )/(10**(18-USD.kcc.deci)))} }
async function kcc_tvl(timestamp,ethBlock,chainBlocks) { return {[USD.kcc.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.kcc, abi: ITVL[2], block: chainBlocks.kcc, chain: 'kcc' }) ).output )/(10**(18-USD.kcc.deci)))} }

async function mtv_p_2(timestamp,ethBlock,chainBlocks) { return {[USD.mtv.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.mtv, abi: ITVL[0], block: chainBlocks.multivac, chain: 'multivac' }) ).output )/(10**(18-USD.mtv.deci)))} }
async function mtv_stk(timestamp,ethBlock,chainBlocks) { return {[USD.mtv.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.mtv, abi: ITVL[1], block: chainBlocks.multivac, chain: 'multivac' }) ).output )/(10**(18-USD.mtv.deci)))} }
async function mtv_tvl(timestamp,ethBlock,chainBlocks) { return {[USD.mtv.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.mtv, abi: ITVL[2], block: chainBlocks.multivac, chain: 'multivac' }) ).output )/(10**(18-USD.mtv.deci)))} }

async function ech_p_2(timestamp,ethBlock,chainBlocks) { return {[USD.ech.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ech, abi: ITVL[0], block: chainBlocks.echelon, chain: 'echelon' }) ).output )/(10**(18-USD.ech.deci)))} }
async function ech_stk(timestamp,ethBlock,chainBlocks) { return {[USD.ech.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ech, abi: ITVL[1], block: chainBlocks.echelon, chain: 'echelon' }) ).output )/(10**(18-USD.ech.deci)))} }
async function ech_tvl(timestamp,ethBlock,chainBlocks) { return {[USD.ech.addr]:(Number( ( await sdk.api.abi.call({ target: tvlGuru.ech, abi: ITVL[2], block: chainBlocks.echelon, chain: 'echelon' }) ).output )/(10**(18-USD.ech.deci)))} }

module.exports = {
	methodology: "USD-denominated value aggregation of most Locked assets held across Guru Network's & Kompound Protocol's smart contracts across multiple chains, powered by direct on-chain storage of quantity, pools and prices using ftm.guru's Universal TVL Finder Tool (tvlGuru.sol). More detailed documentation of TVL is available at https://ftm.guru/rawdata/tvl",
	fantom:		{ pool2: ftm_p_2, staking: ftm_stk, tvl: ftm_tvl },
	kcc:		{ pool2: kcc_p_2, staking: kcc_stk, tvl: kcc_tvl },
	multivac:	{ pool2: mtv_p_2, staking: mtv_stk, tvl: mtv_tvl },
	echelon:	{ pool2: ech_p_2, staking: ech_stk, tvl: ech_tvl },
}

'''
'''--- projects/HoneyFarm/index.js ---
const { addFundsInMasterChef } = require("../helper/masterchef");
const { getBlock } = require("../helper/getBlock");
const {
  transformAvaxAddress,
  transformBscAddress,
} = require("../helper/portedTokens");
const { staking } = require("../helper/staking");

async function avax(timestamp, block, chainBlocks) {
  let balances = {};
  block = await getBlock(timestamp, "avax", chainBlocks);
  const transform = await transformAvaxAddress();

  await addFundsInMasterChef(
    {},
    "0x757490104fd4C80195D3C56bee4dc7B1279cCC51",
    block,
    "avax",
    transform,
    undefined,
    ["0xB669c71431bc4372140bC35Aa1962C4B980bA507"]
  );
  return balances;
}

async function bsc(timestamp, block, chainBlocks) {
  let balances = {};
  block = await getBlock(timestamp, "bsc", chainBlocks);
  const transform = await transformBscAddress();

  await addFundsInMasterChef(
    {},
    "0x88E21dedEf04cf24AFe1847B0F6927a719AA8F35",
    block,
    "bsc",
    transform,
    undefined,
    ["0x1A8d7AC01d21991BF5249A3657C97b2B6d919222"]
  );
  return balances;
}

module.exports = {
  methodology:
    "Only staked LP is counted as TVL. Excluded in TVL : Locked BEE in the RoyalJelly, NFT Jelly, value of BNB & xJOE which aren't on CoinGecko yet.",
  avalanche: {
    tvl: avax,
    staking: staking(
      "0x757490104fd4C80195D3C56bee4dc7B1279cCC51",
      "0xB669c71431bc4372140bC35Aa1962C4B980bA507",
      "avax"
    ),
  },
  bsc: {
    tvl: bsc,
    staking: staking(
      "0x88E21dedEf04cf24AFe1847B0F6927a719AA8F35",
      "0x1A8d7AC01d21991BF5249A3657C97b2B6d919222",
      "bsc"
    ),
  },
}; // node test.js projects/HoneyFarm/index.js

'''
'''--- projects/KungFuu-Finance/index.js ---
const { sumTokens } = require('../helper/unwrapLPs')
const { getChainTransform } = require('../helper/portedTokens')
const sdk = require("@defillama/sdk")

const wFTM = '0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83'
const kngfuu_token = "0x89b61Ab033584918103698953870F07D6db412A3".toLowerCase()

async function tvl(ts, _block, { fantom: block }) {
  const chain = 'fantom'
  const balances = {}
  const transform = await getChainTransform(chain)
  const owners = ["0x29187b10a04B269Cf067AE013B3ab58d4affaC03", "0xaaef45e31e2d2865a4722c1591ba4cd8f6e83bad", "0xfeAFAF0610fe2c73bB6345080056066aE109B31F"]
  const treasuryTokens = [
    wFTM, // WFTM
    "0x04068da6c83afcfa0e13ba15a6696662335d5b75", // USDC
    "0xf704f5ac5edf152168e07e6f5f108366911250ac", // WFTM/KNGFUU, needs to account only half of it
  ]

  const tokensAndOwners = []
  treasuryTokens.forEach(t => owners.forEach(o => tokensAndOwners.push([t, o])))
  await sumTokens(balances, tokensAndOwners, block, chain, transform, { resolveLP: true })
  delete balances[transform(kngfuu_token)]
  const  { output: results } = await sdk.api.eth.getBalances({ targets: owners, chain, block})
  for (const res of results) sdk.util.sumSingleBalance(balances, transform(wFTM), res.balance)
  return balances
}

module.exports = {
  fantom: {
    tvl
  }
}
'''
'''--- projects/Kwikswap/index.js ---
const { getChainTvlBuffered } = require("../helper/getUniSubgraphTvl");
const { getUniTVL } = require("../helper/unknownTokens");
const { staking } = require("../helper/staking.js");

const v1graph = getChainTvlBuffered(
  {
    ethereum:
      "https://api.thegraph.com/subgraphs/name/kwikswap/kwikswap-subgraph",
    bsc: "https://api.thegraph.com/subgraphs/name/kwikswap/kwikswap-bsc-subgraph",
    polygon: "https://api.thegraph.com/subgraphs/name/kwikswap/matic-exchange",
  },
  600,
  "kwikswapFactories",
  "totalLiquidityUSD"
);
// node test.js projects/kwikswap/index.js
const KWIK_TOKEN_ADDRESSES = {
  ethereum: "0x286c0936c7eaf6651099ab5dab9ee5a6cb5d229d",
  shiden: "0xd67de0e0a0fd7b15dc8348bb9be742f3c5850454",
  polygon: "0x8df74088b3aecfd0cb97bcfd053b173782f01e3a",
};

const STAKING_CONTRACTS = {
  ethereum: "0x57Caec63E87e1496E946181e3Fc59086e589D4c0",
  shiden: "0x212CB413c48221cA6fE2100578a9ABED26840380",
  polygon: "0x7965e5F759caB3d5a1b737b9Bb24e94ef6747FA7",
};

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  ethereum: {
    tvl: v1graph("ethereum"),
    staking: staking(
      STAKING_CONTRACTS["ethereum"],
      KWIK_TOKEN_ADDRESSES["ethereum"]
    ),
  },

  polygon: {
    tvl: v1graph("polygon"),
    staking: staking(
      STAKING_CONTRACTS["polygon"],
      KWIK_TOKEN_ADDRESSES["polygon"],
      "polygon"
    ),
  },
  shiden: {
    tvl: getUniTVL({
      factory: '0xf5fC2D145381A2eBAFb93Cc2B60fB2b97FB405aa',
      chain: 'shiden',
      coreAssets: ['0x0f933Dc137D21cA519ae4C7E93f87a4C8EF365Ef',
        // USDC
        "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f",
        // USDT
        "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b",
        // JPYC
        "0x735aBE48e8782948a37C7765ECb76b98CdE97B0F",
        // STND
        "0x722377A047e89CA735f09Eb7CccAb780943c4CB4",],
    }),
    staking: staking(
      STAKING_CONTRACTS["shiden"],
      KWIK_TOKEN_ADDRESSES["shiden"],
      "shiden",
      KWIK_TOKEN_ADDRESSES["ethereum"]
    ),
  },
  bsc: {
    tvl: getUniTVL({
      chain: 'bsc',
      coreAssets: ['0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c'],
      factory: '0x64eBD6CaCece790e9C4DDeA1a24952Ddb2715279',
    }),
  },
}

'''
'''--- projects/LizardExchange/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl');
module.exports = {
    oasis: {
        tvl: calculateUsdUniTvl(
            '0xefA6861931991CCE372c477a015619A21dfEBE8c',
            'oasis',
            '0x21C718C22D52d0F3a789b752D4c2fD5908a8A733',
            [
                '0xdC19A122e268128B5eE20366299fc7b5b199C8e3',
            ],
            'oasis-network'
        )
    }
}; 
'''
'''--- projects/MultiSwap/index.js ---

const sdk = require('@defillama/sdk')
const { createIncrementArray } = require('../helper/utils')
const { sumTokens2 } = require('../helper/unwrapLPs')
const token0ABI  = require('../helper/abis/token0.json')
const token1ABI  = require('../helper/abis/token1.json')

const abis = {
  "poolsCount": {
    "inputs": [],
    "name": "poolsCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolsAddresses": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolsAddresses",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  token0:
  {
    "inputs": [],
    "name": "protocolFees",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "token0",
        "type": "uint128"
      },
      {
        "internalType": "uint128",
        "name": "token1",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  token1:
  {
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
const chain = 'kava'
const positionManager = '0x1Bf12f0650d8065fFCE3Cd9111feDEC21deF6825'
const customWKava = '0xc13791DA84f43525189456CfE2026C60D3B7F706'.toLowerCase()

async function tvl(_, _b, { [chain]: block }) {
  const { output: poolCount } = await sdk.api.abi.call({
    target: positionManager,
    abi: abis.poolsCount,
    chain, block,
  })
  const calls = createIncrementArray(poolCount).map(i => ({ params: i }))
  let { output: poolAddreses } = await sdk.api.abi.multiCall({
    target: positionManager,
    abi: abis.poolsAddresses,
    calls,
    chain, block,
  })

  poolAddreses = poolAddreses.map(i => ({ target: i.output}))
  const { output: token0s } = await sdk.api.abi.multiCall({
    abi: token0ABI,
    calls: poolAddreses,
    chain, block,
  })
  const { output: token1s } = await sdk.api.abi.multiCall({
    abi: token1ABI,
    calls: poolAddreses,
    chain, block,
  })
  const toa = []
  token0s.forEach(({ input: { target }, output }) => toa.push([output, target]))
  token1s.forEach(({ input: { target }, output }) => toa.push([output, target]))
  const kavaBal = await sumTokens2({ chain, block, tokensAndOwners: toa })
  const customKavaKey = 'kava:'+customWKava
  sdk.util.sumSingleBalance(kavaBal, 'kava', (kavaBal[customKavaKey] || 0) / 1e18)
  delete kavaBal[customKavaKey]
  return kavaBal
}

module.exports = {
  kava: {
    tvl
  }
}

'''
'''--- projects/MyTrade/index.js ---
const { getUniTVL } = require("../helper/unknownTokens")
const { sumTokens2 } = require("../helper/unwrapLPs")
const { getUniqueAddresses } = require("../helper/utils")
const sdk = require('@defillama/sdk')

const orderBook = '0x5D36b36c53438C0fb70DCA5082EE5BDe25Bd888B'

module.exports = {
  polygon: {
    tvl: async (_, _b, { polygon: block }) => {
      const {
        pairs,
        updateBalances,
        balances,
      } = await getUniTVL({
        factory: '0x3ee4154c7f42d94e1092ad8ce5debb4b743ed0b2',
        chain: 'polygon',
        coreAssets: [
          '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // wmatic
          '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // usdc
          '0x4535e52cdf3ab787b379b7b72b5990767e6747e4', // myt
        ],
        withMetaData: true,
      })(_, _b, { polygon: block })

      const tokens = Object.values(pairs).map(i => Object.values(i)).flat()

      await sumTokens2({
        chain: 'polygon', block, owner: orderBook, tokens: getUniqueAddresses(tokens), balances,
      })

      await updateBalances(balances)
      return balances
    }
  },
}

'''
'''--- projects/OCP/index.js ---
const utils = require("../helper/utils");

function fetchChain(chainId) {
  return async () => {
    const response = await utils.fetchURL(
      "https://api-omnisteaks.ocp.finance/tvl/apps?q=1666600000"
    );

    let tvl = 0;
    const tradeTvl = response.data["tradeTvl"];
    const compTvl = response.data["compTvl"];
    const vaultTvl = response.data["vaultTvl"];
    const steakTvl = response.data["steakTvl"];
    const farmTvl = response.data["farmTvl"];

    tvl =
      Number(tradeTvl) +
      Number(compTvl) +
      Number(vaultTvl) +
      Number(steakTvl) +
      Number(farmTvl);
    if (tvl === 0) {
      throw new Error(`chain ${chainId} tvl is 0`);
    }
    return tvl;
  };
}

async function fetch() {
  const response = await utils.fetchURL(
    "https://api-omnisteaks.ocp.finance/tvl/apps?q=1666600000"
  );

  let tvl = 0;
  tvl = response.data["totalTvl"];
  if (tvl === 0) {
    throw new Error("tvl is 0");
  }

  return tvl;
}

module.exports = {
  bsc: {
    fetch: fetchChain(56),
  },
  fetch,
};

'''
'''--- projects/Paraluni/index.js ---
const sdk = require("@defillama/sdk");
const { addFundsInMasterChef } = require("../helper/masterchef");
const BigNumber = require("bignumber.js");
const usdtAddr = "0x55d398326f99059ff775485246999027b3197955";
const busdAddr = "0xe9e7cea3dedca5984780bafc599bd69add087d56";
const usdtBusd = "0xEF7ae734a1E522498DF44d68853E9329674d51D5";
const ethAddr = "0x2170ed0880ac9a755fd29b2688956bd959f933f8";
const wBNBAddr = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
const paraChef = "0x77341bF31472E9c896f36F4a448fdf573A0D9B60";
const poolInfo = {
  "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
  "name": "poolInfo",
  "outputs": [{ "internalType": "contract IERC20", "name": "lpToken", "type": "address" }, {
    "internalType": "uint256",
    "name": "allocPoint",
    "type": "uint256"
  }, { "internalType": "uint256", "name": "lastRewardBlock", "type": "uint256" }, {
    "internalType": "uint256",
    "name": "accT42PerShare",
    "type": "uint256"
  }, { "internalType": "contract IParaTicket", "name": "ticket", "type": "address" }, {
    "internalType": "uint256",
    "name": "pooltype",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
};

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  //Some tokens are ignored because we modified the logic that a token can only create a pool.
  //It will only be added once below to prevent repeated calculations
  await addFundsInMasterChef(balances, paraChef, chainBlocks.bsc, "bsc", addr => `bsc:${addr}`, poolInfo, [
    usdtAddr,
    usdtBusd,
    ethAddr,
    wBNBAddr,
    busdAddr,
    "0x5976815f279D8bF22748f75072887591e1f65264",
    "0xcDD33E0A056470E281a03B1d1f3Ef05334f9dBE1",
    "0x781f5D719Dcd59B6eE01aDEE6170750DC9132247"

  ], true, false, V42);
  //add usdt pool
  let usdtBalance0 = (await sdk.api.erc20.balanceOf({
    target: usdtAddr,
    owner: paraChef,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${usdtAddr}`, usdtBalance0);
  //add usdt of usdt-busd
  let usdtBalance1 = (await sdk.api.erc20.balanceOf({
    target: usdtAddr,
    owner: usdtBusd,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${usdtAddr}`, usdtBalance1);
  //add busd of usdt-busd
  let busdBalance = (await sdk.api.erc20.balanceOf({
    target: busdAddr,
    owner: usdtBusd,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${busdAddr}`, busdBalance);
  //add eth
  let ethBalance = (await sdk.api.erc20.balanceOf({
    target: ethAddr,
    owner: paraChef,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${ethAddr}`, ethBalance);
  //add wbnb
  let wbnbBalance = (await sdk.api.erc20.balanceOf({
    target: wBNBAddr,
    owner: paraChef,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${wBNBAddr}`, wbnbBalance);
  return balances;
}

const pool2Addresses = [
  //BTCB_V42
  "0x7Bdc1963CA77f22C0c4829182876EBB2478e6380",
  //BUSD_V42
  "0xdbbDF41929d65c974C13c979A87B235377897DF9",
  //BNB_V42
  "0x478d1721f6FA74124C281CB17744249F51D55BC5"
];

const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
const BUSD = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";
const BTCB = "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c";
const V42 = "0xA573cD6890b50E02Dd658164882ee7B6A86C1122";

async function pool2(time, ethBlock, chainBlocks) {
  const balances = {};

  for (let idx = 0; idx < pool2Addresses.length; idx++) {
    const balances_slp = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: pool2Addresses[idx],
        params: paraChef,
        chain: "bsc",
        block: chainBlocks["bsc"]
      })
    ).output;

    const totalSupply_slp = (
      await sdk.api.erc20.totalSupply({
        target: pool2Addresses[idx],
        chain: "bsc",
        block: chainBlocks["bsc"]
      })
    ).output;

    const underlyingsBalance = (
      await sdk.api.abi.multiCall({
        calls: [BTCB, BUSD, WBNB, V42].map((token) => ({
          target: token,
          params: pool2Addresses[idx]
        })),
        abi: 'erc20:balanceOf',
        chain: "bsc",
        block: chainBlocks["bsc"]
      })
    ).output;

    underlyingsBalance.forEach((call) => {
      const underlyingSetBalance = BigNumber(call.output)
        .times(balances_slp)
        .div(totalSupply_slp);

      sdk.util.sumSingleBalance(
        balances,
        `bsc:${call.input.target}`,
        underlyingSetBalance.toFixed(0)
      );
    });
  }

  return balances;
}

module.exports = {
  start: 1651408734,
  bsc: {
    tvl: tvl,
    pool2: pool2
  }
};

'''
'''--- projects/RavelinFinance/index.js ---
const sdk = require("@defillama/sdk");
const { tombTvl } = require("../helper/tomb");

const ravTokenAddress = "0x9B7c74Aa737FE278795fAB2Ad62dEFDbBAedFBCA";
const rshareTokenAddress = "0xD81E377E9cd5093CE752366758207Fc61317fC70";
const rshareRewardPoolAddress = "0xa85B4e44A28B5F10b3d5751A68e03E44B53b7e89";
const boardroomAddress = "0x618C166262282DcB6Cdc1bFAB3808e2fa4ADFEc2";
const treasuryAddress = "0x351bDAC12449974e98C9bd2FBa572EdE21C1b7C4";

const mADALPs = [
  "0xd65005ef5964b035B3a2a1E79Ddb4522196532DE", // ravmADALpAddress
  "0x73bc306Aa2D393ff5aEb49148b7B2C9a8E5d39c8", //rsharemADALpAddress
];

module.exports = {
  ...tombTvl(ravTokenAddress, rshareTokenAddress, rshareRewardPoolAddress, boardroomAddress, mADALPs, "milkomeda", undefined, false, mADALPs[1])
}

'''
'''--- projects/Shibafantom/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')
const {transformFantomAddress} = require('../helper/portedTokens.js')

const factory = '0xeAcC845E4db0aB59A326513347a37ed4E999aBD8'
async function tvl(_timestamp, _ethBlock, chainBlocks){
  const transform = await transformFantomAddress();

  const balances = await calculateUniTvl(transform, chainBlocks['fantom'], 'fantom', factory, 3795376, true);
  return balances
}

module.exports = {
  fantom:{
    tvl,
  },
}
'''
'''--- projects/Solily/index.js ---
const BigNumber = require('bignumber.js')
const { getConnection } = require('../helper/solana')
const { PublicKey } = require('@solana/web3.js')
const utils = require('../helper/utils')

const programInfoKey = new PublicKey('4GmnzdmugEG4EcwqV5PqEYNsEpXR7KHHFjdUR581383U')

const stratTokens = [
  ['So11111111111111111111111111111111111111112', 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],   // ray lp: sol-usdc
  ['So11111111111111111111111111111111111111112', 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'],   // ray lp: sol-usdt
  ['4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R', 'So11111111111111111111111111111111111111112'],   // ray lp: ray-sol
  ['4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R', 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],  // ray lp: ray-usdc
  ['Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'], // larix USDT
  ['So11111111111111111111111111111111111111112'],  // larix SOL
  ['mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So'],  // larix mSOL
  ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'], // larix USDC
  ['9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E'], // larix btc
  [''],
  ['2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk'], // larix eth
]

const tokenMaps = {
  'So11111111111111111111111111111111111111112': 'solana',
  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'usd-coin',
  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'tether',
  '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R': 'raydium',
  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 'msol',
  '9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E': 'bitcoin',
  '2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk': 'ethereum',
}

var priceCache = new Map()
async function getTokenPrice(tokenPubkey)
{
  //console.log('getTokenPrice(' + tokenPubkey.toString() + ')')

  if (priceCache[tokenPubkey.toString()])
    return priceCache[tokenPubkey.toString()]

  var price = new BigNumber(1.0)

  const prefix = 'https://public-api.solscan.io/market/token/'
  const url = prefix + tokenPubkey.toString()

  const res = await utils.fetchURL(url)
  if (res && res.data && res.data.priceUsdt) {
    price = new BigNumber(res.data.priceUsdt)
    priceCache[tokenPubkey.toString()] = price
  }

  return price
}
async function getSolPrice()
{
  let tokenPubkey = 'So11111111111111111111111111111111111111112'
  var price = new BigNumber(80.0)

  const prefix = 'https://public-api.solscan.io/market/token/'
  const url = prefix + tokenPubkey

  const res = await utils.fetchURL(url)
  if (res && res.data && res.data.priceUsdt)
    price = new BigNumber(res.data.priceUsdt)

  return price
}

async function tvl() {
  const stratInfo = await getConnection().getAccountInfo(programInfoKey)

  const buffer = stratInfo.data
  let tvls = { }

  for (let i in stratTokens) {
    if (i == 9)
      continue

    const xu = buffer.readBigInt64LE(8 + i * 32)
    const pu = new BigNumber(xu).div(1000)
	   
    for (let token of stratTokens[i]) {
      const u = pu.div(stratTokens[i].length)
      const price = await getTokenPrice(new PublicKey(token))
      const amount = u.div(price)
      if (tvls[tokenMaps[token]])
        tvls[tokenMaps[token]] = tvls[tokenMaps[token]].plus(amount)
      else
        tvls[tokenMaps[token]] = amount
    }
  }

  return tvls
}

module.exports = {
  timetravel: false, 
  solana: {
    tvl,
  },
  methodology: 'TVL consists of staked tokens and ray-lps, saber-lps',
}

'''
'''--- projects/StrikeX.js ---
//const {uniTvlExport} = require("./helper/calculateUniTvl");
//const { staking } = require("./helper/staking");
const { masterChefExports } = require("./helper/masterchef")

const masterchef = "0x5867Cd4F7e105878AfbC903505c207eb7b130A50";
const token = "0xd6fdde76b8c1c45b33790cc8751d5b88984c44ec"

module.exports = {
  
    //staking: staking("5867cd4f7e105878afbc903505c207eb7b130a50", "bsc"),
    ...masterChefExports(masterchef, "bsc", token) 

};

'''
'''--- projects/VAX/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')

module.exports = {
   methodology: "Total Value Locked comprises of the sum of net liquidity at each pair of the Value Added eXchange (VAX), calculated using DefiLlamas native 'calculateusdUniTvl' module from SDK.",
   multivac: {
       tvl: calculateUsdUniTvl(
           "0xbaC576111e2BC5EfBbE7c5d765b9DC44083901fD",
           "multivac",
           "0x8E321596267a4727746b2F48BC8736DB5Da26977",
           [
               "0xEa1199d50Ee09fA8062fd9dA3D55C6F90C1bABd2",
               "0x86FF8138dcA8904089D3d003d16a5a2d710D36D2",
               "0x2Eb19Db032dC60039d35E36918d33197D9F7D7b9",
               "0xFC0c8D38166fc417F19De5B44CfC339079a70913",
               "0xCd65eb7630e5A2C46E1b99c0F3a45611be4960B2",
               "0x3b6e35574Fe60D7CeB9CA70DcA56D7294EF28926",
               "0x67558D91654A6ccbe88a3cc4e1DB862BC51fc322",
               "0x25009A734EfFE43cf7609Bc313E987d7ee8ee346",
               "0x282A0c6a96747bfF4BAa80eBa6CE6744aafaBEbB",
               "0x185B1FF9878D27DdE302A511FC2f80765232ADB7",
               "0x175E9B026cf31fbE181628C9BDAb3DF6143b6F18"
           ],
           "multivac"
       ),
   }
};

'''
'''--- projects/VersaGames/config.js ---
const config = {
  tokens: {
    versa: {
      id: "versa",
      symbol: "VERSA",
      addresses: {
        "0x19": "0x00d7699b71290094ccb1a5884cd835bd65a78c17",
      },
      decimals: 18,
    },
    xversa: {
      id: "xversa",
      symbol: "xVERSA",
      addresses: {
        "0x19": "0x8216E362d07741b562eBB02C61b1659B6B1258aD",
      },
      decimals: 18,
    },
  },
  chains: {
    cronos: {
      id: "0x19",
      name: "cronos",
    },
  },
};

module.exports = {
  config,
};

'''
'''--- projects/VersaGames/index.js ---
const { staking } = require("../helper/staking");
const { config } = require("./config");

const chain = config.chains["cronos"];
const versaAddress = config.tokens["versa"].addresses[chain.id];
const xVersaAddress = config.tokens["xversa"].addresses[chain.id];

module.exports = {
  timetravel: true,
  cronos: {
    staking: staking(xVersaAddress, versaAddress, chain.name),
    tvl: () => ({}),
  },
  methodology: "TVL is calculated as value of tokens in VERSA-xVERSA staking",
};

'''
'''--- projects/aada/index.js ---
const axios = require('axios')

async function staking(){
    const aadaLocked = (await axios.get("https://cardano-mainnet.blockfrost.io/api/v0/addresses/addr1wyvej5rmcrhfpcwrwmnqsjtwvf8gv3dn64vwy3xzekp95wqqhdkwa", {
        headers:{
            project_id: "mainnetTV9qV3mfZXbE6e44TVGMe1UoRlLrpSQt"
        }
    })).data.amount.find(token=>token.unit==="8fef2d34078659493ce161a6c7fba4b56afefa8535296a5743f6958741414441").quantity;

    const topPrice = (await axios.get("https://orders.muesliswap.com/orderbook/?policy-id=8fef2d34078659493ce161a6c7fba4b56afefa8535296a5743f69587&tokenname=AADA")
  ).data.buy[0].price;
    
    return {
        cardano: aadaLocked * topPrice
    }
}

module.exports={
    misrepresentedTokens: true,
    methodology: 'Counts amount of AADA staked; by a price of ADA sitting in the orderbook.',
    timetravel: false,
    cardano:{
        staking,
        tvl:()=>({}),
    }
}

'''
'''--- projects/aave-arc/index.js ---
const { aaveExports } = require('../helper/aave');

// start block: 13431423
module.exports = {
    ethereum: aaveExports("ethereum", "0x6FdfafB66d39cD72CFE7984D3Bbcc76632faAb00", id=>id, ["0x71B53fC437cCD988b1b89B1D4605c3c3d0C810ea"]),
};
'''
'''--- projects/aave-v1/index.js ---
const { singleAssetV1Market,uniswapV1Market } = require('../aave/v1');

// v1
const aaveLendingPoolCore = "0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3";
const uniswapLendingPoolCore = "0x1012cfF81A1582ddD0616517eFB97D02c5c17E25";

function ethereum(borrowed) {
  return async (timestamp, block)=> {
    const balances = {}

    await singleAssetV1Market(balances, aaveLendingPoolCore, block, borrowed)
    await uniswapV1Market(balances, uniswapLendingPoolCore, block, borrowed)
    return balances
  }
}

module.exports = {
    ethereum: {
      tvl: ethereum(false),
      borrowed: ethereum(true),
    },
};
'''
'''--- projects/aave/amm.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");
const abi = require('../helper/abis/aave.json');
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');

async function ammMarket(balances, block, borrowed) {
    const lendingPool = "0x7937D4799803FbBe595ed57278Bc4cA21f3bFfCB"
    const reservesList = (await sdk.api.abi.call({
        target: lendingPool,
        abi: abi.getReservesList,
        block
    })).output
    const reservesData = await sdk.api.abi.multiCall({
        abi: abi.getAMMReserveData,
        calls: reservesList.map(r => ({
            target: lendingPool,
            params: r
        })),
        block
    })
    const [balanceOfTokens, symbols] = await Promise.all([
        sdk.api.abi.multiCall({
            abi: "erc20:balanceOf",
            calls: reservesData.output.map((r, idx) => ({
                target: reservesList[idx],
                params: r.output.aTokenAddress
            })),
            block
        }),
        sdk.api.abi.multiCall({
            abi: "erc20:symbol",
            calls: reservesData.output.map((r, idx) => ({
                target: reservesList[idx],
            })),
            block
        }),
    ]);

    if (borrowed) {
        const [supplyStabledebt, supplyVariableDebt] = await Promise.all(["stableDebtTokenAddress", "variableDebtTokenAddress"].map(prop =>
            sdk.api.abi.multiCall({
                abi: "erc20:totalSupply",
                calls: reservesData.output.map((r, idx) => ({
                    target: r.output[prop],
                })),
                block
            })
        ));
        supplyStabledebt.output.map((ssd, i) => {
            balanceOfTokens.output[i].output = BigNumber(ssd.output).plus(supplyVariableDebt.output[i].output).toFixed(0)
        })
    }

    const balancerLps = []
    const uniLps = []
    symbols.output.forEach((symbol, i) => {
        const token = symbol.input.target
        const balance = balanceOfTokens.output[i].output
        if (symbol.output === "BPT") {
            balancerLps.push({
                token,
                balance,
            })
        } else if (symbol.output === "UNI-V2") {
            uniLps.push({
                token,
                balance,
            })
        } else {
            sdk.util.sumSingleBalance(balances, token, balance);
        }
    })

    const balancerTokens = await sdk.api.abi.multiCall({
        abi: abi.getCurrentTokens,
        calls: balancerLps.map(r => ({
            target: r.token,
        })),
        block
    });

    await Promise.all(balancerLps.map(async (bal, idx) => {
        const [amountsOnPair, totalSupply] = await Promise.all([
            sdk.api.abi.multiCall({
                abi: "erc20:balanceOf",
                calls: balancerTokens.output[idx].output.map((r) => ({
                    target: r,
                    params: bal.token
                })),
                block
            }),
            sdk.api.erc20.totalSupply({
                target: bal.token,
                block
            })
        ]);
        balancerTokens.output[idx].output.forEach((token, ydx) => {
            const tokenBalance = BigNumber(amountsOnPair.output[ydx].output).times(bal.balance).div(totalSupply.output)
            sdk.util.sumSingleBalance(balances, token, tokenBalance.toFixed(0))
        })
    }))
    await unwrapUniswapLPs(balances, uniLps, block)
}

module.exports = {
    ammMarket
}
'''
'''--- projects/aave/index.js ---
const sdk = require('@defillama/sdk');
const { getV2Reserves, getTvl, getBorrowed, aaveChainTvl } = require('../helper/aave');
const { staking } = require('../helper/staking');
const { ammMarket } = require('./amm');
const { unwrapBalancerToken } = require('../helper/unwrapLPs');

const addressesProviderRegistryETH = "0x52D306e36E3B6B02c153d0266ff0f85d18BCD413";

function ethereum(borrowed) {
  return async (timestamp, block)=> {
    const balances = {}

    // V2 TVLs
    if (block >= 11360925) {
      const [v2Atokens, v2ReserveTokens, dataHelper] = await getV2Reserves(block, addressesProviderRegistryETH, 'ethereum')
      if(borrowed){
        await getBorrowed(balances, block, "ethereum", v2ReserveTokens, dataHelper, id=>id);
      } else {
        await getTvl(balances, block, 'ethereum', v2Atokens, v2ReserveTokens, id => id);
      }
    }
    if (block >= 11998773) {
      await ammMarket(balances, block, borrowed)
    }

    return balances;
  }
}

const aaveTokenAddress = "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9";

async function stakingBalancerTvl(timestamp, block) {
  return unwrapBalancerToken({ block, owner: '0xa1116930326d21fb917d5a27f1e9943a9595fb47', balancerToken: '0x41a08648c3766f9f9d85598ff102a08f4ef84f84' })
}

const aaveStakingContract = "0x4da27a545c0c5b758a6ba100e3a049001de870f5";

function v2(chain, v2Registry){
  const section = borrowed => sdk.util.sumChainTvls([
    aaveChainTvl(chain, v2Registry, undefined, undefined, borrowed),
  ])
  return {
    tvl: section(false),
    borrowed: section(true)
  }
}

module.exports = {
  timetravel: true,
  methodology: `Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending`,
  ethereum: {
    staking: staking(aaveStakingContract, aaveTokenAddress),
    pool2: stakingBalancerTvl,
    tvl: ethereum(false),
    borrowed: ethereum(true),
  },
  avalanche: v2("avax", "0x4235E22d9C3f28DCDA82b58276cb6370B01265C2"),
  polygon: v2("polygon", "0x3ac4e9aa29940770aeC38fe853a4bbabb2dA9C19"),
};
// node test.js projects/aave/index.js
'''
'''--- projects/aave/v1.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");
const abi = require('../helper/abis/aave.json');

async function getV1Assets(lendingPoolCore, block, chain) {
    const reserves = (
        await sdk.api.abi.call({
            target: lendingPoolCore,
            abi: abi["getReserves"],
            block,
            chain
        })
    ).output;

    return reserves
}

const ethReplacement = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'

async function multiMarketV1TvlBorrowed(balances, lendingPoolCore, block, chain, eth) {
    const reserves = await getV1Assets(lendingPoolCore, block, chain);
    const totalBorrowed = await sdk.api.abi.multiCall({
        block,
        calls: reserves.map((reserve) => ({
            target: lendingPoolCore,
            params: reserve,
        })),
        abi: abi.getReserveTotalBorrows,
        chain
    });
    totalBorrowed.output.forEach(borrowed=>{
        const token = borrowed.input.params[0]
        sdk.util.sumSingleBalance(balances, token === ethReplacement?eth:token, borrowed.output)
    })

    return balances;
}

async function depositMultiMarketV1Tvl(balances, lendingPoolCore, block, chain, eth) {
    const reserves = (await getV1Assets(lendingPoolCore, block, chain)).filter(reserve => reserve !== ethReplacement);

    sdk.util.sumSingleBalance(balances, eth, (await sdk.api.eth.getBalance({ target: lendingPoolCore, block, chain })).output)

    const balanceOfResults = await sdk.api.abi.multiCall({
        block,
        calls: reserves.map((reserve) => ({
            target: reserve,
            params: lendingPoolCore,
        })),
        abi: "erc20:balanceOf",
        chain,
    });

    sdk.util.sumMultiBalanceOf(balances, balanceOfResults, true);

    return balances;
}

function multiMarketV1Tvl(balances, lendingPoolCore, block, borrowed, chain="ethereum", eth = "0x0000000000000000000000000000000000000000") {
    return (borrowed?multiMarketV1TvlBorrowed:depositMultiMarketV1Tvl)(balances, lendingPoolCore, block, chain, eth)
}

async function singleAssetV1Market(balances, lendingPoolCore, block, borrowed, chain, eth) {
    return multiMarketV1Tvl(balances, lendingPoolCore, block, borrowed, chain, eth);
}

async function uniswapV1Market(balances, uniswapLendingPoolCore, block, borrowed, eth = "0x0000000000000000000000000000000000000000"){
    const uniswapMarketTvlBalances = {}
    await multiMarketV1Tvl(
        uniswapMarketTvlBalances,
        uniswapLendingPoolCore,
        block,
        borrowed
    );

    const uniswapv1Calls = Object.keys(uniswapMarketTvlBalances).map(t => ({ target: t }));
    const [uniswapV1Tokens, uniswapV1EthBalance, uniswapV1Supplies] = await Promise.all([
        sdk.api.abi.multiCall({
            abi: { "name": "tokenAddress", "outputs": [{ "type": "address", "name": "out" }], "inputs": [], "constant": true, "payable": false, "type": "function", "gas": 1413 },
            calls: uniswapv1Calls,
            block
        }),
        sdk.api.eth.getBalances({
            targets: Object.keys(uniswapMarketTvlBalances),
            block
        }),
        sdk.api.abi.multiCall({
            abi: 'erc20:totalSupply',
            calls: uniswapv1Calls,
            block
        }),
    ])

    const uniswapV1TokenBalance = await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: uniswapV1Tokens.output.map(t => ({
            target: t.output,
            params: t.input.target
        })),
        block
    })

    // ...add v1 uniswap market TVL
    Object.keys(uniswapMarketTvlBalances).forEach((address, idx) => {
        const balance = uniswapMarketTvlBalances[address];
        if (uniswapV1Tokens.output[idx].success === false) {
            sdk.util.sumSingleBalance(balances, address, balance)
        } else {
            const tokenBalance = BigNumber(uniswapV1TokenBalance.output[idx].output).times(balance).div(uniswapV1Supplies.output[idx].output)
            const ethBalance = BigNumber(uniswapV1EthBalance.output[idx].balance).times(balance).div(uniswapV1Supplies.output[idx].output)
            const token = uniswapV1Tokens.output[idx].output
            sdk.util.sumSingleBalance(balances, token, tokenBalance.toFixed(0))
            sdk.util.sumSingleBalance(balances, eth, ethBalance.toFixed(0))
        }
    });

    return balances
}

module.exports={
    singleAssetV1Market,
    uniswapV1Market
}
'''
'''--- projects/aave/v3.js ---
const { aaveChainTvl } = require('../helper/aave');

const v3params = ["0x770ef9f4fe897e59daCc474EF11238303F9552b6", undefined, ["0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654"]]

function v3(chain){
    const section = borrowed => aaveChainTvl(chain, ...v3params, borrowed, true);
    return {
      tvl: section(false),
      borrowed: section(true)
    }
  }
  
  module.exports = {
    timetravel: true,
    methodology: `Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending`,
    avalanche: v3("avax"),
    ...["optimism", "fantom", "harmony", "arbitrum", "polygon"].reduce((t, c)=>({...t, [c]:v3(c)}), {})
  };
  // node test.js projects/aave/index.js
'''
'''--- projects/aavegotchi/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");
const { transformPolygonAddress } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { request, gql } = require("graphql-request");

const vaultContractETH = "0xFFE6280ae4E864D9aF836B562359FD828EcE8020";
const tokensETH = [
  "0x3F382DbD960E3a9bbCeaE22651E88158d2791550", // GHST
  "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
];

const vaultContractsPolygon = [
  "0xb208f8BB431f580CC4b216826AFfB128cd1431aB", // vaultContract
  "0x27DF5C6dcd360f372e23d5e63645eC0072D0C098", // rarityFarmingContract
];

const GHST_Polygon = "0x385eeac5cb85a38a9a07a70c73e0a3271cfb54a7";
const stkGHST_QUICKContract = "0xA02d547512Bb90002807499F05495Fe9C4C3943f";
const GHST_pools2 = [
    "0xccb9d2100037f1253e6c1682adf7dc9944498aff", // WETH_GHST_UNIV2
    "0x8B1Fd78ad67c7da09B682c5392b65CA7CaA101B9", // GHST_QUICK_UNIV2
    "0x096C5CCb33cFc5732Bcd1f3195C13dBeFC4c82f4"  // GHST_USDC_UNIV2
]

const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  for (const token of tokensETH) {
    await sumTokensAndLPsSharedOwners(
      balances,
      [[token, false]],
      [vaultContractETH]
    );
  }

  return balances;
};

const graphUrl = 'https://api.thegraph.com/subgraphs/name/aavegotchi/aavegotchi-core-matic'
const graphQuery = gql`
query GET_SUMMONED_GOTCHIS ($minGotchiId: Int, $block: Int) {
  aavegotchis(
    first: 1000
    skip: 0
    block: { number: $block }
    where: {
      status: "3" # summoned gotchis
      gotchiId_gt: $minGotchiId
    }
    orderBy: gotchiId
    orderDirection: asc
  ) {
    gotchiId
    collateral
    stakedAmount
  }
}`
async function getGotchisCollateral(timestamp, block) {
  const allGotchis = [];
  let minGotchiId = 0;
  while (minGotchiId !== -1) {
    const { aavegotchis } = await request(
      graphUrl,
      graphQuery, 
      {minGotchiId, block}
    );
    if (aavegotchis && aavegotchis.length > 0) {
      minGotchiId = parseInt(aavegotchis[aavegotchis.length - 1].gotchiId);
      allGotchis.push(...aavegotchis);
    } else {
      minGotchiId = -1;
    }
  }
  const gotchisBalances = {
    output: allGotchis.map(g => ({
      input: {target: g.collateral},
      success: true,
      output: g.stakedAmount
    }))
  };

  const balances = {};
  sdk.util.sumMultiBalanceOf(balances, gotchisBalances, true, x => 'polygon:' + x);
  return gotchisBalances;
}

const polygonTvl = async (timestamp, block, chainBlocks) => {
  const balances = {};

  let transformAddress = await transformPolygonAddress();

  await sumTokensAndLPsSharedOwners(
    balances,
    [[GHST_Polygon, false]],
    vaultContractsPolygon,
    chainBlocks["polygon"],
    "polygon",
    transformAddress
  );

  const gotchisBalances = await getGotchisCollateral(timestamp, chainBlocks["polygon"]);
  sdk.util.sumMultiBalanceOf(balances, gotchisBalances, true, x => 'polygon:' + x);

  return balances;
};

module.exports = {
  timetravel: true,
  ethereum: {
    tvl: ethTvl,
  },
  polygon: {
    staking: staking(stkGHST_QUICKContract, GHST_Polygon, "polygon"),
    tvl: polygonTvl,
    pool2: pool2s([stkGHST_QUICKContract], GHST_pools2, "polygon")
  },
  methodology:
    `We count liquidity on Vaults from ETHEREUM and Polygon chains through Vault Contracts;
    On Rarity Farming, Staking and Pool2s parts on Polygon chain through their Contrats`,
};

'''
'''--- projects/abracadabra/abi.json ---
{
  "balanceOf": {
    "inputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/abracadabra/api.js ---
const {fetchChainExports} = require('../helper/exports')
const {fetchURL} = require('../helper/utils')

const endpoint = "https://analytics.abracadabra.money/api/statistic/tvl"

const chainIds = {
    ethereum: 1,
    //bsc: 56,
    fantom: 250,
    arbitrum: 42161,
    avax: 43114
}

function chainTvl(chain){
    return async()=>{
        const data = await fetchURL(endpoint)
        return data.data.networks[chainIds[chain]]
    }
}

module.exports = fetchChainExports(chainTvl, Object.keys(chainIds))
'''
'''--- projects/abracadabra/index.js ---
const sdk = require('@defillama/sdk');
const marketsJSON = require('./market.json');
const abi = require('./abi.json');
const { unwrapCrv, unwrapYearn } = require('../helper/unwrapLPs')
const { transformAvaxAddress, transformArbitrumAddress, transformFantomAddress 
    } = require("../helper/portedTokens");
const { getBlock } = require('../helper/getBlock');

// --------------------------
// cvx3pool & yvcrvIB tokens
// are not being unwrapped
// on eth (~$169M tvl)
// --------------------------
const bentoBoxAddresses = {
    "ethereum": "0xF5BCE5077908a1b7370B9ae04AdC565EBd643966",
    "arbitrum": "0x74c764D41B77DBbb4fe771daB1939B00b146894A",
    "avax": "0xf4F46382C2bE1603Dc817551Ff9A7b333Ed1D18f",
    "fantom": "0xF5BCE5077908a1b7370B9ae04AdC565EBd643966"
};
async function transformEthAddress() {
    return (addr) => {
        switch(addr.toLowerCase()) {
            case '0xca76543cf381ebbb277be79574059e32108e3e65':
                return '0x383518188c0c6d7730d91b2c03a03c837814a899';
            default:
                return addr;
        };
    };
};
async function ethTvl(timestamp, ethBlock, chainBlocks) {
    return tvl(timestamp, chainBlocks, 'ethereum', (await transformEthAddress()));
};
async function ftmTvl(timestamp, ethBlock, chainBlocks) {
    return tvl(timestamp, chainBlocks, 'fantom', (await transformFantomAddress()));
};
async function arbiTvl(timestamp, ethBlock, chainBlocks) {
    return tvl(timestamp, chainBlocks, 'arbitrum', (await transformArbitrumAddress()));
};
async function avaxTvl(timestamp, ethBlock, chainBlocks) {
    return tvl(timestamp, chainBlocks, 'avax', (await transformAvaxAddress()));
};
async function tvl(timestamp, chainBlocks, chain, transformAddress=addr=>addr) {
    let marketsArray = [];
    let balances = {};
    let block;

    for (const [marketContract, lockedToken] of Object.entries(marketsJSON[chain])) {
        marketsArray.push([lockedToken, marketContract]);
    };

    if (chainBlocks[chain]) {
        block = chainBlocks[chain];
    } else {
        block = await getBlock(timestamp, chain, chainBlocks);
    };

    let tokenBalances = (await sdk.api.abi.multiCall({
        block: block,
        calls: marketsArray.map((market) => ({
            target: bentoBoxAddresses[chain],
            params: market
        })),
        abi: abi.balanceOf,
        chain: chain
    })).output.map(t => t.output);

    for (let index = 0; index < marketsArray.length; index++) {
        sdk.util.sumSingleBalance(
          balances,
          transformAddress(marketsArray[index][0]),
          tokenBalances[index]
        );
        await unwrapYearn(balances, marketsArray[index][0], block, chain, transformAddress);
      };
    for (let [token, balance] of Object.entries(balances)) {
        await unwrapCrv(balances, token, balance, block, chain, transformAddress);
    };
    if ('0x383518188c0c6d7730d91b2c03a03c837814a899' in balances) {
        balances['0x383518188c0c6d7730d91b2c03a03c837814a899'] = 
            balances['0x383518188c0c6d7730d91b2c03a03c837814a899'] / 10**9;
    };
    return balances;
};
module.exports = {
    ethereum: {
        tvl: ethTvl
    },
    arbitrum: {
        tvl: arbiTvl
    },
    avax: {
        tvl: avaxTvl
    },
    fantom: {
        tvl: ftmTvl
    },
}
'''
'''--- projects/abracadabra/market.json ---
{
    "ethereum": {
        "0x7b7473a76D6ae86CE19f7352A1E89F6C9dc39020":"0xdbdb4d16eda451d0503b854cf79d55697f90c8df",
        "0x806e16ec797c69afa8590A55723CE4CC1b54050E":"0xd92494cb921e5c0d3a39ea88d0147bbd82e51008",
        "0x05500e2Ee779329698DF35760bEdcAAC046e7C27":"0x4e15361fd6b4bb609fa63c81a2be19d873717870",
        "0x003d5A75d284824Af736df51933be522DE9Eed0f":"0xca76543cf381ebbb277be79574059e32108e3e65",
        "0x98a84EfF6e008c5ed0289655CcdCa899bcb6B99F":"0x8798249c2e607446efb7ad49ec89dd1865ff4272",
        "0xEBfDe87310dc22404d918058FAa4D56DC4E93f0A":"0x27b7b1ad7288079a66d12350c828d3c00a6f07d7",
        "0x0BCa8ebcB26502b013493Bf8fE53aA2B1ED401C1":"0xdcd90c7f6324cfa40d7169ef80b12031770b4325",
        "0x6cbAFEE1FaB76cA5B5e144c43B3B50d42b7C8c8f":"0x5f18c75abdae578b483e5f43f12a39cf75b973a9",
        "0x551a7CfF4de931F32893c928bBc3D25bF1Fc5147":"0x7da96a3891add058ada2e826306d812c638d87a7",
        "0x920D9BD936Da4eAFb5E25c6bDC9f6CB528953F9f":"0xa258c4606ca8206d8aa700ce2143d7db854d168c",
        "0xFFbF4892822e0d552CFF317F65e1eE7b5D3d9aE6":"0xe14d13d8b3b85af791b2aadd661cdbd5e6097db1",
        
        "0x6Ff9061bB8f97d948942cEF376d98b51fA38B91f":"0xa9fe4601811213c340e850ea305481aff02f5b28",
        "0xbb02A884621FB8F5BFd263A67F58B65df5b090f3":"0x8798249c2e607446efb7ad49ec89dd1865ff4272"
    },
    "fantom": {
        "0x8E45Af6743422e488aFAcDad842cE75A09eaEd34": "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
        "0xd4357d43545F793101b592bACaB89943DC89d11b": "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83"
    },
    "avax": {
        "0x3CFEd0439aB822530b1fFBd19536d897EF30D2a2": "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7"
    },
    "arbitrum": {
        "0xC89958B03A55B5de2221aCB25B58B89A000215E6": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
    }
}
'''
'''--- projects/acala-dex/api.js ---

const { dex } = require('../helper/acala/dex')

module.exports = {
  acala: { tvl: async () => dex('acala') },
};
'''
'''--- projects/acala-dex/index.js ---
const { getExports } = require('../helper/heroku-api')

module.exports = {
  timetravel: false,
  ...getExports("acala-dex", ['acala']),
}
'''
'''--- projects/acala-lcdot/api.js ---

const { staking } = require('../helper/acala/lcdot')

module.exports = {
  acala: { tvl: async () => staking('acala') },
};
'''
'''--- projects/acala-lcdot/index.js ---
const { getExports } = require('../helper/heroku-api')

module.exports = {
  timetravel: false,
  ...getExports("acala-lcdot", ['acala']),
}
'''
'''--- projects/acala-lending/api.js ---

const { lending } = require('../helper/acala/lending')

module.exports = {
  acala: { tvl: async () => lending('acala') },
};
'''
'''--- projects/acala-lending/index.js ---
const {getExports} = require('../helper/heroku-api')

module.exports = {
    timetravel: false,
    ...getExports("acala-lending", ['acala'])
}
'''
'''--- projects/acala-staking/api.js ---

const { staking } = require('../helper/acala/liquidStaking')

module.exports = {
  acala: { tvl: async () => staking('acala') },
};
'''
'''--- projects/acala-staking/index.js ---
const {getExports} = require('../helper/heroku-api')

module.exports = {
    timetravel: false,
    ...getExports("acala-staking", ['acala'])
}
'''
'''--- projects/acoconut/abis/singlePlus.json ---
{
  "totalUnderlying": {
    "inputs": [],
    "name": "totalUnderlying",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/acoconut/abis/vault.json ---
{
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balance": {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/acoconut/index.js ---
const sdk = require('@defillama/sdk');
const vaultAbi = require('./abis/vault');
const singlePlusAbi = require('./abis/singlePlus');

const BigNumber = require('bignumber.js');

const tokensInacBTC = [
  '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
  '0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D'
]

const acBTCTokenHolder = '0x73FddFb941c11d16C827169Bb94aCC227841C396'

const bscSingleTokens = [
  '0xcf8D1D3Fce7C2138F85889068e50F0e7a18b5321', //vBTC+
  '0x73FddFb941c11d16C827169Bb94aCC227841C396', //fBTCB+
  '0xD7806143A4206aa9A816b964e4c994F533b830b0', //acsBTCB+
  '0x02827D495B2bBe37e1C021eB91BCdCc92cD3b604', //autoBTC+
]

const btcb = 'bsc:0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c'

async function eth(timestamp, block) {
  const balances = {};

  const underlyingacBTC = await sdk.api.abi.multiCall({
    calls: tokensInacBTC.map(token => ({
      target: token,
      params: [acBTCTokenHolder]
    })),
    abi: 'erc20:balanceOf',
    block,
  });
  sdk.util.sumMultiBalanceOf(balances, underlyingacBTC)
  
  return balances;
}

async function bsc(timestamp, block, chainBlocks) {
  const balances = {};

  const bscBlock = chainBlocks.bsc

  balances[btcb] = '0'

  const totalUnderlyingResults = await sdk.api.abi.multiCall({
    block: bscBlock.block,
    calls: bscSingleTokens.map((address) => ({
      target: address
    })),
    abi: singlePlusAbi["totalUnderlying"],
    chain: 'bsc'
  });

  totalUnderlyingResults.output.forEach((tokenBalanceResult) => {
      const valueInToken = tokenBalanceResult.output;
      const singleTokenAddress = tokenBalanceResult.input.target;
      balances[btcb] = BigNumber(balances[btcb]).plus(valueInToken).toFixed(0);
  });

  return balances;
}

module.exports = {
  ethereum:{
    tvl: eth,
  },
  bsc:{
    tvl: bsc
  },
  start: 1600185600,    // 09/16/2020 @ 12:00am (UTC+8)
};

'''
'''--- projects/across/abi.json ---
{
    "l1Token": {
        "inputs": [],
        "name": "l1Token",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "pooledTokens": {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "pooledTokens",
        "outputs": [
            {
                "internalType": "address",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "isEnabled",
                "type": "bool"
            },
            {
                "internalType": "uint32",
                "name": "lastLpFeeUpdate",
                "type": "uint32"
            },
            {
                "internalType": "int256",
                "name": "utilizedReserves",
                "type": "int256"
            },
            {
                "internalType": "uint256",
                "name": "liquidReserves",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "undistributedLpFees",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/across/index.js ---
const sdk = require("@defillama/sdk");
const { requery } = require("../helper/requery");
const abi = require("./abi");

const hubPoolAddress = "0xc186fA914353c44b2E33eBE05f21846F1048bEda"

// Captures TVL for Across liquidity pools on L1
async function across(timestamp, block) {
  const balances = {};
  const logs = await sdk.api.util.getLogs({
    target: "0x30B44C676A05F1264d1dE9cC31dB5F2A945186b6",
    topic: "WhitelistToken(uint256,address,address,address)",
    keys: ["topics"],
    fromBlock: 13544988,
    toBlock: block,
  });
  const v2Logs = await sdk.api.util.getLogs({
    target: hubPoolAddress,
    topic: "LiquidityAdded(address,uint256,uint256,address)",
    keys: ["topics"],
    fromBlock: 14819537,
    toBlock: block,
  });

  const v2CollateralAddresses = v2Logs.output.map(function (collateral) {
    return collateral[1];
  });

  const uniqueV2Collateral = [
    ...new Set(v2CollateralAddresses.map((a) => JSON.stringify('0x' + a.slice(26)))),
  ].map((a) => JSON.parse(a));

  const v2LpTokens = await sdk.api.abi.multiCall({
    calls: uniqueV2Collateral.map((poolLog) => ({
      target: hubPoolAddress,
      params: poolLog
    })),
    block,
    abi: abi.pooledTokens,
  });

  const v2pools = v2LpTokens.output
  .filter((t) => t.output !== null)
  .map((c) => [c.input.params[0], c.output.lpToken])

  const bridgePoolAddresses = logs.output.map(function (bridgePool) {
    return bridgePool[3];
  });
  const uniquePools = [
    ...new Set(bridgePoolAddresses.map((a) => JSON.stringify(a))),
  ].map((a) => JSON.parse(a));
  const collaterals = await sdk.api.abi.multiCall({
    calls: uniquePools.map((poolLog) => ({
      target: `0x${poolLog.slice(26)}`,
    })),
    block,
    abi: abi.l1Token,
  });
  await requery(collaterals, "ethereum", block, abi);
  const poolCollaterals = collaterals.output
    .filter((t) => t.output !== null)
    .map((c) => [c.output, c.input.target])

  const mergePools = [...poolCollaterals, ...v2pools]
  await Promise.all(mergePools.map(async poolCollateral=>{
    const poolSupply = await sdk.api.erc20.totalSupply({
      target: poolCollateral[1],
      block
    })
    sdk.util.sumSingleBalance(
      balances,
      poolCollateral[0],
      poolSupply.output
    );
  }))
  return balances;
}

module.exports = {
  ethereum: {
    tvl: across,
  }
};
'''
'''--- projects/acryptos/index.js ---
const utils = require('../helper/utils');
const { toUSDTBalances } = require('../helper/balances');
let _response

function fetchallchain(chainId) {
  return async () => {
    if (!_response) _response = utils.fetchURL('https://api.unrekt.net/api/v2/acryptos-asset')
    const response = await _response;

    let tvl  = 0;
    const total_tvl = response.data.acryptos.total_tvl;

    tvl = total_tvl[chainId];
    return toUSDTBalances(tvl);
  }
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: false,
  methodology: "Acryptos TVL is the USD value of token within the vault and farm contracts",
  bsc: {
    tvl: fetchallchain(56),
  },
  cronos: {
    tvl: fetchallchain(25),
  },
  avalanche: {
    tvl: fetchallchain(43114),
  },
  fantom: {
    tvl: fetchallchain(250),
  },
  moonriver: {
    tvl: fetchallchain(1285),
  },
  moonbeam: {
    tvl: fetchallchain(1284),
  },
  harmony: {
    tvl: fetchallchain(1666600000),
  }
  

}

'''
'''--- projects/acumen/index.js ---
const {getTokenBalance} = require('../helper/solana')

async function tvl() {
    const [usdcAmount,
        btcAmount,
        srmAmount,
        usdtAmount, //added
        ethAmount,
        rayAmount,
        stepAmount,
        xstepAmount, //added
        solAmount,
        sbrmssAmount, //changed for tulipa
        sbrAmount,
        sbrusdAmount, //added
        saberwustAmount, //added
        merAmount] = await Promise.all([
        //usdc
        getTokenBalance("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //btc
        getTokenBalance("9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //srm
        getTokenBalance("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //usdt
        getTokenBalance("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"), //added
        //eth
        getTokenBalance("2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //ray
        getTokenBalance("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //step
        getTokenBalance("StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //xstep
        getTokenBalance("xStpgUCss9piqeFUk2iLVcvJEGhAdJxJQuwLkXP555G", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"), //added  = 0
        //sol
        getTokenBalance("So11111111111111111111111111111111111111112", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //sbrm
        getTokenBalance("DLukwcEV1bhGxzkZmQMNXtTjr1Mre42VvjQYiFjeRAsc", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"), //changed for tulipa = 0
        //sbr   
        getTokenBalance("Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),
        //sbrusd
        getTokenBalance("7QbiocpcnMs5qTXsvUDQ4HJ2yZwFC1DA4f2d2w9Bj52L", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"), //added = 0
        //sbrust
        getTokenBalance("3reHdP6RnTvv5cqp7bXDm7ah2Q3t4mfJh8Ekj3EVNWkB", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"), //added = 0
        //mer
        getTokenBalance("MERt85fc5boKw3BW1eYdxonEuJNvXbiMbs6hvheau5K", "5nDMa98okBQRNyQrtei1YBMCSFd1Nrkb9FZxf39g8aEW"),

    ])

    return {
        'bitcoin': btcAmount, 
        'ethereum': ethAmount,
        'solana':solAmount,
        'serum': srmAmount,
        'tether': usdtAmount, //added
        'step-finance':stepAmount,
        'step-staking':xstepAmount, //added
        'raydium': rayAmount,
        'usd-coin': usdcAmount,
        'saber': sbrAmount,
        'usdt-saber': sbrusdAmount, //added
        'saber-mSol': sbrmssAmount, // changed for tulipa
        'saber-wust': saberwustAmount, //added
        'mercurial': merAmount,
    }
}   

module.exports = {
    timetravel: false,
    tvl,
    methodology: `To obtain the Acumen TVL we make on-chain calls using the function getTokenBalance() that uses the address of the token and the address of the contract where the token is located. The addresses used are the pool address where the corresponding tokens were deposited as collateral to borrow and or earn, borrowed tokens are not counted and these addresses are hard-coded. These calls return the number of tokens held in each pool contract. We then use Coingecko to get the price of each token in USD to export the sum of all tokens.`,
}
'''
'''--- projects/adamantfinance/abi.json ---
{
  "balance": {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOfVault": {
      "inputs": [],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
  },
  "balanceOf": {
    "stateMutability": "view",
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "arg0",
        "type": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ]
  },
  "minter": {
    "stateMutability": "view",
    "type": "function",
    "name": "minter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ]
  },
  "totalSupply": {
    "stateMutability": "view",
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ]
  },
  "coins": {
    "stateMutability": "view",
    "type": "function",
    "name": "coins",
    "inputs": [
      {
        "name": "arg0",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ]
  },
  "lp_token": {
    "stateMutability":"view",
    "type":"function",
    "name":"lp_token",
    "inputs":[],
    "outputs":[
      {
        "name":"",
        "type":"address"
      }
    ]
  },
  "decimals": {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
        {
            "name": "",
            "type": "uint8"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/adamantfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const utils = require("../helper/utils");
const { stakings } = require("../helper/staking");
const { unwrapUniswapLPs, sumTokens, } = require("../helper/unwrapLPs");
const {
  transformPolygonAddress,
  getChainTransform,
  getFixBalances,
} = require("../helper/portedTokens");
const BigNumber = require("bignumber.js");

const vaultsUrl = {
  polygon:
    "https://raw.githubusercontent.com/eepdev/vaults/main/current_vaults.json",
  arbitrum:
    "https://raw.githubusercontent.com/eepdev/vaults/main/arbitrum_vaults.json",
  cronos:
    "https://raw.githubusercontent.com/eepdev/vaults/main/cronos_vaults.json",
};

/*** Polygon Addresses ***/
const stakingContracts_polygon = [
  "0x920f22E1e5da04504b765F8110ab96A20E6408Bd",
];

const vaultAddresses_polygon = ["0xF7661EE874Ec599c2B450e0Df5c40CE823FEf9d3"]; //ADDY/WETH staking contract

const lpAddresses_polygon = ["0xa5bf14bb945297447fe96f6cd1b31b40d31175cb"]; //ADDY/WETH

const ADDY = "0xc3fdbadc7c795ef1d6ba111e06ff8f16a20ea539";

/*** Arbitrum Addresses ***/
const stakingContracts_Arbitrum = [
  "0x097b15dC3Bcfa7D08ea246C09B6A9a778e5b007B",
  "0xc5fFd083B983AAF823a9b485b207F898ed2f32DC",
  "0x9d5d0cb1B1210d4bf0e0FdCC6aCA1583fA48f0fD",
];

const lpAddresses_arbitrum = [];
const ARBY = "0x09ad12552ec45f82bE90B38dFE7b06332A680864"

/*** Cronos Addresses ***/
const stakingContracts_cronos = [
  "0x3f04D6bD50A79c854EF42965471D34E389eB5CDd",
  "0xD4bcCf04a7CA546D3cfC46205AA7C58EB98c7495",
  "0x323663B759567BAf744C182634585F7164c3c442",
];
const CADDY = "0x09ad12552ec45f82be90b38dfe7b06332a680864";

const vaultAddresses_cronos = [
  "0x3a9645ee664DCE6529Af678aaB4fE3AD9d68323f",
  "0x6681EDBf50C0758C719F3024C282de1694807CcB",
];

const lpAddresses_cronos = [
  "0x332937463df26f46a1a715a41205765774beef80", //CADDY-WCRO Cronos
  "0x2a008ef8ec3ef6b03eff10811054e989aad1cf71", //CADDY-WCRO Cronos
];

async function calcPool2(uniVaults, lpAddress, chain, block) {
  const toa = []
  uniVaults.forEach(owner => lpAddress.forEach(lp => toa.push([lp, owner])))
  return sumTokens({}, toa, block, chain, undefined, { resolveLP: true })
}

async function calcPool2_staking_rewards(
  balances,
  uniVaults,
  lpAddress,
  chain,
  transformAddress = (addr) => addr
) {
  let chainBlocks = {};

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: chainBlocks[chain],
      calls: uniVaults.map((vault) => ({
        target: vault,
      })),
      abi: abi.totalSupply, //IStakingRewards.totalSupply()
    })
  ).output.map((val) => val.output);

  const lpPositions = [];

  lpAddress.forEach((lp, idx) => {
    lpPositions.push({
      balance: vault_balances[idx],
      token: lp,
    });
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks[chain],
    chain,
    transformAddress
  );
}

async function pool2Polygon(timestamp, block, chainBlocks) {
  const balances = {};

  const transformAddress = await transformPolygonAddress();
  await calcPool2_staking_rewards(
    balances,
    vaultAddresses_polygon,
    [lpAddresses_polygon[0]],
    "polygon",
    transformAddress
  );
  return balances;
}

async function pool2Cronos(timestamp, block, chainBlocks) {
  return calcPool2(vaultAddresses_cronos, lpAddresses_cronos, "cronos", chainBlocks.cronos);
}

async function polygonTvl(timestamp, block, chainBlocks) {
  return await tvl(timestamp, "polygon", chainBlocks, lpAddresses_polygon);
}

async function arbitrumTvl(timestamp, block, chainBlocks) {
  return await tvl(timestamp, "arbitrum", chainBlocks, lpAddresses_arbitrum);
}

async function cronosTvl(timestamp, block, chainBlocks) {
  return await tvl(timestamp, "cronos", chainBlocks, lpAddresses_cronos);
}

async function valueInGauge(chain, block, GAUGE, HOLDER, transformAddress = (a) => a) {
  // lp token
  let lp_token = (
    await sdk.api.abi.call({
      chain: chain, block: block, target: GAUGE, abi: abi.lp_token,
    })
  ).output;

  // balance of lp token
  const gauge_lp_balance = new BigNumber(
    (await sdk.api.abi.call({ chain: chain, block: block, target: lp_token, abi: abi.balanceOf, params: GAUGE, })
    ).output
  );

  // total supply of lp token
  const lp_total_supply = new BigNumber(
    (await sdk.api.abi.call({ chain: chain, block: block, target: lp_token, abi: abi.totalSupply, })
    ).output
  );

  // balance of gauge
  const holder_gauge_balance = new BigNumber(
    (await sdk.api.abi.call({ chain: chain, block: block, target: GAUGE, abi: abi.balanceOf, params: HOLDER, })
    ).output
  );

  // total supply of gauge
  const gauge_total_supply = new BigNumber(
    (await sdk.api.abi.call({ chain: chain, block: block, target: GAUGE, abi: abi.totalSupply, })
    ).output
  );

  // calc the portion of curve lp locked in the strategy
  let poolCoins = await crvPoolTvl(chain, block, lp_token, transformAddress);
  for (const coinQty in poolCoins) {
    poolCoins[coinQty] = new BigNumber(poolCoins[coinQty]).times(gauge_lp_balance).dividedBy(lp_total_supply).times(holder_gauge_balance).dividedBy(gauge_total_supply).toFixed(0);
  }

  return poolCoins;
}

async function crvPoolTvl(chain, block, COIN_TARGET, transformAddress = (a) => a, SUPPLY_TARGET = COIN_TARGET) {
  const balances = {};
  const maincoins = [];

  // find coins in curve pool
  for (var c = 0; c < 10; c++) {
    try {
      var coinX = await sdk.api.abi.call({
        chain: chain,
        block: block,
        target: COIN_TARGET,
        abi: abi.coins,
        params: c,
      });
      maincoins.push(coinX.output);
    } catch (error) {
      break;
    }
  }

  // find balances of coins
  const underlying_balances = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: block,
      calls: maincoins.map((coin) => ({
        target: coin,
        params: SUPPLY_TARGET,
      })),
      abi: abi.balanceOf,
    })
  ).output.map((val) => new BigNumber(val.output));

  // add up total pool tvl
  for (let j = 0; j < maincoins.length; j++) {
    sdk.util.sumSingleBalance(balances, transformAddress(maincoins[j]), underlying_balances[j].toFixed(0));
  }

  return balances;
}

async function curveTvl(balances, chain, block, curveVaults, transformAddress = (a) => a) {
  let crv3Address;

  if (chain == "arbitrum") {
    crv3Address = "0x7f90122BF0700F9E7e1F688fe926940E8839F353";
  } else if (chain == "polygon") {
    // this is actually 2crv not 3crv
    crv3Address = "0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171";
  }

  let strat_balances = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: block,
      calls: curveVaults.map((vault) => ({
        target: vault.strategyAddress,
      })),
      abi: abi.balanceOfVault,
    })
  ).output.map((val) => new BigNumber(val.output));

  let strat_minters = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: block,
      calls: curveVaults.map((vault) => ({
        target: vault.lpAddress,
      })),
      abi: abi.minter,
    })
  ).output.map((val) => val.output);

  const strat_supplies = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: block,
      calls: curveVaults.map((vault) => ({
        target: vault.lpAddress,
      })),
      abi: abi.totalSupply,
    })
  ).output.map((val) => new BigNumber(val.output));

  for (var i = 0; i < curveVaults.length; i++) {
    const maincoins = [];

    // if it hasn't got a minter, the balance is probably in the token contract
    if (!strat_minters[i]) {
      strat_minters[i] = curveVaults[i].lpAddress;
    }

    for (var c = 0; c < 10; c++) {
      try {
        var coinX = await sdk.api.abi.call({
          chain: chain,
          block: block,
          target: strat_minters[i],
          abi: abi.coins,
          params: c,
        });
        if (coinX.output === "0x7f90122BF0700F9E7e1F688fe926940E8839F353") {
          coinX.output = "0xbF7E49483881C76487b0989CD7d9A8239B20CA41"; // gauge
        }
        maincoins.push(coinX.output);
      } catch {
        break;
      }
    }

    if (maincoins.length == 0) {
      continue;
    }

    const underlying_balances = (
      await sdk.api.abi.multiCall({
        chain: chain,
        block: block,
        calls: maincoins.map((coin) => ({
          target: coin,
          params: strat_minters[i],
        })),
        abi: abi.balanceOf,
      })
    ).output.map((val) =>
      new BigNumber(val.output)
        // only want the portion locked in adamant
        .times(strat_balances[i])
        .dividedBy(strat_supplies[i])
    );

    for (let j = 0; j < maincoins.length; j++) {
      sdk.util.sumSingleBalance(
        balances,
        await transformAddress(maincoins[j]),
        underlying_balances[j].toFixed(0)
      );
    }

    if (i == curveVaults.length - 1) {
      if (chain == "arbitrum") {
        // I know that this guaged pool wont add up properly, so do it manually
        /*
        balances = join(balances, await 
          valueInGauge(chain, block, "0xbf7e49483881c76487b0989cd7d9a8239b20ca41", 
          "0x30dF229cefa463e991e29D42DB0bae2e122B2AC7", transformAddress));
          */
      }

      // lastly, break down any 3crv / 2crv
      // if (`${chain}:${crv3Address}` in balances) {
        //strat_balances.push(new BigNumber(balances[`${chain}:${crv3Address}`]));
      // } else {
        //return balances;
      // }
    }
  }

  const crv2 = "arbitrum:0xbF7E49483881C76487b0989CD7d9A8239B20CA41";
  sdk.util.sumSingleBalance(
    balances,
    "0x6b175474e89094c44da98b954eedeac495271d0f",
    balances[crv2] ?? "0"
  );
  delete balances[crv2];
  // something wrong with decimals
  /*
  if (chain == 'arbitrum') {
    balances['0xdAC17F958D2ee523a2206206994597C13D831ec7'] = 
      (balances['0xdAC17F958D2ee523a2206206994597C13D831ec7'] / 10**12).toFixed(0);
    balances['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'] = 
      (balances['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'] / 10**12).toFixed(0);
  }
  */

  return balances;
}

async function uniTvl(balances, chain, block, uniVaults, lpAddressesIgnored, transformAddress = (a) => a) {
  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: chain,
      block: block,
      calls: uniVaults.map((vault) => ({
        target: vault.vaultAddress,
      })),
      abi: abi.balance,
    })
  ).output.map((val) => val.output);

  const lpPositions = [];

  uniVaults.forEach((v, idx) => {
    if (
      lpAddressesIgnored.some(
        (addr) => addr.toLowerCase() === v.lpAddress.toLowerCase()
      )
    ) {
    } else {
      lpPositions.push({
        balance: vault_balances[idx],
        token: v.lpAddress,
      });
    }
  });

  await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAddress);
  return balances;
}

const tvl = async (timestamp, chain, chainBlocks, lpAddressesIgnored) => {
  const block = chainBlocks[chain];
  const transformAddress = await getChainTransform(chain)
  const fixBalances = await getFixBalances(chain)
  let balances = {};

  let resp = await utils.fetchURL(vaultsUrl[chain]);

  let curveVaults = resp.data
    .filter((vault) => vault.platform.toLowerCase() == "curve" || vault.poolName.toLowerCase() === 'mai-3crv')
    .map((vault) => ({
      vaultAddress: vault.vaultAddress,
      lpAddress: vault.lpAddress,
      strategyAddress: vault.strategyAddress,
    }));
  balances = await curveTvl(balances, chain, block, curveVaults, transformAddress);

  let uniVaults = resp.data
    .filter(
      (vault) =>
        vault.token0 !== vault.token1 &&
        vault.vaultAddress !== "" &&
        vault.platform !== "dodo" &&
        vault.poolName.toLowerCase() !== 'mai-3crv'
    )
    .map((vault) => ({
      vaultAddress: vault.vaultAddress,
      lpAddress: vault.lpAddress,
    }));
  balances = await uniTvl(balances, chain, block, uniVaults, lpAddressesIgnored, transformAddress);

  fixBalances(balances)
  return balances;
};

module.exports = {
  polygon: {
    staking: stakings(stakingContracts_polygon, ADDY, "polygon"),
    pool2: pool2Polygon,
    tvl: polygonTvl,
  },
  arbitrum: {
    staking: stakings(stakingContracts_Arbitrum, ARBY, "arbitrum"),
    tvl: arbitrumTvl,
  },
  cronos: {
    staking: stakings(stakingContracts_cronos, CADDY, "cronos"),
    pool2: pool2Cronos,
    tvl: cronosTvl,
  },
  methodology:
    "The current vaults on Adamant Finance are found on the Github. Once we have the vaults, we filter out the LP addresses of each vault and unwrap the LPs so that each token can be accounted for. Coingecko is used to price the tokens and the sum of all tokens is provided as the TVL",
};

'''
'''--- projects/adao/abi.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/adao/index.js ---
const abi = require("./abi.json");
const sdk = require("@defillama/sdk")

const ADAOTreasuryAddress = "0x9E5A8BB92C3E5A8bf5bad9c40a807dE4151311d1";
const ADAOStakingContract = "0x3BFcAE71e7d5ebC1e18313CeCEbCaD8239aA386c";

async function treasury(timestamp, block, chainBlocks) {
  const balances = {};
  const { output } = await sdk.api.eth.getBalance({ target: ADAOTreasuryAddress, chain: 'astar', block: chainBlocks.astar })
  balances[`astar`] = output/1e18;
  return balances;
}

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const { output } = await sdk.api.abi.call({ target: ADAOStakingContract, chain: 'astar', block: chainBlocks.astar, abi: abi.find(i => i.name === 'totalSupply') })
  balances[`astar`] = output/1e18;
  return balances;
}
module.exports = {
  methodology:
    "A-DAO will be based on dApp staking of Astar Network. Users will get some of the developer rewards while participating and gaining basic rewards. At present, A-DAO divides the developer rewards into: Revenue Reward, On-chain Treasury, Incubation Fund, any rewards of which can be adjusted by DAO governance.",
  astar: {
    tvl,
    treasury,
  },
};

'''
'''--- projects/adaxPro/index.js ---
const { default: axios } = require("axios")

async function fetch(){
    const tvl = (await axios.post("https://amm-api.adax.pro/", {endpoint: "getStatistics", type: "total"})).data
    return tvl[tvl.length-1].tvl_usd
}

module.exports={
    methodology: "Data is retrieved from the api at https://amm-api.adax.pro/",
    timetravel: false, // but there's historical data, this can be changed!
    fetch
}
'''
'''--- projects/adenafinance/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')

const WONE = "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a"

module.exports = {
    misrepresentedTokens: true,
    harmony: {
        tvl: calculateUsdUniTvl("0x44485473431fAF6EFA11D346d1057182d2A0A290", "harmony", WONE,
            [
                '0x97594E465e6B4df48e58327f566a3F79E9274655', // ADENA
                '0x985458e523db3d53125813ed68c274899e9dfab4', // USDC
                '0xe176ebe47d621b984a73036b9da5d834411ef734', // BUSD
                '0x224e64ec1bdce3870a6a6c777edd450454068fec', // UST
            ],  "harmony"),
    }
}

'''
'''--- projects/aelin/abi.json ---
{
  "aelinPool_purchaseToken": {"inputs":[],"name":"purchaseToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
  "aelinPool_aelinRewardsAddress": {"inputs":[],"name":"aelinRewardsAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/aelin/index.js ---
const sdk = require('@defillama/sdk');
const { request, gql } = require("graphql-request");
const { getBlock } = require('../helper/getBlock');
const { staking } = require('../helper/staking')
const { pool2 } = require('../helper/pool2')
const { unwrapUniswapLPs } = require('../helper/unwrapLPs')
const { default: BigNumber } = require('bignumber.js')
const abi = require('./abi.json')

const aelin_data = {
  'ethereum': {
    'graphUrl': 'https://api.thegraph.com/subgraphs/name/aelin-xyz/aelin',
    'AELIN_ETH_LP': '0x974d51fafc9013e42cbbb9465ea03fe097824bcc',
    'AELIN_ETH_staking': '0x944cb90082fc1416d4b551a21cfe6d7cc5447c80',
    'AELIN': '0xa9c125bf4c8bb26f299c00969532b66732b1f758'
  },
  'optimism': {
    'graphUrl': 'https://api.thegraph.com/subgraphs/name/aelin-xyz/optimism', 
    'AELIN': '0x61BAADcF22d2565B0F471b291C475db5555e0b76',
    'AELIN_staking': '0xfe757a40f3eda520845b339c698b321663986a4d',
    'AELIN_ETH_LP': '0x665d8D87ac09Bdbc1222B8B9E72Ddcb82f76B54A',
    'AELIN_ETH_staking': '0x4aec980a0daef4905520a11b99971c7b9583f4f8',
    'vAELIN': '0x780f70882fF4929D1A658a4E8EC8D4316b24748A', 
  },
}
// https://thegraph.com/hosted-service/subgraph/aelin-xyz/optimism
const graphQuery = gql`
query GET_AELIN_POOLS ($minGotchiId: Int, $block: Int) {
  poolCreateds(
    first: 1000
    skip: 0
    block: { number: $block }
  ) {
    id
    name
  }
  totalPoolsCreateds(first: 5) {
    count
  }
}`

function tvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const block = await getBlock(timestamp, chain, chainBlocks, false) - 100; // graph out of sync
    
    const { poolCreateds, totalPoolsCreateds } = await request(
      aelin_data[chain]['graphUrl'],
      graphQuery, 
      {block}
    );

    const n_pools = totalPoolsCreateds[0]['count']
    const poolsAddressesCalls = poolCreateds.map(p => ({ target: p.id }))
    console.log(`${chain} - ${block}: n_pools: ${poolsAddressesCalls.length} / ${n_pools}`) // , poolsAddressesCalls)
    
    const {output: purchaseTokens} = await sdk.api.abi.multiCall({
      calls: poolsAddressesCalls,
      abi: abi["aelinPool_purchaseToken"],
      chain,
      block,
    })
    const balancesCall = purchaseTokens.map((purchaseToken, i) => 
      ({ target: purchaseToken.output, params: [poolCreateds[i].id] }))
    const tokenBalances = await sdk.api.abi.multiCall({
      calls: balancesCall,
        abi: "erc20:balanceOf",
        chain,
      block,
    })

    // console.log(rewardsBalances.output.map(b => b.input.params + ' aelinRewardsAddress pool has: ' + BigNumber(b.output).div(1e18).toFixed(0) + ' of purchaseToken ' + b.input.target))
    const balances = {};
    sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, x => `${chain}:${x}`);
    return balances
  }
}

function stakingTVL(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    if (chain === 'ethereum') {
      return {}
    } 

    const staked = await staking(
      aelin_data[chain]['AELIN_staking'], 
      aelin_data[chain]['AELIN'], 
      chain
    ) (timestamp, ethBlock, chainBlocks)
    return staked
  }
}

function pool2TVL(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const stakingContract = aelin_data[chain]['AELIN_ETH_staking']
    const lpToken = aelin_data[chain]['AELIN_ETH_LP']
    const block = await getBlock(timestamp, chain, chainBlocks, false) - 100; // graph out of sync

    if (chain === 'ethereum') {
      const staked = await pool2(stakingContract, lpToken, chain) (timestamp, ethBlock, chainBlocks)
      const aelin_addr = `ethereum:${aelin_data[chain]['AELIN']}`
      staked['AELIN'] = BigNumber(staked[aelin_addr]).div(1e18).toFixed(0)
      staked[aelin_addr] = 0
      return staked
    } 
    else if (chain === 'optimism') {
      const balances = {}
      const transformAddress = (addr) => `${chain}:${addr}`;
      const {output: heldLPshares} = await sdk.api.abi.call({
          abi: 'erc20:balanceOf',
          target: lpToken,
          params: stakingContract,
          chain,
          block,
      })
      const lpBalances = [
        {
          balance: heldLPshares, 
          token: lpToken
        }
      ]
      // Unwrao Gelato pools
      await unwrapUniswapLPs(balances, lpBalances, block, chain, transformAddress, [], false, 'gelato')
      return balances
    }
  }
}

module.exports = {
  ethereum: {
    tvl: tvl('ethereum'),
    pool2: pool2TVL('ethereum'), 
  },
  optimism: {
    tvl: tvl('optimism'),
    staking: stakingTVL('optimism'), 
    pool2: pool2TVL('optimism'), 
  },
  methodology: 'Aelin TVL consists of purchaseTokens held by pools, as well as AELIN token (staking) and LP (pool2) staked to receive a share of the revenue',
}

'''
'''--- projects/afraswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { stakingPricedLP } = require('../helper/staking');

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0xa098751D407796d773032f5Cc219c3e6889fB893) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  bsc: {
    tvl: calculateUsdUniTvl(
      "0xa098751D407796d773032f5Cc219c3e6889fB893",
      "bsc",
      "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      [
       "0x5badD826AeFa700446Fa6d784e6ff97eD6eeDca9"         
      ],
      "wbnb"
    ),
    staking: stakingPricedLP("0x259C852834375864b65202375558AB11B2d330fd", "0x5badD826AeFa700446Fa6d784e6ff97eD6eeDca9", "bsc", "0x1Da189c1BA3d718Cc431a2ed240a3753f89CD47A", "wbnb")
  },
};
'''
'''--- projects/agarthadao/index.js ---
const {ohmTvl} = require("../helper/ohm");

const clavis = "0xa5b0f5ef809fd04c9d4320211c711cb34ef812dd";
const stakingContract = "0x7e4939ca7847ae3ff9501b27470dcd0a69f54fa6";

const treasury = "0x2c5bb99df3d43efd98ff1d7aa34d4207c83638e4"
const treasuryTokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false],// MIM
    ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false], // WAVAX
    ["0x72f95Da8d7a9b405191cAE0Fc31711d575044eFb", true], // CLAVIS-MIM JLP
    ["0x7d5b42704bb34c5bbbcd3be4f5762a663b38a2df", true] // CLAVIS-WAVAX JLP
]

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "avax", stakingContract, clavis)
}
'''
'''--- projects/agave.js ---
const { staking } = require("./helper/staking.js");
const { aaveChainTvl} = require('./helper/aave.js'); 

// Staking TVLs
const agaveTokenAddress = '0x3a97704a1b25F08aa230ae53B352e2e72ef52843'
const agaveStakingContract = '0x610525b415c1BFAeAB1a3fc3d85D87b92f048221'

const addressesProviderRegistryXDAI = "0xa5E80AEAa020Ae41b1cBEe75dE7826297F7D803E"
const protocolDataHelper = '0xa874f66342a04c24b213BF0715dFf18818D24014'

module.exports = {
  hallmarks: [
    [1647302400, "Reentrancy attack"]
],
  methodology: `Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending`,
  xdai:{
    tvl: aaveChainTvl("xdai", addressesProviderRegistryXDAI, addr=>`xdai:${addr}`, [protocolDataHelper], false),
    borrowed: aaveChainTvl("xdai", addressesProviderRegistryXDAI, addr=>`xdai:${addr}`, [protocolDataHelper], true),
    staking: staking(agaveStakingContract, agaveTokenAddress, "xdai")
  }
};
'''
'''--- projects/agile/index.js ---
const { compoundExports, } = require('../helper/compound')
const sdk = require('@defillama/sdk')
const { getUniTVL } = require("../helper/unknownTokens");

const unitroller = '0x643dc7C5105d1a3147Bd9524DFC3c5831a373F1e'

const lendingMarket = compoundExports(unitroller, "cronos", "0x2e909694B362c2FcA3C8168613bd47842245504B", "0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23", undefined, undefined, {
  blacklistedTokens: [
    '0xa4434afeae0decb9820d906bf01b13291d00651a',
  ]
})

module.exports = {
  methodology: "Liquidity on DEX and supplied and borrowed amounts found using the unitroller address(0x643dc7C5105d1a3147Bd9524DFC3c5831a373F1e)",
  misrepresentedTokens: false,
  cronos: {
    //staking: stakingPricedLP("0x37619cC85325aFea778830e184CB60a3ABc9210B", "0x9A92B5EBf1F6F6f7d93696FCD44e5Cf75035A756", "moonriver", "0xbBe2f34367972Cb37ae8dea849aE168834440685", "moonriver"),
    tvl: sdk.util.sumChainTvls([
      getUniTVL({
        factory: '0xb89E86701C4Fe4a22a16914e3b0Df53eA4BE771b',
        chain: 'cronos',
        coreAssets: [
          "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
          "0xc21223249CA28397B4B6541dfFaEcC539BfF0c59",
          "0x66e428c3f67a68878562e79A0234c1F83c208770",
          "0xe243CCab9E66E6cF1215376980811ddf1eb7F689",
        ]
      }),
      lendingMarket.tvl
    ]),
    borrowed: lendingMarket.borrowed
  }
}
'''
'''--- projects/agora/abi.json ---
{
    "getPricePerFullShare": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "getPricePerFullShare",
        "inputs": []
    },
    "want": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "contract IERC20"
            }
        ],
        "name": "want",
        "inputs": []
    },
    "balance": {
        "inputs": [],
        "name": "balance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}

'''
'''--- projects/agora/index.js ---
const sdk = require("@defillama/sdk");
const { compoundExports } = require("../helper/compound");
const { transformMetisAddress } = require("../helper/portedTokens");
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl.js')

const factory = '0x3c4063B964B1b3bF229315fCc4df61a694B0aE84'
const metis = '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000'
const agora = '0x0Ed0Ca6872073E02cd3aE005BaF04bA43BE947fA'

const whitelist = [
  agora, // AGORA
  '0xEA32A96608495e54156Ae48931A7c20f0dcc1a21', // USDC
  '0xbB06DCA3AE6887fAbF931640f67cab3e3a16F4dC', // USDT
  '0x420000000000000000000000000000000000000A', // WETH
  '0x94e56c0c59433599ba857a9a7243b2826745cf91', //kWBTC
  '0x6d11f074131e3fc61c983cce538f5d0ca3553c0f', //kUSDC
  '0xcfd482dce13ca1d27834d381af1b570e9e6c6810', //kmetis
  '0x2e9347dda00b3ec1b188963b590ca1ecbd73145a', //kweth
]

const { tvl: agoraTvl, borrowed: agoraBorrowed } = compoundExports(
  "0x3fe29D7412aCDade27e21f55a65a7ddcCE23d9B3",
  "metis",
  "0xcFd482DcE13cA1d27834D381AF1b570E9E6C6810",
  metis,
  transformMetisAddress(),
);

const { tvl: agoraPlusTvl, borrowed: agoraPlusBorrowed } = compoundExports(
  "0x92DcecEaF4c0fDA373899FEea00032E8E8Da58Da",
  "metis",
  "0xE85A1ae1A2A21135c49ADEd398D3FD5Ed032B28e",
  metis,
  transformMetisAddress(),
  symbol => symbol.indexOf('appuffNetswap') > -1
);

const { tvl: agoraStakeTvl, borrowed: agoraStakeBorrowed } = compoundExports(
  "0xb36DF0773AbD23081516F54f9dbB9a99Ec27dbB0",
  "metis",
  "0xc3034143816398d37Ec9447c9CA17c407e96Dc12",
  metis,
  transformMetisAddress(),
);

const { tvl: agoraFarmTvl, borrowed: agoraFarmBorrowed } = compoundExports(
  "0xEC1A06f320E6e295Ab6892BB4e0f9e29c712F11F",
  "metis",
  "0x13Cb104a1D94A89a260b27DfAAB07C862da622E5",
  metis,
  transformMetisAddress(),
);

const chainTvl = calculateUsdUniTvl(
  factory,
  "metis",
  metis,
  whitelist,
  "metis-token"
);

module.exports = {
  timetravel: true,
  incentivized: true,
  misrepresentedTokens: true,
  methodology: `As in Compound Finance, TVL counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are counted as "Borrowed" TVL and can be toggled towards the regular TVL.`,
  metis: {
    tvl: sdk.util.sumChainTvls([chainTvl, agoraTvl, agoraPlusTvl, agoraFarmTvl, agoraStakeTvl]),
    borrowed: sdk.util.sumChainTvls([agoraBorrowed, agoraPlusBorrowed, agoraFarmBorrowed, agoraStakeBorrowed]),
  },
};

'''
'''--- projects/agsfinance/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')

const FACTORIES = "0x6A6a541FFb214ca228A58c27bD61b5A099Dc82CC"

const NATIVE_TOKEN_WASTAR = "0xAeaaf0e2c81Af264101B9129C00F4440cCF0F720"

module.exports = {
    misrepresentedTokens: true,
    methodology: "AGS Finance Tvl Calculation",
    astar: {
        tvl: calculateUsdUniTvl(
            FACTORIES, 
            "astar", 
            NATIVE_TOKEN_WASTAR,
            [
                NATIVE_TOKEN_WASTAR,
                "0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c",
                "0xad543f18cFf85c77E140E3E5E3c3392f6Ba9d5CA",
                "0x7f27352D5F83Db87a5A3E00f4B07Cc2138D8ee52",
                "0x75364D4F779d0Bd0facD9a218c67f87dD9Aff3b4",
                "0xdd90E5E87A2081Dcf0391920868eBc2FFB81a1aF",
                "0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98",
                "0x3795C36e7D12A8c252A20C5a7B455f7c57b60283",
                "0x81bC9336f22D832555ceA0Ad84A3FD7F7426cf47"
            ],
            "astar"
        ),
    }
};

'''
'''--- projects/aladdin-dao/abis/Vault.json ---
{
    "balance":{"inputs":[],"name":"balance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}

'''
'''--- projects/aladdin-dao/index.js ---
const sdk = require("@defillama/sdk");
const {unwrapUniswapLPs, unwrapCrv} = require('../helper/unwrapLPs')
const vaultABI = require('./abis/Vault.json')

const tokenMaster = '0xfF4446E9dF1c8281CE1d42610c3bC0342f93E4d7'
const aldsETH = '0xB17d98c36d2238Ffcb27bF797cA9967B3Cc9Aa07'
const aldcrvRenWBTC = '0x4EE014060F4816ad294857d29C22fe62B0e9580B'
const ald3CRV = '0x5C8dC3a18761e4F22F7B8D41228970477168d9e2'
const aldSLPETHWBTC = '0x1C7ed66abE1BA029c8EFceecfBfc4056B8C4bbfc'
const unilpALDETH = '0xED6c2F053AF48Cba6cBC0958124671376f01A903'
const unilpALDUSDC = '0xaAa2bB0212Ec7190dC7142cD730173b0A788eC31'
const crvRenWBTC = '0x49849C98ae39Fff122806C06791Fa73784FB3675'
const SETH = '0xA3D87FffcE63B53E0d54fAa1cc983B7eB0b74A9c'
const threeCRV = '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490'
const slpETHWBTC = '0xceff51756c56ceffca006cd410b03ffc46dd3a58'

const pools = [aldcrvRenWBTC, aldsETH, ald3CRV, aldSLPETHWBTC, unilpALDETH, unilpALDUSDC]
const aldVaults = [aldcrvRenWBTC, aldsETH, ald3CRV, aldSLPETHWBTC]
const aldVaultUnderlyingTokens = [crvRenWBTC, SETH, threeCRV, slpETHWBTC];

async function tvl(timestamp, block) {
  let balances = {}
  const lockedTokens = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    calls: pools.map(p => ({
      target: p,
      params: tokenMaster
    })),
    block
  });

  // whether it's in vaults or in staking, it belongs to aladdin's tvl
  const aldUnderlyingTokenBalances = (await sdk.api.abi.multiCall({
    abi: vaultABI['balance'],
    calls: aldVaults.map(p => ({
      target: p,
      params: [],
    })),
    block
  })).output.map(x => x.output);

  const lpPositions = [];
  const crvBalances = [];

  lockedTokens.output.forEach((call, index) => {
    const token = pools[index];
    const balance= call.output;
    if (index === 4 || index === 5) {
      lpPositions.push({balance, token})
    } else if (index === 0 || index == 1 || index == 2 ) {
      crvBalances.push(aldUnderlyingTokenBalances[index])
    } else if (index === 3) {
      lpPositions.push({balance: aldUnderlyingTokenBalances[index], token: aldVaultUnderlyingTokens[index]})
    }
  })
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
  );

  await unwrapCrv(balances, aldVaultUnderlyingTokens[0], crvBalances[0]);
  await unwrapCrv(balances, aldVaultUnderlyingTokens[1], crvBalances[1]);
  await unwrapCrv(balances, aldVaultUnderlyingTokens[2], crvBalances[2]);

  return balances
}

module.exports = {
  doublecounted: true,
  ethereum:{
    tvl,
  },
}

'''
'''--- projects/alchemist/index.js ---
const utils = require('../helper/utils')

const pool2s = [
    "0xf0D415189949d913264A454F57f4279ad66cB24d", // Aludel v1
    "0x93c31fc68E613f9A89114f10B38F9fd2EA5de6BC" // Aludel v1.5
]

// Retrieve Staked Token Values from API
const endpoint = "https://crucible.alchemist.wtf/api/get-program-staked-usd?network=1"

function get(includePool2){
return async function() {
    const rewardPrograms = await utils.fetchURL(endpoint)
    return Object.entries(rewardPrograms.data).reduce((t, c)=>{
        let isPool2 = pool2s.some(p=>p.toLowerCase()===c[0].toLowerCase())
        if(includePool2){
            isPool2 = !isPool2 
        }
        if(isPool2){
            return t
        }
        return t+c[1]
    }, 0)
}
}

module.exports={
    methodology: 'Tvl equals the sum of the tokens locked on all rewards programs except their own (aludels). Aludels are counted as pool2',
    fetch: get(false),
    pool2:{
        fetch: get(true)
    }
}

'''
'''--- projects/alchemix/contracts.json ---
{
    "fantom": {
      "tokenHolders": {
        "alUSDAlchemist": "0x76b2E3c5a183970AAAD2A48cF6Ae79E3e16D3A0E",
        "alUSDTransmuterBuffer": "0x5a07d36D1f543960EE7806d35827E995539Fe5CF"
      },
      "underlyingTokens": {
        "DAI": "0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E",
        "USDC": "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75",
        "fUSDT": "0x049d68029688eAbF473097a2fC38ef61633A3C7A"
      },
      "yvTokens": {
        "yvDAI": "0x637ec617c86d24e421328e6caea1d92114892439",
        "yvUSDC": "0xef0210eb96c7eb36af8ed1c20306462764935607", 
        "yvUSDT": "0x148c05caf1bb09b5670f00d511718f733c54bc4c"
      }
    },
    "ethereum": {
      "tokenHolders": {
        "alUSDAlchemist": "0x5C6374a2ac4EBC38DeA0Fc1F8716e5Ea1AdD94dd",
        "alETHAlchemist": "0x062Bf725dC4cDF947aa79Ca2aaCCD4F385b13b5c",
        "alUSDAMO": "0x9735f7d3ea56b454b24ffd74c58e9bd85cfad31b",
        "alETHAMO": "0xe761bf731a06fe8259fee05897b2687d56933110",
        "USDTransmuterB": "0xeE69BD81Bd056339368c97c4B2837B4Dc4b796E7",
        "USDYearnVaultAdapter": "0xb039eA6153c827e59b620bDCd974F7bbFe68214A",
        "USDYearnVaultAdapterTransmuterB": "0x6Fe02BE0EC79dCF582cBDB936D7037d2eB17F661",
        "ETHTransmuter": "0x9FD9946E526357B35D95Bcb4b388614be4cFd4AC",
        "ETHAlchemist": "0xf8317BD5F48B6fE608a52B48C856D3367540B73B",
        "ETHYearnVaultAdapter": "0x546E6711032Ec744A7708D4b7b283A210a85B3BC",
        "ETHYearnVaultAdapterB": "0x6d75657771256C7a8CB4d475fDf5047B70160132"
      },
      "underlyingTokens": {
        "DAI": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        "USDC": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        "wstETH": "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
        "rETH": "0xae78736Cd615f374D3085123A210448E74Fc6393",
        "WETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
      },
      "yvTokens": {
        "yvDAI": "0xda816459f1ab5631232fe5e97a05bbbb94970c95",
        "yvUSDC": "0xa354f35829ae975e850e23e9615b11da1b3dc4de", 
        "yvUSDT": "0x7da96a3891add058ada2e826306d812c638d87a7",
        "yvWETH": "0xa258c4606ca8206d8aa700ce2143d7db854d168c"
      },
      "staking": {
          "token": "0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF",
          "holder": "0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa"
      }
    }
  }
'''
'''--- projects/alchemix/index.js ---
const { getChainTransform } = require('../helper/portedTokens.js');
const { unwrapYearn, sumTokensSharedOwners } = require('../helper/unwrapLPs');
const { staking } = require("../helper/staking.js");
const contracts = require('./contracts');

function tvl(chain) {
  return async (timestamp, block, chainBlocks) => {
    const balances = {};
    const transform = await getChainTransform(chain);

    await sumTokensSharedOwners(
      balances, 
      Object.values(contracts[chain].underlyingTokens)
        .concat(Object.values(contracts[chain].yvTokens)), 
        Object.values(contracts[chain].tokenHolders), 
        chainBlocks[chain],
        chain, 
        transform
      );

    for (const yvToken of Object.values(contracts[chain].yvTokens)) {
      await unwrapYearn(balances, yvToken, chainBlocks[chain], chain, transform);
    };

    return balances;
  };
};

module.exports = {
  ethereum: {
    tvl: tvl('ethereum'),
    staking: staking(contracts.ethereum.staking.holder, contracts.ethereum.staking.token)
  },
  fantom: {
    tvl: tvl('fantom')
  }
};
'''
'''--- projects/alcor/index.js ---
const { get_account_tvl } = require("../helper/eos");

// Alcor
// https://eos.alcor.exchange/
async function eos() {
  const accounts = ["alcorammswap", "eostokensdex"];
  const tokens = [
      ["eosio.token", "EOS", "eos"],
      ["tethertether", "USDT", "tether"],
  ];
  return await get_account_tvl(accounts, tokens);
}

// Alcor
// https://wax.alcor.exchange
async function wax() {
  const accounts = ["alcorammswap", "alcordexmain"];
  const tokens = [
      ["eosio.token", "WAX", "wax"],
      ["alien.worlds", "TLM", "alien-worlds"],
      ["token.rfox", "TLM", "redfox-labs"],
  ];
  return await get_account_tvl(accounts, tokens, "wax");
}

module.exports = {
  methodology: `Alcor TVL is achieved by querying token balances from Swap & Limit smart contract(s).`,
  eos: {
    tvl: eos
  },
  wax: {
    tvl: wax
  },
}
'''
'''--- projects/aldrin/index.js ---
const retry = require('../helper/retry')
const {toUSDTBalances} = require('../helper/balances')
const { GraphQLClient, gql } = require('graphql-request')

const API_URL = 'https://api.aldrin.com/graphql'

async function tvl(timestamp) {
  var graphQLClient = new GraphQLClient(API_URL)

  const timestampFrom = Math.floor(timestamp - 60 * 60)
  const timestampTo = Math.floor(timestamp)

  var query = gql`
    {
      getTotalVolumeLockedHistory(
        timezone: "UTC", 
        timestampFrom: ${timestampFrom}, 
        timestampTo: ${timestampTo}
      ) {
        volumes {
          vol
          date
        }
      }
    }
    `;

  const results = await retry(async bail => await graphQLClient.request(query))
  return toUSDTBalances(results.getTotalVolumeLockedHistory.volumes[0].vol)
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  tvl
}

'''
'''--- projects/alexlab/index.js ---
const axios = require("axios");
const retry = require("../helper/retry");

// https://explorer.stacks.co/txid/SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.alex-vault?chain=mainnet
// https://stacks-node-api.blockstack.org/extended/v1/address/SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.alex-vault/balances
const ALEX_API = "https://api.alexlab.co/v1";

async function fetch() {
  const url = `${ALEX_API}/pool_token_stats`;
  const alexStatsResponse = (await retry(async () => await axios.get(url)))
    .data;

  const valueLockedMap = {};
  let totalValueLocked = 0;
  for (const pool of alexStatsResponse) {
    let poolValue = 0;
    const poolToken = pool.pool_token;

    if (poolToken == "age000-governance-token") {
      poolValue = pool.price * pool.reserved_balance;
    } else {
      poolValue = pool.price * pool.total_supply;
    }
    totalValueLocked += poolValue;
    valueLockedMap[poolToken] = poolValue;
  }

  return totalValueLocked;
}

async function staking() {
  const url = `${ALEX_API}/stats/tvl`;
  const alexResponse = (await retry(async () => await axios.get(url))).data;
  return alexResponse.reserve_pool_value;
}

// node test.js projects/alexlab/index.js
module.exports = {
  timetravel: false,
  stacks: {
    fetch,
  },
  staking: { fetch: staking },
  fetch,
  methodology: "Alex Lab TVL is sum of tokens locked in ALEX platform.",
};

'''
'''--- projects/algebra/index.js ---
const sdk = require('@defillama/sdk')
const {transformPolygonAddress} = require('../helper/portedTokens')

const { getBlock } = require('../helper/getBlock');
const { staking } = require('../helper/staking');

const FACTORY =  '0x8C1EB1e5325049B412B7E71337116BEF88a29b3A';

const startBlocks = {
    polygon: 22518977
}

function chainTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const  START_BLOCK = startBlocks[chain]
    const block = await getBlock(timestamp, chain, chainBlocks)
    const logs = (
      await sdk.api.util.getLogs({
        keys: [],
        toBlock: block,
        target: FACTORY,
        fromBlock: START_BLOCK,
        chain,
        topic: 'PoolCreated(address,address,address)',
      })
    ).output

    const pairAddresses = []
    const token0Addresses = []
    const token1Addresses = []

    for (let log of logs) {
      token0Addresses.push(`0x${log.topics[1].substr(-40)}`.toLowerCase())
      token1Addresses.push(`0x${log.topics[2].substr(-40)}`.toLowerCase())
      pairAddresses.push(`0x${log.data.substr(-40)}`.toLowerCase())
    }

    const pairs = {}

    token0Addresses.forEach((token0Address, i) => {
      const pairAddress = pairAddresses[i]
      pairs[pairAddress] = {
        token0Address: token0Address,
      }
    })

    token1Addresses.forEach((token1Address, i) => {
      const pairAddress = pairAddresses[i]
      pairs[pairAddress] = {
        ...(pairs[pairAddress] || {}),
        token1Address: token1Address,
      }
    })

    let balanceCalls = []

    for (let pair of Object.keys(pairs)) {
      balanceCalls.push({
        target: pairs[pair].token0Address,
        params: pair,
      })
      balanceCalls.push({
        target: pairs[pair].token1Address,
        params: pair,
      })
    }

    const tokenBalances = (
      await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: balanceCalls,
        block,
        chain,
      })
    )
    let transform = id=>id
    if(chain === "polygon"){
      transform = await transformPolygonAddress()
    }

    let balances = {};

    sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transform)

    return balances;
  }
}

module.exports = {
  polygon: {
    tvl: chainTvl('polygon'),
    staking: staking('0x32CFF674763b06B983C0D55Ef2e41B84D16855bb', '0x0169ec1f8f639b32eec6d923e24c2a2ff45b9dd6', 'polygon')
  }
}
'''
'''--- projects/algodex.js ---
const { fetchURL } = require('./helper/utils')
const { toUSDTBalances } = require('./helper/balances')

const usdPriceUrl = "https://mainnet.analytics.tinyman.org/api/v1/current-asset-prices/"
const assetTVLURL = "https://eu-central-1.algodex.com/algodex-backend/tvl.php"

async function fetch() {
  const tvlData = await fetchURL(assetTVLURL)
  const usdPriceData = await fetchURL(usdPriceUrl)

  const total_liquidity_in_usd = tvlData.data.reduce((sum, asset) => {
    var assetPrice = 0
    if (usdPriceData.data.hasOwnProperty(asset.assetid)) {
      assetPrice = usdPriceData.data[asset.assetid].price
    } else {
      // price for some asset is not found on tinyman then
      // set its price to zero
      assetPrice = 0
    }

    sum += assetPrice * asset.asaAmountTotal
    return sum
  }, 0)
  return total_liquidity_in_usd 
}
// tvl in USD
module.exports = {
  fetch
}

'''
'''--- projects/algofi/index.js ---
const sdk = require('@defillama/sdk')
const { toUSDTBalances } = require('../helper/balances')
const { get } = require('../helper/http')
const retry = require("async-retry");
const axios = require("axios");
const { lookupApplications, } = require("../helper/algorand");

const marketStrings = {
    underlying_cash : "uc",
    underlying_borrowed : "ub",
    underlying_reserves : "ur",
    active_collateral : "acc",
    oracle_price_scale_factor: "ops",
    lp_circulation: "lc"
}

const orderedAssets = ["ALGO", "STBL", "USDC", "goBTC", "goETH", "vALGO"]
const fixedValueStakingContracts = ["TINYMAN11_STBL_USDC_LP_STAKING", "ALGOFI-STBL-USDC-LP"]
const singleSideStakingContracts = ["DEFLY", "STBL", "OPUL"]
const variableValueStakingContracts = ["ALGOFI-STBL-ALGO-LP", "AF-XET-STBL-75BP-STAKING", "AF-GOBTC-STBL-25BP-STAKING", "AF-GOETH-STBL-25BP-STAKING", "AF-OPUL-STBL-75BP-STAKING",
                                        "AF-DEFLY-STBL-75BP-STAKING", "AF-NANO-USDC-STBL-5BP-STAKING", "AF-NANO-USDT-STBL-5BP-STAKING", "AF-NANO-USDT-USDC-5BP-STAKING",
                                        "AF-USDC-STBL-NANO-SUPER-STAKING", "AF-ZONE-STBL-75BP-STAKING", "AF-TINY-STBL-75BP-STAKING", "AF-GOMINT-STBL-25BP-STAKING"]
const stakingContracts = fixedValueStakingContracts.concat(variableValueStakingContracts).concat(singleSideStakingContracts)

const assetDictionary = {
    "ALGO": {
        "decimals": 6,
        "marketAppId": 465814065,
        "oracleAppId": 531724540,
        "oracleFieldName": "latest_twap_price"
    },
    "USDC": {
        "decimals": 6,
        "marketAppId": 465814103,
        "oracleAppId": 451327550,
        "oracleFieldName": "price"
    },
    "goBTC": {
        "decimals": 8,
        "marketAppId": 465814149,
        "oracleAppId": 531725044,
        "oracleFieldName": "latest_twap_price"
    },
    "goETH": {
        "decimals": 8,
        "marketAppId": 465814222,
        "oracleAppId": 531725449,
        "oracleFieldName": "latest_twap_price"
    },
    "STBL": {
        "decimals": 6,
        "marketAppId": 465814278,
        "oracleAppId": 451327550,
        "oracleFieldName": "price"
    },
    "vALGO": {
        "decimals": 6,
        "marketAppId": 465814318,
        "oracleAppId": 531724540,
        "oracleFieldName": "latest_twap_price",
    },
    "STAKING_CONTRACTS": {
        "STBL": {
            "decimals": 6,
            "assetId": 465865291,
            "marketAppId": 482608867,
        },
        "AF-USDC-STBL-NANO-SUPER-STAKING" : {
            "decimals": 6,
            "marketAppId" : 705657303,
            "poolAppId": 658337046,
        },
        "TINYMAN11_STBL_USDC_LP_STAKING" : {
            "decimals": 6,
            "marketAppId" : 553866305,
        },
        "ALGOFI-STBL-USDC-LP": {
            "marketAppId": 611867642,
            "decimals": 6,
        },
        "ALGOFI-STBL-ALGO-LP": {
            "poolAppId": 607645439,
            "marketAppId": 611801333,
            "decimals": 6,
        },
        "AF-XET-STBL-75BP-STAKING" : {
            "marketAppId" : 635812850,
            "poolAppId": 635256627,
            "decimals": 6,
        },
        "AF-GOBTC-STBL-25BP-STAKING" : {
            "marketAppId" : 635860537,
            "poolAppId": 635846127,
            "decimals": 6
        },
        "AF-GOETH-STBL-25BP-STAKING" : {
            "marketAppId" : 635864509,
            "poolAppId": 635853824,
            "decimals": 6
        },
        "AF-OPUL-STBL-75BP-STAKING" : {
            "marketAppId" : 637793356,
            "poolAppId": 637801923,
            "decimals": 6
        },
        "AF-DEFLY-STBL-75BP-STAKING" : {
            "marketAppId" : 639747119,
            "poolAppId": 624956175,
            "decimals": 6
        },
        "AF-NANO-USDC-STBL-5BP-STAKING" : {
            "marketAppId" : 661192413,
            "poolAppId": 658337046,
            "decimals": 6
        },
        "AF-NANO-USDT-STBL-5BP-STAKING" : {
            "marketAppId" : 661199805,
            "poolAppId": 659677335,
            "decimals": 6
        },
        "AF-NANO-USDT-USDC-5BP-STAKING" : {
            "marketAppId" : 661207804,
            "poolAppId": 659678644,
            "decimals": 6
        },
        "AF-TINY-STBL-75BP-STAKING" : {
            "marketAppId" : 647757513,
            "poolAppId": 624950291,
            "decimals": 6
        },
        "AF-ZONE-STBL-75BP-STAKING" : {
            "marketAppId" : 647785158,
            "poolAppId": 647799801,
            "decimals": 6
        },
        "AF-GOMINT-STBL-25BP-STAKING" : {
            "marketAppId" : 764406975,
            "poolAppId": 764420932,
            "decimals": 6
        },
        "DEFLY" : {
            "marketAppId" : 641499935,
            "assetId": 470842789,
            "decimals": 6
        },
        "OPUL" : {
            "marketAppId" : 674526408,
            "assetId": 287867876,
            "decimals": 10
        }
    }
}

async function getGlobalMarketState(marketId) {
  let response = await lookupApplications(marketId);
  let results = {}
  response.application.params["global-state"].forEach(x => {
    let decodedKey =  Buffer.from(x.key, 'base64').toString('binary')
    results[decodedKey] = x.value.uint
  })

  return results
}

async function getPrices(assetDictionary, orderedAssets) {
  let prices = {}
  for (const assetName of orderedAssets) {
    let response = await lookupApplications(assetDictionary[assetName]["oracleAppId"])
    for (const y of response.application.params["global-state"]) {
      let decodedKey = Buffer.from(y.key, 'base64').toString('binary')
      if (decodedKey === assetDictionary[assetName]["oracleFieldName"]) {
        prices[assetName] = y.value.uint / 1000000
      }
    }
  }

  return prices
}

function getMarketSupply(assetName, marketGlobalState, prices, assetDictionary) {
    let underlyingCash = ((assetName === "STBL") || (assetName === "vALGO"))  ? marketGlobalState[marketStrings.active_collateral] : marketGlobalState[marketStrings.underlying_cash]
    let supplyUnderlying = underlyingCash - marketGlobalState[marketStrings.underlying_reserves]
    supplyUnderlying /= Math.pow(10, assetDictionary[assetName]['decimals'])

    return supplyUnderlying * prices[assetName]
}

function getMarketBorrow(assetName, marketGlobalState, prices) {
    let borrowUnderlying = marketGlobalState[marketStrings.underlying_borrowed]
    borrowUnderlying /= Math.pow(10, assetDictionary[assetName]['decimals'])

    return borrowUnderlying * prices[assetName]
}

async function borrowed() {
    let prices = await getPrices(assetDictionary, orderedAssets)

    let borrow = 0

    for (const assetName of orderedAssets) {
        let marketGlobalState = await getGlobalMarketState(assetDictionary[assetName]["marketAppId"])
        borrow += getMarketBorrow(assetName, marketGlobalState, prices, assetDictionary)
    }

    return toUSDTBalances(borrow)
}

async function supply() {
    let prices = await getPrices(assetDictionary, orderedAssets)

    let supply = 0
    for (const assetName of orderedAssets) {
        let marketGlobalState = await getGlobalMarketState(assetDictionary[assetName]["marketAppId"])
        let assetTvl = getMarketSupply(assetName, marketGlobalState, prices, assetDictionary)
        supply += assetTvl
    }

    return toUSDTBalances(supply)
}

async function staking() {
    let lpCirculations = {}

    let prices = {
             'TINYMAN11_STBL_USDC_LP_STAKING': 2,
             'ALGOFI-STBL-USDC-LP': 2,
    }

    for (const contractName of variableValueStakingContracts) {
        let contractState = await getGlobalMarketState(
            assetDictionary['STAKING_CONTRACTS'][contractName]["poolAppId"]
        )
        lpCirculations[contractName] = contractState[marketStrings.lp_circulation] / 1000000
    }

    let poolSnapshots = await get("https://thf1cmidt1.execute-api.us-east-2.amazonaws.com/Prod/amm_pool_snapshots/?network=MAINNET")
    let assetSnapshots = await get("https://thf1cmidt1.execute-api.us-east-2.amazonaws.com/Prod/amm_asset_snapshots/?network=MAINNET")

    for (const poolSnapshot of poolSnapshots.pool_snapshots) {
        for (const contractName of variableValueStakingContracts) {
            if (poolSnapshot.id == assetDictionary['STAKING_CONTRACTS'][contractName]["poolAppId"]) {
                prices[contractName] = poolSnapshot.balance_info.total_usd / lpCirculations[contractName]
            }
        }
    }

    for (const assetSnapshot of assetSnapshots.asset_snapshots) {
        for (const contractName of singleSideStakingContracts) {
            if (assetSnapshot.id == assetDictionary['STAKING_CONTRACTS'][contractName]["assetId"]) {
                prices[contractName] = assetSnapshot.price
            }
        }
    }

    let staked = 0
    for (const contractName of stakingContracts) {
        let marketGlobalState = await getGlobalMarketState(assetDictionary['STAKING_CONTRACTS'][contractName]["marketAppId"])
        staked += getMarketSupply(contractName, marketGlobalState, prices, assetDictionary['STAKING_CONTRACTS'])
    }

    return toUSDTBalances(staked)
}

async function dex() {
    const response = (
        await retry(
          async (bail) =>
            await axios.get("https://thf1cmidt1.execute-api.us-east-2.amazonaws.com/Prod/amm_protocol_snapshot/?network=MAINNET")
        )
      ).data.protocol_snapshot.tvl.total_usd;
    return toUSDTBalances(response)
}
module.exports = {
    algorand: {
        tvl: sdk.util.sumChainTvls([supply, dex]),
        borrowed,
        staking
    }
}
// node test.js projects/algofi/index.js
'''
'''--- projects/algogard/index.js ---

const { lookupApplications, lookupAccountByID, searchAccounts, } = require("../helper/algorand");
const { toUSDTBalances } = require("../helper/balances");

const reserveAddress = "J2E2XXS4FTW3POVNZIHRIHTFRGOWEWX65NFYIVYIA27HUK63NWT65OLB2Y"
const treasuryAddress = "MTMJ5ADRK3CFG3HGUI7FS4Y55WGCUO5CRUMVNBZ7FW5IIG6T3IU2VJHUMM"

const oracleAppId = 673925841
const gardId = 684649988
const gardPriceValidatorId = 684650147

function getStateUint(state, key) {
  const val = state.find((entry) => {
    if (entry.key === key) {
      return entry;
    }
  })
  return val.value.uint
}

async function getAppState(appId) {
  const res = await lookupApplications(appId);
  return res.application.params["global-state"];
}

/* Get Algo/USD price from oracle */
async function getAlgoPrice() {
  const state = await getAppState(oracleAppId);
  const price = getStateUint(state, 'cHJpY2U=')
  const oracleDecimals = getStateUint(state, 'ZGVjaW1hbHM=')
  return price / (10 ** oracleDecimals);
}

/* Get value locked in user-controlled smart contracts */
async function getAlgoGovernanceAccountBalsUsd(price) {

  let nexttoken
  let response = null
  let totalContractAlgo = 0
  do {
    // Find accounts that are opted into the GARD price validator application
    // These accounts correspond to CDP opened on the GARD protocol
    response = await searchAccounts({
      appId: gardPriceValidatorId,
      limit: 1000,
      nexttoken,
    });
    for (const account of response['accounts']) {
      totalContractAlgo += (account['amount'] / Math.pow(10, 6))
    }
    nexttoken = response['next-token']
  } while (nexttoken != null);

  return totalContractAlgo * price
}

/* Get value locked in treasury */
async function getTreasuryBalUsd(price) {

  const info = await lookupAccountByID(treasuryAddress)
  const treasuryBal = info.account.amount;
  return treasuryBal * price / 1e6 // 1e6 comes from converting from microAlgos to Algos 
}

/* Get total deposits */
async function tvl() {
  const price = await getAlgoPrice();

  const [treasuryBal, algoGovernanceDepositUsd] =
    await Promise.all([
      getTreasuryBalUsd(price),
      getAlgoGovernanceAccountBalsUsd(price),
    ]);

  return toUSDTBalances(treasuryBal + algoGovernanceDepositUsd);
}

/* Get total borrows */
async function borrowed() {

  const info = await lookupAccountByID(reserveAddress)
  const gardBalance = info.account.assets?.find((asset) => asset["asset-id"] === gardId).amount;
  return (92e17 - gardBalance) / 1e6
  // Contract is initialized with 9.2 quintillion microGARD. Each GARD is pegged to $1
}

async function borrowedBalances() {
  return toUSDTBalances(await borrowed())
}

async function treasuryBalances() {
  const price = await getAlgoPrice();
  return toUSDTBalances(await getTreasuryBalUsd(price))
}

module.exports = {
  algorand: {
    tvl,
    borrowed: borrowedBalances,
    treasury: treasuryBalances,
  }
}

'''
'''--- projects/aliensfarm/index.js ---
const { getTokenBalances } = require('../helper/tezos')
const { getFixBalances } = require('../helper/portedTokens')

module.exports = {
  methodology:
    "TVL counts the total cost of tokens staked on both farmings and stakings.",
  timetravel: false,
  tezos: {
    tvl: async () => {
      const fixBalances = await getFixBalances('tezos')
      const dexAddtess = 'KT1DqhpvkfyBySVR4KV8Yu3K3jGSmLy7PTbr'
      const balances = await getTokenBalances(dexAddtess, true)
      fixBalances(balances)
      return balances
    }
  }
};

'''
'''--- projects/alita-finance/index.js ---
const sdk = require("@defillama/sdk");
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')

const ALI_TOKEN = '0x557233E794d1a5FbCc6D26dca49147379ea5073c'
const ALI_FACTORY = "0xC7a506ab3ac668EAb6bF9eCf971433D6CFeF05D9";
const ALI_MASTER_CHEF = '0x4f7b2Be2bc3C61009e9aE520CCfc830612A10694'

async function bscTvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks['bsc'], 'bsc', ALI_FACTORY, 0, true);
}

async function poolsTvl(timestamp, ethBlock, chainBlocks) {
    const balances = {};
    const stakedAli = sdk.api.erc20.balanceOf({
      target: ALI_TOKEN,
      owner: ALI_MASTER_CHEF,
      chain: 'bsc',
      block: chainBlocks.bsc
    })
    sdk.util.sumSingleBalance(balances, 'bsc:' + ALI_TOKEN, (await stakedAli).output)
    return balances
}

module.exports = {
  misrepresentedTokens: true,
  bsc:{
    tvl: bscTvl,
    staking: poolsTvl
  },
  methodology: "The TVL is the total of all liquidity pools. The staking TVL is accounted as the ALI on MasterChef(0x4f7b2Be2bc3C61009e9aE520CCfc830612A10694)",
}
'''
'''--- projects/aliumswap/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require("../helper/calculateUniTvl.js");

const ALMToken = "0x7C38870e93A1f959cB6c533eB10bBc3e438AaC11";
const stakingPool = "0x4f388167F8B52F89C87A4E46706b9C1408F2c137"; // Strong Holder Pool

const bscFactory = "0xbEAC7e750728e865A3cb39D5ED6E3A3044ae4B98";

async function bscTvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(
    (addr) => `bsc:${addr}`,
    chainBlocks.bsc,
    "bsc",
    bscFactory,
    0,
    true
  );
}

async function bscStaking(timestamp, block, chainBlocks) {
  let balances = {};

  let { output: balance } = await sdk.api.erc20.balanceOf({
    target: ALMToken,
    owner: stakingPool,
    block: chainBlocks.bsc,
    chain: "bsc",
  });

  sdk.util.sumSingleBalance(balances, `bsc:${ALMToken}`, balance);

  return balances;
}

module.exports = {
  bsc: {
    tvl: bscTvl,
    staking: bscStaking,
  },
  
};

'''
'''--- projects/alkemi/index.js ---
/*==================================================
  Modules
  ==================================================*/

const sdk = require('@defillama/sdk');
//const abi = require('./abi.json');
const BigNumber = require('bignumber.js');
//const ERROR = BigNumber("3963877391197344453575983046348115674221700746820753546331534351508065746944")

/*==================================================
  TVL
  ==================================================*/

const etherAddress = '0x0000000000000000000000000000000000000000';
const alkPools = [
  '0x397c315d64D74d82A731d656f9C4D586D200F90A', // Alkemi Earn
  '0x4822D9172e5b76b9Db37B75f5552F9988F98a888', // Alkemi Earn Open
];
const alkTokens = [
  '0x8125afd067094cD573255f82795339b9fe2A40ab', // WETH, Alkemi Earn Open
  '0x1f52453B32BFab737247114D56d756A6c37dd9Ef', // WETH, Alkemi Earn
  '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', // WBTC
  '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
  '0x6B175474E89094C44Da98b954EedeAC495271d0F', // DAI
];

async function tvl(timestamp, block) {
  const alkCombos = function () {
    let arr = Array(alkPools.length * alkTokens.length);
    for (var i = 0; i < alkPools.length; i++) {
      for (var j = 0; j < alkTokens.length; j++) {
        arr[i * alkTokens.length + j] = { target: alkTokens[j], params: alkPools[i] };
      }
    }
    return arr;
  };

  const alkQueries = alkCombos();
  //console.log(alkQueries);   // for debugging 
  //console.table(alkQueries); // for debugging

  const wethEarnOpen = '0x8125afd067094cD573255f82795339b9fe2A40ab';
  const wethEarn = '0x1f52453B32BFab737247114D56d756A6c37dd9Ef';
  let balances = {
    [etherAddress]: '0',
    [wethEarnOpen]: '0',
    [wethEarn]: '0',
  };
  const alkBalances = await sdk.api.abi.multiCall(
    {
      calls: alkQueries,
      abi: 'erc20:balanceOf',
      block
    });
  await sdk.util.sumMultiBalanceOf(balances, alkBalances);
  //console.table(balances); // for debugging

  // handle Alkemi custom WETH
  const wethBalances = new BigNumber(balances[wethEarnOpen]).plus(balances[wethEarn]);
  balances[etherAddress] = wethBalances.toFixed(0);
  balances[wethEarnOpen] = '0';
  balances[wethEarn] = '0';

  //console.table(balances); // for debugging
  return balances;
};

/*==================================================
  Exports
  ==================================================*/

module.exports = {
  methodology: "TVL consists of Assets (ETH, WBTC, Stablecoins) deposited in Alkemi Earn, Assets (ETH, WBTC, Stablecoins) deposited in Alkemi Earn Open, and does NOT currently consider assets borrowed",
  start: 1609380306,        // unix timestamp (utc 0) specifying when the project began, or where live data begins
  ethereum: { tvl }                       // tvl adapter
};

'''
'''--- projects/allbridge/index.js ---

const sdk = require('@defillama/sdk')
const solana = require('../helper/solana')
const terra = require('../helper/terra')
const { staking } = require('../helper/staking');
const near = require('../helper/near');
const NATIVE_ADDRESS = "NATIVE";

const data = {
    celo: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0x6e512BFC33be36F2666754E996ff103AD1680Cc9",
            decimals: 18
        },
        tokens: [
            {name: "celo-dollar", address: "0x765DE816845861e75A25fCA122bb6898B8B1282a", decimals: 18},
            {name: "usd-coin", address: "0x2A3684e9Dc20B857375EA04235F2F7edBe818FA7", decimals: 6},
            {name: "poofcash", address: "0x00400FcbF0816bebB94654259de7273f4A05c762", decimals: 18},
            {name: "celo-euro", address: "0xD8763CBa276a3738E6DE85b4b3bF5FDed6D6cA73", decimals: 18},
            {name: "celo", address: NATIVE_ADDRESS, decimals: 18},
        ]
    },
    avax: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0xaFc43610C7840b20b90CAaF93759bE5b54B291c9",
            decimals: 18
        },
        tokens: [
            {name: "avalanche-2", address: NATIVE_ADDRESS, decimals: 18},
            {name: "usd-coin", address: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664", decimals: 6},
            {name: "tether", address: "0xc7198437980c041c805A1EDcbA50c1Ce5db95118", decimals: 6},
            {name: "bitcoin", address: "0x50b7545627a5162F82A992c33b87aDc75187B218", decimals: 8},
            {name: "dai", address: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70", decimals: 18}
        ]
    },
    fantom: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x1Bb92e03d2bdF3D7849296Ff7F9685696b0CaA39",
            abrAddress: "0x543Acd673960041eEe1305500893260F1887B679",
            decimals: 18
        },
        tokens: [
            {name: "bitcoin", address: "0x321162Cd933E2Be498Cd2267a90534A804051b11", decimals: 8},
            {name: "ethereum", address: "0x74b23882a30290451A17c44f4F05243b6b58C76d", decimals: 18},
            {name: "usd-coin", address: "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75", decimals: 6},
            {name: "dai", address: "0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E", decimals: 18},
            {name: "chainlink", address: "0xb3654dc3D10Ea7645f8319668E8F54d2574FBdC8", decimals: 18},
            {name: "fantom", address: NATIVE_ADDRESS, decimals: 18},
        ]
    },
    heco: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0x2D7E64def6c3311A75c2F6eB45E835CD58e52CDE",
            decimals: 18
        },
        tokens: [
            {name: "bitcoin", address: "0x66a79D23E58475D2738179Ca52cd0b41d73f0BEa", decimals: 18},
            {name: "tether", address: "0xa71EdC38d189767582C38A3145b5873052c3e47a", decimals: 18},
            {name: "apyswap", address: "0x90e8896b12a92D51CD213b681C2CaD83A9a6bD49", decimals: 18},

        ]
    },
    polygon: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0x04429fbb948bbd09327763214b45e505a5293346",
            decimals: 18
        },
        tokens: [
            {name: "mimatic", address: "0xa3Fa99A148fA48D14Ed51d610c367C61876997F1", decimals: 18},
            {name: "usd-coin", address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", decimals: 6},
            {name: "tether", address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", decimals: 6},
            {name: "matic-network", address: NATIVE_ADDRESS, decimals: 18},
            {name: "ethereum", address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619", decimals: 18},
            {name: "bitcoin", address: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6", decimals: 8},
            {name: "dai", address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063", decimals: 18},
            {name: "apyswap", address: "0x14743E1c6f812154F7ecc980D890F0F5234103e7", decimals: 18},
        ]
    },
    bsc: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0x68784ffaa6Ff05E3e04575DF77960DC1D9F42b4a",
            decimals: 18
        },
        tokens: [
            {name: "impossible-finance", address: "0xB0e1fc65C1a741b4662B813eB787d369b8614Af1", decimals: 18},
            {name: "krown", address: "0x1446f3CEdf4d86a9399E49f7937766E6De2A3AAB", decimals: 18},
            {name: "binance-usd", address: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", decimals: 18},
            {name: "investin", address: "0x6A46d878401F46B4C7f665f065E0667580e031ec", decimals: 18},
            {name: "tether", address: "0x55d398326f99059fF775485246999027B3197955", decimals: 18},
            {name: "usd-coin", address: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", decimals: 18},
            {name: "bitcoin", address: "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c", decimals: 18},
            {name: "ethereum", address: "0x2170Ed0880ac9A755fd29B2688956BD959F933F8", decimals: 18},
            {name: "binancecoin", address: NATIVE_ADDRESS, decimals: 18},
            {name: "uniswap", address: "0xBf5140A22578168FD562DCcF235E5D43A02ce9B1", decimals: 18},
            {name: "chainlink", address: "0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD", decimals: 18},
            {name: "dai", address: "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3", decimals: 18},
            {name: "hapi", address: "0xD9c2D319Cd7e6177336b0a9c93c21cb48d84Fb54", decimals: 18},
            {name: "1million-nfts", address: "0xa4eF4b0B23C1fc81d3f9ecF93510e64f58A4A016", decimals: 18},
            {name: "apyswap", address: "0x37dfACfaeDA801437Ff648A1559d73f4C40aAcb7", decimals: 18},
            {name: "hedget", address: "0xC7d8D35EBA58a0935ff2D5a33Df105DD9f071731", decimals: 6},
        ]
    },
    ethereum: {
        contractAddress: "0xBBbD1BbB4f9b936C3604906D7592A644071dE884",
        tokens: [
            {name: "apyswap", address: "0xf7413489c474ca4399eeE604716c72879Eea3615", decimals: 18},
            {name: "hapi", address: "0xD9c2D319Cd7e6177336b0a9c93c21cb48d84Fb54", decimals: 18},
            {name: "hedget", address: "0x7968bc6a03017eA2de509AAA816F163Db0f35148", decimals: 6},
            {name: "1million-nfts", address: "0xa4eF4b0B23C1fc81d3f9ecF93510e64f58A4A016", decimals: 18},
            {name: "allbridge", address: "0xa11bD36801d8fa4448F0ac4ea7A62e3634cE8C7C", decimals: 18},
            {name: "ariadne", address: "0xb1c9bc94aCd2fAE6aABf4ffae4429B93512a81D2", decimals: 18},
            {name: "cyberfi", address: "0x63b4f3e3fa4e438698CE330e365E831F7cCD1eF4", decimals: 18},
            {name: "ethereum", address: NATIVE_ADDRESS, decimals: 18},
            {name: "usd-coin", address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", decimals: 6},
            {name: "tether", address: "0xdAC17F958D2ee523a2206206994597C13D831ec7", decimals: 6},
            {name: "ftx-token", address: "0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9", decimals: 18},
            {name: "dai", address: "0x6B175474E89094C44Da98b954EedeAC495271d0F", decimals: 18},
            {name: "bitcoin", address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", decimals: 8},
            {name: "magic-internet-money", address: "0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3", decimals: 18},
            {name: "fei-usd", address: "0x956F47F50A910163D8BF957Cf5846D573E7f87CA", decimals: 18},
            {name: "thorstarter", address: "0x69fa0feE221AD11012BAb0FdB45d444D3D2Ce71c", decimals: 18},
            {name: "uniswap", address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", decimals: 18},
            {name: "chainlink", address: "0x514910771AF9Ca656af840dff83E8264EcF986CA", decimals: 18},
            {name: "smartpad", address: "0x5067006f830224960fb419d7f25a3a53e9919bb0", decimals: 18},
        ]
    },
    aurora: {
        tokens: [],
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0x2BAe00C8BC1868a5F7a216E881Bae9e662630111",
            decimals: 18
        },
    },
    harmony: {
        tokens: [],
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0xf80eD129002B0eE58C6d2E63D0D7Dc9Fc9f3383C",
            decimals: 18
        },
    },
    fuse: {
        tokens: [],
        staking: {
            contractAddress: "0x788BA01f8E2b87c08B142DB46F82094e0bdCad4F",
            abrAddress: "0xa21AaB22A0bAF9fff3392B0aFc5115b955664FD4",
            decimals: 18
        },
    }
}

const solanaData = {
    contractAddress: 'bb1XfNoER5QC3rhVDaVz3AJp9oFKoHNHG6PHfZLcCjj',
    staking: {
        tokenAccount: '51dd7AuT32b5VCK2rBVrjLGvfuvZ3kMayNrZZbWuvas2'
    },
    tokens: [
        {name: "apyswap", tokenAccount: '8fdkYq4XWb1LfkNcAByZUHspyvasyqH7CmFBCkoqSK5d'},
        {name: "solana", tokenAccount: 'HHC3niNsTB3hNN1kZH9BHMLiwLvCSegKBLu82tAT2iG8'},
        {name: "usd-coin", tokenAccount: 'AxsSzB2JvyHZr6uDjV3Prmak2JEqYUoaSQh9rPMSUvf2'},
        {name: "saber", tokenAccount: '7KkMhrF9Hv7dfaX5xXFtTTrfJfVjHYZ5ymwAuXVgJ6Kf'},
    ]
}

const terraData = {
    contractAddress: "terra18hf7422vyyc447uh3wpzm50wzr54welhxlytfg",
    staking: {
        contractAddress: "terra1n3v0c4dhn33adnznl3yh5r6myjgrz57x6pqkeg",
        abrAddress: "terra1a7ye2splpfzyenu0yrdu8t83uzgusx2malkc7u",
        decimals: 6
    },
    tokens: [
        {name: "terrausd", address: "uusd", decimals: 6},
        {name: "terra-luna", address: "uluna", decimals: 6},
    ]
}

const nearData = {
    contractAddress: "bridge.a11bd.near",
    staking: {
        contractAddress: "staking.a11bd.near",
        decimals: 24
    },
    tokens: [
        {name: "near", address: "wrap.near", decimals: 24},
    ]
}

const toNumber = (decimals, n) => Number(n)/Math.pow(10, decimals)

function getTVLFunction(chain)
{
    return async function tvl(timestamp, ethBlock, chainBlocks) {
        const balances = {}
        const chainData = data[chain];
        const block = chainBlocks[chain];
        for (const token of chainData.tokens) {
            const balance = token.address === NATIVE_ADDRESS ? await sdk.api.eth.getBalance({
                block, chain, target: chainData.contractAddress
            }) : await sdk.api.erc20.balanceOf({
                block, chain, target: token.address, owner: chainData.contractAddress
            });
            sdk.util.sumSingleBalance(balances, token.name, toNumber(token.decimals, balance.output));
        }
        return balances
    }
}

function getStakingFunction(chain) {
    const stakingData = data[chain].staking;
    if (!stakingData) {
        return
    }
    return staking(stakingData.contractAddress, stakingData.abrAddress, chain, "allbridge", stakingData.decimals);
}

async function solanaTvl() {
    const balances = {}
    for (const token of solanaData.tokens) {
        const balance = await solana.getTokenAccountBalance(token.tokenAccount);
        sdk.util.sumSingleBalance(balances, token.name, balance);
    }
    return balances
}

async function solanaStaking() {
    const balance = await solana.getTokenAccountBalance(solanaData.staking.tokenAccount);
    return {allbridge: balance}
}

async function terraTvl() {
    const balances = {}
    for (const token of terraData.tokens) {
        const balance = token.address.length > 5
          ? await terra.getBalance(token.address, terraData.contractAddress)
          : await terra.getDenomBalance(token.address, terraData.contractAddress);
        sdk.util.sumSingleBalance(balances, token.name, toNumber(token.decimals, balance));
    }
    return balances
}

async function terraStaking() {
    const balance = await terra.getBalance(terraData.staking.abrAddress, terraData.staking.contractAddress);
    return { allbridge: toNumber(terraData.staking.decimals, balance) }
}

async function nearTvl() {
    const balances = {}
    for (const token of nearData.tokens) {
        const balance = await near.getTokenBalance(token.address, nearData.contractAddress);
        sdk.util.sumSingleBalance(balances, token.name, toNumber(token.decimals, balance));
    }
    return balances
}

async function nearStaking() {
    const balance = await near.call(nearData.staking.contractAddress, "get_abr_balance");
    return { allbridge: toNumber(nearData.staking.decimals, balance) }
}

module.exports={
    methodology: "All tokens locked in Allbridge contracts.",
    ethereum: {
        tvl: getTVLFunction('ethereum'),
        staking: getStakingFunction('ethereum')
    },
    polygon: {
        tvl: getTVLFunction('polygon'),
        staking: getStakingFunction('polygon')
    },
    bsc: {
        tvl: getTVLFunction('bsc'),
        staking: getStakingFunction('bsc')
    },
    fantom: {
        tvl: getTVLFunction('fantom'),
        staking: getStakingFunction('fantom')
    },
    avax: {
        tvl: getTVLFunction('avax'),
        staking: getStakingFunction('avax')
    },
    heco: {
        tvl: getTVLFunction('heco'),
        staking: getStakingFunction('heco')
    },
    celo: {
        tvl: getTVLFunction('celo'),
        staking: getStakingFunction('celo')
    },
    aurora: {
        tvl: getTVLFunction('aurora'),
        staking: getStakingFunction('aurora'),
    },
    harmony: {
        tvl: getTVLFunction('harmony'),
        staking: getStakingFunction('harmony'),
    },
    fuse: {
        tvl: getTVLFunction('fuse'),
        staking: getStakingFunction('fuse'),
    },
    solana: {
        tvl: solanaTvl,
        staking: solanaStaking
    },
    terra: {
        tvl: terraTvl,
        staking: terraStaking
    },
    near: {
        tvl: nearTvl,
        staking: nearStaking
    }
}

'''
'''--- projects/alligator-exchange/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { stakingUnknownPricedLP } = require("../helper/staking");
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");

const token = "0x43C812Ba28cb061b1Be7514145A15C9E18a27342";
const stakingContract = "0x32A948F018870548bEd7e888Cd97a257b700D4c6";
const factory = "0xD9362AA8E0405C93299C573036E7FB4ec3bE1240"

async function getGtrPrice (block) {
    const chain = "avax";   
    const usdtBalance = (await sdk.api.erc20.balanceOf({
        target: "0xc7198437980c041c805a1edcba50c1ce5db95118",
        owner: "0x039b4C79916b7ACc953f0f67e6181842EFBE6e6e",
        block,
        chain
    })).output;
    const gtrBalance = (await sdk.api.erc20.balanceOf({
        target: "0x43C812Ba28cb061b1Be7514145A15C9E18a27342",
        owner: "0x039b4C79916b7ACc953f0f67e6181842EFBE6e6e",
        block,
        chain
    })).output;
    const gtrPrice = usdtBalance/gtrBalance;
    return gtrPrice
}

async function tvl(timestamp, block, chainBlocks) {
    let balances = await calculateUniTvl(addr=>`avax:${addr}`, chainBlocks.avax, "avax", factory, 0, true);
    const gtrPrice = await getGtrPrice(chainBlocks.avax);
    sdk.util.sumSingleBalance(balances, `avax:0x19860ccb0a68fd4213ab9d8266f7bbf05a8dde98`, BigNumber(balances["avax:0x43c812ba28cb061b1be7514145a15c9e18a27342"]).times(gtrPrice).times(10 ** 12).toFixed(0));
    delete balances["avax:0x43c812ba28cb061b1be7514145a15c9e18a27342"];
    return balances;
}

module.exports = {
    misrepresentedTokens: true,
    avalanche: {
        tvl,
        staking: stakingUnknownPricedLP(stakingContract, token, "avax", "0x039b4C79916b7ACc953f0f67e6181842EFBE6e6e")
    }
}
'''
'''--- projects/allinx.js ---
const utils = require('./helper/utils');

/* * * * * * * *
* ==> Correct adapter needs to be created.
*
*****************/
async function fetch() {
  let staked = await utils.fetchURL('https://api.allinx.io/api/stats')
  return staked.data.data.totalLockedValue;
}

module.exports = {
  fetch
}

'''
'''--- projects/almond.js ---
module.exports = {
  timetravel: false,
  methodology: "The pools on https://almond.so/ are included in TVL. Standard tokens (SOL, BTC, ETH, USDC, etc..), no pool 2. The API fetches the balances of the Solana accounts holding the staked tokens, then uses Coingecko prices to determine dollar values.",
  solana: {
    tvl: () =>  ({}), // project is dead
  },
};

'''
'''--- projects/alpaca-finance/abi.json ---
{
  "vaultDebtVal": {
    "inputs": [],
    "name": "vaultDebtVal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalToken": {
    "inputs": [],
    "name": "totalToken",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "pid": {
    "inputs": [],
    "name": "pid",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "reservePool": {
    "inputs": [],
    "name": "reservePool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IPancakePair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "rewardDebt",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfoCake": {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "shares",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastDepositedTime",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "singleAssetPrice":{
    "inputs": [],
    "name": "getPricePerFullShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "pId": {
    "inputs": [],
    "name": "pid",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "ausdTotalStablecoinIssued": {
    "inputs": [],
    "name": "totalStablecoinIssued",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "xalpacaTotalSupply": {
    "inputs": [],
    "name": "supply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/alpaca-finance/ausd.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");

async function getProcolAUSDAddresses(chain) {
  if (chain == "bsc") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/alpaca-stablecoin/main/.mainnet.json"
      )
    ).data;
  }
}

async function getProcolLYFAddresses(chain) {
  if (chain == "bsc") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/bsc-alpaca-contract/main/.mainnet.json"
      )
    ).data;
  }
  if (chain == "fantom") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/bsc-alpaca-contract/main/.fantom_mainnet.json"
      )
    ).data;
  }
}

async function calAusdTvl(chain, block) {
  /// @dev Initialized variables
  const balances = {};

  const ausdAddresses = await getProcolAUSDAddresses(chain);
  const lyfAddresses = await getProcolLYFAddresses(chain);

  const pids = await sdk.api.abi.multiCall({
    block,
    abi: abi.pid,
    calls: ausdAddresses["IbTokenAdapters"].map((each) => {
      return {
        target: each.address,
      };
    }),
    chain,
  });
  const failaunchUserInfos = await sdk.api.abi.multiCall({
    block,
    abi: abi.userInfo,
    calls: pids.output.map((each) => {
      return {
        target: lyfAddresses["FairLaunch"].address,
        params: [each.output, each.input.target],
      };
    }),
    chain,
  });
  const totalTokens = await sdk.api.abi.multiCall({
    block,
    abi: abi.totalToken,
    calls: ausdAddresses["IbTokenAdapters"].map((each) => {
      return {
        target: each.collateralToken,
      };
    }),
    chain,
  });
  const totalSupplys = await sdk.api.abi.multiCall({
    block,
    abi: abi.totalSupply,
    calls: ausdAddresses["IbTokenAdapters"].map((each) => {
      return {
        target: each.collateralToken,
      };
    }),
    chain,
  });
  const vaultTokens = await sdk.api.abi.multiCall({
    block,
    abi: abi.token,
    calls: ausdAddresses["IbTokenAdapters"].map((each) => {
      return {
        target: each.collateralToken,
      };
    }),
    chain,
  });
  
  failaunchUserInfos.output.forEach((eachUserInfo, i) => {
    const balance = new BigNumber(eachUserInfo.output.amount).multipliedBy(totalTokens.output[i].output).dividedBy(totalSupplys.output[i].output)
    balances[`${chain}:${vaultTokens.output[i].output}`] = balance.toFixed(0);
  })
  return balances;
}

module.exports = {
  calAusdTvl,
};

'''
'''--- projects/alpaca-finance/index.js ---
const { calLyfTvl } = require("./lyf");
const { calAusdTvl } = require('./ausd');
const { calxALPACAtvl } = require('./xalpaca');

async function bscTvl(timestamp, ethBlock, chainBlocks) {
  const lyfTvl = await calLyfTvl('bsc', chainBlocks.bsc);
  const ausdTvl = await calAusdTvl('bsc', chainBlocks.bsc);
  return {...lyfTvl, ...ausdTvl};
}

async function bscStaking(timestamp, ethBlock, chainBlocks) {
  return await calxALPACAtvl('bsc', chainBlocks.bsc);
}

async function fantomTvl(timestamp, ethBlock, chainBlocks) {
  const lyfTvl = await calLyfTvl('fantom', chainBlocks.fantom);
  return {...lyfTvl};
}

async function ftmStaking(timestamp, ethBlock, chainBlocks) {
  return await calxALPACAtvl('fantom', chainBlocks.fantom);
}

// node test.js projects/alpaca-finance/index.js
module.exports = {
  start: 1602054167,
  bsc: {
    tvl: bscTvl,
    staking: bscStaking,
  },
  fantom: {
    tvl: fantomTvl,
    staking: ftmStaking,
  }
};

'''
'''--- projects/alpaca-finance/lyf.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

async function getProcolAddresses(chain) {
  if (chain == 'bsc') {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/bsc-alpaca-contract/main/.mainnet.json"
      )
    ).data;
  }
  if (chain == 'fantom') {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/bsc-alpaca-contract/main/.fantom_mainnet.json"
      )
    ).data;
  }
}

async function calLyfTvl(chain, block) {
  /// @dev Initialized variables
  const balances = {};

  /// @dev Getting all addresses from Github
  const addresses = await getProcolAddresses(chain);

  for (let i = 0; i < addresses["Vaults"].length; i++) {
    /// @dev getting balances that each of workers holding
    const stakingTokenInfos = (
      await sdk.api.abi.multiCall({
        block,
        abi: abi.userInfo,
        calls: addresses["Vaults"][i]["workers"].filter((n) => {
          /// @dev filter only workers that are working with LPs
          if (n.name.includes("CakeMaxiWorker")) {
            return false;
          }
          return true;
        }).map((worker) => {
          return {
            target: worker["stakingTokenAt"],
            params: [worker["pId"], worker["address"]],
          };
        }),
        chain,
      })
    ).output;

    /// @dev unwrap LP to get underlaying token balances for workers that are working with LPs
    await unwrapUniswapLPs(
      balances,
      stakingTokenInfos
        .filter((n) => {
          /// @dev filter only workers that are working with LPs
          const name = addresses["Vaults"][i]["workers"].find(
            (w) => w.address === n.input.params[1]
          ).name;
          if (name.includes("CakeMaxiWorker")) {
            return false;
          }
          return true;
        })
        .map((info) => {
          /// @dev getting LP address and return the object that unwrapUniswapLPs want
          const lpAddr = addresses["Vaults"][i]["workers"].find(
            (w) => w.address === info.input.params[1]
          ).stakingToken;
          return {
            token: lpAddr,
            balance: info.output.amount,
          };
        }),
      block,
      chain,
      (addr) => `${chain}:${addr}`
    );

    /// @dev update balances directly for single-asset workers
    const singleAssetWorkersInfos = (
      await sdk.api.abi.multiCall({
        block,
        abi: abi.userInfoCake,
        calls: addresses["Vaults"][i]["workers"].filter((n) => {
          /// @dev filter only single-asset LYF workers
          return n.name.includes("CakeMaxiWorker");
        }).map((worker) => {
          return {
            target: worker["stakingTokenAt"],
            params: [worker["address"]],
          };
        }),
        chain,
      })
    ).output;

    const singleAssetPrice = (
      await sdk.api.abi.multiCall({
        block,
        abi: abi.singleAssetPrice,
        calls: addresses["Vaults"][0]["workers"].filter((n) => {
          /// @dev filter only single-asset LYF workers
          return n.name.includes("CakeMaxiWorker");
        }).map((worker) => {
          return {
            target: worker["stakingTokenAt"],
          };
        }),
        chain,
      })
    ).output;

    const singleAssetWorkersBalances = singleAssetWorkersInfos
      .map((n) => {
        /// @dev getting staking token address and return the object to be sum with balances
        const stakingTokenAddr = addresses["Vaults"][i]["workers"].find(
          (w) => w.address === n.input.params[0]
        ).stakingToken;
        return {
          token: stakingTokenAddr,
          balance: BigNumber(n.output.shares).multipliedBy(BigNumber(singleAssetPrice[0].output)).div(1e18),
        };
      });

    /// @dev sum single-asset balances to balances variable
    singleAssetWorkersBalances.forEach((s) => {
      balances[`${chain}:${s.token}`] = BigNumber(
        balances[`${chain}:${s.token}`] || 0
      )
        .plus(BigNumber(s.balance))
        .toFixed(0);
    });
  }

  /// @dev getting all unused liquidity on each vault
  const unusedBTOKEN = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.balanceOf,
      calls: addresses["Vaults"].map((v) => {
        return {
          target: v["baseToken"],
          params: [v["address"]],
        };
      }),
      chain,
    })
  ).output;

  unusedBTOKEN.forEach((u) => {
    balances[`${chain}:${u.input.target.toLowerCase()}`] = BigNumber(
      balances[`${chain}:${u.input.target.toLowerCase()}`] || 0
    )
      .plus(BigNumber(u.output))
      .toFixed(0);
  });

  return balances;
}

module.exports = {
  calLyfTvl
}
  
'''
'''--- projects/alpaca-finance/xalpaca.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");

async function getProcolXAlpacaAddresses(chain) {
  if (chain == "bsc") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/xALPACA-contract/main/.mainnet.json"
      )
    ).data;
  }
  if (chain == "fantom") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/alpaca-finance/xALPACA-contract/main/.fantom_mainnet.json"
      )
    ).data;
  }
}
  

async function calxALPACAtvl(chain, block) {
  const xalpacaAddresses = await getProcolXAlpacaAddresses(chain);

  const xalpacaTVL = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.xalpacaTotalSupply,
      calls: [
        {
          target: xalpacaAddresses["xALPACA"],
        },
      ],
      chain,
    })
  ).output;
  const alpacaAddress = xalpacaAddresses["Tokens"]["ALPACA"];
  return { [`${chain}:${alpacaAddress}`]: xalpacaTVL[0].output };
}

module.exports = {
  calxALPACAtvl,
}
'''
'''--- projects/alpacacity/index.js ---
const { staking } = require("../helper/staking");
const { pool2, pool2s } = require("../helper/pool2");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");

/*** Ethereum Addresss ***/
const stakingContracts = [
    //stakingContractAlpaFireChamber
    "0x741Cee6e4Bd99Df866ab0dD0D0C0b5ED7033344A",
    //stakingContract
    "0x232F030747008D3bA5d51526f5966d8985218Ff0",
    //StakingContractAlpacaSquadNFTFarm
    "0xE23A7741A5E9500f7a1dE4B246d1F7f29F81605F"
];
const ALPA = "0x7cA4408137eb639570F8E647d9bD7B7E8717514A";

const farmContract = "0x217a7D0Ac6573b0f013e12f92B6d5B250FA15D97";
const WETH_ALPA2_UNIV2 = "0x441f9e2c89a343cefb390a8954b3b562f8f91eca";

const treasuryContracts = [
    "0xd93DC6B8Ef043C3ad409C6480A57b4851b3C055e",
    "0xF30Ccf37c7058Db0026DE9239d373a1c8723210a"
];

/*** BSC Addresss ***/
const stakingContractBSC = "0xa24FBFE379Ecb914c205BE4d9214592F64194059";
const ALPA_BSC = "0xc5E6689C9c8B02be7C49912Ef19e79cF24977f03";

const farmContractsBSC = [
    //V2
    "0x25B0dc84b62D7e2bd4eBba0Dda6C25E3e7c0D717",
    //V1
    "0x03625c4156A010065D135A18123a9e25FF5AEd12",
];
const lpPairContractsBSC = [
    //WBNB_ALPA_CakeLP V2
    "0x4cC442220BE1cE560C1f2573f8CA8f460B3E4172",
    //WBNB_ALPA_CakeLP V1
    "0x837cD42282801E340f1F17AAdf3166fEE99fb07c"
]

const treasuryContractsBSC = [
    "0x3226dBce6317dF643EB68bbeF379E6B968b3E669",
    "0xb9C76Db167Fa6BFd0e6d78063C63B3073C637497",
    "0x6F712F28834b82B7781311b42a945a6134112B2A"
];

async function ethTreasury() {
    const balances = {};

    await sumTokensAndLPsSharedOwners(
        balances,
        [[ALPA, false]],
        treasuryContracts
    );

    return balances;
}

async function bscTreasury(chainBlocks) {
    const balances = {};

    let transform = await transformBscAddress();
    await sumTokensAndLPsSharedOwners(
        balances,
        [[ALPA_BSC, false]],
        treasuryContractsBSC,
        chainBlocks["bsc"],
        "bsc",
        transform
    );

    return balances;
}

async function Staking(...params) {
    for (const contract of stakingContracts) {
        return staking(contract, ALPA)(...params)
    }

}

module.exports = {
    ethereum: {
        treasury: ethTreasury,
        staking: Staking,
        pool2: pool2(farmContract, WETH_ALPA2_UNIV2),
    },
    bsc: {
        treasury: bscTreasury,
        staking: staking(stakingContractBSC, ALPA_BSC, "bsc"),
        pool2: pool2s(farmContractsBSC, lpPairContractsBSC, "bsc"),
    },
    tvl: async => ({}),
    methodology:
        "Counts liquidity on the Farms through AlpacaFarm Contracts; and there are Staking and Pool2 parts only. We export the comunity amount as Treasury Part",
};

'''
'''--- projects/alpha-homora/abi.json ---
{
  "glbDebtVal": {
    "constant": true,
    "inputs": [],
    "name": "glbDebtVal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "totalETH": {
    "constant": true,
    "inputs": [],
    "name": "totalETH",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "reservePool": {
    "constant": true,
    "inputs": [],
    "name": "reservePool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "pendingSushi": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_pid",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "_user",
        "type": "address"
      }
    ],
    "name": "pendingSushi",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "rewardDebt",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getETHPx": {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "getETHPx",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "constant": true,
    "inputs": [],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IUniswapV2Pair",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/alpha-homora/index.js ---
const BigNumber = require("bignumber.js");
const {tvlV1Eth, tvlV1Bsc} = require('./v1.js')
const {tvlV2, tvlV2Onchain} = require('./v2.js')

async function ethTvl(timestamp, block) {
  const ethAddress = "0x0000000000000000000000000000000000000000";
  const balances = {};

  const tvls = await Promise.all([
    tvlV1Eth(timestamp, block),
    tvlV2(block, "ethereum", true),
  ]);

  const ethTvl = BigNumber.sum(tvls[0], tvls[1]);
  balances[ethAddress] = ethTvl.toFixed(0);

  return balances;
}

async function avaxTvl(timestamp, block, chainBlocks) {
  return tvlV2Onchain(chainBlocks.avax, "avax")
}

async function fantomTvl(timestamp, block, chainBlocks) {
  return tvlV2Onchain(chainBlocks.fantom, "fantom")
}

module.exports = {
  misrepresentedTokens: true,
  doublecounted: true,
  ethereum:{
    tvl: ethTvl
  },
  bsc:{
    tvl: tvlV1Bsc
  },
  avalanche:{
    tvl: avaxTvl
  },
  fantom:{
    tvl: fantomTvl
  },
  start: 1602054167, // unix timestamp (utc 0) specifying when the project began, or where live data begins
};

'''
'''--- projects/alpha-homora/v1.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const axios = require("axios");
const BigNumber = require("bignumber.js");

module.exports = {
    tvlV1Eth,
    tvlV1Bsc
}

async function tvlV1Eth(timestamp, block) {
    const startTimestamp = 1602054167;
    const startBlock = 11007158;
  
    if (timestamp < startTimestamp || block < startBlock) {
      return BigNumber(0);
    }
    return tvlV1("ethereum", block, "https://homora.alphafinance.io/static/contracts.json", "WETHAddress", "totalETH")
}

const wBNB = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'
async function tvlV1Bsc(timestamp, block, chainBlocks) {
    const tvlBNB = await tvlV1("bsc", chainBlocks.bsc, "https://homora-bsc.alphafinance.io/static/contracts.json", "WBNBAddress", "totalBNB")
    return {
        ["bsc:"+wBNB]: tvlBNB.toFixed(0)
    }
}

async function tvlV1(chain, block, contractsUrl, wrappedBaseName, totalEthMethodName) {
    const { data } = await axios.get(
      contractsUrl
    );
  
    const bankAddress = data.bankAddress.toLowerCase();
    const WETHAddress = data[wrappedBaseName].toLowerCase();
  
    let pools = data.pools;
  
    const uniswapPools = pools.filter(
      (pool) => pool.id === undefined
    );
  
    const sushiswapPools = pools.filter(
      (pool) => pool.id !== undefined
    );
    pools = [...uniswapPools, ...sushiswapPools];
  
    const { output: _totalETH } = await sdk.api.abi.call({
      target: bankAddress,
      block,
      chain,
      abi: {
          ...abi["totalETH"],
          name: totalEthMethodName
        },
    });
  
    const totalETH = BigNumber(_totalETH);
  
    const { output: _totalDebt } = await sdk.api.abi.call({
      target: bankAddress,
      block,
      chain,
      abi: abi["glbDebtVal"],
    });
  
    const totalDebt = BigNumber(_totalDebt);
  
    // Uniswap Pools
    const { output: _UnilpTokens } = await sdk.api.abi.multiCall({
      calls: uniswapPools.map((pool) => ({
        target: pool.lpStakingAddress,
        params: [pool.goblinAddress],
      })),
      chain,
      abi: abi["balanceOf"],
      block,
    });
  
    // Sushiswap Pools
    const { output: _SushilpTokens } = await sdk.api.abi.multiCall({
      calls: sushiswapPools.map((pool) => ({
        target: pool.lpStakingAddress,
        params: [pool.id, pool.goblinAddress],
      })),
      chain,
      abi: abi["userInfo"],
      block,
    });
  
    const _lpTokens = [
      ..._UnilpTokens,
      ..._SushilpTokens.map((x) => ({
        output: x.output[0],
      })),
    ];
  
    const lpTokens = _lpTokens.map((_lpToken) => BigNumber(_lpToken.output || 0));
  
    const { output: _totalETHOnStakings } = await sdk.api.abi.multiCall({
      calls: pools.map((pool) => ({
        target: WETHAddress,
        params: [pool.lpTokenAddress],
      })),
      chain,
      abi: abi["balanceOf"],
      block,
    });
  
    const totalETHOnStakings = _totalETHOnStakings.map((stake) =>
      BigNumber(stake.output || 0)
    );
  
    const { output: _totalLpTokens } = await sdk.api.abi.multiCall({
      calls: pools.map((pool) => ({
        target: pool.lpTokenAddress,
      })),
      chain,
      abi: abi["totalSupply"],
      block,
    });
  
    const totalLpTokens = _totalLpTokens.map((_totalLpToken) =>
      BigNumber(_totalLpToken.output || 0)
    );
  
    const unUtilizedValue = totalETH.minus(totalDebt);
  
    let tvl = BigNumber(unUtilizedValue);
    for (let i = 0; i < lpTokens.length; i++) {
      if (totalLpTokens[i].gt(0)) {
        const amount = lpTokens[i]
          .times(totalETHOnStakings[i])
          .div(totalLpTokens[i])
          .times(BigNumber(2));
  
        tvl = tvl.plus(amount);
      }
    }
    return tvl;
  }
'''
'''--- projects/alpha-homora/v1/bsc-contracts.json ---
{
    "bankAddress": "0x3bb5f6285c312fc7e1877244103036ebbeda193d",
    "WBNBAddress": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    "pools": [
      {
        "exchange": "Pancake V1",
        "name": "BNB/CAKE",
        "id": 1,
        "tokenAddress": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "goblinAddress": "0xaa00f2b7dd0de46c6fc9655dbadd80ac91a66869",
        "lpTokenAddress": "0xa527a61703d82139f8a06bc30097cc9caa2df5a6",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/cake.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/BUSD",
        "id": 2,
        "tokenAddress": "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "goblinAddress": "0x08d871ddad70bd3aef3fecfbf4350debc57d8264",
        "lpTokenAddress": "0x1b96b92314c44b159149f7e0303511fb2fc4774f",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/busd.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/BTCB",
        "id": 15,
        "tokenAddress": "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
        "goblinAddress": "0x549ef362657a3e3923793a494db3d89e3e5fda35",
        "lpTokenAddress": "0x7561eee90e24f3b348e1087a005f78b4c8453524",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/btcb.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/ETH",
        "id": 14,
        "tokenAddress": "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "goblinAddress": "0x2f050b64ede3b1d21184435974bb1d2fe02012b6",
        "lpTokenAddress": "0x70d8929d04b60af4fb9b58713ebcf18765ade422",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/eth.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/USDT",
        "id": 17,
        "tokenAddress": "0x55d398326f99059ff775485246999027b3197955",
        "goblinAddress": "0x3974071481dad49ac94ca1756f311c872ec3e26e",
        "lpTokenAddress": "0x20bcc3b8a0091ddac2d0bc30f68e6cbb97de59cd",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/usdt.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/UNI",
        "id": 25,
        "tokenAddress": "0xbf5140a22578168fd562dccf235e5d43a02ce9b1",
        "goblinAddress": "0xfdcdf8d07db8c5b33fbf46f41eced421d9d32bee",
        "lpTokenAddress": "0x4269e7f43a63cea1ad7707be565a94a9189967e9",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/uni.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/LINK",
        "id": 7,
        "tokenAddress": "0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd",
        "goblinAddress": "0x047683a9a7958c02ca86b6eecea1f8acfbd54f4f",
        "lpTokenAddress": "0xaebe45e3a03b734c68e5557ae04bfc76917b4686",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/link.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/BAND",
        "id": 4,
        "tokenAddress": "0xad6caeb32cd2c308980a548bd0bc5aa4306c6c18",
        "goblinAddress": "0xc3c16508e77e99e67cfcd30b765e48a5a33d4c9d",
        "lpTokenAddress": "0xc639187ef82271d8f517de6feae4faf5b517533c",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/band.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/YFI",
        "id": 24,
        "tokenAddress": "0x88f1a5ae2a3bf98aeaf342d26b30a79438c9142e",
        "goblinAddress": "0x3663aedebb70dcf0a64e2600233d6913dd3ecf2b",
        "lpTokenAddress": "0x68ff2ca47d27db5ac0b5c46587645835dd51d3c1",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/yfi.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/ALPHA",
        "id": 16,
        "tokenAddress": "0xa1faa113cbe53436df28ff0aee54275c13b40975",
        "goblinAddress": "0xa0aa119e0324d864831c24b78e85927526e42d52",
        "lpTokenAddress": "0x4e0f3385d932f7179dee045369286ffa6b03d887",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/alpha.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/INJ",
        "id": 27,
        "leverages": [1, 1.5, 2, 2.5],
        "tokenAddress": "0xa2b726b1145a4773f68593cf171187d8ebe4d495",
        "goblinAddress": "0x62e32e6ebeabf776b59f5dfb9b364779c3a64137",
        "lpTokenAddress": "0x7a34bd64d18e44cfde3ef4b81b87baf3eb3315b6",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "logo": "/static/tokens/inj.png"
      },
      {
        "exchange": "Pancake V1",
        "name": "BNB/DOT",
        "id": 5,
        "leverages": [1, 1.5, 2, 2.5],
        "tokenAddress": "0x7083609fce4d1d8dc0c979aab8c869ea2c873402",
        "goblinAddress": "0x567f4a45d45945a75898be4cad299a8f32c86d08",
        "lpTokenAddress": "0xbcd62661a6b1ded703585d3af7d7649ef4dcdb5c",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "logo": "'/static/tokens/dot.png'"
      },
  
      {
        "exchange": "Pancake V2",
        "name": "BNB/CAKE",
        "id": 251,
        "tokenAddress": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "goblinAddress": "0x5a71a15037de71d52d8b27b6a637b617b4fae261",
        "lpTokenAddress": "0x0ed7e52944161450477ee417de9cd3a859b14fd0",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/cake.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/BUSD",
        "id": 252,
        "tokenAddress": "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "goblinAddress": "0xa25ad83285e0d0989b1409b3755be7e30bb821d7",
        "lpTokenAddress": "0x58f876857a02d6762e0101bb5c46a8c1ed44dc16",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/busd.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/BTCB",
        "id": 262,
        "tokenAddress": "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
        "goblinAddress": "0x44ae9dfaf7597c3665fb25ed31b5a32bab12ebc4",
        "lpTokenAddress": "0x61eb789d75a95caa3ff50ed7e47b96c132fec082",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/btcb.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/ETH",
        "id": 261,
        "tokenAddress": "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "goblinAddress": "0x1601b34b8ae3378c7c2df675a37a7064164c74ca",
        "lpTokenAddress": "0x74e4716e431f45807dcf19f284c7aa99f18a4fbc",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/eth.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/USDT",
        "id": 264,
        "tokenAddress": "0x55d398326f99059ff775485246999027b3197955",
        "goblinAddress": "0x22bb68bd0b113ccf688e0759ac0b4abc013df824",
        "lpTokenAddress": "0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/usdt.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/UNI",
        "id": 268,
        "tokenAddress": "0xbf5140a22578168fd562dccf235e5d43a02ce9b1",
        "goblinAddress": "0xc07e4cc403b093bd94d80f30c78b63080a79cd10",
        "lpTokenAddress": "0x014608e87af97a054c9a49f81e1473076d51d9a3",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/uni.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/LINK",
        "id": 257,
        "tokenAddress": "0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd",
        "goblinAddress": "0x8252aa78372b59d53e1c001d98f400611e9d2a20",
        "lpTokenAddress": "0x824eb9fadfb377394430d2744fa7c42916de3ece",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/link.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/BAND",
        "id": 254,
        "tokenAddress": "0xad6caeb32cd2c308980a548bd0bc5aa4306c6c18",
        "goblinAddress": "0x7b4b9e3d52296416b7e0396593b5d885cdb27472",
        "lpTokenAddress": "0x168b273278f3a8d302de5e879aa30690b7e6c28f",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/band.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/YFI",
        "id": 267,
        "tokenAddress": "0x88f1a5ae2a3bf98aeaf342d26b30a79438c9142e",
        "goblinAddress": "0x7e52d9dbaf0366aaec36175d551b21762336ecdb",
        "lpTokenAddress": "0xce383277847f8217392eea98c5a8b4a7d27811b0",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5, 3],
        "logo": "/static/tokens/yfi.png",
        "deprecated": true
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/ALPHA",
        "id": 263,
        "tokenAddress": "0xa1faa113cbe53436df28ff0aee54275c13b40975",
        "goblinAddress": "0x78cffa390b2355b14aacaf97571da3be817c84bf",
        "lpTokenAddress": "0xacf47cbeaab5c8a6ee99263cfe43995f89fb3206",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/alpha.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/INJ",
        "id": 270,
        "leverages": [1, 1.5, 2, 2.5],
        "tokenAddress": "0xa2b726b1145a4773f68593cf171187d8ebe4d495",
        "goblinAddress": "0xc2dc871a7ded817d8a960d2f2ceae6edb377c73f",
        "lpTokenAddress": "0x1bdcebca3b93af70b58c41272aea2231754b23ca",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "logo": "/static/tokens/inj.png"
      },
      {
        "exchange": "Pancake V2",
        "name": "BNB/DOT",
        "id": 255,
        "leverages": [1, 1.5, 2, 2.5],
        "tokenAddress": "0x7083609fce4d1d8dc0c979aab8c869ea2c873402",
        "goblinAddress": "0xaef73ea3a6f3f302af20a154c68996790bbaa85e",
        "lpTokenAddress": "0xdd5bad8f8b360d76d12fda230f8baf42fe0022cf",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "logo": "'/static/tokens/dot.png'"
      },
      {
        "tokenLogos": ["/static/tokens/bnb.png", "/static/tokens/xvs.png"],
        "exchange": "Pancake V2",
        "name": "BNB/XVS",
        "id": 260,
        "leverages": [1, 1.5, 2],
        "tokenAddress": "0xcf6bb5389c92bdda8a3747ddb454cb7a64626c63",
        "goblinAddress": "0x8f543b602e0bf1cc652c10f50d0ad853185a5f26",
        "lpTokenAddress": "0x7eb5d86fd78f3852a3e0e064f2842d45a3db6ea2",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "logo": "/static/tokens/xvs.png",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true
      },
      {
        "logo": "/static/tokens/front.png",
        "exchange": "Pancake V2",
        "name": "BNB/FRONT",
        "id": 287,
        "leverages": [1, 1.5, 2],
        "tokenAddress": "0x928e55dab735aa8260af3cedada18b5f70c72f1b",
        "goblinAddress": "0xcd168c28c17aef8d47b88ff0904ef5bf1c806000",
        "lpTokenAddress": "0xc6b668548aa4a56792e8002a920d3159728121d5",
        "lpStakingAddress": "0x73feaa1ee314f8c655e354234017be2193c9e24e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true
      }
    ],
    "exchanges": {
      "Pancake": {
        "name": "Pancake V1",
        "reward": {
          "tokenName": "CAKE",
          "rewardPerPoolPerYear": "0",
          "rewardTokenAddress": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
          "rewardBNBLpTokenAddress": "0xa527a61703d82139f8a06bc30097cc9caa2df5a6"
        }
      },
      "PancakeV2": {
        "name": "Pancake V2",
        "reward": {
          "tokenName": "CAKE",
          "rewardPerPoolPerYear": "0",
          "rewardTokenAddress": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
          "rewardBNBLpTokenAddress": "0x0ed7e52944161450477ee417de9cd3a859b14fd0"
        }
      }
    }
  }
'''
'''--- projects/alpha-homora/v1/eth-contracts.json ---
{
    "bankAddress": "0x67b66c99d3eb37fa76aa3ed1ff33e8e39f0b9c7a",
    "WETHAddress": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "pools": [
      {
        "exchange": "Uniswap",
        "name": "WETH/WBTC",
        "tokenAddress": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "goblinAddress": "0x41f07d87a28adec58dba1d063d540b86ccbb989f",
        "lpTokenAddress": "0xBb2b8038a1640196FbE3e38816F3e67Cba72D940",
        "lpStakingAddress": "0xCA35e32e7926b96A9988f61d510E038108d8068e",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/wbtc.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/USDC",
        "tokenAddress": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "goblinAddress": "0xb7bf6d2e6c4fa291d6073b51911bac17890e92ec",
        "lpTokenAddress": "0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc",
        "lpStakingAddress": "0x7FBa4B8Dc5E7616e59622806932DBea72537A56b",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/usdc.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/USDT",
        "tokenAddress": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "goblinAddress": "0x4668ff4d478c5459d6023c4a7efda853412fb999",
        "lpTokenAddress": "0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852",
        "lpStakingAddress": "0x6C3e4cb2E96B01F4b866965A91ed4437839A121a",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/usdt.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/DAI",
        "tokenAddress": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "goblinAddress": "0x14804802592c0f6e2fd03e78ec3efc9b56f1963d",
        "lpTokenAddress": "0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11",
        "lpStakingAddress": "0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/dai.png"
      },
      {
        "exchange": "IndexCoop",
        "name": "WETH/DPI",
        "tokenAddress": "0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b",
        "goblinAddress": "0xdaa93955982d32451f90a1109ecec7fecb7ee4b3",
        "lpTokenAddress": "0x4d5ef58aac27d99935e5b6b4a6778ff292059991",
        "lpStakingAddress": "0x8f06fba4684b5e0988f215a47775bb611af0f986",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/dpi.png"
      },
      {
        "exchange": "IndexCoop",
        "name": "WETH/DPI",
        "tokenAddress": "0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b",
        "goblinAddress": "0x4d4ad9628f0c16bbd91cab3a39a8f15f11134300",
        "lpTokenAddress": "0x4d5ef58aac27d99935e5b6b4a6778ff292059991",
        "lpStakingAddress": "0xb93b505ed567982e2b6756177ddd23ab5745f309",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/dpi.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/YFI",
        "tokenAddress": "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e",
        "goblinAddress": "0x66e970f2602367f8ae46ccee79f6139737eaff1c",
        "lpTokenAddress": "0x2fDbAdf3C4D5A8666Bc06645B8358ab803996E28",
        "lpStakingAddress": "0xb0942ab3bd38fe3128f09a613de80cd70a90c94d",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/yfi.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/UNI",
        "tokenAddress": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
        "goblinAddress": "0xfbc0d22bf0ecc735a03fd08fc20b48109cb89543",
        "lpTokenAddress": "0xd3d2e2692501a5c9ca623199d38826e513033a17",
        "lpStakingAddress": "0x98a39b20a6907acd7e7710ae80b696c54d4b2dfd",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2],
        "logo": "/static/tokens/uni.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/LINK",
        "tokenAddress": "0x514910771af9ca656af840dff83e8264ecf986ca",
        "goblinAddress": "0xf285e8adf8b871a32c305ab20594cbb251341535",
        "lpTokenAddress": "0xa2107fa5b38d9bbd2c461d6edf11b11a50f6b974",
        "lpStakingAddress": "0xfd97f5bc8ee51fa655f53a21005d0f5653b971c0",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2],
        "logo": "/static/tokens/uni.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/AAVE",
        "tokenAddress": "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
        "goblinAddress": "0xe900e07ce6bcdd3c5696bfc67201e940e316c1f1",
        "lpTokenAddress": "0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f",
        "lpStakingAddress": "0x36a5e6139199b8220f3733a2ad29c8059b1834b1",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2],
        "logo": "/static/tokens/aave.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/MKR",
        "tokenAddress": "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2",
        "goblinAddress": "0xee781f10ce14a45f1d8c2487aeaf24d0366fb9fa",
        "lpTokenAddress": "0xc2adda861f89bbb333c90c492cb837741916a225",
        "lpStakingAddress": "0xa86e0b83831e9e235016ba710bebe754d1602457",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2],
        "logo": "/static/tokens/mkr.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/renBTC",
        "tokenAddress": "0xeb4c2781e4eba804ce9a9803c67d0893436bb27d",
        "goblinAddress": "0x09b4608a0ca9ae8002465eb48cd2f916edf5bf63",
        "lpTokenAddress": "0x81fbef4704776cc5bba0a5df3a90056d2c6900b3",
        "lpStakingAddress": "0x697349dfdda56936c716a243524810506c2898b7",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/renBTC.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/REN",
        "tokenAddress": "0x408e41876cccdc0f92210600ef50372656052a38",
        "goblinAddress": "0x9d00b5eeedeea5141e82b101e645352a2ea960ba",
        "lpTokenAddress": "0x8bd1661da98ebdd3bd080f0be4e6d9be8ce9858c",
        "lpStakingAddress": "0x593d49c82feadc0f5a756a4a4d673573ea0baba4",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/ren.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/SNX",
        "tokenAddress": "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f",
        "goblinAddress": "0x0ec3de9941479526bb3f530c23aaff84148d17a7",
        "lpTokenAddress": "0x43ae24960e5534731fc831386c07755a2dc33d47",
        "lpStakingAddress": "0x201687712c2a0c4669518d838cbbedcea77f98ef",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/snx.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/KP3R",
        "tokenAddress": "0x1ceb5cb57c4d4e2b2433641b95dd330a33185a44",
        "goblinAddress": "0xcbb95b7708b1b543ecb82b2d58db1711f88d265c",
        "lpTokenAddress": "0x87febfb3ac5791034fd5ef1a615e9d9627c2665d",
        "lpStakingAddress": "0x7599a3c5a4eaba41863126df4b14b8b20606fffc",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1],
        "logo": "/static/tokens/kp3r.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/SFI",
        "tokenAddress": "0xb753428af26e81097e7fd17f40c88aaa3e04902c",
        "goblinAddress": "0x6cc2c08e413638ceb38e3db964a114f139fff81e",
        "lpTokenAddress": "0xc76225124f3caab07f609b1d147a31de43926cd6",
        "lpStakingAddress": "0xe932326d463d56ca40b4aaa3572a1052b544f908",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1],
        "logo": "/static/tokens/sfi.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/PERP",
        "tokenAddress": "0xbc396689893d065f41bc2c6ecbee5e0085233447",
        "goblinAddress": "0x766614adcff1137f8fced7f0804d184ce659826a",
        "lpTokenAddress": "0xf66369997ae562bc9eec2ab9541581252f9ca383",
        "lpStakingAddress": "0xcd912be8943fd58bede3859a56048f2a8475b865",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1],
        "logo": "/static/tokens/perp.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/COMP",
        "tokenAddress": "0xc00e94cb662c3520282e6f5717214004a7f26888",
        "goblinAddress": "0xcc11e2cf6755953eed483ba2b3c433647d0f18dc",
        "lpTokenAddress": "0xcffdded873554f362ac02f8fb1f02e5ada10516f",
        "lpStakingAddress": "0x373d22e4fcd14d06d03a89e048f8870f15fb1fd0",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/comp.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/CRV",
        "tokenAddress": "0xd533a949740bb3306d119cc777fa900ba034cd52",
        "goblinAddress": "0x18712bcb987785d6679134abc7cddee669ec35ca",
        "lpTokenAddress": "0x3da1313ae46132a397d90d95b1424a9a7e3e0fce",
        "lpStakingAddress": "0x4803e45218016ad186ed7edb5d289527f177beaa",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/crv.png"
      },
      {
        "exchange": "Uniswap",
        "name": "WETH/OCEAN",
        "tokenAddress": "0x967da4048cd07ab37855c090aaf366e4ce1b9f48",
        "goblinAddress": "0xee8f4e4b13c610bfa2c65d968ba1d5263d640ce6",
        "lpTokenAddress": "0x9b7dad79fc16106b47a3dab791f389c167e15eb0",
        "lpStakingAddress": "0x59aaa3466794cb40183ac96d2762ff74fd773a3f",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1],
        "logo": "/static/tokens/ocean.png"
      },
      {
        "exchange": "Sushi",
        "name": "WETH/SUSHI",
        "id": 12,
        "tokenAddress": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
        "goblinAddress": "0x3c2bbb353b48d54b619db8ac6aa642627fb800e3",
        "lpTokenAddress": "0x795065dcc9f64b5614c407a6efdc400da6221fb0",
        "lpStakingAddress": "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1, 1.5, 2],
        "logo": "/static/tokens/sushi.png"
      },
      {
        "exchange": "Pickle",
        "name": "WETH/PICKLE",
        "id": 0,
        "tokenAddress": "0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5",
        "goblinAddress": "0xa8854bd26ee44ad3c78792d68564b96ad0a45245",
        "lpTokenAddress": "0xdc98556Ce24f007A5eF6dC1CE96322d65832A819",
        "lpStakingAddress": "0xbD17B1ce622d73bD438b9E658acA5996dc394b0d",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1],
        "logo": "/static/tokens/pickle.png"
      },
      {
        "exchange": "mStable",
        "name": "WETH/MTA",
        "tokenAddress": "0xa3bed4e1c75d00fa6f4e5e6922db7261b5e9acd2",
        "goblinAddress": "0x4ec23befb01b9903d58c4bea096d65927e9462cc",
        "lpTokenAddress": "0x0d0d65e7a7db277d3e0f5e1676325e75f3340455",
        "lpStakingAddress": "0x9b4aba35b35eee7481775ccb4055ce4e176c9a6f",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": true,
        "leverages": [1],
        "logo": "/static/tokens/mta.png"
      },
      {
        "exchange": "Sushi",
        "name": "WETH/USDT",
        "id": 0,
        "tokenAddress": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "goblinAddress": "0xd902A3BEdEbaD8bEAD116E8596497cf7d9f45dA2",
        "lpTokenAddress": "0x06da0fd433c1a5d7a4faa01111c044910a184553",
        "lpStakingAddress": "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/usdt.png"
      },
      {
        "exchange": "Sushi",
        "name": "WETH/USDC",
        "id": 1,
        "tokenAddress": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "goblinAddress": "0xf134fDD0BBCE951e963D5BC5b0ffe445C9B6c5C6",
        "lpTokenAddress": "0x397ff1542f962076d0bfe58ea045ffa2d347aca0",
        "lpStakingAddress": "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/usdc.png"
      },
      {
        "exchange": "Sushi",
        "name": "WETH/DAI",
        "id": 2,
        "tokenAddress": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "goblinAddress": "0xd6419FD982a7651A12a757Ca7cD96b969D180330",
        "lpTokenAddress": "0xc3d03e4f041fd4cd388c549ee2a29a9e5075882f",
        "lpStakingAddress": "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/dai.png"
      },
      {
        "exchange": "Sushi",
        "name": "WETH/WBTC",
        "id": 21,
        "tokenAddress": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "goblinAddress": "0x54a2C35D689F4314FA70DD018eA0a84C74506925",
        "lpTokenAddress": "0xceff51756c56ceffca006cd410b03ffc46dd3a58",
        "lpStakingAddress": "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
        "leverages": [1, 1.5, 2, 2.5],
        "logo": "/static/tokens/wbtc.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/BAND",
        "id": 9,
        "tokenAddress": "0xba11d00c5f74255f56a5e366f4f77f5a186d7f55",
        "goblinAddress": "0xa7120893283cc2aba8155d6b9887bf228a8a86d2",
        "lpTokenAddress": "0xa75f7c2f025f470355515482bde9efa8153536a8",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "leverages": [1, 1.25, 1.5, 1.75],
        "logo": "/static/tokens/band.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/LINK",
        "id": 8,
        "tokenAddress": "0x514910771af9ca656af840dff83e8264ecf986ca",
        "goblinAddress": "0xcfbd9eeac76798571ed96ed60ca34df35f29ea8d",
        "lpTokenAddress": "0xc40d16476380e4037e6b1a2594caf6a6cc8da967",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "leverages": [1, 1.25, 1.75, 2],
        "logo": "/static/tokens/link.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/AAVE",
        "id": 37,
        "tokenAddress": "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
        "goblinAddress": "0xbb4755673e9df77f1af82f448d2b09f241752c05",
        "lpTokenAddress": "0xd75ea151a61d06868e31f8988d28dfe5e9df57b4",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "leverages": [1, 1.25, 1.75, 2],
        "logo": "/static/tokens/aave.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/COMP",
        "id": 4,
        "tokenAddress": "0xc00e94cb662c3520282e6f5717214004a7f26888",
        "goblinAddress": "0x35952c82e146da5251f2f822d7b679f34ffa71d3",
        "lpTokenAddress": "0x31503dcb60119a812fee820bb7042752019f2355",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "leverages": [1, 1.25, 1.75, 2],
        "logo": "/static/tokens/comp.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/SNX",
        "id": 6,
        "leverages": [1, 1.25, 1.5, 1.75],
        "tokenAddress": "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f",
        "goblinAddress": "0x8c5cecc9abd8503d167e6a7f2862874b6193e6e4",
        "lpTokenAddress": "0xa1d7b2d891e3a1f9ef4bbc5be20630c2feb1c470",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/snx.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/SUSD",
        "id": 3,
        "leverages": [1, 1.5, 2, 2.5],
        "tokenAddress": "0x57ab1ec28d129707052df4df418d58a2d46d5f51",
        "goblinAddress": "0x69fe7813f804a11e2fd279eba5dc1ecf6d6bf73b",
        "lpTokenAddress": "0xf1f85b2c54a2bd284b1cf4141d64fd171bd85539",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/susd.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/UMA",
        "id": 7,
        "leverages": [1, 1.5, 1.75],
        "tokenAddress": "0x04fa0d235c4abf4bcf4787af4cf447de572ef828",
        "goblinAddress": "0x8fc4c0566606aa0c715989928c12ce254f8e1228",
        "lpTokenAddress": "0x001b6450083e531a5a7bf310bd2c1af4247e23d4",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/uma.jpg"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/YAM",
        "id": 44,
        "leverages": [1],
        "tokenAddress": "0x0aacfbec6a24756c20d41914f2caba817c0d8521",
        "goblinAddress": "0x9d9c28f39696ce0ebc42ababd875977060e7afa1",
        "lpTokenAddress": "0x0f82e57804d0b1f6fab2370a43dcfad3c7cb239c",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/yam.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/CRV",
        "id": 17,
        "leverages": [1, 1.5, 1.75],
        "tokenAddress": "0xd533a949740bb3306d119cc777fa900ba034cd52",
        "goblinAddress": "0x5c767dbf81ec894b2d70f2aa9e45a54692d0d7eb",
        "lpTokenAddress": "0x58dc5a51fe44589beb22e8ce67720b5bc5378009",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/crv.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/REN",
        "id": 13,
        "leverages": [1, 1.5, 1.75],
        "tokenAddress": "0x408e41876cccdc0f92210600ef50372656052a38",
        "goblinAddress": "0x37ef9c13faa609d5eee21f84e4c6c7bf62e4002e",
        "lpTokenAddress": "0x611cde65dea90918c0078ac0400a72b0d25b9bb1",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/ren.png"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/YFI",
        "id": 11,
        "leverages": [1, 1.5, 1.75],
        "tokenAddress": "0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e",
        "goblinAddress": "0x6d0eb60d814a21e2bed483c71879777c9217aa28",
        "lpTokenAddress": "0x088ee5007c98a9677165d78dd2109ae4a3d04d0c",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd",
        "logo": "/static/tokens/yfi.png"
      },
      {
        "logo": "/static/tokens/grt.png",
        "exchange": "Uniswap",
        "name": "ETH/GRT",
        "leverages": [1],
        "tokenAddress": "0xc944e90c64b2c07662a292be6244bdf05cda44a7",
        "goblinAddress": "0xbd95cfef698d4d582e66110475ec7e4e21120e4a",
        "lpTokenAddress": "0x2e81ec0b8b4022fac83a21b2f2b4b8f5ed744d70",
        "lpStakingAddress": "0x003756fc5e1908fba1af693cba81bd8885b44888"
      },
      {
        "logo": "/static/tokens/kp3r.png",
        "exchange": "Sushi",
        "name": "ETH/KP3R",
        "id": 58,
        "leverages": [1],
        "tokenAddress": "0x1ceb5cb57c4d4e2b2433641b95dd330a33185a44",
        "goblinAddress": "0x795d3655d0d7ecbf26dd33b1a7676017bb0ee611",
        "lpTokenAddress": "0xaf988aff99d3d0cb870812c325c588d8d8cb7de8",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd"
      },
      {
        "exchange": "Sushi",
        "name": "ETH/BOR",
        "id": 70,
        "leverages": [1],
        "tokenAddress": "0x3c9d6c1c73b31c837832c72e04d3152f051fc1a9",
        "goblinAddress": "0x6a279df44b5717e89b51645e287c734bd3086c1f",
        "lpTokenAddress": "0x44d34985826578e5ba24ec78c93be968549bb918",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd"
      },
      {
        "logo": "/static/tokens/obtc.png",
        "exchange": "Sushi",
        "name": "ETH/oBTC",
        "id": 81,
        "leverages": [1],
        "tokenAddress": "0x8064d9ae6cdf087b1bcd5bdf3531bd5d8c537a68",
        "goblinAddress": "0x1001ec1b6fc2438e8be6ffa338d3380237c0399a",
        "lpTokenAddress": "0x53e9fb796b2feb4b3184afdf601c2a2797548d88",
        "lpStakingAddress": "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd"
      }
    ],
    "alphaPools": [
      {
        "exchange": "Uniswap",
        "name": "ibETH/ALPHA",
        "tokenAddress": "0xa1faa113cbe53436df28ff0aee54275c13b40975",
        "goblinAddress": "ALPHA_POOL",
        "lpTokenAddress": "0x411a9b902f364817a0f9c4261ce28b5566a42875",
        "hasTradingFeeAPY": true,
        "hasFarmingAPY": false,
        "leverages": [1],
        "logo": "/static/tokens/ibeth.png"
      }
    ],
    "exchanges": {
      "Uniswap": {
        "name": "Uniswap",
        "reward": {
          "tokenName": "UNI",
          "rewardPerPoolPerYear": "3.0416545e25",
          "rewardTokenAddress": "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
          "rewardEthLpTokenAddress": "0xd3d2E2692501A5c9Ca623199D38826e513033a17"
        }
      },
      "IndexCoop": {
        "name": "IndexCoop",
        "reward": {
          "tokenName": "INDEX",
          "rewardPerPoolPerYear": "9.125e23",
          "rewardTokenAddress": "0x0954906da0bf32d5479e25f46056d22f08464cab",
          "rewardEthLpTokenAddress": "0x3452a7f30a712e415a0674c0341d44ee9d9786f9"
        }
      },
      "Sushi": {
        "name": "Sushi",
        "reward": {
          "tokenName": "SUSHI",
          "rewardPerPoolPerYear": "0",
          "rewardTokenAddress": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
          "rewardEthLpTokenAddress": "0x795065dCc9f64b5614C407a6EFDC400DA6221FB0"
        }
      },
      "Pickle": {
        "name": "Pickle",
        "reward": {
          "tokenName": "PICKLE",
          "rewardPerPoolPerYear": "0",
          "rewardTokenAddress": "0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5",
          "rewardEthLpTokenAddress": "0xdc98556Ce24f007A5eF6dC1CE96322d65832A819"
        }
      },
      "mStable": {
        "name": "mStable",
        "reward": {
          "tokenName": "MTA",
          "rewardPerPoolPerYear": "1.2e24",
          "rewardTokenAddress": "0xa3bed4e1c75d00fa6f4e5e6922db7261b5e9acd2",
          "rewardEthLpTokenAddress": "0x0d0d65e7a7db277d3e0f5e1676325e75f3340455"
        }
      }
    }
  }
'''
'''--- projects/alpha-homora/v2.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");
const { request, gql } = require("graphql-request");
const { sumTokens, unwrapCreamTokens, unwrapUniswapLPs } = require('../helper/unwrapLPs')

const chainParams = {
    avax: {
        safeBoxApi: "https://homora-api.alphafinance.io/v2/43114/safeboxes",
        latestAlphaHomoraV2GraphUrl: `https://api.thegraph.com/subgraphs/name/alphafinancelab/alpha-homora-v2-avax`,
        poolsJsonUrl: "https://homora-api.alphafinance.io/v2/43114/pools",
        instances: [
            {
                wMasterChefAddress: "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
                wLiquidityGauge: "0xf1f32c8eeb06046d3cc3157b8f9f72b09d84ee5b", // wrong
                poolsJsonUrl: "https://homora-api.alphafinance.io/v2/43114/pools",
                graphUrl: `https://api.thegraph.com/subgraphs/name/alphafinancelab/alpha-homora-v2-avax`,
            },
        ]
    },
    fantom: {
        safeBoxApi: "https://homora-api.alphafinance.io/v2/250/safeboxes",
        latestAlphaHomoraV2GraphUrl: `https://api.thegraph.com/subgraphs/name/alphafinancelab/alpha-homora-v2-fantom`,
        poolsJsonUrl: "https://homora-api.alphafinance.io/v2/250/pools",        
        instances: [
            {
                wMasterChefAddress: "0x5FC20fCD1B50c5e1196ac790DADCfcDD416bb0C7",
                wLiquidityGauge: "0xf1f32c8eeb06046d3cc3157b8f9f72b09d84ee5b", // wrong
                poolsJsonUrl: "https://homora-api.alphafinance.io/v2/43114/pools",
                graphUrl: `https://api.thegraph.com/subgraphs/name/alphafinancelab/alpha-homora-v2-fantom`,
            },
        ]
    },
    ethereum: {
        safeBoxApi: "https://homora-api.alphafinance.io/v2/1/safeboxes",
        coreOracleAddress: "0x6be987c6d72e25f02f6f061f94417d83a6aa13fc",
        latestAlphaHomoraV2GraphUrl: `https://api.thegraph.com/subgraphs/name/hermioneeth/alpha-homora-v2-mainnet`,
        instances: [
            {
                // Current
                werc20Address: "0x06799a1e4792001aa9114f0012b9650ca28059a3",
                wMasterChefAddress: "0xa2caea05ff7b98f10ad5ddc837f15905f33feb60",
                wLiquidityGauge: "0xf1f32c8eeb06046d3cc3157b8f9f72b09d84ee5b",
                wStakingRewardIndex: "0x011535fd795fd28c749363e080662d62fbb456a7",
                wStakingRewardPerp: "0xc4635854480fff80f742645da0310e9e59795c63",
                poolsJsonUrl: "https://homora-api.alphafinance.io/v2/1/pools",
                graphUrl: `https://api.thegraph.com/subgraphs/name/hermioneeth/alpha-homora-v2-relaunch`,
            },
            {
                // Legacy
                werc20Address: "0xe28d9df7718b0b5ba69e01073fe82254a9ed2f98",
                wMasterChefAddress: "0x373ae78a14577682591e088f2e78ef1417612c68",
                wLiquidityGauge: "0xfdb4f97953150e47c8606758c13e70b5a789a7ec",
                wStakingRewardIndex: "0x713df2ddda9c7d7bda98a9f8fcd82c06c50fbd90",
                wStakingRewardPerp: "0xc4635854480fff80f742645da0310e9e59795c63",
                poolsJsonUrl:
                    "local",
                graphUrl: `https://api.thegraph.com/subgraphs/name/hermioneeth/alpha-homora-v2-mainnet`,
            }
        ]
    }
}

const GET_TOTAL_COLLATERALS = gql`
  query GET_TOTAL_COLLATERALS($block: Int) {
    werc20Collaterals(block: { number: $block }) {
      lpToken
      amount
    }
    sushiswapCollaterals(block: { number: $block }) {
      pid
      amount
    }
    crvCollaterals(block: { number: $block }) {
      pid
      gid
      amount
    }
    wstakingRewardCollaterals(block: { number: $block }) {
      wtoken
      amount
    }
  }
`;
const GET_CY_TOKEN = gql`
  query GET_CY_TOKEN($cyToken: String, $block: Int) {
    cyTokenStates(
      where: { cyToken: $cyToken }
      first: 1
      orderBy: blockTimestamp
      orderDirection: desc
      block: { number: $block }
    ) {
      id
      cyToken
      safeboxBalance
      exchangeRate
      blockTimestamp
    }
  }
`;

module.exports = {
    tvlV2,
    tvlV2Onchain
}

async function getPools(poolsJsonUrl){
    return poolsJsonUrl === "local"? require('./v2/legacy-pools.json') : (await axios.get(poolsJsonUrl)).data
}

async function tvlV2Onchain(block, chain) {
    const balances = {}
    const transform = addr => {
        if (addr.toLowerCase() === '0x260bbf5698121eb85e7a74f2e45e16ce762ebe11') 
          return 'avax:0xc7198437980c041c805a1edcba50c1ce5db95118' // Axelar wrapped UST -> USDT
        if (addr.toLowerCase() === '0x2147efff675e4a4ee1c2f918d181cdbd7a8e208f') 
        return '0xa1faa113cbe53436df28ff0aee54275c13b40975' // Wrapped Alpha Finance -> ALPHA (erc20)
      return  `${chain}:${addr}`
    }
    const { safeBoxApi, poolsJsonUrl } = chainParams[chain];
    const { data: safebox } = await axios.get(safeBoxApi);
    await unwrapCreamTokens(balances, safebox.map(s=>[s.cyTokenAddress, s.safeboxAddress]), block, chain, transform)
    let pools= await getPools(poolsJsonUrl);
    let poolsWithPid = pools.filter(p => p.pid !== undefined)
    let poolsWithoutPid = pools.filter(p => p.pid === undefined)
    const { output: masterchefLpTokens } = await sdk.api.abi.multiCall({
        calls: poolsWithPid.map((pool) => ({
            target: pool.exchange.stakingAddress ?? pool.stakingAddress,
            params: [pool.pid, pool.wTokenAddress],
        })),
        chain,
        abi: abi["userInfo"],
        block,
    });
    let lpPools = masterchefLpTokens.map((amount, i) => ({
        balance: amount.output.amount,
        token: poolsWithPid[i].lpTokenAddress
    }))
    const { output: stakingPoolsLpTokens } = await sdk.api.abi.multiCall({
        calls: poolsWithoutPid.map((pool) => ({
            target: pool.stakingAddress,
            params: [pool.wTokenAddress],
        })),
        chain,
        abi: "erc20:balanceOf",
        block,
    });
    stakingPoolsLpTokens.forEach((amount, i) => lpPools.push({
        balance: amount.output,
        token: poolsWithoutPid[i].lpTokenAddress
    }))
    const blacklisted = ['0xf3a602d30dcb723a74a0198313a7551feaca7dac', '0x2a8a315e82f85d1f0658c5d66a452bbdd9356783',].map(i => i.toLowerCase())
    lpPools = lpPools.filter(p => !blacklisted.includes(p.token.toLowerCase()))
    await unwrapUniswapLPs(balances, lpPools, block, chain, transform)

    return balances
}

async function tvlV2(block, chain) {
    const { safeBoxApi, coreOracleAddress, latestAlphaHomoraV2GraphUrl, instances } = chainParams[chain];
    const cyTokens = await getCyTokens(block, safeBoxApi, latestAlphaHomoraV2GraphUrl);
    const collateralGroups = await Promise.all(instances.map(params => getTotalCollateral(block, params)))

    const tokens = Array.from(
        new Set([
            ...collateralGroups.map(collaterals =>
                collaterals.map((collateral) => collateral.lpTokenAddress)
                    .filter((lpToken) => !!lpToken)).flat(),
            ...cyTokens.map((cy) => cy.token).filter((token) => !!token),
        ])
    );

    const tokenPrices = await getTokenPrices(tokens, block, chain, coreOracleAddress);

    const totalCollateralValue = BigNumber.sum(...collateralGroups.map(collaterals => sumCollaterals(collaterals, tokenPrices)))

    const totalCyValue = BigNumber.sum(
        0,
        ...cyTokens.map((cy) => {
            if (cy.token in tokenPrices) {
                return BigNumber(cy.amount).times(tokenPrices[cy.token]);
            }
            return BigNumber(0);
        })
    );

    return totalCollateralValue
        .plus(totalCyValue);
}

function sumCollaterals(collaterals, tokenPrices) {
    return BigNumber.sum(
        0, // Default value
        ...collaterals.map((collateral) => {
            if (collateral.lpTokenAddress in tokenPrices) {
                return BigNumber(collateral.amount).times(
                    tokenPrices[collateral.lpTokenAddress]
                );
            }
            return BigNumber(0);
        })
    );
}

async function getCyTokens(block, safeBoxApi, AlphaHomoraV2GraphUrl) {
    const { data: safebox } = await axios.get(
        safeBoxApi
    );
    return Promise.all(
        safebox.map(async (sb) => {
            const cyToken = sb.cyTokenAddress;
            const { cyTokenStates } = await request(
                AlphaHomoraV2GraphUrl,
                GET_CY_TOKEN,
                {
                    block,
                    cyToken,
                }
            );
            const cyTokenState = cyTokenStates[0];
            if (!cyTokenState) {
                return { amount: new BigNumber(0), token: null };
            }
            const exchangeRate = new BigNumber(cyTokenState.exchangeRate).div(1e18);
            const cyBalance = new BigNumber(cyTokenState.safeboxBalance);
            return { amount: cyBalance.times(exchangeRate), token: sb.address };
        })
    );
}

async function getTokenPrices(tokens, block, chain, coreOracleAddress) {
    const { output: _ethPrices } = await sdk.api.abi.multiCall({
        calls: tokens.map((token) => ({
            target: coreOracleAddress,
            params: [token],
        })),
        chain,
        abi: abi["getETHPx"],
        block,
    });

    const tokenPrices = {};
    for (let i = 0; i < _ethPrices.length; i++) {
        const price = BigNumber(_ethPrices[i].output).div(BigNumber(2).pow(112));
        if (price.gte(0)) {
            tokenPrices[tokens[i]] = price;
        }
    }
    return tokenPrices;
}

async function getTotalCollateral(
    block,
    {
        werc20Address,
        wMasterChefAddress,
        wLiquidityGauge,
        wStakingRewardIndex,
        wStakingRewardPerp,
        poolsJsonUrl,
        graphUrl,
    }
) {
    const pools = await getPools(poolsJsonUrl);

    const {
        crvCollaterals,
        sushiswapCollaterals,
        werc20Collaterals,
        wstakingRewardCollaterals,
    } = await request(graphUrl, GET_TOTAL_COLLATERALS, {
        block,
    });

    const collaterals = [
        ...crvCollaterals.map((coll) => {
            const pool = pools.find(
                (pool) =>
                    pool.wTokenAddress === wLiquidityGauge &&
                    Number(coll.pid) === pool.pid &&
                    Number(coll.gid) === pool.gid
            );
            if (!pool) {
                return {
                    lpTokenAddress: null,
                    amount: BigNumber(0),
                };
            }
            return {
                lpTokenAddress: pool.lpTokenAddress ? pool.lpTokenAddress : null,
                amount: BigNumber(coll.amount),
            };
        }),
        ...sushiswapCollaterals.map((coll) => {
            const pool = pools.find(
                (pool) =>
                    pool.wTokenAddress === wMasterChefAddress &&
                    Number(coll.pid) === pool.pid
            );
            if (!pool) {
                return {
                    lpTokenAddress: null,
                    amount: BigNumber(0),
                };
            }
            return {
                lpTokenAddress: pool.lpTokenAddress ? pool.lpTokenAddress : null,
                amount: BigNumber(coll.amount),
            };
        }),
        ...werc20Collaterals.map((coll) => ({
            lpTokenAddress:
                "0x" +
                BigNumber(coll.lpToken).toString(16).padStart(40, "0").toLowerCase(),
            amount: BigNumber(coll.amount),
        })),
        ...wstakingRewardCollaterals.map((coll) => {
            const pool = pools.find((pool) => pool.wTokenAddress === coll.wtoken);
            if (!pool) {
                return {
                    lpTokenAddress: null,
                    amount: BigNumber(0),
                };
            }
            return {
                lpTokenAddress: pool.lpTokenAddress ? pool.lpTokenAddress : null,
                amount: BigNumber(coll.amount),
            };
        }),
    ];

    return collaterals;
}

'''
'''--- projects/alpha-homora/v2/avax-pools.json ---
[
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "AVAX/USDT.e",
        "tokens": [
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
            "0xc7198437980c041c805a1edcba50c1ce5db95118"
        ],
        "lpTokenAddress": "0xed8cbd9f0ce3c6986b22002f03c6475ceb7a6256",
        "type": "Yield Farming",
        "color": "#4d9979",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 28,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-28"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "USDC.e/AVAX",
        "tokens": [
            "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        ],
        "lpTokenAddress": "0xa389f9430876455c36478deea9769b7ca4e3ddb1",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 39,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-39"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "WETH.e/AVAX",
        "tokens": [
            "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        ],
        "lpTokenAddress": "0xfe15c2695f1f920da45c30aae47d11de51007af9",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 26,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-26"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "AVAX/DAI.e",
        "tokens": [
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
            "0xd586e7f844cea2f87f50152665bcbc2c279d8d70"
        ],
        "lpTokenAddress": "0x87dee1cc9ffd464b79e058ba20387c1984aed86a",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 37,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-37"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "USDC.e/USDT.e",
        "tokens": [
            "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
            "0xc7198437980c041c805a1edcba50c1ce5db95118"
        ],
        "lpTokenAddress": "0x2e02539203256c83c7a9f6fa6f8608a32a2b1ca2",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 49,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-49"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "WBTC.e/AVAX",
        "tokens": [
            "0x50b7545627a5162f82a992c33b87adc75187b218",
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        ],
        "lpTokenAddress": "0xd5a37dc5c9a396a03dd1136fc76a1a02b1c88ffa",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 27,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-27"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "USDC.e/DAI.e",
        "tokens": [
            "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
            "0xd586e7f844cea2f87f50152665bcbc2c279d8d70"
        ],
        "lpTokenAddress": "0x63abe32d0ee76c05a11838722a63e012008416e6",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 40,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-40"
    },
    {
        "exchange": {
            "name": "Trader Joe",
            "spellAddress": "0xdbc2aa11aa01baa22892de745c661db9f204b2cd",
            "stakingAddress": "0xd6a4f121ca35509af06a0be99093d08462f53052",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "JOE",
                "rewardTokenAddress": "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"
            }
        },
        "name": "USDT.e/DAI.e",
        "tokens": [
            "0xc7198437980c041c805a1edcba50c1ce5db95118",
            "0xd586e7f844cea2f87f50152665bcbc2c279d8d70"
        ],
        "lpTokenAddress": "0xa6908c7e3be8f4cd2eb704b5cb73583ebf56ee62",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb",
        "wTokenType": "WMasterChef",
        "pid": 31,
        "key": "wchef-0xb41de9c1f50697cc3fd63f24ede2b40f6269cbcb-31"
    },
    {
        "exchange": {
            "name": "Pangolin",
            "spellAddress": "0x7723993c1baa141f5decfc8bf5dbad47aaddec86",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "PNG",
                "rewardTokenAddress": "0x60781c2586d68229fde47564546784ab3faca982"
            }
        },
        "name": "AVAX/USDT.e",
        "tokens": [
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
            "0xc7198437980c041c805a1edcba50c1ce5db95118"
        ],
        "lpTokenAddress": "0xe28984e1ee8d431346d32bec9ec800efb643eef4",
        "type": "Yield Farming",
        "color": "#4d9979",
        "wTokenAddress": "0x0b8f60be035cc5b1982ed2145c6bfc05f863ddc1",
        "wTokenType": "WStakingRewards",
        "stakingAddress": "0x006cc053bdb84c2d6380b3c4a573d84636378a47",
        "key": "wstaking-0x0b8f60be035cc5b1982ed2145c6bfc05f863ddc1"
    },
    {
        "exchange": {
            "name": "Pangolin",
            "spellAddress": "0x7723993c1baa141f5decfc8bf5dbad47aaddec86",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "PNG",
                "rewardTokenAddress": "0x60781c2586d68229fde47564546784ab3faca982"
            }
        },
        "name": "USDC.e/AVAX",
        "tokens": [
            "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        ],
        "lpTokenAddress": "0xbd918ed441767fe7924e99f6a0e0b568ac1970d9",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xc681cad10f227ef506a352b3dc5ff6c676b8636f",
        "wTokenType": "WStakingRewards",
        "stakingAddress": "0x84b536da1a2d9b0609f9da73139674cc2d75af2d",
        "key": "wstaking-0xc681cad10f227ef506a352b3dc5ff6c676b8636f"
    },
    {
        "exchange": {
            "name": "Pangolin",
            "spellAddress": "0x7723993c1baa141f5decfc8bf5dbad47aaddec86",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "PNG",
                "rewardTokenAddress": "0x60781c2586d68229fde47564546784ab3faca982"
            }
        },
        "name": "WETH.e/AVAX",
        "tokens": [
            "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        ],
        "lpTokenAddress": "0x7c05d54fc5cb6e4ad87c6f5db3b807c94bb89c52",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0xfcd7ebc3a42d65fe77988171999cfbb7c4a85523",
        "wTokenType": "WStakingRewards",
        "stakingAddress": "0x830a966b9b447c9b15ab24c0369c4018e75f31c9",
        "key": "wstaking-0xfcd7ebc3a42d65fe77988171999cfbb7c4a85523"
    },
    {
        "exchange": {
            "name": "Pangolin",
            "spellAddress": "0x7723993c1baa141f5decfc8bf5dbad47aaddec86",
            "logo": "/static/tokens/uni.png",
            "reward": {
                "tokenName": "PNG",
                "rewardTokenAddress": "0x60781c2586d68229fde47564546784ab3faca982"
            }
        },
        "name": "AVAX/DAI.e",
        "tokens": [
            "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
            "0xd586e7f844cea2f87f50152665bcbc2c279d8d70"
        ],
        "lpTokenAddress": "0xba09679ab223c6bdaf44d45ba2d7279959289ab0",
        "type": "Yield Farming",
        "color": "#3a71be",
        "wTokenAddress": "0x7f7c811c889108c89f539a21d150b5d5fc616545",
        "wTokenType": "WStakingRewards",
        "stakingAddress": "0x63a84f66b8c90841cb930f2dc3d28799f0c6657b",
        "key": "wstaking-0x7f7c811c889108c89f539a21d150b5d5fc616545"
    }
]
'''
'''--- projects/alpha-homora/v2/avax-safeboxes.json ---
[
    {
        "address": "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
        "safeboxAddress": "0x21c630b7824d15bcdfeefa73cbd4e49cafe9f836",
        "cyTokenAddress": "0xb3c68d69e95b095ab4b33b4cb67dbc0fbf3edf56"
    },
    {
        "address": "0xc7198437980c041c805a1edcba50c1ce5db95118",
        "safeboxAddress": "0x858d6353a52c25c53df1869230282d22b41f5790",
        "cyTokenAddress": "0xceb1ce674f38398432d20bc8f90345e91ef46fd3"
    },
    {
        "address": "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
        "safeboxAddress": "0xd3843b60e69f958ef93bec299467e6ed301cbeeb",
        "cyTokenAddress": "0xe28965073c49a02923882b8329d3e8c1d805e832"
    },
    {
        "address": "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
        "safeboxAddress": "0xf9eb24b83b51fbc0bcb1204221c8c9f1cef33994",
        "cyTokenAddress": "0x338eee1f7b89ce6272f302bdc4b952c13b221f1d"
    },
    {
        "address": "0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
        "safeboxAddress": "0x69491fd9a6d9e32f32113cc076b1b69d8b9ebd3f",
        "cyTokenAddress": "0x085682716f61a72bf8c573fbaf88cca68c60e99b"
    },
    {
        "address": "0x50b7545627a5162f82a992c33b87adc75187b218",
        "safeboxAddress": "0x1de90c0ce3d940412c3ba7322a257f7bdcc00ceb",
        "cyTokenAddress": "0xb09b75916c5f4097c8b5812e63e216fef97661fc"
    }
]
'''
'''--- projects/alpha-homora/v2/legacy-pools.json ---
[
    {
      "exchange": "Uniswap",
      "name": "UNI/ETH",
      "tokens": [
        "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
      ],
      "lpTokenAddress": "0xd3d2e2692501a5c9ca623199d38826e513033a17",
      "type": "Liquidity Providing",
      "color": "#f9eaf4",
      "wTokenAddress": "0xe28d9df7718b0b5ba69e01073fe82254a9ed2f98"
    },
    {
      "exchange": "Sushiswap",
      "name": "SUSHI/ETH",
      "tokens": [
        "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
      ],
      "lpTokenAddress": "0x795065dcc9f64b5614c407a6efdc400da6221fb0",
      "type": "Yield Farming",
      "color": "#e75aa5",
      "wTokenAddress": "0x373ae78a14577682591e088f2e78ef1417612c68",
      "pid": 12,
      "rewardSymbol": "SUSHI",
      "rewardAddress": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2"
    },
    {
      "key": "wstaking-0xc4635854480fff80f742645da0310e9e59795c63",
      "exchange": "Balancer",
      "name": "PERP/USDC (80-20)",
      "tokens": [
        "0xbc396689893d065f41bc2c6ecbee5e0085233447",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
      ],
      "lpTokenAddress": "0xf54025af2dc86809be1153c1f20d77adb7e8ecf4",
      "type": "Yield Farming",
      "color": "#195D72",
      "wTokenAddress": "0xc4635854480fff80f742645da0310e9e59795c63",
      "rewardSymbol": "PERP",
      "rewardAddress": "0xbc396689893d065f41bc2c6ecbee5e0085233447",
      "isPoolAvailableV1": false,
      "isFarmingDisabled": true
    },
    {
      "exchange": "Curve",
      "name": "3pool",
      "logo": "/static/tokens/3crv.png",
      "tokens": [
        "0x6b175474e89094c44da98b954eedeac495271d0f",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "0xdac17f958d2ee523a2206206994597c13d831ec7"
      ],
      "lpTokenAddress": "0x6c3f90f043a72fa612cbac8115ee7e52bde6e490",
      "poolAddress": "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7",
      "type": "Yield Farming",
      "color": "#cd5d7d",
      "wTokenAddress": "0xfdb4f97953150e47c8606758c13e70b5a789a7ec",
      "pid": 0,
      "gid": 0,
      "poolContractAbi": [
        {
          "name": "TokenExchange",
          "inputs": [
            {
              "type": "address",
              "name": "buyer",
              "indexed": true
            },
            {
              "type": "int128",
              "name": "sold_id",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "tokens_sold",
              "indexed": false
            },
            {
              "type": "int128",
              "name": "bought_id",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "tokens_bought",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddLiquidity",
          "inputs": [
            {
              "type": "address",
              "name": "provider",
              "indexed": true
            },
            {
              "type": "uint256[3]",
              "name": "token_amounts",
              "indexed": false
            },
            {
              "type": "uint256[3]",
              "name": "fees",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "invariant",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "token_supply",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RemoveLiquidity",
          "inputs": [
            {
              "type": "address",
              "name": "provider",
              "indexed": true
            },
            {
              "type": "uint256[3]",
              "name": "token_amounts",
              "indexed": false
            },
            {
              "type": "uint256[3]",
              "name": "fees",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "token_supply",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RemoveLiquidityOne",
          "inputs": [
            {
              "type": "address",
              "name": "provider",
              "indexed": true
            },
            {
              "type": "uint256",
              "name": "token_amount",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "coin_amount",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RemoveLiquidityImbalance",
          "inputs": [
            {
              "type": "address",
              "name": "provider",
              "indexed": true
            },
            {
              "type": "uint256[3]",
              "name": "token_amounts",
              "indexed": false
            },
            {
              "type": "uint256[3]",
              "name": "fees",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "invariant",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "token_supply",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CommitNewAdmin",
          "inputs": [
            {
              "type": "uint256",
              "name": "deadline",
              "indexed": true
            },
            {
              "type": "address",
              "name": "admin",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAdmin",
          "inputs": [
            {
              "type": "address",
              "name": "admin",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CommitNewFee",
          "inputs": [
            {
              "type": "uint256",
              "name": "deadline",
              "indexed": true
            },
            {
              "type": "uint256",
              "name": "fee",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "admin_fee",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewFee",
          "inputs": [
            {
              "type": "uint256",
              "name": "fee",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "admin_fee",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RampA",
          "inputs": [
            {
              "type": "uint256",
              "name": "old_A",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "new_A",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "initial_time",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "future_time",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StopRampA",
          "inputs": [
            {
              "type": "uint256",
              "name": "A",
              "indexed": false
            },
            {
              "type": "uint256",
              "name": "t",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "outputs": [],
          "inputs": [
            {
              "type": "address",
              "name": "_owner"
            },
            {
              "type": "address[3]",
              "name": "_coins"
            },
            {
              "type": "address",
              "name": "_pool_token"
            },
            {
              "type": "uint256",
              "name": "_A"
            },
            {
              "type": "uint256",
              "name": "_fee"
            },
            {
              "type": "uint256",
              "name": "_admin_fee"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "name": "A",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 5227
        },
        {
          "name": "get_virtual_price",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 1133537
        },
        {
          "name": "calc_token_amount",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "uint256[3]",
              "name": "amounts"
            },
            {
              "type": "bool",
              "name": "deposit"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 4508776
        },
        {
          "name": "add_liquidity",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256[3]",
              "name": "amounts"
            },
            {
              "type": "uint256",
              "name": "min_mint_amount"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 6954858
        },
        {
          "name": "get_dy",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "int128",
              "name": "i"
            },
            {
              "type": "int128",
              "name": "j"
            },
            {
              "type": "uint256",
              "name": "dx"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 2673791
        },
        {
          "name": "get_dy_underlying",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "int128",
              "name": "i"
            },
            {
              "type": "int128",
              "name": "j"
            },
            {
              "type": "uint256",
              "name": "dx"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 2673474
        },
        {
          "name": "exchange",
          "outputs": [],
          "inputs": [
            {
              "type": "int128",
              "name": "i"
            },
            {
              "type": "int128",
              "name": "j"
            },
            {
              "type": "uint256",
              "name": "dx"
            },
            {
              "type": "uint256",
              "name": "min_dy"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 2818066
        },
        {
          "name": "remove_liquidity",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256",
              "name": "_amount"
            },
            {
              "type": "uint256[3]",
              "name": "min_amounts"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 192846
        },
        {
          "name": "remove_liquidity_imbalance",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256[3]",
              "name": "amounts"
            },
            {
              "type": "uint256",
              "name": "max_burn_amount"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 6951851
        },
        {
          "name": "calc_withdraw_one_coin",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "uint256",
              "name": "_token_amount"
            },
            {
              "type": "int128",
              "name": "i"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 1102
        },
        {
          "name": "remove_liquidity_one_coin",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256",
              "name": "_token_amount"
            },
            {
              "type": "int128",
              "name": "i"
            },
            {
              "type": "uint256",
              "name": "min_amount"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 4025523
        },
        {
          "name": "ramp_A",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256",
              "name": "_future_A"
            },
            {
              "type": "uint256",
              "name": "_future_time"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 151919
        },
        {
          "name": "stop_ramp_A",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 148637
        },
        {
          "name": "commit_new_fee",
          "outputs": [],
          "inputs": [
            {
              "type": "uint256",
              "name": "new_fee"
            },
            {
              "type": "uint256",
              "name": "new_admin_fee"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 110461
        },
        {
          "name": "apply_new_fee",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 97242
        },
        {
          "name": "revert_new_parameters",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 21895
        },
        {
          "name": "commit_transfer_ownership",
          "outputs": [],
          "inputs": [
            {
              "type": "address",
              "name": "_owner"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 74572
        },
        {
          "name": "apply_transfer_ownership",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 60710
        },
        {
          "name": "revert_transfer_ownership",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 21985
        },
        {
          "name": "admin_balances",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "uint256",
              "name": "i"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 3481
        },
        {
          "name": "withdraw_admin_fees",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 21502
        },
        {
          "name": "donate_admin_fees",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 111389
        },
        {
          "name": "kill_me",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 37998
        },
        {
          "name": "unkill_me",
          "outputs": [],
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "gas": 22135
        },
        {
          "name": "coins",
          "outputs": [
            {
              "type": "address",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "uint256",
              "name": "arg0"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 2220
        },
        {
          "name": "balances",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [
            {
              "type": "uint256",
              "name": "arg0"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "gas": 2250
        },
        {
          "name": "fee",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2171
        },
        {
          "name": "admin_fee",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2201
        },
        {
          "name": "owner",
          "outputs": [
            {
              "type": "address",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2231
        },
        {
          "name": "initial_A",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2261
        },
        {
          "name": "future_A",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2291
        },
        {
          "name": "initial_A_time",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2321
        },
        {
          "name": "future_A_time",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2351
        },
        {
          "name": "admin_actions_deadline",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2381
        },
        {
          "name": "transfer_ownership_deadline",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2411
        },
        {
          "name": "future_fee",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2441
        },
        {
          "name": "future_admin_fee",
          "outputs": [
            {
              "type": "uint256",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2471
        },
        {
          "name": "future_owner",
          "outputs": [
            {
              "type": "address",
              "name": ""
            }
          ],
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "gas": 2501
        }
      ],
      "curveGaugeAddress": "0xbfcf63294ad7105dea65aa58f8ae5be2d9d0952a",
      "curveGaugeControllerAddress": "0x2f50d538606fa9edd2b11e2446beb18c9d5846bb",
      "curveRawStatsApiUrl": "https://stats.curve.fi/raw-stats/3pool-1440m.json",
      "isPoolAvailableV1": false
    }
  ]
'''
'''--- projects/alphadex.js ---
const { calculateUsdUniTvl } = require("./helper/getUsdUniTvl");
module.exports = {
    methodology: `Uses factory(0xdD9EFCbDf9f422e2fc159eFe77aDD3730d48056d) address and whitelisted tokens address to find and price Liquidity Pool pairs`,
    misrepresentedTokens: true,
    doublecounted: false,
    timetravel: true,
    incentivized: true,
    moonriver: {
        tvl: calculateUsdUniTvl(
            "0xdD9EFCbDf9f422e2fc159eFe77aDD3730d48056d",
            "moonriver",
            "0x98878b06940ae243284ca214f92bb71a2b032b8a",
            [
                "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d",
                "0x1a93b23281cc1cde4c4741353f3064709a16197d"
            ],
            "moonriver"
        ),
    }
};
'''
'''--- projects/amaterasu.js ---
const { calculateUsdUniTvl } = require("./helper/getUsdUniTvl");
module.exports = {
    methodology: `Uses factory(0x34696b6cE48051048f07f4cAfa39e3381242c3eD) address and whitelisted tokens address to find and price Liquidity Pool pairs`,
    misrepresentedTokens: true,
    doublecounted: false,
    timetravel: true,
    incentivized: true,
    aurora: {
        tvl: calculateUsdUniTvl(
            "0x34696b6cE48051048f07f4cAfa39e3381242c3eD",
            "aurora",
            "0xC9BdeEd33CD01541e1eeD10f90519d2C06Fe3feB", 
            [
                //USDC
                "0xB12BFcA5A55806AaF64E99521918A4bf0fC40802",
                //USDT
                "0x4988a896b1227218e4A686fdE5EabdcAbd91571f",
                //wNEAR
                "0xC42C30aC6Cc15faC9bD938618BcaA1a1FaE8501d"
            ], 
            "weth", 
        ),
    }
}; // node test.js projects/amaterasu.js
'''
'''--- projects/ambire-wallet/index.js ---
const { staking } = require('../helper/staking')
const sdk = require('@defillama/sdk')

const WALLET = '0x88800092ff476844f74dc2fc427974bbee2794ae'
const WALLET_staking = '0x47cd7e91c3cbaaf266369fe8518345fc4fc12935'
const ADX = '0xADE00C28244d5CE17D72E40330B1c318cD12B7c3'
const ADX_staking = '0xB6456b57f03352bE48Bf101B46c1752a0813491a'

module.exports = {
  methodology: `TVL for Ambire Wallet consists of the staking of WALLET.`, 
  ethereum:{
    tvl: () => ({}),
    staking: sdk.util.sumChainTvls([
      staking(WALLET_staking, WALLET, 'ethereum'), 
      staking(ADX_staking, ADX, 'ethereum')
    ]), 
  }
}
'''
'''--- projects/amesdefi/index.js ---
const { tombTvl } = require('../helper/tomb');

const ames = "0xb9E05B4C168B56F73940980aE6EF366354357009";
const share = "0xFa4b16b0f63F5A6D0651592620D585D308F749A4";
const boardroom = "0xC183b26Ad8C660AFa7B388067Fd18c1Fb28f1bB4";
const rewardPool = "0x1da194F8baf85175519D92322a06b46A2638A530";
const pool2lps = [
    "0x81722a6457e1825050B999548a35E30d9f11dB5c",
    "0x91da56569559b0629f076dE73C05696e34Ee05c1",
];

module.exports = {
    ...tombTvl(ames, share, rewardPool, boardroom, pool2lps, "bsc", undefined, false, pool2lps[1])
};
'''
'''--- projects/amogus-dao/index.js ---
const { ohmTvl } = require("../helper/ohm")

/*

























*/

const sus = "0x43f673dEDE1A30399E7b9b600AD78193dB00D895";
const amogusStaking = "0xc387d28A373c7683132bebaf8683F70fc6b52Aa5";
const treasury = "0xD8635772d8Fd5fc448f025Ed500e1674F67C91c7";
const treasuryTokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
    ["0x96a89c2bec139d518533251229ee3853fdb89430", true], // SUS-MIM JLP
]

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "avax", amogusStaking, sus, undefined, undefined, false)
}
'''
'''--- projects/ampere/index.js ---
const { tombTvl } = require("../helper/tomb");
const FUSE_ON_ETH = "0x970b9bb2c0444f5e81e9d0efb84c8ccdcdcaf84d";
const FUSE_ON_FUSE = "0x0be9e53fd7edac9f859882afdda116645287c629";
const AMP = "0x2b09179D26FdDB27a24ee25328890791c7A984c2".toLowerCase();
const CURRENT = "0x3B1292FEf70C3F9Fb933DD2e2F4B734DcB35648d".toLowerCase();

const fuseLPs = [
  "0x48515f859e44161bf67ae610a7c83f53b0048713",
  "0xaa33219a463635097fa8d603e5436ad08dd948fc",
];

const rewardPool = "0x8Cdc3584B455b49634b9272247AD2AccEef58c98".toLowerCase();
const masonry = "0x335C392DB4F0AD43f782B0646959E41FC1134350".toLowerCase();
const genesisBlock = 1650700800;

const transform = (addr) => {
  if (addr.toLowerCase() === FUSE_ON_FUSE.toLowerCase()) return FUSE_ON_ETH;
  return "fuse:" + addr;
};

module.exports = {
  methodology: "Pool2 deposits consist of AMP/FUSE and CURRENT/FUSE LP tokens deposits while the staking TVL consists of the CURRENT tokens locked within the Masonry contract, priced using Fuse on Ethereum mainnet.",
  start: genesisBlock,
  ...tombTvl(
    AMP,
    CURRENT,
    rewardPool,
    masonry,
    fuseLPs,
    "fuse",
    transform,
    false,
    fuseLPs[1]
  ),
};

'''
'''--- projects/amun/abi.json ---
{
    "getTokens": {
        "name": "getTokens",
        "type": "function",
        "inputs": [
          
        ],
        "outputs": [
          {
            "name": "",
            "type": "address[]",
            "internalType": "address[]"
          }
        ],
        "stateMutability": "view"
      }
}
'''
'''--- projects/amun/index.js ---
const BigNumber = require('bignumber.js');
const sdk = require('@defillama/sdk');
const axios = require('axios');
const abi = require('./abi.json');
const solana = require('../helper/solana');

const PECO_ADDRESS = '0xA9536B9c75A9E0faE3B56a96AC8EdF76AbC91978';
const DFI_ADDRESS = '0xA9536B9c75A9E0faE3B56a96AC8EdF76AbC91978';
const SOLI_ADDRESS = '8JnNWJ46yfdq8sKgT1Lk4G7VWkAA8Rhh7LhqgJ6WY41G';
const SOLI_COINGECKO_ID = 'solana-ecosystem-index';

function fetchSolanaTvl(tokens) {
  return async () => {
    const balances = {};
    for (const token of tokens) {
      const tokenSupply = await solana.getTokenSupply(token.address);
      balances[token.coingeckoID] = tokenSupply;
    }

    return balances;
  };
}

function chainTvl(chain, tokens) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const block = chainBlocks[chain];
    const balances = {};
    for (const address of tokens) {
      const underlyings = await sdk.api.abi.call({
        block,
        target: address,
        abi: abi.getTokens,
        chain,
      });
      for (const token of underlyings.output) {
        const held = await sdk.api.erc20.balanceOf({
          block,
          target: token,
          owner: address,
          chain,
        });

        sdk.util.sumSingleBalance(balances, `${chain}:${token}`, held.output);
      }
    }

    return balances;
  };
}

module.exports = {
  timetravel: false,
  ethereum: {
    tvl: chainTvl('ethereum', [DFI_ADDRESS]),
  },
  polygon: {
    tvl: chainTvl('polygon', [PECO_ADDRESS]),
  },
  solana: {
    tvl: fetchSolanaTvl([{
      address: SOLI_ADDRESS,
      coingeckoID: SOLI_COINGECKO_ID,
    }]),
  },
  methodology: `Amun Tokens has three investment strategies available, which are the Defi Token Index(DFI), the Polygon Ecosystem Index (PECO) and Solana Ecosystem Index (SOLI). Each strategy has its own address where the underlying tokens are held. To get the TVL for the DFI and PECO, first of all, an on-chain call is made using the function 'tvl()', which first retrieves each token that is held within the strategy addresses and then calls 'balanceOf()' to get the balances of these tokens which are added and used as TVL. For SOLI, getTokenSupply helper method is called to get the total supply of the token, and then multiplied at the current market rate of the token, retrieved from our API endpoint.`,
};

'''
'''--- projects/amyfinance/index.js ---
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs');
const { transformArbitrumAddress } = require('../helper/portedTokens');
const { getBlock } = require('../helper/getBlock');

const tokens = [
    ["0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8", false], //USDC
    ["0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9", false], //USDT
    ["0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", false], //DAI
    ["0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f", false], //WBTC
    ["0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", false], //WETH
    ["0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0", false], //UNI
    ["0xf97f4df75117a78c1A5a0DBb814Af92458539FB4", false], //LINK
    ["0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A", false], //MIM
    ["0xd4d42F0b6DEF4CE0383636770eF773390d85c61A", false], //SUSHI
];
const aibContracts = [
    "0xe76a422C30B09f8d20ad5d8A9D21206835F6c692", //aibUSDC
    "0xE3575B6226a7965f5289C2C6eF2f9C89b6d70941", //aibUSDT
    "0xa6F7A3e16fFC0fE08C43e72C5BB5E15d98c79a05", //aibDAI
    "0x2b3554d6810FA2CEc563b0bC731AbAC60A717f3B", //aibWBTC
    "0x8C1b5FE3A884118569707d07049fbc56A8314CcE", //aibWETH
    "0xE85B64dDA773CB18E0F2a2211Da60DaA536C0284", //aibUNI
    "0x9Dd192fca6A1E7c8a3C014a35087dE3fb9Da14E5", //aibLINK
    "0x381F8482ee0a12202F2A3735370859f5709B12d2", //aibMIM
    "0x52444Aa321dfD7b24aA263Af6F7DCC26565f3629", //aibSUSHI
];

async function tvl(timestamp, ethBlock, chainBlocks) {
    const block = await getBlock(timestamp, "arbitrum", chainBlocks);
    let balances = {};
    const transformAdress = await transformArbitrumAddress();

    await sumTokensAndLPsSharedOwners(balances, tokens, aibContracts, 
        block, "arbitrum", transformAdress);
    return balances;
}

module.exports = {
    tvl,
}

'''
'''--- projects/anchor/index.js ---
const { request, gql } = require("graphql-request");
const { fetchURL } = require("../helper/utils");
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");
const { toUSDTBalances } = require('../helper/balances');

const graphUrl = 'https://mantle.terra.dev/'
const query = gql`
query __bAssetMarket($bAssetTokenBalanceQuery: String!, $bEthTokenBalanceQuery: String!) {
  ubLunaBalance: WasmContractsContractAddressStore(
    ContractAddress: "terra1kc87mu460fwkqte29rquh4hc20m54fxwtsx7gp"
    QueryMsg: $bAssetTokenBalanceQuery
  ) {
    Result
    __typename
  },
  ubEthBalance: WasmContractsContractAddressStore(
    ContractAddress: "terra1dzhzukyezv0etz22ud940z7adyv7xgcjkahuun"
    QueryMsg: $bEthTokenBalanceQuery
  ) {
    Result
    __typename
  },
  balances: BankBalancesAddress(Address: "terra1sepfj7s0aeg5967uxnfk4thzlerrsktkpelm5s") {
    Result {
      Denom
      Amount
      __typename
    }
    __typename
  }
}
`

async function tvl(timestamp, block) {
  const result = await request(graphUrl, query, {
    "bAssetTokenBalanceQuery": '{"balance":{"address":"terra1ptjp2vfjrwh0j0faj9r6katm640kgjxnwwq9kn"}}',
    "bEthTokenBalanceQuery": '{"balance":{"address":"terra10cxuzggyvvv44magvrh3thpdnk9cmlgk93gmx2"}}'
  })
  const ust = Number(result.balances.Result[0].Amount) / 1e6;
  const luna = Number(JSON.parse(result.ubLunaBalance.Result).balance) / 1e6
  const beth = Number(JSON.parse(result.ubEthBalance.Result).balance) / 1e6
  return {
    "staked-ether": beth,
    "terra-luna": luna,
    "terrausd": ust
  }
}

async function borrowed() {
  const data = await fetchURL("https://api.anchorprotocol.com/api/v1/borrow")
  return {
    "terrausd": Number(data.data.total_borrowed) / 1e6
  }
}

async function avalancheTVL(timestamp, ethBlock, chainBlocks) {
  const chain = "avax"
  const wormholeAnchorUST = "0xaB9A04808167C170A9EC4f8a87a0cD781ebcd55e"
  const block = chainBlocks[chain]
  const { output: aUSTBalance } = await sdk.api.erc20.totalSupply({ target: wormholeAnchorUST, block, chain })
  return {
    "anchorust": BigNumber(aUSTBalance).dividedBy(10 ** 6)
  }
}

module.exports = {
  timetravel: false,
  methodology: `We use the Anchor subgraph to get the amount of bLUNA and bETH used as collateral on anchor and the UST that is on anchor but has not been lent, we then use Coingecko to price the tokens in USD.`,
  terra: {
      tvl,
      borrowed
  },
  avalanche: {
    tvl: avalancheTVL
  }
}
'''
'''--- projects/anchorswap/index.js ---
const sdk = require("@defillama/sdk");
const { addFundsInMasterChef } = require("../helper/masterchef.js");
const abi = require("../helper/abis/masterchef.json");

const anchorToken = "0x4aac18De824eC1b553dbf342829834E4FF3F7a9F";
const masterchef = "0x23f7F3119d1b5b6c94a232680e2925703C4ebbF5";

async function tvl(timestamp, chain, chainBlocks) {
    let balances = {};

    await addFundsInMasterChef(balances, masterchef, chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`, abi.poolInfo, [anchorToken], true);

    return balances;
}

async function staking(timestamp, chain, chainBlocks) {
    let balances = {};

    let { output: balance } = await sdk.api.erc20.balanceOf({
        target: anchorToken,
        owner: masterchef,
        block: chainBlocks.bsc,
        chain: "bsc"
    });

    sdk.util.sumSingleBalance(balances, `bsc:${anchorToken}`, balance);

    return balances;
}

module.exports = {
    methodology: `Uses the masterchef addresss() to find the tokens locked within, excludes the $ANCHOR token which is separated and added under the "staking" label`,
    bsc: {
        tvl,
        staking
    },
    
}

'''
'''--- projects/anedak/index.js ---
const retry = require("async-retry");
const { fetchLocal, mkMeta } = require("../helper/pact");

const chainId = "3";
const network = `https://api.chainweb.com/chainweb/0.0/mainnet01/chain/${chainId}/pact`;
const GAS_PRICE = 0.00000001;
const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const getReserve = (tokenData) => {
  return parseFloat(tokenData.decimal ? tokenData.decimal : tokenData);
};

const pairTokens = {
  "coin:free.anedak": {
    name: "coin:free.anedak",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "ADK",
      code: "free.anedak",
    },
  },
  "coin:free.babena": {
    name: "coin:free.babena",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "BABE",
      code: "free.babena",
    },
  },
  "coin:runonflux.flux": {
    name: "coin:runonflux.flux",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "FLUX",
      code: "runonflux.flux",
    },
  },
  "coin:kdlaunch.token": {
    name: "coin:kdlaunch.token",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "KDL",
      code: "kdlaunch.token",
    },
  },
};

const getPairList = async () => {
  const pairList = await Promise.all(
    Object.values(pairTokens).map(async (pair) => {
      let data = await fetchLocal(
        {
          pactCode: `
            (use free.exchange)
            (let*
              (
                (p (get-pair ${pair.token0.code} ${pair.token1.code}))
                (reserveA (reserve-for p ${pair.token0.code}))
                (reserveB (reserve-for p ${pair.token1.code}))
                (totalBal (free.tokens.total-supply (free.exchange.get-pair-key ${pair.token0.code} ${pair.token1.code})))
              )[totalBal reserveA reserveB])
             `,
          meta: mkMeta("", chainId, GAS_PRICE, 3000, creationTime(), 600),
        },
        network
      );

      if (data.result.status === "success") {
        return {
          reserves: [
            getReserve(data.result.data[1]),
            getReserve(data.result.data[2]),
          ],
        };
      }

      throw new Error("Pair reserves fetch failed");
    })
  );
  return pairList;
};

async function fetch() {
  const pairList = await retry(async (bail) => getPairList());
  const anedakPairKdaAmount = pairList[0].reserves[0];
  const babenaPairKdaAmount = pairList[1].reserves[0];
  const fluxPairKdaAmount = pairList[2].reserves[0];
  const kdlPairKdaAmount = pairList[3].reserves[0];

  /*
   * value of each pool taken to be twice the value of its KDA
   * since the only more liquid DEX on Kadena is Kaddex, which only has KDA/FLUX pair
   */
  const tvl =
    2 *
    (anedakPairKdaAmount +
      babenaPairKdaAmount +
      fluxPairKdaAmount +
      kdlPairKdaAmount);

  return {
    kadena: tvl
  };
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  methodology: "TVL accounts for the liquidity on all Anedak AMM pools, with all values calculated in terms of KDA price.",
  kadena: {
    tvl: fetch,
  },
};

'''
'''--- projects/angel-protocol/index.js ---

const { fetchURL } = require('../helper/utils')
const BigNumber = require('bignumber.js');

async function tvl() {
  const res = await fetchURL(`https://fcd.terra.dev/wasm/contracts/terra172ue5d0zm7jlsj2d9af4vdff6wua7mnv6dq5vp/store?query_msg=%7B%22token_info%22:%7B%22sid%22:0%7D%7D`)
  return {
    'anchorust': BigNumber(res.data.result.total_supply) / 1e6,
  }
}

module.exports = {
  timetravel: false,
  methodology: 'TVL takes total apANC in the contract and returns AnchorUST value',
  terra: {
    tvl,
  }
}
'''
'''--- projects/angle/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const { get } = require("../helper/http");
const { sumTokens2 } = require('../helper/unwrapLPs')

const ANGLE = "0x31429d1856ad1377a8a0079410b297e1a9e214c2";
const veANGLE = "0x0C462Dbb9EC8cD1630f1728B2CFD2769d09f0dd5";

const poolManagers_abi = {
  getTotalAsset: {
    inputs: [],
    name: "getTotalAsset",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  token: {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
};

// get Borrowing module vault managers list
async function getVaultManagersFromAPI(chain) {
  const chainIds = {
    ethereum: 1,
    polygon: 137,
    optimism: 10,
    arbitrum: 42161,
    fantom: 250,
  }
  let chainId = chainIds[chain];
  let calls = [];
  let result = await get("https://api.angle.money/v1/vaultManagers?chainId=" + chainId)

  for (const data of Object.values(result)) {
    const token = data.collateral
    if (token) calls.push([token, data.address])
  }
  return calls;
}

async function tvl(chain, block) {
  const balances = {}
  const tokensAndOwners = []
  if (chain === 'ethereum') {

    // Registry will be released in next sdk of Angle + graphql endpoint to come
    const collaterals = {
      dai: "0x6b175474e89094c44da98b954eedeac495271d0f",
      usdc: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      frax: "0x853d955acef822db058eb8505911ed77f175b99e",
      fei: "0x956F47F50A910163D8BF957Cf5846D573E7f87CA",
      weth: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    };

    const agEUR = {
      contract: "0x1a7e4e63778B4f12a199C062f3eFdD288afCBce8",
      stableMasterFront: "0x5adDc89785D75C86aB939E9e15bfBBb7Fc086A87",
      poolManagers: {
        dai: "0xc9daabC677F3d1301006e723bD21C60be57a5915", // DAI
        usdc: "0xe9f183FC656656f1F17af1F2b0dF79b8fF9ad8eD", // USDC
        fei: "0x53b981389Cfc5dCDA2DC2e903147B5DD0E985F44", // FEI
        frax: "0x6b4eE7352406707003bC6f6b96595FD35925af48", // FRAX
        weth: "0x3f66867b4b6eCeBA0dBb6776be15619F73BC30A2", // WETH
      },
    };

    const agTokens = [agEUR]
    const tokenMapping = {}
    agTokens.map((t) => {
      return Object.entries(t.poolManagers).forEach(([key, value]) => {
        tokenMapping[value] = collaterals[key]
      });
    })

    let { output: assets } = await sdk.api.abi.multiCall({
      calls: Object.keys(tokenMapping).map(i => ({ target: i })),
      abi: poolManagers_abi["getTotalAsset"], chain, block,
    })
    let { output: tokens } = await sdk.api.abi.multiCall({
      calls: Object.keys(tokenMapping).map(i => ({ target: i })),
      abi: poolManagers_abi["token"], chain, block,
    })

    assets.forEach(({ output }, i) => sdk.util.sumSingleBalance(balances, tokens[i].output, output))
  }

  // Borrowing module
  tokensAndOwners.push(...await getVaultManagersFromAPI(chain))
  return sumTokens2({ balances, chain, block, tokensAndOwners, })
}

/*
New networks will need to be added progressively. 
If not, the API call defaults to mainnet and the blockchain calls fail and return an error. 
*/

module.exports = {
  ethereum: {
    staking: staking(veANGLE, ANGLE, "ethereum"),
  },
  methodology: `TVL is retrieved on-chain by querying the total assets managed by the Core module, and the balances of the vaultManagers of the Borrowing module.`,
};

['ethereum', 'polygon'].forEach(chain => {
  if (!module.exports[chain]) module.exports[chain] = {}
  module.exports[chain].tvl = async (_, _b, { [chain]: block }) => tvl(chain, block)
})

'''
'''--- projects/animal-farm/index.js ---
const {masterChefExports} = require("../helper/masterchef")

const token = "0xdbdc73b95cc0d5e7e99dc95523045fc8d075fb9e";
const masterchef = "0xe5d9c56B271bc7820Eee01BCC99E593e3e7bAD44";

module.exports = {
    ...masterChefExports(masterchef, "bsc", token, false)
} // node test.js projects/animal-farm/index.js
'''
'''--- projects/ankr/index.js ---
const { get } = require("../helper/http")
const { toUSDTBalances } = require("../helper/balances")
let _response

async function getTvls(serviceName, key) {
  if (!_response) _response = get('https://api.stkr.io/v1alpha/metrics')
  const response = await _response
  const data = response.services.find(i => i.serviceName === serviceName)
  return data ? +data[key] : 0;
}

async function getETHTvl() {
  return {
    ethereum: await getTvls("eth", "totalStaked"),
    'matic-network': await getTvls("polygon", "totalStaked"),
  }
}

async function getBscTvl() {
  return {
    binancecoin: await getTvls("bnb", "totalStaked"),
  }
}

async function getAvaxTvl() {
  return {
    'avalanche-2': await getTvls("avax", "totalStaked"),
  }
}

async function polkadot() {
  return {
    polkadot: await getTvls("dot", "totalStaked"),
  }
}

async function ksm() {
  return {
    kusama: await getTvls("ksm", "totalStaked"),
  }
}

async function getFantomTvl() {
  return {
    fantom: await getTvls("ftm", "totalStaked"),
  }
}

module.exports = {
  timetravel: false,
  ethereum: {
    tvl: getETHTvl,
  },
  bsc: {
    tvl: getBscTvl,
  },
  avalanche: {
    tvl: getAvaxTvl,
  },
  fantom: {
    tvl: getFantomTvl,
  },
  polkadot: {
    tvl: polkadot,
  },
  kusama: {
    tvl: ksm,
  },
  methodology: `We get the total staked amount and total staked USD from Ankr's official API.`,
};

'''
'''--- projects/annex.js ---
const {compoundExports} = require('./helper/compound')

const wBNB = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c";
const cBNB = "0xC5a83aD9f3586e143D2C718E8999206887eF9dDc";

const wCRO = "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23";
const cCRO = "0x61FCA31c51aCc4CC683291Be936E6799AeAAFe41";

module.exports = {
  methodology:
      'TVL is comprised of tokens deposited to the protocol as collateral, similar to Compound Finance and other lending protocols the borrowed tokens are not counted as TVL. Data is pull from the Annex API "https://api.annex.finance/api/v1/governance/annex".',
  bsc: {
    ...compoundExports(
        "0xb13026db8aafa2fd6d23355533dccccbd4442f4c",
        "bsc",
        cBNB,
        wBNB,
        addr => `bsc:${addr}`,
    )
  },
  cronos: {
    ...compoundExports(
        "0xbC1f72e751DE303Ff545D2E348fef2E84D493645",
        "cronos",
        cCRO,
        wCRO,
        addr => `cronos:${addr}`,
    ),
  },
}; // node test.js projects/annex.js

'''
'''--- projects/ante/index.js ---
const sdk = require('@defillama/sdk')
const { default: BigNumber } = require('bignumber.js')

const factory = "0xa03492A9A663F04c51684A3c172FC9c4D7E02eDc"
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"

const toAddress = data=>`0x${data.slice(64 - 40 + 2, 64 + 2)}`

async function tvl(_time, block){
    const poolLogs = await sdk.api.util.getLogs({
        target: factory,
        topic: "AntePoolCreated(address,address)",
        keys: [],
        toBlock: block,
        fromBlock: 13234803-1 // deployment
    })
    const pools = poolLogs.output.map(log=>toAddress(log.data))
    const ethBalances = await sdk.api.eth.getBalances({
        targets: pools,
        block
    })
    return {
        [WETH]: ethBalances.output.reduce((total, pool)=>total.plus(pool.balance), BigNumber(0)).toFixed(0)
    }
}

module.exports={
    tvl
}
'''
'''--- projects/antex.js ---
const { toUSDTBalances } = require('./helper/balances');
const { get } = require('./helper/http');

async function fetch() {
    let response = await get(
        'https://antpad.io/api/index/statistic?platform=bsc&network=main'
    )
    return toUSDTBalances(response.data.total_liquidity_locked);
};

module.exports = {
    timetravel: false,
    bsc: {
        tvl: fetch,
    }
};
'''
'''--- projects/antimatter/abi.json ---
{
    "allCalls": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allCalls",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "allPuts": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allPuts",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "underlying": {
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "length": {
        "inputs": [],
        "name": "length",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/antimatter/index.js ---
const sdk = require("@defillama/sdk");
const abi = require('./abi.json')

const factory = "0x60d0769c4940cA58648C0AA34ecdf390a10F272e"
const usdt = "0xdac17f958d2ee523a2206206994597c13d831ec7"
async function tvl(timestamp, ethBlock) {
    const balances = {};
    const contractsLength = await sdk.api.abi.call({
        target:factory,
        abi: abi.length,
        block:ethBlock
    })
    const calls = [];
    for(let i=0; i<Number(contractsLength.output); i++){
        calls.push({
            target: factory,
            params: [i]
        })
    }
    const [allCalls, allPuts] = await Promise.all([
        sdk.api.abi.multiCall({
            calls,
            block: ethBlock,
            abi: abi.allCalls
        }),
        sdk.api.abi.multiCall({
            calls,
            block: ethBlock,
            abi: abi.allPuts
        })
    ])
    const contracts = allCalls.output.concat(allPuts.output).map(result=>result.output)
    const underlying = await sdk.api.abi.multiCall({
        calls: contracts.map(contract=>({
            target: contract
        })),
        block: ethBlock,
        abi: abi.underlying
    });
    const underlyingBalances = await sdk.api.abi.multiCall({
        calls: underlying.output.map(call=>[{
            target: call.output,
            params: [call.input.target]
        },{
            target: usdt,
            params: [call.input.target]
        }]).flat(),
        block: ethBlock,
        abi: "erc20:balanceOf"
    });
    sdk.util.sumMultiBalanceOf(balances, underlyingBalances, true)

    return balances
}

module.exports = {
    ethereum: {
        tvl
    },
}
'''
'''--- projects/antimatterDAO/abi.json ---
{
  "staking": {
    "TVL": {
      "inputs": [],
      "name": "TVL",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  },
  "bullbear": {
    "allCalls": {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allCalls",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "allPuts": {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allPuts",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "underlying": {
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "length": {
      "inputs": [],
      "name": "length",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
}
'''
'''--- projects/antimatterDAO/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const antimatterStakingContract = "0xCB8429f22541E8F5cd8ea6c20BFFdcE7cDA65227";
const dualInvestContract = "0x7E45149820Fa33B66DCD3fd57158A0E755A67a16";
const dualInvestManagerAddress = "0x32275702f5A47Dcd89705c1ea4d47E99517b0e1a";
const bscBTCContract = "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c";
const bscUSDTContract = "0x55d398326f99059fF775485246999027B3197955";
const bscETHContract = "0x2170Ed0880ac9A755fd29B2688956BD959F933F8";

const factory = "0x90183C741CC13195884B6E332Aa0ac1F7c1E67Fa"

async function bullbearTVL(block, chain, usdToken) {
  const balances = {};
  const contractsLength = await sdk.api.abi.call({
    target: factory,
    abi: abi.bullbear.length,
    block,
    chain,
  })
  const calls = [];
  for (let i = 0; i < Number(contractsLength.output); i++) {
    calls.push({
      target: factory,
      params: [i]
    })
  }
  const [allCalls, allPuts] = await Promise.all([
    sdk.api.abi.multiCall({
      calls,
      block,
      abi: abi.bullbear.allCalls,
      chain,
    }),
    sdk.api.abi.multiCall({
      calls,
      block,
      abi: abi.bullbear.allPuts,
      chain,
    })
  ])
  const contracts = allCalls.output.concat(allPuts.output).map(result => result.output)
  const underlying = await sdk.api.abi.multiCall({
    calls: contracts.map(contract => ({
      target: contract
    })),
    block,
    abi: abi.bullbear.underlying,
    chain,
  });
  const underlyingBalances = await sdk.api.abi.multiCall({
    calls: underlying.output.map(call => [{
      target: call.output,
      params: [call.input.target]
    }, {
      target: usdToken,
      params: [call.input.target]
    }]).flat(),
    block,
    abi: "erc20:balanceOf",
    chain,
  });
  sdk.util.sumMultiBalanceOf(balances, underlyingBalances, true)
  return balances
}

async function ethBullbearTVL(timestamp, ethBlock) {
  return await bullbearTVL(ethBlock, 'ethereum', '0xdac17f958d2ee523a2206206994597c13d831ec7')
}

async function bscBullbearTVL(block) {
  return await bullbearTVL(block, 'bsc', '0xe9e7cea3dedca5984780bafc599bd69add087d56')
}

async function arbitrumBullbearTVL(timestamp, ethBlock, chainBlocks) {
  const balances = await bullbearTVL(chainBlocks['arbitrum'], 'arbitrum', '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9')
  const chainBalances = {}
  Object.keys(balances).forEach(key => chainBalances['arbitrum:' + key] = balances[key])
  return chainBalances
}

async function avaxBullbearTVL(timestamp, ethBlock, chainBlocks) {
  const balances = await bullbearTVL(chainBlocks['avax'], 'avax', '0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664')
  const chainBalances = {}
  Object.keys(balances).forEach(key => chainBalances['avax:' + key] = balances[key])
  return chainBalances
}

const dualInvestTVL = async (bscBlock) => {
  const balances = {}
  const usdtValue = await sdk.api.abi.multiCall({
    target: bscUSDTContract,
    calls: [{
      target: bscUSDTContract,
      params: dualInvestContract
    },
    {
      target: bscUSDTContract,
      params: dualInvestManagerAddress
    }],
    params: dualInvestContract,
    abi: "erc20:balanceOf",
    block: bscBlock,
    chain: "bsc"
  });
  const btcValue = await sdk.api.abi.multiCall({
    target: bscUSDTContract,
    calls: [{
      target: bscBTCContract,
      params: dualInvestContract
    },
    {
      target: bscBTCContract,
      params: dualInvestManagerAddress
    }],
    params: dualInvestContract,
    abi: "erc20:balanceOf",
    block: bscBlock,
    chain: "bsc"
  });

  const ethValue = await sdk.api.abi.multiCall({
    target: bscETHContract,
    calls: [{
      target: bscETHContract,
      params: dualInvestContract
    },
    {
      target: bscETHContract,
      params: dualInvestManagerAddress
    }],
    params: dualInvestContract,
    abi: "erc20:balanceOf",
    block: bscBlock,
    chain: "bsc"
  });

  sdk.util.sumMultiBalanceOf(balances, usdtValue, true);
  sdk.util.sumMultiBalanceOf(balances, btcValue, true);
  sdk.util.sumMultiBalanceOf(balances, ethValue, true)
  return balances;
};

const stakingTVL = async (timestamp, ethBlock) => {
  const balances = {}
  const { output: staked } = await sdk.api.abi.call({
    target: antimatterStakingContract,
    abi: abi.staking.TVL,
    block: ethBlock,
    chain: "ethereum"
  });
  sdk.util.sumSingleBalance(balances, '0xdac17f958d2ee523a2206206994597c13d831ec7', staked)
  return balances
};

async function bscTVL(timestamp, ethBlock, chainBlocks) {
  const dualinvestTVL = await dualInvestTVL(chainBlocks['bsc'])
  const bullbearTvl = await bscBullbearTVL(chainBlocks['bsc'])
  const tvl = Object.assign(dualinvestTVL, bullbearTvl)
  const chainBalances = {}
  Object.keys(tvl).forEach(key => chainBalances['bsc:' + key] = tvl[key])
  return chainBalances
}

module.exports = {
  methodology: "Antimatter application is consist of four parts: 1) Antimatter structured product 2) Antimatter Bull and Bear 3) Antimatter Governance staking and 4) antimatter Nonfungible finance . There are assets locked in each part of the application on multiple chains. TVL is counted as the value of the underlying assets in each part of the applications contract. Our TVL is calling contract from our smart contracts",
  ethereum: {
    staking: stakingTVL, // dao staking
    tvl: ethBullbearTVL
  },
  bsc: {
    tvl: bscTVL
  },
  arbitrum: {
    tvl: arbitrumBullbearTVL
  },
  avalanche: {
    tvl: avaxBullbearTVL
  },
  timetravel: true,
};
'''
'''--- projects/anyswap/index.js ---
const utils = require('../helper/utils')
// const sdk = require("@defillama/sdk")
// console.log(sdk)

const chains = {
  '1': 'ethereum',
  '10': 'optimism',
  '25': 'cronos',
  '30': 'rsk',
  '40': 'telos',
  '56': 'bsc',
  '57': 'syscoin',
  '61': 'ethereumclassic',
  '66': 'okexchain',
  '100': 'xdai',
  '106': 'velas',
  '122': 'fuse',
  '128': 'heco',
  '137': 'polygon',
  '199': 'bittorrent',
  '250': 'fantom',
  '288': 'boba',
  '321': 'kcc',
  '336': 'shiden',
  '592': 'astar',
  '1030': 'conflux',
  '1088': 'metis',
  '1284': 'moonbeam',
  '1285': 'moonriver',
  '2001': 'milkomeda',
  '2020': 'ronin',
  '4689': 'iotex',
  '9001': 'evmos',
  '32659': 'fusion',
  '42161': 'arbitrum',
  '42220': 'celo',
  '42262': 'oasis',
  '43114': 'avax',
  '53935': 'dfk',
  '1313161554': 'aurora',
  '1666600000': 'harmony'
}

const url = 'https://netapi.anyswap.net/bridge/v2/info'
const sleep = ms => new Promise(r => setTimeout(r, ms));

let coingeckoMcapsPromise

async function getCgMcaps() {
  if (coingeckoMcapsPromise) {
    return coingeckoMcapsPromise
  }
  coingeckoMcapsPromise = new Promise(async (resolve) => {
    const { data } = await utils.fetchURL(url)
    const protocolsInChain = data.bridgeList
    const protocolsWithRouters = Array.from(new Set(protocolsInChain.filter(p => p.type === "router" && p.label !== null).map(p => p.label.toLowerCase())));

    const coingeckoMcaps = {}
    const step = 200;;
    for (let i = 0; i < protocolsWithRouters.length; i += step) {
      console.log(i / step)
      const cgUrl = `https://api.coingecko.com/api/v3/simple/price?vs_currencies=usd&include_market_cap=true&ids=${protocolsWithRouters.slice(i, i + step).join(',')
        }`
      await sleep(1e3)
      const partMcaps = await utils.fetchURL(cgUrl)
      Object.assign(coingeckoMcaps, partMcaps.data)
    }
    resolve(coingeckoMcaps)
  })
  return coingeckoMcapsPromise
}

function fetchChain(chain) {
  return async () => {
    const { data } = await utils.fetchURL(url)
    const protocolsInChain = chain === null ? data.bridgeList : data.bridgeList.filter(p => p.chainId.toString() === chain.toString())

    const coingeckoMcaps = await getCgMcaps();
    const counted = {}
    let total = 0
    protocolsInChain.forEach((item) => {
      const tvl = Number(item.tvl || 0)

      if (item.type === "bridge") {
        total += tvl
      } else if (item.type === "router") {
        const label = item.label
        const mcap = coingeckoMcaps[label]?.usd_market_cap
        if (counted[label] === undefined) {
          counted[label] = 0
        }
        if (mcap !== undefined && mcap > counted[label]) {
          const tvlToAdd = Math.min(tvl, mcap - counted[label])
          total += tvlToAdd
          counted[label] += tvlToAdd
        }
      }
    })
    return total
  }
}

const chainTvls = {}
Object.keys(chains).forEach((chain) => {
  const chainName = chains[chain]
  chainTvls[chainName === 'avax' ? 'avalanche' : chainName] = {
    fetch: fetchChain(chain)
  }
})

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  ...chainTvls,
  fetch: fetchChain(null),
}
'''
'''--- projects/aperocket/abi.json ---
{
    "tvlOfPool": {
        "inputs": [
            {
                "internalType": "address",
                "name": "vault",
                "type": "address"
            }
        ],
        "name": "tvlOfPool",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "tvlOfVault": {
        "inputs": [
            {
                "internalType": "address",
                "name": "_vault",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "isLp",
                "type": "bool"
            },
            {
                "internalType": "address",
                "name": "tokenRouter",
                "type": "address"
            }
        ],
        "name": "tvlOfVault",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/aperocket/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

/* Certain portion of TVL accounted by their site is coming from their own native token
 * in differente blockchains (i.e, bsc and polygon). Aprox $6.0M
 */

const V2_READER = "0xDc84cbf85ADA13ACAe796FAa4472C19cC901b042"
const MERCURY_READER = "0xc9e54c7ec73aEe86e2BB07c4c6B65BE8BD86Ca90"

const V2_VAULTS_CONTRACTS_BSC = [
  "0xa13eF34F11cD905A1aACe891e3Fd1b355D770e7F", // BANANA
  "0x41b726444CcD5137A7Ec1Fbb870b9eFF57F89E89", // CAKE
  "0xA298f622E8B46491749C1ccDBe2DfFA13049A930", // BSW
  "0xa126C7f00875343f233e3c2f95067c80ab5B068a", // BANANA-BNB LP (ApeSwap)
  "0xD259A715De1fB30AD76Cc9580e68A15Ee9D12Dc2", // BANANA-BNB LP Maximizer (ApeSwap)
  "0x313adEc67e70a86Bd1166CCAcB8aCA932f28E95B", // CAKE-BNB LP (PancakeSwap)
  "0xaC3184b1F2888caaB5A7dE1381707c15c153B04A", // CAKE-BNB LP Maximizer (PancakeSwap)
  "0xB8469e8A7a8893E4c698B3De8163906386861B96", // BSW-BNB LP (Biswap)
  "0x76a3fE4350F13042EC179E5240bC68349d2AAD35", // BSW-BNB LP Maximizer (Biswap)
  "0x1c86DB4820Acb4Dd91A80a8874afb82251aeb937", // BANANA-BUSD LP (ApeSwap)
  "0xf3D78aE6A67D391fd894ee8f4da7842EC07CF446", // BANANA-BUSD LP Maximizer (ApeSwap)
  "0x34d1f4FA762c85f363cb5907Ca0BAcF53aBac866", // BSW-USDT LP (Biswap)
  "0xcf02e68b900Ce87F8715CAEF8b8a9e212b9158A1", // BUSD-BNB LP (PancakeSwap)
  "0x7dBB2b2Fd312710C805D4c78EE55ca1F8750Bace", // BUSD-BNB LP (ApeSwap)
  "0xa8A2c0aa4C050D2cB5C1Ac224A31c76492A35B80", // BNB-BUSD LP (Biswap)
  "0x101bCD396DDFb934072a171Bc4F625B85D505C78", // BUSD-BNB LP Maximizer (ApeSwap)
  "0xBC84830C42cedc1A32b665BfEaB3Fb16bcdFb8e3", // BNB-BUSD LP Maximizer (Biswap)
  "0xd9137C7be7a3117941317d525B06c441eAC7380d", // ETH-BNB LP Maximizer (ApeSwap)
  "0xe1F45D11B5D0Ddbe300cADFeFd7021Ac750a4281", // BUSD-USDC LP (ApeSwap)
  "0x1119FBECe0F576D318ce489886d05A098e94961F", // BUSD-USDC LP Maximizer (ApeSwap)
  "0x0Edf919fe5cDA4c7fA02AE7de77243cecedFd036", // ADA-BNB LP (ApeSwap)
  "0x8ADDf5FcE06B9F93cBf1F8B2ef580b25D1EDBE56", // ADA-BNB LP Maximizer (ApeSwap)
  "0x8747431ddFf6069f32ad8eE0Da51084432F8594C", // BUSD-USDT LP (ApeSwap)
  "0xC8bba6AC77804b3b6b28D6C5890b98fb935F361F", // BUSD-USDT LP Maximizer (ApeSwap)
  "0x8E1fcB9b48A299b71d7a4CDc24F11439cF253126", // BNB-USDT LP (Biswap)
  "0x681969eBfC476E8208CA551fA364e8FE6a19242F", // ETH-BTCB LP (Biswap)
  "0x1AFB491895D301a7cea026a5c65316b2C05A56B4", // ETH-BTCB LP Maximizer (Biswap)
];

const MERCURY_SINGLE_VAULTS_CONTRACTS_BSC = [
  {
    address: "0xFfDcD49d902d71445B93DCbFa51E2F9797de05C9", // BANANA
    isLp: false,
    router: "0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7",
  },
];

const bscTvl = async (timestamp, block, chainBlocks) => {
  const getV2Tvls = (
    await sdk.api.abi.multiCall({
      abi: abi.tvlOfPool,
      calls: V2_VAULTS_CONTRACTS_BSC.map((vcb) => ({
        target: V2_READER,
        params: [vcb],
      })),
      block,
      chain: "bsc",
    })
  ).output.map((tvl) => tvl.output);

  const v2Tvl = getV2Tvls.reduce((previousValue, currentValue) => Number(previousValue) + Number(currentValue))

  const getMercuryTvls = (
    await sdk.api.abi.multiCall({
      abi: abi.tvlOfVault,
      calls: MERCURY_SINGLE_VAULTS_CONTRACTS_BSC.map((vcb) => ({
        target: MERCURY_READER,
        params: [vcb.address, vcb.isLp, vcb.router],
      })),
      block,
      chain: "bsc",
    })
  ).output.map((tvl) => tvl.output);

  const mercuryTvl = getMercuryTvls.reduce((previousValue, currentValue) => Number(previousValue) + Number(currentValue))

  const totalTvl = (v2Tvl / 10 ** 18) + (mercuryTvl / 10 ** 18)

  return {
    'tether': totalTvl,
  };
};

module.exports = {
  bsc: {
    tvl: bscTvl,
  },  
  methodology: `TVL consists of deposits made to the Earn Vaults of ApeRocket minus the 'SPACE' vault and the 'SPACE-BNB' pool2 vault which are created using the protocol's native token.`,
  misrepresentedTokens: true,
};

'''
'''--- projects/aperture/index.js ---
const { queryContractStore, } = require('../helper/terra')
const BigNumber = require('bignumber.js')
const { toUSDTBalances } = require('../helper/balances')

const TERRA_MANAGER = 'terra1ajkmy2c0g84seh66apv9x6xt6kd3ag80jmcvtz'
const APERTURE_CONTRACT = 'terra1jvehz6d9gk3gl4tldrzd8qzj8zfkurfvtcg99x'

async function tvl() {
  let block
  let sumTvl = BigNumber(0)
  const { next_position_id } = await queryContractStore({
    contract: TERRA_MANAGER,
    queryParam: { get_next_position_id: {}, },
    block
  })
  const positions = [...Array(+next_position_id).keys()]
    .map((_value, position) => ({ chain_id: 3, position_id: `${position}` }))

  const chunkSize = 50
  for (let i = 0; i < positions.length; i += chunkSize) {
    await Promise.all(positions.slice(i, i + chunkSize)
      .map(async position => {
        const {
          items: [{
            info: {
              position_close_info,
              detailed_info,
            }
          }]
        } = await queryContractStore({
          contract: APERTURE_CONTRACT,
          queryParam: getQuery(position),
          block
        })

        if (!position_close_info)  // position is closed no need to add it to tvl
          sumTvl = sumTvl.plus(BigNumber(detailed_info.uusd_value))
      }))
  }

  return {
    'terrausd': sumTvl.dividedBy(BigNumber(1e6)),
  }

  function getQuery(postion) {
    return { batch_get_position_info: { positions: [postion], } }
  }
}

module.exports = {
  timetravel: false,
  terra: {
    tvl,
  }
}
'''
'''--- projects/apeswap/index.js ---
const sdk = require("@defillama/sdk");
const {calculateUniTvl} = require('../helper/calculateUniTvl.js');
const { staking } = require("../helper/staking.js");
const {usdCompoundExports, getCompoundV2Tvl} = require('../helper/compound');
const { transformBscAddress } = require("../helper/portedTokens.js");

const BANANA_TOKEN = '0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95'
const MASTER_APE = '0x5c8D727b265DBAfaba67E050f2f739cAeEB4A6F9'
const FACTORY_BSC = "0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6";
const FACTORY_POLYGON = "0xcf083be4164828f00cae704ec15a36d711491284";
const unitroller_bsc = "0xad48b2c9dc6709a560018c678e918253a65df86e"

const SUBGRAPH_BSC = "https://graph2.apeswap.finance/subgraphs/name/ape-swap/apeswap-subgraph"
const SUBGRAPH_POLYGON = "https://api.thegraph.com/subgraphs/name/apeswapfinance/dex-polygon" 

const abis = {
  oracle: {"constant":true,"inputs":[],"name":"getRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},
  underlyingPrice: {"constant":true,"inputs":[{"internalType":"address","name":"cToken","type":"address"}],"name":"getPriceForUnderling","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
}

async function bscTvl(timestamp, block, chainBlocks) {
  const balances = await calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks['bsc'], 'bsc', FACTORY_BSC, 0, true);
  delete balances["bsc:0x95e7c70b58790a1cbd377bc403cd7e9be7e0afb1"] //YSL - coingecko price broken
  return balances
}

async function polygonTvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(addr=>`polygon:${addr}`, chainBlocks['polygon'], 'polygon', FACTORY_POLYGON, 0, true);
}

const lendingMarket = usdCompoundExports(unitroller_bsc, "bsc", "0x34878F6a484005AA90E7188a546Ea9E52b538F6f", abis)

module.exports = {
  timetravel: true,
  doublecounted: false,
  misrepresentedTokens: true,
  bsc:{
    tvl: sdk.util.sumChainTvls([bscTvl,lendingMarket.tvl]),
    staking: staking(MASTER_APE, BANANA_TOKEN, "bsc"),
    borrowed: lendingMarket.borrowed
  },
  polygon:{
    tvl: polygonTvl,
  },
  methodology: "TVL comes from the DEX liquidity pools, staking TVL is accounted as the banana on 0x5c8D727b265DBAfaba67E050f2f739cAeEB4A6F9",
}
'''
'''--- projects/apex/index.js ---
const {
  GraphQLClient,
  gql
} = require('graphql-request')

async function fetch() {

  var endpoint = 'https://api.apex.exchange/g2/subgraphs/name/apex/exchange'
  var graphQLClient = new GraphQLClient(endpoint)

  var query = gql `
    {
      dexFactories{
        totalLiquidityUSD
      }
    }
    `;

  const results = await graphQLClient.request(query)
  return parseFloat(results.dexFactories[0].totalLiquidityUSD)
}

module.exports = {
  fetch
}
'''
'''--- projects/api3/abi.json ---
{
  "getLockedByGovernance": {"inputs":[],"name":"getLockedByGovernance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  "getLockedRewards": {"inputs":[],"name":"getLockedRewards","outputs":[{"internalType":"uint256","name":"totalLockedRewards","type":"uint256"}],"stateMutability":"view","type":"function"},
  "getLockedVestings": {"inputs":[],"name":"getLockedVestings","outputs":[{"internalType":"uint256","name":"totalLockedVestings","type":"uint256"}],"stateMutability":"view","type":"function"},
  "getTimelocked": {"inputs":[],"name":"getTimelocked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  "getTotalLocked": {"inputs":[],"name":"getTotalLocked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/api3/index.js ---
const sdk = require('@defillama/sdk');
const { staking } = require('../helper/staking')
const { BigNumber } = require('bignumber.js');
const abi = require('./abi.json')

const api3_token = '0x0b38210ea11411557c13457d4da7dc6ea731b88a'
const api3_dao_pool = '0x6dd655f10d4b9e242ae186d9050b68f725c76d76'
const api3CirculatingSupply = "cD34bC5B03C954268d27c9Bc165a623c318bD0a8"

const stakingTVL = async (timestamp, ethBlock, chainBlocks) => {
  const staked = await staking(api3_dao_pool, api3_token)(timestamp, ethBlock, chainBlocks)
  
  const { output: locked_and_vested } = await sdk.api.abi.call({
    target: api3CirculatingSupply,
    abi: abi["getLockedVestings"],
    block: ethBlock,
    chain: 'ethereum'
  });
  console.log(staked, locked_and_vested)
  staked[api3_token] = BigNumber(staked[api3_token]).minus(BigNumber(locked_and_vested)).toFixed(0)
  console.log(staked)

  return staked
}

// TODO: choose if this should be counted as staking or tvl, since this is how the protocol functions (to insure dAPI)
module.exports = {
  ethereum: {
    staking: stakingTVL, // tvl / staking
    // staking: staking(api3_dao_pool, api3_token), // tvl / staking
    tvl: () => ({})
  },
  methodology: 'API3 TVL is all API3 token staked in the API3 DAO Pool contract',
}

'''
'''--- projects/apollodao/index.js ---
const axios = require('axios');
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');

const limit = 1

async function strategies() {
    let totalStrategies = []
    let current = 0
    do {
        // Node is semi-pruned, only every 100th block is stored
        const url = "https://lcd.terra.dev/wasm/contracts/terra1g7jjjkt5uvkjeyhp8ecdz4e4hvtn83sud3tmh2/store?query_msg=" +
            encodeURIComponent(`{"get_strategies": {"limit": ${limit}, "start_from": ${current}}}`);
        const pagedStrategies = (await axios.get(url)).data.result.strategies
        totalStrategies = totalStrategies.concat(pagedStrategies)
        current += limit
        if(current === 30){
            current++; //skip
        }
    } while (totalStrategies.length === current);
    return totalStrategies
}

async function tvl(timestamp, ethBlock, chainBlocks) {
    const strats = await strategies()
    const total = strats.reduce((t, s)=>t+Number(s.tvl), 0)
    return {
        '0xa47c8bf37f92abed4a126bda807a7b7498661acd': BigNumber(total*1e12).toFixed(0)
    }
}

module.exports = {
    timetravel: false,
    methodology: "Total TVL on vaults",
    tvl
}

'''
'''--- projects/apollox/index.js ---
const { pool2 } = require('../helper/pool2');
const { stakings } = require('../helper/staking');
const { sumTokens } = require('../helper/unwrapLPs');

const stakingContract = '0x7eb5af418f199ea47494023c3a8b83a210f8846f'
const stakingContract_APX = '0x6bE863e01E17A226c945e3629D0D9Cb6E52Ce90E'
const poolContract = '0xa0ee789a8f581cb92dd9742ed0b5d54a0916976c'
const treasureContract = '0xe2e912f0b1b5961be7cb0d6dbb4a920ace06cd99'
const daoContract = "0x7f878994507F5B0588cF0EBEE07128d9A742ad9d"

const TOKEN_APX = '0x78f5d389f5cdccfc41594abab4b0ed02f31398b3'
const TOKEN_BSC_USD = '0x55d398326f99059fF775485246999027B3197955'
const TOKEN_BUSD = '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56'
const TOKEN_CAKE = '0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82'
const TOKEN_BABY = '0x53e562b9b7e5e94b81f10e96ee70ad06df3d2657'
const TOKEN_LEOS = '0x2c8368f8f474ed9af49b87eac77061beb986c2f1'

const TreasureTokens = [
  TOKEN_BSC_USD,
  TOKEN_BUSD,
  TOKEN_CAKE,
  TOKEN_BABY,
  TOKEN_LEOS,
]

async function tvl(timestamp, _block, { bsc: block }) {
  const toa = TreasureTokens.map(t => [t, treasureContract])
  return sumTokens({}, toa, block, 'bsc')
}

module.exports = {
  start: 1640100600,  // 12/21/2021 @ 15:30pm (UTC)
  bsc: {
    tvl,
    staking: stakings([stakingContract_APX, daoContract], TOKEN_APX, 'bsc'),
    pool2: pool2(stakingContract, poolContract, 'bsc'),
  },
};

'''
'''--- projects/apricot.js ---
const {getTokenBalance, sumOrcaLPs} = require('./helper/solana')

async function tvl() {
    const [
        usdcAmount, 
        btcAmount, 
        ethAmount, 
        msolAmount,          
        usdtAmount,          
        rayAmount,
        orcaAmount,          
        solAmount,
        ustAmount,
        /*
        orcaUsdcUsdt,
        orcaSolUsdc,
        orcaEthUsdc,
        orcaSolUsdt,
        orcaOrcaUsdc,
        orcaOrcaSol,*/
        ] = await Promise.all([
        
        getTokenBalance("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("So11111111111111111111111111111111111111112", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
        getTokenBalance("9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"),
    ])
    const orcaPoolsTVL = await sumOrcaLPs([
        //usdt/usdc
        ["GjpXgKwn4VW4J2pZdS3dovM58hiXWLJtopTfqG83zY2f", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //SOL/USDC
        ["FFdjrSvNALfdgxANNpt3x85WpeVMdQSH5SEP2poM8fcK", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //ETH/USDC
        ["HDP2AYFmvLz6sWpoSuNS62JjvW4HjMKp7doXucqpWN56", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //SOL/USDT
        ["71vZ7Jvu8fTyFzpX399dmoSovoz24rVbipLrRn2wBNzW", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //ORCA/USDC
        ["Gc7W5U66iuHQcC1cQyeX9hxkPF2QUVJPTf1NWbW8fNrt", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //ORCA/SOL
        ["B5waaKnsmtqFawPspUwcuy1cRjAC7u2LrHSwxPSxK4sZ", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //mSOL/USDC[aquafarm]
        ["9y3QYM5mcaB8tU7oXRzAQnzHVa75P8riDuPievLp64cY", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //BTC/mSOL[aquafarm]
        ["6uA1ADUJbvwYJZpzUn9z9LuyKoRVngBKcQTKdXsSivA8", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //ETH/SOL
        ["CGFTRh4jKLPbS9r4hZtbDfaRuC7qcA8rZpbLnVTzJBer", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
        //mSOL/SOL[stable][aquafarm]
        ["576ABEdvLG1iFU3bLC8AMJ3mo5LhfgPPhMtTeVAGG6u7", "7Ne6h2w3LpTNTa7CNYcUs7UkjeJT3oW7jcrXWfVScTXW"],
    ])
    return {
        'bitcoin': btcAmount,
        'usd-coin': usdcAmount,
        'ethereum': ethAmount, //+ (orcaEthUsdc/2),       
        'tether': usdtAmount + orcaPoolsTVL,  //+ orcaUsdcUsdt,        
        'raydium': rayAmount,        
        'orca': orcaAmount, //+ (orcaOrcaSol/2) + (orcaOrcaUsdc/2),
        'solana': solAmount, //+ (orcaSolUsdt/2) + (orcaSolUsdc/2),
        'msol': msolAmount,
        'terrausd': ustAmount,  
    }
}

module.exports = {
    timetravel: false,
    tvl,
    methodology: 'TVL consists of deposits made to the protocol and like other lending protocols, borrowed tokens are not counted. Coingecko is used to price tokens.',
}

'''
'''--- projects/apwine/abi.json ---
{
    "registry_futureVaultCount": {"inputs":[],"name":"futureVaultCount","outputs":[{"internalType":"uint256","name":"futureVaultCount","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}, 
    "registry_getFutureVaultAt": {"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"name":"getFutureVaultAt","outputs":[{"internalType":"address","name":"futureVault","type":"address"}],"stateMutability":"nonpayable","type":"function"}, 
    "registry_getIBTAddress": {"inputs":[],"name":"getIBTAddress","outputs":[{"internalType":"address","name":"IBTAddress","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "ammregistry_getFutureAMMPool": {"inputs":[{"internalType":"address","name":"_futureVaultAddress ","type":"address"}],"name":"getFutureAMMPool","outputs":[{"internalType":"address","name":"_futureAMMPoolAddress ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "futurevault_STAKED_TOKEN": {"inputs":[],"name":"STAKED_TOKEN","outputs":[{"internalType":"address","name":"_STAKED_TOKEN_Address ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "futurevault_getPTAddress": {"inputs":[],"name":"getPTAddress","outputs":[{"internalType":"address","name":"_PTAddress ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
        
    "ammPool_getFYTAddress": {"inputs":[],"name":"getFYTAddress","outputs":[{"internalType":"address","name":"_address ","type":"address"}],"stateMutability":"nonpayable","type":"function"}, 
    "ammPool_getFutureAddress": {"inputs":[],"name":"getFutureAddress","outputs":[{"internalType":"address","name":"_address ","type":"address"}],"stateMutability":"nonpayable","type":"function"}, 
    "ammPool_getIBTAddress": {"inputs":[],"name":"getIBTAddress","outputs":[{"internalType":"address","name":"IBTAddress","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "ammPool_getPTAddress": {"inputs":[],"name":"getPTAddress","outputs":[{"internalType":"address","name":"_address ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "ammPool_getPoolTokenAddress": {"inputs":[],"name":"getPoolTokenAddress","outputs":[{"internalType":"address","name":"_address ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "ammPool_getUnderlyingOfIBTAddress": {"inputs":[],"name":"getUnderlyingOfIBTAddress","outputs":[{"internalType":"address","name":"_address ","type":"address"}],"stateMutability":"nonpayable","type":"function"},
    "ammPool_getPairWithID_BAD_OUTPUT_ABI": {"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getPairWithID","outputs":[
        {"internalType":"address","name":"tokenAddress ","type":"address"},
        {"internalType":"uint256[2]","name":"weights ","type":"uint256[2]"},
        {"internalType":"uint256[2]","name":"balances ","type":"uint256[2]"},
        {"internalType":"bool","name":"liquidityIsInitialized ","type":"bool"}
    ],"stateMutability":"nonpayable","type":"function"}   
}

'''
'''--- projects/apwine/index.js ---
const sdk = require("@defillama/sdk")
const abi = require("./abi.json")
const {sumTokens, unwrapCrv} = require("../helper/unwrapLPs.js")
const {staking} = require("../helper/staking.js")
const {pool2s} = require("../helper/pool2.js")

// Same registry addresses for polygon and mainnet
const registry = '0x72d15eae2cd729d8f2e41b1328311f3e275612b9' 
const AMMregistry = '0x6646A35e74e35585B0B02e5190445A324E5D4D01'

// Mapping from tokens locked in APWine to ones that can be read by coingecko
const transformMapping_ethereum = {
  '0xaC14864ce5A98aF3248Ffbf549441b04421247D3': '0x73968b9a57c6e53d41345fd57a6e6ae27d6cdb2f', // xSDT -> SDT
  '0x6b1D394Ca67fDB9C90BBd26FE692DdA4F4f53ECD': '0xcafe001067cdef266afb7eb5a286dcfd277f3de5', // sPSP_PP4 -> PSP
  '0xA991356d261fbaF194463aF6DF8f0464F8f1c742': '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // tfUSDC -> USDC
  '0x24E79e946dEa5482212c38aaB2D0782F04cdB0E0': '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9', // palStkAave -> AAVE
}
const transformMapping_polygon = {
}
const tokensToUnwrap =  {
  'polygon:0xDDe43710DefEf6CbCf820B18DeBfC3cF9a4f449F': {'type': 'crv', 'unwrapTo': '0xad326c253a84e9805559b73a08724e11e49ca651'},  // miFARM_4eur-f (bf4eur-f) -> 4eur-f
  'polygon:0x5A0801BAd20B6c62d86C566ca90688A6b9ea1d3f': {'type': 'crv', 'unwrapTo': '0xdad97f7713ae9437fa9249920ec8507e5fbb23d3'}, // Moo Curve aTriCrypto3 -> aTriCrypto3

  'polygon:0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171': {'type': 'crv', 'unwrapTo': '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171'}, // curve am3CRV
  'polygon:0xad326c253a84e9805559b73a08724e11e49ca651': {'type': 'crv', 'unwrapTo': '0xad326c253a84e9805559b73a08724e11e49ca651'},  // miFARM_4eur-f (bf4eur-f) -> 4eur-f
  'polygon:0xdad97f7713ae9437fa9249920ec8507e5fbb23d3': {'type': 'crv', 'unwrapTo': '0xdad97f7713ae9437fa9249920ec8507e5fbb23d3'}, // Moo Curve aTriCrypto3 -> aTriCrypto3
}
const transform  = {
  'ethereum': addr => transformMapping_ethereum[addr] || addr,
  'polygon': addr => transformMapping_polygon[addr] || `polygon:${addr}`
}

// Staking - vote escrowed staking ala crv
const APW = '0x4104b135dbc9609fc1a9490e61369036497660c8'
const veAPW = '0xc5ca1ebf6e912e49a6a70bb0385ea065061a4f09'

// Pool2 - APW-XXX LP staked
const APW_WETH_cometh = '0x70797fc5b1c04541113b5ac20ea05cb390392e30'
const APW_MUST_cometh = '0x174f902194fce92ef3a51079b531f1e5073de335'
const APW_WETH_cometh_staking = '0x4e2114f7fa11dc0765ddd51ad98b6624c3bf1908'
const APW_MUST_cometh_staking = '0xb7ae78f49ac9bd9388109a4c5f53c6b79be4deda'

const tvl_from_registry = (chain) => {
  return async (timestamp, ethBlock, chainBlocks) => {
    const balances = {}
    const block = chainBlocks[chain]

    // ----------------------------
    // A. Get vault addresses and IBT tokens held by each vault
    let {output: futureVaultCount} = await sdk.api.abi.call({
        abi: abi['registry_futureVaultCount'],
        target: registry,
        block,
        chain,
      })
    // futureVaultCount = 2
    const {output: futureVaults} = await sdk.api.abi.multiCall({
        abi: abi['registry_getFutureVaultAt'],
        calls:  [...Array(parseInt(futureVaultCount)).keys()].map((i) => ({
          target: registry,
          params: i,
        })),
        block,
        chain,
      })
    const {output: IBTAddressTokens} = await sdk.api.abi.multiCall({
      abi: abi['registry_getIBTAddress'],
      calls: futureVaults.map((vault) => ({
        target: vault.output,
      })),
      block,
      chain,
    })
    // Unwrap tokens amount held by each vault
    const tokensAndOwners = IBTAddressTokens.map(t => [t.output, t.input.target])
    await sumTokens(balances, tokensAndOwners, block, chain, transform[chain]) 
    
    // ------------------------------
    // B. Also get AMM pools balances (get pools and underlyings balances)
    const ammPools = (await sdk.api.abi.multiCall({
      abi: abi['ammregistry_getFutureAMMPool'],
      calls: futureVaults.map((vault) => ({
        target: AMMregistry,
        params: vault.output,
      })),
      block,
      chain,
    })).output.filter(v=>v.output !== "0x0000000000000000000000000000000000000000")
    const {output: underlyingOfIBTAddresses} = await sdk.api.abi.multiCall({
      abi: abi['ammPool_getUnderlyingOfIBTAddress'],
      calls: ammPools.map((vault) => ({
        target: vault.output,
      })),
      block,
      chain,
    })
    // Get the amm pools underlying tokens balances
    const tokensAndOwnersAMM = underlyingOfIBTAddresses.map( (t, i) => [t.output, ammPools[i].output] )
      .concat(underlyingOfIBTAddresses.map((t, i) => [t.output, ammPools[i].output]))
    // Use FYTAddresses in the concat to get balances of FYT
    // Use underlyingOfIBTAddresses in concat to mimic a twice
    await sumTokens(balances, tokensAndOwnersAMM, block, chain, transform[chain]) 

    // const {output: FYTAddresses} = await sdk.api.abi.multiCall({
    //   abi: abi['ammPool_getFYTAddress'],
    //   calls: ammPools.map((vault) => ({
    //     target: vault.output,
    //   })),
    //   block,
    //   chain,
    // })
    // let transform_to_underlying = (addr) => {
    //   const idx = FYTAddresses.map(c => c.output).indexOf(addr)
    //   if (idx >= 0) {
    //     return transform[chain](underlyingOfIBTAddresses[idx].output)
    //   } 
    //   return transform[chain](addr)
    // }
    // transform_to_underlying = transform[chain]

    // ------------------------
    // Handle wrapped pools in balances - like curvePools, etc
    for (let i = 0; i < 2; i++) { // since crvTriCrypto contains am3crv, unwrap twice
      for (const token of Object.keys(balances)) {
        if (Object.keys(tokensToUnwrap).includes(token) && balances[token] > 0) {
          if (tokensToUnwrap[token].type === 'crv') {
            await unwrapCrv(balances, tokensToUnwrap[token].unwrapTo, balances[token], block, chain, transform[chain]) 
          }
          balances[token] = 0 // Once unwrapped, set balance of wrapped curve token to zero
          // console.log('unwrapping', token, balances)
        }
      }
    }

    console.log(`balances for chain ${chain}`, balances) 
    return balances
  }
}

module.exports = {
  doublecounted: true,
  ethereum: {
    tvl: tvl_from_registry('ethereum'),
    staking: staking(veAPW, APW, "ethereum"), 
  },
  polygon: {
    tvl: tvl_from_registry('polygon'), 
    pool2: pool2s([APW_WETH_cometh_staking, APW_MUST_cometh_staking], [APW_WETH_cometh, APW_MUST_cometh], "polygon", id=>`polygon:${id}`)
  },
  methodology: `Use the registry to retrieve futureVaults, and get for each vault the IBT which is the token that this vault holds - the user locked collateral`
}

'''
'''--- projects/apyfinance/abi.json ---
{
    "underlyer": {
        "inputs": [],
        "name": "underlyer",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getPoolTotalValue":{"inputs":[],"name":"getPoolTotalValue","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/apyfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require('bignumber.js')

const liquidityContracts = [
  // DAI Liquidity
  "0x75CE0E501e2E6776FcAAa514f394a88a772A8970",
  // USDC Liquidity
  "0xe18b0365D5D09F394f84eE56ed29DD2d8D6Fba5f",
  // USDT Liquidity
  "0xeA9c5a2717D5Ab75afaAC340151e73a7e37d99A7",
];

const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const underlyers = (
    await sdk.api.abi.multiCall({
      abi: abi.underlyer,
      calls: liquidityContracts.map((lc) => ({
        target: lc,
      })),
      block: ethBlock,
    })
  ).output.map((underlyer) => underlyer.output);

  const balance = (
    await sdk.api.abi.multiCall({
      abi: abi.getPoolTotalValue,
      calls: underlyers.map((nd, idx) => ({
        target: liquidityContracts[idx],
      })),
      block: ethBlock,
    })
  ).output.map((bal) => bal.output);

  for (let index = 0; index < underlyers.length; index++) {
    sdk.util.sumSingleBalance(balances, `${underlyers[1]}`, BigNumber(balance[index]).div(10**2).toFixed(0));
  }

  return balances;
};

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
  methodology: `The TVL for APY.Finance can be found in three contract addresses. Each address corresponds to the type of token that can be deposited, DAI, USDC, and USDT. After having the balance for each address, they are simply added together to get the total TVL.`
};

'''
'''--- projects/aquarius/getEntireSystemColl.abi.json ---
{
  "inputs": [],
  "name": "getEntireSystemColl",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "entireSystemColl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/aquarius/index.js ---
const sdk = require("@defillama/sdk");
const getEntireSystemCollAbi = require("./getEntireSystemColl.abi.json")
const {getLiquityTvl} = require('../helper/liquity')

const FTM_ADDRESS = '0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83';
const TROVE_MANAGER_ADDRESS = "0xC87D230B3239d1A90463463d8adDFD70709D391b";
/*
async function tvl(_, _ethBlock, chainBlocks) {
  const balance = (
    await sdk.api.abi.call({
      target: TROVE_MANAGER_ADDRESS,
      abi: getEntireSystemCollAbi,
      block: chainBlocks['fantom'],
      chain: 'fantom'
    })
  ).output;

  return { [FTM_ADDRESS]: balance };
}
*/
module.exports = {
  tvl: getLiquityTvl(FTM_ADDRESS,TROVE_MANAGER_ADDRESS,"fantom"),
  methodology: `Aquarius does not run its own web interface deposits for it's TVL are made at third-party frontend operators incetivized with the AQU token. TVL consists of deposits made to mint aUSD.`
};

'''
'''--- projects/ara-finance/index.js ---
const { ohmTvl } = require("../helper/ohm");

const ara = "0x2ced20fdfcbe72c27a607d0c9ab1c9ada598c60f";
const stakingContract = "0x19672375464ccbf1f8c6c7c32d8d8987d27262a5";
const treasuryContract = "0x674969110CA4004A804eeA5043CD9302996900AC";

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasuryContract, [
        ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
        ["0x9dd1cde570b96ba13e63d317e23637651142227c", true] // araMimJLP
    ], "avax", stakingContract, ara, undefined, undefined, false)
}
'''
'''--- projects/arable-protocol/index.js ---
const { staking } = require("../helper/staking");
const { pool2Exports } = require("../helper/pool2");

const acre = "0x00ee200df31b869a321b10400da10b561f3ee60d";
const stakingContract = "0x4bc722Cd3F7b29ae3A5e0a17a61b72Ea5020502B";
const farming = "0x598EBAC38cF211749b1277c9a34d217226A476Af";
const acrewavaxpgl = "0x64694FC8dFCA286bF1A15b0903FAC98217dC3AD7";

module.exports = {
    avalanche: {
        tvl: async () => ({}),
        staking: staking(stakingContract, acre, "avax"),
        pool2: pool2Exports(farming, [acrewavaxpgl], "avax")
    }
}
'''
'''--- projects/arbicheems/index.js ---
const sdk = require("@defillama/sdk");
const { stakingUnknownPricedLP } = require("../helper/staking");
const { pool2Exports } = require("../helper/pool2");

const cheems = "0x75a2f30929C539E7d4eE033c9331b89F879c0cf7";
const stakingContract = "0xaaCcB989FE1084c6935f09aE4BBD49AfF58Bdb94";

const mim = "0xfea7a6a0b346362bf88a9e4a88416b77a57d6c2a";
const mimPool = "0x79F12596B78F9E982bDaB6e2d83D4bc155672372";
const ethPool = "0xd495Beb0011e3DFEC0C93376f5216C1C3dD01C23";

const cheemsEthPool = "0x1382EcDf09507ba87022c79312DfAfb2A5063d73";
const cheemsEthSLP = "0xce786f1f3d3025fe4a64e37d28fa76311ff5253f";

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};

  const ethBal = (
    await sdk.api.eth.getBalance({
      target: ethPool,
      block: chainBlocks.arbitrum,
      chain: "arbitrum",
    })
  ).output;
  sdk.util.sumSingleBalance(
    balances,
    "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    ethBal
  );

  const mimBal = (
    await sdk.api.erc20.balanceOf({
      target: mim,
      owner: mimPool,
      block: chainBlocks.arbitrum,
      chain: "arbitrum",
    })
  ).output;
  sdk.util.sumSingleBalance(balances, `arbitrum:${mim}`, mimBal);

  return balances;
}

module.exports = {
  arbitrum: {
    tvl,
    staking: stakingUnknownPricedLP(
      stakingContract,
      cheems,
      "arbitrum",
      cheemsEthSLP,
      (addr) => `arbitrum:${addr}`
    ),
    pool2: pool2Exports(
      cheemsEthPool,
      [cheemsEthSLP],
      "arbitrum",
      (addr) => `arbitrum:${addr}`
    ),
  },
};

'''
'''--- projects/arbinyan/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const BigNumber = require("bignumber.js");
const { getBlock } = require("../helper/getBlock");

const stakingETHContract = "0x9F7968de728aC7A6769141F63dCA03FD8b03A76F";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";

const stakingNYANContract = "0x32e5594F14de658b0d577D6560fA0d9C6F1aa724";
const NYAN = "0xed3fb761414da74b74f33e5c5a1f78104b188dfc";

const stakingPool2Contract = "0x62FF5Be795262999fc1EbaC29277575031d2dA2C";
const NYAN_WETH_SLP = "0x70Df9Dd83be2a9F9Fcc58Dd7C00d032d007b7859";
const WETH_arb = "0x82af49447d8a07e3bd95bd0d56f35241523fbab1";

async function pool2(time, ethBlock, chainBlocks) {
  const balances = {};

  const balance_slp = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: NYAN_WETH_SLP,
      params: stakingPool2Contract,
      chain: "arbitrum",
      block: chainBlocks["arbitrum"],
    })
  ).output;

  const totalSupply_slp = (
    await sdk.api.erc20.totalSupply({
      target: NYAN_WETH_SLP,
      chain: "arbitrum",
      block: chainBlocks["arbitrum"],
    })
  ).output;

  const underlyingsBalance = (
    await sdk.api.abi.multiCall({
      calls: [NYAN, WETH_arb].map((token) => ({
        target: token,
        params: NYAN_WETH_SLP,
      })),
      abi: 'erc20:balanceOf',
      chain: "arbitrum",
      block: chainBlocks["arbitrum"],
    })
  ).output;

  underlyingsBalance.forEach((call) => {
    const underlyingSetBalance = BigNumber(call.output)
      .times(balance_slp)
      .div(totalSupply_slp);

    sdk.util.sumSingleBalance(
      balances,
      `arbitrum:${call.input.target}`,
      underlyingSetBalance.toFixed(0)
    );
  });

  return balances;
}

async function arbTvl(time, _ethBlock, chainBlocks) {
  const block = await getBlock(time, "arbitrum", chainBlocks);
  const eth = await sdk.api.eth.getBalance({
    target: stakingETHContract,
    block,
    chain: "arbitrum",
  });
  return {
    [WETH]: eth.output,
  };
}

module.exports = {
  misrepresentedTokens: true,
  arbitrum: {
    staking: staking(stakingNYANContract, NYAN, "arbitrum"),
    pool2: pool2,
    tvl: arbTvl,
  },
  methodology:
    "Counts as TVL the ETH asset deposited through StakingETH Contract, and we count Staking and Pool2 parts in the same way",
};

'''
'''--- projects/arbirise-finance/abis/arbiStakerERC20.json ---
{
  "stakedTokenTotal": {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "stakedTokenTotal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getNumTokensStaked": {
    "inputs": [],
    "name": "getNumTokensStaked",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "num",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getTokenStakedAt": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "name": "getTokenStakedAt",
    "outputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/arbirise-finance/abis/getPair.json ---
{
  "constant": true,
  "inputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    },
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "name": "getPair",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/arbirise-finance/abis/getReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
    {
      "internalType": "uint112",
      "name": "_reserve0",
      "type": "uint112"
    },
    {
      "internalType": "uint112",
      "name": "_reserve1",
      "type": "uint112"
    },
    {
      "internalType": "uint32",
      "name": "_blockTimestampLast",
      "type": "uint32"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/arbirise-finance/abis/token0.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token0",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/arbirise-finance/contracts.json ---
{
  "arbiStaker": "0x6a894bd1A5476Bdc52B709623B8751e244E6e975",
  "sushiFactoryAddress": "0xc35DADB65012eC5796536bD9864eD8773aBc74C4",
  "weth": "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
  "usdc": "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
  "usdcWethPair": "0x905dfCD5649217c42684f23958568e533C711Aa3"
}

'''
'''--- projects/arbirise-finance/getPrice.js ---
const sdk = require("@defillama/sdk");
const getPair = require("./abis/getPair.json");
const getReserves = require("./abis/getReserves.json");
const token0 = require("./abis/token0.json");
const contracts = require("./contracts.json");
const { default: BigNumber } = require("bignumber.js");
const { getBlock } = require("../helper/getBlock");

const getETHPrice = async (block) => {
  const reserves = (
    await sdk.api.abi.call({
      target: contracts["usdcWethPair"],
      abi: getReserves,
      block: block,
      chain: "arbitrum",
    })
  ).output;

  const _token0 = (
    await sdk.api.abi.call({
      target: contracts["usdcWethPair"],
      abi: token0,
      block: block,
      chain: "arbitrum",
    })
  ).output;

  const WETHReserve = new BigNumber(
    _token0.toLowerCase() === contracts["weth"].toLowerCase()
      ? reserves._reserve0
      : reserves._reserve1
  ).div(1e18);
  const USDCReserve = new BigNumber(
    _token0.toLowerCase() === contracts["usdc"].toLowerCase()
      ? reserves._reserve0
      : reserves._reserve1
  ).div(1e6);

  return new BigNumber(USDCReserve).div(new BigNumber(WETHReserve));
};

const getPrice = async (tokenAddress, block) => {
  try {
    const ETHPrice = await getETHPrice(block);

    const symbol = (
      await sdk.api.abi.call({
        target: tokenAddress,
        abi: "erc20:symbol",
        chain: "arbitrum",
        block
      })
    ).output;

    const isLp = symbol === "SLP";

    if (tokenAddress.toLowerCase() === contracts["weth"].toLowerCase()) {
      return { price: ETHPrice, decimals: 18 };
    }

    const pairAddress = isLp
      ? tokenAddress
      : (
          await sdk.api.abi.call({
            target: contracts["sushiFactoryAddress"],
            abi: getPair,
            params: [tokenAddress, contracts["weth"]],
            block: block,
            chain: "arbitrum",
          })
        ).output;

    const reserves = (
      await sdk.api.abi.call({
        target: pairAddress,
        abi: getReserves,
        block: block,
        chain: "arbitrum",
      })
    ).output;

    const _token0 = (
      await sdk.api.abi.call({
        target: pairAddress,
        abi: token0,
        block: block,
        chain: "arbitrum",
      })
    ).output;

    const decimals = (
      await sdk.api.abi.call({
        target: tokenAddress,
        abi: "erc20:decimals",
        chain: "arbitrum",
        block
      })
    ).output;

    const WETHReserve = new BigNumber(
      _token0.toLowerCase() === contracts["weth"].toLowerCase()
        ? reserves._reserve0
        : reserves._reserve1
    ).div(1e18);
    const tokenReserve = new BigNumber(
      _token0.toLowerCase() === tokenAddress.toLowerCase()
        ? reserves._reserve0
        : reserves._reserve1
    ).div(`1e${decimals}`);

    if (isLp) {
      const totalSupply = (
        await sdk.api.abi.call({
          target: tokenAddress,
          abi: "erc20:totalSupply",
          chain: "arbitrum",
          block
        })
      ).output;

      return {
        price: new BigNumber(WETHReserve)
          .times(ETHPrice)
          .times(2)
          .div(new BigNumber(totalSupply).div(`1e${decimals}`)),
        decimals,
      };
    }

    const priceInETH = new BigNumber(tokenReserve).div(
      new BigNumber(WETHReserve)
    );

    return {
      price: ETHPrice.div(priceInETH),
      decimals,
    };
  } catch (e) {
    return {
      price: new BigNumber(0),
      decimals: 0,
    };
  }
};

module.exports = {
  getPrice,
};

'''
'''--- projects/arbirise-finance/index.js ---
const sdk = require("@defillama/sdk");
const { getBlock } = require("../helper/getBlock");
const arbiStakerERC20 = require("./abis/arbiStakerERC20.json");
const contracts = require("./contracts.json");
const { default: BigNumber } = require("bignumber.js");
const { getPrice } = require("./getPrice");

async function tvl(time, _ethBlock, chainBlocks) {
  const block = await getBlock(time, "arbitrum", chainBlocks);

  const nbOfPrograms = (
    await sdk.api.abi.call({
      block,
      target: contracts["arbiStaker"],
      abi: arbiStakerERC20["getNumTokensStaked"],
      chain: "arbitrum",
    })
  ).output;

  const stakingTokens = (
    await sdk.api.abi.multiCall({
      block,
      abi: arbiStakerERC20["getTokenStakedAt"],
      calls: [...Array(+nbOfPrograms).keys()].map((index) => ({
        target: contracts["arbiStaker"],
        params: index,
      })),
      chain: "arbitrum",
    })
  ).output.map((o) => o.output);

  const stakedByProgram = (
    await sdk.api.abi.multiCall({
      block,
      abi: arbiStakerERC20["stakedTokenTotal"],
      calls: stakingTokens.map((token) => ({
        target: contracts["arbiStaker"],
        params: token,
      })),
      chain: "arbitrum",
    })
  ).output;

  let balances = {};

  for (let i = 0; i < stakedByProgram.length; i++) {
    const { price, decimals } = await getPrice(
      stakedByProgram[i].input.params[0],
      block
    );
    const staked = new BigNumber(stakedByProgram[i].output).div(
      `1e${decimals}`
    );
    // Adding USDC decimals (6)again here `price.times(staked).times(1e6)` because `sumSingleBalance` will remove them
    const rewardProgramTVL = price.times(staked).times(1e6).toFixed(0);
    sdk.util.sumSingleBalance(
      balances,
      `arbitrum:${contracts["usdc"]}`,
      rewardProgramTVL
    );
  }

  return balances;
}

module.exports = {
  methodology:
    "TVL is calculated by summing up all reward program total staked values.",
  arbitrum: {
    tvl,
  },
};

'''
'''--- projects/arbis.js ---
const { staking } = require('./helper/staking')
const sdk = require('@defillama/sdk')
const { unwrapLPsAuto } = require('./helper/unwrapLPs')
const { getChainTransform } = require('./helper/portedTokens')

const chain = 'arbitrum'

async function tvl(_, _b, { [chain]: block}) {
  const balances = {}
  const transformAddress = await getChainTransform(chain)
  const vaults1 = [
    '0x47a156668F1Ecc659Efbbf4910508Ace1b46a49b',
    '0xdc2d66044e894d0726570bdc03d2123ab8f2cd51',
    '0x5ec477eda75303450a4185b3557c2c2fbb85a9fc',
    '0x69f9a2eF122180366108583F2032DfB2030D8F96',
    '0x374e9F3AFFB6a2c3E388aA69c21D925C193aF13a',
    '0x1922c36f3bc762ca300b4a46bb2102f84b1684ab',
  ]
  const vaults = [
    '0x32e5594F14de658b0d577D6560fA0d9C6F1aa724',
    '0x62FF5Be795262999fc1EbaC29277575031d2dA2C',
    '0x2C5058325373d02Dfd6c08E48d91FcAf8fD49f45',
    '0xE340031b61A394c7811868ef81d2eacc79098BC2',
    '0xF6a37745FC911666132E8b8F29fC9c4F5C4a703D',
    '0xb970E280F9ddAA3349ab9F3ecf778970cDE46655',
  ]

  const { output: tokens } = await sdk.api.abi.multiCall({
    abi: abi.stakedToken,
    calls: vaults.map(i => ({ target: i})),
    chain, block,
  })

  const { output: deposits } = await sdk.api.abi.multiCall({
    abi: abi.totalSupply,
    calls: vaults.map(i => ({ target: i})),
    chain, block,
  })

  const { output: tokens1 } = await sdk.api.abi.multiCall({
    abi: abi.depositToken,
    calls: vaults1.map(i => ({ target: i})),
    chain, block,
  })

  const { output: deposits1 } = await sdk.api.abi.multiCall({
    abi: abi.totalDeposits,
    calls: vaults1.map(i => ({ target: i})),
    chain, block,
  })

  tokens.forEach((data, i) => {
    sdk.util.sumSingleBalance(balances, transformAddress(data.output), deposits[i].output)
  })

  tokens1.forEach((data, i) => {
    sdk.util.sumSingleBalance(balances, transformAddress(data.output), deposits1[i].output)
  })

  await unwrapLPsAuto({ balances, block, chain, })

  return balances
}

module.exports = {
  arbitrum: {
    tvl,
    staking: staking('0xBf00759D7E329d7A7fa1D4DCdC914C53d1d2db86', '0x9f20de1fc9b161b34089cbeae888168b44b03461', 'arbitrum')
  }
}

const abi = {
  depositToken: {
    "inputs": [],
    "name": "depositToken",
    "outputs": [
      {
        "internalType": "contract IPair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  totalDeposits: {
    "inputs": [],
    "name": "totalDeposits",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  stakedToken: {
    "inputs": [],
    "name": "stakedToken",
    "outputs": [
      {
        "internalType": "contract IPair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  totalSupply: {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
'''
'''--- projects/arch-ethereum-web-3/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens } = require('../helper/unwrapLPs');

const archEthereumWeb3AddressETH = "0xe8e8486228753E01Dbc222dA262Aa706Bd67e601";

const abi = {
  "inputs": [],
  "name": "getComponents",
  "outputs": [
    {
      "internalType": "address[]",
      "name": "",
      "type": "address[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

async function tvl(ts, block) {
  const { output: tokens } = await sdk.api.abi.call({ target: archEthereumWeb3AddressETH, abi, block })
  const toa = tokens.map(t => [t, archEthereumWeb3AddressETH])
  return sumTokens({}, toa, block)
}

module.exports = {
  ethereum: {
    tvl,
  },
};
'''
'''--- projects/arcx.js ---
const sdk = require("@defillama/sdk")
const BigNumber = require("bignumber.js")

const stARCx = '0x9bffad7a6d5f52dbc51cae33e419793c72fd7d9d'
const stakingContract = '0x9bffad7a6d5f52dbc51cae33e419793c72fd7d9d'
const ARCx = '0x1321f1f1aa541a56c31682c57b80ecfccd9bb288'

async function staking(timestamp, ethBlock, chainBlocks) {  
  const stakedARCx = (await sdk.api.abi.call({
      target: ARCx, 
      params: stakingContract,
      abi: 'erc20:balanceOf',
      block: ethBlock,
      chain: 'ethereum'
    })).output
  const balances = {
    [ARCx]: stakedARCx
  }
  return balances
}

module.exports = {
  methodology: "ARCx can be staked in the protocol",
  ethereum: {
    staking,
    tvl: () => ({})
  },
}

'''
'''--- projects/arenaswap/index.js ---
const sdk = require("@defillama/sdk");
const {addFundsInMasterChef} = require("../helper/masterchef");
const arena = "0x2A17Dc11a1828725cdB318E0036ACF12727d27a2";
const arenaMasterChef = "0xbEa60d145747a66CF27456ef136B3976322b7e77";
const pyram = "0xedeCfB4801C04F3EB394b89397c6Aafa4ADDa15B";
const pyramMasterChef = "0x3e91B21ddE13008Aa73f07BdE26970322Fe5D533";
const poolInfo = {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"poolInfo","outputs":[{"internalType":"contract IBEP20","name":"lpToken","type":"address"},{"internalType":"uint256","name":"allocPoint","type":"uint256"},{"internalType":"uint256","name":"lastRewardBlock","type":"uint256"},{"internalType":"uint256","name":"accArenaPerShare","type":"uint256"},{"internalType":"uint16","name":"depositFeeBP","type":"uint16"},{"internalType":"uint256","name":"harvestInterval","type":"uint256"}],"stateMutability":"view","type":"function"};

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, arenaMasterChef, chainBlocks.bsc, "bsc", addr => `bsc:${addr}`, poolInfo, [arena], true, false, arena);
    await addFundsInMasterChef(balances, pyramMasterChef, chainBlocks.bsc, "bsc", addr => `bsc:${addr}`, poolInfo, [pyram], true, false, pyram);
    return balances;
}

async function staking(timestamp, block, chainBlocks) {
    let balances = {};
    let arenaStakingBalance = (await sdk.api.erc20.balanceOf({
        target: arena,
        owner: arenaMasterChef,
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;
    sdk.util.sumSingleBalance(balances, `bsc:${arena}`, arenaStakingBalance);
    let pyramStakingBalances = (await sdk.api.abi.multiCall({
        calls: [
            {
                target: arena,
                params: pyramMasterChef
            },
            {
                target: pyram,
                params: pyramMasterChef
            }
        ],
        abi: "erc20:balanceOf",
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;
    for (let i in pyramStakingBalances) {
        sdk.util.sumSingleBalance(balances, `bsc:${pyramStakingBalances[i].input.target}`, pyramStakingBalances[i].output);
    }
    return balances;
}

module.exports = {
    methodology: "Counts value locked in farms and pools",
    bsc: {
        tvl,
        staking
    },
}
'''
'''--- projects/argano/index.js ---
const sdk = require('@defillama/sdk')
const { calculateUniTvl } = require('../helper/calculateUniTvl')
const { transformPolygonAddress } = require('../helper/portedTokens')

const contracts = {
    factory: '0xdAc31E70c2C4Fea0629e85e7B67222127A8672d8',
    usdtPool: '0x250EFcd45D9f83036f2D403223c7cCb2E1e9D00b',
    usdt: '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
    wbtcPool: '0x610094adF401626D6B62df62bF6E67A7A6E22043',
    wbtc: '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6'
};

async function tvl(timestamp, block, chainBlocks) {
    const transform = await transformPolygonAddress();
    let balances = await calculateUniTvl(
        transform, 
        chainBlocks.polygon, 
        'polygon', 
        contracts.factory, 
        23309648
    );

    const deposits = await sdk.api.abi.multiCall({
        calls: [{
            target: contracts.usdt,
            params: contracts.usdtPool
        }, {
            target: contracts.wbtc,
            params: contracts.wbtcPool
        }],
        abi: "erc20:balanceOf",
        chain: 'polygon',
        block: chainBlocks.polygon
    });

    await sdk.util.sumMultiBalanceOf(
        balances, 
        deposits,
        true,
        transform
    );

    return balances;
};

module.exports = {
    timetravel: true,
    misrepresentedTokens: false,
    polygon: {
        tvl
    }
};
'''
'''--- projects/argofinance/index.js ---
const { fetchURL } = require("../helper/utils");
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");
const cryptoOrgUrl = 'https://mainnet.crypto.org:1317/cosmos/staking/v1beta1/delegations/cro1klkxkl2c59m5dcw4w0683ctfaxklsy9py26jg3'

async function tvl(timestamp, chain) {
  const data = await fetchURL(cryptoOrgUrl)
  let total = new BigNumber(0)
  data.data.delegation_responses.forEach(delegation => {
    total = BigNumber.sum(total, new BigNumber(delegation.balance.amount))
  })
  let balance = {
    'cronos:0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23': total.multipliedBy(new BigNumber(10000000000), 10),
  }
  return balance
}

async function staking(timestamp, chain) {
  const { output: xargoBalance } = await sdk.api.erc20.totalSupply({ target: "0x1dE93ce995d1bC763c2422ba30b1E73dE4A45a01", chain: 'cronos' })
  
  const bigXArgoBalance = new BigNumber(xargoBalance)
  let balance = {
    "cronos:0x47A9D630dc5b28F75d3AF3be3AAa982512Cd89Aa": bigXArgoBalance
  }
  return balance
}

module.exports = {
  timetravel: false,
  methodology: `The TVL is counted as the total CRO that is currently being delegated. We query the crypto.org api for the delegations and sum up the CRO being delegated. The Staking TVL is computed as the total XARGO being pledged on our platform. ARGO and XARGO has a 1:1, with XARGO being a pledged version of ARGO. The Staking TVL is calculated by getting the totalSupply() of XARGO in our contract.`,
  cronos: {
    tvl,
    staking
  }
}
'''
'''--- projects/arkadiko.js ---
const retry = require("./helper/retry");
const axios = require("axios");
// node test.js projects/arkadiko.js
async function tvl() {
  let balances = {};
  const dikoPrice = (
    await retry(
      async (bail) =>
        await axios.get("https://arkadiko-api.herokuapp.com/api/v1/tokens/diko")
    )
  ).data["price_in_cents"];

  const response = (
    await retry(
      async (bail) =>
        await axios.get("https://arkadiko-api.herokuapp.com/api/v1/pools")
    )
  ).data;

  for (let pool of response.pools) {
    balances[pool.token_y_name] =
      pool.token_y_name in balances
        ? Number(balances[pool.token_y_name]) + Number(pool.tvl_token_y)
        : Number(pool.tvl_token_y);
    balances[pool.token_x_name] =
      pool.token_x_name in balances
        ? Number(balances[pool.token_x_name]) + Number(pool.tvl_token_x)
        : Number(pool.tvl_token_x);
  }

  balances["blockstack"] = balances["wrapped-stx-token"] / 10 ** 6;
  delete balances["wrapped-stx-token"];
  balances["usd-coin"] = balances["usda-token"] / 10 ** 6;
  delete balances["usda-token"];
  balances["usd-coin"] =
    Number(balances["usd-coin"]) +
    Number(balances["arkadiko-token"] / 10 ** 8) * dikoPrice;
  delete balances["arkadiko-token"];
  balances["wrapped-bitcoin"] = balances["Wrapped-Bitcoin"] / 10 ** 8;
  delete balances["Wrapped-Bitcoin"]

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  stacks: {
    tvl,
  },
};
// node test.js projects/arkadiko.js

'''
'''--- projects/armorfinance/abiNXMVault.json ---
{
  "aum": {
    "inputs": [],
    "name": "aum",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "aumTotal",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/armorfinance/index.js ---
const sdk = require("@defillama/sdk");
const utils = require("../helper/utils");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const abiNXMVault = require("./abiNXMVault.json");

const POOL_BUYCOVER_ACTION = "0xcafea35cE5a2fc4CED4464DA4349f81A122fd12b";
const NXM_VAULT = "0x1337DEF1FC06783D4b03CB8C1Bf3EBf7D0593FC4";
const DAI = "0x6b175474e89094c44da98b954eedeac495271d0f";
const NXM = "0xd7c49cee7e9188cca6ad8ff264c1da2e69d4cf3b";
const stETH = "0xae7ab96520de3a18e5e111b5eaab095312d7fe84";

// --- It only provides current, so better grab the addresses and use sdk ---
const endpointFarms = "https://armorfi.info/api/apy";

const ethTvl = async (timestamp, ethBlock) => {
  let balances = {};
  // --- Grab the tokens bal which are being deposited in pool via buyCover ---
  const ethBalPool = (
    await sdk.api.eth.getBalance({
      target: POOL_BUYCOVER_ACTION,
      block: ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(
    balances,
    "0x0000000000000000000000000000000000000000",
    ethBalPool
  );

  /*
     Apparently certain portion of the ETH deposited for buying covers are used to be swapped for stETH
     likely for yield
  */
  const stETHBal = (
    await sdk.api.erc20.balanceOf({
      target: stETH,
      owner: POOL_BUYCOVER_ACTION,
      block: ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, stETH, stETHBal);

  const daiBalPool = (
    await sdk.api.erc20.balanceOf({
      target: DAI,
      owner: POOL_BUYCOVER_ACTION,
      block: ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, DAI, daiBalPool);

  // --- AUM by the arNXM vault (wNXM bal + stake deposit) ---
  const aum = (
    await sdk.api.abi.call({
      abi: abiNXMVault.aum,
      target: NXM_VAULT,
      block: ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, NXM, aum);

  /*
     FarmController(0x0Bdb7976c34aB05E5a9031F258B8956f68ee29cf) does not have a method to catch the lenght of farms so we used API
  */
  let farmsInfo = (await utils.fetchURL(endpointFarms)).data.dailyapys.map(
    (farm) => ({
      contract_address: farm.contract_address,
      token_address: farm.token_address,
    })
  );

  let lpPositions = [];

  const lpReserves = (
    await sdk.api.abi.multiCall({
      block: ethBlock,
      abi: {
        constant: true,
        inputs: [],
        name: "getReserves",
        outputs: [
          { internalType: "uint112", name: "_reserve0", type: "uint112" },
          { internalType: "uint112", name: "_reserve1", type: "uint112" },
          {
            internalType: "uint32",
            name: "_blockTimestampLast",
            type: "uint32",
          },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
      },
      calls: farmsInfo.map((farm) => ({ target: farm.token_address })),
    })
  ).output.map((token) => token.output);

  const nonNull = lpReserves
    .map((el, idx) => {
      if (el != null) return idx;
    })
    .filter((el) => el != null);

  for (let i = 0; i < farmsInfo.length; i++) {
    const bal = (
      await sdk.api.erc20.balanceOf({
        target: farmsInfo[i].token_address,
        owner: farmsInfo[i].contract_address,
        block: ethBlock,
      })
    ).output;

    /*
        Filter out temp the portions which are from 1inch & Balancer, otherwise will trigger errors in 
        unwrapUniswapLPs fnc, built workaround later on
    */
    if (nonNull.includes(i)) {
      lpPositions.push({
        balance: bal,
        token: farmsInfo[i].token_address,
      });
    }
  }

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    ethBlock
  );

  return balances;
};

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
};

'''
'''--- projects/arrow/index.js ---
const utils = require("../helper/utils");
const SUNNY_POOLS = require("../helper/sunny-pools.json");

const { getMultipleAccountBuffers, getMultipleAccountsRaw } = require("../helper/solana");

const readTVL = async ({
  tokenA,
  tokenB,
  tokenAReserve,
  tokenBReserve,
  poolMint,
  tokenAccounts,
}) => {
  const accountData = await getMultipleAccountBuffers({
    tokenAReserve,
    tokenBReserve,
    poolMint,
  });
  if (accountData.sunnyPool === null) {
    return {};
  }

  const decimals = accountData.poolMint.readUInt8(44);
  const divisor = 10 ** decimals;

  const tokenAccountsData = (await getMultipleAccountsRaw(tokenAccounts))
    .map((account) => {
      if (account !== null) {
        return Buffer.from(account.data[0], account.data[1]);
      }
      return null;
    })
    .filter((d) => !!d);
  const totalTokens = tokenAccountsData
    .map((tad) =>
      // sorry, this code is a tad hacky
      Number(tad.readBigUInt64LE(64))
    )
    .reduce((acc, el) => acc + el, 0);
  const lpTokenTotalSupply = Number(accountData.poolMint.readBigUInt64LE(36));
  const poolShare = totalTokens / lpTokenTotalSupply;

  const reserveAAmount =
    Number(accountData.tokenAReserve.readBigUInt64LE(64)) / divisor;
  const reserveBAmount =
    Number(accountData.tokenBReserve.readBigUInt64LE(64)) / divisor;

  const poolTvlCoins = {};

  if (tokenA === tokenB) {
    poolTvlCoins[tokenA] =
      poolShare * reserveAAmount + poolShare * reserveBAmount;
  } else {
    poolTvlCoins[tokenA] = poolShare * reserveAAmount;
    poolTvlCoins[tokenB] = poolShare * reserveBAmount;
  }

  return poolTvlCoins;
};

async function tvl() {
  // a mapping of coin name to coin amount
  const tvlResult = {};

  // this is a mapping of token mint to list of token accounts
  // more details: https://github.com/arrowprotocol/arrowdex
  const arrowTokens = await utils.fetchURL(
    "https://raw.githubusercontent.com/arrowprotocol/arrowdex/master/data/token-accounts.json"
  );

  // Run these serially to avoid rate limiting issues
  for (const [poolMint, tokenAccounts] of Object.entries(arrowTokens.data)) {
    const sunnyPool = SUNNY_POOLS.find(
      (pool) => pool.relevantAccounts.lpTokenSPL === poolMint
    );
    if (!sunnyPool) {
      continue;
    }

    const poolTVL = await readTVL({
      tokenA: sunnyPool.tokenA,
      tokenB: sunnyPool.tokenB,
      tokenAReserve: sunnyPool.relevantAccounts.tokenAReserve,
      tokenBReserve: sunnyPool.relevantAccounts.tokenBReserve,
      poolMint,
      tokenAccounts,
    });

    for (const [tokenId, amount] of Object.entries(poolTVL)) {
      if (!tvlResult[tokenId]) {
        tvlResult[tokenId] = amount;
      } else {
        tvlResult[tokenId] += amount;
      }
    }
  }

  return tvlResult;
}

module.exports = {
  timetravel: false,
  methodology:
    'TVL counts LP token deposits made to Arrow Protocol. CoinGecko is used to find the price of tokens in USD, only the original "SOL" token price is used for all existing variations of the token.',
  solana: { tvl },
};

'''
'''--- projects/artemis/abi.json ---
{
    "poolInfo": {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "poolInfo",
      "outputs": [
        {
          "internalType": "contract IBEP20",
          "name": "lpToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "allocPoint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastRewardBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "accTreePerShare",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "depositFeeBP",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
}
'''
'''--- projects/artemis/index.js ---
const { default: axios } = require("axios");
const { toUSDTBalances } = require("../helper/balances");
const retry = require("../helper/retry");

const farmApi = "https://api.elision.farm/getFarmStats/harmony/artemis";

function tvl(pool2) {
  return async () => {
    let tvl = 0;
    let { data: farms } = await retry(async (bail) => await axios.get(farmApi));
    for (let i = 0; i < farms.length; i++) {
      if (farms[i].name.startsWith("MIS") || farms[i].name.endsWith("MIS")) {
        if(pool2){
          tvl += farms[i].farm_liquidity_usd;
        }
      } else {
        if(!pool2){
          tvl += farms[i].farm_liquidity_usd;
        }
      }
    }
    return toUSDTBalances(tvl);
  }
}

module.exports = {
  harmony: {
    pool2: tvl(true),
    tvl: tvl(false),
  }
};
'''
'''--- projects/arthswap/index.js ---
const { getUniTVL } = require("../helper/unknownTokens");
const { stakingPricedLP } = require("../helper/staking");

const FACTORIES = "0xA9473608514457b4bF083f9045fA63ae5810A03E";
const NATIVE_TOKEN_WASTAR = "0xAeaaf0e2c81Af264101B9129C00F4440cCF0F720";

const TOKENS = {
  WASTAR: NATIVE_TOKEN_WASTAR,
  WETH: "0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c",
  WBTC: "0xad543f18cFf85c77E140E3E5E3c3392f6Ba9d5CA",
  WBNB: "0x7f27352D5F83Db87a5A3E00f4B07Cc2138D8ee52",
  WSDN: "0x75364D4F779d0Bd0facD9a218c67f87dD9Aff3b4",
  MATIC: "0xdd90E5E87A2081Dcf0391920868eBc2FFB81a1aF",
  USDC: "0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98",
  USDT: "0x3795C36e7D12A8c252A20C5a7B455f7c57b60283",
  ARSW: "0xDe2578Edec4669BA7F41c5d5D2386300bcEA4678",
  DOT: "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
};

const STAKING_CONTRACTS = {
  astar: "0x42d175a498Cb517Ad29d055ea7DcFD3D99045404",
};

module.exports = {
  timetravel: true,
  methodology: "Arthswap Tvl Calculation",
  astar: {
    tvl: getUniTVL({
      factory: FACTORIES,
      chain: 'astar',
      coreAssets: Object.values(TOKENS),
    }),
    staking: stakingPricedLP(
      STAKING_CONTRACTS.astar,
      TOKENS.ARSW,
      "astar",
      "0x50497E7181eB9e8CcD70a9c44FB997742149482a",
      "arthswap"
    ),
  },
};

'''
'''--- projects/asgard-dao/index.js ---
const {ohmTvl} = require("../helper/ohm");

const treasury = "0xFb445ce1CFE11B86505dD293f1bE438fFaa4fF8c";
const treasuryTokens = [
    ["0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3", false], // DAI
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], // BUSD
    ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false], // WBNB
    ["0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", false], // CAKE
    ["0x55d398326f99059ff775485246999027b3197955", false], // USDT
    ["0xE119c951b68555d50eB6Aa54b5Cf0b854715CB2c", true], // ASGARD-WBNB CAKE LP
    ["0x11ceddd7a64ec79212d8ae9c8b46d23b8b750db0", true], // ASGARD-BUSD CAKE LP
    ["0xE5E926c8Ca7A44F7FFD900F5a88eA33E2B07162D", true] // ASGARD-DAI CAKE LP
];
const stakingAddress = "0xFdFC6a9717B33Ab43d066cFa686D0e374Cf2779b";
const stakingToken = "0xa5593837af2b99021fe657c80d70d2365F5CfD38";

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "bsc", stakingAddress, stakingToken)
}
'''
'''--- projects/asgardfinance/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const AsgardStaking = "0x4EA2bb6Df87F66cbea70818aE92f3A48F98EBC93";
const ASG = "0x0DC5189Ec8CDe5732a01F0F592e927B304370551";

const AsgardTreasury = "0x9D5818af130705F95444d78A55B4F3d85cBfCC13";

const DAI = "0x6b175474e89094c44da98b954eedeac495271d0f";
const ASG_DAI_SLP = "0x024cc95611d478dd367240e72c82662d9e390a6a";
const FRAX = "0x853d955acef822db058eb8505911ed77f175b99e";
const ASG_FRAX_SLP = "0x5696cd9054ce11625141f5ee2c65fc4d57c2a5ca";
const WUST = "0xa47c8bf37f92abed4a126bda807a7b7498661acd";
const ASG_UST_SLP = "0x5a1abc007f031aa58238f45941d965ce6892fdff";

/*** Staking of native token (ASG) TVL Portion ***/
const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const stakingBalance = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: ASG,
      params: AsgardStaking,
      block: ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, ASG, stakingBalance);

  return balances;
};

/*** Bonds TVL Portion (Treasury) ***
 * Treasury TVL consists of DAI, UST and FRAX balances + Sushi SLPs balance
 ***/
async function ethTvl(timestamp, block) {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [DAI, false],
      [FRAX, false],
      [WUST, false],
      [ASG_DAI_SLP, true],
      [ASG_FRAX_SLP, true],
      [ASG_UST_SLP, true],
    ],
    [AsgardTreasury],
    block
  );

  return balances;
}

module.exports = {
  ethereum: {
    staking,
    tvl: ethTvl,
  },
  methodology:
    "Counts DAI, DAI SLP (ASG-DAI), FRAX, FRAX SLP (ASG-FRAX), UST, UST SLP (ASG-UST) on the treasury",
};

'''
'''--- projects/asol/index.js ---
const {getTokenAccountBalance} = require('../helper/solana')

async function tvl() {
  return {
    "solana": await getTokenAccountBalance("4Bo98VrTYkHLbE9zoXx3tCD3qEDcGZFCZFksgyYPKdG9"),
    "msol": await getTokenAccountBalance("7n1AmrpywC84MdALohPBipAx1SYhjpSLjYFb2EuTV9wm"),
  }
}

module.exports = {
  timetravel: false,
  methodology:
    "aSOL TVL is computed by looking at the token balances of the accounts holding the stake pool tokens backing the aSOL Crate. The token accounts come from https://asol.so/#/admin.",
  tvl,
};

'''
'''--- projects/astar-dapps-staking/index.js ---
// const { ApiPromise, WsProvider } = require("@polkadot/api");

// const ASTR_DECIMALS = 18;

// async function tvl() {
//   const provider = new WsProvider("wss://astar.api.onfinality.io/public-ws");
//   const api = new ApiPromise({
//     provider,
//   });

//   await api.isReady;
//   const era = await api.query.dappsStaking.currentEra();
//   const result = await api.query.dappsStaking.generalEraInfo(era);
//   const tvl = result.unwrap().staked.valueOf();
//   const AstrLocked = tvl / 10 ** ASTR_DECIMALS;

//   return {
//     astar: AstrLocked,
//   };
// }

// module.exports = {
//   methodology:
//     "TVL considers ASTR tokens deposited to the Dapps-Staking program",
//   astar: { tvl },
// };

// This has been delisted

module.exports = {
  astar: {
    tvl: () => ({})
  }
}

'''
'''--- projects/astarexchange/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')

const WASTR = "0xEcC867DE9F5090F55908Aaa1352950b9eed390cD" // their own barely used version

module.exports = {
    misrepresentedTokens: true,
    methodology: "Astar Exchange Tvl Calculation",
    astar: {
        tvl: calculateUsdUniTvl("0x95f506E72777efCB3C54878bB4160b00Cd11cd84", "astar", WASTR,
            [
                '0xEcC867DE9F5090F55908Aaa1352950b9eed390cD', // ASTAR
                '0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98', // USDC
                '0xdd90E5E87A2081Dcf0391920868eBc2FFB81a1aF', // MATIC
                '0x75364D4F779d0Bd0facD9a218c67f87dD9Aff3b4', // WSDN
                '0x7f27352D5F83Db87a5A3E00f4B07Cc2138D8ee52', // BNB
            ], "astar"),
    }
}

'''
'''--- projects/astarfarm/abi.json ---
[
  {
    "inputs": [],
    "name": "stakedV2",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/astarfarm/index.js ---
const abi = require("./abi.json");
const sdk = require('@defillama/sdk')

const stakingContract = '0x992bad137Fc8a50a486B5C6375f581964b4A15FC'

module.exports = {
    astar: {
        tvl: async (ts, _block, { astar: block }) => {
            const { output: lockedAstar } = await sdk.api.abi.call({ target: stakingContract, block, abi: abi.find(i => i.name === 'stakedV2'), chain: 'astar' })
            return { 'astar': +lockedAstar / 1e18 }
        }
    }
}

'''
'''--- projects/astarnova/abi.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "pool",
      "type": "address"
    }
  ],
  "name": "tvlOfPool",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "tvl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/astarnova/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const BigNumber = require('bignumber.js')

const dashboard = '0x63d3b2d066c1247245B31252441B3B6744e5BeB1'
const pools = [
    '0x2426F33359ef3BC6cb80104D3e2C81D81c790D6F',
    '0x3ad9F054454E948D0016aaa568D05b22CE1B7b37',
    '0xa573fd50404ffFa247Ea5B74ecC24EB9574300F0',
    '0xf1819937dE70179D0dcBf81dDBe372e5b5A4F1Fc',
    '0xe1bA9549DCf544c225BF7352803814fA8248F53F',
    '0x344fd0308a00db704b05Bd95760160C660787a38',
    '0x8b332a0EaEe5F774AfB344D39D1F643f2B98Db80',
    '0x5a28E0a888bf710248Ab27914168b2EB7F930cb8',
    '0x812A2EB0094aCB81337150E768De9CAbc13E1580',
    '0xd854566C787548172Ada3e17724045107b2412C3',
    '0x989f69D2C64E53f93DBfb5cE1eC62294f915Bc0C'
]

const ZERO = new BigNumber(0)
const USDC = new BigNumber(10).pow(6)

async function astar(timestamp, ethBlock, chainBlock) {
    const block = chainBlock.astar
    const total = (await sdk.api.abi.multiCall({
        calls: pools.map( address => ({
            target: dashboard,
            params: address
        })),
        block,
        abi: abi,
        chain: 'astar'
    })).output.reduce((tvl, call) => tvl.plus(new BigNumber(call.output)), ZERO)
        
    return {
        'tether': total.dividedBy(USDC).toNumber()
    }
}

module.exports = {
    misrepresentedTokens: true,
    astar:{
        tvl: astar
    },
}

'''
'''--- projects/astral.js ---
const utils = require("./helper/utils");
 var chainId;
 var vault;

 async function fetch() {
   const response = await utils.fetchURL("https://api.astral.financial/tvl");

   let tvl = 0;
   for (chainId in response.data) {
     const chain = response.data[chainId];

     for (vault in chain) {
       tvl += chain[vault];
     }
   }

   return tvl;
 }

 module.exports = {
   methodology:
     'TVL data is pulled from the Astral Financial API "https://api.astral.financial/tvl".',
   fetch,
 };
'''
'''--- projects/astralfarm/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking, stakingPricedLP } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0x13E5A680606aB4965d09B1997486C715dE225EBE"
const astral = "0xd95322C0D069B51a41ed2D94A39617C2ACbcE636"
const astralFtmLP = "0x93E7752e611B2cD808E546E7FdA5512a89A91d4D"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [astral, astralFtmLP],true,true,astral);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: stakingPricedLP(chef, astral, "fantom",astralFtmLP, "fantom"),
      pool2: pool2Exports(chef, [astralFtmLP], "fantom"),
  },

} // node test.js projects/astralfarm/index.js
'''
'''--- projects/astriddao/abi/ActivePool.abi.json ---
{
  "getCOL": {
    "inputs": [],
    "name": "getCOL",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/astriddao/abi/DefaultPool.abi.json ---
{
  "getCOL": {
    "inputs": [],
    "name": "getCOL",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/astriddao/index.js ---
const { sumTokens } = require('../helper/unwrapLPs')
const { getFixBalances } = require('../helper/portedTokens')

const chain = 'astar'

const COLLATERALS = {
  WASTAR: {
    tokenAddress: "0x19574c3c8fafc875051b665ec131b7e60773d2c9",
    contracts: {
      activePool: "0x70724b57618548eE97623146F76206033E67086e",
      defaultPool: "0x2fE3FDf91786f75C92e8AB3B861588D3D051D83F",
    }
  },
  BUSD: {
    tokenAddress: "0x4Bf769b05E832FCdc9053fFFBC78Ca889aCb5E1E",
    bridgeTokenMapping: "0x4fabb145d64652a948d72533023f6e7a623c7c53",
    contracts: {
      activePool: "0x892af684Afd5fCee1023f7811C35fd695Bf0cd6f",
      defaultPool: "0xe487b9066A8fFde840b29892f1052CBEdccc3073",
    }
  },
  DAI: {
    tokenAddress: "0x6De33698e9e9b787e09d3Bd7771ef63557E148bb",
    bridgeTokenMapping: "0x6b175474e89094c44da98b954eedeac495271d0f",
    contracts: {
      activePool: "0xCE90059FbCEc696634981945600d642A79e262aD",
      defaultPool: "0x3aD8FE12674B4c9481d5C7585ed5bDC4E35025b9",
    }
  },
  DOT: {
    tokenAddress: "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
    contracts: {
      activePool: "0x8cd0b101838b082133e25eEb76C916Ae2AC56f36",
      defaultPool: "0x4e8B4867899A69bB05EFa6A16e68363C2BBeB02f",
    }
  },
  USDC: {
    tokenAddress: "0x6a2d262d56735dba19dd70682b39f6be9a931d98",
    bridgeTokenMapping: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    contracts: {
      activePool: "0x5070d543654D866964C44E610a3b7f85fcAf2859",
      defaultPool: "0xEb80f1a9ede36412cF26E1e35ae74dbA30cCfF02",
    }
  },
  WETH: {
    tokenAddress: "0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c",
    contracts: {
      activePool: "0x5Ec419F08602caE5e4C591dE65bD640d66673035",
      defaultPool: "0x2eE0F3daa042af6Fdd56f0194d5aBfdA0A723D95",
    }
  },
  WBTC: {
    tokenAddress: "0xad543f18cFf85c77E140E3E5E3c3392f6Ba9d5CA",
    bridgeTokenMapping: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    contracts: {
      activePool: "0x1685E4f68FD9A50246ce92F0eb07a977591F5Ba2",
      defaultPool: "0xD69eB04d9ff456A31Da6D2a20538512C433ac1Ca",
    }
  },
}

const BAI_TOKEN_ADDRESS = "0x733ebcC6DF85f8266349DEFD0980f8Ced9B45f35"
const STAKES = {
  WASTAR: {
    contracts: {
      stabilityPool: "0x7e3D1e75C8deef26d659B2fb7b7E436ab8Ea35d9"
    }
  },
  BUSD: {
    contracts: {
      stabilityPool: "0x2D95D9191F12a17D61B3a1904581DceFd2C6e3eD"
    }
  },
  DAI: {
    contracts: {
      stabilityPool: "0xA5Bb226e06732005Cf6053429B8F6d607A8A530a"
    }
  },
  DOT: {
    contracts: {
      stabilityPool: "0xB333a7a951DC495bA7F27999cD41361AAafb6BE0"
    }
  },
  USDC: {
    contracts: {
      stabilityPool: "0x3598e5Aa98FDa59261b7372D68C116ad7220716D"
    }
  },
  WETH: {
    contracts: {
      stabilityPool: "0x19Af5DA5770d17808aA9b0011a47693379f338DD"
    }
  },
  WBTC: {
    contracts: {
      stabilityPool: "0x9A64Af13Cd72212ab0D812BEB839Fa93692E8B9F"
    }
  },
}

const BRIDGE_TOKEN_MAPPINGS = {}
for (const collateralInfo of Object.values(COLLATERALS)) {
  if (collateralInfo.bridgeTokenMapping) {
    BRIDGE_TOKEN_MAPPINGS[collateralInfo.tokenAddress] = collateralInfo.bridgeTokenMapping;
  }
}

function translateBalancesForBridgeToken(balances) {
  const translatedBalances = {};
  for (const key in balances) {
    if (key in BRIDGE_TOKEN_MAPPINGS) {
      translatedBalances[BRIDGE_TOKEN_MAPPINGS[key]] = balances[key]
    } else {
      translatedBalances[key] = balances[key]
    }
  }
  return translatedBalances
}

async function tvl(ts, _block, chainBlocks ) {
  const block = chainBlocks[chain]
  let balances = {}
  for (const collateralInfo of Object.values(COLLATERALS)) {
    const tokensAndOwners = Object.values(collateralInfo.contracts).map(owner => [collateralInfo.tokenAddress, owner])
    await sumTokens(balances, tokensAndOwners, block, chain)
  }
  for (const stakeInfo of Object.values(STAKES)) {
    const tokensAndOwners = Object.values(stakeInfo.contracts).map(owner => [BAI_TOKEN_ADDRESS, owner])
    await sumTokens(balances, tokensAndOwners, block, chain)
  }
  balances = translateBalancesForBridgeToken(balances)
  ;(await getFixBalances(chain))(balances)
  return balances
}

module.exports = {
  timetravel: true,
  start: 915830,
  methodology: "Total locked collateral assets (in ERC-20 form) in ActivePool and DefaultPool, plus total staked BAI in StabilityPool",
  astar: {
    tvl,
  },
};

'''
'''--- projects/astroport/index.js ---
const {getFactoryTvl} = require('../terraswap/factoryTvl')

module.exports = {
    timetravel: false,
    misrepresentedTokens: true,
    methodology: "Liquidity on the DEX",
    terra: {
        tvl: getFactoryTvl(
            "terra1fnywlw4edny3vw44x04xd67uzkdqluymgreu7g"
        )
    },
    terra2: {
        tvl: getFactoryTvl(
            "terra14x9fr055x5hvr48hzy2t4q7kvjvfttsvxusa4xsdcy702mnzsvuqprer8r", 
            true
        )
    }
} // node test.js projects/astroport/index.js
'''
'''--- projects/astroswap.js ---
const { request, gql } = require("graphql-request");
var url = "https://thegraph.astroswap.app/subgraphs/name/astro";

async function fetch(timestamp) {
  var query = gql`
    query overviewCharts {
      pancakeDayDatas(
        first: 1000
        skip: 0
        where: { 
            date_gte: ${timestamp - 86400} 
            date_lt: ${timestamp}
        }
        orderBy: date
        orderDirection: asc
      ) {
        totalLiquidityUSD
      }
    }
  `;
  const response = await request(url, query);
  return response.pancakeDayDatas[0].totalLiquidityUSD;
}

module.exports = {
  timetravel: false,
  fetch,
};

'''
'''--- projects/astrowar-finance/index.js ---
const { sumTokens } = require('../helper/unwrapLPs')
const { getPoolInfo, } = require('../helper/masterchef')
// Enso finance TVL lies for now in the index tokens held by the liquidityMigration contracts

async function tvl(timestamp, _block, { harmony: block }) {
    const stakePool = '0x1B7084DD5A3874C7DE8ff3e7AA668290f0613Afb';
    const masterChef = '0x50bca04eb01e4B66cBb04dcdFA872D23942D0B00';
    const standardPoolInfoAbi = { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "poolInfo", "outputs": [{ "internalType": "contract IERC20", "name": "lpToken", "type": "address" }, { "internalType": "uint256", "name": "allocPoint", "type": "uint256" }, { "internalType": "uint256", "name": "lastRewardBlock", "type": "uint256" }, { "internalType": "uint256", "name": "accWeVEPerShare", "type": "uint256" }], "stateMutability": "view", "type": "function" }
    const chain = 'harmony'
    const poolInfo = await getPoolInfo(masterChef, block, chain, standardPoolInfoAbi)
    const toa = poolInfo.map(i => [i.output[0], stakePool])
    return sumTokens({}, toa, block, chain, undefined, { resolveLP: true })
}

module.exports = {
    deadFrom: 1650564340,
    harmony: {
        tvl
    }
};
'''
'''--- projects/athena-money/index.js ---
const { tombTvl } = require("../helper/tomb");

const athena = "0x5C2dA48241d3bE9626dd0c48081c76DBb6D1046E";
const ashare = "0xBEcc61601c59d5aFFFE750D201eC98CdC70DB796";
const senate = "0x1Dc0A29e51521E2e9262b91E6E78F4c15A4B7A1a";
const aShareRewardPool = "0x8E57FbcA4191Baf208AfdAe4E7b5591423427f38"; //ashare reward pool

const pool2LPs = [
    "0xc881c93ebb075b3c80f16bc9e513a7784f794ef9",
    "0xc89c09a04440b7952790969ef470f8215bce4804"
]

module.exports = {
    misrepresentedTokens: true,
    ...tombTvl(athena, ashare, aShareRewardPool, senate, pool2LPs, "moonriver", undefined, false, pool2LPs[1])
}

'''
'''--- projects/atlantisloans/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { compoundExports } = require("../helper/compound");

const comptroller = "0xE7E304F136c054Ee71199Efa6E26E8b0DAe242F3";

const vaultStakingContract = "0x9aFc9877b1621e414E907F13A8d3ED9511bE03de";
const ATL = "0x1fD991fb6c3102873ba68a4e6e6a87B3a5c10271";

const lpVaultStakingContract = "0xC7A5Bb6FCd603309D7a010de44dcBDe26fD45B58";
const ALT_BUSD_CakeLP = "0xaa40dc3ec6ad76db3254b54443c4531e3dfe6bdb";

module.exports = {
  misrepresentedTokens: true,
  timetravel: true,
  doublecounted: false,
  bsc: {
    pool2: pool2(lpVaultStakingContract, ALT_BUSD_CakeLP, "bsc"),
    staking: staking(vaultStakingContract, ATL, "bsc"),
    ...compoundExports( comptroller,
      "bsc",
      "0x5A9A90983A369b6bB8F062f0AFe6219Ac01caF63",
      "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"
    ),
  },
  methodology:
    "Same as compound, we just get all the collateral (not borrowed money) on the lending markets",
};

'''
'''--- projects/atlas-usv/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasuryAddress = "0x71EF2894E23D7ea7Fd73a3558B3a0bA25689bC86";
module.exports = ohmTvl(treasuryAddress, [
//DAI
  ["0x8f3cf7ad23cd3cadbd9735aff958023239c6a063", false],
//FRAX
  ["0x104592a158490a9228070e0a8e5343b499e125d0", false],
//SSX
  ["0x9e2d266d6c90f6c0d80a88159b15958f7135b8af", false] ,
//Sushi LP
  ["0xc16e382aa7353aad0f598856afd9a93513542970", true]
], "polygon", "0x99bbc86E1f5447cf1908b27CEd0D2a0B9aA5efb2", "0xAC63686230f64BDEAF086Fe6764085453ab3023F", undefined, undefined, false)

'''
'''--- projects/atlendis/index.js ---
const { GraphQLClient, gql } = require('graphql-request')
const { getBlock } = require("../helper/getBlock.js");
const { transformPolygonAddress } = require('../helper/portedTokens');

async function fetchData(block, balances, transform, borrowed=false) {
  const baseUrl = 'https://api.thegraph.com/subgraphs/name/atlendis';
  const urlPolygon = `${baseUrl}/atlendis-hosted-service-polygon`;
  const graphQLClient = new GraphQLClient(urlPolygon)

  const query = gql`
  query get_tvl($block: Int) {
    poolStatuses (block: { number: $block }) {
      state
      pool {
        id
        identifier
        parameters {
          underlyingToken
        }
      }
      normalizedAvailableAmount
      normalizedBorrowedAmount
      adjustedPendingAmount
    }
  }
  `;

  // pull data
  const data = await graphQLClient.request(query, {
    block: block
  });

  // calculate TVL
  if (!borrowed) {
    for (let i=0; i < data.poolStatuses.length; i++) {
      let amount = parseInt(data.poolStatuses[i].normalizedAvailableAmount)
                + parseInt(data.poolStatuses[i].adjustedPendingAmount);
      let assetAddress = data.poolStatuses[i].pool.parameters.underlyingToken;

      assetAddress = transform(assetAddress);
      balances[assetAddress] = (balances[assetAddress] || 0) + amount / 1e12;
    }
  } else {
    for (let i=0; i < data.poolStatuses.length; i++) {
      let amount = parseInt(data.poolStatuses[i].normalizedBorrowedAmount)
      let assetAddress = data.poolStatuses[i].pool.parameters.underlyingToken;

      assetAddress = transform(assetAddress);
      balances[assetAddress] = (balances[assetAddress] || 0) + amount / 1e12;
    }
  }
}

async function tvl (timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();
  block = await getBlock(timestamp, "polygon", chainBlocks);
  await fetchData(block, balances, transform);
  return balances;
}

async function borrowed (timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();
  block = await getBlock(timestamp, "polygon", chainBlocks);
  await fetchData(block, balances, transform, true);
  return balances;
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  polygon: {
    tvl: tvl,
    borrowed: borrowed,
  }
};
'''
'''--- projects/atmossoft.js ---
const { transformBscAddress, transformFantomAddress 
    } = require('./helper/portedTokens');
const { unwrapUniswapLPs } = require('./helper/unwrapLPs');
const sdk = require('@defillama/sdk');

async function bsc(timestamp, ethBlock, chainBlocks) {
    const transform = await transformBscAddress();
    const atmosToken = 'bsc:0xc53c65c4a925039cc149fa99fd011490d40270a3';
    const pools = [{
        'pool2Address': '0xaF18cde26fdd22561df2a02958CbA092f41875d8',
        'pairToken': 'bsc:0x55d398326f99059ff775485246999027b3197955',
        'stakingContract': '0x282FFbE782F903340A14955649032302e8020b9C'  
    },{
        'pool2Address': '0xdf825e486d9d15848a36c113b7725d7923e886a4',
        'pairToken': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        'stakingContract': '0xa65d60e8a71dBDbb14B6eE7073522546FE73CFE4' 
    }];
    let balances = {};

    for (const pool of pools) {
        let balance = ((await sdk.api.abi.call({
            chain: 'bsc',
            block: chainBlocks['bsc'],
            target: pool.pool2Address,
            abi: 'erc20:balanceOf',
            params: pool.stakingContract
        })).output);

        await unwrapUniswapLPs(
            balances,
            [{balance: balance, token: pool.pool2Address}],
            chainBlocks['bsc'],
            'bsc',
            transform
        );
        //because atmos token isnt on coingecko
        delete balances[atmosToken];
        balances[pool.pairToken] *= 2;
    };
    return balances;
};
async function ftm(timestamp, ethBlock, chainBlocks) {
    const transform = await transformFantomAddress();
    const atmosToken = 'fantom:0xfc74d58550485e54dc3a001f6f371741dceea094';
    const pools = [{
        'pool2Address': '0x662db0c6fa77041fe4901149558cc70ca1c8e874',
        'pairToken': '0x4e15361fd6b4bb609fa63c81a2be19d873717870',
        'stakingContract': 'f043f876d3d220acce029ca76c9572f0449e5e71'  
    }];
    let balances = {};

    for (const pool of pools) {
        let balance = ((await sdk.api.abi.call({
            chain: 'fantom',
            block: chainBlocks['fantom'],
            target: pool.pool2Address,
            abi: 'erc20:balanceOf',
            params: pool.stakingContract
        })).output);

        await unwrapUniswapLPs(
            balances,
            [{balance: balance, token: pool.pool2Address}],
            chainBlocks['fantom'],
            'fantom',
            transform
        )
        // because atmos token isnt on coingecko
        delete balances[atmosToken];
        balances[pool.pairToken] *= 2;
    };
    return balances;
};

module.exports = {
    misrepresentedTokens: true,
    fantom: {
        tvl: async () => ({}), 
        pool2: ftm,
    },
    bsc: {
        pool2: bsc
    },
};
'''
'''--- projects/atomichub/index.js ---
const { get_account_tvl } = require("../helper/eos");

// AtomicHub
// https://eos.atomichub.io/
async function eos() {
  const tokens = [
    ["eosio.token", "EOS", "eos"],
  ];
  return await get_account_tvl("atomicmarket", tokens);
}

// AtomicHub
// https://wax.atomichub.io/
async function wax() {
  const tokens = [
    ["eosio.token", "WAX", "wax"],
  ];
  return await get_account_tvl("atomicmarket", tokens, "wax");
}

module.exports = {
  methodology: `AtomicHub TVL is achieved by querying token balances from AtomicHub's smart contract.`,
  eos: {
    tvl: eos
  },
  wax: {
    tvl: wax
  },
}
'''
'''--- projects/atrix.js ---
const retry = require('./helper/retry');
const axios = require('axios');

async function fetch() {
  const response = (
    await retry(
      async (bail) => await axios.get('https://api.atrix.finance/api/tvl')
    )
  ).data;

  return response.tvl;
}

module.exports = {
  timetravel: false,
  methodology: "The Atrix API endpoint fetches on-chain data from the Serum orderbook and token accounts for each liquidity pool, then uses prices from Coingecko to aggregate total TVL.",
  fetch,
};

'''
'''--- projects/auctus/abi.json ---
{
	"collateral": {
		"inputs": [],
		"name": "collateral",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"totalCollateral": {
		"inputs": [],
		"name": "totalCollateral",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"balance":{
		"inputs": [],
		"name": "balance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"token": {
		"inputs": [],
		"name": "token",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}
'''
'''--- projects/auctus/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const sdk = require('@defillama/sdk');

  const abi = require('./abi.json');
  const { default: BigNumber } = require('bignumber.js');

  const START_BLOCK = 10104891;
  const FACTORY = '0x176b98ab38d1aE8fF3F30bF07f9B93E26F559C17';
  const POOLS_FACTORY = '0xe28520DDB1b419Ac37eCDBB2c0F97c8Cf079CCC3';
  const VAULTS = '0x2Ce43b4570Ad9DEAb8CFE6258B42DB7301e3b6C0';
  const ETHER_ADDRESS = '0x0000000000000000000000000000000000000000';

/*==================================================
  TVL
  ==================================================*/

  const getTokenAddressFromNewAcoTokenLogData = data => '0x' + data.substring(154, 194);

  const getPoolAddressFromNewAcoPoolLogData = data => '0x' + data.substring(26, 66);

  const getVaultAddressFromSetAcoVaultLogData = data => '0x' + data.substring(26, 66);

  const getUnderlyingAddressFromNewAcoPoolLogData = data => '0x' + data.substring(26, 66);
  const getStrikeAssetAddressFromNewAcoPoolLogData = data => '0x' + data.substring(26, 66);

  async function tvl(timestamp, block) {
    var logsPromises = await Promise.all([
      sdk.api.util.getLogs({
        keys: [],
        toBlock: block,
        target: FACTORY,
        fromBlock: START_BLOCK,
        topic: 'NewAcoToken(address,address,bool,uint256,uint256,address,address)',
      }),
      sdk.api.util.getLogs({
        keys: [],
        toBlock: block,
        target: FACTORY,
        fromBlock: START_BLOCK,
        topic: 'NewAcoTokenData(address,address,bool,uint256,uint256,address,address,address)',
      }),
      sdk.api.util.getLogs({
        keys: [],
        toBlock: block,
        target: POOLS_FACTORY,
        fromBlock: START_BLOCK,
        topic: 'NewAcoPool(address,address,bool,address,address)',
      }),
      sdk.api.util.getLogs({
        keys: [],
        toBlock: block,
        target: VAULTS,
        fromBlock: START_BLOCK,
        topic: 'AcoVault(address,bool)',
      })
    ])

    const logs = logsPromises[0].output;

    let acoOptionsAddresses = [];
    logs.forEach((log) => {
      const address = getTokenAddressFromNewAcoTokenLogData(log.data);
      acoOptionsAddresses.push(address)
    });

    const logs2 = logsPromises[1].output;
    logs2.forEach((log) => {
      const address = getTokenAddressFromNewAcoTokenLogData(log.data);
      acoOptionsAddresses.push(address)
    });

    let collateralResult = await sdk.api.abi.multiCall({
      block,
      calls: acoOptionsAddresses.map((option) => ({
        target: option
      })),
      abi: abi.collateral,
    });

    let collateralAddressMap = {}

    collateralResult.output.forEach((result) => {
        collateralAddressMap[result.input.target] = result.output;
    });

    let totalCollateralResult = await sdk.api.abi.multiCall({
      block,
      calls: acoOptionsAddresses.map((option) => ({
        target: option
      })),
      abi: abi.totalCollateral,
    });

    let balances = {}
    balances[ETHER_ADDRESS] = "0"

    totalCollateralResult.output.forEach((result) => {
        var colateralAddress = collateralAddressMap[result.input.target].toLowerCase()
        if (!balances[colateralAddress]) {
          balances[colateralAddress] = "0"
        }
        const existingBalance = new BigNumber(balances[colateralAddress]);
        balances[colateralAddress] = existingBalance.plus(new BigNumber(result.output)).toFixed()
    });

    const newAcoPoolLogs = logsPromises[2].output;

    let acoPools = {};
    newAcoPoolLogs.forEach((log) => {
      const address = getPoolAddressFromNewAcoPoolLogData(log.data).toLowerCase();
      const underlyingAddress = getUnderlyingAddressFromNewAcoPoolLogData(log.topics[1]).toLowerCase();
      const strikeAssetAddress = getStrikeAssetAddressFromNewAcoPoolLogData(log.topics[2]).toLowerCase();
      acoPools[address] = {underlying: underlyingAddress, strikeAsset: strikeAssetAddress}
    });

    let poolCallsMap = Object.entries(acoPools).map(([poolAddress, poolData]) => ({
      target: poolData.underlying,
      params: poolAddress,
    }))

    poolCallsMap = poolCallsMap.concat(Object.entries(acoPools).map(([poolAddress, poolData]) => ({
      target: poolData.strikeAsset,
      params: poolAddress,
    })))

    let erc20CallsMap = poolCallsMap.filter((f) => f.target !== ETHER_ADDRESS)

    let poolBalances = await sdk.api.abi.multiCall({
      block,
      calls: erc20CallsMap,
      abi: 'erc20:balanceOf',
    });
    sdk.util.sumMultiBalanceOf(balances, poolBalances);

    let ethCallsMap = poolCallsMap.filter((f) => f.target === ETHER_ADDRESS)
    await (
      Promise.all(ethCallsMap.map(async (ethCall) => {
        const balance = (await sdk.api.eth.getBalance({target: ethCall.params, block})).output;
        balances[ETHER_ADDRESS] = BigNumber(balances[ETHER_ADDRESS]).plus(new BigNumber(balance)).toFixed();
      }))
    );

    const setVaultLog = logsPromises[3].output;

    let acoVaultsAddresses = [];
    setVaultLog.forEach((log) => {
      const address = getVaultAddressFromSetAcoVaultLogData(log.topics[1]);
      acoVaultsAddresses.push(address)
    });

    let balancesResult = await sdk.api.abi.multiCall({
      block,
      calls: acoVaultsAddresses.map((vault) => ({
        target: vault
      })),
      abi: abi.balance,
    });

    let tokensResult = await sdk.api.abi.multiCall({
      block,
      calls: acoVaultsAddresses.map((vault) => ({
        target: vault
      })),
      abi: abi.token,
    });

    balancesResult.output.forEach((result, index) => {
        var token = tokensResult.output[index].output.toLowerCase()
        var balance = result.output;
        balances[token] = BigNumber(balances[token]).plus(new BigNumber(balance)).toFixed();
    });

    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1590014400,   // 05/20/2020 @ 08:10:40pm (UTC)
    ethereum: { tvl }
  }

'''
'''--- projects/augmented-finance/abi.json ---
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getReservesData",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "underlyingAsset",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "pricingAsset",
            "type": "address"
          },
          {
            "internalType": "string",
            "name": "name",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "symbol",
            "type": "string"
          },
          {
            "internalType": "uint256",
            "name": "decimals",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "baseLTVasCollateral",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "reserveLiquidationThreshold",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "reserveLiquidationBonus",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "reserveFactor",
            "type": "uint256"
          },
          {
            "internalType": "bool",
            "name": "usageAsCollateralEnabled",
            "type": "bool"
          },
          {
            "internalType": "bool",
            "name": "borrowingEnabled",
            "type": "bool"
          },
          {
            "internalType": "bool",
            "name": "stableBorrowRateEnabled",
            "type": "bool"
          },
          {
            "internalType": "bool",
            "name": "isActive",
            "type": "bool"
          },
          {
            "internalType": "bool",
            "name": "isFrozen",
            "type": "bool"
          },
          {
            "internalType": "uint128",
            "name": "liquidityIndex",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "variableBorrowIndex",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "liquidityRate",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "variableBorrowRate",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "stableBorrowRate",
            "type": "uint128"
          },
          {
            "internalType": "uint40",
            "name": "lastUpdateTimestamp",
            "type": "uint40"
          },
          {
            "internalType": "address",
            "name": "depositTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "stableDebtTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "variableDebtTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "strategy",
            "type": "address"
          },
          {
            "internalType": "bool",
            "name": "isExternalStrategy",
            "type": "bool"
          },
          {
            "internalType": "uint256",
            "name": "availableLiquidity",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "totalPrincipalStableDebt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "averageStableRate",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "totalStableDebt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "stableDebtLastUpdateTimestamp",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "totalScaledVariableDebt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "priceInEth",
            "type": "uint256"
          }
        ],
        "internalType": "struct IUiPoolDataProvider.AggregatedReserveData[]",
        "name": "",
        "type": "tuple[]"
      },
      {
        "components": [
          {
            "internalType": "address",
            "name": "underlyingAsset",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "scaledDepositTokenBalance",
            "type": "uint256"
          },
          {
            "internalType": "bool",
            "name": "usageAsCollateralEnabledOnUser",
            "type": "bool"
          },
          {
            "internalType": "uint256",
            "name": "stableBorrowRate",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "scaledVariableDebt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "principalStableDebt",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "stableBorrowLastUpdateTimestamp",
            "type": "uint256"
          }
        ],
        "internalType": "struct IUiPoolDataProvider.UserReserveData[]",
        "name": "",
        "type": "tuple[]"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/augmented-finance/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');

const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const DATA_PROVIDERS = {
    ETHEREUM: '0x8F5273c5aa638e946BC5dD2171Ae9E9184C75228',
    BSC: '0xa450547F27F0947760C9C818d9fd2CD51DFA7441',
    AVALANCHE: '0x483B76b13B14DB4fF49359aF9DF3A51F25FaB6a0',
    XDAI: '0x75e5cF901f3A576F72AB6bCbcf7d81F1619C6a12',
};

/**
 * Get TVL for chain
 * Available chains: arbitrum, avax, fantom, polygon, xdai, bsc, ethereum
 */
function _tvlByChain(chainName, dataProviderAddress) {
    return async function tvl(timestamp, ethBlock, chainBlocks) {
        const block = chainBlocks[chainName];
        const transform = address => `${chainName}:${address}`
        const {output: reservesData} = await sdk.api.abi.call({
            target: dataProviderAddress,
            abi: abi.find(abi => abi.name === 'getReservesData'),
            params: [ZERO_ADDRESS],
            block,
            chain: chainName,
        });

        const [reserves] = reservesData;
        const totalSupply = await sdk.api.abi.multiCall({
            abi: 'erc20:totalSupply',
            calls: reserves.map(reserve => ({target: reserve.depositTokenAddress})),
            block,
            chain: chainName,
        });

        let balances = {};
        totalSupply.output.forEach((call, index) => {
            const tokenAddress = reserves[index].underlyingAsset;
            const tokenBalance = call.output;

            sdk.util.sumSingleBalance(balances, transform(tokenAddress), tokenBalance);
        })

        if ('bsc:0x85EAC5Ac2F758618dFa09bDbe0cf174e7d574D5B' in balances) {
            balances['tron'] = balances['bsc:0x85EAC5Ac2F758618dFa09bDbe0cf174e7d574D5B'] / 10 ** 18;
            delete balances['bsc:0x85EAC5Ac2F758618dFa09bDbe0cf174e7d574D5B'];
        }
        if ('0x8E16bf47065Fe843A82f4399bAF5aBac4E0822B7' in balances) {
            balances['filecoin'] = balances['0x8E16bf47065Fe843A82f4399bAF5aBac4E0822B7'] / 10 ** 18;
            delete balances['0x8E16bf47065Fe843A82f4399bAF5aBac4E0822B7'];
        }

        return balances;
    }
}

const ethereum = _tvlByChain('ethereum', DATA_PROVIDERS.ETHEREUM);
const bsc = _tvlByChain('bsc', DATA_PROVIDERS.BSC);
const avalanche = _tvlByChain('avax', DATA_PROVIDERS.AVALANCHE);
const xdai = _tvlByChain('xdai', DATA_PROVIDERS.XDAI);

module.exports = {
    start: 13339609, // Oct-02-2021 11:33:05 AM +UTC
    ethereum: {
        tvl: ethereum,
    },
    bsc: {
        tvl: bsc,
    },
    avalanche: {
        tvl: avalanche,
    },
    xdai: {
        tvl: xdai,
    },
    methodology: "Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending.",
}

'''
'''--- projects/augur/index.js ---
const sdk = require('@defillama/sdk');

const dai = '0x6b175474e89094c44da98b954eedeac495271d0f'
const universe = '0x49244bd018ca9fd1f06ecc07b9e9de773246e5aa'
const delegator = '0xd5524179cB7AE012f5B642C1D6D700Bbaa76B96b'

async function tvl(timestamp, block) {
  const daiBalance = await sdk.api.erc20.balanceOf({
    target: dai,
    owner: universe,
    block
  })
  const ethBalance = await sdk.api.eth.getBalance({
    target: delegator,
    block
  })

  return {
    '0x0000000000000000000000000000000000000000': ethBalance.output,
    [dai]: daiBalance.output
  }
}

module.exports = {
  ethereum: {
    tvl,
  },
}

'''
'''--- projects/auguryfinance/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accOmenPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "depositFeeBP",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/auguryfinance/index.js ---
const sdk = require("@defillama/sdk");
const utils = require("../helper/utils");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformPolygonAddress } = require("../helper/portedTokens");

const MasterAugur = "0x6ad70613d14c34aa69E1604af91c39e0591a132e";

const polygonTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const poolLength = Number(
    (
      await sdk.api.abi.call({
        abi: abi.poolLength,
        target: MasterAugur,
        chain: "polygon",
        block: chainBlocks["polygon"],
      })
    ).output
  );

  const allPoolNums = Array.from(Array(poolLength).keys());

  const lpTokens = (
    await sdk.api.abi.multiCall({
      abi: abi.poolInfo,
      calls: allPoolNums.map((num) => ({
        target: MasterAugur,
        params: num,
      })),
      chain: "polygon",
      block: chainBlocks["polygon"],
    })
  ).output.map((lp) => lp.output[0]);

  const balance = (
    await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: lpTokens.map((lp) => ({
        target: lp,
        params: MasterAugur,
      })),
      chain: "polygon",
      block: chainBlocks["polygon"],
    })
  ).output.map((lp) => lp.output);

  const lpPositions = [];

  for (let index = 0; index < allPoolNums.length; index++) {
    if (index == 1 || index == 17 || index == 18) {
      lpPositions.push({
        token: lpTokens[index],
        balance: balance[index],
      });
    } else {
      sdk.util.sumSingleBalance(
        balances,
        `polygon:${lpTokens[index]}`,
        balance[index]
      );
    }
  }

  const transformAddress = await transformPolygonAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["polygon"],
    "polygon",
    transformAddress
  );

  return balances;
};

// ----- Treasury TVL -----
const treasuryTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const DeveloperTeamWallet = "0xE2E26BAc2ff37A7aE219EcEF74C5A1Bf95d5f854";

  /*** Tokens aren't in the file matic.json that exit in GitHub respository of the protocol ***/
  const amWMATIC = "0x8df3aad3a84da6b69a4da8aec3ea40d9091b2ac4";
  const OMEN = "0x76e63a3E7Ba1e2E61D3DA86a87479f983dE89a7E";
  const QUICK = "0x831753dd7087cac61ab5644b308642cc1c33dc13";

  const tokens_polygon = (
    await utils.fetchURL(
      "https://raw.githubusercontent.com/augury-finance/default-token-list/master/tokens/matic.json"
    )
  ).data.map((tokenAddress) => tokenAddress.address).filter(token => token !== "0xaaAEBE6Fe48E54f431b0C390CfaF0b017d09D42d");

  tokens_polygon.push(amWMATIC, OMEN, QUICK);

  const balanceTreasury = (
    await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: tokens_polygon.map((tp) => ({
        target: tp,
        params: DeveloperTeamWallet,
      })),
      chain: "polygon",
      block: chainBlocks["polygon"],
    })
  ).output.map((lp) => lp.output);

  for (let index = 0; index < tokens_polygon.length; index++) {
      sdk.util.sumSingleBalance(
        balances,
        `polygon:${tokens_polygon[index]}`,
        balanceTreasury[index]
      );
  }

  return balances;
};

module.exports = {
  methodology: 'MasterAugur(MasterChef) contract is used to pull LP token amounts. LP tokens are unwrapped and each token token balance is considered in the TVL sum.',
  polygon: {
    tvl: polygonTvl,
    treasury: treasuryTvl
  },
};

'''
'''--- projects/auraswap/index.js ---
const sdk = require("@defillama/sdk");
const {calculateUniTvl} = require('../helper/calculateUniTvl.js');
const { staking } = require("../helper/staking.js");

const AURA_TOKEN = '0x1b7805e2829fd7D194DCc3078a4199b13c77E467'
const MASTER_CHEF = '0x44Bb1a3E56Cb12b7B1a8E925f09A170e3646346d'
const FACTORY_POLYGON = "0x015DE3ec460869eb5ceAe4224Dc7112ac0a39303";

async function polygonTvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(addr=>`polygon:${addr}`, chainBlocks['polygon'], 'polygon', FACTORY_POLYGON, 0, true);
}

module.exports = {
  timetravel: true,
  doublecounted: false,
  polygon:{
    tvl: polygonTvl,
	  staking: staking(MASTER_CHEF, AURA_TOKEN, "polygon"),
  },
}
'''
'''--- projects/aurigami.js ---
const { compoundExports } = require("./helper/compound");

module.exports = {
    timetravel: true,
    aurora: {
        ...compoundExports(
            '0x817af6cfAF35BdC1A634d6cC94eE9e4c68369Aeb',
            'aurora',
            '0xca9511B610bA5fc7E311FDeF9cE16050eE4449E9',
            '0xc9bdeed33cd01541e1eed10f90519d2c06fe3feb'
        )
    }
};
'''
'''--- projects/aurora.js ---
constutils=require('./helper/utils');

asyncfunctiontvl(){
consttotalTvl=awaitutils.fetchURL('https://api.llama.fi/charts/aurora')

return{
near:totalTvl.data.pop().totalLiquidityUSD
}
}

module.exports={
methodology:'IncludestheAuroraTVLasaprojectunderNEAR',
tvl,
}
'''
'''--- projects/auroraswap/index.js ---
const { staking } = require("../helper/staking");
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const masterchefAddress = "0x35CC71888DBb9FfB777337324a4A60fdBAA19DDE";
const brlTokenAddress = "0x12c87331f086c3C926248f964f8702C0842Fd77F";

const tvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = await calculateUniTvl(
    (addr) => `aurora:${addr}`,
    chainBlocks.aurora,
    "aurora",
    "0xC5E1DaeC2ad401eBEBdd3E32516d90Ab251A3aA3",
    0,
    true
  );
  return balances;
};

module.exports = {
  aurora: {
    tvl,
    staking: staking(masterchefAddress, brlTokenAddress, "aurora"),
  },
};

'''
'''--- projects/autofarm.js ---
const utils = require('./helper/utils');
const {fetchChainExports} = require('./helper/exports');

const transformChain = {
  okexchain: 'okex',
  avalanche: 'avax',
}

function chainTvl(chain){
  return async()=>{
    const data = await utils.fetchURL(`https://static.autofarm.network/${transformChain[chain] ?? chain}/stats.json`)
  return data.data.platformTVL
  }
}

module.exports=fetchChainExports(chainTvl, [
  'bsc',       'polygon',
  'heco',      'avalanche',
  'fantom',    'moonriver',
  'okexchain', 'celo',
  'cronos',    'boba',
  'harmony','xdai',
  'velas','aurora',
  'oasis'
])

'''
'''--- projects/autoshark/abi.json ---
{
  "allPairsLength": {
    "constant": true,
    "inputs": [],
    "name": "allPairsLength",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "allPairs": {
    "constant": true,
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "allPairs",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/autoshark/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");

const finsFactory = "0xe759Dd4B9f99392Be64f1050a6A8018f73B53a13";

const jaws = "0xdd97ab35e3c0820215bc85a395e13671d84ccba2";
const jawsPool = "0x5D2112Ba0969EC66012380C1fb88F2A3D182Eb90";

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  const allPairsLength = (
    await sdk.api.abi.call({
      target: finsFactory,
      abi: abi.allPairsLength,
      block: chainBlocks.bsc,
      chain: "bsc",
    })
  ).output;
  const allPairs = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(allPairsLength) }, (_, k) => ({
        target: finsFactory,
        params: k,
      })),
      abi: abi.allPairs,
      block: chainBlocks.bsc,
      chain: "bsc",
    })
  ).output;
  const totalSupply = (
    await sdk.api.abi.multiCall({
      calls: allPairs.map((p) => ({
        target: p.output,
      })),
      abi: "erc20:totalSupply",
      block: chainBlocks.bsc,
      chain: "bsc",
    })
  ).output;
  let lpPos = [];
  totalSupply.forEach((p) => {
    if (p.output === "0") return;
    lpPos.push({
      token: p.input.target,
      balance: p.output,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPos,
    chainBlocks.bsc,
    "bsc",
    (addr) => `bsc:${addr}`
  );
  return balances;
}

module.exports = {
  methodology: "Liquidity from the finsFactory is counted as TVL",
  bsc: {
    tvl,
    staking: staking(jawsPool, jaws, "bsc"),
  },
};

'''
'''--- projects/avalaunch/index.js ---
const sdk = require('@defillama/sdk')
const { unwrapUniswapLPs } = require('../helper/unwrapLPs')
const {fixAvaxBalances} = require('../helper/portedTokens')

const xavaAddress = "0xd1c3f94DE7e5B45fa4eDBBA472491a9f4B166FC4";
const stakingContracts = [
    "0xE82AAE7fc62547BdFC36689D0A83dE36FF034A68", // single staking
    "0xA6A01f4b494243d84cf8030d982D7EeB2AeCd329" // allocation proxy
];
const lp = "0x42152bDD72dE8d6767FE3B4E17a221D6985E8B25";
const farm = "0x6E125b68F0f1963b09add1b755049e66f53CC1EA";

async function tvl(){
    return {};
};
async function pool2(timestamp, ethBlock, chainBlocks){
    const block = chainBlocks.avax;
    const lpLocked = await sdk.api.erc20.balanceOf({
        target: lp,
        owner: farm,
        block,
        chain: 'avax'
    });
    const balances = {};
    await unwrapUniswapLPs(balances, [{
        token: lp,
        balance: lpLocked.output
    }], block, 'avax', addr=>`avax:${addr}`);
    fixAvaxBalances(balances);
    return balances;
};
async function staking(timestamp, ethBlock, chainBlocks){
    const block = chainBlocks.avax;
    const balances  = await sdk.api.abi.multiCall({
        block: block,
        chain: 'avax',
        calls: stakingContracts.map(c => ({
            target: xavaAddress,
            params: c
        })),
        abi: 'erc20:balanceOf'
      });
    let staking = {};
    staking[`avax:${xavaAddress}`] = balances.output.map(b => 
        b.output).reduce((a, b) => Number(a) + Number(b), 0)
    return staking;
};

module.exports={
    methodology: "Within pool2, it counts the XAVA-AVAX staked in the farm",
    avalanche:{
        tvl,
        pool2,
        staking
    },
}

'''
'''--- projects/avalps/index.js ---
const {ohmTvl} = require("../helper/ohm");

const blanc = "0xf481Eec738C46F675e077ee966A680a19210Af11";
const stakingContract = "0x1b6CD48f1148FF53e61809a68bca74b384B8C630";
const treasuryContract = "0x76EcB72ffeEb0Bf57869758c9bf020F45d0a04d0";

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasuryContract, [
        ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
        ["0x9B4E1cFD1417cBa22a2fb2B7cbdd8dcC1dc1e7C7", true], // BLANC-MIM
        ["0x0FB87c2dA68CC565f380DDE4A5cdafd6F5A315b0", true], // BLANC-WAVAX
    ], "avax", stakingContract, blanc, undefined, undefined, false)
}
'''
'''--- projects/avault/abi.json ---
{
  "wantAddress": {
    "inputs": [],
    "name": "wantAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "wantLockedTotal": {
    "inputs": [],
    "name": "wantLockedTotal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "name": {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token0": {
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "token1": {
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/avault/avault-vault-utils.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const vaultsBase = async (chainLocal, vaultAddressArr, block) => {
  const wantedLockedCall = [];
  for (let j = 0; j < vaultAddressArr.length; j++) {
    const vaultAddress = vaultAddressArr[j];
    wantedLockedCall.push({
      target: vaultAddress,
    });
  }

  const [_wantedLocked, _wantedAddresses, _vaultName] = await Promise.all([
    sdk.api.abi.multiCall({
      block: block,
      calls: wantedLockedCall,
      abi: abi.wantLockedTotal,
      chain: chainLocal,
    }),
    sdk.api.abi.multiCall({
      block: block,
      calls: wantedLockedCall,
      abi: abi.wantAddress,
      chain: chainLocal,
    }),
    sdk.api.abi.multiCall({
      block: block,
      calls: wantedLockedCall,
      abi: abi.name,
      chain: chainLocal,
    }),
  ]);
  const wantedLocked = _wantedLocked.output.map((v) => v.output);
  const wantedAddresses = _wantedAddresses.output.map((v) => v.output);
  const vaultName = _vaultName.output.map((v) => v.output);
  return {
    wantedLocked,
    wantedAddresses,
    vaultName,
  };
};

module.exports = {
  vaultsBase,
};

'''
'''--- projects/avault/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { getChainTransform, getFixBalances } = require("../helper/portedTokens");
const utils = require("../helper/utils");
const { vaultsBase } = require("./avault-vault-utils");
const url = "https://www.avault.network/media/get-vaults.json";
async function tvl(chainBlocks) {
  const balances = {};
  const vaultsInfo = (await utils.fetchURL(url)).data;
  // const vaultsInfo = {
  //   astr: {
  //     aAAA: "0x9a45b203Af044ADACceD4D95ca3cDa020E082c8A",
  //     aDotUsdc: "0x898BF9C743a436C9C3F332aF445aAd69c15b10b8",
  //     aDotAstr: "0xE66560C1B5FAaE4e4f77ba40F61F21F4ADbb6924",
  //     aMuuuAstr: "0x57D942953d416835F7B60bE2A8b49870cc7bcfe1",
  //     aKglAstr: "0xe7465336BaA2EfBe52e3e67a8B06a97630d76882",
  //     aLayAstr: "0xc59B9d3ECC93967e697accDbfe9EAB74bB3Fba22",
  //     aOusdUsdc: "0x40B18bc7AEE5A03515fCf241ad89d548899FB74f",
  //     aBaiUsdc: "0x5417F117E4A2283623B3b9A07Ec2B2f269d19A75",
  //     aBaiAstr: "0xC730151a27A4cE6a09d51cFaB115233C2E73D471",
  //     aNikaAstr: "0x13E01d7Da7b3F211C6972c331DA88c142dF571D8",
  //     aOruAstr: "0x8f0fD0A3b767a67E992F33063817A2d472EFf74f",
  //     aJpycAstr: "0x8d90E9C50Af206a2757e09B56160991Dd7548db9",
  //     aSdnAstr: "0x5F612d4155b1CEdE2a2cda61146834280f706B78",
  //     aMaticAstr: "0x7D7b744CB50Eb228fe23Bbb29bc5918c507180B7",
  //     aBnbAstr: "0x6B13DDF4d1E1F2E036619920746318fB79f9EA84",
  //     aBtcAstr: "0x945bC42819F4F612d07DaBd1d57F10Aac494405f",
  //     aUsdtAstr: "0x8964FAE92bb4b79D408e9Bd3d48e7C9EcaA5f163",
  //     aUsdcAstr: "0xDaD1D300E9a6f4f36AeD40213EF473Fd019704E9",
  //     aEthAstr: "0xDaac872a9098aC5620C9D8eaF2DD50FBABc50Bb1",
  //     aDaiUsdc: "0x81FbF3A32D600C65B9Df30404C2D372b6c9eE845",
  //     aBusdUsdc: "0x8552030E314cD15300f75AA93fA8133BB3340E6f",
  //     aUsdtUsdc: "0x41F97524B5E73575F3848E1983181c0622d10e41",
  //   },
  // };
  const chainArr = Object.keys(vaultsInfo);
  const chain = "astr";
  const chainLocal = chain === "astr" ? "astar" : chainArr[i];
  const fixBalances = await getFixBalances(chainLocal);
  const vaultAddressArr = Object.values(vaultsInfo[chainLocal]);
  const transformAddress = await getChainTransform(chainLocal);
  const { wantedLocked, wantedAddresses, vaultName } = await vaultsBase(
    chainLocal,
    vaultAddressArr,
    chainBlocks
  );

  const lpPositions = [];
  for (let k = 0; k < wantedLocked.length; k++) {
    if (vaultName[k].toLowerCase().endsWith(" lp")) {
      lpPositions.push({
        token: wantedAddresses[k],
        balance: wantedLocked[k],
      });
    } else {
      sdk.util.sumSingleBalance(
        balances,
        `${chainLocal}:${wantedAddresses[k]}`,
        wantedLocked[k]
      );
    }
  }
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks[chainLocal],
    chainLocal,
    transformAddress
  );
  fixBalances(balances);

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  methodology: "Avault - The Best Yield Aggregator on ASTR Network",
  astar: {
    tvl: tvl,
  },
};

'''
'''--- projects/avaviking/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const token = "0xF1b0F6DF4fc3710b3497c34B0Ee366099054add8";
const masterchef = "0xEF8285A4B4F21D3F9dC9E5cEf7E39977E2Ef8B3d";

module.exports = {
    ...masterChefExports(masterchef, "avax", token, false)
}
'''
'''--- projects/avaware/abi.json ---
{
    "poolCount": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "poolCount",
        "inputs": []
    },
    "getPool": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "tuple",
                "name": "",
                "internalType": "struct FarmPoolManager.Pool",
                "components": [
                    {
                        "type": "address",
                        "name": "pool",
                        "internalType": "address"
                    },
                    {
                        "type": "string",
                        "name": "name",
                        "internalType": "string"
                    },
                    {
                        "type": "uint256",
                        "name": "rewardAmount",
                        "internalType": "uint256"
                    },
                    {
                        "type": "bool",
                        "name": "legacy",
                        "internalType": "bool"
                    },
                    {
                        "type": "bool",
                        "name": "active",
                        "internalType": "bool"
                    }
                ]
            }
        ],
        "name": "getPool",
        "inputs": [
            {
                "type": "uint256",
                "name": "id",
                "internalType": "uint256"
            }
        ]
    },
    "stakingToken": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "contract IERC20"
            }
        ],
        "name": "stakingToken",
        "inputs": []
    }
}
'''
'''--- projects/avaware/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const FarmPoolManager = "0x7ec4AeaeB57EcD237F35088D11C59525f7D631FE";
const treasuryAddress = "0x9300736E333233F515E585c26A5b868772392709";
const AVE = "0x78ea17559B3D2CF85a7F9C2C704eda119Db5E6dE";

const malformedLPTokens = [
  '0x75AB49DfF2649b2c7C5d1519fBabA89Ea57a4ef6',
  '0x2af262DD90bd2D124E95Fc778D9c85aA03734Ff2',
  '0xE5403978fF8AD2B0a007F330f6235F7250F54a6C',
  '0x91934e4fA7E2D25DF2FA132a4aAFEFE929751224',
  '0xac2d6DBE97de8C0363FfCeA77b701c8Ffc4D2F3b',
].map(token => token.toLowerCase())

/*** Staking of native token AVE TVL Portion ***/
const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const transformAddress = await transformAvaxAddress();

  await sumTokensAndLPsSharedOwners(
    balances,
    [[AVE, false]],
    [treasuryAddress],
    chainBlocks["avax"],
    "avax",
    transformAddress
  );

  return balances;
};

/*** farms TVL portion ***/
const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const transformAddress = await transformAvaxAddress();

  const CountOfPools = (
    await sdk.api.abi.call({
      abi: abi.poolCount,
      target: FarmPoolManager,
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output;

  const lpPositions = [];
  const promises = []

  for (let index = 0; index < CountOfPools; index++) {
    if (index == 14) {
      continue // 14 isn't a normal pool, it's NFT staking rewards
    }

    promises.push((async () => {
      const getPoolAddress = (
        await sdk.api.abi.call({
          abi: abi.getPool,
          target: FarmPoolManager,
          params: index,
          chain: "avax",
          block: chainBlocks["avax"],
        })
      ).output.pool;

      const stakingLpOrTokens = (
        await sdk.api.abi.call({
          abi: abi.stakingToken,
          target: getPoolAddress,
          chain: "avax",
          block: chainBlocks["avax"],
        })
      ).output;

      const balanceOfLpoOrToken = (
        await sdk.api.abi.call({
          abi: 'erc20:balanceOf',
          target: stakingLpOrTokens,
          params: getPoolAddress,
          chain: "avax",
          block: chainBlocks["avax"],
        })
      ).output;

      if (index == 8) {
        sdk.util.sumSingleBalance(
          balances,
          transformAddress(stakingLpOrTokens),
          balanceOfLpoOrToken
        );
      } else {
        if (malformedLPTokens.includes(stakingLpOrTokens.toLowerCase()))
          return;
        lpPositions.push({
          token: stakingLpOrTokens,
          balance: balanceOfLpoOrToken,
        });
      }
    })())
  }

  await Promise.all(promises)

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["avax"],
    "avax",
    transformAddress,
    undefined,
    undefined,
    undefined,
    { skipFailingLPs: true }
  );

  return balances;
};

module.exports = {
  timetravel: true,
  avalanche: {
    staking,
    tvl: avaxTvl,
  },
  methodology: `We count TVL that is on the Farms threw FarmPoolManager contract 
    and the portion of staking the native token (AVE) by treasury contract`,
};

'''
'''--- projects/axe/index.js ---
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking.js");

const treasuryAddresses = ["0xa2039621Cc042567092fAaee89B03Ef959F89712"];
const DAI = "0x6b175474e89094c44da98b954eedeac495271d0f";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const AXEStaking = "0x7f4d186b76a39a2da32804a8c35b3d04e0e174fd";
const AXE = "0x30AC8317DfB0ab4263CD8dB1C4F10749911B126C";

const AXE_DAI_POOL = "0xd34d3b648db688bee383022dd26a9027592b82d5";
/*** Bonds TVL Portion (Treasury) ***
 * Treasury TVL consists of DAI and UNI-V2 balances
 ***/
 async function ethTvl(timestamp, block) {
    const balances = {};
  
    await sumTokensAndLPsSharedOwners(
      balances,
      [
        [DAI, false],
        [USDC, false],
        [AXE_DAI_POOL, true]
      ],
      treasuryAddresses,
      block
    );
  
    return balances;
}

module.exports = {
    deadFrom: 1648765747,
    start: 1637036516, // 16 Nov 2021
    ethereum: {
      tvl: ethTvl,
      staking: staking(AXEStaking, AXE, "ethereum"),
    },
    methodology:
      "Counts DAI, USDC and DAI SLP (AXE-DAI) on the treasury",
};

'''
'''--- projects/axial/abi.json ---
{
  "getToken": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
          {
              "type": "address",
              "name": "",
              "internalType": "contract IERC20"
          }
      ],
      "name": "getToken",
      "inputs": [
          {
              "type": "uint8",
              "name": "index",
              "internalType": "uint8"
          }
      ]
  },
  "want": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
          {
              "type": "address",
              "name": "",
              "internalType": "address"
          }
      ],
      "name": "want",
      "inputs": []
  },
  "balanceOf": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
          {
              "type": "uint256",
              "name": "",
              "internalType": "uint256"
          }
      ],
      "name": "balanceOf",
      "inputs": []
  },
  "token": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
          {
              "type": "address",
              "name": "",
              "internalType": "contract IERC20"
          }
      ],
      "name": "token",
      "inputs": []
  },
  "balance": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
          {
              "type": "uint256",
              "name": "",
              "internalType": "uint256"
          }
      ],
      "name": "balance",
      "inputs": []
  },
  "poolLength": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [
        {
            "type": "uint256",
            "name": "pools",
            "internalType": "uint256"
        }
    ],
    "name": "poolLength",
    "inputs": []
  },
  "poolInfo": {
    "type": "function",
    "stateMutability": "view",
    "inputs": [{
        "internalType":"uint256",
        "name":"",
        "type":"uint256"
    }],
    "name": "poolInfo",
    "outputs":[{
        "internalType":"contract IERC20",
        "name":"lpToken",
        "type":"address"
        },
        {
        "internalType":"uint256",
        "name":"accAxialPerShare",
        "type":"uint256"
        },
        {
        "internalType":"uint256",
        "name":"lastRewardTimestamp",
        "type":"uint256"
        },
        {
        "internalType":"uint256",
        "name":"allocPoint",
        "type":"uint256"
        },
        {
        "internalType":"contract IRewarder",
        "name":"rewarder",
        "type":"address"
        }
    ]
  },
  "owner": {
    "name": "owner",
    "type": "function",
    "stateMutability":"view",
    "inputs": [],
    "outputs": [{
        "internalType": "address",
        "name": "",
        "type": "address"
    }]
  }
}
'''
'''--- projects/axial/index.js ---

const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
// node test.js projects/axial/index.js
const AXIAL_JLP_TOKEN = "0x5305A6c4DA88391F4A9045bF2ED57F4BF0cF4f62";
const AXIAL_MASTERCHEF_V3 = "0x958C0d0baA8F220846d3966742D4Fb5edc5493D3";

async function getAxialVaultBalances(balances, vaults, block) {
  await Promise.all(vaults.map(async (vault) => {
    await sdk.api.abi.multiCall({
      calls: [0, 1, 2, 3].map(num => ({
        target: vault,
        params: [num]
      })),
      abi: abi.getToken,
      block,
      chain: 'avax'
    }).then(async tokens => {
      await sdk.api.abi.multiCall({
        calls: tokens.output.filter(t => t.output != null).map(token => ({
          target: token.output,
          params: [vault]
        })),
        abi: 'erc20:balanceOf',
        block,
        chain: 'avax'
      }).then(tokenBalances => {
        const balancesToAdd = {};
        sdk.util.sumMultiBalanceOf(balancesToAdd, tokenBalances);
        Object.entries(balancesToAdd).forEach(balance => {
          sdk.util.sumSingleBalance(balances, `avax:${balance[0]}`, balance[1]);
        });
      });
    });
  }));
}

async function getAxialJLPBalance(_timestamp, _ethereumBlock, chainBlocks) {
  const balances = {}
  const block = chainBlocks['avax'];
  const axialBalance = (await sdk.api.abi.call({
    target: AXIAL_JLP_TOKEN,
    params: [AXIAL_MASTERCHEF_V3],
    block,
    chain: 'avax',
    abi: 'erc20:balanceOf'
  })).output;
  await unwrapUniswapLPs(balances, [{token: AXIAL_JLP_TOKEN, balance: axialBalance}], block, 'avax', (addr) => `avax:${addr}`);
  return balances;
}

async function getAxialPools(block) {
  let vaults = [];
  const poolLength = (await sdk.api.abi.call({
    target: AXIAL_MASTERCHEF_V3,
    abi: abi.poolLength,
    chain: 'avax',
    block
  })).output;
  await sdk.api.abi.multiCall({
    calls: [...Array(Number(poolLength)).keys()].map(num => ({
      target: AXIAL_MASTERCHEF_V3,
      params: num
    })),
    chain: 'avax',
    abi: abi.poolInfo,
    block
  }).then(async pools => {
    await sdk.api.abi.multiCall({
      calls: pools.output.map(pool => ({
        target: pool.output.lpToken
      })),
      chain: 'avax',
      abi: abi.owner,
      block
    }).then(owners => {
      vaults = owners.output.filter(e => e.output).map(e => e.output);
    });
  });
  return vaults;
}

async function tvl(_timestamp, _ethereumBlock, chainBlocks) {
  const balances = {};
  const block = chainBlocks['avax'];
  const vaults = await getAxialPools(chainBlocks.avax);

  await getAxialVaultBalances(balances, vaults, block);
  return balances;
}

module.exports = {
  methodology: "Our TVL is the value of the tokens within the Axial pools, and the Axial LP tokens within our rewards pools MasterChef",
  avalanche: {
    tvl,
    pool2: getAxialJLPBalance
  }
}

'''
'''--- projects/axion/abi.json ---
{
  "getStatFields": {
    "inputs": [],
    "name": "getStatFields",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint72",
            "name": "totalStakedAmount",
            "type": "uint72"
          },
          {
            "internalType": "uint72",
            "name": "sharesTotalSupply",
            "type": "uint72"
          },
          {
            "internalType": "uint72",
            "name": "_gap",
            "type": "uint72"
          },
          {
            "internalType": "uint40",
            "name": "lastStakeId",
            "type": "uint40"
          }
        ],
        "internalType": "struct StakeBase.StatFields",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/axion/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const AXION = "0x839F1a22A59eAAf26c85958712aB32F80FEA23d9";
const MANAGER = "0x5F95DB799CecD1E9d95f66bA36a88A9a571Db9cD";
async function staking(timestamp, block, chainBlocks) {
  const stats = await sdk.api.abi.call({
    target: MANAGER,
    block: chainBlocks.polygon,
    abi: abi.getStatFields,
    chain: "polygon",
  });

  return {
    // Add 12 0's since total staked amount is 6 decimals, but token amount is 18 decimals
    [`polygon:${AXION}`]: `${stats.output.totalStakedAmount}000000000000`,
  };
}

const BTC = "0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6";
const VC = "0x660B71C03C15B24EFa800F2454540CD9011E40cB";
async function tvl(timestamp, block, chainBlocks) {
  const stats = await sdk.api.abi.call({
    target: BTC,
    block: chainBlocks.polygon,
    abi: abi.balanceOf,
    params: VC,
    chain: "polygon",
  });

  return {
    [`polygon:${BTC}`]: stats.output,
  };
}

module.exports = {
  polygon: {
    staking,
    tvl,
  },
};

'''
'''--- projects/axl-inu/index.js ---
const { stakings } = require("../helper/staking");

const stakingContractsBSC = ["0xd500a6652365E819888Aa4df72d79eE970dB9B42"]
const stakingContractsETH = ["0x440D1c47379CF17CCB7Eb334Ae80DC8291FB14Ad"]

const AXL = "0x25b24B3c47918b7962B3e49C4F468367F73CC0E0";

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology: 'TVL only counts liquidity in the staking pools.',
  bsc: {
    staking: stakings(stakingContractsBSC, AXL, "bsc"),
    tvl: (async) => ({}),
  },
  ethereum: {
    staking: stakings(stakingContractsETH, AXL),
    tvl: (async) => ({}),
  },
};

'''
'''--- projects/aztec/abi.json ---
{
    "getSupportedAsset": {"inputs":[{"internalType":"uint256","name":"assetId","type":"uint256"}],"name":"getSupportedAsset","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
    "getSupportedAssets": {"inputs":[],"name":"getSupportedAssets","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
    "getTotalDeposited": {"inputs":[],"name":"getTotalDeposited","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},
    "getTotalFees": {"inputs":[],"name":"getTotalFees","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},
    "getTotalPendingDeposit": {"inputs":[],"name":"getTotalPendingDeposit","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},
    "getTotalWithdrawn": {"inputs":[],"name":"getTotalWithdrawn","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/aztec/index.js ---
const sdk = require("@defillama/sdk")
const abi = require('./abi.json');

const aztecRollupProcessor = '0x737901bea3eeb88459df9ef1BE8fF3Ae1B42A2ba'
// "getSupportedAssets" "getTotalDeposited" "getTotalPendingDeposit" "getTotalWithdrawn" "getTotalFees" 
const weth = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2' 

async function tvl(timestamp, ethBlock, chainBlocks) { 
    const balances = {}
  
    // Get aztec supported assets
    const { output: supportedAssets } = await sdk.api.abi.call({
        abi: abi['getSupportedAssets'],
        target: aztecRollupProcessor, 
        block: ethBlock, 
        chain: 'ethereum' 
    })

    // Get eth balance
    const { output: ethBalance } = await sdk.api.eth.getBalance({
        target: aztecRollupProcessor,
        block: ethBlock, 
        chain: 'ethereum' 
    });
    sdk.util.sumSingleBalance( balances, weth, ethBalance );
    
    // Get supported assets balances
    const assetsBalances = await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: supportedAssets.map( asset => ({
            params: aztecRollupProcessor,
            target: asset,
        })), 
        block: ethBlock, 
        chain: 'ethereum' 
    })
    sdk.util.sumMultiBalanceOf( balances, assetsBalances, true);

    return balances
}

module.exports = {
  methodology: "TVL of Aztec consists of ethereum and supported assets (DAI and renBTC at the moment) locked into the rollup processor",
  ethereum: {
    tvl,
  }
}

'''
'''--- projects/azuro/index.js ---
const sdk = require("@defillama/sdk");

const LPContract = '0xac004b512c33D029cf23ABf04513f1f380B3FD0a'
const token = '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d'

async function tvl(timestamp, ethBlock, chainBlocks) {

  const balance = await sdk.api.erc20.balanceOf({
    target: token,
    owner: LPContract,
    block: chainBlocks['xdai'],
    chain: 'xdai'
  })

  return {['xdai:' + token]: balance.output};
}

module.exports = {
  xdai:{
    tvl,
  },
  methodology: `TVL is the total quantity of xDAI held on Liquidity pools smart-contracts.`
}

'''
'''--- projects/babelfish/index.js ---
const axios = require("axios");
const BigNumber = require('bignumber.js')
const { toUSDTBalances } = require("../helper/balances");

async function getTvl() {
  const massetAddress = '0x1440d19436bEeaF8517896bffB957a88EC95a00F';
  const apiKey = 'ckey_a88d61b514564402b9eece2017c';
  const prec = new BigNumber(10).pow(18);
  const url =
    `https://api.covalenthq.com/v1/30/address/${massetAddress}/balances_v2/?quote-currency=USD&format=JSON&nft=false&no-nft-fetch=false&key=${apiKey}`;
  const result = await axios.get(url);
  return result.data.data.items.reduce(
    (p, c) => p.plus(new BigNumber(c.balance)),
    new BigNumber(0))
    .div(prec);
}

module.exports = {
  fetch: getTvl
};

'''
'''--- projects/babena/index.js ---
const axios = require("axios");
const { fetchLocal, mkMeta } = require("../helper/pact");

const chainId = "3";
const network = `https://api.chainweb.com/chainweb/0.0/mainnet01/chain/${chainId}/pact`;
const GAS_PRICE = 0.00000001;
const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const getReserve = (tokenData) => {
  return parseFloat(tokenData.decimal ? tokenData.decimal : tokenData);
}

const getTokenToKadena = async (token) => {
  let data = await fetchLocal({
    pactCode: `
          (use free.exchange)
          (let*
            (
              (p (get-pair ${token} coin))
              (reserveA (reserve-for p ${token}))
              (reserveB (reserve-for p coin))
            )[reserveA reserveB])
           `,
    meta: mkMeta("account", chainId, GAS_PRICE, 3000, creationTime(), 600),
  }, network);

  if (data.result.status === "success") {
    const tokenReserve = getReserve(data.result.data[0]);
    const kadenaReserve = getReserve(data.result.data[1]);
    return kadenaReserve / tokenReserve;
  }

  throw new Error(`Babena fetch failed`);
}

const fetchBebePrice = async () => {
  return await getTokenToKadena("free.babena");
}

const getTotalLockedKda = async () => {
  let data = await fetchLocal(
    {
      pactCode: '(coin.get-balance "babena-bank")',
      meta: mkMeta('', chainId, 0.01, 1000, 28800, creationTime())
    },
    network
  );
  if (data.result.status === "success") {
    return getReserve(data.result.data);
  }

  throw new Error("Total locked KDA fetch failed");
}

const getTotalLockedBabe = async () => {
  let data = await fetchLocal(
    {
      pactCode: '(free.babena.get-balance "babena-bank")',
      meta: mkMeta('', chainId, 0.01, 1000, 28800, creationTime())
    },
    network
  );
  if (data.result.status === "success") {
    return getReserve(data.result.data);
  }

  throw new Error("Total locked BABE failed");
}

function calcTVL(availableKda) {
  let totalPriceKda = 0;

  if (availableKda > 0) {
    totalPriceKda = availableKda;
  }

  return { kadena: totalPriceKda };
}

function stakingcalcTVL(babenaPrice, availableBabe) {
  let totalPriceBabe = 0;

  if (availableBabe > 0 && babenaPrice > 0) {
    totalPriceBabe = availableBabe * babenaPrice;
  }

  return { kadena: totalPriceBabe }
}

async function fetch() {
  const availableKda = await getTotalLockedKda();

  return calcTVL(availableKda);
}
async function stakingfetch() {
  const bebePrice = await fetchBebePrice();
  const babenaPrice = bebePrice;
  const availableBabe = await getTotalLockedBabe();

  return stakingcalcTVL(babenaPrice, availableBabe);
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  kadena: {
    tvl: fetch,
    staking: stakingfetch
  }

}
'''
'''--- projects/babylon-finance/abi.json ---
{
    "getGardens": {
        "name": "getGardens",
        "inputs": [],
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    "getGardenDetails": {
        "inputs": [
            {
                "internalType": "address",
                "name": "_garden",
                "type": "address"
            }
        ],
        "name": "getGardenDetails",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            },
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            },
            {
                "internalType": "address[5]",
                "name": "",
                "type": "address[5]"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "bool[4]",
                "name": "",
                "type": "bool[4]"
            },
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            },
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            },
            {
                "internalType": "uint256[10]",
                "name": "",
                "type": "uint256[10]"
            },
            {
                "internalType": "uint256[10]",
                "name": "",
                "type": "uint256[10]"
            },
            {
                "internalType": "uint256[3]",
                "name": "",
                "type": "uint256[3]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getCompleteStrategy": {
        "inputs": [
            {
                "internalType": "address",
                "name": "_strategy",
                "type": "address"
            }
        ],
        "name": "getCompleteStrategy",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            },
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            },
            {
                "internalType": "uint256[16]",
                "name": "",
                "type": "uint256[16]"
            },
            {
                "internalType": "bool[]",
                "name": "",
                "type": "bool[]"
            },
            {
                "internalType": "uint256[]",
                "name": "",
                "type": "uint256[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/babylon-finance/helper.js ---
const sdk = require("@defillama/sdk")
const BigNumber = require("bignumber.js")
const abi = require('./abi.json');
const { } = require("../helper/unwrapLPs");

const { request, gql } = require("graphql-request")

// pool will give you the amount of fUniV3_WETH_ABC held by the pool of the position token against that token total supply
const uniV3_nft_contract = '0xc36442b4a4522e871399cd717abdd847ab11fe88'

const abi_staking = {
  'univ3_positions': { "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "positions", "outputs": [{ "internalType": "uint96", "name": "nonce", "type": "uint96" }, { "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "address", "name": "token0", "type": "address" }, { "internalType": "address", "name": "token1", "type": "address" }, { "internalType": "uint24", "name": "fee", "type": "uint24" }, { "internalType": "int24", "name": "tickLower", "type": "int24" }, { "internalType": "int24", "name": "tickUpper", "type": "int24" }, { "internalType": "uint128", "name": "liquidity", "type": "uint128" }, { "internalType": "uint256", "name": "feeGrowthInside0LastX128", "type": "uint256" }, { "internalType": "uint256", "name": "feeGrowthInside1LastX128", "type": "uint256" }, { "internalType": "uint128", "name": "tokensOwed0", "type": "uint128" }, { "internalType": "uint128", "name": "tokensOwed1", "type": "uint128" }], "stateMutability": "view", "type": "function" },

  'erc721_tokenOfOwnerByIndex': { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "index", "type": "uint256" }], "name": "tokenOfOwnerByIndex", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },

  'token0': { "inputs": [], "name": "token0", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
  'token1': { "inputs": [], "name": "token1", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
}

// Convert Uniswap v3 tick to a price (i.e. the ratio between the amounts of tokens: token1/token0)
const tickBase = 1.0001
function tick_to_price(tick) {
  return tickBase ** tick
}
// GraphQL query to get the pool information
const univ3_graph_url = "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3"
const univ3_graph_query = gql`
query position($block: Int, $position_id: ID!) {
		position (
				id: $position_id
				block: { number: $block }
		) {
				id
				owner
				tickLower {tickIdx}
				tickUpper {tickIdx}
				liquidity
				pool {
						tick
						liquidity
						feeTier
						token0 { symbol decimals id }
						token1 { symbol  decimals id }
				}
		}
}`

/*
univ3_Positions:{
        vault,
        pool
}[]
*/
async function unwrapUniswapV3LPs(balances, univ3_Positions, block, chain = 'ethereum', transformAddress = (addr) => addr) {
  await Promise.all(univ3_Positions.map(async univ3_Position => {
    try {
      // Get share of that LP NFT inside the vault as balanceOf / totalSupply
      const { output: totalSupply } = await sdk.api.abi.call({
        block,
        abi: 'erc20:totalSupply',
        target: univ3_Position.vault,
        chain
      })
      const { output: heldLPshares } = await sdk.api.abi.call({
        block,
        abi: 'erc20:balanceOf',
        target: univ3_Position.vault,
        params: univ3_Position.pool,
        chain
      })
      const sharesRatio = heldLPshares / totalSupply

      /*
      const {output: uniV3_nft_count} = await sdk.api.abi.call({
              block,
              abi: 'erc20:balanceOf',
              target: uniV3_nft_contract,
              params: univ3_Position.vault,
              chain
      })
      */
      // Here we assume only the first nft position is retrieved
      // could look for more using uniV3_nft_count 
      const { output: position_id } = await sdk.api.abi.call({
        block,
        abi: abi_staking['erc721_tokenOfOwnerByIndex'],
        target: uniV3_nft_contract,
        params: [univ3_Position.vault, 0],
        chain
      })

      const positionBalances = await getUniv3PositionBalances(position_id, block)

      // Add balances while multiplying amount by ratio of shares
      Object.entries(positionBalances).forEach(async entry => {
        const [key, value] = entry;
        // balances[key] = BigNumber( balances[key] || 0 ).plus(sharesRatio * value);
        sdk.util.sumSingleBalance(balances, await transformAddress(key), BigNumber(sharesRatio * value).toFixed(0))
      });
      console.log(`ratio of the pool: ${(100 * sharesRatio).toFixed(1)}% of position_id ${position_id}`)

    } catch (e) {
      console.log(`Failed to get data for LP token vault at ${univ3_Position.vault} on chain ${chain}`)
      throw e
    }
  }))
}

async function getUniv3PositionBalances(position_id, block) {
  // Retrieve aTokens and reserves from graphql API endpoint
  const { position } = await request(
    univ3_graph_url,
    univ3_graph_query, {
    block: block,
    position_id: position_id
  })

  // Extract pool parameters
  const pool = position['pool']
  const tick = pool['tick']
  const token0 = pool['token0']['id']
  const token1 = pool['token1']['id']
  // Retrieve these from the graphql query instead of onchain call
  const bottom_tick = position['tickLower']['tickIdx']
  const top_tick = position['tickUpper']['tickIdx']
  const liquidity = position['liquidity']

  // Compute square roots of prices corresponding to the bottom and top ticks
  const sa = tick_to_price(Math.floor(bottom_tick / 2))
  const sb = tick_to_price(Math.floor(top_tick / 2))
  const price = tick_to_price(tick)
  const sp = price ** 0.5
  // const decimals0 = pool['token0']['decimals']
  // const decimals1 = pool['token1']['decimals']
  // const adjusted_price = price / (10 ** (decimals1 - decimals0))

  // Compute real amounts of the two assets
  const amount0 = liquidity * (sb - sp) / (sp * sb)
  const amount1 = liquidity * (sp - sa)

  console.log(`Whole pool: amount0: ${(amount0 / 1e18).toFixed(1)} / amount1: ${(amount1 / 1e18).toFixed(1)}`)
  return {
    [token0]: amount0,
    [token1]: amount1,
  }
}

/*
// Could get some props of the position itself onchain rather than using uni-v3 graphql endpoint, but some information needed is missing like whole pool liq/tick etc
const {output: position_props} = await sdk.api.abi.call({
    block,
    abi: abi_staking['univ3_positions'],
    target: uniV3_nft_contract,
    params: position_id, // get the last one for demonstration
    chain: 'ethereum'
})
const bottom_tick = position_props['tickLower']
const top_tick = position_props['tickUpper']
const L = position_props['liquidity']
const token0 = position_props['token0']
const token1 = position_props['token1']
*/

module.exports = {
  unwrapUniswapV3LPs
}

'''
'''--- projects/babylon-finance/index.js ---
const sdk = require("@defillama/sdk")
const BigNumber = require("bignumber.js")
const abi = require('./abi.json');
const { unwrapUniswapV3LPs } = require("./helper");

const babController = '0xd4a5b5fcb561daf3adf86f8477555b92fba43b5f'
const babylonViewer = '0x740913FEF40720E82498D5b73A4E8C3a5D9b9d79'

async function tvl(timestamp, ethBlock, chainBlocks) {
    const balances = {}

    // Get all gardens using babController contract
    let { output: gardens } = await sdk.api.abi.call({
        abi: abi['getGardens'],
        target: babController,
        block: ethBlock,
        chain: 'ethereum'
    })
    // console.log('gardens (public and private)', gardens)

    const gardensToIgnore = ["0xB0EE8C61c78aA9B7ED138bcC6bce7ABeC8470038", "0xF0AF08d7bc6e4aE42b84771aE3f9DA7D8e58b083", "0x4f5721Ce7F02586D67eA0CC6003e889E974DC9A0"]
    gardens = gardens.filter(i => !gardensToIgnore.includes(i))
    // Get details of all gardens using babylonViewer contract
    const gardensDetails = await sdk.api.abi.multiCall({
        abi: abi['getGardenDetails'],
        calls: gardens.map(garden => ({
            params: garden,
            target: babylonViewer,
        })),
        block: ethBlock,
        chain: 'ethereum'
    })

    for (const gardenDetails of gardensDetails.output) {
        if (gardensToIgnore.includes(gardenDetails.input.params[0])) { continue; };
        console.log(gardenDetails.input.params[0], !!gardenDetails.output)
        const [gardenName, symbol, creators, reserveAsset, arr1, strategies, finalizedStrategies, voteParams, capitalArr, profits] = gardenDetails.output
        // const garden_principal = capitalArr[0]
        const garden_idle = capitalArr[9]
        // Get strategies details
        const strategiesDetails = await sdk.api.abi.multiCall({
            abi: abi['getCompleteStrategy'],
            calls: strategies.map(strategy => ({
                params: strategy,
                target: babylonViewer,
            })),
            block: ethBlock,
            chain: 'ethereum'
        })
        let strategy_str = ''
        const strategies_tvl = strategiesDetails.output.map(strategyDetails => {
            const [, strategyName, strategyProps, ,] = strategyDetails.output
            const [capitalAllocated, nav] = [strategyProps[4], strategyProps[10]]
            strategy_str += `   strategy ${strategyName}: nav (tvl): ${nav / 1e18} out of capitalAllocated, : ${capitalAllocated / 1e18}\n`
            return nav
        })

        const garden_tvl = strategies_tvl.reduce((acc, el) => acc.plus(BigNumber(el)), BigNumber(garden_idle))
        balances[reserveAsset] = balances[reserveAsset] ? BigNumber(balances[reserveAsset]).plus(garden_tvl) : garden_tvl
        if (garden_tvl / 1e18 > 10)
            console.log(`Garden with name "${gardenName}" TVL: ${garden_tvl / 1e18} of reserveAsset: ${reserveAsset} locked\n${strategy_str}-----------------------------`)
    }
    return Object.fromEntries(Object.entries(balances).map(b => [b[0], b[1].toFixed(0)]))
}

const harvest_vault = '0xadB16dF01b9474347E8fffD6032360D3B54627fB'
const harvest_pool = '0x3e6397E309f68805FA8Ef66A6216bD2010DdAF19'
// const harvest_position_id = 158516
async function staking(timestamp, ethBlock, chainBlocks) {
    const balances = {}
    const univ3_Positions = [{
        vault: harvest_vault,
        pool: harvest_pool
    }]
    await unwrapUniswapV3LPs(balances, univ3_Positions, ethBlock, 'ethereum')
    console.log('balances:', balances)
    return balances
}

module.exports = {
    methodology: "TVL of Babylon corresponds to capital locked into each garden (idle capital waiting to be deployed) as well as capital deployed to each strategy of these gardens",
    ethereum: {
        staking, // : () => ({})
        tvl // : () => ({}),
    }
}

/* garden Details
(
    gardenName,
    symbol,
    creators,
    garden.reserveAsset(),
    [true, garden.privateGarden(), garden.publicStrategists(), garden.publicStewards()],
    garden.getStrategies(),
    garden.getFinalizedStrategies(),
    [
        garden.depositHardlock(),
        garden.minVotesQuorum(),
        garden.maxDepositLimit(),
        garden.minVoters(),
        garden.minStrategyDuration(),
        garden.maxStrategyDuration(),
        garden.strategyCooldownPeriod(),
        garden.minContribution(),
        garden.minLiquidityAsset(),
        garden.totalKeeperFees().add(garden.keeperDebt())
    ],
    [
        principal,
        garden.reserveAssetRewardsSetAside(),
        uint256(garden.absoluteReturns()),
        garden.gardenInitializedAt(),
        garden.totalContributors(),
        garden.totalStake(),
        totalSupplyValuationAndSeed[1] > 0
            ? totalSupplyValuationAndSeed[0].preciseMul(totalSupplyValuationAndSeed[1])
            : 0,
        totalSupplyValuationAndSeed[0],
        totalSupplyValuationAndSeed[2],
        totalSupplyValuationAndSeed[3]
    ],
    profits
)
*/
/* Complete Strategy
(
    strategist,
    strategyName,
    [
        strategy.getOperationsCount(),
        strategy.stake(),
        strategy.totalPositiveVotes(),
        strategy.totalNegativeVotes(),
        strategy.capitalAllocated(),
        strategy.capitalReturned(),
        strategy.duration(),
        strategy.expectedReturn(),
        strategy.maxCapitalRequested(),
        strategy.enteredAt(),
        strategy.getNAV(),
        rewards,
        strategy.maxAllocationPercentage(),
        strategy.maxGasFeePercentage(),
        strategy.maxTradeSlippagePercentage(),
        strategy.isStrategyActive() ? _estimateStrategyRewards(_strategy) : 0
    ],
    status,
    ts
)
*/
'''
'''--- projects/babypigfinance/index.js ---
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2 } = require('../helper/pool2')

const chef = "0x7f8ECcC1437aaCEFE533A6f1BfE2144b1d0d7D35"
const fbabypig = "0x3a76b1b3e827cc7350e66a854eced871a81a3527"
const fbabypigFtmLP = "0xc56a420486f547a5adc1dd64b4a13051baa4a8e0"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, undefined, [fbabypig, fbabypigFtmLP])
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom:{
    staking: staking(chef, fbabypig, "fantom"),
    pool2: pool2(chef, fbabypigFtmLP, "fantom"),
    tvl
  },
}
'''
'''--- projects/babyswap/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IBEP20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accCakePerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/babyswap/index.js ---
const { staking } = require("../helper/staking");

const MasterChefContract = "0xdfAa0e08e357dB0153927C7EaBB492d1F60aC730";
const BABY = "0x53E562b9B7E5E94b81f10e96Ee70Ad06df3D2657";

// node test.js projects/babyswap/index.js

/*
module.exports = {
  timetravel: true,
  bsc: {
    staking: staking(MasterChefContract, BABY, "bsc"),
    tvl: bscTvl,
  },
  methodology:
    "We count liquidity on the Farms (LP tokens) and Pools (single tokens) seccions threw MasterChef Contract",
};*/
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
module.exports = {
    methodology: `Uses factory(0x86407bEa2078ea5f5EB5A52B2caA963bC1F889Da) address and whitelisted tokens address to find and price Liquidity Pool pairs`,
    misrepresentedTokens: true,
    doublecounted: false,
    timetravel: true,
    incentivized: true,
    bsc: {
        tvl: calculateUsdUniTvl(
            "0x86407bEa2078ea5f5EB5A52B2caA963bC1F889Da",
            "bsc",
            "0x55d398326f99059ff775485246999027b3197955",
            [
                "0x53E562b9B7E5E94b81f10e96Ee70Ad06df3D2657",
                "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
                "0xe9e7cea3dedca5984780bafc599bd69add087d56",
                "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
                "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
                "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
                "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
                "0xba2ae424d960c26247dd6c32edc70b295c744c43"
            ],
            "tether"
        ),
        staking: staking(MasterChefContract, BABY, "bsc"),
    }
};

'''
'''--- projects/backfinance/abi.json ---
{
    "pairFactory": {
        "inputs": [],
        "name": "pairFactory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolFactory": {
        "inputs": [],
        "name": "poolFactory",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getPools": {
        "inputs": [],
        "name": "getPools",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "supplyToken": {
        "inputs": [],
        "name": "supplyToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrow": {
        "inputs": [],
        "name": "totalBorrow",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getPairs": {
        "inputs": [],
        "name": "getPairs",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrowToken0": {
        "inputs": [],
        "name": "totalBorrowToken0",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrowToken1": {
        "inputs": [],
        "name": "totalBorrowToken1",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/backfinance/index.js ---
const sdk = require("@defillama/sdk");
const erc20 = require("../helper/abis/erc20.json");
const abi = require("./abi.json");

const BackConfig = "0x51b4fa29dA61715d3384Be9f8a7033bD349Ef629";

const calcTvl = async (balances, chain, block, factoryAddr, poolAddrs, token, balance) => {
    const backFactory = (await sdk.api.abi.call({
        abi: factoryAddr,
        target: BackConfig,
        block,
        chain
    })).output;

    const poolAddresses = (await sdk.api.abi.call({
        abi: poolAddrs,
        target: backFactory,
        block,
        chain
    })).output;

    const tokens = (await sdk.api.abi.multiCall({
        abi: token,
        calls: poolAddresses.map(pool => ({
            target: pool
        })),
        block,
        chain
    })).output.map(t => t.output);

    if (balance == erc20.balanceOf || balance == abi.totalBorrow) {

        if (balance == erc20.balanceOf) {
            const balancePools = (await sdk.api.abi.multiCall({
                abi: balance,
                calls: poolAddresses.map((pool, idx) => ({
                    target: tokens[idx],
                    params: pool
                })),
                block,
                chain
            })).output.map(bp => bp.output);

            for (let index = 0; index < poolAddresses.length; index++) {
                sdk.util.sumSingleBalance(
                    balances,
                    `heco:${tokens[index]}`,
                    balancePools[index]
                );
            }
        } else {
            const balancePools = (await sdk.api.abi.multiCall({
                abi: balance,
                calls: poolAddresses.map(pool => ({
                    target: pool
                })),
                block,
                chain
            })).output.map(bp => bp.output);

            for (let index = 0; index < poolAddresses.length; index++) {
                sdk.util.sumSingleBalance(
                    balances,
                    `heco:${tokens[index]}`,
                    balancePools[index]
                );
            }
        }
    } else {
        const balancePools = (await sdk.api.abi.multiCall({
            abi: balance,
            calls: poolAddresses.map(pool => ({
                target: pool
            })),
            block,
            chain
        })).output.map(bp => bp.output);

        for (let index = 0; index < poolAddresses.length; index++) {
            sdk.util.sumSingleBalance(
                balances,
                `heco:${tokens[index]}`,
                balancePools[index]
            );
        }
    }
}

const hecoTvl = async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};

    //  --- Single token pool TVL portion ---
    await calcTvl(
        balances,
        "heco",
        chainBlocks["heco"],
        abi.poolFactory,
        abi.getPools,
        abi.supplyToken,
        erc20.balanceOf
    );

    await calcTvl(
        balances,
        "heco",
        chainBlocks["heco"],
        abi.poolFactory,
        abi.getPools,
        abi.supplyToken,
        abi.totalBorrow
    );

    //  --- Pairs pool TVL portion ---
    await calcTvl(
        balances,
        "heco",
        chainBlocks["heco"],
        abi.pairFactory,
        abi.getPairs,
        abi.token0,
        abi.totalBorrowToken0,
    );

    await calcTvl(
        balances,
        "heco",
        chainBlocks["heco"],
        abi.pairFactory,
        abi.getPairs,
        abi.token1,
        abi.totalBorrowToken1,
    );

    return balances;
};

module.exports = {
    heco: {
        tvl: hecoTvl,
    },
};
'''
'''--- projects/bacondao/index.js ---
const { staking } = require("../helper/staking.js");
const { pool2 } = require("../helper/pool2.js");

// ETH contracts
const baconToken = "0x34f797e7190c131cf630524655a618b5bd8738e7";
const stakingContract = "0x27FC644f86a5D4Ad0809BFF8EafCc528E5F4e034";

// BACON-USDC Pair
const ethLP = "0xc992a50169f6075d52013118355c633bf92ae853";

// BSC contracts
const bscBaconToken = "0x0615dbba33fe61a31c7ed131bda6655ed76748b1";
const bscStakingContract = "0x1624f949b1c972eA24e9BeeAd7A0f60E201D6eD3";

// BACON-BUSD Pair
const bscPool2Contract = "0x529943544Eb7f1765b4009862420fBd22A6D5eE7";
const bscLP = "0xdf2f838fda9294a7dedb25c815c4f8a3dc30851c";

module.exports = {
  ethereum: {
    tvl: async () => ({}),
    pool2: pool2(stakingContract, ethLP),
    staking: staking(stakingContract, baconToken, "ethereum"),
  },
  bsc: {
    tvl: async () => ({}),
    pool2: pool2(bscPool2Contract, bscLP, "bsc", (addr) => `bsc:${addr}`),
    staking: staking(bscStakingContract, bscBaconToken, "bsc"),
  },
};

'''
'''--- projects/badgerdao.js ---
const utils = require('./helper/utils');
const {fetchChainExports} = require('./helper/exports');

function chainTvl(chain){
  const hallmarks = []
  return async()=>{
    let data = await utils.fetchURL(`https://api.badger.finance/v2/value?chain=${chain==="ethereum"?"eth":chain}`)
    return data.data.totalValue
  }
}

module.exports = fetchChainExports(chainTvl, ["ethereum", "bsc", "arbitrum"]),
module.exports.hallmarks =  [[1638403200, "Front-end attack"]
]

'''
'''--- projects/bagel-finance/abi.json ---
{
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "banks":{
    "constant":true,
    "inputs":[
        {
            "internalType":"address",
            "name":"",
            "type":"address"
        }
    ],
    "name":"banks",
    "outputs":[
        {
            "internalType":"address",
            "name":"tokenAddr",
            "type":"address"
        },
        {
            "internalType":"address",
            "name":"gTokenAddr",
            "type":"address"
        },
        {
            "internalType":"bool",
            "name":"isOpen",
            "type":"bool"
        },
        {
            "internalType":"bool",
            "name":"canDeposit",
            "type":"bool"
        },
        {
            "internalType":"bool",
            "name":"canWithdraw",
            "type":"bool"
        },
        {
            "internalType":"uint256",
            "name":"totalVal",
            "type":"uint256"
        },
        {
            "internalType":"uint256",
            "name":"totalDebt",
            "type":"uint256"
        },
        {
            "internalType":"uint256",
            "name":"totalDebtShare",
            "type":"uint256"
        },
        {
            "internalType":"uint256",
            "name":"totalReserve",
            "type":"uint256"
        },
        {
            "internalType":"uint256",
            "name":"lastInterestTime",
            "type":"uint256"
        },
        {
            "internalType":"uint256",
            "name":"tokenIdx",
            "type":"uint256"
        }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  }
}

'''
'''--- projects/bagel-finance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const bankAddress = "0x18C32E273D0F13D5b8268B3Bc5acD30f26A8F91a";
const tokens = [
  "0x55d398326f99059ff775485246999027b3197955",
  "0xe9e7cea3dedca5984780bafc599bd69add087d56",
  "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
  "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
  "0x9c65ab58d8d978db963e63f2bfb7121627e3a739",
  "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
  "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
  "0xbb238fce6e2ee90781cd160c9c6eaf3a4cfad801",
];

const lps = [
  {
    0: "0x35e716c5D1038D41BdbA201413dBa9FDF16BBede",
    1: "0x0eD7e52944161450477ee417DE9Cd3a859b14fD0",
  },
  {
    0: "0x9583a15ED9766634d5b947F9837fB9156e80Cc55",
    1: "0x58f876857a02d6762e0101bb5c46a8c1ed44dc16",
  },
  {
    0: "0x78ab47680dF11a14509eEB46D07A5296161102dd",
    1: "0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae",
  },
  {
    0: "0x62B21315F17A0929DC76F888256bd66F774fc8E8",
    1: "0xf45cd219aef8618a92baa7ad848364a158a24f33",
  },
  {
    0: "0x13C7551604CD533f19fd8AC07c4f02eF7F749036",
    1: "0x804678fa97d91b974ec2af3c843270886528a9e6",
  },
  {
    0: "0x30e3624584441ed9c2552265743bA2e02cAe7714",
    1: "0xea26b78255df2bbc31c1ebf60010d78670185bd0",
  },
  {
    0: "0x4eBf4522046c5D1AAB5881C5c8A1679ba41c71B7",
    1: "0x61eb789d75a95caa3ff50ed7e47b96c132fec082",
  },
  {
    0: "0x69C8e18fEBE99Eb32EBde5b0Bf4970066C9C0fEc",
    1: "0xe1cbe92b5375ee6afe1b22b555d257b4357f6c68",
  },
  {
    0: "0x56d382C3f62E00e0D4eeAA283212f557C82D2Ab4",
    1: "0xda28eb7aba389c1ea226a420bce04cb565aafb85",
  },
  {
    0: "0x09e44Da2975C119B42fA990d24dA5B16B6e37962",
    1: "0x09cb618bf5ef305fadfd2c8fc0c26eecf8c6d5fd",
  },
  {
    0: "0x1Cb542509BbBba65ab4a1509bd59fc9f7195a9CA",
    1: "0x0fb881c078434b1c0e4d0b64d8c64d12078b7ce2",
  },
  {
    0: "0x63cA00DEfc958af2a8a14923978F79CAd1268fE4",
    1: "0x340192d37d95fb609874b1db6145ed26d1e47744",
  },
  {
    0: "0xA37255b10b1757aA1c6009A3089F50b654f5a093",
    1: "0xaf9aa53146c5752bf6068a84b970e9fbb22a87bc",
  },
  {
    0: "0xBd245975DB5D4255E5E6c4531DffE5A6829db985",
    1: "0xba68d6bee4f433630dee22c248a236c8f6eae246",
  },
  {
    0: "0xe4aD6C2Cd37DEd0560f766327dD426e04B0Fa657",
    1: "0x1c0276642f2a7cbcf6624d511f34811cdc65212c",
  },
  {
    0: "0x3b402F7448edC7c7a959B336367a06aDDe9Ca07B",
    1: "0x223740a259e461abee12d84a9fff5da69ff071dd",
  },
  {
    0: "0xdf7039684F943E82a8738A340830e4D8068F1f7D",
    1: "0x969f2556F786a576F32AeF6c1D6618f0221Ec70e",
  },
  {
    0: "0x514b825ebb062EB29681C281092f27eFeC838Ceb",
    1: "0x82E8F9e7624fA038DfF4a39960F5197A43fa76aa",
  },
  {
    0: "0x116D641DCBDc3Ad83377720Befb2B3ACcC3525Fd",
    1: "0xe1cbe92b5375ee6afe1b22b555d257b4357f6c68",
  },
  {
    0: "0x5dA197Fc0d6Cc95E2FfAB1b5d716787Ed361086f",
    1: "0xda28eb7aba389c1ea226a420bce04cb565aafb85",
  },
  {
    0: "0x04b5bfE991F70917b3c57372969A556ba82d1490",
    1: "0x09cb618bf5ef305fadfd2c8fc0c26eecf8c6d5fd",
  },
  {
    0: "0x24290AaBeD957BD9dbFa26B7E35D4848493DF257",
    1: "0x0fb881c078434b1c0e4d0b64d8c64d12078b7ce2",
  },
  {
    0: "0x54fa364FA14Bb522b974423a7975736a179ABb64",
    1: "0x340192d37d95fb609874b1db6145ed26d1e47744",
  },
  {
    0: "0xC99733f519F95f332f7c89783E53A47b2baa146e",
    1: "0xaf9aa53146c5752bf6068a84b970e9fbb22a87bc",
  },
  {
    0: "0x738977EF319acC5b68E4e33d4ae15e9439587DF5",
    1: "0xba68d6bee4f433630dee22c248a236c8f6eae246",
  },
  {
    0: "0xB6E9E7cC2ED0bc17c9904E7Bddb9bAD0B23572fc",
    1: "0x1c0276642f2a7cbcf6624d511f34811cdc65212c",
  },
  {
    0: "0xfAeEEc3bf5c95cB656e8D1F7B4a11C822Bbcf600",
    1: "0x223740a259e461abee12d84a9fff5da69ff071dd",
  },
  {
    0: "0x0Fef1343E8f4104AcA4f248BbD9b97E99735483E",
    1: "0x969f2556F786a576F32AeF6c1D6618f0221Ec70e",
  },
  {
    0: "0x661FFF9Da7Be79Ffc5c745Cd5fe164Eb7f19560D",
    1: "0x82E8F9e7624fA038DfF4a39960F5197A43fa76aa",
  },
];
async function bnbTvl(bankAddress, block) {
  let balances = {
    "0x0000000000000000000000000000000000000000": (
      await sdk.api.eth.getBalance({ target: bankAddress, block, chain: "bsc" })
    ).output,
  };
  return balances;
}

function getBSCAddress(address) {
  return `bsc:${address}`;
}

async function tvl(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {};
  const block = chainBlocks.bsc;
  const banksInfos = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.banks,
      calls: tokens.map((token) => ({
        target: bankAddress,
        params: token,
      })),
      chain: "bsc",
    })
  ).output;

  const lendingBalances = banksInfos
    .filter((n) => {
      return true;
    })
    .map((n) => {
      const stakingTokenAddr = n.input.params[0];
      const i5 = n.output["5"];
      const i6 = n.output["6"];
      const i8 = n.output["8"];
      return {
        token: stakingTokenAddr,
        balance: BigNumber(i5).plus(BigNumber(i8)).toFixed(0),
      };
    });
  lendingBalances.forEach((s) => {
    balances[getBSCAddress(s.token)] = BigNumber(
      balances[getBSCAddress(s.token)] || 0
    )
      .plus(BigNumber(s.balance))
      .toFixed(0);
  });

  /// @dev bnb
  const bnbBalance = await bnbTvl(bankAddress, block);
  balances[getBSCAddress("0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c")] =
    BigNumber(bnbBalance["0x0000000000000000000000000000000000000000"]);

  const lpTotalSupplys = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.totalSupply,
      calls: lps.map((n) => ({
        target: n["0"],
      })),
      chain: "bsc",
    })
  ).output;

  /// @dev unwrap LP to get underlaying token balances for workers that are working with LPs
  await unwrapUniswapLPs(
    balances,
    lps.map((info, index) => {
      /// @dev getting LP address and return the object that unwrapUniswapLPs want
      const lpAddr = info["1"];
      return {
        token: lpAddr,
        balance: BigNumber(lpTotalSupplys[index].output),
      };
    }),
    block,
    "bsc",
    (addr) => `bsc:${addr}`
  );

  return balances;
}

module.exports = {
  start: 1602054167,
  tvl,
};

'''
'''--- projects/baguette/index.js ---
const { getAvaxUniswapTvl } = require("../helper/getUniSubgraphTvl")

const tvl = getAvaxUniswapTvl('https://api.thegraph.com/subgraphs/name/baguette-exchange/baguette', 'baguetteFactories')

module.exports = {
  misrepresentedTokens: true,
  methodology: 'We count liquidity on the pairs. We get that information from the "baguette-exchange/baguette" subgraph',
  avalanche:{
    tvl,
  },
}
'''
'''--- projects/baker-guild-finance/index.js ---
const sdk = require("@defillama/sdk");
const {addFundsInMasterChef} = require("../helper/masterchef");
const {pool2BalanceFromMasterChefExports} = require("../helper/pool2");
const {staking} = require("../helper/staking");

const token = "0xfe27133f2e8c8539363883d914bccb4b21ebd28a";
const masterchef = "0x81A9A4e95443B505ee6b10227E61b74D39CDeBc0";

const wMEMO = "0x0da67235dd5787d67955420c84ca1cecd4e5bb3b"
const time = "avax:0xb54f16fb19478766a268f172c9480f8da1a7c9c3";

const wsSPA= "0x89346b51a54263cf2e92da79b1863759efa68692";
const spa = "fantom:0x5602df4a94eb6c680190accfa2a475621e0ddbdc";

const translate = {
    "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e":"0x6b175474e89094c44da98b954eedeac495271d0f",
    "0x9879abdea01a879644185341f7af7d8343556b7a":"0x0000000000085d4780b73119b644ae5ecd22b376",
    "0x9f47f313acfd4bdc52f4373b493eae7d5ac5b765":"avax:0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd",
    "0x511d35c52a3c244e7b8bd92c0c297755fbd89212":"avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
}

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, masterchef, chainBlocks.fantom, "fantom", addr=> {
        addr = addr.toLowerCase();
        if (translate[addr] !== undefined) {
            return translate[addr];
        }
        return `fantom:${addr}`
    }, undefined, [token], true, true, token);
    const memo = (await sdk.api.abi.call({
        target: wMEMO,
        params: [balances["fantom:0xddc0385169797937066bbd8ef409b5b3c0dfeb52"]],
        abi:{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"wMEMOToMEMO","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
        block: chainBlocks.avax,
        chain: "avax",
    })).output;
    balances[time] = memo
    delete balances["fantom:0xddc0385169797937066bbd8ef409b5b3c0dfeb52"];
    const sSPA = (await sdk.api.abi.call({
        target: wsSPA,
        params:[balances["fantom:0x89346b51a54263cf2e92da79b1863759efa68692"]],
        abi: {"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"wOHMTosOHM","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
        block: chainBlocks.fantom,
        chain: "fantom"
    })).output;
    balances[spa] = sSPA;
    delete balances["fantom:0x89346b51a54263cf2e92da79b1863759efa68692"];
    return balances;
}

module.exports = {
    fantom: {
        tvl,
        pool2: pool2BalanceFromMasterChefExports(masterchef, token, "fantom", addr=>`fantom:${addr}`),
        staking: staking(masterchef, token, "fantom")
    }
}
'''
'''--- projects/bakeryswap/index.js ---
const {uniTvlExport} = require("../helper/calculateUniTvl");
const { staking } = require("../helper/staking");

const factory = "0x01bF7C66c6BD861915CdaaE475042d3c4BaE16A7";

module.exports = {
  bsc:{
    staking: staking("6a8dbbfbb5a57d07d14e63e757fb80b4a7494f81", "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5", "bsc"),
    tvl: uniTvlExport(factory, "bsc") 
  }
};

'''
'''--- projects/baksdao/index.js ---
const { sumTokens, } = require('../helper/unwrapLPs')
const { transformBscAddress, } = require('../helper/portedTokens');

const chain = 'bsc'

const DEPOSIT_TOKENS = [
  '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // wBnB
  '0x2170Ed0880ac9A755fd29B2688956BD959F933F8', //ETH,
  '0x55d398326f99059fF775485246999027B3197955', // USDT
  '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c', // BTC
]

const DEPOSIT_CONTRACT = '0xe94286A3e83D66aB3bAF9840184a2E5680e9A7eC'
const BANK_ADDRESS = '0x86D21a8183e150e5050ba5DFd53535b6dE100435'

async function tvl(timestamp, ethBlock, chainBlocks) {
  const balances = {}

  const block = chainBlocks[chain]
  const tokenPairs = DEPOSIT_TOKENS.map(token => [
    [token, DEPOSIT_CONTRACT],
    [token, BANK_ADDRESS],
  ]).flat()
  const transform = await transformBscAddress()

  await sumTokens(
    balances,
    tokenPairs,
    block,
    chain,
    transform,
  )

  return balances
}

module.exports = {
  bsc: {
    tvl
  },
}
'''
'''--- projects/balanced/index.js ---
const axios = require("axios");
const BigNumber = require("bignumber.js");

const icxApiEndpoint = 'https://ctz.solidwallet.io/api/v3'
const balancedDexContract = 'cxa0af3165c08318e988cb30993b3048335b94af6c'
const balancedLoansContract = 'cx66d4d90f5f113eba575bf793570135f9b10cece1'
const bandOracleContract = 'cx087b4164a87fdfb7b714f3bafe9dfb050fd6b132'
const bnusdContract = 'cx88fd7df7ddff82f7cc735c871dc519838cb235bb'
const sicxContract = 'cx2609b924e33ef00b648a409245c7ea394c467824'

async function icxCall(address, method, params) {
    let response = await axios.post(icxApiEndpoint, {
        jsonrpc: '2.0',
        method: 'icx_call',
        id: 1234,
        params: {
            to: address,
            dataType: 'call',
            data: {
                method: method,
                params: params
            }
        }
    })
    return response.data.result
}

async function getIcxUsdPrice() {
    let response = await icxCall(bandOracleContract, 'get_ref_data', {'_symbol': 'ICX'})
    let icxUsdPrice = parseInt(response.rate, 16) / 10 ** 9;
    return icxUsdPrice
}

async function getSicxIcxPrice() {
    let response = await icxCall(balancedDexContract, 'getPrice', {'_id': '1'})
    let sicxIcxPrice = parseInt(response, 16) / 10 ** 18;
    return sicxIcxPrice
}

async function getLoanTvl() {
    let icxUsdPrice = await getIcxUsdPrice()
    let sicxIcxPrice = await getSicxIcxPrice()
    let response = await icxCall(balancedLoansContract, 'getTotalCollateral') // Fetch total sICX collateral.
    let loanTvlSicx = parseInt(response, 16) / 10 ** 18;
    let loanTvlUsd = loanTvlSicx * icxUsdPrice * sicxIcxPrice
    return loanTvlUsd
}

async function getBnusdUsdPrice() {
    let sicxUsdPrice = await getSicxUsdPrice()
    let response = await icxCall(balancedDexContract, 'getSicxBnusdPrice')
    let sicxBnusdPrice = parseInt(response, 16) / 10 ** 18
    let bnusdSicxPrice = 1 / sicxBnusdPrice
    let bnusdUsdPrice = bnusdSicxPrice * sicxUsdPrice
    return bnusdUsdPrice
}

async function getSicxUsdPrice() {
    let sicxIcxPrice = await getSicxIcxPrice()
    let icxUsdPrice = await getIcxUsdPrice()
    let sicxUsdPrice = sicxIcxPrice * icxUsdPrice
    return sicxUsdPrice
}

async function getDexTvl() {
    let icxUsdPrice = await getIcxUsdPrice()
    let sicxUsdPrice = await getSicxUsdPrice()
    let bnusdUsdPrice = await getBnusdUsdPrice()

    let sicxIcxPool = await icxCall(balancedDexContract, 'totalSupply', {'_id': '1'}); // Get sICX/ICX TVL in ICX.
    let sicxBnusdPool = await icxCall(balancedDexContract, 'getPoolTotal', {'_id': '2', '_token': bnusdContract}); // Get sICX/bnUSD TVL in bnUSD.
    let balnBnusdPool = await icxCall(balancedDexContract, 'getPoolTotal', {'_id': '3', '_token': bnusdContract}); // Get BALN/bnUSD TVL in bvnUSD.
    let balnSicxPool = await icxCall(balancedDexContract, 'getPoolTotal', {'_id': '4', '_token': sicxContract}); // Get BALN/sICX TVL in sICX.

    let sicxIcxTvlUsd = parseInt(sicxIcxPool, 16) * icxUsdPrice / 10 ** 18;
    let sicxBnusdTvlUsd = parseInt(sicxBnusdPool, 16) * 2 * bnusdUsdPrice / 10 ** 18; // Multiply by 2 to get USD value of entire pool.
    let balnBnusdTvlUsd = parseInt(balnBnusdPool, 16) * 2 * bnusdUsdPrice / 10 ** 18; // Multiply by 2 to get USD value of entire pool.
    let balnSicxTvlUsd = parseInt(balnSicxPool, 16) * 2 * sicxUsdPrice / 10 ** 18; // Multiply by 2 to get USD value of entire pool.
    
    let dexTvlUsd = sicxIcxTvlUsd + sicxBnusdTvlUsd + balnBnusdTvlUsd + balnSicxTvlUsd
    
    return dexTvlUsd;
}

async function fetch() {
    let loanTvl = await getLoanTvl()
    let dexTvl = await getDexTvl()
    let tvl = new BigNumber(loanTvl + dexTvl).toFixed(2);
    return tvl
}

module.exports = {
    methodology: 'TVL consists of liquidty on the DEX and deposits made to the lending program. Data is pulled from the ICX API "https://ctz.solidwallet.io/api/v3"',
    fetch,
}
'''
'''--- projects/balancer/abi.json ---

{
    "getCurrentTokens": {
        "constant": true,
        "inputs": [],
        "name": "getCurrentTokens",
        "outputs": [
            {
            "internalType": "address[]",
            "name": "tokens",
            "type": "address[]"
            }
        ],
        "payable": false,
         "type": "function"
    }

}

'''
'''--- projects/balancer/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");
const { GraphQLClient, gql } = require('graphql-request')
const { toUSDTBalances } = require('../helper/balances');
const { getBlock } = require('../helper/getBlock');
async function getTVL(subgraphName, block) {
  // delayed by around 5 mins to allow subgraph to update
  block -= 25;
  var endpoint = `https://api.thegraph.com/subgraphs/name/balancer-labs/${subgraphName}`
  var graphQLClient = new GraphQLClient(endpoint)

  var query = gql`
  query get_tvl($block: Int) {
    balancers(
      first: 5,
      block: { number: $block }
    ) {
      totalLiquidity,
      totalSwapVolume
    }
  }
  `;
  const results = await graphQLClient.request(query, {
    block
  })
  return results.balancers[0].totalLiquidity;
}

async function getTVLFromPools(subgraphName, block) {
  // delayed by around 5 mins to allow subgraph to update
  block -= 25;
  var endpoint = `https://api.thegraph.com/subgraphs/name/balancer-labs/${subgraphName}`
  var graphQLClient = new GraphQLClient(endpoint)

  var query = gql`
  query get_tvl($block: Int) {
    pools (
      block: { number: $block }
      orderBy: liquidity
      orderDirection:desc
    ) {
      liquidity
    }
  }
  `;
  const results = await graphQLClient.request(query, {
    block
  })
  return results.pools
    .map(i => +i.liquidity)
    .filter(i => i < 1e10)  // we filter out if liquidity is higher than 10B as it is unlikely/error
    .reduce((acc, i) => acc + i, 0)
}

async function ethereum(timestamp, ethBlock) {
  const [v1,v2] = await Promise.all([getTVLFromPools("balancer", ethBlock), getTVL("balancer-v2", ethBlock)])

  return toUSDTBalances(BigNumber(v1).plus(v2))
}

async function polygon(timestamp, ethBlock, chainBlocks) {
  return toUSDTBalances(await getTVL("balancer-polygon-v2", await getBlock(timestamp, "polygon", chainBlocks)))
}

async function arbitrum(timestamp, ethBlock, chainBlocks) {
  return toUSDTBalances(await getTVL("balancer-arbitrum-v2", await getBlock(timestamp, "arbitrum", chainBlocks)))
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology: `Balancer TVL is pulled from the Balancer subgraph and includes deposits made to Balancer v1 and v2 liquidity pools.`,
  ethereum:{
    tvl: ethereum
  },
  polygon:{
    tvl: polygon
  },
  arbitrum:{
    tvl: arbitrum
  },
}

'''
'''--- projects/balancer/onchain.js ---
const sdk = require('@defillama/sdk');

const { request, gql } = require("graphql-request");
const { transformArbitrumAddress } = require('../helper/portedTokens')
const { requery } = require('../helper/requery')

const abi = require('./abi');
const ignored = ["0xC011A72400E58ecD99Ee497CF89E3775d4bd732F", "0x57Ab1E02fEE23774580C119740129eAC7081e9D3", // old synthetix
"0x00f109f744B5C918b13d4e6a834887Eb7d651535", "0x645F7dd67479663EE7a42feFEC2E55A857cb1833" // self destructed
]

const V2_ADDRESS = '0xBA12222222228d8Ba445958a75a0704d566BF2C8'; // shared by all networks
const subgraphs = {
  ethereum: 'balancer-v2',
  arbitrum: 'balancer-arbitrum-v2',
  polygon: 'balancer-polygon-v2'
}

async function v1(timestamp, block) {
  let balances = {
    '0x0000000000000000000000000000000000000000': '0', // ETH
  };

  let poolLogs = await sdk.api.util.getLogs({
    target: '0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd',
    topic: 'LOG_NEW_POOL(address,address)',
    keys: ['topics'],
    fromBlock: 9562480,
    toBlock: block
  });

  let poolCalls = [];

  let pools = poolLogs.output.map((poolLog) => {
    if (poolLog.topics) {
      return `0x${poolLog.topics[2].slice(26)}`
    } else {
      return `0x${poolLog[2].slice(26)}`
    }
  });

  const poolTokenData = (await sdk.api.abi.multiCall({
    calls: pools.map((poolAddress) => ({ target: poolAddress })),
    abi: abi.getCurrentTokens,
  })).output;

  poolTokenData.forEach((poolToken) => {
    let poolTokens = poolToken.output;
    let poolAddress = poolToken.input.target;

    poolTokens.forEach((token) => {
      if(ignored.includes(token)){
        return
      }
      poolCalls.push({
        target: token,
        params: poolAddress,
      });
    })
  });

  let poolBalances = await sdk.api.abi.multiCall({
    block,
    calls: poolCalls,
    abi: 'erc20:balanceOf'
  });

  sdk.util.sumMultiBalanceOf(balances, poolBalances)
  return balances
}

function v2(chain) {
  return async (time, ethBlock, chainBlocks) => {
    const block = chainBlocks[chain]
    const balances = {}
    const tokensApi = `https://api.thegraph.com/subgraphs/name/balancer-labs/${subgraphs[chain]}`;
    const POOL_TOKENS = gql`
      {
        balancers {
          pools {
            tokens {
              address
            }
          }
        }
      }`;

    const v2Tokens = await request(tokensApi, POOL_TOKENS, {
      block,
    });
    let tokenAddresses = [];
    for (let i = 0; i < v2Tokens.balancers[0].pools.length; i++) {
      for (let address of v2Tokens.balancers[0].pools[i].tokens) {
        tokenAddresses.push(address.address)
      }
    }
    tokenAddresses = [...new Set(tokenAddresses)]

    let v2Calls = tokenAddresses.map((address) => {
      return {
        target: address,
        params: V2_ADDRESS
      }
    });
    let v2Balances = await sdk.api.abi.multiCall({
      block,
      calls: v2Calls,
      abi: 'erc20:balanceOf'
    });
    await requery(v2Balances, chain, block, "erc20:balanceOf")
    let transform = addr => `${chain}:${addr}`
    if(chain === "arbitrum"){
      transform = await transformArbitrumAddress()
    }
    sdk.util.sumMultiBalanceOf(balances, v2Balances, true, transform)

    return balances;
  }
}

module.exports = {
  polygon:{
    tvl:  v2("polygon")
  },
  arbitrum:{
    tvl: v2("arbitrum")
  },
  ethereum:{
    tvl: sdk.util.sumChainTvls([v1, v2("ethereum")])
  },
}

'''
'''--- projects/bamboodefi/index.js ---
const sdk = require("@defillama/sdk");
const { uniTvlExport } = require("../helper/calculateUniTvl.js");
const { getChainTransform } = require("../helper/portedTokens");

const factoryETH = "0x3823Ac41b77e51bf0E6536CE465479cBdedcaEa9";
const factoryBSC = "0xFC2604a3BCB3BA6016003806A288E7aBF75c8Aa3";
const factoryPolygon = "0x25cc30af6b2957b0ed7ceca026fc204fdbe04e59";
const factoryVelas = "0xFC2604a3BCB3BA6016003806A288E7aBF75c8Aa3";

module.exports = {
  misrepresentedTokens: false,
  timetravel: true,
  methodology:
    "TVL is calculated from the Bamboo DeFi factory smart contracts on each chain.",
  bsc: {
    tvl: uniTvlExport(factoryBSC, "bsc"),
  },
  ethereum: {
    tvl: uniTvlExport(factoryETH, "ethereum"),
  },

  polygon: {
    tvl: uniTvlExport(factoryPolygon, "polygon"),
  },
  velas: {
    tvl: uniTvlExport(factoryVelas, "velas", () => getChainTransform("velas")),
  },
}

'''
'''--- projects/banana.js ---
const { masterChefExports, } = require("./helper/masterchef")

const token = "0xc67b9b1b0557aeafa10aa1ffa1d7c87087a6149e";
const masterchef = "0x0e69359B4783094260abFaD7dD904999fc1d6Fd0";

module.exports = {
    ...masterChefExports(masterchef, "boba", token, false)
}
'''
'''--- projects/banano/index.js ---
const { pool2BalanceFromMasterChefExports} = require("../helper/pool2.js");
const masterchefAbi = require("../helper/abis/masterchef.json");

//Polygon and BSC staking contracts
const polygonContract = "0xefa4aED9Cf41A8A0FcdA4e88EfA2F60675bAeC9F";
const bscContract = "0x1E30E12e82956540bf870A40FD1215fC083a3751";

const ban = "0xe20B9e246db5a0d21BF9209E4858Bc9A3ff7A034";

module.exports = {
    methodology: 'Pool2 TVL in Polygon and BSC LPs',
    polygon: {
        tvl: async ()=>({}),
        pool2: pool2BalanceFromMasterChefExports(polygonContract, ban, "polygon", addr=>`polygon:${addr}`, masterchefAbi.poolInfo)
    },   
    bsc: {
        tvl: async ()=>({}),
        pool2: pool2BalanceFromMasterChefExports(bscContract, ban, "bsc", addr=>`bsc:${addr}`, masterchefAbi.poolInfo)
    },
}

'''
'''--- projects/bancor/abi.json ---
{
  "abiContractRegistryAddressOf": {
    "inputs": [{
      "internalType": "bytes32",
      "name": "_contractName",
      "type": "bytes32"
    }],
    "name": "addressOf",
    "outputs": [{
      "internalType": "address",
      "name": "",
      "type": "address"
    }],
    "stateMutability": "view",
    "type": "function"
  },
  "abiConverterRegistryGetPools": {
    "inputs": [],
    "name": "getLiquidityPools",
    "outputs": [{
      "internalType": "address[]",
      "name": "",
      "type": "address[]"
    }],
    "stateMutability": "view",
    "type": "function"
  },
  "abiRegistryGetConvertersBySmartTokens": {
    "inputs": [{
      "internalType": "address[]",
      "name": "_smartTokens",
      "type": "address[]"
    }],
    "name": "getConvertersBySmartTokens",
    "outputs": [{
      "internalType": "contract IConverter[]",
      "name": "",
      "type": "address[]"
    }],
    "stateMutability": "view",
    "type": "function"
  },
  "abiConverterConnectorTokens": {
    "inputs": [{
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }],
    "name": "connectorTokens",
    "outputs": [{
      "internalType": "contract IERC20Token",
      "name": "",
      "type": "address"
    }],
    "stateMutability": "view",
    "type": "function"
  },
  "liquidityPools": {
      "inputs": [],
      "name": "liquidityPools",
      "outputs": [
          {
              "internalType": "contract Token[]",
              "name": "",
              "type": "address[]"
          }
      ],
      "stateMutability": "view",
      "type": "function"
  }
}

'''
'''--- projects/bancor/index.js ---
const abi = require('./abi.json');
const sdk = require('@defillama/sdk');
const { sumTokens } = require('../helper/unwrapLPs');

async function generateCallsByBlockchain(block) {
  const registryAddress = '0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4';
  const converterRegistryHex = '0x42616e636f72436f6e7665727465725265676973747279000000000000000000';

  let result;
  let converterRegistryAddress;

  if (block < 9195218) {
    converterRegistryAddress = '0xf6E2D7F616B67E46D708e4410746E9AAb3a4C518';
  }
  else {
    // get converter registry address
    result = await sdk.api.abi.call({
      target: registryAddress,
      abi: abi['abiContractRegistryAddressOf'],
      params: [converterRegistryHex],
      block
    });

    converterRegistryAddress = result.output;
  }

  // get pool anchor addresses
  result = await sdk.api.abi.call({
    target: converterRegistryAddress,
    abi: abi['abiConverterRegistryGetPools'],
    block
  });

  // get converter addresses
  result = await sdk.api.abi.call({
    target: converterRegistryAddress,
    abi: abi['abiRegistryGetConvertersBySmartTokens'],
    params: [result.output],
    block
  });

  // get reserve token addresses (currently limited to 2)
  const converterAddresses = result.output;
  const reserveTokenCalls = [];
  for (let i = 0; i < converterAddresses.length; i++) {
    reserveTokenCalls.push({
      target: converterAddresses[i],
      params: [0]
    });
    reserveTokenCalls.push({
      target: converterAddresses[i],
      params: [1]
    });
  }

  result = await sdk.api.abi.multiCall({
    calls: reserveTokenCalls,
    abi: abi['abiConverterConnectorTokens'],
    block
  });

  // create reserve balance calls
  const balanceCalls = [];
  for (let i = 0; i < result.output.length; i++) {
    const item = result.output[i];
    balanceCalls.push({
      target: item.output,
      params: [item.input.target]
    });
  }

  return balanceCalls;
}

const ethAddress = '0x0000000000000000000000000000000000000000';
const ethReserveAddresses = ['0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'];
const bancor = '0x1f573d6fb3f13d689ff844b4ce37794d79a7ff1c'

async function addV3Balance(balances, block) {
  const masterVault = '0x649765821D9f64198c905eC0B2B037a4a52Bc373'
  const networkSettings = '0xeEF417e1D5CC832e619ae18D2F140De2999dD4fB'
  const { output: tokens } = await sdk.api.abi.call({
    target: networkSettings, block, abi: abi.liquidityPools
  })

  tokens.push(bancor)

  const toa = tokens
    .filter(t => !ethReserveAddresses.includes(t.toLowerCase()))
    .map(t => [t, masterVault])

  const { output: balance } = await sdk.api.eth.getBalance({ target: masterVault, block })
  sdk.util.sumSingleBalance(balances, ethAddress, balance)
  return sumTokens(balances, toa, block)
}

/*==================================================
  TVL
  ==================================================*/

async function tvl(timestamp, block) {
  let balanceCalls = await generateCallsByBlockchain(block);

  // get ETH balances
  let balances = {};

  const ethBalanceCalls = balanceCalls.filter((call) => ethReserveAddresses.includes(call.target.toLowerCase())).map(call => call.params[0])
  ethBalanceCalls.push('0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315')

  const { output: ethBalances } = await sdk.api.eth.getBalances({ targets: ethBalanceCalls, block })
  ethBalances.forEach(bal => sdk.util.sumSingleBalance(balances, ethAddress, bal.balance))

  // get reserve balances
  let result = await sdk.api.abi.multiCall({
    calls: balanceCalls.filter(c => c.target.toLowerCase() !== "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".toLowerCase()),
    abi: 'erc20:balanceOf',
    block
  });

  sdk.util.sumMultiBalanceOf(balances, result);

  return addV3Balance(balances, block)
}

module.exports = {
  start: 1501632000,  // 08/02/2017 @ 12:00am (UTC)
  ethereum: {
    tvl,
  }
};

'''
'''--- projects/banksyfarm/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const banksy = "0x9C26e24ac6f0EA783fF9CA2bf81543c67cf446d2";
const masterchef = "0x64aB872a2937dE057F21c8e0596C0175FF2084d8"

module.exports = {
    ...masterChefExports(masterchef, "avax", banksy, false)
}
'''
'''--- projects/bao/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accBaoPerShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/bao/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens, unwrapLPsAuto,  } = require('../helper/unwrapLPs')
const abi = require('./abi.json')
const erc20 = require('./../helper/abis/erc20.json')

const masterChef = '0xBD530a1c060DC600b951f16dc656E4EA451d1A2D'
const xdaiMasterChef = '0xf712a82DD8e2Ac923299193e9d6dAEda2d5a32fd'

function chainTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    return getTvl(chain, chainBlocks[chain], ethBlock)
  }
}

async function getTvl(chain, block, ethBlock) {
  const owner = chain === 'xdai' ? xdaiMasterChef : masterChef
  const { output: poolLength } = await sdk.api.abi.call({
    target: owner,
    abi: abi.poolLength,
    chain, block,
  });
  const calls = []
  const toa = []
  for (let i = 0; i < poolLength; i++)
    calls.push({ params: i })
  let { output: tokens } = await sdk.api.abi.multiCall({
    target: owner,
    abi: abi.poolInfo,
    calls,
    chain, block,
  })
  tokens.forEach(t => toa.push([t.output[0], owner]))
  if (chain !== 'xdai') {
    return sumTokens({}, toa, block, chain, undefined, { resolveLP: true })
  }

  const balances = {}
  await sumTokens(balances, toa, block, chain)
  const tokenMapping = {}
  const tokenNameMapping = {}
  Object.keys(balances).forEach(i => {
    if (!i.startsWith('xdai'))  return; // we want to resolve LP tokens only, ignore all others 
    const bareToken = stripTokenHeader(i).toLowerCase()
    tokenMapping[bareToken] = i
  })
  const { output: tokenNames } = await sdk.api.abi.multiCall({
    abi: erc20.name,
    calls: Object.keys(tokenMapping).map(i => ({ target: i })),
    chain, block,
  })

  tokenNames.forEach(i => tokenNameMapping[i.input.target] = i.output)
  const ethBalances = {}
  
  // move bridged sushi LP balances to 'ethBalances'
  Object.entries(balances).forEach(([token, balance]) => {
    const bareToken = stripTokenHeader(token).toLowerCase()
    if (!/Token on/.test(tokenNameMapping[bareToken] || '')) return;
    delete balances[token]
    sdk.util.sumSingleBalance(ethBalances, bareToken, balance)
  })

  // console.log(JSON.stringify(ethBalances, null, 2));
  // resolve LPs
  await Promise.all([
    unwrapLPsAuto({ balances, block, chain, }),
    // disabling resolving ETH balance resolving since we dont know how to resolve bridged LP address
    // unwrapLPsAuto({ balances: ethBalances, block: ethBlock, chain: 'ethereum', }),
  ])

  // merge balances
  // Object.entries(ethBalances).forEach(([token, balance]) => {
  //   sdk.util.sumSingleBalance(balances, token, balance)
  // })

  return balances
}

module.exports = {
  ethereum: {
    tvl: chainTvl('ethereum')
  },
  xdai: {
    tvl: chainTvl('xdai')
  },
}

function stripTokenHeader(token) {
  return token.indexOf(':') > -1 ? token.split(':')[1] : token
}
'''
'''--- projects/barnbridge/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');
const { fetchURL } = require('../helper/utils');

const syPoolAPIs = {
    'ethereum': 'https://api-v2.barnbridge.com/api/smartyield/pools',
    'polygon': 'https://prod-poly-v2.api.barnbridge.com/api/smartyield/pools',
}
const saPoolAPIs = {
    'ethereum': 'https://api-v2.barnbridge.com/api/smartalpha/pools',
    'polygon': 'https://prod-poly-v2.api.barnbridge.com/api/smartalpha/pools',
    'avax': 'https://prod-avalanche.api.barnbridge.com/api/smartalpha/pools'
}

const STK_AAVE_ADDRESS = '0x4da27a545c0c5b758a6ba100e3a049001de870f5';
const AAVE_ADDRESS = '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9';

async function fetchSyPools(apiUrl) {
    return fetchURL(apiUrl)
        .then(res => res.data)
        .then(({status, data}) => status === 200 ? data : []);
}

async function fetchSaPools(apiUrl) {
    return fetchURL(apiUrl)
        .then(res => res.data)
        .then(({status, data}) => status === 200 ? data : []);
}

function syGetUnderlyingTotal(chain, smartYieldAddress, block) {
    return sdk.api.abi.call({
        abi: {
            name: "underlyingTotal",
            type: "function",
            stateMutability: "view",
            constant: true,
            payable: false,
            inputs: [],
            outputs: [
                {
                    name: "total",
                    type: "uint256",
                    internalType: "uint256",
                },
            ],
        },
        target: smartYieldAddress,
        chain,
        block,
    }).then(({output}) => new BigNumber(output));
}

function saGetEpochBalance(chain, smartAlphaAddress, block) {
    return sdk.api.abi.call({
        abi: {
            name: "epochBalance",
            type: "function",
            stateMutability: "view",
            constant: true,
            payable: false,
            inputs: [],
            outputs: [
                {
                    name: "balance",
                    type: "uint256",
                    internalType: "uint256",
                },
            ],
        },
        target: smartAlphaAddress,
        chain,
        block,
    }).then(({output}) => new BigNumber(output));
}

function saGetQueuedJuniorsUnderlyingIn(chain, smartAlphaAddress, block) {
    return sdk.api.abi.call({
        abi: {
            name: "queuedJuniorsUnderlyingIn",
            type: "function",
            stateMutability: "view",
            constant: true,
            payable: false,
            inputs: [],
            outputs: [
                {
                    name: "amount",
                    type: "uint256",
                    internalType: "uint256",
                },
            ],
        },
        target: smartAlphaAddress,
        chain,
        block,
    }).then(({output}) => new BigNumber(output));
}

function saGetQueuedSeniorsUnderlyingIn(chain, smartAlphaAddress, block) {
    return sdk.api.abi.call({
        abi: {
            name: "queuedSeniorsUnderlyingIn",
            type: "function",
            stateMutability: "view",
            constant: true,
            payable: false,
            inputs: [],
            outputs: [
                {
                    name: "amount",
                    type: "uint256",
                    internalType: "uint256",
                },
            ],
        },
        target: smartAlphaAddress,
        chain,
        block,
    }).then(({output}) => new BigNumber(output));
}

function resolveAddress(address) {
    switch (address) {
        case STK_AAVE_ADDRESS:
            return AAVE_ADDRESS;
        default:
            return address;
    }
}

function sumTvl(tvlList = []) {
    return async (...args) => {
        const results = await Promise.all(tvlList.map(fn => fn(...args)));
        return results.reduce((a, c) => Object.assign(a, c), {});
    };
}

async function tvl(chain, block) {
    const balances = {};

    if (chain in syPoolAPIs) {
        // calculate TVL from SmartYield pools
        const syPools = await fetchSyPools(syPoolAPIs[chain]);

        await Promise.all(syPools.map(async syPool => {
            const {smartYieldAddress, underlyingAddress} = syPool;
            const underlyingTotal = await syGetUnderlyingTotal(chain, smartYieldAddress, block);

            sdk.util.sumSingleBalance(balances, chain+':'+resolveAddress(underlyingAddress), underlyingTotal.toFixed(0));
        }));
    };
    if (chain in saPoolAPIs) {
        // calculate TVL from SmartAlpha pools
        const saPools = await fetchSaPools(saPoolAPIs[chain]);

        await Promise.all(saPools.map(async saPool => {
            const {poolAddress, poolToken} = saPool;
            const [epochBalance, queuedJuniorsUnderlyingIn, queuedSeniorsUnderlyingIn] = await Promise.all([
                saGetEpochBalance(chain, poolAddress, block),
                saGetQueuedJuniorsUnderlyingIn(chain, poolAddress, block),
                saGetQueuedSeniorsUnderlyingIn(chain, poolAddress, block),
            ]);

            const underlyingTotal = epochBalance
                .plus(queuedJuniorsUnderlyingIn)
                .plus(queuedSeniorsUnderlyingIn);
            sdk.util.sumSingleBalance(balances, chain+':'+resolveAddress(poolToken.address), underlyingTotal.toFixed(0));
        }));
    };

    return balances;
}

async function mainnetTvl(timestamp, block, chainBlocks) {
    return tvl('ethereum', block)
}

async function polygonTvl(timestamp, block, chainBlocks) {
    return tvl('polygon', chainBlocks['polygon'])
}

async function avaxTvl(timestamp, block, chainBlocks) {
    return tvl('avax', chainBlocks['avax'])
}
module.exports = {
    start: 1615564559, // Mar-24-2021 02:17:40 PM +UTC
    doublecounted: true,
    timetravel: false,
    misrepresentedTokens: true,
    ethereum: {
        tvl: mainnetTvl,
    },
    polygon: {
        tvl: polygonTvl
    },
    avalanche: {
        tvl: avaxTvl
    },
};

'''
'''--- projects/based-finance/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapCrv, unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");

const bshareRewardPoolAddress = "0xac0fa95058616d7539b6eecb6418a68e7c18a746";
const acropolisAddress = "0xe5009dd5912a68b0d7c6f874cd0b4492c9f0e5cd";
const treasuryAddress = "0xa0e0f462d66de459711bc721ce1fdcc3d9405831";

// Token Addresses
const basedTokenAddress = "0x8d7d3409881b51466b483b11ea1b8a03cded89ae";
const bshareTokenAddress = "0x49c290ff692149a4e16611c694fded42c954ab7a";
const tombAddress = "0x6c021ae822bea943b2e66552bde1d2696a53fbb7";
const usdcAddress = "0x04068da6c83afcfa0e13ba15a6696662335d5b75";
const usdtAddress = "0x049d68029688eAbF473097a2fC38ef61633A3C7A";
const maiAddress = "0xfB98B335551a418cD0737375a2ea0ded62Ea213b";
const wftmAddress = "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83";
const tshareAddress = "0x4cdF39285D7Ca8eB3f090fDA0C069ba5F4145B37";

// LP Addresses
const basedTombLpAddress = "0xab2ddcbb346327bbdf97120b0dd5ee172a9c8f9e";
const bshareFtmLpAddress = "0x6f607443dc307dcbe570d0ecff79d65838630b56";
const basedBshareLpAddress = "0x5748b5Dd1f59342f85d170c48C427959c2f9f262";
const basedMaiTSwapLpAddress = "0x7B5B3751550be4FF87aC6bda89533F7A0c9825B3";
const basedTombTSwapLpAddress = "0x172BFaA8991A54ABD0b3EE3d4F8CBDab7046FF79";
const basedUsdcTSwapLpAddress = "0x7c849a7E2cb08f09cf37482cc0A04ecB5891844a";
const g3CrvAddress = "0xd02a30d33153877bc20e5721ee53dedee0422b2f";
const crv3CryptoAddress = "0x58e57cA18B7A47112b877E31929798Cd3D703b0f";

const poolLPs = [
  basedTombLpAddress,
  bshareFtmLpAddress,
  basedBshareLpAddress,
  basedMaiTSwapLpAddress,
  basedTombTSwapLpAddress,
  basedUsdcTSwapLpAddress,
  g3CrvAddress,
  crv3CryptoAddress,
];

const treasuryTokens = [
  basedBshareLpAddress,
  basedMaiTSwapLpAddress,
  basedTombTSwapLpAddress,
  basedUsdcTSwapLpAddress,
  g3CrvAddress,
  crv3CryptoAddress,
  tombAddress,
  usdcAddress,
  usdtAddress,
  wftmAddress,
  basedTokenAddress,
  bshareTokenAddress,
  tshareAddress,
  maiAddress,
];

async function calcPool2(rewardPool, lps, block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.map((p) => ({
        target: p,
        params: rewardPool,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;

  let lpPositions = [];
  lpBalances.slice(0, 6).forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  await unwrapCrv(
    balances,
    g3CrvAddress,
    lpBalances[6].output,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  await unwrapCrv(
    balances,
    crv3CryptoAddress,
    lpBalances[7].output,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  return balances;
}

async function calcTreasury(treasury, tokens, block, chain) {
  let balances = {};

  const tokenBalances = (
    await sdk.api.abi.multiCall({
      calls: tokens.map((p) => ({
        target: p,
        params: treasury,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;

  let lpPositions = [];
  tokenBalances.slice(0, 4).forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  await unwrapCrv(
    balances,
    g3CrvAddress,
    tokenBalances[4].output,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  await unwrapCrv(
    balances,
    crv3CryptoAddress,
    tokenBalances[5].output,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );

  tokenBalances.slice(6).forEach((balance) => {
    sdk.util.sumSingleBalance(balances, `${chain}:${balance.input.target}`, balance.output);
  });

  return balances;
}

async function pool2(timestamp, block, chainBlocks) {
  return await calcPool2(bshareRewardPoolAddress, poolLPs, chainBlocks.fantom, "fantom");
}

async function treasury(timestamp, block, chainBlocks) {
  return await calcTreasury(treasuryAddress, treasuryTokens, chainBlocks.fantom, "fantom");  
}

module.exports = {
  methodology: "Pool2 deposits consist of BASED/TOMB, BSHARE/FTM LP, g3CRV (geist stable LP on Curve) receipt tokens while the staking TVL consists of the BSHARES tokens locked within the Acropolis contract. Treasury consists of deposit fees accumulated from genesis pools as well as g3CRV pool",
  fantom: {
    tvl: async () => ({}),
    pool2,
    staking: staking(acropolisAddress, bshareTokenAddress, "fantom"),
    treasury
  },
};

// node test.js projects/based-finance/index.js

'''
'''--- projects/baseprotocol/index.js ---
const { stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");

const stakingContracts = [
  "0x15AE3846d7183Ba27Ad5772FeC55aeeFdd365975",
  "0x6f29466949de9E9Fb906193b97916739Fa982cB5",
  "0x1EF25079FB3F74856A31EF45dD925D203B168721",
  "0x32260d3574E1c698Eb728Ac1E69DCf33f581C25b",
  "0x84f0b803c7EA123fd1eE3e7Dd7aA6552f65dAc88",
];
const BASE = "0x07150e919b4de5fd6a63de1f9384828396f25fdc";

const stakingLpContracts = [
  "0x84f0b803c7EA123fd1eE3e7Dd7aA6552f65dAc88",
  "0xef73903956E599611bF36aC1F209045544AAD423",
  "0x6D075dF51cdF493FB3AA09f33166a9815339b206",
  "0x3fa7D6dC3836B03d8766BBf5054ac0C2AcaB3Ae9",
];
const WETH_BASE_UNIV2 = "0xdE5b7Ff5b10CC5F8c95A2e2B643e3aBf5179C987";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, BASE),
    pool2: pool2s(stakingLpContracts, [WETH_BASE_UNIV2]),
    tvl: async() => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
};

'''
'''--- projects/basis-cash.js ---
const { sumTokens } = require('./helper/unwrapLPs')

async function tvl(ts, block) {
  const toa = [
    ['0x6b175474e89094c44da98b954eedeac495271d0f', '0xEBd12620E29Dc6c452dB7B96E1F190F3Ee02BDE8'],
    ['0x57ab1ec28d129707052df4df418d58a2d46d5f51', '0xdc42a21e38c3b8028b01a6b00d8dbc648f93305c'],
    ['0xdac17f958d2ee523a2206206994597c13d831ec7', '0x2833bdc5B31269D356BDf92d0fD8f3674E877E44'],
    ['0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0x51882184b7F9BEEd6Db9c617846140DA1d429fD4'],
    ['0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8', '0xC462d8ee54953E7d7bF276612b75387Ea114c3bf'],
  ]

  return sumTokens(undefined, toa, block)
}

module.exports = {
  ethereum: {
    tvl
  }
}

'''
'''--- projects/basis-market/index.js ---
const {getTokenAccountBalance} = require('../helper/solana')

const basis = "Basis9oJw9j8cw53oMV7iqsgo6ihi9ALw4QR31rcjUJa";
const basis_staking = "3sBX8hj4URsiBCSRV26fEHkake295fQnM44EYKKsSs51";

async function stakingTVL(){
  const stakedBasis = await getTokenAccountBalance(basis_staking)
  return {"basis-markets": stakedBasis}
}

module.exports = {
  methodology: `TVL for basis market is staking for now`, 
  solana:{
    tvl: () => ({}),
    staking: stakingTVL//: staking(basis_staking, basis, "solana"), 
  }
}
'''
'''--- projects/basketdao/index.js ---
const sdk = require("@defillama/sdk");
const {unwrapUniswapLPs} = require('../helper/unwrapLPs')
const BigNumber = require('bignumber.js')

const dpiToken = '0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b'
const dpiEthToken = '0x4d5ef58aAc27d99935E5b6B4A6778ff292059991'
const bDPISLP = '0x8d782C5806607E9AAFB2AC38c1DA3838Edf8BD03'
const bDPIToken = '0x0309c98B1bffA350bcb3F9fB9780970CA32a5060'
const masterChef = '0xDB9daa0a50B33e4fe9d0ac16a1Df1d335F96595e'
const weth = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
const continuousMigrator = '0x3f436dE9ef3f07b770c4DB45F60f9f1d323Bbf36'

const bmiToken = "0x0aC00355F80E289f53BF368C9Bdb70f5c114C44B";
const daiToken = '0x6b175474e89094c44da98b954eedeac495271d0f'

async function tvl(timestamp, block) {
  let balances = {};
  const dpiLocked = sdk.api.erc20.balanceOf({
    target: dpiToken,
    owner: masterChef,
    block
  })
  const dpiLockedOnMigrator = sdk.api.erc20.balanceOf({
    target: dpiToken,
    owner: continuousMigrator,
    block
  })
  const dpiLPLocked = sdk.api.erc20.balanceOf({
    target: dpiEthToken,
    owner: masterChef,
    block
  })
  const bdpiSupply = sdk.api.erc20.totalSupply({
    target: bDPIToken,
    block
  })
  const bmiSupply = sdk.api.erc20.totalSupply({
    target: bmiToken,
    block,
  });
  await unwrapUniswapLPs(balances, [{
    token: dpiEthToken,
    balance: (await dpiLPLocked).output
  }], block)
  sdk.util.sumSingleBalance(balances, dpiToken, (await dpiLocked).output)
  sdk.util.sumSingleBalance(balances, dpiToken, (await dpiLockedOnMigrator).output)

  sdk.util.sumSingleBalance(balances, bDPIToken, (await bdpiSupply).output)
  sdk.util.sumSingleBalance(balances, daiToken, (await bmiSupply).output);
  return balances
}

module.exports = {
  tvl
}

'''
'''--- projects/bastilledelabouje/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const chef = "0x51839D39C4Fa187E3A084a4eD34a4007eae66238"
const bastille = "0xcef2b88d5599d578c8d92E7a6e6235FBfaD01eF4"

module.exports = {
  ...masterChefExports(chef, "fantom", bastille, false),
}
'''
'''--- projects/bastion/abi.json ---
{
  "balanceOfUnderlying": {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "balanceOfUnderlying",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  }
}

'''
'''--- projects/bastion/index.js ---
const { compoundExports } = require("../helper/compound");
const sdk = require('@defillama/sdk')

const mainHubExport = compoundExports(
  "0x6De54724e128274520606f038591A00C5E94a1F6",
  "aurora",
  "0x4E8fE8fd314cFC09BDb0942c5adCC37431abDCD0",
  "0xc9bdeed33cd01541e1eed10f90519d2c06fe3feb"
);

const auroraRealmExport = compoundExports(
  "0xA195b3d7AA34E47Fb2D2e5A682DF2d9EFA2daF06",
  "aurora"
);

const multiChainRealmExport = compoundExports(
  "0xe1cf09BDa2e089c63330F0Ffe3F6D6b790835973",
  "aurora"
);

const stakedNearRealmExport = compoundExports(
  "0xE550A886716241AFB7ee276e647207D7667e1E79",
  "aurora"
);

const bastion = [
  mainHubExport,
  auroraRealmExport,
  multiChainRealmExport,
  stakedNearRealmExport,
];

module.exports = {
  timetravel: true,
  aurora: {
    tvl: async (...args) => {
      let balances = {};
      const tvls = await Promise.all(bastion.map(realm => realm.tvl(...args)))
      tvls.forEach(tvl => {
        Object.keys(tvl).forEach(key => sdk.util.sumSingleBalance(balances, key, tvl[key]))
      })
      return balances;
    },
    borrowed: async (...args) => {
      let balances = {};
      const tvls = await Promise.all(bastion.map(realm => realm.borrowed(...args)))
      tvls.forEach(tvl => {
        Object.keys(tvl).forEach(key => sdk.util.sumSingleBalance(balances, key, tvl[key]))
      })
      return balances;
    },
  },
};
'''
'''--- projects/bchpad/index.js ---
const sdk = require('@defillama/sdk');
const { calculateUsdUniTvlPairs } = require('../helper/getUsdUniTvl')
const { staking } = require('../helper/staking')

const CHAIN = "smartbch"

// token contracts
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04"
const LAW = "0x0b00366fBF7037E9d75E4A569ab27dAB84759302"
const MIST = "0x5fA664f69c2A4A3ec94FaC3cBf7049BD9CA73129"
const BPAD = "0x9192940099fDB2338B928DE2cad9Cd1525fEa881"
const CATS = "0x265bD28d79400D55a1665707Fa14A72978FA6043"

// tvl pools
const BPAD_POOL = "0xc39f046a0E2d081e2D01558269D1e3720D2D2EA1" // BPAD single asset pool, ended
const CATS_POOL = "0x9F8a513C11c278dfF624678108B41310fA0398E3" // CATS single asset pool, ended
const MIST_POOL = "0x919D17195Aa7E4733FE1bd7245E97931FD62D21d" // MIST signle asset pool, ended
const LAW_POOL = "0xA3Ac25321789626e30b49d7F34ef0e326D19f582"  // LAW single asset pool

const bpadPoolTVL = staking(BPAD_POOL, BPAD, CHAIN, "bchpad", 18)
const catsPoolTVL = staking(CATS_POOL, CATS, CHAIN, "cashcats", 2)
const mistPoolTVL = staking(MIST_POOL, MIST, CHAIN, "mistswap", 18)
const lawPoolTVL = staking(LAW_POOL, LAW, CHAIN, "law", 18)

// tvl pairs
const BPAD_WBCH_PAIR = "0x8221d04a71fcd0dd3d096cb3b49e22918095933f"
const bpadWbchPairTVL = calculateUsdUniTvlPairs([BPAD_WBCH_PAIR], CHAIN, WBCH, [BPAD], "bitcoin-cash", 18)

const totalTVLs = sdk.util.sumChainTvls([lawPoolTVL, bpadWbchPairTVL])
const totalStaking = sdk.util.sumChainTvls([bpadPoolTVL, catsPoolTVL, mistPoolTVL])

module.exports = {
    misrepresentedTokens: true,
    methodology: "BCHPad uses LP pools created on other dexes and single asset pools of non-native tokens for their liquidity mining, these pools are used for TVL calculation.",
    smartbch: {
        tvl: totalTVLs,
        staking: totalStaking
    },
}

'''
'''--- projects/beamswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { stakingPricedLP, stakingUnknownPricedLP } = require("../helper/staking");

const GLINT_TOKEN = "0xcd3B51D98478D53F4515A306bE565c6EebeF1D58"
const SHARE_CONTRACT = "0x4204cAd97732282d261FbB7088e07557810A6408"
const GLINT_GLMR_LP = "0x99588867e817023162F4d4829995299054a5fC57"

module.exports = {
  misrepresentedTokens: true,
  timetravel: true,
  incentivized: true,
  methodology:
    "Factory address (0x985BcA32293A7A496300a48081947321177a86FD) is used to find the LP pairs. TVL is equal to the liquidity on the AMM & Staking balance is equal to the amount of GLINT staked within the SHARE token contract(0x4204cAd97732282d261FbB7088e07557810A6408)",
  moonbeam: {
    tvl: calculateUsdUniTvl(
      "0x985BcA32293A7A496300a48081947321177a86FD",
      "moonbeam",
      "0xAcc15dC74880C9944775448304B263D191c6077F",
      [
        "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b", //usdc
        "0xcd3B51D98478D53F4515A306bE565c6EebeF1D58", //glint
        "0xa649325aa7c5093d12d6f98eb4378deae68ce23f", //busd
        "0xc9baa8cfdde8e328787e29b4b078abf2dadc2055", //bnb
      ],
      "moonbeam"
    ),
    staking: stakingPricedLP(SHARE_CONTRACT, GLINT_TOKEN, "moonbeam", GLINT_GLMR_LP, "moonbeam")
  },
};
'''
'''--- projects/bean/bean-utils.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");

const bean_abi = {
    "totalDepositedBeans": {
        "inputs": [],
        "name": "totalDepositedBeans",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalDepositedLP": {
        "inputs": [],
        "name": "totalDepositedLP",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getTotalDeposited": {
        "inputs": [
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            }
        ],
        "name": "getTotalDeposited",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
};

const crv_abi = {
	"crvLP_coins": { "stateMutability": "view", "type": "function", "name": "coins", "inputs": [{ "name": "arg0", "type": "uint256" }], "outputs": [{ "name": "", "type": "address" }], "gas": 3123 }
}

// Adapted from /helper/unwrapLPs.js genericUnwrapCrv() because it seems 
// it was written for Curve V1 and tried to calc the amount of tokens in the pool
// from the Curve Pool name. In Curve V2 the name can be changed and therefore
// the old way doesn't work anymore. 
// Please specify how many coins are in the pool.
async function unwrapCrvSimple(balances, crvToken, lpBalance, block, chain, numTokens) {
	const { output: resolvedCrvTotalSupply } = await sdk.api.erc20.totalSupply({
		target: crvToken,
		chain, block
	})
    
    // don't add any balances if total supply of curve pool is 0
    // avoids error later when dividing by it
    if(resolvedCrvTotalSupply === "0") return;

	const LP_tokens_count = numTokens;
	const coins_indices = Array.from(Array(LP_tokens_count).keys())
	const coins = (await sdk.api.abi.multiCall({
		abi: crv_abi['crvLP_coins'],
		calls: coins_indices.map(i => ({ params: [i] })),
		target: crvToken,
		chain,
		block
	})).output.map(c => c.output)
	const crvLP_token_balances = await sdk.api.abi.multiCall({
		abi: 'erc20:balanceOf',
		calls: coins.map(c => ({
			target: c,
			params: crvToken,
		})),
		chain,
		block
	})

	// Edit the balances to weigh with respect to the wallet holdings of the crv LP token
	crvLP_token_balances.output.forEach(call =>
		call.output = BigNumber(call.output).times(lpBalance).div(resolvedCrvTotalSupply).toFixed(0)
	)
	sdk.util.sumMultiBalanceOf(balances, crvLP_token_balances);
}

module.exports = {
    bean_abi,
    unwrapCrvSimple,
}
'''
'''--- projects/bean/index.js ---
const sdk = require('@defillama/sdk');
const utils = require('../helper/utils')
const { sumTokens } = require('../helper/unwrapLPs');
const { unwrapCrvSimple } = require ("./bean-utils.js");

const BEAN_DIA_ADDR = "0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5";

const BEAN_TOKEN_ADDR = "0xdc59ac4fefa32293a95889dc396682858d52e5db";
const BEAN_ETH_ADDR = "0x87898263B6C5BABe34b4ec53F22d98430b91e371";

// To add new curve pools to the TVL:  
// add their LP token address and the number of tokens in the pool 
const BEAN_CRV_POOLS = [
    { addr: "0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D", numToken: 2 },
    { addr: "0x3a70DfA7d2262988064A2D051dd47521E43c9BdD", numToken: 2 },
];

async function staking(time, block) {
    const balances = {};
    // add balance of siloed Beans
    await sumTokens(balances, [[BEAN_TOKEN_ADDR, BEAN_DIA_ADDR]], block)

    return balances;
}

async function pool2(time, block) {
    const balances = {};

    // add balance of siloed BEAN:ETH from uniswap pool
    await sumTokens(balances, [[BEAN_ETH_ADDR, BEAN_DIA_ADDR]], block, undefined, undefined, { resolveLP: true  })

    // add balances of all siloed curve pools
    // this is the block when SiloV2Facet with getTotalDeposited() was introduced
    if (block >= 14218934) {
        await Promise.all(BEAN_CRV_POOLS.map(async (pool) => {
            const lpBalance = (await sdk.api.abi.call({
                abi: 'erc20:balanceOf',
                chain: 'ethereum',
                target: pool.addr,
                params: BEAN_DIA_ADDR,
                block: block,
            })).output;
            // skip if there's a balance of 0 to avoid errors when curve pool doesn't exist yet in a block number
            if(lpBalance !== "0") {
                await unwrapCrvSimple(balances, pool.addr, lpBalance, block, "ethereum", pool.numToken);
            }
        }));
    }

    return balances;
}

module.exports={
    timetravel: true,
    methodology: "Counts all beans and current LPs in the silo.",
    start: 12974077,
    ethereum: {
        tvl: async () => ({}),
        pool2,
        staking,
    },    
    hallmarks: [
        [1650153600, "Governance proposal hack"]
    ]
};
'''
'''--- projects/bearfinance/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");
const { transformFantomAddress } = require("../helper/portedTokens");
const {unwrapUniswapLPs} = require("../helper/unwrapLPs");

const MASTER_CHEF = "0x16a06259725e4c7dFcE648f24D3443AfB96Aa0e5"
const BEAR = "0x3b1a7770A8c97dCB21c18a2E18D60eF1B01d6DeC"
const BEAR_DAI_LP = "0x9e5719236e2ce62dc286ac89ae5a0fa142ae3aa8"
const DAI = '0x6b175474e89094c44da98b954eedeac495271d0f';

async function tvl(timestamp, block, chainBlocks) {
	const transformAddress = await transformFantomAddress();

	const [tokenBalances] = await Promise.all([
		sdk.api.abi.multiCall({
			block,
			calls: [
				{
					target: BEAR,
					params: MASTER_CHEF
				}, {
					target: BEAR_DAI_LP,
					params: MASTER_CHEF
				}
			],
			abi: 'erc20:balanceOf',
			chain: 'fantom',
		})
	])

	let balances = {};
	await unwrapUniswapLPs(balances, [{
		balance: tokenBalances.output[1].output,
		token: tokenBalances.output[1].input.target
	}], block, 'fantom', transformAddress);

	const bearInLiquidity = new BigNumber(balances[`fantom:${BEAR.toLowerCase()}`]);
	const daiInLiquidity = new BigNumber(balances[DAI.toLowerCase()]);
	const bearPrice = daiInLiquidity.dividedBy(bearInLiquidity);
	const daiBalanceFromBear = bearInLiquidity.multipliedBy(bearPrice);
	const bearStaked = new BigNumber(tokenBalances.output[0].output);
	const bearStakedInDai = bearStaked.multipliedBy(bearPrice);

	const results = {};

	results[DAI.toLowerCase()] = new BigNumber(daiInLiquidity.plus(daiBalanceFromBear).plus(bearStakedInDai).toFixed(0)).toString(10);

	return results;
}

async function handleStaking(timestamp, _ethBlock, chainBlocks) {
	const [tokenBalances] = await Promise.all([
		sdk.api.abi.multiCall({
			block: chainBlocks['fantom'],
			calls: [
				{
					target: BEAR,
					params: MASTER_CHEF
				}, {
					target: BEAR_DAI_LP,
					params: MASTER_CHEF
				}
			],
			abi: 'erc20:balanceOf',
			chain: 'fantom',
		})
	]);

	const transformAddress = await transformFantomAddress();
	let balances = {};
	await unwrapUniswapLPs(balances, [{
		balance: tokenBalances.output[1].output,
		token: tokenBalances.output[1].input.target
	}], chainBlocks['fantom'], 'fantom', transformAddress);
	const bearInLiquidity = new BigNumber(balances[`fantom:${BEAR.toLowerCase()}`]);
	const daiInLiquidity = new BigNumber(balances[DAI.toLowerCase()]);
	const bearPrice = daiInLiquidity.dividedBy(bearInLiquidity);
	const bearStaked = new BigNumber(tokenBalances.output[0].output);
	const bearStakedInDai = bearStaked.multipliedBy(bearPrice);
	const results = {};
	results[DAI.toLowerCase()] = new BigNumber(daiInLiquidity.plus(bearStakedInDai).toFixed(0)).toString(10);
	return results;
}

async function handlePool2(timestamp, _ethBlock, chainBlocks) {
	const [tokenBalances] = await Promise.all([
		sdk.api.abi.multiCall({
			block: chainBlocks['fantom'],
			calls: [
				{
					target: BEAR,
					params: MASTER_CHEF
				}, {
					target: BEAR_DAI_LP,
					params: MASTER_CHEF
				}
			],
			abi: 'erc20:balanceOf',
			chain: 'fantom',
		})
	]);

	const transformAddress = await transformFantomAddress();
	let balances = {};
	await unwrapUniswapLPs(balances, [{
		balance: tokenBalances.output[1].output,
		token: tokenBalances.output[1].input.target
	}], chainBlocks['fantom'], 'fantom', transformAddress);
	const bearInLiquidity = new BigNumber(balances[`fantom:${BEAR.toLowerCase()}`]);
	const daiInLiquidity = new BigNumber(balances[DAI.toLowerCase()]);
	const bearPrice = daiInLiquidity.dividedBy(bearInLiquidity);
	const daiBalanceFromBear = bearInLiquidity.multipliedBy(bearPrice);
	const results = {};
	results[DAI.toLowerCase()] = new BigNumber(daiInLiquidity.plus(daiBalanceFromBear).toFixed(0)).toString(10);
	return results;
}

module.exports = {
	deadFrom: 1648765747,
	methodology: "TVL includes all farms in MasterChef contract",
	fantom: {
		tvl,
		staking: handleStaking,
		pool2: handlePool2,
	}
}

'''
'''--- projects/bearnfi/abi.json ---
{
  "wantAddress": {
    "inputs": [],
    "name": "wantAddress",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "wantLockedTotal": {
    "inputs": [],
    "name": "wantLockedTotal",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/bearnfi/index.js ---
const sdk = require("@defillama/sdk");

const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");
const tvlOnPairs = require("../helper/processPairs.js");

const abi = require("./abi.json");
const abiFork = require("../inverse/abi.json");
const utils = require("../helper/utils");

const url = "https://api.bdollar.fi/api/bvault/get-vaults";

const BDEX_FACTORY = "0x2C358A7C62cdb9D554A65A86EEa034bc55D1E715";
const COMPTROLLER = "0xEEea0D4aAd990c4ede8e064A8Cb0A627B432EDa0";
const ibBNB = "0xa3948B027f94Ca195eAC645746435Aaa7eB555a7";

async function bscTvl(timestamp, chainBlocks) {
  let balances = {};

  // --- bVaults & bDollar TVL section, all contract addresses grab from endpoint ---
  // --- Sections of boardroom is not considered in TVL (bDollar Shares related) ---
  let vaultsInfo = (await utils.fetchURL(url)).data.data.vaultInfos;

  const keys = Object.keys(vaultsInfo);

  const strategies = [];

  keys.forEach((key) => {
    strategies.push({
      address: vaultsInfo[key].strategy,
      token: vaultsInfo[key].token,
    });
  });

  let wantedLocked = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      calls: strategies.map((strategy) => ({ target: strategy.address })),
      abi: abi.wantLockedTotal,
      chain: "bsc",
    })
  ).output.map((el) => el.output);

  let wantedAddresses = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      calls: strategies.map((strategy) => ({ target: strategy.address })),
      abi: abi.wantAddress,
      chain: "bsc",
    })
  ).output.map((el) => el.output);

  const transformAdress = await transformBscAddress();

  const lpPositions = [];

  strategies.map((strategy, idx) => {
    if (
      strategy.token.includes("CakeLP") ||
      strategy.token.includes("BLP") ||
      strategy.token.includes("CLP") ||
      strategy.token.includes("vBSWAP") ||
      strategy.token.includes("VLP") && strategy.token !== "VLP_BDO_VDOLLAR"
    ) {
      lpPositions.push({
        token: wantedAddresses[idx],
        balance: wantedLocked[idx],
      });
    } else {
      // apparently this strategy in the endpoint states 0 tvl, so it is filter out
      if (!strategy.token.includes("ibBUSD")) {
        sdk.util.sumSingleBalance(
          balances,
          `bsc:${wantedAddresses[idx]}`,
          wantedLocked[idx]
        );
      }
    }
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["bsc"],
    "bsc",
    transformAdress
  );

  // --- bLending TVL section ---
  let markets = (
    await sdk.api.abi.call({
      block: chainBlocks["bsc"],
      chain: "bsc",
      target: COMPTROLLER,
      params: [],
      abi: abiFork.getAllMarkets,
    })
  ).output.filter((market) => market != ibBNB);

  let getAllCash = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      chain: "bsc",
      calls: markets.map((market) => ({
        target: market,
      })),
      abi: abiFork.getCash,
    })
  ).output.map((cash) => cash.output);

  let allUnderlying = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      chain: "bsc",
      calls: markets.map((market) => ({
        target: market,
      })),
      abi: abiFork.underlying,
    })
  ).output.map((underlying) => underlying.output);

  getAllCash.forEach((cashVal, idx) => {
    sdk.util.sumSingleBalance(balances, `bsc:${allUnderlying[idx]}`, cashVal);
  });

  // missing market without underlying aka BNB
  let getCash = (
    await sdk.api.abi.call({
      block: chainBlocks["bsc"],
      chain: "bsc",
      target: ibBNB,
      params: [],
      abi: abiFork.getCash,
    })
  ).output;

  sdk.util.sumSingleBalance(
    balances,
    "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    getCash
  );

  // --- bDex TVL section ---
  await tvlOnPairs("bsc", chainBlocks, BDEX_FACTORY, balances);

  return balances;
}

module.exports = {
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/becoswap/index.js ---
const { getChainTvl } = require('../helper/getUniSubgraphTvl');
const { getUniTVL } = require('../helper/unknownTokens');
const { staking } = require("../helper/staking");

const chainTvl = getChainTvl({
  kardia: 'https://graph.kaistream.org/subgraphs/name/beco/exchange'
}, "becoFactories")

const becoToken = '0x2Eddba8b949048861d2272068A94792275A51658'
const masterChef = '0x20e8Ff1e1d9BC429489dA76B1Fc20A9BFbF3ee7e'

module.exports = {
  misrepresentedTokens: true,
  methodology: 'TVL accounts for the liquidity on all AMM pools, using the TVL chart on https://becoswap.com/info as the source. Staking accounts for the BECO locked in MasterChef (0x20e8Ff1e1d9BC429489dA76B1Fc20A9BFbF3ee7e)',
  kardia: {
    staking: staking(masterChef, becoToken, "kardia", "becoswap-token", 18),
    // tvl: chainTvl("kardia"),
    tvl: getUniTVL({
      chain: 'kardia',
      coreAssets: [
        '0x92364Ec610eFa050D296f1EEB131f2139FB8810e', // KUSDT
        becoToken,
      ],
      factory: '0x58b54BCDF2aF8a70dD6433EB39b308148261bB49',
    })
  },
};

'''
'''--- projects/beefstake/index.js ---
const retry = require('async-retry')
const utils = require('../helper/utils');

async function getData() {
  const res = await retry(async bail => await utils.fetchURL('https://vite-api.thomiz.dev/tvl/beefstake'))
  return res.data;
}

async function fetch() {
  const data = await getData()
  return data.tvl
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  vite:{
    fetch: fetch
  },
  fetch: fetch
}
'''
'''--- projects/beefy/index.js ---
const utils = require('../helper/utils');
const { toUSDTBalances } = require('../helper/balances');
let _response

function fetchChain(chainId, staking) {
  return async () => {
    if (!_response) _response = utils.fetchURL('https://api.beefy.finance/tvl')
    const response = await _response;

    let tvl = 0;
    const chain = response.data[chainId];
    for (const vault in chain) {
      const isBIFI = vault.includes("bifi")
      if ((isBIFI && staking) || (!isBIFI && !staking)) {
        tvl += Number(chain[vault]);
      }
    }
    if (tvl === 0 && !staking) {
      throw new Error(`chain ${chainId} tvl is 0`)
    }

    return toUSDTBalances(tvl);
  }
}

const chains = {
  optimism: 10,
  cronos: 25,
  bsc: 56,
  fuse: 122,
  heco: 128,
  polygon: 137,
  fantom: 250,
  metis: 1088,
  moonbeam: 1284,
  moonriver: 1285,
  arbitrum: 42161,
  celo: 42220,
  oasis: 42262,
  avalanche: 43114,
  aurora: 1313161554,
  harmony: 1666600000
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  doublecounted: true,
  ...Object.fromEntries(Object.entries(chains).map(chain => [chain[0], {
    tvl: fetchChain(chain[1], false),
    staking: fetchChain(chain[1], true),
  }]))
}

'''
'''--- projects/beethovenx/index.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require("../helper/balances");
const { getBalancerSubgraphTvl } = require("../helper/balancer");

const backendGraphUrlFantom = "https://backend.beets-ftm-node.com/graphql";
const backendGraphUrlOptimism =
  "https://backend-optimism.beets-ftm-node.com/graphql";

const backendGraphQuery = gql`
  query get_tvl {
    data: beetsGetProtocolData {
      totalLiquidity
      block
    }
  }
`;

async function getLatestSyncedBlockFantom() {
  const { data } = await request(backendGraphUrlFantom, backendGraphQuery);
  return data.block;
}

async function getLatestSyncedBlockOptimism() {
  const { data } = await request(backendGraphUrlOptimism, backendGraphQuery);
  return data.block;
}

async function fantom(timestamp, ...params) {
  if (Math.abs(timestamp - Date.now() / 1000) < 3600 / 2) {
    const { data } = await request(backendGraphUrlFantom, backendGraphQuery);
    return toUSDTBalances(data.totalLiquidity);
  }
  return getBalancerSubgraphTvl(
    "https://api.thegraph.com/subgraphs/name/beethovenxfi/beethovenx",
    "fantom"
  )(timestamp, ...params);
}

async function optimism(timestamp, ...params) {
  if (Math.abs(timestamp - Date.now() / 1000) < 3600 / 2) {
    const { data } = await request(backendGraphUrlOptimism, backendGraphQuery);
    return toUSDTBalances(data.totalLiquidity);
  }
  return getBalancerSubgraphTvl(
    "https://api.thegraph.com/subgraphs/name/beethovenxfi/beethovenx-optimism",
    "optimism"
  )(timestamp, ...params);
}

module.exports = {
  methodology: `BeethovenX TVL is pulled from the Balancer subgraph and includes deposits made to v2 liquidity pools.`,
  fantom: {
    tvl: fantom,
  },
  optimism: {
    tvl: optimism,
  },
};

'''
'''--- projects/beglobal/index.js ---
const sdk = require("@defillama/sdk");
const {addFundsInMasterChef} = require("../helper/masterchef");

const token = "0xcF958B53EC9340886d72bb4F5F2977E8C2aB64D3";
const masterchef = "0x7883aD0e83ce50f4820a862EdB56f756599A3248";

async function tvl(timestamp, chain, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, masterchef, chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`, undefined, [token]);
    return balances;
}

async function staking(timestamp, chain, chainBlocks) {
    let balances = {};
    let balance = (await sdk.api.erc20.balanceOf({
        target: token,
        owner: masterchef,
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;
    sdk.util.sumSingleBalance(balances, `bsc:${token}`, balance);
    return balances;
}

module.exports = {
    bsc: {
        tvl,
        staking
    }
}
'''
'''--- projects/behodler/index.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require('../helper/balances');

const graphUrl = 'https://api.thegraph.com/subgraphs/name/arrenv/behodler'
const graphQuery = gql`
query get_tvl($block: Int) {
  behodlers(
    block: { number: $block }
  ) {
    id
    usdVolume
    usdLiquidity
  }
}
`;

async function tvl(timestamp, block) {
  const {behodlers} = await request(
    graphUrl,
    graphQuery,
    {
      block,
    }
  );
  const usdTvl = Number(behodlers[0].usdLiquidity)

  return toUSDTBalances(usdTvl)
}

module.exports = {
  misrepresentedTokens: true,
  methodology: `ERC20 tokens deposited as liquidity on the AMM. You can see this on https://analytics.behodler.io/#/, pulling the data from the 'arrenv/behodler' subgraph`,
  ethereum:{
    tvl,
  },
}
'''
'''--- projects/bella.js ---

const sdk = require('@defillama/sdk')
const { sumTokens } = require('./helper/unwrapLPs')
const bVaultAbi = require('./config/bella/abis/bVault')

const bVaults = {
  bUsdt: { address: '0x2c23276107b45E64c8c59482f4a24f4f2E568ea6', },
  bUsdc: { address: '0x8016907D54eD8BCf5da100c4D0EB434C0185dC0E', },
  bArpa: { address: '0x750d30A8259E63eD72a075f5b6630f08ce7996d0', },
  bWbtc: { address: '0x3fb6b07d77dace1BA6B5f6Ab1d8668643d15a2CC', },
  bHbtc: { address: '0x8D9A39706d3B66446a298f1ae735730257Ec6108', },
  bBusd: { address: '0x378388aa69f3032FA46150221210C7FA70A35153', },
}

const uniswapV2Pools = {
  belUsdt: { address: '0xf0d1109e723cb06e400e2e57d0b6c7c32bedf61a', owner: '0x6731a6a2586a0d555dcff7eb4d8fb7444bdfde2a' },
  belEth: { address: '0x9e98deac1a416c9ce3c892bd8eef586f1291ca35', owner: '0x994be2994471d5ef93c600cf78c2752c5e96f5a7' },
  arpaUsdt: { address: '0x9F624b25991b99D7b14d6740A9D581DD77980808', owner: '0xc935285b0d88069305431dace0c3c01d7e793d84' },
}

async function tvl(ts, block) {
  const tokenCalls = Object.values(bVaults).map(a => ({ target: a.address }))

  const { output: tokenResponse } = await sdk.api.abi.multiCall({
    block, calls: tokenCalls, abi: bVaultAbi.find(i => i.name === 'token')
  })

  const { output: underlyingBalances } = await sdk.api.abi.multiCall({
    block, calls: tokenCalls, abi: bVaultAbi.find(i => i.name === 'underlyingBalance')
  })

  const balances = {}
  tokenResponse.forEach(({ input, output }, i) => {
    sdk.util.sumSingleBalance(balances, output, underlyingBalances[i].output)
  })
  return balances
}

async function pool2(ts, block) {
  const toa = []
  Object.values(uniswapV2Pools).forEach(({ address, owner }) => toa.push([address, owner]))
  return sumTokens({}, toa, block, undefined, undefined, { resolveLP: true })
}

module.exports = {
  ethereum: {
    tvl,
    pool2,
  },
}

'''
'''--- projects/belt/abi.json ---
{
    "calcPoolValueInToken": {
        "inputs": [],
        "name": "calcPoolValueInToken",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/belt/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const retry = require('async-retry')
const axios = require("axios");
const BigNumber = require("bignumber.js");
const { toUSDTBalances } = require('../helper/balances');

// https://docs.belt.fi/contracts/contract-deployed-info
const bscVaults = [
    '0x51bd63F240fB13870550423D208452cA87c44444',
    '0xAA20E8Cb61299df2357561C2AC2e1172bC68bc25',
    '0xa8Bb71facdd46445644C277F9499Dd22f6F0A30C',
    '0x9171Bf7c050aC8B4cf7835e51F7b4841DFB2cCD0',
    '0x55E1B1e49B969C018F2722445Cd2dD9818dDCC25',
    '0x7a59bf07D529A5FdBab67D597d63d7D5a83E61E5',
    '0x9A86fc508a423AE8a243445dBA7eD5364118AB1D'
]

const hecoVaults = [
    '0x4Cd59EEB3a4D2fa5c35FD3dE0BA1723EeaF1D258',
    '0xB1493B7bc8e260B0b25235ae5c34B0dC201ce8C3',
    '0x86f5C8EB736c95dd687182779edd792FEF0fA674',
    '0xA8714b9c86Fb590bF2CEE12bdFccC575aB454272',
    '0xC04a84d0E3f290D0777c233E0945678469adF353',
    '0x9bC7a8ec3a8b9d9AEc0C5808456e35A934f457e5',
    '0x0e564BC863c2072C47FB8f952062BD5bc673E142'
]

// const klaytnVaults = [
//     '0xe510d40a4B92302798d6baA1eF004E4629438e81',
//     '0x426533F501c3615A4244087d2A9981b037C40D46',
//     '0x826c88315bb441e6886a63f80164E67F89359C5A',
//     '0xe7fa18E435FE9aCBdFb5016514B00C61C9a27507',
//     '0x39Ff319dd1282452cd73154B6ac670449234230F',
//     '0x430a6768Ef348B06F65F1FEEf01B9b2B58C75f79',
//     '0xf70644e5650e2ef5f0D31dF46e7e369771c2707F'
// ]

const tetherLP = "0x04100231d548Df31a003BEb99e81e3305Be9647b"
// const BELT = "0xE0e514c71282b6f4e823703a39374Cf58dc3eA4f"

async function getTvl(chain, block, address) {
    const underlyingTokens = await sdk.api.abi.multiCall({
        chain: chain,
        calls: address.map(v=>({target:v})),
        block,
        abi: abi.token
    })
    const underlyingBalances = await sdk.api.abi.multiCall({
        chain: chain,
        calls: address.map(v=>({target:v})),
        block,
        abi: abi.calcPoolValueInToken
    })
    const balances = {}
    underlyingBalances.output.forEach((balance, index)=>{
        sdk.util.sumSingleBalance(balances, chain+':'+underlyingTokens.output[index].output, balance.output)
    })

    const beltInfo = await retry(async bail => await axios.get('https://s.belt.fi/info/all.json'))
    const lockedUSDT = beltInfo.data.info[chain.toUpperCase()].vaultPools.find(x => x.wantToken.toLowerCase() === tetherLP.toLowerCase())
    const [ usdt, wantLocked ] = Object.entries(toUSDTBalances(lockedUSDT.wantLocked))[0]
    balances[usdt] = wantLocked

    return balances
}

function bscTvl(timestamp, ethBlock, chainBlocks) {
    return getTvl('bsc', chainBlocks['bsc'], bscVaults)
}

function hecoTvl(timestamp, ethBlock, chainBlocks) {
    return getTvl('heco', chainBlocks['heco'], hecoVaults)
}

async function klaytnTvl() {
    const beltInfo = await retry(async bail => await axios.get('https://s.belt.fi/info/all.json'))
    var tvl = new BigNumber('0');

    beltInfo.data.info.KLAYTN.vaults.forEach(vault =>{
        tvl = tvl.plus(vault.tvl)
    })

    const lockedUSDT = beltInfo.data.info.KLAYTN.vaultPools.find(x => x.wantToken.toLowerCase() === tetherLP.toLowerCase())
    tvl = tvl.plus(lockedUSDT.wantLocked)

    return toUSDTBalances(tvl.toFixed(2))
}

async function getStaking(chain) {
    const beltInfo = await retry(async bail => await axios.get('https://s.belt.fi/info/all.json'))
    const stakingInfo = beltInfo.data.info[chain.toUpperCase()].staking

    return toUSDTBalances(stakingInfo.tvl)
}

module.exports = {
    timetravel: false,
    methodology: 'TVL includes the liquidity of all the Vaults, 3Tether LP and staking counts the BELT that has been staked in BSC. Data is pulled from:"https://s.belt.fi/info/all.json".',
    bsc: {
        tvl: bscTvl,
        staking: () => getStaking('bsc'),
    },
    heco: {
        tvl: hecoTvl,
    },
    klaytn: {
        tvl: klaytnTvl,
    },
}

'''
'''--- projects/beluga/index.js ---
const { get } = require('../helper/http')
let _data

function fetch(chain) {
  return async () => {
    if (!_data) _data = get('https://api.beluga.fi/tvl')
    let data = await _data
    return {
      'usd-coin': data[chain]
    }
  }
}

module.exports = {
  timetravel: false,
  polygon: {
    tvl: fetch('Polygon')
  },
  fantom: {
    tvl: fetch('Fantom')
  },
}

'''
'''--- projects/bencu/index.js ---
const {usdCompoundExports} = require("../helper/compound")

module.exports={
    misrepresentedTokens: true,
    metis:usdCompoundExports("0xC5986Df018D1ff8ecA79fd3f266428616617cDF3", "metis", undefined, undefined, {
        blacklist: ['0x718F2e019F8166d81523d959F720Ad4A6e379209'.toLowerCase()]
    })
}
'''
'''--- projects/benddao/helper/abis/UiPoolDataProvider.json ---
[{
  "inputs": [
    {
      "internalType": "contract ILendPoolAddressesProvider",
      "name": "provider",
      "type": "address"
    }
  ],
  "name": "getSimpleReservesData",
  "outputs": [
    {
      "components": [
        {
          "internalType": "address",
          "name": "underlyingAsset",
          "type": "address"
        },
        { "internalType": "string", "name": "name", "type": "string" },
        { "internalType": "string", "name": "symbol", "type": "string" },
        { "internalType": "uint256", "name": "decimals", "type": "uint256" },
        {
          "internalType": "uint256",
          "name": "reserveFactor",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "borrowingEnabled",
          "type": "bool"
        },
        { "internalType": "bool", "name": "isActive", "type": "bool" },
        { "internalType": "bool", "name": "isFrozen", "type": "bool" },
        {
          "internalType": "uint128",
          "name": "liquidityIndex",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "variableBorrowIndex",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "liquidityRate",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "variableBorrowRate",
          "type": "uint128"
        },
        {
          "internalType": "uint40",
          "name": "lastUpdateTimestamp",
          "type": "uint40"
        },
        {
          "internalType": "address",
          "name": "bTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "debtTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "interestRateAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "availableLiquidity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalVariableDebt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "priceInEth",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "variableRateSlope1",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "variableRateSlope2",
          "type": "uint256"
        }
      ],
      "internalType": "struct IUiPoolDataProvider.AggregatedReserveData[]",
      "name": "",
      "type": "tuple[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
},
{
  "inputs": [
    {
      "internalType": "contract ILendPoolAddressesProvider",
      "name": "provider",
      "type": "address"
    }
  ],
  "name": "getSimpleNftsData",
  "outputs": [
    {
      "components": [
        {
          "internalType": "address",
          "name": "underlyingAsset",
          "type": "address"
        },
        { "internalType": "string", "name": "name", "type": "string" },
        { "internalType": "string", "name": "symbol", "type": "string" },
        { "internalType": "uint256", "name": "ltv", "type": "uint256" },
        {
          "internalType": "uint256",
          "name": "liquidationThreshold",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "liquidationBonus",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "redeemDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "auctionDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "redeemFine",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "redeemThreshold",
          "type": "uint256"
        },
        { "internalType": "bool", "name": "isActive", "type": "bool" },
        { "internalType": "bool", "name": "isFrozen", "type": "bool" },
        {
          "internalType": "address",
          "name": "bNftAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "priceInEth",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalCollateral",
          "type": "uint256"
        }
      ],
      "internalType": "struct IUiPoolDataProvider.AggregatedNftData[]",
      "name": "",
      "type": "tuple[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}]
'''
'''--- projects/benddao/helper/abis/index.js ---
const UiPoolDataProvider = require("./UiPoolDataProvider.json");

module.exports = {
  UiPoolDataProvider,
};

'''
'''--- projects/benddao/helper/address.js ---
const UiPoolDataProvider = {
  ethereum: "0x5250cCE48E43AB930e45Cc8E71C87Ca4B51244cf",
};

const LendPoolAddressProvider = {
  ethereum: "0x24451F47CaF13B24f4b5034e1dF6c0E401ec0e46",
};

module.exports = {
  UiPoolDataProvider,
  LendPoolAddressProvider,
};

'''
'''--- projects/benddao/helper/index.js ---
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");

const abi = require("./abis");
const address = require("./address");

async function getTVL(balances, chain, timestamp, chainBlocks) {
  const block = chainBlocks[chain];

  const [{ output: simpleReservesData }, { output: simpleNftsData }] =
    await Promise.all([
      sdk.api.abi.call({
        target: address.UiPoolDataProvider[chain],
        params: [address.LendPoolAddressProvider[chain]],
        abi: abi.UiPoolDataProvider.find(
          (a) => a.name === "getSimpleReservesData"
        ),
        block,
        chain,
      }),
      sdk.api.abi.call({
        target: address.UiPoolDataProvider[chain],
        params: [address.LendPoolAddressProvider[chain]],
        abi: abi.UiPoolDataProvider.find((a) => a.name === "getSimpleNftsData"),
        block,
        chain,
      }),
    ]);

  simpleReservesData.forEach((d) => {
    balances[d.underlyingAsset] = new BigNumber(
      balances[d.underlyingAsset] || 0
    ).plus(d.availableLiquidity);
  });

  simpleNftsData.forEach((d) => {
    balances["ETHEREUM"] = new BigNumber(balances["ETHEREUM"] || 0).plus(
      new BigNumber(d.totalCollateral).multipliedBy(d.priceInEth).shiftedBy(-18)
    );
  });

  return balances;
}

async function getBorrowed(balances, chain, timestamp, chainBlocks) {
  const block = chainBlocks[chain];

  const [{ output: simpleReservesData }] = await Promise.all([
    sdk.api.abi.call({
      target: address.UiPoolDataProvider[chain],
      params: [address.LendPoolAddressProvider[chain]],
      abi: abi.UiPoolDataProvider.find(
        (a) => a.name === "getSimpleReservesData"
      ),
      block,
      chain,
    }),
  ]);

  simpleReservesData.forEach((d) => {
    balances[d.underlyingAsset] = new BigNumber(
      balances[d.underlyingAsset] || 0
    ).plus(d.totalVariableDebt);
  });

  return balances;
}

module.exports = {
  getTVL,
  getBorrowed,
};

'''
'''--- projects/benddao/index.js ---
const sdk = require("@defillama/sdk");

const { getTVL, getBorrowed } = require("./helper/index");

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};

  await getTVL(balances, "ethereum", timestamp, chainBlocks);

  return balances;
}

async function borrowed(timestamp, block, chainBlocks) {
  const balances = {};

  await getBorrowed(balances, "ethereum", timestamp, chainBlocks);

  return balances;
}

module.exports = {
  timetravel: true,
  methodology: `Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL`,
  ethereum: {
    tvl,
    borrowed,
  },
};

'''
'''--- projects/benqi-staked-avax/index.js ---
const sdk = require("@defillama/sdk");
const savaxAbi = require("./savax.json");

const SAVAX = "0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE";
const WAVAX = "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7";

const transformAddress = (addr) => `avax:${addr}`;

async function tvl(timestamp, block, chainBlocks) {
    const pooledAvax = await sdk.api.abi.call({
        target: SAVAX,
        abi: savaxAbi.totalPooledAvax,
        chain: "avax",
        block: chainBlocks.avax,
    });
    
    return {
        [transformAddress(WAVAX)]: pooledAvax.output
    };
}

module.exports={
    avalanche: {
        tvl,
    },
    methodology: "Counts staked AVAX tokens.",
}

'''
'''--- projects/benqi-staked-avax/savax.json ---
{
  "totalPooledAvax": {
    "inputs": [],
    "name": "totalPooledAvax",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getSharesByPooledAvax": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "avaxAmount",
        "type": "uint256"
      }
    ],
    "name": "getSharesByPooledAvax",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/benqi/index.js ---
const {compoundExports} = require('../helper/compound')
const {pool2} = require('../helper/pool2')

module.exports={
    timetravel: true,
    doublecounted: false,
    methodology: "Same as compound, we just get all the collateral (not borrowed money) on the lending markets",
    avalanche:{
        ...compoundExports("0x486af39519b4dc9a7fccd318217352830e8ad9b4", "avax"),
        pool2: pool2("0x784da19e61cf348a8c54547531795ecfee2affd1", "0xe530dc2095ef5653205cf5ea79f8979a7028065c", "avax")
    }
}

'''
'''--- projects/benswap/index.js ---
const sdk = require('@defillama/sdk');
const { getBlock } = require('../helper/getBlock');
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')

const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04";
const EBEN = "0x77CB87b57F54667978Eb1B199b28a0db8C8E1c0B";
const FLEXUSD = "0x7b2B3C5308ab5b2a1d9a94d20D35CCDf61e05b72";
const FACTORY = "0x8d973bAD782c1FFfd8FcC9d7579542BA7Dd0998D";
const MASTERBREEDER = "0xDEa721EFe7cBC0fCAb7C8d65c598b21B6373A2b6";
const EBEN_WBCH_LP = "0x0D4372aCc0503Fbcc7EB129e0De3283c348B82c3";
const COREASSETNAME = "bitcoin-cash";
const CHAIN = "smartbch";

async function bchMasterChef(timestamp, ethBlock, chainBlocks) {
    const block = await getBlock(timestamp, CHAIN, chainBlocks, true);

    const stakedBCH = (await sdk.api.erc20.balanceOf({
        target: WBCH,
        owner: MASTERBREEDER,
        chain: CHAIN,
        block: block,
        decimals: 18
    })).output;

    return {
        [COREASSETNAME]: Number(stakedBCH)
    }
}

const bchDexTvl = calculateUsdUniTvl(FACTORY, CHAIN, WBCH, [EBEN, FLEXUSD], COREASSETNAME)

module.exports = {
    misrepresentedTokens: true,
    methodology: "Factory address (0x8d973bAD782c1FFfd8FcC9d7579542BA7Dd0998D) is used to find the LP pairs on smartBCH and Factory address (0x4dC6048552e2DC6Eb1f82A783E859157d40FA193) is used to find the liquidity of the pairs on BSC. TVL is equal to the liquidity on both AMMs plus the extra staking balance and masterchef pools.",
    smartbch: {
        tvl: sdk.util.sumChainTvls([bchDexTvl, bchMasterChef]),
        masterchef: bchMasterChef,
        staking: stakingPricedLP(MASTERBREEDER, EBEN, "smartbch", EBEN_WBCH_LP, COREASSETNAME),
    },
    bsc: {
        tvl: calculateUsdUniTvl("0x4dC6048552e2DC6Eb1f82A783E859157d40FA193", "bsc", "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", ["0x8173dDa13Fd405e5BcA84Bd7F64e58cAF4810A32"], "binancecoin"),
        staking: stakingPricedLP("0x03245d87295cd0783e1f10a2ea54f9e80b726af8", "0x8173dda13fd405e5bca84bd7f64e58caf4810a32", "bsc", "0x4558e53328cddd5877b7348702c991f521aa35c0", "binancecoin", true),
    },
}

'''
'''--- projects/bent/bentBasePoolAbi.json ---
{
  "cvxPoolId": {
    "inputs": [],
    "name": "cvxPoolId",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [],
    "name": "lpToken",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/bent/constants.js ---
const addressZero = "0x0000000000000000000000000000000000000000";
const ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
const wethAddress = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const bentCVXAddress = "0x9E0441E084F5dB0606565737158aa6Ab6B970fE0";
const CVXAddress = "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B";
const pool2Address = "0xd564b2feec19df8f4d6cb52c0a4386d05a993583";
const sushiLpAddress = "0x5fa4370164a2fabeef159b893299d59ff5dc1e6d";
const bentAddress = "0x01597e397605bf280674bf292623460b4204c375";
const daiAddress = "0x6b175474e89094c44da98b954eedeac495271d0f";
const weBent = "0x04637d61F538911929ff96E755B589C014fD9ce2";

const bentPools = {
  BentPoolBentCvxCvx: "0xf083FBa98dED0f9C970e5a418500bad08D8b9732",
  BentPoolTriCrypto2: "0xb5a69B26920E1A430b1405Bc75a455d687328D67",
  BentPoolMIM: "0x397DD120bF0e6d0f2Af2e12f29d57Fb1A58c041c",
  BentPoolFrax: "0xD714e4cB809759ECf37067cfF56feCA887E3C168",
  BentPoolAlusd: "0x16b385cc9959BbE83905eA5E71820b406804d037",
  BentPoolSTETH: "0x9a50F371B262d8eE84879EEE70B8d41CBC904dd0",
  BentPoolMIMUST: "0x5D551CE7564b6D9B95559a70A5648af908a8AD09",
  BentPoolOUSD: "0x519590c576D4e0aA49B7614492B64ADB8669F52A",
  BentPoolCVXETH: "0xADe08F43C0bA6eAF8F7a100A8f773285b39caBb5",
  BentPoolCVXCRV: "0xf5306c00648c8aA07b8e451E2B4176FbA971A7dA",
  BentPoolD3Pool: "0xA9E82F48e1cE96e3cE80e6b7E495831823a98AE9",
  BentPoolUSTWormHole: "0x7c325F13395334a376D7D388FD3450d38488a1AF",
  BentPoolDola: "0xD6B8580a39A17b9fBea427fD50593970f4Ac31b6",
  BentPoolCrvEth: "0x5D77b731803916cbcdec2BBdb3Ad0649C6a6EA17",
  BentPool3Pool: "0x9a9606a399c62d20d7ba11028ed1218ed3f8f244",
};

const bentCVXSingleStaking = "0xe55C5069ED7F8fE2EA656aFf4551af52F8dbdeF7";

const crvRegistry = "0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5";

const bentMasterChefAddress = "0xfeAEA5e904D6e8B88888Ea1101c59F4084a94557";
const bentMasterChefPools = ["0xf083FBa98dED0f9C970e5a418500bad08D8b9732"];

const crvPoolByLpTokenAddress = {
  "0x3a283d9c08e8b55966afb64c515f5143cf907611":
    "0xb576491f1e6e5e62f1d8f26062ee822b40b0e0d4", // cvx-eth
  "0xed4064f376cb8d68f770fb1ff088a3d0f3ff5c4d":
    "0x8301ae4fc9c624d1d396cbdaa1ed877821d7c511", // crv-eth
  "0xc4ad29ba4b3c580e6d59105fff484999997675ff":
    "0xd51a44d3fae010294c616388b506acda1bfaae46", // tricrpyto2
  "0xfeaea5e904d6e8b88888ea1101c59f4084a94557":
    "0xf083fba98ded0f9c970e5a418500bad08d8b9732", // bentcvx-cvx
};

module.exports = {
  bentPools,
  crvPoolByLpTokenAddress,
  crvRegistry,
  addressZero,
  ethAddress,
  wethAddress,
  bentMasterChefAddress,
  bentMasterChefPools,
  bentCVXAddress,
  CVXAddress,
  bentCVXSingleStaking,
  weBent,
  pool2Address,
  sushiLpAddress,
  bentAddress,
  daiAddress,
};

'''
'''--- projects/bent/curvePoolAbi.json ---
{
  "coins": {
    "constant": true,
    "name": "coins",
    "outputs": [
      {
        "type": "address",
        "name": ""
      }
    ],
    "inputs": [
      {
        "type": "uint256",
        "name": "arg0"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "gas": 2280
  },
  "get_dy": {
    "stateMutability": "view",
    "type": "function",
    "name": "get_dy",
    "inputs": [
      { "name": "i", "type": "int128" },
      { "name": "j", "type": "int128" },
      { "name": "dx", "type": "uint256" }
    ],
    "outputs": [{ "name": "", "type": "uint256" }],
    "gas": 2110507
  }
}

'''
'''--- projects/bent/curveRegistryAbi.json ---
{
  "get_pool_from_lp_token": {
    "stateMutability": "view",
    "type": "function",
    "name": "get_pool_from_lp_token",
    "inputs": [{ "name": "arg0", "type": "address" }],
    "outputs": [{ "name": "", "type": "address" }],
    "gas": 2443
  },
  "get_coins": {
    "stateMutability": "view",
    "type": "function",
    "name": "get_coins",
    "inputs": [{ "name": "_pool", "type": "address" }],
    "outputs": [{ "name": "", "type": "address[8]" }],
    "gas": 12102
  }
}

'''
'''--- projects/bent/index.js ---
const sdk = require("@defillama/sdk");

const basePoolAbi = require("./bentBasePoolAbi.json");
const curveRegistryAbi = require("./curveRegistryAbi.json");
const curvePoolAbi = require("./curvePoolAbi.json");
const BigNumber = require("bignumber.js");
const {
  bentPools,
  crvPoolByLpTokenAddress,
  crvRegistry,
  addressZero,
  ethAddress,
  wethAddress,
  bentMasterChefAddress,
  bentMasterChefPools,
  bentCVXAddress,
  CVXAddress,
  weBent,
  bentCVXSingleStaking,
  pool2Address,
  sushiLpAddress,
  bentAddress,
  daiAddress,
} = require("./constants");

async function tvl(timestamp, block) {
  const poolAddresses = Object.values(bentPools);
  const poolBalances = [];

  const bentCVXpriceInCVX = new BigNumber(
    (
      await sdk.api.abi.call({
        target: bentMasterChefPools[0],
        abi: curvePoolAbi.get_dy,
        params: [1, 0, new BigNumber(1).times(10 ** 18).toString()],
        block,
      })
    ).output
  ).dividedBy(10 ** 18);

  // Fetch balances of each of the pools
  for (let poolIndex = 0; poolIndex < poolAddresses.length; poolIndex++) {
    const poolAddress = poolAddresses[poolIndex];
    const masterChefPoolIndex = bentMasterChefPools.indexOf(poolAddress);
    const isMasterChefPool = masterChefPoolIndex !== -1;
    let poolSupply, poolLpToken;

    if (!isMasterChefPool) {
      const results = (
        await Promise.all([
          sdk.api.erc20.totalSupply({
            target: poolAddress,
            block,
          }),
          sdk.api.abi.call({
            target: poolAddress,
            abi: basePoolAbi.lpToken,
            block,
          }),
        ])
      ).map((p) => p.output.toLowerCase());
      poolSupply = results[0];
      poolLpToken = results[1];
    } else {
      poolLpToken = poolAddress;
      poolSupply = (
        await sdk.api.erc20.balanceOf({
          target: poolLpToken,
          owner: bentMasterChefAddress,
          block,
        })
      ).output;
    }

    const lpTokenTotalSupply = (
      await sdk.api.erc20.totalSupply({
        target: poolLpToken,
        block,
      })
    ).output;

    // Find the curve pool
    let crvPoolAddr = (
      await sdk.api.abi.call({
        target: crvRegistry,
        abi: curveRegistryAbi.get_pool_from_lp_token,
        params: poolLpToken,
        block,
      })
    ).output;

    // Find the balance of the underlying coins in the curve pool
    let coins = [];
    if (crvPoolAddr !== addressZero) {
      coins = (
        await sdk.api.abi.call({
          target: crvRegistry,
          abi: curveRegistryAbi.get_coins,
          params: crvPoolAddr,
          block,
        })
      ).output.filter((a) => a !== addressZero);
    } else {
      // Either use a manual mapping, or the pool is the lp token itself.
      crvPoolAddr = crvPoolByLpTokenAddress[poolLpToken] || poolLpToken;
      for (let i = 0, err = false; i < 8 && !err; i++) {
        try {
          let coin = (
            await sdk.api.abi.call({
              target: crvPoolAddr,
              abi: curvePoolAbi.coins,
              params: i,
            })
          ).output;
          coins.push(coin);
        } catch (e) {
          err = true;
        }
      }
    }

    const includesEth =
      coins.findIndex(
        (addr) =>
          addr.toLowerCase() === ethAddress ||
          addr.toLowerCase() === wethAddress
      ) !== -1;

    /**
     * addr : balance for the curve pool
     */
    let curvePoolBalances = (
      await sdk.api.abi.multiCall({
        calls: coins
          .filter((addr) => addr.toLowerCase() !== ethAddress)
          .map((coinAddr) => ({
            target: coinAddr,
            params: crvPoolAddr,
          })),
        abi: "erc20:balanceOf",
        block,
      })
    ).output.reduce((curvePoolBalances, { success, input, output }) => {
      if (!success) return curvePoolBalances;

      curvePoolBalances[input.target] = output;
      return curvePoolBalances;
    }, {});

    if (includesEth) {
      var ethbal = await sdk.api.eth.getBalance({
        target: crvPoolAddr,
        block,
      });
      curvePoolBalances[addressZero] = ethbal.output;
    }

    // Calculate the share of the pool we have.
    const poolShare = BigNumber(poolSupply).div(lpTokenTotalSupply);
    const ourBalances = {};
    Object.keys(curvePoolBalances).forEach((coinAddr) => {
      let poolBalance = curvePoolBalances[coinAddr];
      ourBalances[coinAddr] = new BigNumber(poolBalance)
        .times(poolShare)
        .toFixed(0);
    });
    poolBalances.push(ourBalances);
  }

  const balances = poolBalances.reduce((overallBalances, poolBalances) => {
    Object.keys(poolBalances).forEach((tokenAddress) => {
      let current = new BigNumber(overallBalances[tokenAddress] || "0");
      let pool = new BigNumber(poolBalances[tokenAddress] || "0");
      if (tokenAddress.toLowerCase() === bentCVXAddress.toLowerCase()) {
        tokenAddress = CVXAddress.toLowerCase();
        pool = pool.times(bentCVXpriceInCVX);
      }
      overallBalances[tokenAddress] = current.plus(pool).toFixed(0);
    });
    return overallBalances;
  }, {});

  // Add single sided bentCVX staking:
  const stakedBentCVX = (
    await sdk.api.erc20.balanceOf({
      target: bentCVXAddress,
      owner: bentCVXSingleStaking,
      block,
    })
  ).output;

  balances[CVXAddress] = new BigNumber(balances[CVXAddress] || 0).plus(
    new BigNumber(stakedBentCVX).times(bentCVXpriceInCVX)
  );

  return balances;
}

async function pool2(timestamp, block) {
  const pool2Balance = (
    await sdk.api.erc20.balanceOf({
      target: sushiLpAddress,
      owner: pool2Address,
      block,
    })
  ).output;

  const lpTotalSupply = (
    await sdk.api.erc20.totalSupply({
      target: sushiLpAddress,
      block,
    })
  ).output;

  const share = new BigNumber(pool2Balance).dividedBy(lpTotalSupply);

  const [daiBalance, bentBalance] = (
    await sdk.api.abi.multiCall({
      calls: [
        { target: daiAddress, params: sushiLpAddress },
        { target: bentAddress, params: sushiLpAddress },
      ],
      abi: "erc20:balanceOf",
      block,
    })
  ).output.map(({ output }) => new BigNumber(output).times(share));

  return {
    [daiAddress]: daiBalance.toFixed(0),
    [bentAddress]: bentBalance.toFixed(0),
  };
}

async function staking(timestamp, block) {
  const stakingBalance = (
    await sdk.api.erc20.balanceOf({
      target: bentAddress,
      owner: weBent,
      block,
    })
  ).output;

  return {
    [bentAddress]: stakingBalance,
  };
}

module.exports = {
  methodology: `TVL:BENT allows users to stake their curve LP tokens. For each supported curve pool LP token: Find the total supply of the LP token, Find the balance of LP staked in bent, Find the curve pool whose liquidity it represents, Enumerate the addresses of each token that makes up the pool, Get the balance of each token from 4, Use 1 & 2 to work out the LP share staked in bent, Multiply the token balances from 5 by the bent share to get the bent balances. Pool2 and staking: Pool2 and staking are fairly standard. Pool2 calculates fraction of LP staked as a share of the sushi LP and multiplies by the sushi LP coin balances. Staking simply takes the balance of the staking contract for BENT.`,
  ethereum: {
    tvl,
    pool2,
    staking,
  },
};

'''
'''--- projects/bepswap.js ---
module.exports = {
  fetch: () => 0
}
'''
'''--- projects/betafinance/index.js ---
const sdk = require("@defillama/sdk");
const { get } = require("../helper/http");
const { sumTokens } = require("../helper/unwrapLPs");

const config = {
  ethereum: {
    bank: '0x972a785b390D05123497169a04c72dE652493BE1',
    collaterals: [
      "0xdac17f958d2ee523a2206206994597c13d831ec7",
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      "0x6b175474e89094c44da98b954eedeac495271d0f",
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    ],
    poolURL: 'https://beta-reward-xvn33y7hlq-uc.a.run.app/beta_active_eth/reward_infos'
  },
  avax: {
    bank: '0xf3a82ddd4fbf49a35eccf264997f82d40510f36b',
    collaterals: [
      "0xc7198437980c041c805a1edcba50c1ce5db95118",
      "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
      "0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
      "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
      "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
    ],
    poolURL: 'https://beta-reward-xvn33y7hlq-uc.a.run.app/beta_active_avax/reward_infos'
  }
}

const underlyingABI = {
  "inputs": [],
  "name": "underlying",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

async function getPools(chain) {
  const url = config[chain].poolURL
  return (await get(url)).pool_infos
    .filter(i => i.kind === 'BetaLendHandler')
    .map(i => i.address)
}

function setChainTVL(chain) {
  module.exports[chain] = {
    tvl: async (ts, _block, chainBlocks) => {
      const block = chainBlocks[chain]
      const pools = await getPools(chain)
      const { bank, collaterals } = config[chain]
      const calls = pools.map(i => ({ target: i }))
      const underlyings = await sdk.api.abi.multiCall({ abi: underlyingABI, calls, block, chain })
      const toa = underlyings.output.map(({ output, input: { target }}) => [output, target])
      collaterals.forEach(token => toa.push([token, bank]))
      return sumTokens({}, toa, block, chain)
    }
  }
}

module.exports = {
  methodology:
    "TVL is comprised of tokens deposited to the protocol as collateral, similar to Compound Finance and other lending protocols the borrowed tokens are not counted as TVL.",
};

Object.keys(config).forEach(setChainTVL)
'''
'''--- projects/bethash/index.js ---
const { get_account_tvl } = require("../helper/eos");

const accounts = [
  "eoshashhouse",
  "eoshashstake"
]

const tokens = [
    ["eosio.token", "EOS", "eos"]
];

// BetHash
// https://bethash.io/
async function eos() {
  return await get_account_tvl(accounts, tokens);
}

module.exports = {
  methodology: `BetHash TVL is achieved by querying token balances from BetHash's smart contracts.`,
  eos: {
    tvl: eos
  },
}
'''
'''--- projects/betswirl/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens2 } = require('../helper/unwrapLPs')

const banks = {
  bsc: [
    [18371153, "0xC7130b9D454243BE816B7f5Ab09E7eF292b0c465"],
    [Infinity, "0xF26E41e3714eFe1ff03b423f45DCc31a98C21867"],
  ],
  polygon: [
    [29120547, "0x72A5b0295EAaCC8c005Ec6a800cB9BECEd73DA0E"],
    [Infinity, "0x1a54574CBAe9f8a4f9dd19d56687F2266d0C9d31"],
  ],
  avax: [[Infinity, "0x187De399100aA962F209Aa78621F5138ACA6111f"]],
};

function treasury(chain) {
  return async (_timestamp, _block, chainBlocks) => {
    const block = chainBlocks[chain];

    // Get the Bank for the input block
    const [, bankAddressOfBlock] = banks[chain].find(
      ([bankLastBlock]) => block < bankLastBlock
    );

    // Retrieves all tokens from the Bank contract
    const { output: tokens } = await sdk.api.abi.call({
      target: bankAddressOfBlock,
      abi: {
        inputs: [],
        name: "getTokens",
        outputs: [
          {
            components: [
              {
                internalType: "uint8",
                name: "decimals",
                type: "uint8",
              },
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address",
              },
              {
                internalType: "string",
                name: "name",
                type: "string",
              },
              {
                internalType: "string",
                name: "symbol",
                type: "string",
              },
              {
                components: [
                  {
                    internalType: "bool",
                    name: "allowed",
                    type: "bool",
                  },
                  {
                    internalType: "uint16",
                    name: "balanceRisk",
                    type: "uint16",
                  },
                  {
                    internalType: "address",
                    name: "partner",
                    type: "address",
                  },
                  {
                    components: [
                      {
                        internalType: "uint16",
                        name: "dividend",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "referral",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "partner",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "treasury",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "team",
                        type: "uint16",
                      },
                      {
                        internalType: "uint256",
                        name: "dividendAmount",
                        type: "uint256",
                      },
                      {
                        internalType: "uint256",
                        name: "partnerAmount",
                        type: "uint256",
                      },
                      {
                        internalType: "uint256",
                        name: "treasuryAmount",
                        type: "uint256",
                      },
                      {
                        internalType: "uint256",
                        name: "teamAmount",
                        type: "uint256",
                      },
                      {
                        internalType: "uint256",
                        name: "referralAmount",
                        type: "uint256",
                      },
                      {
                        internalType: "uint256",
                        name: "minPartnerTransferAmount",
                        type: "uint256",
                      },
                    ],
                    internalType: "struct Bank.HouseEdgeSplit",
                    name: "houseEdgeSplit",
                    type: "tuple",
                  },
                  {
                    internalType: "uint256",
                    name: "balanceReference",
                    type: "uint256",
                  },
                  {
                    components: [
                      {
                        internalType: "uint16",
                        name: "thresholdRate",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "toTreasury",
                        type: "uint16",
                      },
                      {
                        internalType: "uint16",
                        name: "toTeam",
                        type: "uint16",
                      },
                    ],
                    internalType: "struct Bank.BalanceOverflow",
                    name: "balanceOverflow",
                    type: "tuple",
                  },
                ],
                internalType: "struct Bank.Token",
                name: "token",
                type: "tuple",
              },
            ],
            internalType: "struct Bank.TokenMetadata[]",
            name: "",
            type: "tuple[]",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      block,
      chain,
    });

    // Filter BetSwirl's governance token
    const tokensWithoutBETS = tokens.filter((token) => token.symbol !== "BETS").map(i => i.tokenAddress)
    return sumTokens2({ chain, block, owner: bankAddressOfBlock, tokens: tokensWithoutBETS })
  };
}

module.exports = {
  timetravel: true,
  methodology:
    "BetSwirl has no users TVL yet. However, it includes the bankrolls amounts (each tokens amount in the bank allowing players to bet).",
  // The first Bank was deployed on Polygon at tx 0x6b99f617946d2f8c23adcd440cd3309d2da750e52d135853f38a0da11cdc3233
  start: 1648344312, // new Date(Date.UTC(2022, 2, 27, 1, 25, 12)).getTime() / 1e3,
  bsc: {
    treasury: treasury("bsc"),
    tvl: () => ({}),
  },
  polygon: {
    treasury: treasury("polygon"),
  },
  avalanche: {
    treasury: treasury("avax"),
  },
};

'''
'''--- projects/biconomy/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens2 } = require("../helper/unwrapLPs");
const { returnEthBalance } = require("../helper/utils")
const { getChainTransform } = require("../helper/portedTokens");

// taken from https://docs.biconomy.io/products/hyphen-instant-cross-chain-transfers/contract-addresses
const config = {
  ethereum: {
    bridges: [
      '0xebaB24F13de55789eC1F3fFe99A285754e15F7b9',
      '0x2A5c2568b10A0E826BfA892Cf21BA7218310180b',
    ],
    tokens: [
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
      '0x6b175474e89094c44da98b954eedeac495271d0f',
      '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
      '0xdac17f958d2ee523a2206206994597c13d831ec7',
    ]
  },
  polygon: {
    bridges: [
      '0xebaB24F13de55789eC1F3fFe99A285754e15F7b9',
      '0x2A5c2568b10A0E826BfA892Cf21BA7218310180b',
    ],
    tokens: [
      '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
      '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
      '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',
      '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',
    ]
  },
  avax: {
    bridges: [
      '0xebaB24F13de55789eC1F3fFe99A285754e15F7b9',
      '0x2A5c2568b10A0E826BfA892Cf21BA7218310180b',
    ],
    tokens: [
      '0xc7198437980c041c805a1edcba50c1ce5db95118',
      '0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664',
      '0xd586e7f844cea2f87f50152665bcbc2c279d8d70',
      '0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab',
    ]
  },
  bsc: {
    bridges: [
      '0x279ac60785a2fcb85550eb243b9a42a543171cc7',
      '0x94D3E62151B12A12A4976F60EdC18459538FaF08',
    ],
    tokens: [
      '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
      '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d',
      '0x55d398326f99059ff775485246999027b3197955',
    ]
  },
  optimism: {
    bridges: [
      '0xb4778f5aefeb4605ed96e893417271d4a55e32ee',
      '0x856cb5c3cbbe9e2e21293a644aa1f9363cee11e8',
    ],
    tokens: [
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
      '0x7f5c764cbc14f9669b88837ca1490cca17c31607',
    ]
  },
  arbitrum: {
    bridges: [
      '0xb4778f5aefeb4605ed96e893417271d4a55e32ee',
      '0x856cb5c3cbbe9e2e21293a644aa1f9363cee11e8',
    ],
    tokens: [
      '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
      '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8',
    ]
  },
}

module.exports = {
  misrepresentedTokens: false,
  methodology:
    "Biconomy TVL is the USD value of token balances in the Hyphen 2.0 contracts.",
}

Object.keys(config).forEach(chain => module.exports[chain] = {
  tvl: async (time, _, { [chain]: block }) => {
    const { bridges, tokens, } = config[chain]
    return sumTokens2({ chain, block, owners: bridges, tokens, });
  }
})
'''
'''--- projects/bifi/abi/oracle.json ---
[
    {
       "inputs":[
          {
             "internalType":"uint256",
             "name":"tokenID",
             "type":"uint256"
          }
       ],
       "name":"getTokenPrice",
       "outputs":[
          {
             "internalType":"uint256",
             "name":"",
             "type":"uint256"
          }
       ],
       "stateMutability":"view",
       "type":"function"
    }
]
'''
'''--- projects/bifi/index.js ---
const sdk = require("@defillama/sdk");
const { stakings } = require("../helper/staking");
const OracleAbi = require('./abi/oracle.json');
const { toUSDTBalances } = require("../helper/balances");

const stakingPool = ['0x488933457E89656D7eF7E69C10F2f80C7acA19b5', '0x4b1791422dE4807B2999Eeb65359F3E13fa9d11d'];
const bfcAddr = '0x0c7D5ae016f806603CB1782bEa29AC69471CAb9c';

const ethPool = '0x13000c4a215efe7e414bb329b2f11c39bcf92d78';
const ethTokenPools = {
    'usdt': {
        'pool': '0x808c3ba97268dbf9695b1ec10729e09c7e67a9e3',
        'token': '0xdac17f958d2ee523a2206206994597c13d831ec7'
    },
    'dai': {
        'pool': '0xd76b7060f1b646fa14740ff6ac670a4f0a6fc5e3',
        'token': '0x6b175474e89094c44da98b954eedeac495271d0f'
    },
    'link': {
        'pool': '0x25567603eb61a4a49f27e433652b5b8940d10682',
        'token': '0x514910771af9ca656af840dff83e8264ecf986ca'
    },
    'usdc': {
        'pool': '0x128647690C7733593aA3Dd149EeBC5e256E79217',
        'token': '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
    },
    'wbtc': {
        'pool': '0x93948Aa8488F522d5b079AF84fe411FBCE476e9f',
        'token': '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599'
    }
}

const bscPool = '0x170b6AA872166eC2F8515c2B855C34B6C7563c18'
const bscTokenPools = {
    'usdt': {
        'pool': '0x2A29598cbc17BA112C8Fd0E07Fbf5402eF57E6b8',
        'token': '0x55d398326f99059ff775485246999027b3197955'
    },
    'dai': {
        'pool': '0xB67C5433d234d656002f12664d15ab4b40666D9B',
        'token': '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3'
    },
    'eth': {
        'pool': '0xf86d8218BCC15874f5D25c191FdDd43F2334c3EB',
        'token': '0x2170ed0880ac9a755fd29b2688956bd959f933f8'
    },
    'usdc': {
        'pool': '0xBA9De5a8FD91408826616f2d6d7470A11E34c9F0',
        'token': '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d'
    },
    'btcb': {
        'pool': '0x26d0E4707af1c1DAAd8e9BA21b99cDa7Fd24c40B',
        'token': '0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c'
    },
    'busd': {
        'pool': '0x829ED2a2BeF8b72e648f92CBF01587C7E12e8c1e',
        'token': '0xe9e7cea3dedca5984780bafc599bd69add087d56'
    }
}

const avaxPool = '0x446881360d6d39779D292662fca9BC85C5789dB3'
const avaxTokenPools = {
    'eth': {
        'pool': '0x8AbA88E8A4AB28319b782199cB17f0001EE67984',
        'token': '0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB'
    },
    'usdt': {
        'pool': '0xE893233515b7D02dD4e3D888162d4C87Dc837943',
        'token': '0xc7198437980c041c805A1EDcbA50c1Ce5db95118'
    },
    'usdc': {
        'pool': '0x8385Ea36dD4BDC84B3F2ac718C332E18C1E42d36',
        'token': '0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664'
    },
    'dai': {
        'pool': '0x34DA42143b0c6E321CEb76931c637c12Bd865f7e',
        'token': '0xd586E7F844cEa2F87f50152665BCbc2C279D8d70'
    },
    'wbtc': {
        'pool': '0xc4D1e935F02A44D44985E6b1C0eE1ee616fC146a',
        'token': '0x50b7545627a5162F82A992c33b87aDc75187B218'
    },
}

const klayOracleContract = '0xCD4F7C7451FFD8628b7F3D5c1b68a3A207ab1125';
const klayPool = '0x829fCFb6A6EeA9d14eb4C14FaC5B29874BdBaD13';
const klaytnTokenPools = {
    'keth': {
        'pool': '0x07970F9D979D8594B394fE12345211C376aDfF89',
        'token': '0x34d21b1e550d73cee41151c77f3c73359527a396'
    },
    'kusdt': {
        'pool': '0xe0e67b991d6b5CF73d8A17A10c3DE74616C1ec11',
        'token': '0xcee8faf64bb97a73bb51e115aa89c17ffa8dd167'
    },
    'kdai': {
        'pool': '0xE03487927e137526a2dB796A9B3b4048ab615043',
        'token': '0x5c74070fdea071359b86082bd9f9b3deaafbe32b'
    },
    'usdc': {
        'pool': '0x808c707c53c3D30d0247e4b8D78AA0D8b75CAAE1',
        'token': '0x754288077d0ff82af7a5317c7cb8c444d421d103'
    },
    'kwbtc': {
        'pool': '0xa6aDE2e6c6F50a2d9b9C4b819e84b367F88C1598',
        'token': '0x16d0e1fbd024c600ca0380a4c5d57ee7a2ecbf9c'
    },
    'kxrp': {
        'pool': '0x4800577A71F68eD7ef4C09cFBe7fd6E066D5F0dA',
        'token': '0x9eaefb09fe4aabfbe6b1ca316a3c36afc83a393f'
    },
}

function getAVAXAddress(address) {
    return `avax:${address}`
}

function getBSCAddress(address) {
    return `bsc:${address}`
}

const coinAddress = '0x0000000000000000000000000000000000000000'

async function eth(timestamp, block) {
    let balances = {};

    const ethBlock = block

    // eth
    balances[coinAddress] = (await sdk.api.eth.getBalance({
        target: ethPool,
        block: ethBlock
    })).output

    // eth tokens
    sdk.util.sumMultiBalanceOf(balances, await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        block: ethBlock,
        calls: Object.values(ethTokenPools).map(tokenPool=>({
            params: tokenPool.pool,
            target: tokenPool.token,
        }))
    }), true)

    return balances
}

const wbtc = "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
async function bitcoin(timestamp, ethBlock) {
    const tokenPool = {
        'pool': '0x986Eb51E67e154901ff9B482835788B8f3054076',
        'token': '0x4ca7a5Fb41660A9c5c31683B832A17f7f7457344'
    }
    let tokenLocked = await sdk.api.erc20.balanceOf({
        owner: tokenPool.pool,
        target: tokenPool.token,
        block: ethBlock
    });
    return {
        [wbtc]: tokenLocked.output
    }
}

const wbnb = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
async function bsc(timestamp, block, chainBlocks) {
    let balances = {};

    const bscBlock = chainBlocks.bsc
    // bsc
    balances[getBSCAddress(wbnb)] = ((await sdk.api.eth.getBalance({
        target: bscPool,
        chain: 'bsc',
        block: bscBlock
    })).output)

    // bsc tokens
    sdk.util.sumMultiBalanceOf(balances, await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        block: bscBlock,
        chain: 'bsc',
        calls: Object.values(bscTokenPools).map(tokenPool=>({
            params: tokenPool.pool,
            target: tokenPool.token,
        }))
    }), true, getBSCAddress)

    return balances
}

const wavax = "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7"
async function avax(timestamp, block, chainBlocks) {
    let balances = {};

    const avaxBlock = chainBlocks.avax
    // avax
    balances[getAVAXAddress(wavax)] = ((await sdk.api.eth.getBalance({
        target: avaxPool,
        chain: 'avax',
        block: avaxBlock
    })).output)

    // avax tokens
    for (const token in avaxTokenPools) {
        const tokenPool = avaxTokenPools[token];
        let tokenLocked = await sdk.api.erc20.balanceOf({
            owner: tokenPool.pool,
            target: tokenPool.token,
            chain: 'avax',
            block: avaxBlock
        });

          sdk.util.sumSingleBalance(balances, getAVAXAddress(tokenPool.token), tokenLocked.output);
    }

    return balances
}

async function klaytn(ts, _block, chainBlocks) {
    const chain = 'klaytn'
    const block = chainBlocks[chain]
    let klaytnTVL = 0;

    const { output: klayPrice} = await sdk.api.abi.call({
        chain, block,
        target: klayOracleContract,
        params: [0],
        abi: OracleAbi.find(i => i.name === 'getTokenPrice')
    })
    const { output: klayBalance } = await sdk.api.eth.getBalance({
        target: klayPool, block, chain
    })

    klaytnTVL += klayPrice * klayBalance / (10 ** 36);

    let oracleID = 0
    for (const token in klaytnTokenPools) {
        oracleID += 1;

        const tokenAddress = klaytnTokenPools[token].token;
        const tokenPoolAddress = klaytnTokenPools[token].pool;

        const { output: tokenPrice} = await sdk.api.abi.call({
            chain, block,
            target: klayOracleContract,
            params: [oracleID],
            abi: OracleAbi.find(i => i.name === 'getTokenPrice')
        })

        const { output: balance} = await sdk.api.abi.call({
            chain, block,
            target: tokenAddress,
            params: [tokenPoolAddress],
            abi: 'erc20:balanceOf'
        })

        const { output: decimals} = await sdk.api.abi.call({
            chain, block,
            target: tokenAddress,
            abi: 'erc20:decimals'
        })

        const div = 18 + parseInt(decimals, 10);

        klaytnTVL += balance * tokenPrice / 10 ** div;
    }

    return toUSDTBalances(klaytnTVL);
}

module.exports = {
    ethereum: {
        tvl: eth,
        staking: stakings(stakingPool, bfcAddr)
    },
    bsc: {
        tvl: bsc
    },
    bitcoin:{
        tvl: bitcoin
    },
    avax: {
        tvl: avax
    },
    klaytn: {
        tvl: klaytn
    }
}

'''
'''--- projects/bifrost/api.js ---
const { ApiPromise, WsProvider } = require("@polkadot/api");
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk")

// node test.js projects/bifrost/api.js
function formatTokenAmount(amount, tokenSymbol) {
  let decimals = 12;

  switch (tokenSymbol) {
    case "DOT":
    case "RMRK":
      decimals = 10;
      break;

    case "BNC":
    case "KSM":
    case "KAR":
    case "KUSD":
      decimals = 12;
      break;
    case "ETH":
    case "ZLK":
    case "MOVR":
      decimals = 18;
      break;
  }

  return Number(amount / Number(10 ** decimals));
}

function formatToken(token) {
  switch (token) {
    case `{"Token":"RMRK"}`:
      return "RMRK";
    case `{"Token":"KSM"}`:
      return "KSM";
    case `{"VSToken":"KSM"}`:
      return "KSM";
    case `{"Token":"KAR"}`:
      return "KAR";
    case `{"Token":"ZLK"}`:
      return "ZLK";
    case `{"Stable":"KUSD"}`:
      return "KUSD";
    default :
      return null;
  }
}

const tokenToCoingecko = {
  DOT: "polkadot",
  BNC: "bifrost",
  KSM: "kusama",
  KAR: "karura",
  MOVR: "moonriver",
  KUSD: "tether",
  ZLK: "zenlink-network-token",
  RMRK: "rmrk",
  ETH: "ethereum"
};

async function tvl() {
  const provider = new WsProvider("wss://bifrost-rpc.liebi.com/ws");
  const api = await ApiPromise.create(({ provider }));

  // Get Salp tvl
  const vsKSM = (await api.query.tokens.totalIssuance({ "vsToken": "KSM" })).toString();
  const vsDOT = (await api.query.tokens.totalIssuance({ "vsToken": "DOT" })).toString();

  const totalLiquidity = {};
  totalLiquidity.KSM = vsKSM;
  totalLiquidity.DOT = vsDOT;

  // Get swap tvl
  const pools = await api.query.zenlinkProtocol.pairStatuses.entries();
  await Promise.all(pools.map(async (pool) => {
    if (pool[1].toHuman()?.Trading?.pairAccount) {
      const poolAccountTokens = await api.query.tokens.accounts.entries(pool[1].toHuman()?.Trading?.pairAccount);
      poolAccountTokens.map(item => {
        const currentToken = formatToken(JSON.stringify(item[0].toHuman()[1]));
        if (currentToken) {
          if (totalLiquidity[currentToken]) {
            totalLiquidity[currentToken] = new BigNumber(totalLiquidity[currentToken]).plus(item[1].toJSON().free).toString();
          } else {
            totalLiquidity[currentToken] = new BigNumber(item[1].toJSON().free).toString();
          }
        }
      });
    }
  }));

  // Get vToken tvl (vKSM / vMOVR )
  const tokenPool = await api.query.vtokenMinting.tokenPool.entries();

  await Promise.all(tokenPool.map(async (pool) => {
    const token=pool[0].toHuman()[0].Token||pool[0].toHuman()[0].Native
    totalLiquidity[token]=new BigNumber(totalLiquidity[token]||0).plus(pool[1].toString()).toString()
  }));

  // Get vETH tvl
  const { output: totalSupply } = await sdk.api.erc20.totalSupply({
    target: '0xc3d088842dcf02c13699f936bb83dfbbc6f721ab'
  })
  totalLiquidity["ETH"] = totalSupply;

  const totalLiquidityFormatted = {};
  for (const key in totalLiquidity) {
    totalLiquidityFormatted[tokenToCoingecko[key]] = formatTokenAmount(
      totalLiquidity[key],
      key
    );
  }

  return totalLiquidityFormatted;
}

module.exports = {
  timetravel: false,
  methodology: "1.Liquidity Pools from Zenlink (only calculate the initiall Pool's liquidity). 2.Minted vTokens from other chains (only calculate the underlying asset value)",
  bifrost: { tvl }
};
'''
'''--- projects/bifrost/index.js ---
const { getExports } = require('../helper/heroku-api')

module.exports = {
	timetravel: false,
	...getExports("bifrost", ['bifrost'])
}
'''
'''--- projects/bigdataprotocol/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "rewardPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/bigdataprotocol/index.js ---
const sdk = require("@defillama/sdk");
const { GraphQLClient, gql } = require('graphql-request');
const retry = require('../helper/retry');
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { addFundsInMasterChef } = require("../helper/masterchef");

const BDPMasterContract = "0x0De845955E2bF089012F682fE9bC81dD5f11B372";
const BDP = "0xf3dcbc6d72a4e1892f7917b7c43b74131df8480e";

const endpoint = 'https://subgraph.mainnet.bigdataprotocolmarket.com:8000/subgraphs/name/oceanprotocol/ocean-subgraph'

const ethTvl = async (chainBlocks) => {
  const balances = {};

  /*** BDP Seed Pools (Data Vault seccion) TVL portion ***/
  await addFundsInMasterChef(
    balances,
    BDPMasterContract,
    chainBlocks["ethereum"],
    "ethereum",
    addr => addr,
    abi.poolInfo,
  );

  /*** BDP Data Set Pools (Data Market seccion) TVL portion ***/
  const graphQLClient = new GraphQLClient(endpoint);

  const query = gql`{
    poolFactories{
      totalValueLocked
    }
  }`;

  const tvlInBDP = (await retry(
    async bail => await graphQLClient.request(query))).poolFactories.map(tvl => tvl.totalValueLocked);

  sdk.util.sumSingleBalance(balances, 'big-data-protocol', +tvlInBDP[0]);

  return balances;
};

module.exports = {
  ethereum: {
    staking: staking(BDPMasterContract, BDP),
    tvl: ethTvl,
  },
  methodology: `Counts liquidity on the Pools of Data Vault and Data Market seccions through BDPMaster Contract
  and using Subgraph API 'https://subgraph.mainnet.bigdataprotocolmarket.com:8000/subgraphs/name/oceanprotocol/ocean-subgraph'
  to pulling data`
}
'''
'''--- projects/billion-happiness/index.js ---
const sdk = require("@defillama/sdk");
const { pool2 } = require("../helper/pool2.js");

const bhcToken = "0x6fd7c98458a943f469E1Cf4eA85B173f5Cd342F4";
const masterchef = "0xC5c482a4Ed34b80B861B4e6Eb28664a46bd3eC8B"; //"Feeling Sweet Masterchef"
const pool2LP = "0x851dB01B337Ee3E5Ab161ad04356816F09EA01dc"; // "Feeling Sweet" BHC-WBNB

const stakingPools = [
  "0xa4712bd37cdE563bDfccCfa6DE5E5c2b1Da5572B", // "Feeling Playful"
  "0xE9bFC901644B85161BAFa103ecf4478a87D398E1", // "Feeling Loyal"
  "0xE40525c866Ab074e4103e5d26570Dc61f1729B6d", // "Feeling Stable"
];

async function staking(timestamp, block, chainBlocks) {
  let balances = {};

  let { output: balance } = await sdk.api.abi.multiCall({
    calls: Array.from({ length: stakingPools.length }, (v, k) => ({
      target: bhcToken,
      params: stakingPools[k],
    })),
    abi: "erc20:balanceOf",
    block: chainBlocks.bsc,
    chain: "bsc",
  });

  for (let i = 0; i < balance.length; i++) {
    sdk.util.sumSingleBalance(balances, `bsc:${bhcToken}`, balance[i].output);
  }

  return balances;
}

module.exports = {
  methodology:
    "Pool 2 TVL includes the BHC-WBNB Pancake LP and staking TVL are the BHC tokens staked into the emotion pools",
  bsc: {
    tvl: async () => ({}),
    staking,
    pool2: pool2(masterchef, pool2LP, "bsc", (addr) => `bsc:${addr}`),
  },
};

'''
'''--- projects/bishares/abi.js ---
module.exports = {
  token: {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  balance: {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
'''
'''--- projects/bishares/config.js ---
// data taken from 
// https://api.thegraph.com/subgraphs/name/toffick/bisharesfunds 
// https://api.thegraph.com/subgraphs/name/bisharesindexfund/bisharesfunds-ybf-fantom
// https://api.thegraph.com/subgraphs/name/toffick/bisharesfunds-fantom

module.exports = {
  toa: {
    fantom: [
      [
        "0x1e4f97b9f9f913c46f1632781732927b9019c68b",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0x29b0da86e484e1c0029b56e817912d778ac0ec69",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0x5cc61a78f164885776aa610fb0fe1257df78e59b",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0x82f0b8b456c1a451378467398982d4834b6829c1",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0xae75a438b2e0cb8bb01ec1e1e376de11d44477cc",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0xd2f38621c3c65300ecaba7020c05d1350f9c265c",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0xd67de0e0a0fd7b15dc8348bb9be742f3c5850454",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0xddcb3ffd12750b45d32e084887fdf1aabab34239",
        "0x259c0cf00f8710b473457314420114ae4c87cee5"
      ],
      [
        "0x0e121961dd741c9d49c9a04379da944a9d2fac7a",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x10b620b2dbac4faa7d7ffd71da486f5d44cd86f9",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x37c045be4641328dfeb625f1dde610d061613497",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x5cc61a78f164885776aa610fb0fe1257df78e59b",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x6b77d8b9be440fcbfe72cb4104d98bbd7cf91b14",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x6c021ae822bea943b2e66552bde1d2696a53fbb7",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x82f0b8b456c1a451378467398982d4834b6829c1",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0xc5e2b037d30a390e62180970b3aa4e91868764cd",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0xd2f38621c3c65300ecaba7020c05d1350f9c265c",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0xf16e81dce15b08f326220742020379b855b87df9",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0xfbfae0dd49882e503982f8eb4b8b1e464eca0b91",
        "0xa55568847c5c5be3b6c59c6e57e74677591d900d"
      ],
      [
        "0x0e121961dd741c9d49c9a04379da944a9d2fac7a",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0x1e4f97b9f9f913c46f1632781732927b9019c68b",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0x29b0da86e484e1c0029b56e817912d778ac0ec69",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0x5cc61a78f164885776aa610fb0fe1257df78e59b",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0x82f0b8b456c1a451378467398982d4834b6829c1",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0xae75a438b2e0cb8bb01ec1e1e376de11d44477cc",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0xc5e2b037d30a390e62180970b3aa4e91868764cd",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0xfbfae0dd49882e503982f8eb4b8b1e464eca0b91",
        "0xab8ac08c597fb090b36eb514ba3f3a8b4a78aed1"
      ],
      [
        "0x1e4f97b9f9f913c46f1632781732927b9019c68b",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0x29b0da86e484e1c0029b56e817912d778ac0ec69",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0x5cc61a78f164885776aa610fb0fe1257df78e59b",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0x82f0b8b456c1a451378467398982d4834b6829c1",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0xae75a438b2e0cb8bb01ec1e1e376de11d44477cc",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0xd2f38621c3c65300ecaba7020c05d1350f9c265c",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0xd67de0e0a0fd7b15dc8348bb9be742f3c5850454",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ],
      [
        "0xddcb3ffd12750b45d32e084887fdf1aabab34239",
        "0xead77cdfeb1fe4672704ba322d63a3d2bdca2025"
      ]
    ],
    bsc: [
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0x1ce0c2827e2ef14d5c4f29a091d735a204794041",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0x3ee2200efb3400fabb9aacf31297cbdd1d435d47",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0xad29abb318791d579433d831ed122afeaf29dcfe",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0xcc42724c6683b7e57334c4e856f4c9965ed682bd",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "0x10a520829c1e9631ef9e60e37eea3916092caa99"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x52ce071bd9b1c4b00a0b92d298c512478cad67e8",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x88f1a5ae2a3bf98aeaf342d26b30a79438c9142e",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x947950bcc74888a40ffa2593c5798f11fc9124c4",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x9ac983826058b8a9c7aa1c9171441191232e8404",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0xfb6115445bff7b52feb98650c87f44907e58f802",
        "0x28939911a862bd4e6b10e281f233a5e060114e0b"
      ],
      [
        "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0x47bead2563dcbf3bf2c9407fea4dc236faba485a",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0x4b0f1812e5df2a09796481ff14017e6005508003",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xa7f552078dcc247c2684336020c03648500c6d9f",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xca3f508b8e4dd382ee878a314789373d80a5190a",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xcf6bb5389c92bdda8a3747ddb454cb7a64626c63",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xd41fdb03ba84762dd66a0af1a6c8540ff1ba5dfb",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0xe02df9e3e622debdd69fb838bb799e3f168902c5",
        "0x2a5f983706b6535ab5d69f003eb271ec44b5e839"
      ],
      [
        "0x154a9f9cbd3449ad22fdae23044319d6ef2a1fab",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x3203c9e46ca618c8c1ce5dc67e7e9d75f5da2377",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x3fcca8648651e5b974dd6d3e50f61567779772a8",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x477bc8d23c634c154061869478bce96be6045d12",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x715d400f88c167884bbcc41c5fea407ed4d2f8a0",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x833f307ac507d47309fd8cdd1f835bef8d702a93",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0xd9025e25bb6cf39f8c926a704039d2dd51088063",
        "0x8f9f6589c2eb04ae4a0a737b78353fdbb628ffe8"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x2198b69b36b86f250549d26d69c5957912a34ec2",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x339c72829ab7dd45c3c52f965e7abe358dd8761e",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x3fcca8648651e5b974dd6d3e50f61567779772a8",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x55671114d774ee99d653d6c12460c780a67f1d18",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x565b72163f17849832a692a3c5928cc502f46d69",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x57effde2759b68d86c544e88f7977e3314144859",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x9d986a3f147212327dd658f712d5264a73a1fdb0",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x9eab0a93b0cd5d904493694f041bdcedb97b88c6",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x9fd87aefe02441b123c3c32466cd9db4c578618f",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0xd40bedb44c081d2935eeba6ef5a3c8a31a1bbe13",
        "0xf09026225aa59d8ab89ec4e06aa1d6dcbe5eb1cf"
      ],
      [
        "0x0491648c910ad2c1afaab733faf71d30313df7fc",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0x0a38bc18022b0ccb043f7b730b354d554c6230f1",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0xa4f93159ce0a4b533b443c74b89967c60a5969f8",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0xba26397cdff25f0d26e815d218ef3c77609ae7f1",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0xd9025e25bb6cf39f8c926a704039d2dd51088063",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "0xf19b6746769132926ee82f47137aeb7a8702c4b9"
      ],
      [
        "0x19a6da6e382b85f827088092a3dbe864d9ccba73",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x1d2f0da169ceb9fc7b3144628db156f3f6c60dbe",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x3ee2200efb3400fabb9aacf31297cbdd1d435d47",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x4338665cbb7b2485a8855a139b75d5e34ab0db94",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x7083609fce4d1d8dc0c979aab8c869ea2c873402",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x85eac5ac2f758618dfa09bdbe0cf174e7d574d5b",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0x947950bcc74888a40ffa2593c5798f11fc9124c4",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0xba2ae424d960c26247dd6c32edc70b295c744c43",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0xbf5140a22578168fd562dccf235e5d43a02ce9b1",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0xcc42724c6683b7e57334c4e856f4c9965ed682bd",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ],
      [
        "0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd",
        "0xfc02d63e44e71d4b8c81a436f19ce580eb7bfada"
      ]
    ]
  },
  vaults: {
    fantom: [
      "0x408bd7e0cdcf28103ea978ea5e5b6307cd48f36d",
      "0x4667c53a1150a94224c0ab4ccd24aeec1d8b764c",
      "0xb69c3fc013c5a1c5b615d2aa90c6d6fc54701d01",
      "0xed94e02b9946de6fc363823bb889522093b0694f",
      "0xf41d1d1cc6edb7512ef8b9f8d0134dc7df9b71f0",
    ]
  }
}

'''
'''--- projects/bishares/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens, unwrapLPsAuto } = require('../helper/unwrapLPs')
const { toa, vaults } = require('./config')
const abi = require('./abi')
const { getChainTransform } = require('../helper/portedTokens')

async function fantom(ts, _, { fantom: block }) {
  const chain = 'fantom'
  const transformAddress = await getChainTransform(chain)
  const calls = vaults.fantom.map(i => ({ target: i }))
  const balances = {}
  const { output: token } = await sdk.api.abi.multiCall({
    abi: abi.token,
    calls,
    chain, block,
  })
  const { output: balance } = await sdk.api.abi.multiCall({
    abi: abi.balance,
    calls,
    chain, block,
  })
  token.forEach(({ output }, idx) => sdk.util.sumSingleBalance(balances, transformAddress(output), balance[idx].output))
  await unwrapLPsAuto({ balances, block, chain, transformAddress })
  return sumTokens(balances, toa.fantom, block, 'fantom')
}

async function bsc(ts, _, { bsc: block }) {
  return sumTokens({}, toa.bsc, block, 'bsc')
}

module.exports = {
  fantom: {
    tvl: fantom
  },
  bsc: {
    tvl: bsc
  },
};

'''
'''--- projects/biswap/index.js ---
const {getChainTvl} = require("../helper/getUniSubgraphTvl");
const {uniTvlExport} = require("../helper/calculateUniTvl");
const {sumTokens} = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");

const factory = "0x858e3312ed3a876947ea49d572a7c42de08af7ee";

const subgraphTvl = getChainTvl({
  "bsc": "https://api.thegraph.com/subgraphs/name/biswapcom/exchange5"
}, "pancakeFactories")('bsc')

const BSW = "0x965f527d9159dce6288a2219db51fc6eef120dd1"

const stakingPools = [
  // Staking pool
  "0xDbc1A13490deeF9c3C12b44FE77b503c1B061739",

  // Other pools + inactive
  "0x13e9031133E901d5214fb4D593DF8ECc034c8237",
  "0xD4855892a3188DA76da0066b9e4918939511E67a",
  "0x9b9F3F1112E74765518cE93B1489c70F6db52bFf",
  "0x683963df7331c65Df8ACE6818651a7611bdc39E5",
  "0xBD09D5E5dcC904bbf8649af78d323eEfdf7b0D1D",
  "0x8b10E6959F2915f532fE142b9C53B167eEC42fF4",
  "0x7D621C9F70B3743CbAb15c22d781754FcD7c9589",
  "0x1F337dea1679730906F46A06fd6034054BD32970",
  "0x131010022654B57b0C39c918ef8313ce79Fa04B8",
  "0x6653c3c4CD2083fEbFf49A52F9a5ce4c30978A25",
  "0x44EeCE1e9ccbaa5Ad0b8C14192467Ab83BE0BA51",
  "0xA394dD5ADC4AAF41aa1f9CFf28158A6AF2823459",
  "0x6cBbA2f3BD677Da630aEd2311253713e8Ba1394D",
  "0xa3A911033af250f7013597A6AF6a719906Ac4444",
  "0xE42D17b1a734e04d2e0cB33234Ab074E21c175A7",
  "0xAa2b37d023Ffa244022A9aa60EeB351cc79FD4e5",
  "0x69C4c9cf979431DA6C4B4a2F3874E6378DFC8157",
  "0xE056FB8Ce6A3437530B1AfF799185A009b25990b",
  "0xf31F62A6Afb0546771a821e0F98FD187Ee7f7d4C",
  "0x2792Ccd3F02a22beBa49F28F3ab0B52dF18BD280",
  "0x109eAA8b5Ea469fb5aCe0647A93695D8DCD5e836",
]

async function staking(time, ethBlock, chainBlocks){
  const balances = {}
  await sumTokens(balances, stakingPools.map(pool=>[BSW, pool]), chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`)
  return balances
}

module.exports = {
  bsc: {
    staking,
    tvl: uniTvlExport(factory, "bsc", transformBscAddress)
  },
};
'''
'''--- projects/bitBTC.js ---
const sdk = require("@defillama/sdk");
const { getBlock } = require('./helper/getBlock');
const { transformOptimismAddress } = require('./helper/portedTokens');

const WBTC = "0x68f180fcce6836688e9084f035309e29bf0a2095";
const bitANT = "0x5029c236320b8f15ef0a657054b84d90bfbeded3";
const bitBTC = "0xc98b98d17435aa00830c87ea02474c5007e1f272";

const tvlContracts = [
    {
        address: '0x03bBa86E68c7DD733703cbCD44072082aF702d85', // farmV2
        token: WBTC
    }, {
        address: '0xEcbaFFaa5c4e94219f4C166DaC9D4A1520CAd827', // farmV3
        token: WBTC
    }
];

const stakingContracts = [
    {
        address: '0x03bBa86E68c7DD733703cbCD44072082aF702d85', // farmV2
        token: bitANT
    }, {
        address: '0xEcbaFFaa5c4e94219f4C166DaC9D4A1520CAd827', // farmV3
        token: bitANT
    }, {
        address: '0x03bBa86E68c7DD733703cbCD44072082aF702d85', // farmV2
        token: bitBTC
    }, {
        address: '0xEcbaFFaa5c4e94219f4C166DaC9D4A1520CAd827', // farmV3
        token: bitBTC
    }
];

async function findBalances(contracts, block) {
    const transform = await transformOptimismAddress();
    const balances = {};

    const balanceOfs = (await sdk.api.abi.multiCall({
        calls: contracts.map((c) => ({
            target: c.token,
            params: c.address
        })),
        abi: "erc20:balanceOf",
        block,
        chain: 'optimism'
    })).output;
    
    for (let i = 0; i < contracts.length; i++) {
        if (contracts[i].token == bitBTC) {
            sdk.util.sumSingleBalance(
                balances, 
                transform(WBTC), 
                balanceOfs[i].output / 10 ** 16
            );
        } else {
            sdk.util.sumSingleBalance(
                balances, 
                transform(contracts[i].token), 
                balanceOfs[i].output
            );
        };
    };
    return balances;
};

async function tvl(timestamp, block, chainBlocks) {
    block = await getBlock(timestamp, 'optimism', chainBlocks);
    return await findBalances(tvlContracts, block);
};

async function staking(timestamp, block, chainBlocks) {
    block = await getBlock(timestamp, 'optimism', chainBlocks);
    return await findBalances(stakingContracts, block);
};

module.exports = {
    optimism: {
        tvl,
        staking
    }
};
'''
'''--- projects/bitgert/index.js ---
const { staking } = require('../helper/staking')

module.exports = {
  bsc: {
  tvl: () =>  ({}),
    staking: staking('0xD578BF8Cc81A89619681c5969D99ea18A609C0C3', '0x8FFf93E810a2eDaaFc326eDEE51071DA9d398E83', 'bsc')
  },
};

'''
'''--- projects/bitpif/index.js ---
const { stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");

const stakingContracts = [
  // stakingContract1 =
  "0xA2b37bB22a3E685c5c7ee19DBCc06344FA35d6dc",
  // stakingContract2
  "0x6D905919ab41De27dC566ACD1f04f4F1CA60A160",
  // stakingContract3
  "0x1Da83856f1E2fa6ff07072a4108fd57e13812714",
    // stakingContract4
  "0xfC2c975AC2B14B5F073141A0ba75e1e36d21bBb1",
    // stakingContract5
  "0x27195cb7002A9e121249adc693460F98e69F93eF",
    // stakingContract6
  "0x5f0B3d111DC3e27EcaC483c5d981a27974CB84B4",
    // stakingContract7
  "0xcCACBafF877003853374BDEBca2B0AdAc463DA12",
];

const WETH_BPF_UNIV2 = "0x0111842555A378cbaA937eb02818101d0040733B";
const USDT_BPF_UNIV2 = "0x70e688b7ff542Bac51ee0e65B77F2f1096e2A361";
const DAI_BPF_UNIV2 = "0xa061Fa048F894bcfed5eC0B2c5B56d80d488833d";
const USDC_BPF_UNIV2 = "0xb2aa61b5bF5Da7b39404A89D20FD9CF10076B77D";
const BPF = "0x5197FBE1a86679FF1360E27862BF88B0c5119BD8";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, BPF),
    pool2: pool2s(stakingContracts, [WETH_BPF_UNIV2]),
    tvl: (async) => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, BPF),
    pool2: pool2s(stakingContracts, [USDT_BPF_UNIV2]),
    tvl: (async) => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, BPF),
    pool2: pool2s(stakingContracts, [DAI_BPF_UNIV2]),
    tvl: (async) => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, BPF),
    pool2: pool2s(stakingContracts, [USDC_BPF_UNIV2]),
    tvl: (async) => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
};

'''
'''--- projects/blackbird-finance/index.js ---
const {addFundsInMasterChef} = require("../helper/masterchef");
const {stakingUnknownPricedLP} = require("../helper/staking");
const {pool2BalanceFromMasterChefExports} = require("../helper/pool2");

const bird = "0x9A3d8759174f2540985aC83D957c8772293F8646";
const masterchef = "0xDF937094C6f2B757Dfd1265e5e1550Ea0055b27A";

const translate = {
    "0xbed48612bc69fa1cab67052b42a95fb30c1bcfee": "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
    "0x765277eebeca2e31912c9946eae1021199b39c61": "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
    "0xb44a9b6905af7c801311e8f4e76932ee959c663c": "fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
    "0x9b8077c6590b560f1a9d60512648277d29b35a3b": "polygon:0x8a953cfe442c5e8855cc6c61b1293fa648bae472",
    "0xc9baa8cfdde8e328787e29b4b078abf2dadc2055": "polygon:0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
}

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, masterchef, chainBlocks.cronos, "cronos", addr=>{
        addr = addr.toLowerCase();
        if (translate[addr] !== undefined) {
            return translate[addr]
        }
        return `cronos:${addr}`
    }, undefined, [bird], true, true, bird);
    return balances;
}

module.exports = {
    cronos: {
        tvl,
        staking: stakingUnknownPricedLP(masterchef, bird, "cronos", "0xa970c3B154dE5dbf0054f3dBF18AE2f92Fb937ae"),
        pool2: pool2BalanceFromMasterChefExports(masterchef, bird, "cronos", addr=>`cronos:${addr}`)
    }
}
'''
'''--- projects/blackgoat-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const token = "0xa9351B9Bf071a95bEFDAa1e76267919A7214b922";
const masterChef = "0x46ba4eF20f78e881A8219E5368107181617afB50";

module.exports = {
    ...masterChefExports(masterChef, "fantom", token, false)
}
'''
'''--- projects/blackpool.js ---
const sdk = require("@defillama/sdk")
const BigNumber = require("bignumber.js")
const { unwrapUniswapLPs } = require("./helper/unwrapLPs");

// STAKING = xBPT staking on mainnet + LP staking on mainnet + LP staking on polygon/cometh
// xBPT staking on mainnet
const BPT_mainnet = '0x0eC9F76202a7061eB9b3a7D6B59D36215A7e37da'
const xBPT_mainnet = '0x46c5098f73fa656e82d7e9afbf3c00b32b7b1ee2'

// LP tokens staked on sushiswap (mainnet against weth)  
const sushiMasterchef = "0xc2edad668740f1aa35e4d8f227fb8e17dca888cd"
const BPT_WETH_LP_mainnet_sushi = '0x57024267e8272618f9c5037d373043a8646507e5' 

// LP tokens staked on polygon (cometh against weth and must)
const BPT_polygon = '0x6863BD30C9e313B264657B107352bA246F8Af8e0'
const BPT_WETH_LP_cometh = '0x1f2f74bf3478ab4614e002cad1c67d3a84a5c2bd'
const BPT_MUST_LP_cometh = '0xc8978a3de5ce54e1a2fe88d2036e2cc972238126' 
const BPT_WETH_LP_staking = '0xe3ae080d6a4f1ac5ababf514f871428342135877'
const BPT_MUST_LP_staking = '0xe29544a8145978a2355e44fbac61f4748f0ecca6'

async function mainnetStaking(timestamp, ethBlock, chainBlocks) { 
  let balances = {}

  // xBPT staking
  const { output: xBPT_BPT_bal } = await sdk.api.erc20.balanceOf({
    target: BPT_mainnet,
    owner: xBPT_mainnet,
    block: ethBlock,
    chain: 'ethereum'
  })
  console.log(`BPT staked in xBPT on mainnet: ${xBPT_BPT_bal / 1e18}`)
  sdk.util.sumSingleBalance(
    balances,
    BPT_mainnet,
    xBPT_BPT_bal
  );

  // Sushiswap LP BPT/WETH staking
  const { output: BPT_WETH_LP_tokens } = await sdk.api.erc20.balanceOf({
    target: BPT_WETH_LP_mainnet_sushi,
    owner: sushiMasterchef,
    block: ethBlock, 
    chain: 'ethereum' 
  })
  const lpBalances = [{
      'token': BPT_WETH_LP_mainnet_sushi, 
      'balance': BPT_WETH_LP_tokens
  }]
  console.log('Sushiswap BPT/WETH LP staked in masterchef', BPT_WETH_LP_tokens / 1e18)
  balances = {}
  await unwrapUniswapLPs(balances, lpBalances, ethBlock);

  return balances
}

async function polygonStaking(timestamp, ethBlock, chainBlocks) { 
  const balances = {}

  const {output: lpBalances} = await sdk.api.abi.multiCall({
    calls: [
      {target: BPT_WETH_LP_cometh, params: BPT_WETH_LP_staking},
      {target: BPT_MUST_LP_cometh, params: BPT_MUST_LP_staking} 
    ],
    abi: 'erc20:balanceOf',
    block: chainBlocks['polygon'],
    chain: 'polygon'
  })
  const lpPositions = lpBalances.map(t => ({
    token: t.input.target,
    balance: t.output,
  }))
  const transform = addr => {
    if (addr.toLowerCase() === BPT_polygon.toLowerCase()) {
      return BPT_mainnet
    } else {
      return 'polygon:' + addr
    }
  }
  await unwrapUniswapLPs(balances, lpPositions, chainBlocks['polygon'], 'polygon', transform)

  return balances
}

module.exports = {
  methodology: "TVL of BlackPool corresponds to staking which consists of xBPT staking on mainnet + LP staking on mainnet/sushiswap (BPT/WETH in masterchef) + LP staking on polygon/cometh (BPT/WETH + BPT/MUST)",
  ethereum: {
    staking: mainnetStaking,
    tvl: () => ({})
  },
  polygon: {
    staking: polygonStaking,
    tvl: () => ({})
  },
}

'''
'''--- projects/blindex/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("../helper/abis/blindex.json");
const { getBlock } = require("../helper/getBlock");
const { calculateUniTvl } = require("../helper/calculateUniTvl.js");
const { formatAddressChecksum } = require("../helper/formatAddressChecksum.js");

//-------------------------------------------------------------------------------------------------------------
// How to add a new chain?
// 1. Add it to the chains global array
// 2. create a function to calculate the TVL of the chain (similar to what we did with the 'rskTvl' function)
// 3. Add your new chain to the export module
// 4. Add your new chain to the 'sumChainTvls' function in the export module
//-------------------------------------------------------------------------------------------------------------

// Test on the RSK network:
// Go to @defilama/sdk/build/computetvl/blocks.js and add 'rsk' to the chainsForBlocks array

const chains = {
  rsk: {
    uniswapFactoryAddress: "0x5Af7cba7CDfE30664ab6E06D8D2210915Ef73c2E",
    bdxTokenAddress: "0x6542a10E68cEAc1Fa0641ec0D799a7492795AAC1",
    // If a token doesn't exist on CoinGecko, map it to another token that's equal to it / wrappes it
    coingeckoMapping: {
      prefix: "rsk",
      "0x542fda317318ebf1d3deaf76e0b632741a7e677d": "rootstock", // RSK's WRBTC
      "0x1d931bf8656d795e50ef6d639562c5bd8ac2b78f": "ethereum", // RSK's ETHs
      "0xb450ff06d950efa9a9c0ad63790c51971c1be885": "usd-coin", // RSK's BDUS - USD stable
      "0x99ac494badd0cba26143bd423e39a088591c7b09": "tether-eurt", // RSK's BDEU, - Euro stable
      "0xa4a8fb98a26e5314397170e5d12da8b73dc2ceb5": "pax-gold", // RSK's bXAU, - Gold stable
      "0x2415e222755fd1f07b0a565eb4f036e410852ee0":
        "jarvis-synthetic-british-pound", // RSK's bGBP - British Pound Stable
      "0xb5999795be0ebb5bab23144aa5fd6a02d080299f": "usd-coin", // RSK's XUSD, - USD stable
      "0xe700691da7b9851f2f35f8b8182c69c53ccad9db": "usd-coin", // RSK's DOC - USD stable
    },
  },
};

function mapCoingeckoAddress(chainName, address) {
  let mappedName =
    chains[chainName].coingeckoMapping[address] ||
    chains[chainName].coingeckoMapping[address.toLowerCase()];

  if (!mappedName) {
    const addressPrefix =
      chainName === "ethereum"
        ? ""
        : `${chains[chainName].coingeckoMapping["prefix"]}:`;
    mappedName = `${addressPrefix}${formatAddressChecksum(address, chainName)}`;
  }

  return mappedName;
}

async function getBDStableCollateralBalances(block, chainName, bdstable) {
  const collateralPoolsLength = (
    await sdk.api.abi.call({
      target: formatAddressChecksum(bdstable.address, chainName),
      abi: abi["getBdStablesPoolsLength"],
      chain: chainName,
      block,
    })
  ).output;

  const bdstableCollateralPools = [];
  for (let index = 0; index < collateralPoolsLength; index++) {
    const poolAddress = (
      await sdk.api.abi.call({
        target: formatAddressChecksum(bdstable.address, chainName),
        abi: abi["bdstable_pools_array"],
        params: index,
        chain: chainName,
        block,
      })
    ).output;

    bdstableCollateralPools.push(poolAddress);
  }

  const balances = {};

  for (let index = 0; index < bdstableCollateralPools.length; index++) {
    const collateralAddress = await (
      await sdk.api.abi.call({
        target: formatAddressChecksum(
          bdstableCollateralPools[index],
          chainName
        ),
        abi: abi["getBDStablePoolCollateral"],
        chain: chainName,
        block,
      })
    ).output;

    const coingeckoMappedName = mapCoingeckoAddress(
      chainName,
      collateralAddress
    );
    const collateralBalance = await getBalanceOfWithPercision(
      block,
      chainName,
      formatAddressChecksum(bdstableCollateralPools[index], chainName),
      collateralAddress
    );

    sdk.util.sumSingleBalance(balances, coingeckoMappedName, collateralBalance)
  }

  const bdxTokenAddress = chains[chainName].bdxTokenAddress;
  const coingeckoMapBdxAddress = mapCoingeckoAddress(
    chainName,
    bdxTokenAddress
  );

  balances[coingeckoMapBdxAddress] = await getBalanceOfWithPercision(
    block,
    chainName,
    formatAddressChecksum(bdstable.address, chainName),
    formatAddressChecksum(bdxTokenAddress, chainName)
  );

  return balances;
}

async function getBalanceOfWithPercision(block, chainName, owner, target) {
  let balance = (
    await sdk.api.erc20.balanceOf({
      target: formatAddressChecksum(target, chainName),
      owner: formatAddressChecksum(owner, chainName),
      chain: chainName,
      block,
    })
  ).output;

  const decimals = (
    await sdk.api.erc20.decimals(
      formatAddressChecksum(target, chainName),
      chainName
    )
  ).output;

  return balance / 10 ** decimals;
}

function sumBalances(balancesArray) {
  return balancesArray.reduce((balances, singleBalance) => {
    for (const [coingeckoTokenId, amount] of Object.entries(singleBalance)) {
      if (!balances[coingeckoTokenId]) {
        balances[coingeckoTokenId] = 0;
      }

      balances[coingeckoTokenId] += amount;
    }

    return balances;
  }, {});
}

async function uniswapV2Tvl(block, chainName) {
  const rawBalances = await calculateUniTvl(
    (address) => formatAddressChecksum(address, chainName),
    block,
    chainName,
    formatAddressChecksum(chains[chainName].uniswapFactoryAddress, chainName),
    undefined,
    true
  );

  const tokensAddresses = Object.keys(rawBalances);
  const balances = {};

  for (let index = 0; index < tokensAddresses.length; index++) {
    const currentToken = tokensAddresses[index];
    const decimals = (
      await sdk.api.erc20.decimals(
        formatAddressChecksum(currentToken, chainName),
        chainName
      )
    ).output;

    const mappedAddress = mapCoingeckoAddress(chainName, currentToken);
    if (!balances[mappedAddress]) {
      balances[mappedAddress] = 0;
    }

    balances[mappedAddress] += rawBalances[currentToken] / 10 ** decimals;
  }

  return balances;
}

async function getAllBDStables(block, bdxTokenAddress, chainName) {
  const bdStables = [];
  const bdstablesLength = (
    await sdk.api.abi.call({
      target: formatAddressChecksum(bdxTokenAddress, chainName),
      abi: abi["getBdStablesLength"],
      chain: chainName,
      block,
    })
  ).output;

  for (let index = 0; index < bdstablesLength; index++) {
    bdStables.push({
      address: (
        await sdk.api.abi.call({
          target: formatAddressChecksum(bdxTokenAddress, chainName),
          abi: abi["getBDStable"],
          chain: chainName,
          block,
          params: index,
        })
      ).output,
    });
  }

  return bdStables;
}

async function getBdxPriceInUSD(block, chainName) {
  const bdusAddress = formatAddressChecksum(
    "0xb450ff06d950efa9a9c0ad63790c51971c1be885",
    chainName
  );

  const bdxPriceInUsd_d12 = (
    await sdk.api.abi.call({
      target: bdusAddress,
      abi: abi["getBDXPriceUsdD12"],
      chain: chainName,
      block,
    })
  ).output;

  return bdxPriceInUsd_d12 / 10 ** 12;
}

// TODO: This is needed until BDX will be avilable on Coingecko
async function convertBdxToUsdc(block, chainName, balances) {
  const bdxTokenAddress = chains[chainName].bdxTokenAddress;
  const coingeckoMapBdxAddress = mapCoingeckoAddress(
    chainName,
    bdxTokenAddress
  );

  balances["usd-coin"] +=
    balances[coingeckoMapBdxAddress] *
    (await getBdxPriceInUSD(block, chainName));
  balances[coingeckoMapBdxAddress] = 0;

  return balances;
}

async function tvl(chainName, block) {
  const balancesArray = [];

  //=======
  // AMM
  //=======
  balancesArray.push(await uniswapV2Tvl(block, chainName));

  //===================
  // Collateral
  //===================
  const bdstables = await getAllBDStables(
    block,
    chains[chainName].bdxTokenAddress,
    chainName
  );
  for (let index = 0; index < bdstables.length; index++) {
    balancesArray.push(
      await getBDStableCollateralBalances(block, chainName, bdstables[index])
    );
  }

  const balances = sumBalances(balancesArray);

  // TODO: This should be removed when BDX will be listed on Coingecko
  return await convertBdxToUsdc(block, chainName, balances);
}

const rsk = async function rskTvl(timestamp, ethBlock, chainblocks) {
  const block = await getBlock(timestamp, "rsk", chainblocks);
  return tvl("rsk", block);
};

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "(1) AMM LP pairs - All the liquidity pools from the Factory address are used to find the LP pairs. (2) Collateral - All the collateral being used to support the stable coins - Bitcoin, Ethereum & BDX",
  rsk: {
    tvl: rsk,
  },
};

'''
'''--- projects/blitzlabs.js ---
const { stakings } = require("./helper/staking");
const { pool2s } = require("./helper/pool2");

const singleStakingContracts = [
    "0x8A6297d1df7d0c84f0d5F600Fe601b6d9Ce32F53",
];

const LPStakingContracts = [
    "0xAfCEE27282dFC68Eb4b7aecbFDFfA1FA8A04dbf7",
]

const BUSD_BLITZ_CAKELP = "0x000d27d4DfB3e336a6462A3435C3dd3953391bb7";
const BLITZ = "0xF376807DcdbAa0d7FA86E7c9EAcC58d11ad710E4";

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    staking: stakings(singleStakingContracts, BLITZ, 'bsc'),
    pool2: pool2s(LPStakingContracts, [BUSD_BLITZ_CAKELP], 'bsc'),
    tvl: async () => ({}),
  },
  methodology: "Counts liquidty on the staking and pool2s only",
}

'''
'''--- projects/blizzard/abi.json ---
{
    "token": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "contract IERC20"
            }
        ],
        "name": "token",
        "inputs": []
    },
    "balance": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "balance",
        "inputs": []
    },
    "want": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "contract IERC20"
            }
        ],
        "name": "want",
        "inputs": []
    }
}
'''
'''--- projects/blizzard/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");

//Blizz Vault
const VaultBlizz = "0x37126BCaeF2b033011d7a68c3884eC294c965B3a";
const BLIZZ = "0xB147656604217a03Fe2c73c4838770DF8d9D21B8";
const WAVAX = "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7";

//Locked Vault
const VaultLockedBlizz = "0x7754cdd32BD47a6A857c1939740845905F5F9308";

//JOE Vault
const VaultJoe = "0x336e16b1f3A10048F38367B16808CF70e9e34E50";

const lpVaults = [
  "0xE595C99b35f17408178097aFcF08DaE31DF0AD78", //PGL Vault PNG
  "0xe69FaFbCA661368855A29B9Bf7eD14aA5c27FB4E", //JLP Vault JOE
  "0xBcf284640dF1b17DC9022168798bc839e36F39Df", //JLP Vault JOE
  "0x5806F70646832bfe5Dd11dF847832f9c268545c4", //JLP Vault JOE
  "0x3C6e6019337AeEb1E58dcab16473Bf05B92B7417", //PGL Vault PNG
  "0x18914D6691A5D9c43Db28a51Fb0c0891e73ae5b6", //USDC Vault
  //"0xdc68EB4F1E603DA8909929bE74b68CBa943017c6", //JLP Vault JOE
  //"0xD0659570B2De12F7814189c54f1316381F947329", //JLP Vault JOE
];

const calcTvl = async (balances, chain, block, token, balance, vault) => {
  const TokenOrWant = (
    await sdk.api.abi.call({
      abi: token,
      target: vault,
      chain,
      block,
    })
  ).output;

  const balanceOfvault = (
    await sdk.api.abi.call({
      abi: balance,
      target: vault,
      chain,
      block,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, `avax:${TokenOrWant}`, balanceOfvault);
};

const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const wantOfVaults = (
    await sdk.api.abi.multiCall({
      abi: abi.want,
      calls: lpVaults.map((vault) => ({
        target: vault,
      })),
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output.map((w) => w.output);

  const balanceOfVaults = (
    await sdk.api.abi.multiCall({
      abi: abi.balance,
      calls: lpVaults.map((vault) => ({
        target: vault,
      })),
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output.map((w) => w.output);

  const lpPositions = [];

  for (let i = 0; i < lpVaults.length; i++) {
    lpPositions.push({
      token: wantOfVaults[i],
      balance: balanceOfVaults[i],
    });
  }

  const transformAddress = await transformAvaxAddress();
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["avax"],
    "avax",
    transformAddress
  );

  await calcTvl(
    balances,
    "avax",
    chainBlocks["avax"],
    abi.token,
    abi.balance,
    VaultLockedBlizz
  );

  await calcTvl(
    balances,
    "avax",
    chainBlocks["avax"],
    abi.want,
    abi.balance,
    VaultJoe
  );

  return balances;
};

module.exports = {
  deadFrom: 1648765747,
  misrepresentedTokens: true,
  avalanche: {
    tvl: avaxTvl,
    staking: staking(VaultBlizz, BLIZZ, "avax"),
  },
  methodology: "We count liquidity on the Vaults through their contracts",
};

'''
'''--- projects/blizzfinance/index.js ---
const { aaveExports } = require('../helper/aave')

module.exports={
    timetravel: true,
    methodology: "Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending",
    avax:{
        tvl: aaveExports("avax", "0xfF50b540c9152F1841edF47b49dA69696Be59783").tvl,
        borrowed: ()=>({}) // hacked, it's all bad debt
    }
}

'''
'''--- projects/blockng/index.js ---
const { sumUnknownTokens, getUniTVL } = require('../helper/unknownTokens');
const { stakingPricedLP, staking, } = require('../helper/staking')
const sdk = require('@defillama/sdk')
const blockng = require('../helper/abis/blockng.json');
const kashipairABI = require('../helper/abis/kashipair.json');
const BigNumber = require('bignumber.js');
const utils = require('../helper/utils');

const chain = 'smartbch'
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04"
const LAW = "0x0b00366fBF7037E9d75E4A569ab27dAB84759302"
const lawUSD = "0xE1E655BE6F50344e6dd708c27BD8D66492d6ecAf"

const coreAssets = [
  WBCH,
  LAW,
  '0x7b2B3C5308ab5b2a1d9a94d20D35CCDf61e05b72',  // FlexUSD
  '0xBc2F884680c95A02cea099dA2F524b366d9028Ba',  // BlockNG pegged USDT
]

const masterchefTvl = async (timestamp, ethBlock, { [chain]: block }) => {
  const toa = [
    ['0x0000000000000000000000000000000000000000', '0x896a8ddb5B870E431893EDa869feAA5C64f85978'], // BCH
    ['0x24d8d5Cbc14FA6A740c3375733f0287188F8dF3b', '0x82112e12533A101cf442ee57899249C719dc3D4c'], // DAIQUIRI
  ]

  return sumUnknownTokens({ chain, block, coreAssets, tokensAndOwners: toa, });
}

const pool2 = async (timestamp, ethBlock, { [chain]: block }) => {
  const toa = [
    ['0x88b2522b9f9121b3e19a28971a85d34d88e4acc6', '0xe49717403eEa8c9Fa03610Bd9E6df96Ac5066298'], // lawETP-LAW@BEN
    ['0x1d5a7bea34ee984d54af6ff355a1cb54c29eb546', '0xb7Ac725E59860051f77397C14dd8D30d9cb825e6'], // lawUsdfLawLpMist
    ['0x8e992c4c2c84e5d372ef9a933be06f34962e42f5', '0xf3F7dC16Cab45c946F04F3D2F965Ca6dCBDb3aae'], // lawUSD-flexUSD@BEN
    ['0xFEdfE67b179b2247053797d3b49d167a845a933e', '0x3D82b2D0927f528E708eC7680ae0088490A6d0C4'], // lawUSD-BCH@BEN
    ['0xd55a9a41666108d10d31baeeea5d6cdf3be6c5dd', '0xCee23c02B819e4B9b6E34753e3c0C7f21c4bC398'], // LAW-BCH@BEN
    // ['0x8735628e1E5442B49A37F9751B0793C11014d1b6', '0x5227fDc4876677551c487C42893e282a1E4A9dDa'], // lawETPlawswapLP
    // ['0x58B006A8380Cc4807b1d58C5a339A0E6f2338F1A', '0xc5E4c50f0d39E2A592419314D03880e541939d11'], // lawUsdfLawLpLawSwap
    // ['0x7d43E5A766E9325E981ede2396B1b51Ff8A635Ed', '0xa9172f21D5BD0d60A1f4d6aa73DFC3173512Af0E'], // lawUsdflexUsdLpLawSwap
    // ['0x43205613aD09aeF94fE0396F34c2C93eBc6D1b7E', '0xAfAca05002412b6200B2e24e3044E63713c9bcD3'], // lawUsdusdtLpLawSwap
    // ['0xB82FF56E3E91c102a5dAf9Aa31BaE4c8c63F53A5', '0x5a6b3a1B16794D492Fa9B72092C94468ae74901D'], // lawUSD-bcBCH@LAWSWAP
    // ['0x54AA3B2250A0e1f9852b4a489Fe1C20e7C71fd88', '0xE55dd317e8A4DaAB35dfEA7590518811947a4ADC'], // LAW-BCH@LAWSWAP
  ]

  return sumUnknownTokens({ chain, block, coreAssets, tokensAndOwners: toa, });
}

const BENTOBOX = "0xDFD09C4A1Fd999F6e8518398216c53fcEa6f4020"
const bentoAssets = [
  [LAW, "law"],
  [WBCH, "bitcoin-cash"]
]
const bentoTVLs = bentoAssets.map(asset => staking(BENTOBOX, asset[0], chain, asset[1], 18))

const lawswapFactory = '0x3A2643c00171b1EA6f6b6EaC77b1E0DdB02c3a62'.toLowerCase()
const lawETP = "0x4ee06d0486ced674E75Ed9e521725580e8ffDA21"
const LAW_LAWETP_PAIR = "0x8735628e1e5442b49a37f9751b0793c11014d1b6"
const lawETP_POOL = "0x7B2B28a986E744D646F43b9b7e9F6f416a2a2BdA" // lawETP single asset pool
const lawEtpPool = stakingPricedLP(lawETP_POOL, lawETP, "smartbch", LAW_LAWETP_PAIR, "law", 18)

// staking
const LAW_RIGHTS = "0xe24Ed1C92feab3Bb87cE7c97Df030f83E28d9667" // DAO address
const daoStaking = staking(LAW_RIGHTS, LAW, "smartbch", "law", 18)

const lawSwapTVL = getUniTVL({
  chain,
  factory: lawswapFactory,
  coreAssets,
})

//voter
const VOTER = "0x10EAc6Cf7F386A11B6811F140CA8B9D6Ae7FbDf5"
//blockng agg contract
const AGG = "0x2bb410bD6c71147A593aCbB1CEB586aA253EFD92"

const civilBeams = async (_, _b, { [chain]: block }) => {

  const beamCount = (await sdk.api.abi.call({
    target: AGG, abi: blockng["numberOfPool"], params: [VOTER], chain, block,
  })
  ).output
  //skip pool 0 cause it is nft pool
  const allbeamInfo = (await sdk.api.abi.call({
    abi: blockng["getPoolInfo"],
    target: AGG,
    params: [VOTER, LAW, 1, beamCount],
    chain, block,
  })
  ).output
  const gaugeMapping = {}
  for (let i = 0; i < allbeamInfo.length; i++) {
    let { dexFactory, gaugeAddress, lpTokenAddress, } = allbeamInfo[i]
    dexFactory = dexFactory.toLowerCase()
    gaugeAddress = gaugeAddress.toLowerCase()
    lpTokenAddress = lpTokenAddress.toLowerCase()
    if (dexFactory !== lawswapFactory)
      gaugeMapping[gaugeAddress] = lpTokenAddress
  }

  const toa = []
  Object.entries(gaugeMapping).forEach(([owner, token]) => toa.push([token, owner]))

  return sumUnknownTokens({ chain, block, coreAssets, tokensAndOwners: toa, });
}

// borrows
const kashiPairs = [
  ["0x3F562957b199d6362B378dBa5e3b45EE6fe77779", WBCH, lawUSD],
  ["0xd46e5a9Cd7A55Bf8d3582Ff66218aD3e63462506", LAW, lawUSD],
]

const bentoBorrows = async (_, _b, { [chain]: block }) => {
  const totalBorrow = kashipairABI.find(val => val.name === "totalBorrow");
  const totals = await Promise.all(kashiPairs.map(async (pair) => {
      const total = (await sdk.api.abi.call({
          target: pair[0],
          abi: totalBorrow,
          chain, block,
      })).output
      return total.base
  }))
  const total = totals.reduce((sum, val) => BigNumber(sum).plus(val).toFixed(0), "0")

  // skip conversion assuming 1 lawUSD = 1 flexUSD
  return {'tether': BigNumber(total).dividedBy(10 ** 18)}
}

// fetch punksTVL from an api endpoint, data is updated every 15 minutes
// Punk tvl is no longer counted, because we do not count nft value in any other protocol
const punksTVL = async () => {
  const response = await utils.fetchURL(`https://raw.githubusercontent.com/BlockNG-Foundation/LawPunkMetaverse/master/punksTVL.json`)
  const tvl = Number(response.data.totalPunkValueLockedInBch) / 1e18
  return { "bitcoin-cash": tvl }
}

module.exports = {
  smartbch: {
    tvl: sdk.util.sumChainTvls([lawSwapTVL, masterchefTvl, ...bentoTVLs,  ]),
    // borrowed: bentoBorrows,
    pool2: sdk.util.sumChainTvls([pool2, civilBeams, ]),
    staking: sdk.util.sumChainTvls([lawEtpPool, daoStaking,]),
  }
}
'''
'''--- projects/bloxmove/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const farmContract = "0xb39EDbC5d0b23d7F4F140bBfDE92562fB1838769";
const WETH_BLXM_UNIV2 = "0xE0a97733F90d089df8EeE74a8723d96196fC4931";
const BLXM = "0x38d9eb07A7b8Df7D86F440A4A5c4a4c1a27E1a08";

const farmContract_bsc = "0xFaD010684a68AefAcF6BBe1357642c7C73a7Ed80";
const WBNB_BLXM_CakeLP = "0xD617cc09A85dC93De9FB1487ac8863936c5E511F";
const BLXM_bsc = "0x40e51e0ec04283e300f12f6bb98da157bb22036e";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(farmContract, BLXM),
    pool2: pool2(farmContract, WETH_BLXM_UNIV2),   
  },
  bsc: {
    staking: staking(farmContract_bsc, BLXM_bsc, "bsc"),
    pool2: pool2(farmContract_bsc, WBNB_BLXM_CakeLP, "bsc"),
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking and pool2 only",
};

'''
'''--- projects/bluebit/abis.json ---
{
  "summary": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "summary",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "tvl",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deposites",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/bluebit/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abis.json");
const { staking } = require("../helper/staking");
const { toUSDTBalances } = require("../helper/balances");

const account = "0x0000000000000000000000000000000000000000";
const token = "0x4148d2Ce7816F0AE378d98b40eB3A7211E1fcF0D";
const veToken = "0xdf7C547f332351A86DB0D89a89799A7aB4eC9dEB";

const tvl = async (timestamp, block, chainBlocks) => {
  const stats = chainBlocks.aurora > 66730102 
    ? "0x36C6FBA304009a036BaaE1a24a570B450Ae14a5C" 
    : "0xd1bc52B30b1031a9283Cc9C84575Fc3837A098F5";

  let tvl = (
    await sdk.api.abi.call({
      abi: abi.summary,
      chain: "aurora",
      target: stats,
      params: [account],
      block: chainBlocks.aurora,
    })
  ).output.tvl;
  return toUSDTBalances(tvl / 1e18);
};

module.exports = {
  methodology: "The vaults on https://bluebit.fi are included in TVL.",
  timetravel: true,
  misrepresentedTokens: false,
  start: 62936418,
  aurora: {
    tvl: tvl,
    staking: staking(veToken, token, "aurora"),
  },
};

'''
'''--- projects/blueshift/abi.json ---
{
  "BlueshiftRegistry": {
    "getPortfolios": {
      "inputs": [],
      "name": "getPortfolios",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "baseTokenAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "lpTokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lpTokenPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenCount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "depositLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawLimit",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "depositEMAPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawEMAPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "portfolioShare",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "targetWeight",
                  "type": "uint256"
                }
              ],
              "internalType": "struct BlueshiftPortfolioAndPairRegistry.TokenInfo[]",
              "name": "tokens",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct BlueshiftPortfolioAndPairRegistry.PortfolioInfo[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  },
  "BlueshiftEarning": {
    "getAccDeposit": {
      "inputs": [],
      "name": "getAccDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "getToken": {
      "inputs": [],
      "name": "getToken",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
}
'''
'''--- projects/blueshift/index.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');
const { transformMilkomedaAddress } = require('../helper/portedTokens');

const abi = require('./abi.json');

const REGISTRY_CONTRACT = '0x83E384d119adA05195Caca26396B8f56fdDA1c91';
const MANUAL_POOL_CONTRACT = '0xA4f0e3C80C77b347250B9D3999478E305FF814A4';
// temporary solution using BLUES/ADA price
const BLUESHIFT_INDEX_PORTFOLIO = '0xB2A76Ce2D5eD32aD7F8B93a1098C1Fee473e27bA';

async function staking(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformMilkomedaAddress();

  const value = (await sdk.api.abi.call({
    abi: abi.BlueshiftEarning.getAccDeposit,
    chain: 'milkomeda',
    target: MANUAL_POOL_CONTRACT,
    params: [],
    block: chainBlocks['milkomeda'],
  })).output;

  const tokenAddress = (await sdk.api.abi.call({
    abi: abi.BlueshiftEarning.getToken,
    chain: 'milkomeda',
    target: MANUAL_POOL_CONTRACT,
    params: [],
    block: chainBlocks['milkomeda'],
  })).output;

  // temporary solution using BLUES/ADA price
  const portfolios = (await sdk.api.abi.call({
    abi: abi.BlueshiftRegistry.getPortfolios,
    chain: 'milkomeda',
    target: REGISTRY_CONTRACT,
    params: [],
    block: chainBlocks['milkomeda'],
  })).output;

  const bluesPortfolio = portfolios.filter(portfolio => portfolio.contractAddress === BLUESHIFT_INDEX_PORTFOLIO)[0];
  if (!bluesPortfolio) {
    return balances;
  }

  const baseTokenAddress = bluesPortfolio.baseTokenAddress;
  const baseTokenPrice = bluesPortfolio.tokens.filter(token => token.tokenAddress === baseTokenAddress)[0].price;
  const tokenPrice = bluesPortfolio.tokens.filter(token => token.tokenAddress === tokenAddress)[0].price;
  const valueInBaseToken = BigNumber(value).multipliedBy(tokenPrice).div(baseTokenPrice);

  await sdk.util.sumSingleBalance(balances, transform(baseTokenAddress), valueInBaseToken.toNumber());
  // ----------------------------------------

  // CoinGecko solution
  // await sdk.util.sumSingleBalance(balances, transform(tokenAddress), value);

  return balances;
}

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformMilkomedaAddress();

  const portfolios = (await sdk.api.abi.call({
    abi: abi.BlueshiftRegistry.getPortfolios,
    chain: 'milkomeda',
    target: REGISTRY_CONTRACT,
    params: [],
    block: chainBlocks['milkomeda'],
  })).output;

  for (let portfolio of portfolios) {
    const value = portfolio.totalValue;
    await sdk.util.sumSingleBalance(balances, transform(portfolio.baseTokenAddress), value);
  }

  return balances;
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology: 'Accumulates TVL of all Blueshift portfolios calculated in base tokens. Adds TVL of BLUES tokens staked in Blueshift yield pools.',
  start: 2023331,
  milkomeda: {
    staking,
    tvl
  }
};

'''
'''--- projects/blur-finance/abi.js ---
module.exports = {
  poolInfo2: {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_pid",
        "type": "uint256"
      }
    ],
    "name": "poolInfo2",
    "outputs": [
      {
        "internalType": "address",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "strat0",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "share0",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "strat1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "share1",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  poolLength: {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
'''
'''--- projects/blur-finance/index.js ---
const sdk = require("@defillama/sdk")
const abi = require('./abi')
const { getChainTransform } = require('../helper/portedTokens')
const chain = 'bsc'
const { getLPData, getTokenPrices, } = require('../helper/unknownTokens')
let totalTvl

const contract = '0xf300b9171aAb493F4584b8f5601d97E627AaB451'
const blur = '0x4165084a6e5388ce53c9d9892f904a2712dd943a'
const wbnb = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c'
const sushi = '0x4165084A6e5388ce53c9D9892f904a2712Dd943A'
const busd = '0x66e428c3f67a68878562e79a0234c1f83c208770'

async function gettotalTvl(block) {
  if (!totalTvl) totalTvl = getTVL()
  return totalTvl

  async function getTVL() {
    const transform = await getChainTransform(chain)
    const balances = {
      tvl: {},
      pool2: {},
      staking: {},
    }
    const { output: length } = await sdk.api.abi.call({
      target: contract,
      abi: abi.poolLength,
      chain, block,
    })

    const calls = []
    for (let i = 0; i < length; i++) calls.push({ params: [i] })
    const { output: data } = await sdk.api.abi.multiCall({
      target: contract,
      abi: abi.poolInfo2,
      calls,
      chain, block,
    })

    const tempBalances = {}
    const lps = []

    data.forEach(({ output }) => {
      const token = output.lpToken.toLowerCase()
      const amount = output.amount0
      sdk.util.sumSingleBalance(tempBalances, token, amount)
      lps.push(token)
    })

    balances.staking['bsc:' + blur] = tempBalances[blur]
    delete tempBalances[blur]

    const pairs = await getLPData({ lps, chain, block })

    const { updateBalances, } = await getTokenPrices({ lps: Object.keys(pairs), allLps: true, coreAssets: [ ], block, chain, minLPRatio: 0.001 })

    Object.entries(tempBalances).forEach(([token, balance]) => {
      if (pairs[token]) {
        const { token0Address, token1Address } = pairs[token]
        if (blur === token0Address || blur === token1Address) {
          sdk.util.sumSingleBalance(balances.pool2, transform(token), balance)
          return;
        }
      }
      sdk.util.sumSingleBalance(balances.tvl, transform(token), balance)
    })

    await updateBalances(balances.tvl)
    await updateBalances(balances.pool2)

    return balances
  }
}

async function tvl(_, _b, { [chain]: block }) {
  return (await gettotalTvl(block)).tvl
}

async function pool2(_, _b, { [chain]: block }) {
  return (await gettotalTvl(block)).pool2
}

async function staking(_, _b, { [chain]: block }) {
  return (await gettotalTvl(block)).staking
}

module.exports = {
  bsc: {
    tvl, pool2, staking,
  }
}
'''
'''--- projects/bnbminer/index.js ---
const sdk = require('@defillama/sdk')

const contract = "0xce93F9827813761665CE348e33768Cb1875a9704"

async function tvl(time, ethBlock, chainBlocks) {
  const bnb = await sdk.api.eth.getBalance({
    target: contract,
    chain: 'bsc',
    block: chainBlocks.bsc
  })
  return {
    "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c": bnb.output
  }
}

module.exports = {
  methodology: `We count the BNB on ${contract}`,
  bsc: {
    tvl
  }
}
'''
'''--- projects/bobagateway/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "address",
                "name": "l1TokenAddress",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "l2TokenAddress",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "userDepositAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastAccUserReward",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accUserReward",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accUserRewardPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accOwnerReward",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "startTime",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/bobagateway/index.js ---
const sdk = require("@defillama/sdk");
const listTokens = require("./listTokens.json");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { getChainTransform } = require('../helper/portedTokens')

const L1LiquidityPool = "0x1A26ef6575B7BBB864d984D9255C069F6c361a14";
const L1StakingTokens = [
  "0xd26114cd6EE289AccF82350c8d8487fedB8A0C07", // OMG
  "0x42bbfa2e77757c645eeaad1655e0911a7553efbc", // BOBA
];

const L2LiquidityPool = "0x3A92cA39476fF84Dc579C868D4D7dE125513B034";
const L2StakingTokens = [
  "0xe1E2ec9a85C607092668789581251115bCBD20de", //OMG on boba
  "0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7", //BOBA on boba
];

const calcTvl = async (
  balances,
  liquidityPool,
  excludedTokens,
  chain = "ethereum",
  block,
) => {
  const transform = await getChainTransform(chain)

  const values = listTokens.tokenList.map(Object.values);
  const names = listTokens.tokenList.map(Object.keys);
  const tokensL1 = [];
  const tokensL2 = [];

  for (let i = 0; i < values.length; i++) {
    if (names[i][0].includes("TK_L1")) {
      tokensL1.push(values[i][0]);
    } else {
      tokensL2.push(values[i][0]);
    }
  }
  const calls = (chain == "ethereum" ? tokensL1 : tokensL2)
    .filter(t  => !excludedTokens.some((addr) => addr.toLowerCase() === t.toLowerCase()))
    .map(t => ({ params: t}))
  const { output } = await sdk.api.abi.multiCall({
    target: liquidityPool,
    abi: abi.poolInfo,
    calls,
    chain, block: block,
  })

  output.forEach(({ input, output: { userDepositAmount }}) => {
    sdk.util.sumSingleBalance(balances, transform(input.params[0]), userDepositAmount)
  })
};

const ethTvl_L1 = async (_, _b, { ethereum: block }) => {
  const balances = {};
  await calcTvl(balances, L1LiquidityPool, L1StakingTokens, 'ethereum', block);
  return balances;
};

const bobaTvl_L2 = async (_, _b, { boba: block }) => {
  const balances = {};
  await calcTvl(balances, L2LiquidityPool, L2StakingTokens, "boba", block);
  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: sdk.util.sumChainTvls([
      staking(L1LiquidityPool, L1StakingTokens[0]),
      staking(L1LiquidityPool, L1StakingTokens[1]),
    ]),
    tvl: ethTvl_L1,
  },
  boba: {
    staking: sdk.util.sumChainTvls([
      staking(L2LiquidityPool, L2StakingTokens[0], "boba"),
      staking(L2LiquidityPool, L2StakingTokens[1], "boba", L1StakingTokens[1]),
    ]),
    tvl: bobaTvl_L2,
  },
  methodology:
    "Counts liquidity of all the Assets deposited through LiquidtyPool Contracts",
};

'''
'''--- projects/bobagateway/listTokens.json ---
{
    "tokenList": [
        {
            "TK_L1OMG": "0xd26114cd6EE289AccF82350c8d8487fedB8A0C07"
        },
        {
            "TK_L2OMG": "0xe1E2ec9a85C607092668789581251115bCBD20de"
        },
        {
            "TK_L1USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7"
        },
        {
            "TK_L2USDT": "0x5DE1677344D3Cb0D7D465c10b72A8f60699C062d"
        },
        {
            "TK_L1DAI": "0x6b175474e89094c44da98b954eedeac495271d0f"
        },
        {
            "TK_L2DAI": "0xf74195Bb8a5cf652411867c5C2C5b8C2a402be35"
        },
        {
            "TK_L1USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
        },
        {
            "TK_L2USDC": "0x66a2A913e447d6b4BF33EFbec43aAeF87890FBbc"
        },
        {
            "TK_L1WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
        },
        {
            "TK_L2WBTC": "0xdc0486f8bf31DF57a952bcd3c1d3e166e3d9eC8b"
        },
        {
            "TK_L1REP": "0x221657776846890989a759ba2973e427dff5c9bb"
        },
        {
            "TK_L2REP": "0x8b5B1E971862015bc058234FC11ce6C4a4c536dD"
        },
        {
            "TK_L1BAT": "0x0d8775f648430679a709e98d2b0cb6250d2887ef"
        },
        {
            "TK_L2BAT": "0xc0C16dF1ee7dcEFb88C55003C49F57AA416A3578"
        },
        {
            "TK_L1ZRX": "0xe41d2489571d322189246dafa5ebde1f4699f498"
        },
        {
            "TK_L2ZRX": "0xf135f13Db3B114107dCB0B32B6c9e10fFF5a6987"
        },
        {
            "TK_L1SUSHI": "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2"
        },
        {
            "TK_L2SUSHI": "0x5fFccc55C0d2fd6D3AC32C26C020B3267e933F1b"
        },
        {
            "TK_L1LINK": "0x514910771af9ca656af840dff83e8264ecf986ca"
        },
        {
            "TK_L2LINK": "0xD5D5030831eE83e22a2C9a5cF99931A50c676433"
        },
        {
            "TK_L1UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984"
        },
        {
            "TK_L2UNI": "0xDBDE1347fED5dC03C74059010D571a16417d307e"
        },
        {
            "TK_L1DODO": "0x43Dfc4159D86F3A37A5A4B3D4580b888ad7d4DDd"
        },
        {
            "TK_L2DODO": "0x572c5B5BF34f75FB62c39b9BFE9A75bb0bb47984"
        },
        {
            "TK_L1TEST": "0xB68a38D3a10F28948EBf0f2450Fef348680F4714"
        },
        {
            "TK_L2TEST": "0xeDB79B0FD84c81E870b2fCB1D3CcF366179bA6D2"
        },
        {
            "TK_L1FRAX": "0x853d955acef822db058eb8505911ed77f175b99e"
        },
        {
            "TK_L2FRAX": "0xAb2AF3A98D229b7dAeD7305Bb88aD0BA2c42f9cA"
        },
        {
            "TK_L1FXS": "0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0"
        },
        {
            "TK_L2FXS": "0xdc1664458d2f0B6090bEa60A8793A4E66c2F1c00"
        },
        {
            "TK_L1BOBA": "0x42bbfa2e77757c645eeaad1655e0911a7553efbc"
        },
        {
            "TK_L2BOBA": "0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7"
        }
    ]
}
'''
'''--- projects/bodhfinance/index.js ---
const { compoundExports } = require('../helper/compound')
const { transformBobaAddress } = require('../helper/portedTokens')

const WETH = "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000"
const bETH = "0xe970c37243F3d0B2AeB041b855Ef6466CB140BcA"
const unitroller = "0x97b491744587d05ca33e84bB18B61Df9B3986DcE"

const { tvl, borrowed } = compoundExports(
    unitroller, "boba", bETH, WETH, transformBobaAddress(),
);

module.exports = {
    timetravel: true,
    doublecounted: false,
    methodology: "Same as Compound Finance, we just count all the tokens supplied (not borrowed money) on the lending markets",
    boba: { tvl, borrowed }
}

'''
'''--- projects/bogged.js ---
const { stakings } = require("./helper/staking");
const { pool2s } = require("./helper/pool2");

const stakingContracts = [
  "0xc3ab35d3075430f52D2636d08D4f29bD39a18B65",
  "0xcD48268d66068963242681Ed7ca39d349Fb690B9",
  "0x2F0596b989d79fda9b0A89F57D982ea02f8D978B",
];
const boggedToken = "0xb09fe1613fe03e7361319d2a43edc17422f36b09";

const lpContracts = [
  "0x2F0596b989d79fda9b0A89F57D982ea02f8D978B",
  "0xc3ab35d3075430f52D2636d08D4f29bD39a18B65",
];
const lpAddresses = [
  "0xdD901faf9652D474b0A70263E13DA294990d49AE",
];

module.exports = {
  bsc: {
    staking: stakings(stakingContracts, boggedToken, "bsc"),
    pool2: pool2s(lpContracts, lpAddresses, "bsc"),
    tvl: (async) => ({}),
  },
};

'''
'''--- projects/bolide/index.js ---
const { staking } = require("../helper/staking")
const { pool2 } = require("../helper/pool2")
const { toUSDTBalances } = require("../helper/balances")
const sdk = require('@defillama/sdk')

const getTotalDepositABI = {
  'inputs': [],
  'name': 'getTotalDeposit',
  'outputs': [
    {
      'internalType': 'uint256',
      'name': '',
      'type': 'uint256'
    }
  ],
  'stateMutability': 'view',
  'type': 'function'
}

async function tvl(ts, _block, chainBlocks) {
  const value = (await sdk.api.abi.call({
    target: '0xf1f25A26499B023200B3f9A30a8eCEE87b031Ee1', 
    abi: getTotalDepositABI,
    block: chainBlocks.bsc,
    chain: 'bsc'
  })).output

  return toUSDTBalances(value, 1e-12)
}

module.exports = {
  bsc: {
    tvl,
    staking: staking('0x3782c47e62b13d579fe748946aef7142b45b2cf7', '0x766AFcf83Fd5eaf884B3d529b432CA27A6d84617', 'bsc'),
    pool2: pool2('0x3782c47e62b13d579fe748946aef7142b45b2cf7', '0x12c35ed2405bc70721584594723351bf5db6235c', 'bsc'),
  }
}
'''
'''--- projects/bombmoney/index.js ---
const sdk = require("@defillama/sdk");
const {pool2Exports} = require("../helper/pool2");
const { staking } = require("../helper/staking");

const token = "0x522348779DCb2911539e76A1042aA922F9C47Ee3";
const shares = "0x531780FAcE85306877D7e1F05d713D1B50a37F7A";
const shareRewardPool = "0x1083926054069AaD75d7238E9B809b0eF9d94e5B";
const masonry = "0xcAF7D9CE563E361A304FB6196499c1Dfd11b5991";

const pancakeLPs = [
    "0x1303246855b5B5EbC71F049Fdb607494e97218f8", // BSHARE-WBNB 
    "0x84392649eb0bC1c1532F2180E58Bae4E1dAbd8D6" // BOMB-BTCB 
]

module.exports = {
    bsc: {
        tvl: async () => ({}),
        staking: staking(masonry, shares, "bsc"),
        pool2: pool2Exports(shareRewardPool, pancakeLPs, "bsc", addr=>`bsc:${addr}`)
    }
}
'''
'''--- projects/bond-appetit.js ---
const retry = require('./helper/retry')
const { GraphQLClient, gql } = require('graphql-request')

async function fetch() {
    var endpoint = 'https://cache.bondappetit.io/api'
    var graphQLClient = new GraphQLClient(endpoint)

    var query = gql`
    {
        getTVL
    }
    `;

    var results = await retry(async bail => await graphQLClient.request(query))
    return parseFloat(results.getTVL)
}

module.exports = {
  fetch
}

'''
'''--- projects/boofinance/abi.json ---
{
  "tokenList": {
    "inputs": [],
    "name": "tokenList",
    "outputs": [
      { "internalType": "address[]", "name": "", "type": "address[]" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "tokenParameters": {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "tokenParameters",
    "outputs": [
      {
        "internalType": "contract IRewarder",
        "name": "rewarder",
        "type": "address"
      },
      {
        "internalType": "contract IBoofiStrategy",
        "name": "strategy",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastCumulativeReward",
        "type": "uint256"
      },
      { "internalType": "uint256", "name": "storedPrice", "type": "uint256" },
      {
        "internalType": "uint256",
        "name": "accZBOOFIPerShare",
        "type": "uint256"
      },
      { "internalType": "uint256", "name": "totalShares", "type": "uint256" },
      { "internalType": "uint256", "name": "totalTokens", "type": "uint256" },
      { "internalType": "uint128", "name": "multiplier", "type": "uint128" },
      { "internalType": "uint16", "name": "withdrawFeeBP", "type": "uint16" }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/boofinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const token0Abi = require("../helper/abis/token0.json");
const token1Abi = require("../helper/abis/token1.json");
const {unwrapUniswapLPs} = require("../helper/unwrapLPs");
const {staking} = require("../helper/staking");
const BigNumber = require("bignumber.js");

const boofi = "0xb00f1ad977a949a3ccc389ca1d1282a2946963b0";
const stakingAddress = "0x67712c62d1DEAEbDeF7401E59a9E34422e2Ea87c";
const hauntedHouse = "0xB178bD23876Dd9f8aA60E7FdB0A2209Fe2D7a9AB";

const transform = {
    "0x4f60a160d8c2dddaafe16fcc57566db84d674bd6":"harmony:0x72cb10c6bfa5624dd07ef608027e366bd690048f",
    "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e":"avax:0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664"
}

const joe = "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd";
const xjoe = "0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33";

async function calcTvl(block, chain, pool2) {
    let balances = {};
    const tokenList = (await sdk.api.abi.call({
        target: hauntedHouse, 
        abi: abi.tokenList,
        block,
        chain
    })).output;
    const tokenBalances = (await sdk.api.abi.multiCall({
        calls: tokenList.map(p => ({
            target: hauntedHouse,
            params: p
        })),
        abi: abi.tokenParameters,
        block,
        chain
    })).output;
    const symbols = (await sdk.api.abi.multiCall({
        calls: tokenList.map(p => ({
            target: p
        })),
        abi: "erc20:symbol",
        block,
        chain
    })).output;
    const token0Address = (await sdk.api.abi.multiCall({
        calls: tokenList.map(p => ({
            target: p,
        })),
        abi: token0Abi,
        block,
        chain
    })).output;
    const token1Address = (await sdk.api.abi.multiCall({
        calls: tokenList.map(p => ({
            target: p,
        })),
        abi: token1Abi,
        block,
        chain
    })).output;
    
    let lpPositions = [];
    for (let i = 0; i < tokenList.length; i++) {
        let token = tokenList[i].toLowerCase();
        let balance = tokenBalances[i].output.totalShares;
        let symbol = symbols[i].output;
        let token0 = token0Address[i].output;
        let token1 = token1Address[i].output;
        if (token === boofi) continue;
        if (pool2 && !symbol.endsWith("LP") && !symbol.endsWith("PGL")) continue;
        if (!symbol.endsWith("LP") && !symbol.endsWith("PGL")) {
            if (token === xjoe) {
                const joeBalance = (await sdk.api.erc20.balanceOf({
                    target: joe,
                    owner: xjoe,
                    block,
                    chain
                })).output;
                const xJoeSupply = (await sdk.api.erc20.totalSupply({
                    target: xjoe,
                    block,
                    chain
                })).output;
                sdk.util.sumSingleBalance(balances, `avax:${joe}`, BigNumber(balance).times(joeBalance/xJoeSupply).toFixed(0));
                continue;
            }
            if (transform[token] !== undefined) {
                token = transform[token];
                sdk.util.sumSingleBalance(balances, token, balance);
                continue;
            }
            sdk.util.sumSingleBalance(balances, `${chain}:${token}`, balance);
            continue;
        }
        token0 = token0.toLowerCase();
        token1 = token1.toLowerCase();
        if (pool2) {
            if (token0 !== boofi && token1 !== boofi) continue;
        }
        else if (!pool2) {
            if (token0 === boofi || token1 === boofi) continue;
        }
        lpPositions.push({
            token,
            balance
        });
    }
    await unwrapUniswapLPs(balances, lpPositions, block, chain, addr=>{
        addr = addr.toLowerCase();
        if (transform[addr] !== undefined) {
            return transform[addr];
        }
        return `avax:${addr}`;
    })
    return balances;
}

async function tvl(timestamp, block, chainBlocks) {
    return await calcTvl(chainBlocks.avax, "avax", false);
}

async function pool2(timestamp, block, chainBlocks) {
    return await calcTvl(chainBlocks.avax, "avax", true);
}

module.exports = {
    avalanche: {
        tvl,
        pool2,
        staking: staking(stakingAddress, boofi, "avax")
    }
}
'''
'''--- projects/borgswap/abi.json ---
{
  "masterFarmerPoolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accBSCXPerShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IBEP20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accLqdrPerShare",
        "type": "uint256"
      },
      {
        "internalType": "uint16",
        "name": "depositFeeBP",
        "type": "uint16"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "strategies": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "strategies",
    "outputs": [
      {
        "internalType": "contract IStrategy",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/borgswap/index.js ---
const abi = require("./abi.json");
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const {staking} = require("../helper/staking");

const MASTERCHEF = "0x4de6c2de6b9eBD974738686C9be7a31597146Ac6";
const MASTERCHEF2 = "0x92eEd89eeC81d992FF9135Ee451008E93b83dD86";
const MASTERCHEF3 = "0xC8FF977ee4e5EdA2D650C0e2706995a1DbB4926b";
const MASTERCHEF4 = "0xaDb6C60f0D62d6e7583e4b7B3697aAAd723d4a85";

const GPL = "0xdDa7DA47f3b53aA1FcB341650C614DaF554f3e57"
const EARS = "0x0EC4B89462557150302AC6e81270a081F2e3BD20"

const masterchefTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const transformAddress = await transformFantomAddress();

  for(const currentMasterchef of [MASTERCHEF, MASTERCHEF2, MASTERCHEF3, MASTERCHEF4]){
   await addFundsInMasterChef(
    balances,
    currentMasterchef,
    chainBlocks.fantom,
    "fantom",
    transformAddress,
    currentMasterchef === MASTERCHEF4?abi.masterFarmerPoolInfo:abi.poolInfo
   );
  }

  return balances;
};

module.exports = {
  methodology: 'MasterChef Contents Sum',
  fantom:{
    //staking:staking(GPL, EARS, 'fantom'),
    tvl: masterchefTvl,
    masterchef: masterchefTvl
  }
};

'''
'''--- projects/boringdao/contracts.json ---
{
  "ethereum": {
    "contracts": {
      "NBridge": "0xdBe43C732080271Fd7588aa5fe71bd07456D9173",
      "BoringChefSatellite": "0x204c87CDA5DAAC87b2Fc562bFb5371a0B066229C",
      "TwoWayV2": "0xecaD1ab3464ECcC7536af6aFeE414dF873495616",
      "tunnel": "0x258a1eb6537ae84cf612f06b557b6d53f49cc9a1"
    },
    "tokens": {
      "VEMP": "0xcFEB09C3c5F0f78aD72166D55f9e6E9A60e96eEC",
      "xVEMP": "0x4a4e2d4859af854d2a3fc6df295843d21e70cc78",
      "FIN": "0x054f76beed60ab6dbeb23502178c52d6c5debe40",
      "USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7",
      "AMY": "0xb6225104d9434CC148570cDDEEf19B2e46dA350D",
      "AAVE": "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
      "CRV": "0xD533a949740bb3306d119CC777fa900bA034cd52",
      "USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      "FIRE": "0x0f0Dd5E2c0e0c4A41F8908D73D36B8D142F6745a",
      "iZi": "0x9ad37205d608b8b219e6a2573f922094cec5c200",
      "ETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      "METIS": "0x9E32b13ce7f2E80A01932B42553652E053D6ed8e",
      "PBTC": "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
      "AAC": "0xe75ad3aAB14E4B0dF8c5da4286608DaBb21Bd864",
      "NODE": "0x0C3eF32f802967DB75B9D49fE1e76620151cCB81"
    }
  },
  "optimism": {
    "contracts": {
      "TwoWayV2": "0x29414EC76d79Ff238E5E773322799d1c7Ca2443F"
    },
    "tokens": {
      "USDT": "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
      "USDC": "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
      "ETH": "0x4200000000000000000000000000000000000006",
      "PBTC": "0x68f180fcCe6836688e9084f035309E29Bf0A2095"
    }
  },
  "bsc": {
    "contracts": {
      "NBridge": "0xe7b388d44fA9069385E174efe6f10616B149Fe86",
      "BoringChefUsdtLP": "0xa056c100cEB4111899916Cf2d361152eE9147aDF",
      "TwoWayV2": "0x0075Ac0C662a5B655060d1519fF739D834078705"
    },
    "tokens": {
      "VEMP": "0xeDF3ce4Dd6725650a8e9398e5C6398D061Fa7955",
      "xVEMP": "0xAe9a0E6Bd6CB21cF36B773d47923980b410D3C85",
      "USDT": "0x55d398326f99059ff775485246999027b3197955",
      "WSG": "0xA58950F05FeA2277d2608748412bf9F802eA4901",
      "USDC": "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
      "lowb": "0x843d4a358471547f51534e3e51fae91cb4dc3f28",
      "LOL": "0x55E3f23B563769426f8Aa4059e9977689c74B47E",
      "FIRE": "0x0f0Dd5E2c0e0c4A41F8908D73D36B8D142F6745a",
      "ETH": "0x2170Ed0880ac9A755fd29B2688956BD959F933F8",
      "PBTC": "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c"
    }
  },
  "polygon": {
    "contracts": {
      "NBridge": "0x64E4E7840bC20959c8BA984Db82fA0132D9b04dD",
      "BoringChef": "0x5304990549f9f6e24C8d726a153c62dbD7F3333a",
      "BoringChefUsdtLP": "0x9159b63bFD1566ab4c99Ee1Ff21575C86d2cEBB9",
      "TwoWayV2": "0x6dc551088AFAf828b95a9c9Ad590AeFE797c8e87",
      "TwoWayChef": "0xB225cC2207FECC82806042cEB386eF2b23E2464c",
      "StakingRewardForChefoUSDT": "0x421A538234aF050c77eF735b23A1Db03243B0e4b",
      "StakingRewardForChefoUSDC": "0xBb5eA9b628f8A93c653c0eaC986238407930059d",
      "StakingRewardForChefoLOL": "0x70dfE627c3b04FDF8E8C9572FcEC9E098FeD552d",
      "StakingRewardForChefoiZi": "0x091C23C213945b1F96e4BA660bdee1FD61663d11",
      "StakingRewardForChefoFIN": "0x6B906d17301447117C83F12DEc183331Ac3BCaa5",
      "StakingRewardForChefoMETIS": "0xc5e8228b910722C6B7aE77221dd96DC134B9C861",
      "StakingRewardForChefoETH": "0x775E38077FDbdAfCB777215ccfB41cf8FC949019"
    },
    "tokens": {
      "USDT": "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
      "oUSDT": "0x413cfE1C41F98879365D665CACB7E79a60001fEE",
      "USDC": "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
      "oUSDC": "0x8DE93f998b6b0ddA780Ee12B97dde1F2fADd3B1d",
      "oLOL": "0x0D9ceFE09299C8c3Cbe1F2706fbcEdBc35d73052",
      "iZi": "0x60d01ec2d5e98ac51c8b4cf84dfcce98d527c747",
      "oiZi": "0x79904eC9De1FCCF7ca50fE3f8430e922d53e07e6",
      "FIN": "0x576c990a8a3e7217122e9973b2230a3be9678e94",
      "oFIN": "0x4D98192A8A078D0937c8FCa144C07e741364BdcA",
      "ETH": "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
      "oMETIS": "0x746158B125447C909291cf3B271C929D156cBAd2",
      "oETH": "0x0caD6ef3383C4349c68f072076BCDE7B7623576B",
      "PBTC": "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
      "INS": "0xb988Bd378A0754957d5D9471C96E0F8051645a26"
    }
  },
  "fantom": {
    "contracts": {
      "NBridge": "0x77B3aa18D89ea24e4AF7BB9BC221D49FD5534c19",
      "BoringChef": "0x1f5330323b12c62eB1258FA227D88C8E63fDb855",
      "BoringChefUsdtLP": "0x6D6D851bE4Ae838f32B0694a2561FDe3a18765e6",
      "TwoWayV2": "0x66D6A03394dC9D155F3704e14C6c0F03076B40D1"
    },
    "tokens": {
      "USDT": "0x049d68029688eabf473097a2fc38ef61633a3c7a",
      "USDC": "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
      "ETH": "0x74b23882a30290451A17c44f4F05243b6b58C76d"
    }
  },
  "boba": {
    "contracts": {
      "NBridge": "0x225247882FD7396c62E29707DA0890151208161a",
      "BoringChefSec": "0xB238a595e9797E009eFD5f938C9918181662066C"
    },
    "tokens": {
      "USDT": "0x5DE1677344D3Cb0D7D465c10b72A8f60699C062d",
      "USDC": "0x66a2A913e447d6b4BF33EFbec43aAeF87890FBbc"
    }
  },
  "metis": {
    "contracts": {
      "NBridge": "0xD01a5051253007ae0b7123b50410E3B5A3f6cF95",
      "TwoWayV2": "0x57E05346A576A3f75972aC0E7c9d9f46765B346E"
    },
    "tokens": {
      "CRV": "0x87DD4a7Ad23B95cD9fF9C26B5cF325905CaF8663",
      "AAVE": "0x68D97B7A961a5239B9F911DA8dEb57F6eF6e5e28",
      "WSG": "0x4F497F9D85A6fE135fFca99f0f253919fE827211",
      "USDT": "0xbB06DCA3AE6887fAbF931640f67cab3e3a16F4dC",
      "USDC": "0xEA32A96608495e54156Ae48931A7c20f0dcc1a21",
      "lowb": "0xd5B59f9F35F9a5bE75E7357798BF15A4E958B6B2",
      "LOL": "0x55E3f23B563769426f8Aa4059e9977689c74B47E",
      "ETH": "0x420000000000000000000000000000000000000A",
      "METIS": "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000"
    }
  },
  "arbitrum": {
    "contracts": {
      "TwoWayV2": "0x2e220E3ab85fC4A46F770A34eF2CdDc8074E4689",
      "BoringChefSec": "0x216f332D17145871D1d5ff5fEB4b08513Ef7Cc21",
      "NBridge": "0x9d8bDAa1dDE16da55c86cCaF12C81647ff9858B8"
    },
    "tokens": {
      "USDT": "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
      "AMY": "0x8fbd420956fdd301f4493500fd0bcaaa80f2389c",
      "USDC": "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
      "ETH": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
      "PBTC": "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f"
    }
  },
  "avax": {
    "contracts": {
      "NBridge": "0x2e220E3ab85fC4A46F770A34eF2CdDc8074E4689",
      "BoringChef": "0x61CF453D7930ECf145f3Dd29fCE4d9c15F9405c3",
      "BoringChefUsdtLP": "0xAf9f062613dF193dCF4d4008ACC3bb9280c87323",
      "TwoWayV2": "0x12f3a5af0a82af48af89FA5BAcf6307e1b226903"
    },
    "tokens": {
      "USDT": "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
      "USDC": "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
      "ETH": "0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB",
      "PBTC": "0x50b7545627a5162F82A992c33b87aDc75187B218"
    }
  },
  "harmony": {
    "contracts": {
      "NBridge": "0x216f332D17145871D1d5ff5fEB4b08513Ef7Cc21",
      "TwoWayV2": "0x7F942c3f0F61dE5133447B8A4974969EA36a7f19",
      "BoringChef": "0xB98863f0a0cFE367496bFa393dA4D408Bee0A5Bf",
      "BoringChefUsdtLP": "0x39c412fa81dAe9673A3E00e83B2F58a08DD8Fbc9"
    },
    "tokens": {
      "USDT": "0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f",
      "USDC": "0x985458e523db3d53125813ed68c274899e9dfab4",
      "ONE": "0x323B6b60B286f69D2cEf2277A71038FbDfd18F86",
      "ETH": "0x6983d1e6def3690c4d616b13597a09e6193ea013"
    }
  },
  "okexchain": {
    "contracts": {
      "NBridge": "0xb9A9587eee2Da928f72A5846440E81C7426d595f",
      "BoringChef": "0xef002868F3Ee02a20ac6d7fd8381A83a8C127005",
      "BoringChefUsdtLP": "0xAd2F796199ff714AfE4f6716C50fF6dc431322C8",
      "TwoWayV2": "0xf82B64169f3F43706F423c3246a10D190D12B576"
    },
    "tokens": {
      "FIN": "0x8d3573f24c0aa3819a2f5b02b2985dd82b487715",
      "WrapFIN": "0x2B21237BA30deF78EC551a10C99d656F90Eb10fC",
      "USDT": "0x382bB369d343125BfB2117af9c149795C6C65C50",
      "VEMP": "0x2c9a1d0e1226939edb7bbb68c43a080c28743c5c",
      "xVEMP": "0x861afdBC2F3DF53F07d397EacfA443683653cA99",
      "USDC": "0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85",
      "ETH": "0xEF71CA2EE68F45B9Ad6F72fbdb33d707b872315C",
      "PBTC": "0x54e4622dc504176b3bb432dccaf504569699a7ff"
    }
  },
  "xdai": {
    "contracts": {
      "NBridge": "0xE3B59FD01c0155A98146a6E0Beb8376B751363fc",
      "BoringChef": "0x560EB8c4B113ce38da680DafA3388Ffbeb61B14D",
      "BoringChefUsdtLP": "0x0Bf101ab5CC8C6Be93D9fb6742e1e4d724aFa414",
      "TwoWayV2": "0x805675c662CF99B0156C8D1D76EAB86a830d9E8D"
    },
    "tokens": {
      "USDT": "0x4ECaBa5870353805a9F068101A40E0f32ed605C6",
      "USDC": "0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83",
      "ETH": "0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1"
    }
  },
  "heco": {
    "contracts": {
      "NBridge": "0xE3B59FD01c0155A98146a6E0Beb8376B751363fc",
      "BoringChef": "0x560EB8c4B113ce38da680DafA3388Ffbeb61B14D",
      "BoringChefUsdtLP": "0x0Bf101ab5CC8C6Be93D9fb6742e1e4d724aFa414",
      "TwoWayV2": "0x66D6A03394dC9D155F3704e14C6c0F03076B40D1"
    },
    "tokens": {
      "USDT": "0xa71edc38d189767582c38a3145b5873052c3e47a",
      "USDC": "0x9362bbef4b8313a8aa9f0c9808b80577aa26b73b",
      "ETH": "0x64FF637fB478863B7468bc97D30a5bF3A428a1fD",
      "HBTC": "0x66a79D23E58475D2738179Ca52cd0b41d73f0BEa"
    }
  },
  "oasis": {
    "contracts": {
      "NBridge": "0x87DD4a7Ad23B95cD9fF9C26B5cF325905CaF8663"
    },
    "tokens": {}
  },
  "kcc": {
    "contracts": {
      "TwoWayV2": "0x87DD4a7Ad23B95cD9fF9C26B5cF325905CaF8663"
    },
    "tokens": {
      "USDT": "0x0039f574eE5cC39bdD162E9A88e3EB1f111bAF48",
      "USDC": "0x980a5AfEf3D17aD98635F6C5aebCBAedEd3c3430",
      "ETH": "0xf55aF137A98607F7ED2eFEfA4cd2DfE70E4253b1",
      "PBTC": "0xfa93c12cd345c658bc4644d1d4e1b9615952258c"
    }
  },
  "aurora": {
    "contracts": {
      "NBridge": "0xB98863f0a0cFE367496bFa393dA4D408Bee0A5Bf",
      "TwoWayV2": "0x68D97B7A961a5239B9F911DA8dEb57F6eF6e5e28"
    },
    "tokens": {
      "USDC": "0xB12BFcA5A55806AaF64E99521918A4bf0fC40802",
      "USDT": "0x4988a896b1227218e4A686fdE5EabdcAbd91571f",
      "ONE": "0x731203A6E33001d76AF6da49096fC8753b9E4932",
      "ETH": "0xC9BdeEd33CD01541e1eeD10f90519d2C06Fe3feB"
    }
  },
  "iotex": {
    "contracts": {
      "TwoWayV2": "0x87DD4a7Ad23B95cD9fF9C26B5cF325905CaF8663"
    },
    "tokens": {
      "USDC": "0x3b2bf2b523f54c4e454f08aa286d03115aff326c",
      "USDT": "0x6fbcdc1169b5130c59e72e51ed68a84841c98cd1"
    }
  }
}
'''
'''--- projects/boringdao/index.js ---
const { getBalance } = require("../helper/utils");
const { sumTokens } = require("../helper/unwrapLPs")
const contracts = require("./contracts.json");
const sdk = require("@defillama/sdk");

function chainTvl(chain) {
  const exports = {
    tvl: async (timestamp, _, { [chain]: block }) => {
      const toa = []
      const holders = Object.values(contracts[chain].contracts)
      const tokens = Object.values(contracts[chain].tokens)
      holders.forEach(o => tokens.forEach(t => toa.push([t, o])))
      return sumTokens({}, toa, block, chain)
    },
  }
  if (chain === 'ethereum')
    exports.staking = async (_, block) => {
      return sumTokens({}, [
        ["0xbc19712feb3a26080ebf6f2f7849b417fdd792ca", "0x204c87CDA5DAAC87b2Fc562bFb5371a0B066229C"],
      ], block)
    }
  return exports
};

const chainTVLObject = Object.keys(contracts)
  .reduce((agg, chain) => ({ ...agg, [chain]: chainTvl(chain) }), {});

module.exports = {
  ...chainTVLObject,
  timetravel: false,
  bitcoin: {
    tvl: async () => {
      return {
        bitcoin: await getBalance('bitcoin', '33ZibwpiZe4bM5pwpAdQNqqs2RthLkpJer')
      }
    }
  },
  litecoin: {
    tvl: async (_, block) => {
      return {
        litecoin: (await sdk.api.erc20.totalSupply({ target: '0x07C44B5Ac257C2255AA0933112c3b75A6BFf3Cb1', block })).output / 1e18
      }
    }
  },
  doge: {
    tvl: async (_, block) => {
      return {
        dogecoin: (await sdk.api.erc20.totalSupply({ target: '0x9c306A78b1a904e83115c05Ac67c1Ef07C653651', block })).output / 1e18
      }
    }
  }
};
'''
'''--- projects/boss-swap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

module.exports={
    harmony: {
        tvl:calculateUsdUniTvl("0x7f107365E6Ef1F8824C724EA6aF7654AFB742963", "harmony", "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a", [], "harmony")
    }
}
'''
'''--- projects/boujefinance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const chef = "0x89dcd1DC698Ad6A422ad505eFE66261A4320D8B5"
const bouje = "0x37F70aa9fEfc8971117BD53A1Ddc2372aa7Eec41"

module.exports = {
  ...masterChefExports(chef, "fantom", bouje),
  methodology: "TVL includes all farms in MasterChef contract",
}
'''
'''--- projects/bourbon-dao/index.js ---
const {ohmTvl} = require("../helper/ohm");

const whiskey = "0xce1ad4e2810e413e2e3684decc58a0bd01c907d9";
const stakingContract = "0x5e398c5da5353182aae7410fb824a1578fc518cb";

const treasury = "0x950d8c342bc6e0bcf9c1deb87d039947f35b3eb9";
const treasuryTokens = [
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], // BUSD
    ["0x55d398326f99059ff775485246999027b3197955", false], // USDT
    ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false], // WBNB
    ["0x96b6d5482313eecc031afeb2fb32da2ba7439ba2", true], // WHISKEY-BUSD CAKELP
]

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "bsc", stakingContract, whiskey, undefined, undefined, false)
}
'''
'''--- projects/bprotocol/abi.json ---
{
  "cdpTvl": {
    "constant": true,
    "inputs": [
      {
        "internalType": "contract BCdpManagerLike",
        "name": "man",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "cdp",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "ilk",
        "type": "bytes32"
      }
    ],
    "name": "cdpTvl",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "cdpi": {
    "constant": true,
    "inputs": [
      {
        "internalType": "contract BCdpManagerLike",
        "name": "man",
        "type": "address"
      }
    ],
    "name": "cdpi",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "avatarLength": {
    "constant": true,
    "inputs": [],
    "name": "avatarLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6a7d9ff9"
  },
  "avatars": {
    "constant": true,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "avatars",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x834d5fac"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOfUnderlying": {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "balanceOfUnderlying",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "bamms" : {
    "inputs":[{"internalType":"uint256","name":"","type":"uint256"}],
    "name":"bamms",
    "outputs":[{"internalType":"address","name":"","type":"address"}],
    "stateMutability":"view","type":"function"
  },
  "getCompoundedLUSDDeposit" : {
    "inputs":[{"internalType":"address","name":"_depositor","type":"address"}],
    "name":"getCompoundedLUSDDeposit",
    "outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
    "stateMutability":"view",
    "type":"function"
  }

}

'''
'''--- projects/bprotocol/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const sdk = require('@defillama/sdk');
  const abi = require('./abi.json');
  const BigNumber = require("bignumber.js");

/*==================================================
  Settings
  ==================================================*/

  const bTvlAddress = '0x60312e01A2ACd1Dac68838C949c1D20C609B20CF';
  const bcdpmanagerAddress = '0x3f30c2381CD8B917Dd96EB2f1A4F96D91324BBed';
  const ethIlk = '0x4554482d41000000000000000000000000000000000000000000000000000000';
  const mFirstBlock = 11257606
  const cFirstBlock = 11935020
  const lFirstBlock = 12934992
  const registryAddress = "0xbf698df5591caf546a7e087f5806e216afed666a";
  const comptrollerAddress = "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B";
  const bKeeperAddress = "0xeaE019ef845A4Ffdb8829210De5D30aC6FbB5371";
  const stabilityPoolAddress = "0x66017D22b0f8556afDd19FC67041899Eb65a21bb";

  const usdcEth = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  const usdcFantom = "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75"
  const usdcArbitrum = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"
  
  const daiEth = "0x6b175474e89094c44da98b954eedeac495271d0f"
  const daiFantom = "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e"
  
  const usdtEth = "0xdac17f958d2ee523a2206206994597c13d831ec7"
  const usdtArbitrum = "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"

  const fraxEth = "0x853d955aCEf822Db058eb8505911ED77F175b99e"
  
  const usdcFantomBAMM = "0xEDC7905a491fF335685e2F2F1552541705138A3D"
  const daiFantomBAMM = "0x6d62d6Af9b82CDfA3A7d16601DDbCF8970634d22"
  const usdcArbitrumBAMM = "0x04208f296039f482810B550ae0d68c3E1A5EB719"
  const usdtArbitrumBAMM = "0x24099000AE45558Ce4D049ad46DDaaf71429b168"

  const hDAIPolygon = "0xE4e43864ea18d5E5211352a4B810383460aB7fcC"
  const hUSDCPolygon = "0x607312a5C671D0C511998171e634DE32156e69d0"
  const hUSDTPolygon = "0x103f2CA2148B863942397dbc50a425cc4f4E9A27"
  const hFRAXPolygon = "0x2c7a9d9919f042C4C120199c69e126124d09BE7c"   
  
  const bammDAIPolygon = "0x998Bf304Ce9Cb215F484aA39d1177b8210078f49"
  const bammUSDCPolygon = "0x0F0dD66D2d6c1f3b140037018958164c6AB80d56"
  const bammUSDTPolygon = "0x1EcF1b0DE9b4c2D01554062eA2faB84b1917B41d"
  const bammFRAXPolygon = "0x2DA13538056aFf0bFC81d3A4c6364B0a7e0f9feb"

  const polygonHTokens = [hDAIPolygon, hUSDCPolygon, hUSDTPolygon, hFRAXPolygon]
  const polygonBamms = [bammDAIPolygon, bammUSDCPolygon, bammUSDTPolygon, bammFRAXPolygon]
  const polygonEthUnderlying = [daiEth, usdcEth, usdtEth, fraxEth]

/*==================================================
  TVL
  ==================================================*/

  async function compoundTvl(timestamp, block) {
    if (block < cFirstBlock) return { '0x0000000000000000000000000000000000000000': '0' };

    // number of accounts
    const { output: avatarLength } = await sdk.api.abi.call(
      {
        block,
        target: registryAddress,
        params: [],
        abi: abi["avatarLength"]
      }
    )

    // list of account id's
    const avatarIds = Array.from({ length: Number(avatarLength) }, (_, i) => i)

    // list of account addresses
    const avatarsAdresess = (await sdk.api.abi.multiCall({
      abi: abi["avatars"],
      calls: avatarIds.map((id, ) => ({
        target: registryAddress,
        params: [id]
      })),
      block,
    })).output.map(({ output }) => output);

    // all of Compound's supply & borrow assets adresses
    const { output: cTokens } = await sdk.api.abi.call(
      {
        block,
        target: comptrollerAddress,
        params: [],
        abi: abi["getAllMarkets"]
      }
    )

    const balances = {}

    // for each of Compound's cTokens get all of our users accounts balance and the underlying token address
    await Promise.all(cTokens.map(async (cTokenAddress) => {
      try {
        // get the underlying token address
        const isCEth = cTokenAddress.toLowerCase() === "0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5"
        const { output: token } = isCEth
          ? { output: '0x0000000000000000000000000000000000000000' } // ETH has no underlying asset on Compound
          : await sdk.api.abi.call(
            {
              block,
              target: cTokenAddress,
              params: [],
              abi: abi["underlying"]
            }
          )

        // making a call to get the asset balance for each of our users
        const calls = []

        avatarsAdresess.forEach(avatar => {
          calls.push({
            target: cTokenAddress,
            params: [avatar]
          })
        })

        const underlyingBalances = (await sdk.api.abi.multiCall({
          abi: abi["balanceOfUnderlying"],
          calls,
          block,
        })).output.map(({ output }) => output);

        // accumilating all our users balances to calculate the TVL for this indevidual asset
        const sumTotal = underlyingBalances.reduce((acc, val) => {
          return (new BigNumber(acc).plus(new BigNumber(val))).toString(10)
        }, "0")

        balances[token] = (new BigNumber(balances[token] || "0").plus(new BigNumber(sumTotal)) ).toString(10)
      } catch (err) {
        console.error(err)
      }
    }))
    return balances
  }

  async function makerTvl(timestamp, block) {
    if (block < mFirstBlock) return { '0x0000000000000000000000000000000000000000': '0' };

    const cdpiRes = await sdk.api.abi.call(
      {
        block,
        target: bTvlAddress,
        params: [bcdpmanagerAddress],
        abi: abi["cdpi"]
      });

    const maxCdp = Number(cdpiRes.output);
    const cdps = Array.from({ length: maxCdp }, (_, i) => i + 1)

    const smallCdps = Array.from({ length: 20 }, (_, i) => i + 1)
    const ethBalances = (await sdk.api.abi.multiCall({
      abi: abi["cdpTvl"],
      calls: cdps.map((cdp, ) => ({
        target: bTvlAddress,
        params: [bcdpmanagerAddress, cdp, ethIlk]
      })),
      block,
    })).output.map(value => value.output);

    let totalBalance = new BigNumber(0);
    ethBalances.forEach(balance => totalBalance = totalBalance.plus(new BigNumber(balance)));
    const balances = { '0x0000000000000000000000000000000000000000': totalBalance.toString(10) };

    return balances
  }

  async function liquityTvl(timestamp, block) {
    if (block < lFirstBlock) return { '0x5f98805A4E8be255a32880FDeC7F6728C6568bA0': '0' };

    let totalBalance = new BigNumber(0);

    for(let i = 0 ; ; i++) {
      try {
        const bamm = await sdk.api.abi.call(
          {
            block,
            target: bKeeperAddress,
            params: [i],
            abi: abi["bamms"]
          });
        const balance = await sdk.api.abi.call(
          {
            block,
            target: stabilityPoolAddress,
            params: [bamm.output],
            abi: abi["getCompoundedLUSDDeposit"]
          });

          totalBalance = totalBalance.plus(new BigNumber(balance.output));
      }
      catch {
        break;
      }
    }

    // all balance is lusd
    return {'0x5f98805A4E8be255a32880FDeC7F6728C6568bA0' : totalBalance.toString(10)}
  }

  async function tvlEth(timestamp, block) {
    const [cTvl, mTvl, lTvl] = await Promise.all([compoundTvl(timestamp, block), makerTvl(timestamp, block), liquityTvl(timestamp, block)])
    // combine balances for Maker and Compound B.Protocol's TVL
    const allLendingPlatformBalances = {}
    // all assets in B.Protocol
    const uniq = arry => [... new Set(arry)]
    uniq(Object.keys(cTvl).concat(Object.keys(mTvl)).concat(Object.keys(lTvl))).forEach(asset => {
      allLendingPlatformBalances[asset] = new BigNumber(cTvl[asset] || "0").plus(new BigNumber(mTvl[asset] || "0")).plus(new BigNumber(lTvl[asset] || "0")).toString(10)
    })

    return allLendingPlatformBalances;
  }

  async function tvlFantom(unixTimestamp, ethBlock, chainBlocks) {
    const block = chainBlocks["fantom"]

    const balances = {}

    balances[usdcEth] = (
      await sdk.api.erc20.balanceOf({
        target: usdcFantom,
        owner: usdcFantomBAMM,
        block: block,
        chain: "fantom",
      })
    ).output;

    balances[daiEth] = (
      await sdk.api.erc20.balanceOf({
        target: daiFantom,
        owner: daiFantomBAMM,
        block: block,
        chain: "fantom",
      })
    ).output;    

    return balances
  }

  async function tvlArbitrum(unixTimestamp, ethBlock, chainBlocks) {
    const block = chainBlocks["arbitrum"]

    const balances = {}

    balances[usdcEth] = (
      await sdk.api.erc20.balanceOf({
        target: usdcArbitrum,
        owner: usdcArbitrumBAMM,
        block: block,
        chain: "arbitrum",
      })
    ).output;

    balances[usdtEth] = (
      await sdk.api.erc20.balanceOf({
        target: usdtArbitrum,
        owner: usdtArbitrumBAMM,
        block: block,
        chain: "arbitrum",
      })
    ).output;    

    return balances
  }  

  async function tvlPolygon(unixTimestamp, ethBlock, chainBlocks) {
    const block = chainBlocks["polygon"]

    const balances = {}

    for(let i = 0 ; i < polygonBamms.length ; i++) {
      const balance = await sdk.api.abi.call(
        {
          block,
          target: polygonHTokens[i],
          params: [polygonBamms[i]],
          abi: abi["balanceOfUnderlying"],
          chain: "polygon"
        });
        
      balances[polygonEthUnderlying[i]] = balance.output
    }

    return balances
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    ethereum: {"tvl": tvlEth},
    fantom: {"tvl" : tvlFantom},
    arbitrum: {"tvl" : tvlArbitrum},
    polygon: {"tvl": tvlPolygon}
  };

'''
'''--- projects/brahmafi/batcher.json ---
{
  "pendingDeposit": {
    "inputs": [],
    "name": "pendingDeposit",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/brahmafi/helper.js ---
const sdk = require("@defillama/sdk");
const vaultAbi = require("./vault.json");
const batcherAbi = require("./batcher.json");
const teAbi = require("./tradeExecutor.json");

const vaults = [
  {
    address: "0xAa0508FcD0352B206F558b2B817dcC1F0cc3F401",
    batcher: "0x47c84A87A2a972769cc5DeDa28118617E3A48F8C",
  },
  {
    address: "0x1C4ceb52ab54a35F9d03FcC156a7c57F965e081e",
    batcher: "0x1b6BF7Ab4163f9a7C1D4eCB36299525048083B5e",
  },
  {
    address: "0x3c4Fe0db16c9b521480c43856ba3196A9fa50E08",
    batcher: "0xa67feFA6657e9aa3e4ee6EF28531641dAFBB8cAf",
  },
];

const getTVLData = async (block) => {
  const vaultCalls = vaults.map((v) => ({ target: v.address }));
  const batcherCalls = vaults.map((v) => ({ target: v.batcher }));

  const [totalSupplies, pendingDeposits, tokens] = await Promise.all([
    sdk.api.abi.multiCall({
      block,
      calls: vaultCalls,
      abi: "erc20:totalSupply",
    }),
    sdk.api.abi.multiCall({
      block,
      calls: batcherCalls,
      abi: batcherAbi.pendingDeposit,
    }),
    sdk.api.abi.multiCall({
      block,
      calls: vaultCalls,
      abi: vaultAbi.wantToken,
    }),
  ]).then((o) => o.map((it) => it.output));

  return { totalSupplies, pendingDeposits, tokens };
};

const getVaultL1Funds = async (vault, wantToken, block) => {
  const executors = await getExecutorsForVault(vault, block);
  const positionCalls = executors.map((e) => ({ target: e }));
  const balanceCalls = executors.map((e) => ({ target: wantToken, params: e }));

  const [_wantTokenBalances, _positionValues] = await Promise.all([
    sdk.api.abi.multiCall({
      block,
      calls: balanceCalls,
      abi: "erc20:balanceOf",
    }),
    sdk.api.abi.multiCall({
      block,
      calls: positionCalls,
      abi: teAbi.positionInWantToken,
    }),
  ]).then((o) => o.map((it) => it.output));

  const wantTokenBalances = _wantTokenBalances.map((it) => +it.output);
  const positionValues = _positionValues.map((it) => +it.output.posValue);

  let totalExecutorFunds = 0

  for (const [index] of executors.entries()) {
    totalExecutorFunds += wantTokenBalances[index] + positionValues[index]
  }

  const vaultBalance = await sdk.api.abi.call({
    block,
    target: wantToken,
    params: vault,
    abi: "erc20:balanceOf",
  });

  return totalExecutorFunds + +vaultBalance.output;
};

const getExecutorsForVault = async (vault, block) => {
  var index = 0;
  let flag = true;

  const executors = [];

  while (flag) {
    try {
      const { output } = await sdk.api.abi.call({
        block,
        target: vault,
        abi: vaultAbi.executorByIndex,
        params: index,
      });

      executors.push(output);
    } catch (e) {
      flag = false;
    }

    index++;
  }

  return executors;
};

module.exports = {
  vaults,
  getTVLData,
  getVaultL1Funds,
};

'''
'''--- projects/brahmafi/index.js ---
const { vaults, getTVLData, getVaultL1Funds } = require("./helper");
const MAX_BPS = 1e3;
const sdk = require('@defillama/sdk')

const tvl = async (_, block) => {
  const { pendingDeposits, tokens, totalSupplies } = await getTVLData(block);

  const balances = {};

  for (const [idx, { address }] of vaults.entries()) {
    const wantToken = tokens[idx].output;
    const totalSupply = totalSupplies[idx].output;

    const totalFunds = await getVaultL1Funds(address, wantToken, block);
    const sharePrice = totalFunds * MAX_BPS / totalSupply;

    const value = totalSupply * sharePrice / MAX_BPS + +pendingDeposits[idx].output
    console.log(value, value.toFixed(0))
    sdk.util.sumSingleBalance(balances, wantToken, value.toFixed(0))
  }

  return balances
};

module.exports = {
  methodology:
    "TVL is the total supply of our vault tokens, multiplied by their corresponding share price. The share price is calculated based on the value of positions taken by vaults both on ethereum and optimism networks",
  ethereum: {
    tvl,
  },
};

'''
'''--- projects/brahmafi/tradeExecutor.json ---
{
  "positionInWantToken": {
    "inputs": [],
    "name": "positionInWantToken",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "posValue",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastUpdatedBlock",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/brahmafi/vault.json ---
{
  "wantToken": {
    "inputs": [],
    "name": "wantToken",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalVaultFunds": {
    "inputs": [],
    "name": "totalVaultFunds",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "executorByIndex": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_index",
        "type": "uint256"
      }
    ],
    "name": "executorByIndex",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/bridge-mutual/abi.json ---
{
  "balanceOf": {
    "constant": true,
    "inputs": [{ "name": "_owner", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "name": "balance", "type": "uint256" }],
    "type": "function"
  },
  "count": {
    "inputs": [],
    "name": "count",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "list": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "offset",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "limit",
        "type": "uint256"
      }
    ],
    "name": "list",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "_policyBooksArr",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getShieldTokenAddress": {
    "inputs": [
      {
        "internalType": "address",
        "name": "_policyBook",
        "type": "address"
      }
    ],
    "name": "getShieldTokenAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "virtualUsdtAccumulatedBalance": {
    "inputs": [],
    "name": "virtualUsdtAccumulatedBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/bridge-mutual/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const chain = "ethereum";

// addresses pools
const CapitalPool = "0x426f72ab027da5f5a462d377a5eb057f63082b02";
const BMIStaking = "0x55978a6f6a4cfa00d5a8b442e93e42c025d0890c";
const ClaimVoting = "0x81d73999fabec7e8355d76d1010afbe3068f08fa";
// addresses tokens
const usdt = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const bmi = "0x725c263e32c72ddc3a19bea12c5a0479a81ee688";
// addresses getters
const PolicyBookRegistry = "0xff13c3d2c7931e86e13c993a8cb02d68848f9613";
const ShieldMining = "0x6d6fCf279a63129797def89dBA82a65b3386497e";

// =================== GET LIST OF POLICY BOOKS =================== //
async function getPolicyBookList(timestamp, block) {
  const countPolicyBooks = (
    await sdk.api.abi.call({
      target: PolicyBookRegistry,
      abi: abi["count"],
      chain: chain,
      block: block,
    })
  ).output;
  const listPolicyBooks = (
    await sdk.api.abi.call({
      target: PolicyBookRegistry,
      params: [0, countPolicyBooks],
      abi: abi["list"],
      chain: chain,
      block: block,
    })
  ).output;
  return listPolicyBooks;
}

async function tvl(timestamp, block) {
  let balances = {};
  const listPolicyBooks = await getPolicyBookList(timestamp, block);

  // =================== GET USDT BALANCES =================== //
  const vusdtBalances = (
    await sdk.api.abi.call({
      target: CapitalPool,
      abi: abi["virtualUsdtAccumulatedBalance"],
      chain: chain,
      block: block,
    })
  ).output;
  sdk.util.sumSingleBalance(balances, usdt, vusdtBalances);

  // =================== GET TOKENX BALANCES =================== //
  for (let PolicyBook of listPolicyBooks) {
    const tokenX = (
      await sdk.api.abi.call({
        target: ShieldMining,
        params: PolicyBook,
        abi: abi["getShieldTokenAddress"],
        chain: chain,
        block: block,
      })
    ).output;
    if (tokenX != "0x0000000000000000000000000000000000000000") {
      const tokenXBalance = await sdk.api.abi.call({
        target: tokenX,
        params: PolicyBook,
        abi: abi["balanceOf"],
        chain: chain,
        block: block,
      });
      sdk.util.sumSingleBalance(balances, tokenX, tokenXBalance.output);
    }
  }

  // ============================================================ //
  return balances;
}

async function staking(timestamp, block) {
  let balances = {};

  // =================== GET BMI BALANCES =================== //
  const bmiPools = [BMIStaking, ClaimVoting];

  const bmiBalances = await sdk.api.abi.multiCall({
    target: bmi,
    calls: bmiPools.map((bmiPool) => ({
      params: bmiPool,
    })),
    abi: abi["balanceOf"],
    chain: chain,
    block: block,
  });
  sdk.util.sumMultiBalanceOf(balances, bmiBalances);

  return balances;
}

module.exports = {
  ethereum: {
    tvl: tvl,
    staking: staking,
  },
};

'''
'''--- projects/bright-union/abi.json ---
{
  "totalTVL": {
    "inputs": [],
    "name": "totalTVL",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "_tvl",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  }
}

'''
'''--- projects/bright-union/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const {pool2s} = require('../helper/pool2')

// BRI
const BrightRiskIndex = "0xa4b032895BcB6B11ec7d21380f557919D448FD04";
// Staking
const BRIGHT = "0xbeab712832112bd7664226db7cd025b153d3af55";
const BrightStaking = "0x1EB7c3CBac942983B80b384A978946DcEDc6CF5a";
const BrightLPStaking = ["0x160c43821004Cb76C7e9727159dD64ab8468f61C"];

//UNIV2
const ETH_BRIGHT_UNIV2 = "0xf4835af5387fab6bbc59f496cbcfa92998469b7b";
const DAI = "0x6b175474e89094c44da98b954eedeac495271d0f"

async function tvl (timestamp, block) {
    return {
        [DAI]: (await sdk.api.abi.call({
            target: BrightRiskIndex,
            block,
            abi: abi["totalTVL"]
        })).output
    }
}

async function staking (timestamp, block) {
    const balances = {};
    const stakingBright = (
        await sdk.api.erc20.balanceOf({
            target: BRIGHT,
            owner: BrightStaking,
            block
        })
    ).output;

    sdk.util.sumSingleBalance(balances, BRIGHT, stakingBright)

    return balances;
}

module.exports = {
    ethereum: {
        tvl: tvl,
        pool2: pool2s(BrightLPStaking, [ETH_BRIGHT_UNIV2]),
        staking: staking,
    },
};

'''
'''--- projects/brinc/index.js ---
const { stakingPricedLP } = require('../helper/staking')
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')
const { transformArbitrumAddress } = require("../helper/portedTokens");

const treasury = "0xB5de3f06aF62D8428a8BF7b4400Ea42aD2E0bc53"

async function tvl(time, ethBlock, chainBlocks){
    const balances = {};
    const transformAddress = await transformArbitrumAddress();
    await sumTokensAndLPsSharedOwners(balances, [
        ["0xda10009cbd5d07dd0cecc66161fc93d7c9000da1", false], //dai
        
    ], [treasury], chainBlocks.arbitrum, "arbitrum", transformAddress)
    return balances
}

module.exports={
    methodology: `DAI reserves in the bonding curve `,
    arbitrum:{
        tvl,
        //staking: stakingPricedLP("0xE5Df6583eE8DAe9F532e65D7D2C30A961c442f8a", "0x5fE5E1d5D86BDD4a7D84B4cAfac1E599c180488f", "ethereum", "0xe4f157c7ca54f435fcc3bb0b4452f98d3a48f303", "dai", true )
    }
}
'''
'''--- projects/bring/index.js ---
const { staking, stakings } = require("../helper/staking");
const { sumTokens2, } = require("../helper/unwrapLPs");
const { pool2s } = require("../helper/pool2");

/*** Ethereum Addresses ***/
const chefContracts = "0xDfa3D27Aa7E93527b2075Da5b7911184449f2c27";
const BRNG = "0x3Ecb96039340630c8B82E5A7732bc88b2aeadE82";

const listOfToken = [
  //APYS
  "0xf7413489c474ca4399eee604716c72879eea3615",
  //1MIL
  "0xa4ef4b0b23c1fc81d3f9ecf93510e64f58a4a016",
  //HAPI
  "0xd9c2d319cd7e6177336b0a9c93c21cb48d84fb54",
  //NUX
  "0x89bd2e7e388fab44ae88bef4e1ad12b4f1e0911c",
];

/*** New BSC Addresses ***/
const chefContractsNew_bsc = "0xe9d8b35e1D51b9C17504E5903C3F4D5b14d8c29E";
const BRNG_bsc = "0x939D5A13cf0074586a2Dcf17bC692B2D3CCdD517";
const BNB_BRNG2_CakeLP = "0xE412f518A6a39351c965E201A329eC83047FEb4A";

const lpPoolsNew_bsc = [
  // WBNB-WELD 6
  "0x91bf1ad3868a45bf710c516a7869dcf3e61b8b7b",
  // WBNB-YARL 9
  "0x2dC3A32895D13732a151A17C0f40E695C73AD797",
  // WBNB-SMG 2
  "0x21b64d891805b0c6437e8209146e60ad87ebb499",
];

const listOfTokenNew_bsc = [
  //YARL
  "0x843CbC1732aE7D7ba0533C6380989DACec315FfE",
  //SMG
  "0x6bfd576220e8444ca4cc5f89efbd7f02a4c94c16",
  //WELD
  "0x5b6ebb33eea2d12eefd4a9b2aeaf733231169684",
];

/*** Old BSC Addresses ***/
const chefContractsOld_bsc = "0xbb6e99F9565d872F7D75850c43D9CA5c46c6fF0c";

const lpPoolsOld_bsc = [
  // WBNB-APYS
  "0x510b29a93ebf098f3fc24a16541aaa0114d07056",
  // WBNB-ROAD
  "0x9e0eaf240eebed129136f4f733480feabbca136b",
  // WBNB-HGET
  "0xf74ee1e10e097dc326a2ad004f9cc95cb71088d3",
];

const listOfTokenOld_bsc = [
  //APYS
  "0x37dfacfaeda801437ff648a1559d73f4c40aacb7",
  //ROAD
  "0x1a3057027032a1af433f6f596cab15271e4d8196",
  //HGET
  "0xc7d8d35eba58a0935ff2d5a33df105dd9f071731",
];

/*** Harmony Addresses ***/
const chefHarmonyContracts = "0x3d4ACf89997148DcF2D266Ceb52A8bea2a7d4B2c";
const BRNG_harmony = "0x3Ecb96039340630c8B82E5A7732bc88b2aeadE82";

const listOfToken_harmony = [
  //BRNG
  "0x3Ecb96039340630c8B82E5A7732bc88b2aeadE82",
];

async function bscTvl(_, _b, { bsc: block }) {
  const chain = 'bsc'
  const toa = [];
  ([...lpPoolsNew_bsc, ...listOfTokenNew_bsc]).forEach(token => toa.push([token, chefContractsNew_bsc]));
  ([...listOfTokenOld_bsc, ...lpPoolsOld_bsc]).forEach(token => toa.push([token, chefContractsOld_bsc]));
  return sumTokens2({ chain, block, tokensAndOwners: toa, resolveLP: true, })
}

async function ethTvl(_, block) {
  const toa = [];
  listOfToken.forEach(token => toa.push([token, chefContracts]))
  return sumTokens2({ block, tokensAndOwners: toa, resolveLP: true, })
}

async function harmonyTvl(_, _b, { harmony: block }) {
  const chain = 'harmony'
  const toa = [];
  listOfToken_harmony.forEach(token => toa.push([token, chefHarmonyContracts]))
  return sumTokens2({ chain, block, tokensAndOwners: toa, resolveLP: true, })
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(chefContracts, BRNG),
    tvl: ethTvl,
  },
  bsc: {
    staking: stakings(
      [chefContractsNew_bsc, chefContractsOld_bsc],
      BRNG_bsc,
      "bsc"
    ),
    pool2: pool2s(
      [chefContractsNew_bsc, chefContractsOld_bsc],
      [BNB_BRNG2_CakeLP],
      "bsc"
    ),
    tvl: bscTvl,
  },
  harmony: {
    staking: harmonyTvl,
    tvl: () => ({})
  },
  methodology: "Counts liquidty of the Pools through their chefContracts",
};

'''
'''--- projects/brokoli/index.js ---
const { staking } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");

/*** Ethereum Addresses ***/
const farmContracts = [
    "0xd723e387D4B8a45d19C25a2e919F510C8B65eFe1",
    "0x8C9e9635861b2C8A9C92D8319AfA2C2c6324b671"
]
const USDC_BRKL_UNIV2 = "0xEBd17511F46A877199Ff08f0eA4f119c9b4Aea50";
const BRKL = "0x4674a4f24c5f63d53f22490fb3a08eaaad739ff8";

/*** BSC Addresses ***/
const farmContracts_bsc = [
    "0x58351236275E6f378BB2211B9fd623fd6E5e9D17",
    "0x9B937aB45Bab1e8CC4590eCF55dC5577caF89dE1"
];
const BUSD_BRKL_CakeLP = "0x0e537bb44eb6064D12326fF2543d918e9b9a5482";

const farmStakingContract_bsc = "0x6A4fab0070f2402F00f12D54250E47BcE36c4F4e"
const BRKL_bsc = "0x66cafcf6c32315623c7ffd3f2ff690aa36ebed38";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    pool2: pool2s(farmContracts, [USDC_BRKL_UNIV2]),   
  },
  bsc: {
    staking: staking(farmStakingContract_bsc, BRKL_bsc, "bsc"),
    pool2: pool2s(farmContracts_bsc, [BUSD_BRKL_CakeLP], "bsc"),
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking and pool2 only",
};

'''
'''--- projects/bscstation/abi.json ---
{
    "stakedToken": {
        "inputs": [],
        "name": "stakedToken",
        "outputs": [
            {
                "internalType": "contract ERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/bscstation/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const token = "0xbcb24AFb019BE7E93EA9C43B7E22Bb55D5B7f45D"
const stakingPools = [
    // START POOLS
    "0x5a42e0B986Af9756d47C263e9b4A54e3958C19dc",
    "0xC8eEeDa5b6F758208abA89bb3d614Ea135c4f29f",
    "0x97c68E1DD1d344926fc2Ef409b0848BFea7C8e8B",
    "0xb86AC944bEECaB78d7ab49cA71b27d25363E6251",
    "0x9534C17Deb29C4999a2B476B8e5ff5De4F326df8",
    "0x9Cec597abAD7f62726BDF02627C1d55B78795d61",
    "0x2cdEc23D9a583fE428E798335F0E92B12527A3a4",
    "0xCE13F6F3b27A15E5d3D641A84813Fc33D98257f2",
    // IDO POOLS
    "0x9d1933c1B85Ff8BCdE9FEbbC0562f7342D0b42D6",
    "0xaeFA83C71D87551c99546DfB7dB5F713ddcd4E28",
    "0x79d5529976252f2579a21c3cB046001f5fb99333"
];

const startPools = [
    "0xA4Cac7BD6F7cEa85a20943eB20B690dc807eD421",
    "0x2f66931d8aa91058B1FCC4Fa38F408dF7dbC56ED",
    "0x9321838064eE23a5e81d8B832eDA8a56435d0C67",
    "0x7A0b27A6f5EBAC48727FE8458E6cA787323F22e2",
    "0x9685ecB565a3305F9f0df5d26A319A7d5aB710Ad",
    "0xfF3790BE5f065C82c688129a41aF84D3A61a37Fd",
    "0x5F352530a5A93ADDfF95a7C4117c92ebc9198aa4",
    "0x1cb255CFb0E6273c2554F1Ca1Cb3C3B37b2CE554",
    "0xAB13600B0237C73eb30C931B93aDE5B1699321d6"
];

const poolTokens = [
    // FARMS
    "0x1d80B4d9afC9472Fc379aDc0fFcEDF32483EDe49",
    "0x3cFedE1dC2134a53383A435d197ED34dB741936c",
    "0x7584A86e9525d9e45daCa7Dd72A9B6f2BF4889e5",
    "0xE40Dd1BF7c0C57d9fe7E2D67E9D8F8e1a5EA291D",
    "0x7b1f753753bd187D08107B312A3991Ee9599B674",
    "0x2a4D0eb224769BCD1468769eAC372E9B5166F0B2",
    "0xdeBbe71d94E4E2b2AAd016D9a3bF8018ACD3F5Ad",
    "0x53F6d4eb57d9ab4BAa623bf1BEd641295DE1B606",
    // IDO
    "0x4CCc37AE6BAAf1Af67899cF8cf0c809Af31d7e7c",
    "0xA4D8348d574FCe65A46b34Efce5952b6158c1787"
];

async function tvl(timestamp, block, chainBlocks) {
    let balances = {}

    let startPoolUnderlying = (await sdk.api.abi.multiCall({
        calls: startPools.map(p => ({
            target: p
        })),
        abi: abi.stakedToken,
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;

    let startPoolBalances = (await sdk.api.abi.multiCall({
        calls: startPoolUnderlying.map(p => ({
            target: p.output,
            params: p.input.target
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;

    startPoolBalances.forEach(e => {
        sdk.util.sumSingleBalance(balances, `bsc:${e.input.target}`, e.output);
    });

    let lpUnderlying = (await sdk.api.abi.multiCall({
        calls: poolTokens.map(p => ({
            target: p
        })),
        abi: abi.stakedToken,
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;

    let lpBalances = (await sdk.api.abi.multiCall({
        calls: lpUnderlying.map(p => ({
            target: p.output,
            params: p.input.target
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;

    let lpPositions = [];
    for (let i in lpBalances) {
        lpPositions.push({
            balance: lpBalances[i].output,
            token: lpBalances[i].input.target
        });
    }

    await unwrapUniswapLPs(balances, lpPositions, chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`);
    return balances;
}

async function staking(timestamp, block, chainBlocks) {
    let balances = {};

    let tokenBalance = (await sdk.api.abi.multiCall({
        calls: stakingPools.map(p => ({
            target: token,
            params: p
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;

    tokenBalance.forEach(e => {
        sdk.util.sumSingleBalance(balances, `bsc:${token}`, e.output);
    });
    
    return balances;
}

module.exports = {
    bsc: {
        tvl,
        staking
    },
}
'''
'''--- projects/bscswap/index.js ---
const { staking } = require("../helper/staking");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

const BSWAPStakingContract = "0x7B2dAC429DF0b39390cD3D4E6a8b8bcCeB331E2D";
const BSWAP = "0xacc234978a5eb941665fd051ca48765610d82584";

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    staking: staking(BSWAPStakingContract, BSWAP, "bsc"),
    tvl: calculateUsdUniTvl(
      "0xCe8fd65646F2a2a897755A1188C04aCe94D2B8D0",
      "bsc",
      "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      [
        "0x55d398326f99059ff775485246999027b3197955",
        "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
      ],
      "WBNB"
    ),
  },
  methodology:
    "Factory address on BSC (0xCe8fd65646F2a2a897755A1188C04aCe94D2B8D0) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
};

'''
'''--- projects/bt-finance.js ---
const utils = require('./helper/utils');

/* * * * * * * *
* ==> Correct adapter needs to be created.
*
*****************/
async function fetch() {
  let staked = await utils.fetchURL('https://api.bt.finance/api/stats')
  return staked.data.data.totalLockedValue;
}

module.exports = {
  fetch
}

'''
'''--- projects/btcst/index.js ---
const { staking, stakings } = require("../helper/staking");
const { transformBscAddress } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const treasuryContract = "0xAd3784cD071602d6c9c2980d8e0933466C3F0a0a";
const BTCST = "0x78650B139471520656b9E7aA7A5e9276814a38e9";

const vaultContracts = [
  // Live Vaults
  "0x18a144B11feE170230177a481Ba5C2532c0279BD",
  // Finezhed Vaults
  "0xeA17a97705BB74b2c6270830943b7663890D7ceB",
  // BTCST_BTC vault
  "0x216944bAf1182e49252223E78B783fE7d5a02223",
  // BTCST_BTCST Vault
  "0xDC06E57f3987feDdA1567b49791e78B4712E8A28",
  // stake sigmaBitcoin Vault
  "0x68C59C11601BcC6bc515137aD8063382446cBA77",
  // stake sigmaDogecoin Vault
  "0xb94B8e65FD03a7C5cB5bC39C604563ab8F800d21",
];

const listOfTokens = [
  //BTCB
  "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
  //sigmaBTC
  "0x2cd1075682b0fccaadd0ca629e138e64015ba11c",
  //sigmaDOGE
  "0xe550a593d09fbc8dcd557b5c88cea6946a8b404a",
  //DOGE
  "0xba2ae424d960c26247dd6c32edc70b295c744c43",
];

async function Treasury(...params) {
  return staking(treasuryContract, BTCST, "bsc")(...params);
}

async function bscTvl(chainBlocks) {
  const balances = {};

  const transformAddress = await transformBscAddress();
  for (const token of listOfTokens) {
    await sumTokensAndLPsSharedOwners(
      balances,
      [[token, false]],
      vaultContracts,
      chainBlocks["bsc"],
      "bsc",
      transformAddress
    );
  }

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    treasury: Treasury,
    staking: stakings(vaultContracts, BTCST, "bsc"),
    tvl: bscTvl,
  },
  methodology: "Counts liquidty on all the Vaults through their Contracts",
};

'''
'''--- projects/btn-group.js ---
const retry = require('./helper/retry')
const axios = require("axios");

async function fetch() {
  var response = await retry(async bail => await axios.get('https://btn.group/pools/tvl'))

  return response.data;
}

module.exports = {
  fetch
}
'''
'''--- projects/buffaloswap/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const masterchef = "0x67D26cF7e6CB68feE0Cf546Ac489691d961c97da"
const buff = "0x10a49f1fc8c604ea7f1c49bcc6ab2a8e58e77ea5";

module.exports = {
    ...masterChefExports(masterchef, "bsc", buff)
}
'''
'''--- projects/buffer/index.js ---
const sdk = require("@defillama/sdk");

const tokens = {
  IBFR: "0xa296aD1C47FE6bDC133f39555C1D1177BD51fBc5",
  POOL: "0x7338ee5535F1E0f1a210a6Ef6dB34f5357EB9860",
  STAKING: "0xE6C2cDD466Eb1Fa6bDFDb8af1BD072d4A57734C2",
  WBNB: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
};

async function staking_tvl(_timestamp, ethBlock, chainBlocks) {
  const ibfrV1 = (
    await sdk.api.erc20.balanceOf({
      target: tokens.IBFR,
      owner: tokens.STAKING,
      block: chainBlocks["bsc"],
      chain: "bsc",
    })
  ).output;
  let iBFR_address = `bsc:${tokens.IBFR}`;
  var balances = {};
  balances[iBFR_address] = ibfrV1;

  return balances;
}

async function tvl(_timestamp, ethBlock, chainBlocks) {
  const bnbV1 = (
    await sdk.api.eth.getBalance({
      target: tokens.POOL,
      block: chainBlocks["bsc"],
      chain: "bsc",
    })
  ).output;
  let WBNB_address = `bsc:${tokens.WBNB}`;
  var balances = {};
  balances[WBNB_address] = bnbV1;

  return balances;
}

module.exports = {
  methodology: `TVL for Buffer is calculated by using the BNB deposited in the write pool and the iBFR deposited in the revenue share pool`,
  bsc: {
    staking: staking_tvl,
    tvl: tvl,
  },
};

'''
'''--- projects/bullish/index.js ---
const { get_account_tvl } = require("../helper/eos");

// Bullish
// https://bullish.com
async function eos() {
  return await get_account_tvl("bullishfunds", [["eosio.token", "EOS", "eos"]]);
}

module.exports = {
  methodology: `Bullish TVL is achieved by querying token balances from Bullish funds account.`,
  eos: {
    tvl: eos
  },
}
'''
'''--- projects/bumper/index.js ---
const sdk = require('@defillama/sdk')

const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
const contract = "0xBabeE6d5F6EDD301B5Fae591a0D61AB702b359d0"
const currentTvlAbi = {"inputs":[],"name":"currentTVL","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
async function tvl(time, block){
    return {
        [USDC]:(await sdk.api.abi.call({
            target: contract,
            block,
            abi: currentTvlAbi
        })).output
    }
}

module.exports={
    methodology: `Count the USDC that has been deposited on ${contract}`,
    ethereum:{
        tvl,
        masterchef: tvl
    },
}
'''
'''--- projects/bunicorn/index.js ---
const BigNumber = require("bignumber.js");
const { toUSDTBalances } = require("../helper/balances");
const sdk = require("@defillama/sdk");
const { request, gql } = require("graphql-request");

const tokenSubgraphUrl =
  "https://api.thegraph.com/subgraphs/name/bunicorndefi/buni-token";
const stableSubgraphUrl =
  "https://api.thegraph.com/subgraphs/name/bunicorndefi/buni-stablecoins";
const BUNI_CONTRACT_ADDRESS = "0x0e7beec376099429b85639eb3abe7cf22694ed49";
const MASTERCHEF_CONTRACT_ADDRESS =
  "0xA12c974fE40ea825E66615bA0Dc4Fd19be4D7d24";

const graphTotalTokenTVLQuery = gql`
  query GET_TOTAL_TOKEN_TVL($block: Int) {
    bunis(where: { id: 1 }, block: { number: $block }) {
      totalLiquidity
    }
  }
`;

const graphTotalStableTVLQuery = gql`
  query GET_TOTAL_STABLE_TVL($block: Int) {
    buniCornFactories(
      where: { id: "0x86873f85bc12ce40321340392c0ff39c3bdb8d68" }
      block: { number: $block }
    ) {
      id
      totalLiquidityUSD
    }
  }
`;

async function getTotalFarmTVL(timestamp, ethBlock, chainBlocks) {
  try {
    const balances = {};
    const stakedBuni = sdk.api.erc20.balanceOf({
      target: BUNI_CONTRACT_ADDRESS,
      owner: MASTERCHEF_CONTRACT_ADDRESS,
      chain: "bsc",
      block: chainBlocks.bsc,
    });
    sdk.util.sumSingleBalance(
      balances,
      "bsc:" + BUNI_CONTRACT_ADDRESS,
      (await stakedBuni).output
    );
    return balances;
  } catch (e) {
    throw new Error("getTotalFarmTVL has exception:" + e.message);
  }
}

async function getTotalTokenTVL(timestamp, ethBlock, chainBlocks) {
  try {
    const { bunis } = await request(tokenSubgraphUrl, graphTotalTokenTVLQuery, {
      block: chainBlocks.bsc,
    });

    return (bunis[0] && bunis[0].totalLiquidity) || 0;
  } catch (e) {
    throw new Error("getTotalTokenTVL has exception:" + e.message);
  }
}

async function getTotalStableTVL(timestamp, ethBlock, chainBlocks) {
  try {
    const { buniCornFactories } = await request(
      stableSubgraphUrl,
      graphTotalStableTVLQuery,
      {
        block: chainBlocks.bsc,
      }
    );

    return (
      (buniCornFactories[0] && buniCornFactories[0].totalLiquidityUSD) || 0
    );
  } catch (e) {
    throw new Error("getTotalStableTVL has exception:" + e.message);
  }
}

async function getTotalTVL(timestamp, ethBlock, chainBlocks) {
  const [tokensSummary, stableSummary] = await Promise.all([
    getTotalTokenTVL(timestamp, ethBlock, chainBlocks),
    getTotalStableTVL(timestamp, ethBlock, chainBlocks),
  ]);

  return toUSDTBalances(new BigNumber(tokensSummary).plus(stableSummary));
}

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: getTotalTVL,
    staking: getTotalFarmTVL,
  },
};

'''
'''--- projects/bunny/abi.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "pool",
      "type": "address"
    }
  ],
  "name": "tvlOfPool",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "tvl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/bunny/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const potABI = require('./pot_abi.json')
const leverageABI = require('./leverage_abi.json')
const BigNumber = require('bignumber.js')

const dashboard = '0xb3C96d3C3d643c2318E4CDD0a9A48aF53131F5f4'
const pools = [
    '0xb037581cF0cE10b04C4735443d95e0C93db5d940',
    '0x4fd0143a3DA1E4BA762D42fF53BE5Fab633e014D',
    //'0x69FF781Cf86d42af9Bf93c06B8bE0F16a2905cBC', // pool2
    '0xCADc8CB26c8C7cB46500E61171b5F27e9bd7889D',
    '0xEDfcB78e73f7bA6aD2D829bf5D462a0924da28eD',
    '0x7eaaEaF2aB59C2c85a17BEB15B110F81b192e98a',
    '0x3f139386406b0924eF115BAFF71D0d30CC090Bd5',
    '0x0137d886e832842a3B11c568d5992Ae73f7A792e',
    '0xCBd4472cbeB7229278F841b2a81F1c0DF1AD0058',
    '0xE02BCFa3D0072AD2F52eD917a7b125e257c26032',
    '0x41dF17D1De8D4E43d5493eb96e01100908FCcc4f',
    '0x1b6e3d394f1D809769407DEA84711cF57e507B99',
    '0x92a0f75a0f07C90a7EcB65eDD549Fa6a45a4975C',
    '0xC1aAE51746bEA1a1Ec6f17A4f75b422F8a656ee6',
    '0xE07BdaAc4573a00208D148bD5b3e5d2Ae4Ebd0Cc',
    '0xa59EFEf41040e258191a4096DC202583765a43E7',
    '0xa5B8cdd3787832AdEdFe5a04bF4A307051538FF2',
    '0xC0314BbE19D4D5b048D3A3B974f0cA1B2cEE5eF3',
    '0x866FD0028eb7fc7eeD02deF330B05aB503e199d4',
    '0x52cFa188A1468A521A98eaa798E715Fbb9eb38a3',
    '0x22af73683dee5D266B0c36c37D0Fd62c402Fd250',
    '0x549d2e2B4fA19179CA5020A981600571C2954F6a',
    '0x0Ba950F0f099229828c10a9B307280a450133FFc',
    '0x0243A20B20ECa78ddEDF6b8ddb43a0286438A67A',
    '0xD1ad1943b70340783eD9814ffEdcAaAe459B6c39',

    // pancakeswap v2
    '0xa6C29a422D1612293669156a34f2793526783622',
    '0xA599d6b81eC4a5DDd8eCa85e3AAc31E006aF00AA',
    '0x203Ee29ba85BbDfA23bFaE5D77620AeFDaf92cB1',
    '0x285F793CE97079D4a5712E616AFBbb971Dbf1f1f',
    '0xac20925e6615ad6871987e199783Fa80Bf24EB39',
    '0x0d17e7B77C678C79C3ab5176e164FF0BCceb8EAa',
    '0x7D52a1697F2dF08E6fb2b5A88E0E8e4D7C11a921',
    '0xE0aca387C6600b455CCFC32B253e2DB13b71ca62',
    '0x81fa6F9F4599c5316Cc53B782DE7c01EFf4f9551',
    '0x633e538EcF0bee1a18c2EDFE10C4Da0d6E71e77B',
    '0xac7D40638271D349cb2DeDfdC6268A77738403Fa',
    '0xFdb7D4AbD0109b36667946726dF943E83570286C',
    '0x7f0320cef62C88CE1DB7d77c1849082C053E2344',
    '0xC341c6a006cab105E8CD2518e25aaB311Cb22FF6',
    '0x74fdc215f8309Ec58Fd34455bf3Fee95FB3416dD',
    '0xc1d9Ead28Fc4CB9658C62594A695a53bfD306f77',
    '0xf92f12b505594EedF65CB8B973819dfA242c61D7',
    '0xFeED0bb79035c61CF6519795a02a6a2A69A11aAC',
    '0xD2220455E760Fb27ED8aaA6F9C7E143A687BB0aD',
    '0xBdd478cF8313240EfDC54108A2ed389d450cD702',

    // qSAV
    '0xDe80CE223C9f1D1db0BC8D5bDD88E03f6882eEA3',   // CAKE
    '0x67c42b3dAC9526efCBFeeb2FC1C56Cf77F494e46',   // BNB
    '0x4FC359E39A99acFDF44c794eF702fab93067B2A6',   // BUSD
    '0x53fd20bc5D4d222764B70817810494F1D06f3403',   // USDT
    '0x401c22395200Caaae87f8aB9f9446636Dde38c9A',   // DAI
    '0xEe3Ee0BEb7919eDD31a4506d7d4C93940f2ACED6',   // USDC
    '0xB9Cf0d36e82C2a1b46eD51e44dC0a4B0100D6d74',   // BTCB
    '0x4b107b794c9Bbfd83E5Ac9E8Dd59F918510C5729',   // ETH
    '0x33F93897e914a7482A262Ef10A94319840EB8D05',   // bQBT
    '0xE6b3fb8E6c7B9d7fBf3BFD1a50ac8201c2fa5a8F',   // bQBT-BNB

    // vSAV v2
    '0xA555443A5eE77f334648eF4F557C0B5070fcb4de',
    '0xf70e331AcDDfC2a5cd169B8B3D1cC02951E8dE85',
    '0xa08a2664BD2124dD011224E1cb4fd6E263E3A208',
    '0x7cD22bd5B7a45F952a4f375AA6d5bf08538ed03C',
    '0x7d2De1362dc32c1974d3A7CBBbd6Ad898E7B3EE7',
]

const pots = [
    '0xa9b005d891414E0d6E0353490e099D0CA4C778Fc',
    '0xD601966588E812218a45f3ec06D3A89602348183'
]

const leveragedPools = [
    '0xfb8358f34133c275B0393E3883BDd8764Cb610DE',
    '0xD75f3E4e8ed51ec98ED57386Cb47DF457308Ad08',
    '0xb04D1A8266Ff97Ee9f48d48Ad2F2868b77F1C668',
    '0x12B7b4BEc740A7F438367ff3117253507eF605A7',
    '0xe0fB5Cd342BCA2229F413DA7a2684506b0397fF3',
    '0x8626Af388F0B69BB15C36422cE67f9638BA2B800'
]

const dashboardPolygon = '0xFA71FD547A6654b80c47DC0CE16EA46cECf93C02'
const poolsPolygon = [
    // polyBUNNY
    '0x10C8CFCa4953Bc554e71ddE3Fa19c335e163D7Ac',
    '0x7a526d4679cDe16641411cA813eAf7B33422501D',
    '0x6b86aB330F18E8FcC4FB214C91b1080577df3513',
    '0xe167Cf12a60f606C4C83bc34F09C4f9D9453690e',
    // qPool
    '0x4beB900C3a642c054CA57EfCA7090464082e904F',
    '0x54E1feE2182d0d96D0D8e592CbFd4debC8EEf7Df',
    '0x3cba7b58b4430794fa7a37F042bd54E3C2A351A8',
    '0x4964e4d8E17B86e15A2f0a4D8a43D8E4AbeC3E78',
    '0xf066208Fb16Dc1A06e31e104bEDb187468206a92',
    '0xB0621a46aFd14C0D1a1F8d3E1021C4aBCcd02F5b',
    '0x95aF402e9751f665617c3F9037f00f91ec00F7b6',
    '0x29270e0bb9bD89ce4febc2fBd72Cd7EB53C0aDD7',
    '0xE94096Fb06f60C7FC0d122A352154842384F80bd',
    '0x58918F94C14dD657f0745f8a5599190f5baDFa05',
    '0x4ee929E9b25d00E6C7FCAa513C01311Da40462F2',
    '0x560F866fE4e1E6EA20701B9dCc9555486E1B84c2',
    '0x470Be517cBd063265c1A519aE186ae82d10dD360',

    // sPool
    '0x87c743C1418864c9799FdE4C8612D1Ba64188ECe',
    '0x16CeE21c231E2c3cf2778Fe568230c145C8591cA',
    '0x45F10bAE59Ff9D4Be78eD20F0AAfDE532b254707',
    '0xdF0BE663C84322f55aD7b40A4120CdECBa4C4B45',
    '0x51C30ee94052baAABA60Db6b931c1f4657FFe174',
    '0x39D28Db6742a457BCfB927D4539bEea55Dc5Dd87',
    
]

const ZERO = new BigNumber(0)
const ETHER = new BigNumber(10).pow(18)

async function bsc(timestamp, ethBlock, chainBlock) {
    const block = chainBlock.bsc
    const total = (await sdk.api.abi.multiCall({
        calls: pools.map( address => ({
            target: dashboard,
            params: address
        })),
        block,
        abi: abi,
        chain: 'bsc'
    })).output.reduce((tvl, call) => tvl.plus(new BigNumber(call.output)), ZERO)
    
    const pot_total = (await sdk.api.abi.multiCall({
        calls: pots.map( address => ({
            target: address
        })),
        block,
        abi: potABI,
        chain: 'bsc'
    })).output.reduce((tvl, call) => tvl.plus(new BigNumber(call.output)), ZERO)
    
    const leverage_total = (await sdk.api.abi.multiCall({
        calls: leveragedPools.map( address => ({
            target: address
        })),
        block,
        abi: leverageABI,
        chain: 'bsc'
    })).output.reduce((tvl, call) => tvl.plus(new BigNumber(call.output[1])), ZERO)
        
    return {
        'tether': total.plus(pot_total).plus(leverage_total).dividedBy(ETHER).toNumber()
    }
}

async function polygon(timestamp, ethBlock, chainBlock) {
    const block = chainBlock.polygon
    const total = (await sdk.api.abi.multiCall({
        calls: poolsPolygon.map( address => ({
            target: dashboardPolygon,
            params: address
        })),
        block,
        abi: abi,
        chain: 'polygon'
    })).output.reduce((tvl, call) => tvl.plus(new BigNumber(call.output)), ZERO)

    return {
        'tether': total.dividedBy(ETHER).toNumber()
    }
}

module.exports = {
    misrepresentedTokens: true,
    bsc:{
        tvl: bsc
    },
    polygon:{
        tvl:polygon
    },
}

'''
'''--- projects/bunny/leverage_abi.json ---
{
  "inputs": [],
  "name": "getVaultState",
  "outputs": [
    {
      "components": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tvl",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "debtRatioLimit",
          "type": "uint256"
        }
      ],
      "type": "tuple"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/bunny/pot_abi.json ---
{
  "inputs": [],
  "name": "totalValueInUSD",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "valueInUSD",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/bunnypark/index.js ---
const sdk = require("@defillama/sdk");
const { addFundsInMasterChef } = require("../helper/masterchef");

const bp = "0xACB8f52DC63BB752a51186D1c55868ADbFfEe9C1";
const masterchef = "0x6148104d39924f071DF05eeb2f6AEB53F7b2EFE7";
const stakingPools = [
    "0x8a8389D174081E585983DAB7189ea1Cf18F11896",
    "0xE051C61baBa59Fd9d184a26F15BE4361027c9916"
]
const poolInfo = {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"poolInfo","outputs":[{"internalType":"contract IBEP20","name":"lpToken","type":"address"},{"internalType":"uint256","name":"lpSupply","type":"uint256"},{"internalType":"uint256","name":"allocPoint","type":"uint256"},{"internalType":"uint256","name":"lastRewardBlock","type":"uint256"},{"internalType":"uint256","name":"accBPPerShare","type":"uint256"}],"stateMutability":"view","type":"function"};

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, masterchef, chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`, poolInfo);
    return balances;
}

async function staking(timestamp, block, chainBlocks) {
    let balances = {};
    let stakingBalance = (await sdk.api.abi.multiCall({
        calls: stakingPools.map(p => ({
            target: bp,
            params: p
        })),
        abi: "erc20:balanceOf",
        block : chainBlocks.bsc,
        chain: "bsc"
    })).output;
    stakingBalance.forEach(e => {
        sdk.util.sumSingleBalance(balances, `bsc:${bp}`, e.output);
    })
    return balances;
}

module.exports = {
    bsc: {
        tvl,
        staking
    }
}
'''
'''--- projects/burgerswap/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "pid",
                "type": "uint256"
            },
            {
                "internalType": "contract IERC20",
                "name": "depositToken",
                "type": "address"
            },
            {
                "internalType": "contract IERC20",
                "name": "earnToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastUpdateBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastEarnAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accRewardPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accEarnPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "tokenType",
                "type": "uint16"
            },
            {
                "internalType": "bool",
                "name": "added",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getDepositTokenSupply": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_pid",
                "type": "uint256"
            }
        ],
        "name": "getDepositTokenSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/burgerswap/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { staking } = require("../helper/staking");

const stakingContract = "0x9154c2684aeF8d106babcB19Aa81d4FabF7581ec";
const BURGER = "0xae9269f27437f0fcbc232d39ec814844a51d6b8f";

const Factory = "0x8a1E9d3aEbBBd5bA2A64d3355A48dD5E9b511256";
const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";

const shackChef = "0x07dE034A0Fc0DA7a0bf703F6DcA7025bcD61BA3e";

async function bscShackTvl(timestamp, ethBlock, chainBlocks) {
  const balances = {};

  const poolLength = (
    await sdk.api.abi.call({
      abi: abi.poolLength,
      target: shackChef,
      chain: "bsc",
      block: chainBlocks["bsc"],
    })
  ).output;

  for (let i = 0; i <= poolLength; i++) {
    const tokenDeposited = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: shackChef,
        params: i,
        chain: "bsc",
        block: chainBlocks["bsc"],
      })
    ).output.depositToken;

    const balanceDeposited = (
      await sdk.api.abi.call({
        abi: abi.getDepositTokenSupply,
        target: shackChef,
        params: i,
        chain: "bsc",
        block: chainBlocks["bsc"],
      })
    ).output;

    sdk.util.sumSingleBalance(
      balances,
      `bsc:${tokenDeposited}`,
      balanceDeposited
    );
  }

  return balances;
}

const bscDexTvl = calculateUsdUniTvl(
  Factory,
  "bsc",
  WBNB,
  [BURGER],
  "binancecoin"
);

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: sdk.util.sumChainTvls([bscDexTvl, bscShackTvl]),
    staking: staking(stakingContract, BURGER, "bsc"),
  },
  methodology:
    "TVL is equal to AMMs liquidity plus the Assets deposited on Burger Shack",
};

'''
'''--- projects/burrow.cash/index.js ---
const { call, sumSingleBalance } = require('../helper/near')
const BURROW_CONTRACT = 'contract.main.burrow.near'

function tvl(borrowed = false) {
  return async () => {
    const balances = {};
    const assetsCallResponse = await call(BURROW_CONTRACT, 'get_assets_paged', {});

    const assets = assetsCallResponse.map(([asset]) => asset);
    const amount = borrowed ? assetsCallResponse.map(a => a[1].borrowed.balance) 
      : assetsCallResponse.map(a => a[1].supplied.balance - a[1].borrowed.balance);

    for (let asset of assets) {
      sumSingleBalance(balances, asset, amount[assets.indexOf(asset)]);
    };

    return balances;
  }
};

module.exports = {
  near: {
    tvl: tvl(),
    borrowed: tvl(true)
  },
  misrepresentedTokens: true,
  timetravel: false,
  methodology: 'Summed up all the tokens deposited in their main lending contract'
}

'''
'''--- projects/butterswap/index.js ---
const sdk = require("@defillama/sdk");
const {calculateUniTvl} = require("../helper/calculateUniTvl");

//HECO ADDRESSES
const hecoFactory = "0x874D01CA682C9c26BA7E6D9f6F801d1a1fb49201";
const hecoButter = "0xbf84214ea409A369774321727595F218889eD943";
const hecoChef = "0x89a3BfA840CF4C9022789CC60500Ec03df8C2935";

//BSC ADDRESSES
const bscFactory = "0x1Ba94C0851D96b2c0a01382Bf895B5b25361CcB2";
const bscButter = "0x5eF7814f4cB17b38408F1F641e4b5b61c5D023a8";
const bscHButter = "0x2f3bca2631fff538b8a55207f6c2081457e229f7";
const bscChef = "0xa49f4CF57eaFE0098D398DF3eD3A7dF10EAaBfAB";

async function hecoTvl(timestamp, block, chainBlocks) {
    return await calculateUniTvl(addr=>{
        if (addr.toLowerCase() === "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f") {
            return "0x6f259637dcd74c767781e37bc6133cd6a68aa161"
        }
        else if (addr.toLowerCase() === "0xdd86dd2dc0aca2a8f41a680fc1f88ec1b7fc9b09"){
            return "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce";
        }
        else if (addr.toLowerCase() === "0x311bcb634a4111e6516d3899f9fbfbfe984f021a") {
            return "0xb2e260f12406c401874ecc960893c0f74cd6afcd"
        }
        else if (addr.toLowerCase() === "0xdb11743fe8b129b49b11236e8a715004bdabe7e5") {
            return "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0"
        }
        else if (addr.toLowerCase() === "0x40280e26a572745b1152a54d1d44f365daa51618") {
            return "bsc:0xba2ae424d960c26247dd6c32edc70b295c744c43"
        }
        else if (addr.toLowerCase() === "0x4f99d10e16972ff2fe315eee53a95fc5a5870ce3") {
            return "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
        }
        return `heco:${addr}`
    }, chainBlocks.heco, "heco", hecoFactory, 0, true);
}

async function bscTvl(timestamp, block, chainBlocks) {
    return await calculateUniTvl(addr=>{
        addr = addr.toLowerCase();
        if (addr === "0x2f3bca2631fff538b8a55207f6c2081457e229f7" || addr === "0x5ef7814f4cb17b38408f1f641e4b5b61c5d023a8") {
            return "heco:0xbf84214ea409a369774321727595f218889ed943"
        }
        return `bsc:${addr}`
    }, chainBlocks.bsc, "bsc", bscFactory, 0, true);
}

async function bscStaking(timestamp, block, chainBlocks) {
    let balances = {};
    let stakingBalance = (await sdk.api.erc20.balanceOf({
        target: bscButter,
        owner: bscChef,
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;
    sdk.util.sumSingleBalance(balances, `heco:${hecoButter}`, stakingBalance);
    return balances;
}

async function hecoStaking(timestamp, block, chainBlocks) {
    let balances = {};
    let stakingBalance = (await sdk.api.erc20.balanceOf({
        target: hecoButter,
        owner: hecoChef,
        block: chainBlocks.heco,
        chain: "heco"
    })).output;
    sdk.util.sumSingleBalance(balances, `heco:${hecoButter}`, stakingBalance);
    return balances;
}

module.exports = {
    heco: {
        tvl: hecoTvl,
        staking: hecoStaking
    },
    bsc: {
        tvl: bscTvl,
        staking: bscStaking
    },
}
'''
'''--- projects/bwatch/index.js ---
const retry = require('async-retry');
const axios = require("axios");
const BigNumber = require("bignumber.js");

const API = 'https://mtg-api.b.watch/api/etfs'

async function fetchBwatch() {
  const resp = await retry(async bail => await axios.get(API))
  const etfs = resp.data.data.etfs;
  let sum = new BigNumber(0);
  for (let ix = 0; ix < etfs.length; ix++) {
    const etf = etfs[ix];
    sum = sum.plus(new BigNumber(etf.circulating_supply).times(etf.price))
  }
  return sum.toFixed(2);
}

async function fetch() {
  const ret = await fetchBwatch();
  return ret;
}

module.exports = {
  fetch
}

'''
'''--- projects/bxh/index.js ---

const { uniTvlExport } = require('../helper/calculateUniTvl');

module.exports = {
    heco: {
      tvl: uniTvlExport('0xe0367ec2bd4ba22b1593e4fefcb91d29de6c512a', 'heco'),
    },
    bsc: {
      tvl: uniTvlExport('0x7897c32cbda1935e97c0b59f244747562d4d97c1', 'bsc'),
    },
    ethereum: {
      tvl: uniTvlExport('0x8d0fCA60fDf50CFE65e3E667A37Ff3010D6d1e8d', 'ethereum'),
    },
    avax: {
      tvl: uniTvlExport('0xDeC9231b2492ccE6BA01376E2cbd2bd821150e8C', 'avax'),
    },
    okexchain: {
      tvl: uniTvlExport('0xff65bc42c10dcc73ac0924b674fd3e30427c7823', 'okexchain'),
    },
}; // node test.js projects/bxh/index.js

'''
'''--- projects/bzx.js ---
const utils = require('./helper/utils');

/* * * * * * * *
* ==> Correct adapter needs to be created.
*
*****************/
async function fetch() {
  let staked = await utils.fetchURL('https://api.bzx.network/v1/vault-balance-usd?networks=bsc,eth,polygon')
  return Number(staked.data.data.bsc.all) + Number(staked.data.data.eth.all) + Number(staked.data.data.polygon.all);
}

module.exports = {
  fetch
}

'''
'''--- projects/cafeswap/index.js ---
const sdk = require("@defillama/sdk");
const tvlOnPairs = require("../helper/processPairs.js");
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require("../helper/balances");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const masterchefAbi = require("../helper/abis/masterchef.json")

const BSC_DEX_FACTORY = "0x3e708fdbe3ada63fc94f8f61811196f1302137ad";
const BSC_MASTER_CHEF = "0xc772955c33088a97d56d0bbf473d05267bc4febb";
const POLYGON_DEX_FACTORY = "0x5ede3f4e7203bf1f12d57af1810448e5db20f46c";
const POLYGON_MASTER_CHEF = "0xca2DeAc853225f5a4dfC809Ae0B7c6e39104fCe5"
const BSC_BREW_ADDRESS = "0x790be81c3ca0e53974be2688cdb954732c9862e1";
const POLYGON_BREW_ADDRESS = "0xb5106A3277718eCaD2F20aB6b86Ce0Fee7A21F09";
const BSC_DEX_SUBGRAPH =
  "https://graphapi.cafeswap.finance/subgraphs/name/cafeswap/cafeswap-subgraph-bsc";

const liquidityQuery = gql`
  query get_tvl($id: String, $block: Int) {
    uniswapFactory(id: $id, block: { number: $block }) {
      totalVolumeUSD
      totalLiquidityUSD
    }
  }
`;

// async function bscTvl(timestamp, block, chainBlocks) {
//   const { uniswapFactory } = await request(BSC_DEX_SUBGRAPH, liquidityQuery, {
//     id: BSC_DEX_FACTORY,
//     block: chainBlocks.bsc
//   });
//   const usdTvl = Number(uniswapFactory.totalLiquidityUSD); // (Subgraph) Use totalLiquidityUSD till last sync block
//   return toUSDTBalances(usdTvl);
// }

// async function poolsTvl(timestamp, ethBlock, chainBlocks) {
//   const balances = {};
//   const stakedBrew = sdk.api.erc20.balanceOf({
//     target: BREW_ADDRESS,
//     owner: BSC_MASTER_CHEF,
//     chain: "bsc",
//     block: chainBlocks.bsc,
//   });
//   sdk.util.sumSingleBalance(
//     balances,
//     "bsc:" + BREW_ADDRESS,
//     (await stakedBrew).output
//   );
//   return balances;
// }

async function bscTvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks.bsc, "bsc", BSC_DEX_FACTORY, 0, true);
}

async function bscStaking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (await sdk.api.erc20.balanceOf({
    target: BSC_BREW_ADDRESS,
    owner: BSC_MASTER_CHEF,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${BSC_BREW_ADDRESS}`, balance);
  return balances;
}

async function polygonTvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(addr=>`polygon:${addr}`, chainBlocks.polygon, "polygon", POLYGON_DEX_FACTORY, 0, true);
}

async function polygonStaking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (await sdk.api.erc20.balanceOf({
    target: POLYGON_BREW_ADDRESS,
    owner: POLYGON_MASTER_CHEF,
    block: chainBlocks.polygon,
    chain: "polygon"
  })).output;
  // Using BSC_BREW_ADDRESS for calculation 
  sdk.util.sumSingleBalance(balances, `bsc:${BSC_BREW_ADDRESS}`, balance);
  return balances;
}

module.exports = {
  bsc: {
    tvl: bscTvl,
    staking: bscStaking
  },
  polygon: {
    tvl: polygonTvl,
    staking: polygonStaking
  },
};

'''
'''--- projects/caffeinefund/index.js ---
const { tombTvl } = require('../helper/tomb');

const cfn = "0x3873788Acb34a7d67e90F053da8598aEF76298c6";
const cshare = "0x41160139986dFfE2011a07fbB5F4B316200A5419";

const boardroom = "0xf916Dc7bfEAd1cA29cB1aCE71D82dFF68Cc12291";
const rewardPool = "0x803b87cC88B701E4F871939826944e1d0413747c";

const pool2lps = [
    "0x504183690063734eAAd4f53b77729266b28E3b60",
    "0x190a83FdaC8560d0e6ED2ab00dDE62D648A46747"
]

module.exports = {
    ...tombTvl(cfn, cshare, rewardPool, boardroom, pool2lps, "avax", undefined, false, pool2lps[1])
}
'''
'''--- projects/cake-monster/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const { transformBscAddress } = require("../helper/portedTokens");
const CM_TOKEN_CONTRACT = "0x8A5d7FCD4c90421d21d30fCC4435948aC3618B2f";
const CM_STAKING_CONTRACT = "0xF7CDDF60CD076d4d64c613489aA00dCCf1E518F6";

async function staking(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformBscAddress();

  const stakingBalance = (
    await sdk.api.abi.call({
      abi: "erc20:balanceOf",
      chain: "bsc",
      target: CM_TOKEN_CONTRACT,
      params: [CM_STAKING_CONTRACT],
      block: chainBlocks["bsc"],
    })
  ).output;

  let stakingBalanceCorrected = new BigNumber(stakingBalance)
    .minus(new BigNumber(1000000000).times(10 ** 18))
    .toFixed();

  await sdk.util.sumSingleBalance(
    balances,
    transform(CM_TOKEN_CONTRACT),
    stakingBalanceCorrected
  );

  return balances;
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology:
    "counts the number of $MONSTA tokens in the Cake Monster Staking contract, excluding the amount reserved for the staking rewards.",
  start: 15765654,
  bsc: {
    tvl: () => ({}),
    staking,
  },
};

'''
'''--- projects/cakedao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const cakeStaking = "0xA3E4200CA1ac92331d529327E82d89C149CcD81C";
const cake = "0x4eb49a2f9a79053866fae806fac95a3ef5b92c05";

const treasury = "0x829D805F26E26aE6c2C6294B7fF9c0fE14d982Ac";
const treasuryTokens = [
  ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
  ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false], // WAVAX,
  ["0xc7198437980c041c805a1edcba50c1ce5db95118", false], // USDT
  ["0x50b7545627a5162f82a992c33b87adc75187b218", false], // WBTC
  ["0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab", false], // WETH
  ["0x84d2fe6adace63407f4b6bd91ab9f782ba3cb420", true], // CAKE-MIM JLP
  ["0xb8df8111a74e5fd62b13dbbe59ddeb343fc91d4a", true] // CAKE-WAVAX JLP                                                  
]

module.exports = {
  ...ohmTvl(
    treasury,
    treasuryTokens,
    "avax",
    cakeStaking,
    cake
  ),
};

'''
'''--- projects/canary/index.js ---
const { getAvaxUniswapTvl } = require("../helper/getUniSubgraphTvl")

const tvl = getAvaxUniswapTvl('https://api.thegraph.com/subgraphs/name/canarydeveloper/canarydex', 'canaryFactories')

module.exports = {
  misrepresentedTokens: true,
  methodology: 'We count liquidity on the pairs. We get that information from the "canarydeveloper/canarydex" subgraph',
  avalanche:{
    tvl,
  },
}
'''
'''--- projects/candle/index.js ---
const { stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");

const stakingContracts = [
  // stakingContract1 =
  "0xDE6d8C4B6ee674EB8d9c4652eE7456E70D9d24B9",
  // stakingContract2

];

const USDC_CNDL_UNIV2 = "0x65a364c98aa6554932b551471e7873d9617047d4";
const CNDL = "0x3D97EdB1c1D87C0cBf098a0D2230d7380d4b1432";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, CNDL),
    pool2: pool2s(stakingContracts, [USDC_CNDL_UNIV2]),
    tvl: () => ({}),
  },
  // candle: {
  //   staking: stakings(stakingContracts, CNDL, 'candle'),
  //   pool2: pool2s(stakingContracts, [USDC_CNDL_UNIV2], 'candle'),
  //   tvl: () => ({}),
  // },
  methodology: "Counts liquidty on the staking and pool2s only",

};

'''
'''--- projects/cap/index.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');

const contracts = {
    "treasury": "0x283C41b726634fBD6B72aA22741B202DB7E56aaC",
    "treasuryV2": "0x1058AFe66BB5b79C295CCCE51016586949Bc4e8d",
    "trading1": "0x9BC357bc5b312AaCD41a84F3C687F031B8786853",
    "trading2": "0xA55Eee92a46A50A4C65908F28A0BE966D3e71633",
    "trading3": "0xCAEc650502F15c1a6bFf1C2288fC8F819776B2eC",
    "trading4": "0xbEd32937D8A5D1421241F52809908f1a17D75bDb",
    "staking": "0xC8CDd2Ea6A5149ced1F2d225D16a775ee081C67D",
    "ethPool": "0xE0cCd451BB57851c1B2172c07d8b4A7c6952a54e",

    "usdcPool": "0x958cc92297e6F087f41A86125BA8E121F0FbEcF2",
};
const cap = "0x031d35296154279dc1984dcd93e392b1f946737b";
const weth = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const usdc = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8";

async function tvl(_time, _ethBlock, chainBlocks) {
    let balances = {};

    balances[`arbitrum:${usdc}`] = (await sdk.api.erc20.balanceOf({
        target: usdc,
        owner: contracts.usdcPool,
        chain: 'arbitrum',
        block: chainBlocks.arbitrum
    })).output;

    const ethLocked = await sdk.api.eth.getBalances({
        targets: [
            contracts.trading1,
            contracts.trading2,
            contracts.trading3,
            contracts.trading4,
            contracts.ethPool
        ],
        chain: 'arbitrum',
        block: chainBlocks.arbitrum
    });

    balances[weth] = ethLocked.output.reduce((total, item) =>
        BigNumber(item.balance).plus(total), 0).toFixed(0);

    return balances;
};

async function treasury(_time, _ethBlock, chainBlocks) {
    let balances = {};
    balances[`arbitrum:${usdc}`] = (await sdk.api.erc20.balanceOf({
        target: usdc,
        owner: contracts.treasury,
        chain: 'arbitrum',
        block: chainBlocks.arbitrum
    })).output;

    const ethLocked = await sdk.api.eth.getBalances({
        targets: [contracts.treasury, contracts.treasuryV2],
        chain: 'arbitrum',
        block: chainBlocks.arbitrum
    });

    balances[weth] = ethLocked.output.reduce((total, item) =>
        BigNumber(item.balance).plus(total), 0).toFixed(0);
    return balances;
};

async function staking(_time, _ethBlock, chainBlocks) {
    const capLocked = (await sdk.api.erc20.balanceOf({
        target: cap,
        owner: contracts.staking,
        chain: 'arbitrum',
        block: chainBlocks.arbitrum
    }));

    return { [`arbitrum:${cap}`]: capLocked.output }
}

module.exports = {
    methodology: "ETH locked on trading contracts",
    arbitrum: {
        treasury,
        staking,
        tvl
    }
};
'''
'''--- projects/capital-dao/index.js ---
const {staking} = require('../helper/staking')
const {pool2} = require('../helper/pool2')

const cdsAddress = '0x3c48Ca59bf2699E51d4974d4B6D284AE52076e5e';
const lpWethCds = '0x0be902716176d66364f1c2ecf25829a6d95c5bee';
const stakingAddress = '0x0a6bfa6aaaef29cbb6c9e25961cc01849b5c97eb';

module.exports = {
  timetravel: true,
  methodology: "TVL includes all farms in staking and swap contract",
  ethereum:{
    tvl: async ()=>({}),
    staking: staking(stakingAddress, cdsAddress),
    pool2: pool2(stakingAddress, lpWethCds)
  }
}

'''
'''--- projects/capitaldex/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address in Ethereum(0x03407772F5EBFB9B10Df007A2DD6FFf4EdE47B53) and in Curio(0xc36f5180b181f1b949e0ff4d65b258e0987f443f) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  ethereum: {
    tvl: calculateUsdUniTvl(
      "0x03407772F5EBFB9B10Df007A2DD6FFf4EdE47B53",
      "ethereum",
      "0xf56b164efd3cfc02ba739b719b6526a6fa1ca32a",
      [
        "0x00c83aecc790e8a4453e5dd3b0b4b3680501a7a7", 
        "0x6b175474e89094c44da98b954eedeac495271d0f", 
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 
        "0xfdcdfa378818ac358739621ddfa8582e6ac1adcb",
        "0x46683747b55c4a0ff783b1a502ce682eb819eb75"
      ],
      "curio-governance"
    ),
  },
  curio: {
    tvl: calculateUsdUniTvl(
      "0xc36f5180b181f1b949e0ff4d65b258e0987f443f",
      "curio",
      "0x134EbAb7883dFa9D04d20674dd8A8A995fB40Ced",
      [
        "0x97F5E64c9e46d5F28AeD64C5B42cF8f7CCEEF317",
        "0x2BCEC1888D8c8d9B5955Bf9307a96BdC2122c849",
        "0xb5D8201e187Fd68aF4B54C7662124D93506dE505",
        "0x32ee5d263c76FE335feF85E4c6abE70E8d5CB097",
        "0x8648923e13a01f21852ce46017fe640858e0ad8c",
        "0xd2aaa00700000000000000000000000000000000",
        "0x300b4334cd9fbae70c4aef3abcad30fa31a1bb30"
      ],
      "curio-governance"
    ),
  },
};
'''
'''--- projects/carbon/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const BigNumber = require("bignumber.js");
const { getBlock } = require("../helper/getBlock");

const stakingETHContract = "0x27F0408729dCC6A4672e1062f5003D2a07E4E10D";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";

const stakingCARBONContract = "0x2C5058325373d02Dfd6c08E48d91FcAf8fD49f45";
const CARBON = "0xfa42da1bd08341537a44a4ca9d236d1c00a98b40";

const stakingPool2Contracts = [
  //stakingCARBON_WETHContract
  "0x701e594B58b183b93C1ebaE437fBC9a9A3eC97d7",
  //stakingCARBON_NYANContract
  "0x45acd6Af27B2506ad68C0fEA9F597D6eE6818722",
];
const lpAddresses = [
  //CARBON_WETH_SLP
  "0x08da83452Ae158c3F348d4e0789b7A78989f34eE",
  //CRABON_NYAN_SLP
  "0x89450F6C7d7f2c5971E9Ee28e94d8b199d17f673",
];

const WETH_arb = "0x82af49447d8a07e3bd95bd0d56f35241523fbab1";
const NYAN = "0xed3fb761414da74b74f33e5c5a1f78104b188dfc";

async function pool2(time, ethBlock, chainBlocks) {
  const balances = {};

  for (let idx = 0; idx < lpAddresses.length; idx++) {
    const balances_slp = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: lpAddresses[idx],
        params: stakingPool2Contracts[idx],
        chain: "arbitrum",
        block: chainBlocks["arbitrum"],
      })
    ).output;

    const totalSupply_slp = (
      await sdk.api.erc20.totalSupply({
        target: lpAddresses[idx],
        chain: "arbitrum",
        block: chainBlocks["arbitrum"],
      })
    ).output;

    const underlyingsBalance = (
      await sdk.api.abi.multiCall({
        calls: [CARBON, NYAN, WETH_arb].map((token) => ({
          target: token,
          params: lpAddresses[idx],
        })),
        abi: 'erc20:balanceOf',
        chain: "arbitrum",
        block: chainBlocks["arbitrum"],
      })
    ).output;

    underlyingsBalance.forEach((call) => {
      const underlyingSetBalance = BigNumber(call.output)
        .times(balances_slp)
        .div(totalSupply_slp);

      sdk.util.sumSingleBalance(
        balances,
        `arbitrum:${call.input.target}`,
        underlyingSetBalance.toFixed(0)
      );
    });
  }

  return balances;
}

async function arbTvl(time, _ethBlock, chainBlocks) {
  const block = await getBlock(time, "arbitrum", chainBlocks);
  const eth = await sdk.api.eth.getBalance({
    target: stakingETHContract,
    block,
    chain: "arbitrum",
  });
  return {
    [WETH]: eth.output,
  };
}

module.exports = {
  misrepresentedTokens: true,
  arbitrum: {
    staking: staking(stakingCARBONContract, CARBON, "arbitrum"),
    pool2: pool2,
    tvl: arbTvl,
  },
  methodology:
    "Counts as TVL the ETH asset deposited through StakingETH Contract, and we count Staking and Pool2 parts in the same way",
};

'''
'''--- projects/carbonswap/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology: "Factory address (0x17854c8d5a41d5A89B275386E24B2F38FD0AfbDd) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  energyweb: {
    tvl: getUniTVL({
      chain: 'energyweb',
      factory: '0x17854c8d5a41d5A89B275386E24B2F38FD0AfbDd',
      coreAssets: ['0x6b3bd0478DF0eC4984b168Db0E12A539Cc0c83cd'],
    })
  }
};

'''
'''--- projects/cardstarter/index.js ---
const { staking } = require('../helper/staking');
const { pool2s } = require('../helper/pool2');

const cardsStakeAddr = "0xad2fd18932c39fa5085429853e1f0d39a65a438e";
const lpStakeAddr = "0x7Dca3372A0a236A305FdEC3D48d52B09dff82E14";
const cardsAddr = "0x3d6f0dea3ac3c607b3998e6ce14b6350721752d9";

//cards, c3, and gero in that order
const lpPoolAddrs = ["0x94ae6d2390680ac6e6ee6069be42067d6ad72e2a", "0x984A3eAB3Cf2Fc2b4ca6E4A3768624a8272fe2a3",
  "0x5b6be21c4d1f2c1c5A3d6Af3599f3BB0a785AE2F"];

module.exports = {
  ethereum: {
    tvl: () => ({}),
    staking: staking(cardsStakeAddr, cardsAddr),
    pool2: pool2s([lpStakeAddr], lpPoolAddrs),
  }
}

'''
'''--- projects/caribou-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef")

const token = "0x2dBa3ea510cf7bFCCc9c185b7c9094d687ADE503";
const masterchef = "0x23bd5312cE63AC23651112d3c9638C082aaeAf38";

module.exports = {
    ...masterChefExports(masterchef, "fantom", token, false)
}
'''
'''--- projects/cashcow/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accCowPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cashcow/index.js ---
const abi = require("./abi.json");
const { getCompoundV2Tvl, compoundExports } = require("../helper/compound");
const { transformBscAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");

const comptroller = "0x44f2A790aCB1bE42d3F7864e9F73762556eb895E";
const cBNB = "0xC819cCfA453C4b5D2B9c9fF7CF8017adE99CB9B1";
const WBNBEquivalent = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";

const stakingChef = "0xbfcaB1627c4fB86A055DE4B8a56D46e625F51C0B";

const stakingPools = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  let transformAddress = await transformBscAddress();

  await addFundsInMasterChef(
    balances,
    stakingChef,
    chainBlocks["bsc"],
    "bsc",
    transformAddress,
    abi.poolInfo
  );

  return balances;
};

module.exports = {
  timetravel: true,
  doublecounted: false,
  bsc: {
    staking: stakingPools,
    ...compoundExports(comptroller,
      "bsc",
      cBNB,
      WBNBEquivalent)
  },
  methodology:
    "We count liquidity on the lending markets same as compound; and the Pools (LP Piars) through Chef Contract",
};

'''
'''--- projects/cashcowprotocol/index.js ---
const { transformBscAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");

const MasterChef = "0x94098E24FCf4701237CF58ef2A222C1cF5003c86";

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  let transformAddress = await transformBscAddress();

  await addFundsInMasterChef(
    balances,
    MasterChef,
    chainBlocks["bsc"],
    "bsc",
    transformAddress
  );

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: bscTvl,
  },
  methodology:
    "We count liquidity on the Farms (LP Piars) through MasterChef Contract",
};

'''
'''--- projects/cashio/index.js ---
const utils = require("../helper/utils");
const SUNNY_POOLS = require("../helper/sunny-pools.json");

const {
  getMultipleAccountBuffers,
  getMultipleAccountsRaw,
} = require("../helper/solana");

async function getTotalBalancesFromMultipleAccounts(tokenAccounts) {
  const tokenAccountsData = (await getMultipleAccountsRaw(tokenAccounts))
    .map((account) => {
      if (account !== null) {
        return Buffer.from(account.data[0], account.data[1]);
      }
      return null;
    })
    .filter((d) => !!d);
  return tokenAccountsData
    .map((tad) =>
      // sorry, this code is a tad hacky
      Number(tad.readBigUInt64LE(64))
    )
    .reduce((acc, el) => acc + el, 0);
}

const readTVL = async ({
  tokenA,
  tokenB,
  tokenAReserve,
  tokenBReserve,
  poolMint,
  tokenAccounts,
}) => {
  const accountData = await getMultipleAccountBuffers({
    tokenAReserve,
    tokenBReserve,
    poolMint,
  });
  if (accountData.sunnyPool === null) {
    return {};
  }

  const decimals = accountData.poolMint.readUInt8(44);
  const divisor = 10 ** decimals;

  const tokenAccountsData = (await getMultipleAccountsRaw(tokenAccounts))
    .map((account) => {
      if (account !== null) {
        return Buffer.from(account.data[0], account.data[1]);
      }
      return null;
    })
    .filter((d) => !!d);
  const totalTokens = tokenAccountsData
    .map((tad) =>
      // sorry, this code is a tad hacky
      Number(tad.readBigUInt64LE(64))
    )
    .reduce((acc, el) => acc + el, 0);
  const lpTokenTotalSupply = Number(accountData.poolMint.readBigUInt64LE(36));
  const poolShare = totalTokens / lpTokenTotalSupply;

  const reserveAAmount =
    Number(accountData.tokenAReserve.readBigUInt64LE(64)) / divisor;
  const reserveBAmount =
    Number(accountData.tokenBReserve.readBigUInt64LE(64)) / divisor;

  const poolTvlCoins = {};

  if (tokenA === tokenB) {
    poolTvlCoins[tokenA] =
      poolShare * reserveAAmount + poolShare * reserveBAmount;
  } else {
    poolTvlCoins[tokenA] = poolShare * reserveAAmount;
    poolTvlCoins[tokenB] = poolShare * reserveBAmount;
  }

  return poolTvlCoins;
};

async function tvl() {
  // a mapping of coin name to coin amount
  const tvlResult = {};

  // contains a list of all token accounts + their associated sunny pool or coingecko ID
  // more details: https://github.com/cashioapp/treasury
  const cashioTreasuryAccounts = await utils.fetchURL(
    "https://raw.githubusercontent.com/cashioapp/treasury/master/data/token-accounts.json"
  );

  const { coingeckoTokens, sunnyPools } = cashioTreasuryAccounts.data;

  // fetch all normal tokens (tokens with coingecko IDs)
  for (const [coingeckoID, tokenAccounts] of Object.entries(coingeckoTokens)) {
    const amount =
      (await getTotalBalancesFromMultipleAccounts(tokenAccounts)) / 10 ** 6;
    if (!tvlResult[coingeckoID]) {
      tvlResult[coingeckoID] = amount;
    } else {
      tvlResult[coingeckoID] += amount;
    }
  }

  // Run these serially to avoid rate limiting issues
  for (const [sunnyPoolKey, tokenAccounts] of Object.entries(sunnyPools)) {
    const sunnyPool = SUNNY_POOLS.find(
      (pool) => pool.relevantAccounts.sunnyPool === sunnyPoolKey
    );
    if (!sunnyPool) {
      continue;
    }

    const poolTVL = await readTVL({
      tokenA: sunnyPool.tokenA,
      tokenB: sunnyPool.tokenB,
      tokenAReserve: sunnyPool.relevantAccounts.tokenAReserve,
      tokenBReserve: sunnyPool.relevantAccounts.tokenBReserve,
      poolMint: sunnyPool.relevantAccounts.lpTokenSPL,
      tokenAccounts,
    });

    for (const [tokenId, amount] of Object.entries(poolTVL)) {
      if (!tvlResult[tokenId]) {
        tvlResult[tokenId] = amount;
      } else {
        tvlResult[tokenId] += amount;
      }
    }
  }

  return tvlResult;
}

module.exports = {
  timetravel: false,
  hallmarks: [
    [1647993600, "Infinite mint glitch"]
],
  methodology:
    "TVL counts LP token deposits made to Cashio and accrued reward tokens to its bank. CoinGecko is used to find the price of tokens in USD.",
  solana: { tvl },
};

'''
'''--- projects/catsluck/index.js ---
const sdk = require('@defillama/sdk');
const { getBlock } = require('../helper/getBlock');
const { default: BigNumber } = require('bignumber.js');

const CHAIN = "smartbch"

// token contracts
const CLK = "0x659F04F36e90143fCaC202D4BC36C699C078fC98"

// staking pool addresses
const catsPoolAddress = "0x659F04F36e90143fCaC202D4BC36C699C078fC98"
const bchPoolAddress = "0x4d16fB4811cf8BF7a5d35397527A95911E122611"
const flexusdPoolAddress = "0xC5bBdf3838BA468359a5a97523925350dfcc3599"
const daoPoolAddress = "0x5BBAE609bd2e6E0c6c59401e59B5358F0C1D16b1"
const ebenPoolAddress = "0x404B74F4B945A51FCAcF3B86b28c248aBD9496eB"
const mistPoolAddress = "0xFbc43093c71c960F26Eed32Ec73F3d096F02C053"
const tangoPoolAddress = "0x43A4a713e3248Ab6CB05EB9c817355Ea85E580Ca"
const lawPoolAddress = "0x3F52E5e897AfC6e7BF8C6A4e88f86fc6B9Ce645b"

// [[pool address, coingecko-id, decimals]]
const stakingPools = [
    [catsPoolAddress, "cashcats", 2],
    [bchPoolAddress, "bitcoin-cash", 18],
    [flexusdPoolAddress, "flex-usd", 18],
    [daoPoolAddress, 'decentralized-autonomous-organization', 7],
    [ebenPoolAddress, "green-ben", 18],
    [mistPoolAddress, "mistswap", 18],
    [tangoPoolAddress, "tangoswap", 18],
    [lawPoolAddress, "law", 18]
]

// "function info(address addr) external view returns (uint, uint, uint)""
const poolInfoAbi = {
    "inputs": [
      {
        "internalType": "address",
        "name": "addr",
        "type": "address"
      },
    ],
    "name": "info",
    "outputs": [
      {
        "internalType": "uint",
        "name": "totalBalance",
        "type": "uint"
      },
      {
        "internalType": "uint",
        "name": "totalShare",
        "type": "uint"
      },
      {
        "internalType": "uint",
        "name": "sharesAndLockUntil",
        "type": "uint"
      },
    ],
    "stateMutability": "view",
    "type": "function"
  }

const tvl = async (timestamp, ethBlock, chainBlocks) => {
    const block = await getBlock(timestamp, CHAIN, chainBlocks, false)

    const totals = await Promise.all(stakingPools.map(async (pool) => {
        const [poolAddress, addr, decimals] = pool;
        const total = (await sdk.api.abi.call({
            target: poolAddress,
            params: [bchPoolAddress],
            abi: poolInfoAbi,
            chain: CHAIN,
            block
        })).output.totalBalance

        return {[addr]: BigNumber(total).dividedBy(10 ** decimals).toNumber()}
    }))
    return totals.reduce((a, b) => ({...a, ...b}), {})
}

module.exports = {
    misrepresentedTokens: true,
    methodology: "Total value of non-native tokens staked in prediction pools is counted towards tvl metric.",
    smartbch: {
        tvl: tvl,
    },
}

'''
'''--- projects/celerbridge/index.js ---
const { getBlock } = require("../helper/getBlock");
const { chainExports } = require("../helper/exports");
const { sumTokens } = require("../helper/unwrapLPs");
const { getFixBalances } = require('../helper/portedTokens')
const ethers = require("ethers")
const { config } = require('@defillama/sdk/build/api');

const bridgeContractV1 = "0x841ce48F9446C8E281D3F1444cB859b4A6D0738C";
config.setProvider("clv", new ethers.providers.StaticJsonRpcProvider(
  "https://api-para.clover.finance",
  {
    name: "clv",
    chainId: 1024,
  }
))

// Bridge and token contract addresses are taken from https://cbridge-docs.celer.network/reference/contract-addresses
const liquidityBridgeContractsV2 = {
  // NOTE: Some chains have addresses before and after the liquidity bridge upgrade / migration
  arbitrum: [
    "0xdd90E5E87A2081Dcf0391920868eBc2FFB81a1aF",
    "0x1619DE6B6B20eD217a58d00f37B9d47C7663feca",
    "0xFe31bFc4f7C9b69246a6dc0087D91a91Cb040f76",
    "0xEA4B1b0aa3C110c55f650d28159Ce4AD43a4a58b",
  ],
  astar: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  aurora: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C", "0xbCfeF6Bb4597e724D720735d32A9249E0640aA11",],
  avax: [
    "0xBB7684Cc5408F4DD0921E5c2Cadd547b8f1AD573",
    "0xef3c714c9425a8F3697A9C969Dc1af30ba82e5d4",
    "0x5427FEFA711Eff984124bFBB1AB6fbf5E3DA1820",
    "0xb51541df05DE07be38dcfc4a80c05389A54502BB",
  ],
  boba: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C", '0x8db213bE5268a2b8B78Af08468ff1EA422073Da0', '0x4C882ec256823eE773B25b414d36F92ef58a7c0C'],
  bsc: [
    "0x5d96d4287D1ff115eE50faC0526cf43eCf79bFc6",
    "0xdd90E5E87A2081Dcf0391920868eBc2FFB81a1aF",
    "0x78bc5Ee9F11d133A08b331C2e18fE81BE0Ed02DC",
    "0x11a0c9270D88C99e221360BCA50c2f6Fda44A980",
  ],
  celo: ["0xBB7684Cc5408F4DD0921E5c2Cadd547b8f1AD573", '0xD9d1034ef3d21221F008C7e96346CA999966752C'],
  clv: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  conflux: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  ethereum: [
    "0xc578Cbaf5a411dFa9F0D227F97DaDAa4074aD062",
    "0x5427FEFA711Eff984124bFBB1AB6fbf5E3DA1820",
    "0xb37d31b2a74029b5951a2778f959282e2d518595",
    "0x7510792A3B1969F9307F3845CE88e39578f2bAE1",
  ],
  fantom: [
    "0x3795C36e7D12A8c252A20C5a7B455f7c57b60283",
    "0x374B8a9f3eC5eB2D97ECA84Ea27aCa45aa1C57EF",
    "0x7D91603E79EA89149BAf73C9038c51669D8F03E9",
  ],
  harmony: ["0x78a21C1D3ED53A82d4247b9Ee5bF001f4620Ceec"],
  heco: ["0xBB7684Cc5408F4DD0921E5c2Cadd547b8f1AD573", "0x5d96d4287D1ff115eE50faC0526cf43eCf79bFc6"],
  metis: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  milkomeda: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  moonbeam: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  moonriver: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  oasis: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  okexchain: ["0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98"],
  optimism: [
    "0x6De33698e9e9b787e09d3Bd7771ef63557E148bb",
    "0x9D39Fc627A6d9d9F8C831c16995b209548cc3401",
    "0xbCfeF6Bb4597e724D720735d32A9249E0640aA11",
  ],
  polygon: [
    "0xa251c4691C1ffd7d9b128874C023427513D8Ac5C",
    "0x88DCDC47D2f83a99CF0000FDF667A468bB958a78",
    "0xc1a2D967DfAa6A10f3461bc21864C23C1DD51EeA",
  ],
  rei: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C"],
  shiden: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C", "0xBB7684Cc5408F4DD0921E5c2Cadd547b8f1AD573",],
  syscoin: ["0x841ce48F9446C8E281D3F1444cB859b4A6D0738C", "0x1E6b1ceAF75936f153ABB7B65FBa57AbaE14e6CE"],
  xdai: ["0x3795C36e7D12A8c252A20C5a7B455f7c57b60283"],
};

// Tokens added to the liquidity bridges, excluding Celer-Pegged tokens.
const liquidityBridgeTokens = [
  {
    // USDT
    arbitrum: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
    aurora: "0x4988a896b1227218e4A686fdE5EabdcAbd91571f",
    avax: "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
    bsc: "0x55d398326f99059ff775485246999027b3197955",
    ethereum: "0xdac17f958d2ee523a2206206994597c13d831ec7",
    fantom: "0x049d68029688eabf473097a2fc38ef61633a3c7a",
    heco: "0xa71edc38d189767582c38a3145b5873052c3e47a",
    okexchain: "0x382bb369d343125bfb2117af9c149795c6c65c50",
    optimism: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
    polygon: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    xdai: "0x4ECaBa5870353805a9F068101A40E0f32ed605C6",
  },
  {
    // USDC
    arbitrum: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
    aurora: "0xB12BFcA5A55806AaF64E99521918A4bf0fC40802",
    avax: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
    boba: "0x66a2A913e447d6b4BF33EFbec43aAeF87890FBbc",
    bsc: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
    ethereum: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    fantom: "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
    harmony: "0x985458e523db3d53125813ed68c274899e9dfab4",
    heco: "0x9362bbef4b8313a8aa9f0c9808b80577aa26b73b",
    okexchain: "0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85",
    optimism: "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
    polygon: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
    xdai: "0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83",
  },
  {
    // BUSD
    ethereum: "0x4fabb145d64652a948d72533023f6e7a623c7c53",
    bsc: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
  },
  {
    // DAI
    avax: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
    bsc: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
    ethereum: "0x6b175474e89094c44da98b954eedeac495271d0f",
    optimism: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
    polygon: "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
  },
  {
    // WETH
    arbitrum: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    avax: "0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB",
    bsc: "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
    ethereum: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    fantom: "0x74b23882a30290451A17c44f4F05243b6b58C76d",
    optimism: "0x4200000000000000000000000000000000000006",
    polygon: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
  },
  {
    // WBTC
    arbitrum: "0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f",
    avax: "0x50b7545627a5162F82A992c33b87aDc75187B218",
    ethereum: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
    fantom: "0x321162Cd933E2Be498Cd2267a90534A804051b11",
    polygon: "0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",
  },
  {
    // DODO
    arbitrum: "0x69eb4fa4a2fbd498c257c57ea8b7655a2559a581",
    bsc: "0x67ee3cb086f8a16f34bee3ca72fad36f7db929e2",
    ethereum: "0x43Dfc4159D86F3A37A5A4B3D4580b888ad7d4DDd",
  },
  {
    // MCB
    arbitrum: "0x4e352cf164e64adcbad318c3a1e222e9eba4ce42",
    ethereum: "0x4e352cF164E64ADCBad318C3a1e222E9EBa4Ce42",
  },
  {
    // CELR
    arbitrum: "0x3a8B787f78D775AECFEEa15706D4221B40F345AB",
    bsc: "0x1f9f6a696c6fd109cd3956f45dc709d2b3902163",
    ethereum: "0x4f9254c83eb525f9fcf346490bbb3ed28a81c667",
  },
  {
    // IF
    bsc: "0xb0e1fc65c1a741b4662b813eb787d369b8614af1",
    ethereum: "0xb0e1fc65c1a741b4662b813eb787d369b8614af1",
  },
  {
    // LYRA
    ethereum: "0x01ba67aac7f75f647d94220cc98fb30fcc5105bf",
    optimism: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
  },
  {
    // IMX
    arbitrum: "0x9c67ee39e3c4954396b9142010653f17257dd39c",
    avax: "0xeA6887e4a9CdA1B77E70129E5Fba830CdB5cdDef",
    ethereum: "0x7b35ce522cb72e4077baeb96cb923a5529764a00",
    harmony: "0xbd8064cdb96c00a73540922504f989c64b7b8b96",
    moonriver: "0x900f1Ec5819FA087d368877cD03B265Bf1802667",
    polygon: "0x60bb3d364b765c497c8ce50ae0ae3f0882c5bd05",
  },
  {
    // DOMI
    ethereum: "0x45C2F8c9B4c0bDC76200448cc26C48ab6ffef83F",
  },
  {
    // BOBA
    boba: "0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7",
    ethereum: "0x42bbfa2e77757c645eeaad1655e0911a7553efbc",
  },
  {
    // XTK
    arbitrum: "0xF0A5717Ec0883eE56438932b0fe4A20822735fBa",
    ethereum: "0x7f3edcdd180dbe4819bd98fee8929b5cedb3adeb",
  },
  {
    // xXTKa
    arbitrum: "0xd8083e393985530b7cf6798d44a2f1536e211ab6",
    ethereum: "0x314022E24ceD941781DC295682634B37Bd0d9cFc",
  },
  {
    // METIS
    ethereum: "0x9e32b13ce7f2e80a01932b42553652e053d6ed8e",
    metis: "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000",
  },
  {
    // CVP
    bsc: "0x5ec3adbdae549dce842e24480eb2434769e22b2e",
    ethereum: "0x38e4adb44ef08f22f5b5b76a8f0c2d0dcbe7dca1",
  },
  {
    // CEC
    bsc: "0x957c49a76b3e008637ca1cce23188a8ce884911e",
    ethereum: "0x9e564eb5550E1A9b1448D916fd85a8d876661bdC",
  },
  {
    // STND
    ethereum: "0x9040e237c3bf18347bb00957dc22167d0f2b999d",
    metis: "0xc12caC7090baa48Ec750CceeC57C80768F6ee58E",
  },
  {
    // WOO
    arbitrum: "0xcafcd85d8ca7ad1e1c6f82f651fa15e33aefd07b",
    avax: "0xabc9547b534519ff73921b1fba6e672b5f58d083",
    bsc: "0x4691937a7508860f876c9c0a2a617e7d9e945d4b",
    ethereum: "0x4691937a7508860f876c9c0a2a617e7d9e945d4b",
    fantom: "0x6626c47c00f1d87902fc13eecfac3ed06d5e8d8a",
    polygon: "0x1B815d120B3eF02039Ee11dC2d33DE7aA4a8C603",
  },
  {
    // DF
    arbitrum: "0xaE6aab43C4f3E0cea4Ab83752C278f8dEbabA689",
    bsc: "0x4a9a2b2b04549c3927dd2c9668a5ef3fca473623",
    ethereum: "0x431ad2ff6a9c365805ebad47ee021148d6f7dbe0",
    optimism: "0x9e5AAC1Ba1a2e6aEd6b32689DFcF62A509Ca96f3",
    polygon: "0x08C15FA26E519A78a666D19CE5C646D55047e0a3",
  },
  {
    // USX
    arbitrum: "0x641441c631e2F909700d2f41FD87F0aA6A6b4EDb",
    bsc: "0xb5102cee1528ce2c760893034a4603663495fd72",
    ethereum: "0x0a5e677a6a24b2f1a2bf4f3bffc443231d2fdec8",
    optimism: "0xbfD291DA8A403DAAF7e5E9DC1ec0aCEaCd4848B9",
    polygon: "0xCf66EB3D546F0415b368d98A95EAF56DeD7aA752",
  },
  {
    // PERP
    arbitrum: "0x753d224bcf9aafacd81558c32341416df61d3dac",
    bsc: "0x4e7f408be2d4e9d60f49a64b89bb619c84c7c6f5",
    ethereum: "0xbc396689893d065f41bc2c6ecbee5e0085233447",
    optimism: "0x9e1028f5f1d5ede59748ffcee5532509976840e0",
  },
  {
    // KROM
    arbitrum: "0x55ff62567f09906a85183b866df84bf599a4bf70",
    ethereum: "0x3af33bef05c2dcb3c7288b77fe1c8d2aeba4d789",
    optimism: "0xf98dcd95217e15e05d8638da4c91125e59590b07",
    polygon: "0x14Af1F2f02DCcB1e43402339099A05a5E363b83c",
  },
  {
    // TCR
    arbitrum: "0xa72159fc390f0e3c6d415e658264c7c4051e9b87",
    ethereum: "0x9c4a4204b79dd291d6b6571c5be8bbcd0622f050",
  },
  {
    // PKEX
    ethereum: "0xe6f143a0e0a8f24f6294ce3432ea10fad0206920",
  },
  {
    // ZLK
    moonbeam: "0x3fd9b6c9a24e09f67b7b706d72864aebb439100c",
    moonriver: "0x0f47ba9d9bde3442b42175e51d6a367928a1173b",
  },
  {
    // PERL
    bsc: "0x0f9e4d49f25de22c2202af916b681fbb3790497b",
    ethereum: "0xeca82185adce47f39c684352b0439f030f860318",
  },
  {
    // BMI
    bsc: "0x3e1b4Ff4AE3Ab8f0Cb40a34a6ad3fC817F7dA2b6",
    ethereum: "0x725c263e32c72ddc3a19bea12c5a0479a81ee688",
    polygon: "0x3e1b4Ff4AE3Ab8f0Cb40a34a6ad3fC817F7dA2b6",
  },
  {
    // JPEG
    avax: "0x6241af3817Db48a7F9E19FD9446d78E50936d275",
    bsc: "0x4bfce5a1acc3b847afa9579ba91da33b08e66fb7",
    ethereum: "0x4bfce5a1acc3b847afa9579ba91da33b08e66fb7",
  },
  {
    // MASK
    bsc: "0x2eD9a5C8C13b93955103B9a7C167B67Ef4d568a3",
    ethereum: "0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074",
  },
  {
    // REEF
    bsc: "0xF21768cCBC73Ea5B6fd3C687208a7c2def2d966e",
    ethereum: "0xFE3E6a25e6b192A42a44ecDDCd13796471735ACf",
  },
  {
    // THALES
    ethereum: "0x8947da500Eb47F82df21143D0C01A29862a8C3c5",
    optimism: "0x217D47011b23BB961eB6D93cA9945B7501a5BB11",
  },
  {
    // TORN
    bsc: "0x1ba8d3c4c219b124d351f603060663bd1bcd9bbf",
    ethereum: "0x77777FeDdddFfC19Ff86DB637967013e6C6A116C",
  },
  {
    // HUH
    bsc: "0xc15e89f2149bCC0cBd5FB204C9e77fe878f1e9b2",
    ethereum: "0x86D49fbD3B6f989d641E700a15599d3b165002AB",
    polygon: "0x08648471B5AAd25fEEeb853d6829048f3Fc37786",
  },
  {
    // iZi
    arbitrum: "0x60D01EC2D5E98Ac51C8B4cF84DfCCE98D527c747",
    bsc: "0x60D01EC2D5E98Ac51C8B4cF84DfCCE98D527c747",
    ethereum: "0x9ad37205d608B8b219e6a2573f922094CEc5c200",
  },
  {
    // ESW
    astar: "0xb361DAD0Cc1a03404b650A69d9a5ADB5aF8A531F",
    aurora: "0xd2Fa7C9386040f260e3Ec934601982aD4Cd7902B",
    ethereum: "0x5a75A093747b72a0e14056352751eDF03518031d",
    polygon: "0xd2A2a353D28e4833FAFfC882f6649c9c884a7D8f",
    shiden: "0xb4BcA5955F26d2fA6B57842655d7aCf2380Ac854",
  },
  {
    // ASVA
    bsc: "0xF7b6d7E3434cB9441982F9534E6998C43eEF144a",
    polygon: "0xE7E0bA6f84D843d17Cb8410810Bf3E8Bcda0caA1",
  },
  {
    // ANML
    ethereum: "0x38B0e3A59183814957D83dF2a97492AED1F003e2",
    polygon: "0xEcc4176B90613Ed78185f01bd1E42C5640C4F09d",
  },
  {
    // GOVI
    arbitrum: "0x07E49d5dE43DDA6162Fa28D24d5935C151875283",
    ethereum: "0xeEAA40B28A2d1b0B08f6f97bB1DD4B75316c6107",
    polygon: "0x43Df9c0a1156c96cEa98737b511ac89D0e2A1F46",
  },
  {
    // PEOPLE
    ethereum: "0x7a58c0be72be218b41c608b7fe7c5bb630736c71",
  },
  {
    // SOS
    ethereum: "0x3b484b82567a09e2588a13d54d032153f0c0aee0",
  },
  {
    // OLO
    boba: "0x5008F837883EA9a07271a1b5eB0658404F5a9610",
  },
  {
    // oneDODO
    ethereum: "0xcA37530E7c5968627BE470081d1C993eb1dEaf90",
  },
  {
    // cUSD
    celo: "0x765DE816845861e75A25fCA122bb6898B8B1282a",
  },
  {
    // WSYS
    // origin: "syscoin:0xd3e822f3ef011Ca5f17D82C956D952D8d7C3A1BB",
    syscoin: "0xd3e822f3ef011Ca5f17D82C956D952D8d7C3A1BB",
    bsc: "0x6822A778726CD2f0d4A1Cfaca2D04654e575cC82",
    ethereum: "0xF3C96924d85566C031ddc48DbC63B2d71da6D0f6",
  },
  {
    // PSP
    ethereum: "0xcAfE001067cDEF266AfB7Eb5A286dCFD277f3dE5",
    bsc: "0xcAfE001067cDEF266AfB7Eb5A286dCFD277f3dE5",
  },
  {
    // WXT
    ethereum: "0xa02120696c7b8fe16c09c749e4598819b2b0e915",
  },
  {
    // FRAX
    ethereum: "0x853d955acef822db058eb8505911ed77f175b99e",
  },
  {
    // FXS
    ethereum: "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0",
  },
  {
    // MAI
    polygon: "0xa3fa99a148fa48d14ed51d610c367c61876997f1",
  },
  {
    // ATL
    bsc: "0x1fD991fb6c3102873ba68a4e6e6a87B3a5c10271",
  },
  {
    // BNB
    bsc: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  },
  {
    // AVAX
    avax: "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
  },
  {
    // FTM
    fantom: "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
  },
  {
    // AMY
    arbitrum: "0x8fbd420956fdd301f4493500fd0bcaaa80f2389c",
  },
  {
    // GHX
    ethereum: "0x728f30fa2f100742c7949d1961804fa8e0b1387d",
  },
  {
    // SAFLE
    polygon: "0x04b33078ea1aef29bf3fb29c6ab7b200c58ea126",
  },
  {
    // WREVA
    bsc: "0xec81aa154d470c6857219b529de3f1d755ee2ae7",
  },
  {
    // MARK
    heco: "0x779a8134750809F79Cf0Ba48ee0fF1A5c41a8fDC",
  },
  {
    // PLATO
    heco: "0x4668e0E7cC545De886aBF038067F81cD4DC0924b",
  },
  {
    // SDN
    // origin: "shiden:0x0f933dc137d21ca519ae4c7e93f87a4c8ef365ef",
    shiden: "0x0f933dc137d21ca519ae4c7e93f87a4c8ef365ef",
  },
  {
    // CONV
    ethereum: "0xc834fa996fa3bec7aad3693af486ae53d8aa8b50",
  },
  {
    // TSD
    avax: "0x4fbf0429599460d327bd5f55625e30e4fc066095",
  },
  {
    // MATIC
    polygon: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
  },
  {
    // AAVE
    ethereum: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
  },
  {
    // CRV
    ethereum: "0xD533a949740bb3306d119CC777fa900bA034cd52",
  },
  {
    // AVG
    ethereum: "0xa41f142b6eb2b164f8164cae0716892ce02f311f",
  },
  {
    // AELIN
    optimism: "0x61baadcf22d2565b0f471b291c475db5555e0b76",
  },
  {
    // CGG
    ethereum: "0x1fe24f25b1cf609b9c4e7e12d802e3640dfa5e43",
  },
  {
    // REVA
    bsc: "0x4FdD92Bd67Acf0676bfc45ab7168b3996F7B4A3B",
  },
  {
    // IMX
    ethereum: "0x7b35ce522cb72e4077baeb96cb923a5529764a00",
  },
  {
    // WAGMIv1
    boba: "0xCe055Ea4f29fFB8bf35E852522B96aB67Cbe8197",
  },
  {
    // LUSD
    ethereum: "0x5f98805A4E8be255a32880FDeC7F6728C6568bA0",
  },
  {
    // JONES
    arbitrum: "0x10393c20975cF177a3513071bC110f7962CD67da",
  },
  {
    // SWAY
    polygon: "0x262B8AA7542004f023B0eB02bc6b96350A02b728",
  },
  {
    // JADE
    bsc: "0x7ad7242A99F21aa543F9650A56D141C57e4F6081",
  },
  {
    // MELOS
    ethereum: "0x1afb69DBC9f54d08DAB1bD3436F8Da1af819E647",
  },
  {
    // MSU
    ethereum: "0xdfD8D604951eBF1b2297285F1B68de140C43992b",
  },
  {
    // UCG
    ethereum: "0x7D92a06808B4c4833623F809218ed403e4A85FE1",
  },
  {
    // MGH
    ethereum: "0x8765b1A0eb57ca49bE7EACD35b24A574D0203656",
  },
  {
    // ASTR
    astar: "0xAeaaf0e2c81Af264101B9129C00F4440cCF0F720",
  },
  {
    // ANML
    ethereum: "0x38B0e3A59183814957D83dF2a97492AED1F003e2",
  },
  {
    // BLANK
    ethereum: "0x41A3Dba3D677E573636BA691a70ff2D606c29666",
  },
];

function chainTvl(chain) {
  return async (time, _, chainBlocks) => {
    const block = await getBlock(time, chain, chainBlocks, true);
    const toa = []
    liquidityBridgeTokens.forEach(token => {
      if (!token[chain])
        return;
      toa.push([token[chain], bridgeContractV1])
      if (liquidityBridgeContractsV2[chain])
        liquidityBridgeContractsV2[chain].filter(owner => owner.toLowerCase() !== bridgeContractV1.toLowerCase())
          .forEach(owner => toa.push([token[chain], owner]))
    })
    const balances = await sumTokens({}, toa, block, chain)
    const fixBalances = await getFixBalances(chain)
    fixBalances(balances)
    return balances
  };
}

let chains = liquidityBridgeTokens.reduce((allChains, token) => {
  Object.keys(token).forEach((key) => allChains.add(key));
  return allChains;
}, new Set());

Object.keys(liquidityBridgeContractsV2).forEach(chain => chains.add(chain))

module.exports = chainExports(chainTvl, Array.from(chains));
module.exports.methodology = `Tokens bridged via cBridge are counted as TVL`;
module.exports.misrepresentedTokens = true;

'''
'''--- projects/celery/index.js ---
const { staking } = require('../helper/staking')

const CHAIN = "smartbch"

// token contract
const CLY = "0x7642df81b5beaeeb331cc5a104bd13ba68c34b91"

module.exports = {
    misrepresentedTokens: false,
    methodology: "Staked CLY tokens are counted towards staking metric",
    smartbch: {
        tvl: () => ({}),
        staking: staking(CLY, CLY, CHAIN, "celery", 18),
    },
}

'''
'''--- projects/cemetery/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const hauntchef = "0xe5483461a024524e0a76B935A56B8D161E3F0D82"
const haunt = "0x8bD04EE83a6076d1216237C8B91f7EeE3AccaB35"
const hauntFtmLP = "0xd366d2af991755c0bd4f18ec13a3169a3d8a027e"
const hauntUsdcLP = "0x95b70d9ed25ffe2560b8ab182ec71bc712f55c72";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, hauntchef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [haunt, hauntFtmLP, hauntUsdcLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(hauntchef, haunt, "fantom"),
      pool2: pool2Exports(hauntchef, [hauntFtmLP, hauntUsdcLP], "fantom"),
  },
  
} 

'''
'''--- projects/cennz-bridge.js ---
const sdk = require("@defillama/sdk");
const target = '0x76BAc85e1E82cd677faa2b3f00C4a2626C4c6E32';
const WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';

async function tvl(timestamp, block) {
    return { [ WETH ]: 
        (await sdk.api.eth.getBalance({ target, block })).output 
    };
};

module.exports = {
    methodology: "Tracks funds locked in the ERC20Peg contract on Ethereum",
    ethereum: {
        tvl
    }
}; // node test.js projects/cennz-bridge.js
'''
'''--- projects/cerberusdao/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0x56D595ea5591D264bc1Ef9E073aF66685F0bFD31"
module.exports = {
    deadFrom: 1648765747,
    ...ohmTvl(treasury, [
    //SHIB
    ["0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE", false],
    //FLOKI
    ["0x43f11c02439e2736800433b4594994bd43cd066d", false],
    //WETH
    ["0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", false],
    //uniswap LP shib/weth
    ["0xb5b6c3816c66fa6bc5b189f49e5b088e2de5082a", true],
   ], "ethereum", "0x95deaF8dd30380acd6CC5E4E90e5EEf94d258854", "0x8a14897eA5F668f36671678593fAe44Ae23B39FB")
}
'''
'''--- projects/cesta/abi.json ---
{
  "getAllPoolInUSD": {
    "inputs": [],
    "name": "getAllPoolInUSD",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/cesta/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

async function avax(timestamp, block) {
  const CestaVault = {
    DexAvax: "0xe4809ed214631017737a3d7fa3e78600ee96eb85",
    DexStable: "0xcfDafB1E6310c1844EcC30C60A01D6E0D37368C5",
    StableAvax: "0xfbE9613a6bd9d28ceF286b01357789b2b02E46f5",
    StableStable: "0xB103F669E87f67376FB9458A67226f2774a0B4FD",
  };
  let usd = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";

  let [DexAvaxTVL, DexStableTVL, StableAvaxTVL, StableStableTVL] =
    await Promise.all([
      sdk.api.abi.call({
        block,
        target: CestaVault.DexAvax,
        abi: abi["getAllPoolInUSD"],
        chain: "avax",
      }),
      sdk.api.abi.call({
        block,
        target: CestaVault.DexStable, // contract address
        abi: abi["getAllPoolInUSD"], // erc20:methodName
        chain: "avax",
      }),
      sdk.api.abi.call({
        block,
        target: CestaVault.StableAvax, // contract address
        abi: abi["getAllPoolInUSD"], // erc20:methodName
        chain: "avax",
      }),
      sdk.api.abi.call({
        block,
        target: CestaVault.StableStable, // contract address
        abi: abi["getAllPoolInUSD"], // erc20:methodName
        chain: "avax",
      }),
    ]);

  DexAvaxTVL = parseInt(DexAvaxTVL.output) / 10 ** 12;
  DexStableTVL = parseInt(DexStableTVL.output) / 10 ** 12;
  StableAvaxTVL = parseInt(StableAvaxTVL.output) / 10 ** 12;
  StableStableTVL = parseInt(StableStableTVL.output) / 10 ** 12;

  const result = {
    "Dex-Avax Vault": DexAvaxTVL,
    "Dex-StableCoin Vault": DexStableTVL,
    "StableCoin-Avax Vault": StableAvaxTVL,
    "StableCoin Vault": StableStableTVL,
  };

  let balances = 0;
  for (const prop in result) {
    balances += result[prop];
  }
  let tk = usd;
  return { [tk]: balances };
}

module.exports = {
  avax: {
    tvl: avax,
  },
};

'''
'''--- projects/cgo-finance/index.js ---
const sdk = require('@defillama/sdk');
const chefAbi = require('./vaultChefAbi.json')
const tokenAbi = require("../helper/abis/token.json");
const token0Abi = require("../helper/abis/token0.json");
const token1Abi = require("../helper/abis/token1.json");
const getReservesAbi = require("../helper/abis/getReserves.json");
const strategyAbi =  require('./strategyAbi.json')

const { unwrapUniswapLPs, unwrapLPsAuto, isLP } = require('../helper/unwrapLPs')
const { getBlock } = require('../helper/getBlock');
const { default: BigNumber } = require('bignumber.js');
const { getChainTransform, getFixBalances } = require('../helper/portedTokens');

// --- Cronos Addresses ---
const VaultChefContractCronos = "0x5795BE23A2C330209849e0D1D19cc05755E23Ca2";
const CGO_Cronos = "0x869c3e35Ef9E5F50003D9a2A80f1D61d670D4CB6";

async function getSymbolsAndBalances(block, chain, poolInfo, wantLockedTotal = strategyAbi.wantLockedTotal) {
  const [symbols, tokenBalances] = await Promise.all([
      sdk.api.abi.multiCall({
          block,
          calls: poolInfo.map(p => ({
              target: p.output[0]
          })),
          abi: 'erc20:symbol',
          chain,
      }),
      sdk.api.abi.multiCall({
          block,
          calls: poolInfo.map(p => ({
              target: p.output[4]              
          })),
          abi: wantLockedTotal,
          chain,
      })
  ])
  return [symbols, tokenBalances]
}

async function getPoolInfo(
  vaultChef, 
  block,
  chain, 
  poolInfoAbi = chefAbi.poolInfo
){
  const poolLength = (
    await sdk.api.abi.call({
        abi: chefAbi.poolLength,
        target: vaultChef,
        block,
        chain,
    })
  ).output;

  const poolInfo = (
    await sdk.api.abi.multiCall({
        block,
        calls: Array.from(Array(Number(poolLength)).keys()).map(i => ({
            target: vaultChef,
            params: i,
        })),
        abi: poolInfoAbi,
        chain,
    })
  ).output;

  return poolInfo
}

function vaultMasterChefExports(masterChef, 
  chain, 
  stakingTokenRaw, 
  poolInfoAbi = chefAbi.poolInfo, 
  wantLockedTotalAbi = strategyAbi.wantLockedTotal,
  tokenIsOnCoingecko = true) {

  const stakingToken = stakingTokenRaw.toLowerCase();
  let balanceResolve;

  async function getTvl(timestamp, ethBlock, chainBlocks) {
    const block = await getBlock(timestamp, chain, chainBlocks, true)
    const transformAddress = await getChainTransform(chain);

    const poolInfo = await getPoolInfo(masterChef, block, chain, poolInfoAbi)
    const [symbols, tokenBalances] = await getSymbolsAndBalances(block, chain, poolInfo, wantLockedTotalAbi);

    const balances = {
      staking: {},
      pool2: {},
      tvl: {}
    } 

    const lpPositions = [];

    await Promise.all(symbols.output.map(async (symbol, idx) => {
      const balance = tokenBalances.output[idx].output;
      const token = symbol.input.target.toLowerCase();
      if (token === stakingToken) {
          sdk.util.sumSingleBalance(balances.staking, transformAddress(token), balance)
      } else if (isLP(symbol.output, symbol.input.target, chain)) {
          lpPositions.push({
              balance,
              token
          });
      } else {
          sdk.util.sumSingleBalance(balances.tvl, transformAddress(token), balance)
      }
    }));

    const [token0, token1] = await Promise.all([
      sdk.api.abi.multiCall({
          calls: lpPositions.map(p => ({
              target: p.token
          })),
          abi: token0Abi,
          block,
          chain
      }),
      sdk.api.abi.multiCall({
          calls: lpPositions.map(p => ({
              target: p.token
          })),
          abi: token1Abi,
          block,
          chain
      }),
    ]);

    const pool2LpPositions = []
    const outsideLpPositions = []
    lpPositions.forEach((position, idx) => {
        if (token0.output[idx].output.toLowerCase() === stakingToken || token1.output[idx].output.toLowerCase() === stakingToken) {
            pool2LpPositions.push(position);
        } else {
            outsideLpPositions.push(position);
        }
    })
    await Promise.all([unwrapUniswapLPs(
        balances.tvl,
        outsideLpPositions,
        block,
        chain,
        transformAddress
    ), unwrapUniswapLPs(
        balances.pool2,
        pool2LpPositions,
        block,
        chain,
        transformAddress
    )]);

    if (!tokenIsOnCoingecko && pool2LpPositions.length) {
      const response = (await sdk.api.abi.multiCall({
          calls: pool2LpPositions.map(p => ({
              target: stakingToken,
              params: [p.token]
          })),
          abi: "erc20:balanceOf",
          block,
          chain
      })).output
      const maxPool2ByToken = response.reduce((max, curr) => {
          if (BigNumber(curr.output).gt(max.output)) {
              return curr
          }
          return max
      });
      const poolAddress = maxPool2ByToken.input.params[0].toLowerCase()
      const poolReserves = await sdk.api.abi.call({
          block,
          chain,
          abi: getReservesAbi,
          target: poolAddress
      })
      const posToken0 = token0.output.find(t => t.input.target.toLowerCase() === poolAddress).output;
      const posToken1 = token1.output.find(t => t.input.target.toLowerCase() === poolAddress).output;
      let price, otherToken;
      if (posToken0.toLowerCase() === stakingToken) {
          price = poolReserves.output[1] / poolReserves.output[0]
          otherToken = transformAddress(posToken1)
      } else {
          price = poolReserves.output[0] / poolReserves.output[1]
          otherToken = transformAddress(posToken0)
      }
      const transformedStakingToken = transformAddress(stakingToken)
      Object.values(balances).forEach(balance => {
          Object.entries(balance).forEach(([addr, bal]) => {
              if (addr.toLowerCase() === transformedStakingToken) {
                  balance[otherToken] = BigNumber(bal).times(price).toFixed(0)
                  delete balance[addr]
              }
          })
      })
    }

    if (['cronos'].includes(chain)) {
      const fixBalances = await getFixBalances(chain)
      Object.values(balances).map(fixBalances)
    }

    return balances
  };

  function getTvlPromise(key) {
    return async (ts, _block, chainBlocks) => {
        if (!balanceResolve)
            balanceResolve = getTvl(ts, _block, chainBlocks)
        return (await balanceResolve)[key]
    }
  }

  return {
      methodology: "TVL includes all farms in MasterChef contract",
      [chain]: {
          staking: getTvlPromise("staking"),
          pool2: getTvlPromise("pool2"),
          masterchef: getTvlPromise("tvl"),
          tvl: getTvlPromise("tvl"),
      }
  };
}

module.exports = {
  misrepresentedTokens: true,
  ...vaultMasterChefExports(VaultChefContractCronos, "cronos", CGO_Cronos, 
  chefAbi.poolInfo, 
  strategyAbi.wantLockedTotal,
  false),
  methodology:
    "TVL includes all farms in MasterChef contract",
};
'''
'''--- projects/cgo-finance/strategyAbi.json ---
{
    "wantLockedTotal" : {
        "inputs": [],
        "name": "wantLockedTotal",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cgo-finance/vaultChefAbi.json ---
{
    "poolInfo" : {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "want",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accCGOPerShare",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "strat",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength" : {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cgx-finance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

// --- Cronos Addresses ---
const MasterChefContractCronos = "0xd6b3bf54ef015259cc92880cd639c1f3c22e2b85";
const CGX_Cronos = "0x40ff4581cf2d6e4e07b02034105d6435d4f3f84c";

module.exports = {
  misrepresentedTokens: true,
  ...masterChefExports(MasterChefContractCronos, "cronos", CGX_Cronos, false),
  methodology:
    "TVL includes all Farms and Pools seccion through MasterChef Contracts",
};

'''
'''--- projects/chad-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const chad = "0xcce93540b80abf71b66e0a44fd71e322ce9c4d9e";
const masterchad = "0xDA094Ee6bDaf65c911f72FEBfC58002e5e2656d1";

module.exports = {
    ...masterChefExports(masterchad, "fantom", chad, false)
}
'''
'''--- projects/chainge.js ---
const utils = require('./helper/utils');

// fusion
async function fetch() {
    let tvl = await utils.fetchURL('https://info.chainge.finance/api/v1/info/getInfoOuterTvl')

    return tvl.data.data.totalTvl
}

module.exports = {
    methodology: "assets in liquidity are counted as TVL",
    fetch
}

'''
'''--- projects/chainport/index.js ---
const utils = require('../helper/utils');

async function fetch() {
    let tvl = await utils.fetchURL('https://api.chainport.io/tvl/get')

    return tvl.data["tvl_usd"]
}

module.exports = {
    methodology: "assets in liquidity are counted as TVL",
    fetch
}

'''
'''--- projects/chainxyz/index.js ---
const { stakings } = require('../helper/staking')

const stakingContracts = [
  '0x23445c63FeEf8D85956dc0f19aDe87606D0e19A9',
]
const xcnToken = '0xA2cd3D43c775978A96BdBf12d733D5A1ED94fb18'

module.exports = {
  ethereum: {
    staking: stakings(stakingContracts, xcnToken),
    tvl: async () => ({}),
  },
}

'''
'''--- projects/champagne-swap.js ---
const { request, gql } = require("graphql-request");
const sdk = require('@defillama/sdk')
const { toUSDTBalances } = require('./helper/balances')

const graphEndpoint = 'https://api.thegraph.com/subgraphs/name/champagneswap/exchangev3'
const currentQuery = gql`
query champagneFactories {
  champagneFactories(first: 1) {
    totalLiquidityUSD
  }
}
`
const historicalQuery = gql`
query champagneDayDatas {
champagneDayDatas(
  first: 1000
  orderBy: date
  orderDirection: asc
  ) {
    date
    dailyVolumeUSD
    totalLiquidityUSD
    __typename
  }
}
`

const graphUrl = 'https://api.thegraph.com/subgraphs/name/champagneswap/exchangev3'
const graphQuery = gql`
query get_tvl($block: Int) {
  uniswapFactories(
    block: { number: $block }
  ) {
    totalVolumeUSD
    totalLiquidityUSD
  }
}
`;
async function tvl(timestamp, ethBlock, chainBlocks) {
  if (Math.abs(timestamp - Date.now() / 1000) < 3600) {
    const tvl = await request(graphEndpoint, currentQuery, {}, {
      "referer": "https://champagne.finance/",
      "origin": "https://champagne.finance",
    })
    return toUSDTBalances(tvl.champagneFactories[0].totalLiquidityUSD)
  } else {
    const tvl = (await request(graphEndpoint, historicalQuery)).champagneDayDatas
    let closest = tvl[0]
    tvl.forEach(dayTvl => {
      if (Math.abs(dayTvl.date - timestamp) < Math.abs(closest.date - timestamp)) {
        closest = dayTvl
      }
    })
    if(Math.abs(closest.date - timestamp) > 3600*24){ // Oldest data is too recent
      const {uniswapFactories} = await request(
        graphUrl,
        graphQuery,
        {
          block: chainBlocks['bsc'],
        }
      );
      const usdTvl = Number(uniswapFactories[0].totalLiquidityUSD)
    
      return toUSDTBalances(usdTvl)
    }
    return toUSDTBalances(closest.totalLiquidityUSD)
  }
}

const factory = '0xb31A337f1C3ee7fA2b2B83c6F8ee0CA643D807a0'
const champagneToken = '0x4957c1c073557BFf33C01A7cA1436D0d2409d439'
const masterChef = '0x15C17442eb2Cd3a56139e877ec7784b2dbD97270'
async function staking(timestamp, ethBlock, chainBlocks) {
  const balances = {}
  const stakedCham = sdk.api.erc20.balanceOf({
    target: champagneToken,
    owner: masterChef,
    chain: 'bsc',
    block: chainBlocks.bsc
  })

  sdk.util.sumSingleBalance(balances, 'bsc:' + champagneToken, (await stakedCham).output)
  return balances
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology: 'TVL accounts for the liquidity on all AMM pools, using the TVL chart on https://champagne.finance/ as the source. Staking accounts for the CHAM locked in MasterChef (0x15C17442eb2Cd3a56139e877ec7784b2dbD97270)',
  bsc: {
    staking,
    tvl
  },
}

'''
'''--- projects/channels/abi.json ---
{
  "markets": {
    "constant":true,
    "inputs":[
      {
        "name":"",
        "type":"address"
      }
    ],
    "name":"markets",
    "outputs":[
      {
        "name":"isSupported",
        "type":"bool"
      },
      {
        "name":"blockNumber",
        "type":"uint256"
      },
      {
        "name":"interestRateModel",
        "type":"address"
      },
      {
        "name":"totalSupply",
        "type":"uint256"
      },
      {
        "name":"supplyRateMantissa",
        "type":"uint256"
      },
      {
        "name":"supplyIndex",
        "type":"uint256"
      },
      {
        "name":"totalBorrows",
        "type":"uint256"
      },
      {
        "name":"borrowRateMantissa",
        "type":"uint256"
      },
      {
        "name":"borrowIndex",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "totalBorrows": {
    "constant":true,
    "inputs":[

    ],
    "name":"totalBorrows",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "borrowRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"borrowRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "supplyRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"supplyRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6f307dc3"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "signature": "0x3b1d21a2",
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xb0772d0b"
  }
}

'''
'''--- projects/channels/index.js ---
const { compoundExports } = require('../helper/compound');

const comptroller = {
    heco: "0x8955aeC67f06875Ee98d69e6fe5BDEA7B60e9770",
    bsc: "0x8Cd2449Ed0469D90a7C4321DF585e7913dd6E715",
    arbitrum: "0x3C13b172bf8BE5b873EB38553feC50F78c826284"
}

const ceth = {
    bsc: "0x14E134365F754496FBC70906b8611b8b49f66dd4",
    heco: "0x397c6D1723360CC1c317CdC9B2E926Ae29626Ff3",
}

const native = {
    bsc: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    heco: "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f",
}

module.exports = {
    ...Object.keys(comptroller).reduce((exp, chain) => {
        exp[chain] = compoundExports(comptroller[chain], chain, ceth[chain], native[chain], undefined, symbol => ["MLP", "CLP", "SLP"].some(c => symbol.includes(c)))
        return exp
    }, {})
}

'''
'''--- projects/chaotic.js ---
const sdk = require("@defillama/sdk");
const getReserves = require("./helper/abis/getReserves.json");
const BigNumber = require("bignumber.js");
const { getBlock } = require("./helper/getBlock");

const CollateralSystemAddress = "0x78D4664408c06F2BeDc4f108f3Fc8f0AB017a0AE";

const MovrChaosPoolAddress = "0x8d341E5E955E936B45B29dbF49960b8538FCA978";
const MovrUsdcPoolAddress = "0xe537f70a8b62204832B8Ba91940B77d3f79AEb81";

const tokens = {
  CHAOS: "0xf4c6850B6e3288E81Be542909b76865a0BdF9585",
};

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const moonriverBlock = await getBlock(timestamp, "moonriver", chainBlocks);

  const stakedChaos = await sdk.api.abi.call({
    chain: "moonriver",
    block: moonriverBlock,
    target: tokens["CHAOS"],
    params: CollateralSystemAddress,
    abi: "erc20:balanceOf",
  });

  // token0: WMOVR. token1: CHAOS
  const movrChaosPoolReserves = await sdk.api.abi.call({
    chain: "moonriver",
    block: moonriverBlock,
    target: MovrChaosPoolAddress,
    params: [],
    abi: getReserves,
  });

  // token0: WMOVR. token1: USDC
  const movrUsdcPoolReserves = await sdk.api.abi.call({
    chain: "moonriver",
    block: moonriverBlock,
    target: MovrUsdcPoolAddress,
    params: [],
    abi: getReserves,
  });

  const totalChaos = new BigNumber(stakedChaos.output)

  // Calculate USD value of CHAOS via Solarbeam
  const totalMovrValue = totalChaos
    .times(movrChaosPoolReserves.output._reserve0)
    .div(movrChaosPoolReserves.output._reserve1);
  const totalUsdcValue = totalMovrValue
    .times(movrUsdcPoolReserves.output._reserve1)
    .div(movrUsdcPoolReserves.output._reserve0);

  balances["usd-coin"] = totalUsdcValue.div("1000000").toNumber();

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  moonriver: {
    tvl,
  },
};

'''
'''--- projects/chargedefi/index.js ---
const sdk = require("@defillama/sdk");
const { transformBscAddress } = require("../helper/portedTokens");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { pool2Exports } = require("../helper/pool2");
const { staking } = require("../helper/staking");

const chargeTokenAddress = "0x1C6bc8e962427dEb4106aE06A7fA2d715687395c";

const staticBUSDLpAddress = "0x69758726b04e527238B261ab00236AFE9F34929D";
const chargeBUSDLpAddress = "0xB73b4eeb4c4912C1d1869219A22660eB478B57eA";

const chargeBoardroomAddress = "0x53D55291c12EF31b3f986102933177815DB72b3A";
const staticBUSDBoardroomAddress = "0x7692bCB5F646abcdFA436658dC02d075856ac33C";

const chargeBUSDFarmStrategyAddress = "0xA1Be11eAB62283E9719021aCB49400F6d5918153";
const staticBUSDFarmStrategyAddress = "0x53eE388f037876850D4fd60307FBA02e203A1C0e";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  let lpPositions = [];
  let transformAddress = await transformBscAddress();

  // Static-BUSD Boardroom TVL
  const staticBUSDBoardroomBalance = sdk.api.erc20
    .balanceOf({
      target: staticBUSDLpAddress,
      owner: staticBUSDBoardroomAddress,
      block: chainBlocks["bsc"],
      chain: "bsc",
    });

  lpPositions.push({
    token: staticBUSDLpAddress,
    balance: (await staticBUSDBoardroomBalance).output,
  });

  // Charge Farms Static-BUSD TVL
  const chargeFarmStaticBUSDBalance = sdk.api.erc20
    .balanceOf({
      target: staticBUSDLpAddress,
      owner: staticBUSDFarmStrategyAddress,
      block: chainBlocks["bsc"],
      chain: "bsc",
    });

  lpPositions.push({
    token: staticBUSDLpAddress,
    balance: (await chargeFarmStaticBUSDBalance).output,
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["bsc"],
    "bsc",
    transformAddress
  );
  return balances;
}

module.exports = {
  methodology: 'The TVL of Charge Defi is calculated using the Pancake LP token deposits (Static/BUSD and Charge/BUSD) in the farms, and the Charge & Static-BUSD deposits found in each Boardroom.',
  bsc: {
    tvl,
    pool2: pool2Exports(
      chargeBUSDFarmStrategyAddress,
      [chargeBUSDLpAddress],
      "bsc"
    ),
    staking: staking(chargeBoardroomAddress, chargeTokenAddress, "bsc"),

  },
};

'''
'''--- projects/charmfinance/cubePoolAbi.json ---
{
  "poolBalance": {
    "inputs": [],
    "name": "poolBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/charmfinance/index.js ---
const sdk = require("@defillama/sdk");
const axios = require("axios");
const { sumTokens } = require('../helper/unwrapLPs')

const vaultAbi = require("./vaultAbi.json");
const cubePoolAbi = require("./cubePoolAbi.json");

const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const WBTC = "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599";
const ETH = "0x0000000000000000000000000000000000000000";

const vaults = [
  // Old alpha vault - v0
  "0x55535C4C56F6Bf373E06C43E44C0356aaFD0d21A",
  // New alpha vault - v1
  "0xE72f3E105e475D7Db3a003FfA377aFAe9c2c6c11",
  "0x9bF7B46C7aD5ab62034e9349Ab912C0345164322",
  "0xBD7c6D2edE836b6b27C461799c4e9ecB8F4e8A66"
];

const CUBE_POOL = "0x23F6A2D8d691294c3A1144EeD14F5632e8bc1B67";

async function tvl(timestamp, block) {
  let balances = {};

  const optionsContracts = (
    await axios.get(
      "https://raw.githubusercontent.com/charmfinance/options-protocol/main/markets.yaml"
    )
  ).data;

  const optionsContractsWithoutComments = optionsContracts
    .split('\n')
    .map(i => i.trim())
    .filter(i => !i.startsWith('#'))  // removing comments here
    .join('')

  const OPTIONS_CONTRACTS = JSON.parse(optionsContractsWithoutComments);
  const vaultCalls = vaults.map(v => ({ target: v }))
  const { output: vaultAmts } = await sdk.api.abi.multiCall({ abi: vaultAbi.getTotalAmounts, calls: vaultCalls, block, })
  const { output: token0 } = await sdk.api.abi.multiCall({ abi: vaultAbi.token0, calls: vaultCalls, block, })
  const { output: token1 } = await sdk.api.abi.multiCall({ abi: vaultAbi.token1, calls: vaultCalls, block, })

  vaultAmts.map((vaultAmt, i) => {
    sdk.util.sumSingleBalance(balances, token0[i].output, vaultAmt.output.total0);
    sdk.util.sumSingleBalance(balances, token1[i].output, vaultAmt.output.total1);
  })

  const { output: poolBalance } = await sdk.api.abi.call({ abi: cubePoolAbi.poolBalance, target: CUBE_POOL, block, })
  sdk.util.sumSingleBalance(balances, ETH, poolBalance);

  // --- Run a check in all options contracts holdings (ETH, USDC, WBTC) ---
  const erc20_holdings = [USDC, WBTC]
  const tokensAndOwners = []
  erc20_holdings.forEach(t => OPTIONS_CONTRACTS.forEach(o => tokensAndOwners.push([t, o])))
  const { output: ethBalances } = await sdk.api.eth.getBalances({ targets: OPTIONS_CONTRACTS, block })
  Object.values(ethBalances).forEach(item => {
    sdk.util.sumSingleBalance(balances, ETH, item.balance)
  })

  return sumTokens(balances, tokensAndOwners, block)
};

module.exports = {
  ethereum: {
    tvl,
  },
};

'''
'''--- projects/charmfinance/vaultAbi.json ---
{
  "getTotalAmounts": {
    "inputs": [],
    "name": "getTotalAmounts",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "total0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "total1",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token0": {
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token1": {
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/cheesedao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasuryAddress = "0xf8c08c5aD8270424Ad914d379e85aC03a44fF996";
module.exports = ohmTvl(treasuryAddress, [
//1DAI
  ["0xef977d2f931c1978db5f6747666fa1eacb0d0339", false],
//1FRAX
  ["0xeb6c08ccb4421b6088e581ce04fcfbed15893ac3", false],
//Sushi LP
  ["0x82723f6c0b32f28ddc2006b9cdbca6cee0ad957a", true]
], "harmony", "0x72Be77E232Dd13E6aE06088696B83256892c2933", "0xBbD83eF0c9D347C85e60F1b5D2c58796dBE1bA0d")
'''
'''--- projects/cherryswap/index.js ---
const { staking } = require('../helper/staking')
const { getUniTVL } = require('../helper/unknownTokens')

const che = "0x8179d97eb6488860d816e3ecafe694a4153f216c"
const cheStaking = "0x9Ab8BCf67fE8d8D2aD27D42Ec2A0fD5C206DAE60"

module.exports = {
  methodology: "Staking is the CHE staked on 0x9Ab8BCf67fE8d8D2aD27D42Ec2A0fD5C206DAE60, tvl is the liquidity on the exchange and the money locked on the pools that distribute CHE",
  okexchain: {
    staking: staking(cheStaking, che, "okexchain", "okexchain:" + che),
    tvl: getUniTVL({
      factory: '0x709102921812b3276a65092fe79edfc76c4d4afe',
      chain: 'okexchain',
      coreAssets: [
        "0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15", // WOKT
        "0x382bB369d343125BfB2117af9c149795C6C65C50", // USDT
        "0x54e4622DC504176b3BB432dCCAf504569699a7fF", // BTCK
        "0xEF71CA2EE68F45B9Ad6F72fbdb33d707b872315C", // ETHK
        "0xdF54B6c6195EA4d948D03bfD818D365cf175cFC2", // OKB
        "0xab0d1578216A545532882e420A8C61Ea07B00B12", // KST
        "0x8179d97eb6488860d816e3ecafe694a4153f216c", // che
      ],
    })
  },
};

'''
'''--- projects/chest-finance/index.js ---
const { sumTokens, getSolBalance } = require("../helper/solana");
const BigNumber = require("bignumber.js");

// SOL chest owner: https://solscan.io/account/3SGP67y3XAxZivaz2peNTxS6E44cQXErnEMyBXaCeT2n
const SOL_chest_owner = "3SGP67y3XAxZivaz2peNTxS6E44cQXErnEMyBXaCeT2n";
const mSOL = "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So";
const soETH = "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk";
const BTC = "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E";
const USDC = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

const tokensAndAccounts = [mSOL, soETH, BTC, USDC].map((token) => [
  token,
  SOL_chest_owner,
]);

// Tokens with no Coingecko ID, need a replacementCoingeckoId to avoid erroring out
const CASH = "CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT";
tokensAndAccounts.push([CASH, SOL_chest_owner, "dai"]);

async function solanaTVL() {
  // Sum Tokens balances
  let balances = await sumTokens(tokensAndAccounts);

  // Get SOL balance as well (not wrapped SOL)
  const solBalance = await getSolBalance(SOL_chest_owner);
  console.log("Chest SOL:", solBalance, ", Chest tokenBalances", balances);
  balances["solana"] = new BigNumber(balances["solana"] || "0").plus(
    new BigNumber(solBalance)
  );
  return balances;
}

module.exports = {
  solana: {
    tvl: solanaTVL,
  },
  methodology: "Summing balances of all chests of chest finance",
};

'''
'''--- projects/chfry/abi.json ---
{
  "getTotalDeposited": {
    "inputs": [],
    "name": "totalDeposited",
    "outputs": [{
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/chfry/index.js ---
const sdk = require("@defillama/sdk");
const abi = require('./abi.json');
const BigNumber = require("bignumber.js");

const fryerContracts = [
    // Fryer USDT
    "0xd1ffa2cbAE34FF85CeFecdAb0b33E7B1DC19024b",
    // Fryer DAI
    "0x87F6fAA87358B628498E8DCD4E30b0378fEaFD07",
    // Fryer USDC
    "0x7E271Eb034dFc47B041ADf74b24Fb88E687abA9C",
]

const USDT = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const DAI = "0x6b175474e89094c44da98b954eedeac495271d0f";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";

async function tvl(timestamp, block) {
    let balances = {};

    const tvlUSDT = (await sdk.api.abi.call({
        target: fryerContracts[0],
        abi: abi['getTotalDeposited'],
        block: block
    })).output;
    const tvlDAI = (await sdk.api.abi.call({
        target: fryerContracts[1],
        abi: abi['getTotalDeposited'],
        block: block
    })).output;
    const tvlUSDC = (await sdk.api.abi.call({
        target: fryerContracts[2],
        abi: abi['getTotalDeposited'],
        block: block
    })).output;
    balances[USDT] = tvlUSDT;
    balances[DAI] = tvlDAI;
    balances[USDC] = tvlUSDC;
    return balances;
}

module.exports = {
    methodology: "TVL is being calculated as the total amount deposited in the lending protocol by users.",
    ethereum:{
        tvl,
    },
}

'''
'''--- projects/chickenswap/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accChickenPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "balance": {
        "inputs": [],
        "name": "balance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/chickenswap/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { getChainTvl } = require('../helper/getUniSubgraphTvl');

const chickenChefContract = "0x87AE4928f6582376a0489E9f70750334BBC2eb35";
const KFC = "0xE63684BcF2987892CEfB4caA79BD21b34e98A291";
const WETH_KFC_UNIV2 = "0x90544c3f88d0a9e374ed35490028f45642a8b3f2";

const kfcVaults = [
    //kfcUSDT
    "0x408eC098bAB8457499EcE4BF17f197637e338D3a",
    //kfcUSDC
    "0x13DfDa244e281Ced094796e0E0d2A1Cf91A1BD13"
];

/*** Pools(pairs) TVL Portion ***/
const ethChainTvl = getChainTvl({
    ethereum: 'https://api.thegraph.com/subgraphs/name/chickenswap/graph',
});

/*** Vaults TVL Portion ***/
const ethTvl = async (timestamp, block, chainBlocks) => {
    const balances = {};

    await addFundsInMasterChef(
        balances,
        chickenChefContract,
        chainBlocks["ethereum"],
        "ethereum",
        addr => addr,
        abi.poolInfo,
        [KFC, WETH_KFC_UNIV2, kfcVaults[0], kfcVaults[1]]
    );

    const kfcTokens = (
        await sdk.api.abi.multiCall({
            abi: abi.token,
            calls: kfcVaults.map(vault => ({
                target: vault,
            })),
            block 
        })
    ).output.map(tokens => tokens.output);

    const tokensBalance = (
        await sdk.api.abi.multiCall({
            abi: abi.balance,
            calls: kfcVaults.map(vault => ({
                target: vault,
            })),
            block
        })
    ).output.map(bals => bals.output);

    kfcTokens.forEach((token, idx) => {
        sdk.util.sumSingleBalance(balances, token, tokensBalance[idx]);
    });

    return balances;
};

module.exports = {
    misrepresentedTokens: true,
    ethereum: {
        staking: staking(chickenChefContract, KFC),
        pool2: pool2(chickenChefContract, WETH_KFC_UNIV2),
        tvl: sdk.util.sumChainTvls([ethTvl, ethChainTvl('ethereum')]),
    },
    methodology:
        `We count liquidity on the Vaults (only single tokens) through ChickenChef Contract and the liquuidity on the AMM Pools (only pairs) 
        pulling data from the subgraph at https://api.thegraph.com/subgraphs/name/chickenswap/graph`,
};
'''
'''--- projects/chiknfarm/index.js ---
const retry = require('async-retry')
const axios = require("axios");

async function staking() {
    let response = await retry(async bail => await axios.get('https://cdn-b.chikn.farm/api/feed/staked'))
    return {
        'chikn-egg': response.data.totalStakedAmount
    }
}

async function tvl() {
    return {}
}

module.exports = {
    avalanche:{
        tvl,
        staking
    },
}

'''
'''--- projects/chintai/index.js ---
const { get_account_tvl } = require("../helper/eos");

const tokens = [
    ["chexchexchex", "CHEX", "chex-token"],
    ["eosio.token", "EOS", "eos"]
];

// Chintai
// https://chintai.io/
async function eos() {
  return await get_account_tvl("chintailease", tokens);
}

module.exports = {
  methodology: `Chintai TVL is achieved by querying token balances from Chintai leasing smart contract.`,
  eos: {
    tvl: eos
  },
}
'''
'''--- projects/chronicle/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const farmContract = "0x0eC4EE75bF85b553F471ad82839229316B358FB0";
const XNL_BUSD_CakeLP = "0x879fC01b663396aEA410259E7be200dC7049F518";
const XNL = "0x5f26fa0c2ee5d3c0323d861d0c503f31ac212662";

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    staking: staking(farmContract, XNL, "bsc"),
    pool2: pool2(farmContract, XNL_BUSD_CakeLP, "bsc"),
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking and pool2 only",
};

'''
'''--- projects/chronoswap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')
const sdk = require("@defillama/sdk")

module.exports={
    misrepresentedTokens: true,
    methodology: "Factory address (0x6C50Ee65CFcfC59B09C570e55D76daa7c67D6da5) is used to find the LP pairs. TVL is equal to the liquidity on the AMM, while staking is the amount of CNO & CBO tokens found in the Masterchefs(0x77ea4a4cF9F77A034E4291E8f457Af7772c2B254,0xaBAD73Be9fd441731ADb007AdB6C1b03e730A8e0).",
    cronos: {
        tvl:calculateUsdUniTvl(
            "0x6C50Ee65CFcfC59B09C570e55D76daa7c67D6da5", 
            "cronos", 
            "0xca2503482e5D6D762b524978f400f03E38d5F962", 
            [
                "0x322e21dcAcE43d319646756656b29976291d7C76",
                "0xA46d5775c18837e380eFB3d8Bf9D315bcd028AB1",
                "0xc21223249CA28397B4B6541dfFaEcC539BfF0c59",
                "0xE2589867ad472bD1Aa46407c182E13c08f8Eadc9",
                "0x66e428c3f67a68878562e79A0234c1F83c208770",
                "0xe44Fd7fCb2b1581822D0c862B68222998a0c299a",
                "0x062E66477Faf219F25D27dCED647BF57C3107d52",
                "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f",
                "0xc9BAA8cfdDe8E328787E29b4B078abf2DaDc2055"
            ], 
            "crypto-com-chain"),
        staking: sdk.util.sumChainTvls([
            stakingPricedLP("0xaBAD73Be9fd441731ADb007AdB6C1b03e730A8e0", "0xA46d5775c18837e380eFB3d8Bf9D315bcd028AB1", "cronos", "0x9b76213969885044FeF03AFCc08d3F4039768F7e", "crypto-com-chain"),
            stakingPricedLP("0x3790F3A1cf8A478042Ec112A70881Dcfa9c7fd2a", "0x322e21dcAcE43d319646756656b29976291d7C76", "cronos", "0x4bbce14d69f9fea118992f1944c084753f1b0bf9", "crypto-com-chain")        

        ]) 
    }
}
'''
'''--- projects/citycoins/index.js ---
const retry = require('../helper/retry')
const axios = require('axios')
const BigNumber = require('bignumber.js')
const sdk = require('@defillama/sdk')

const STACKS_API = 'https://stacks-node-api.mainnet.stacks.co/extended/v1/address'

const NYC_CONTRACT = 'SP2H8PY27SEZ03MWRKS5XABZYQN17ETGQS3527SA5.newyorkcitycoin-core-v1'
const NYC_CONTRACT_V2 = 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-core-v2'
const MIAMI_CONTRACT = 'SP466FNC0P7JWTNM2R9T199QRZN1MYEDTAR0KP27.miamicoin-core-v1'
const MIAMI_CONTRACT_V2 = 'SP1H1733V5MZ3SZ9XRW9FKYGEZT0JDGEB8Y634C7R.miamicoin-core-v2'
const MIAMI_CITY_WALLET = 'SM2MARAVW6BEJCD13YV2RHGYHQWT7TDDNMNRB1MVT'
const NYC_CITY_WALLET = 'SM18VBF2QYAAHN57Q28E2HSM15F6078JZYZ2FQBCX'

async function tvl() {
  const balances = {}

  await Promise.all([
    addStacks(NYC_CONTRACT, balances),
    addStacks(MIAMI_CONTRACT, balances),
    addStacks(NYC_CONTRACT_V2, balances),
    addStacks(MIAMI_CONTRACT_V2, balances),
  ])
  return balances
}

async function treasury() {
  const balances = {}
  await Promise.all([
    addStacks(MIAMI_CITY_WALLET, balances),
    addStacks(NYC_CITY_WALLET, balances)
  ])
  return balances
}

async function staking() {
  const balances = {}

  await Promise.all([
    addTokens(NYC_CONTRACT, balances),
    addTokens(MIAMI_CONTRACT, balances),
    addTokens(NYC_CONTRACT_V2, balances),
    addTokens(MIAMI_CONTRACT_V2, balances),
  ])
  return balances
}

async function getStacksBalances(address) {
  const url = `${STACKS_API}/${address}/balances`
  return retry(async () => await axios.get(url))
}

async function addStacks(address, balances) {
  const stx_balance = (await getStacksBalances(address)).data.stx.balance
  sdk.util.sumSingleBalance(balances, 'blockstack', BigNumber(stx_balance).div(1e6).toFixed(0))
}

async function addTokens(address, balances) {
  const {
    data: {
      fungible_tokens
    }
  } = await getStacksBalances(address)

  const decimals = [MIAMI_CONTRACT_V2, NYC_CONTRACT_V2] ? 6 : 0

  const tokenBalances = {
    output: Object.keys(fungible_tokens)
      .map(token =>
      ({
        input: { target: token },
        success: true,
        output: BigNumber(fungible_tokens[token].balance / 10 ** decimals).toFixed(0)
      }))
  }
  sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transformStacksToken)
}

function transformStacksToken(token) {
  token = token.split('::')[1] // take only the part after :: in the token string

  if (token === 'newyorkcitycoin')
    return 'nycccoin' // I am guessing coingecko id for NYC city coin is 'nyccoin' hence this replacement

  return  token
}

module.exports = {
  stacks: {
    tvl,
    // treasury, Note: Treasury has been disabled upon team request since they view it as amount reserved for city governers and does not belong to team
    staking,
  },
  methodology: 'Added STX tokens in addresses marked as city wallets as treasury. Added STX in contracts as TVL, and native tokens in it as staking'
};
'''
'''--- projects/claimswap/index.js ---
const retry = require('async-retry')
const axios = require('axios')
const { toUSDTBalances } = require('../helper/balances');

async function fetchLiquidity() {
  const claimswapInfo = await retry(async bail => axios.get('https://data-api.claimswap.org/dashboard/allpool'));
  let totalValue = 0;
  for (const pool of claimswapInfo.data) {
    totalValue = totalValue + pool.liquidity;
  }

  return toUSDTBalances(totalValue.toFixed(2));
}

async function fetchCls() {
  const claimswapInfo = await retry(async bail => await axios.get('https://data-api.claimswap.org/dashboard/index'));
  const clsValue = claimswapInfo.data.claPrice * claimswapInfo.data.totalClaStaked;
  return toUSDTBalances(clsValue.toFixed(2));
}

module.exports = {
  methodology: `Tvl counts the tokens locked on AMM pools and staking counts the CLA that has been staked. Data is pulled from the 'dashboard.claimswap.org'`,
  klaytn: {
    tvl: fetchLiquidity,
    staking: fetchCls,
  },
  misrepresentedTokens: true,
  timetravel: false,
}
'''
'''--- projects/claystack/clayABIs/clayMain.json ---
{
  "funds": {
    "inputs": [],
    "name": "funds",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "currentDeposit",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stakedDeposit",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accruedFees",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/claystack/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./clayABIs/clayMain.json');

const clayAddresses = {
  clayMatic: "0x91730940DCE63a7C0501cEDfc31D9C28bcF5F905",
};

const coinAddresses = {
  matic: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
};

async function getClayMaticTvl(block) {
  const deposits = (
    await sdk.api.abi.call({
      target: clayAddresses.clayMatic,
      abi: abi.funds,
      chain: "ethereum",
      block
    })
  ).output;
  return { [coinAddresses.matic]: deposits.currentDeposit };
}

module.exports = {

  ethereum: {
    tvl: getClayMaticTvl,
  },
  methodology: `We get the total token deposited in clay contracts and convert it to USD.`
}
'''
'''--- projects/clayswap/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0x4c7fc1495559a13d68fa4b60286621dfcec16cf3";
const token = "0xfd54aE2369a3Be69d441cAcC49F920fFEc9068Ac";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/clearpool/abi.json ---
{
  "borrows": {
    "inputs": [],
    "name": "borrows",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/clearpool/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens } = require("../helper/unwrapLPs");
const abi = require("./abi.json");

const PoolFactory = "0x969d7DDbE3b6F8b51E26D8473AaAC1a9f4a6b47B";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const START_BLOCK = 14443222;

const ethereumTVL = async (timestamp, block, chainBlocks) => {
  const balances = {};
  const Logs = (
    await sdk.api.util.getLogs({
      target: PoolFactory,
      topic: "PoolCreated(address,address,address,bool)",
      keys: [],
      fromBlock: START_BLOCK,
      toBlock: block,
    })
  ).output;
  const tokensAndOwners = [];
  for (let i = 0; i < Logs.length; i++) {
    const pool = "0x" + Logs[i].topics[1].substring(26, 66);
    tokensAndOwners.push([USDC, pool]);
  }
  await sumTokens(balances, tokensAndOwners, block);
  return balances;
};

const ethereumBorrowed = async (timestamp, block, chainBlocks) => {
  const totalBorrowed = {};
  const Logs = (
    await sdk.api.util.getLogs({
      target: PoolFactory,
      topic: "PoolCreated(address,address,address,bool)",
      keys: [],
      fromBlock: START_BLOCK,
      toBlock: block,
    })
  ).output;
  for (let i = 0; i < Logs.length; i++) {
    const pool = "0x" + Logs[i].topics[1].substring(26, 66);
    const borrowed = (
      await sdk.api.abi.call({
        target: pool,
        abi: abi.borrows,
      })
    ).output;

    sdk.util.sumSingleBalance(totalBorrowed, USDC, borrowed);
  }
  return totalBorrowed;
};

module.exports = {
  ethereum: {
    tvl: ethereumTVL,
    borrowed: ethereumBorrowed,
  },
  methodology: "We count liquidity by USDC deposited on the pools contracts",
};

'''
'''--- projects/cleopatradao.js ---
const { ohmTvl } = require("./helper/ohm");

const cat = "0x48358BfAA1EC39AafCb0786c3e0342Db676Df93E";
const stakingContract = "0x6636dF51544bAef6B90f4012504B1dfE1eD5e3Fd";
const treasury = "0x10243C6D13875443716ff3E88b7Da7664e431E09";
const treasuryTokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
    ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false], // WAVAX
    ["0x6a71044647c960afb6bbe758cc444dedfa9349f7", true] // CAT-MIM JLP
]   

module.exports = {
    deadFrom: 1648765747,
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "avax", stakingContract, cat, undefined, undefined, false)
}

'''
'''--- projects/clever/index.js ---
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");

const lockCvxAddress = '0x96C68D861aDa016Ed98c30C810879F9df7c64154';

const cvxAddress = "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B";

async function tvl(timestamp, block) {
  let balances = {}
  const totalLockedGlobal = (await sdk.api.abi.call({
    target: lockCvxAddress,
    block,
    abi: {
      "inputs": [],
      "name": "totalLockedGlobal",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  })).output
  if (!BigNumber(totalLockedGlobal).isZero()) {
    sdk.util.sumSingleBalance(balances, cvxAddress, BigNumber(totalLockedGlobal).toFixed(0))
  }
  return balances
}
module.exports = {
  ethereum: {
    tvl
  }
}

'''
'''--- projects/clipper/index.js ---
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs')
const { getChainTransform } = require('../helper/portedTokens')
const sdk = require('@defillama/sdk')
const retry = require('../helper/retry')
const axios = require("axios")
const BigNumber = require('bignumber.js')

const oldPools = {
	ethereum: ["0xe82906b6B1B04f631D126c974Af57a3A7B6a99d9",],
}

const chainConfig = {
	ethereum: { chainId: 1, },
	polygon: { chainId: 137, },
	moonbeam: { chainId: 1284, },
	optimism: { chainId: 10, },
}
const weth = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
const moonbeamGLMR = "moonbeam:0x0000000000000000000000000000000000000802"

async function getChainData(chain) {
	const { chainId } = chainConfig[chain]

	const {
		data: {
			pool: {
				address: poolAddress
			},
			assets
		}
	} = await retry(async () => await axios.get(`https://api.clipper.exchange/rfq/pool?chain_id=${chainId}`))
	return {
		poolAddress,
		assets: assets.map(({ address }) => address)
	}
}

function chainTVL(chain) {
	return {
		tvl: async (time, _block, chainBlocks) => {
			const balances = {}
			const block = chainBlocks[chain]
			const transform = await getChainTransform(chain)
			const { poolAddress, assets } = await getChainData(chain)
			const pools = oldPools[chain] || []
			const poolAddresses = [poolAddress, ...pools,]

			await sumTokensAndLPsSharedOwners(balances, assets.map(t => [t, false]), poolAddresses, block, chain, transform)

			if (balances[moonbeamGLMR]) {
				balances['moonbeam'] = BigNumber(balances[moonbeamGLMR]).dividedBy(10 ** 18).toFixed(0)
				delete balances[moonbeamGLMR]
			}

			if (chain === 'ethereum')
				for(const pool of poolAddresses)
					sdk.util.sumSingleBalance(balances, weth, (await sdk.api.eth.getBalance({ target: pool, block })).output)

			return balances

		}
	}
}

const chainTVLObject = Object.keys(chainConfig).reduce((agg, chain) => ({ ...agg, [chain]: chainTVL(chain) }), {})

module.exports = {
	...chainTVLObject,
	methodology: `Counts the tokens in pool address in different chains`
}

'''
'''--- projects/cobraswap/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const sdk = require("@defillama/sdk");
const { BigNumber } = require("bignumber.js");

const factory = "0x3165d94dd2f71381495cb897832de02710a0dce5";

async function getCobraPrice(block) {
  const chain = "bsc";

  const busdBalance = (await sdk.api.erc20.balanceOf({
    target: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    owner: "0x1011d0abd6fd3965d34a56f7c1789a19fdd9cf67",
    block,
    chain
  })).output;

  const cobraBalance = (await sdk.api.erc20.balanceOf({
    target: "0x2c449ba613873e7b980faf2b686207d7bd205541",
    owner: "0x1011d0abd6fd3965d34a56f7c1789a19fdd9cf67",
    block,
    chain
  })).output;

  return busdBalance/cobraBalance;
}

async function getViperPrice(block) {
  const chain = "bsc";

  const cobraBalance = (await sdk.api.erc20.balanceOf({
    target: "0x2c449ba613873e7b980faf2b686207d7bd205541",
    owner: "0x77a6704a382e5cd8ac74a5994576989d9cede976",
    block,
    chain
  })).output;

  const viperBalance = (await sdk.api.erc20.balanceOf({
    target: "0x7e080699d0f306dbae458b13ea6fa8bfd0efe752",
    owner: "0x77a6704a382e5cd8ac74a5994576989d9cede976",
    block,
    chain
  })).output;

  return cobraBalance/viperBalance;
}

async function tvl(timestamp, block, chainBlocks) {
  let balances = await calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks.bsc, "bsc", factory, 9503477, true);
  const cobraPrice = await getCobraPrice(chainBlocks.bsc);
  const viperPrice = await getViperPrice(chainBlocks.bsc);
  sdk.util.sumSingleBalance(balances, "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", BigNumber(balances["bsc:0x2c449ba613873e7b980faf2b686207d7bd205541"]).times(cobraPrice).toFixed(0));
  delete balances["bsc:0x2c449ba613873e7b980faf2b686207d7bd205541"];
  sdk.util.sumSingleBalance(balances, "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", BigNumber(balances["bsc:0x7e080699d0f306dbae458b13ea6fa8bfd0efe752"]).times(cobraPrice * viperPrice).toFixed(0));
  delete balances["bsc:0x7e080699d0f306dbae458b13ea6fa8bfd0efe752"];
  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  methodology: `Include liquidity in AMM pools`,
  bsc:{
    tvl
  }
}

'''
'''--- projects/coconuts-finance/abi.json ---
{
    "totalAssets" : 
    {
    "gas": 4633,
    "inputs": [],
    "name": "totalAssets",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  } 
}
'''
'''--- projects/coconuts-finance/index.js ---
const sdk = require('@defillama/sdk');
const utils = require('../helper/utils');
const abi = require("./abi.json");

function getAvaxTvl(timestamp, block, chainBlocks) {
    return async () => {
        let avaxResponse = await utils.fetchURL(`https://coconutsfinance-test.herokuapp.com/api/apys?network=43114`);
        let balances = {}
        let avaxData = await avaxResponse.data;
        for (let i = 0; i < avaxData.length; i++) {
            let token = avaxData[i].token

            const balance = (await sdk.api.abi.call({
                abi: abi.totalAssets,
                chain: 'avax',
                target: avaxData[i].addr,
                block: chainBlocks.avax
            })).output;

            sdk.util.sumSingleBalance(balances, `avax:${token}`, balance)

        }

        if (balances === 0) {
            throw new Error('avax fetch error')

        }
        return balances;
    }
}

function getPolygonTvl(timestamp, block, chainBlocks) {
    return async () => {
        let polyResponse = await utils.fetchURL(`https://coconutsfinance-test.herokuapp.com/api/apys?network=137`);
        let balances = {}
        let polyData = await polyResponse.data;

        for (let i = 0; i < polyData.length; i++) {
            let token = polyData[i].token

            let balance = (await sdk.api.abi.call({
                abi: abi.totalAssets,
                chain: 'polygon',
                target: polyData[i].addr,
                block
            })).output;

            sdk.util.sumSingleBalance(balances, `polygon:${token}`, balance)

        }

        if (balances === 0) {
            throw new Error(chainId)

        }
        return balances;
    }
}

module.exports = {
    avax: {
        // tvl: getAvaxTvl()
        tvl: () => ({})
    },
    // polygon: {
        // tvl: getPolygonTvl()
    // },
    broken: 'Api is down'
}; 

'''
'''--- projects/code7/index.js ---
const { tombTvl } = require("../helper/tomb");

const code7 = "0xF77864FCFfeC4598813E3378681c9330B771cA88";
const sevenshare = "0xB215014176720EdA5334df07f827c3f11ec0f1bD";
const rewardPool = "0x42cd7c105cdc5c85d2ba1e57f7c74cb96f95e549";
const masonry = "0x39990bf6889ec7481ed021c11210b09d29c1c2ea";

const lps = [
    "0x25d6e427e0db1594156f1d4f334f62184555332e",
    "0xd4996a8654cf4cd319fc82e70430e4704f6e55d5"
];

module.exports = {
    ...tombTvl(code7, sevenshare, rewardPool, masonry, lps, "fantom", undefined, false, lps[0])
}
'''
'''--- projects/coffin/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformFantomAddress } = require("../helper/portedTokens");

const MasterChefV1Contract = "0x155482Bd4e5128082D61a2384935D4BBDcb0E7a7";
const MasterChefV2Contract = "0x2447115E9Ba73bd2877821BF69E09259664a2bd5";

const stakingContract = "0x61Befe6E5f20217960bD8659cd3113CC1ca67d2F";
const WFTM = "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83";

const ftmTvl = async (timestamp, ethBlock, chainBlocks) => {

  const balances = {};

  let transformAddress = await transformFantomAddress();

  await addFundsInMasterChef(
    balances,
    MasterChefV1Contract,
    chainBlocks["fantom"],
    "fantom",
    transformAddress
  );

  return balances;
};

const v2TVL = async (timestamp, ethBlock, chainBlocks) => {
  let balances = {};
  let transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(
    balances,
    MasterChefV2Contract,
    chainBlocks["fantom"],
    "fantom",
    transformAddress
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  fantom: {
    staking: staking(stakingContract, WFTM, "fantom"),
    tvl: sdk.util.sumChainTvls([ftmTvl, v2TVL]),
  },
  methodology: "We count liquidity on the Farms through MasterChef and MasterChefv2 Contract",
};

'''
'''--- projects/cofix.js ---
const { sumTokens } = require('./helper/unwrapLPs')

async function tvl(_, block) {
  return sumTokens({}, [
    ['0xdac17f958d2ee523a2206206994597c13d831ec7', '0xb2b7bedd7d7fc19804c7dd4a4e8174c4c73c210d'],
    ['0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', '0xb2b7bedd7d7fc19804c7dd4a4e8174c4c73c210d'],
    ['0x0316EB71485b0Ab14103307bf65a021042c6d380', '0x7c2d7b53aca4038f2eb649164181114b9aee93cb'],
    ['0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', '0x7c2d7b53aca4038f2eb649164181114b9aee93cb'],
  ], block)
}

module.exports = {
  ethereum: { tvl }
}

'''
'''--- projects/coinswap/index.js ---
const sdk = require("@defillama/sdk");
const tvlOnPairs = require("../helper/processPairs.js");

/* There is a farming portion, where their own lp tokens  
*  are deposited in the farming contracts to earn CSS, but
*  it will be double counting the same tvl coming from the pool contracts
*/

const factory = "0xC2D8d27F3196D9989aBf366230a47384010440c0";

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  await tvlOnPairs("bsc", chainBlocks, factory, balances);

  return balances;
};

module.exports = {
  methodology: 'TVL counts the liquidity of the DEX. The factory address(0xC2D8d27F3196D9989aBf366230a47384010440c0) is used to find every LP pair that has been created.',
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/coinwind/abi.json ---
{
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "poolInfo": {
        "inputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "name": "poolInfo",
        "outputs": [{
            "internalType": "address",
            "name": "token",
            "type": "address"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "totalAmount",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "ethPoolInfo": {
        "inputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "name": "poolInfo",
        "outputs": [{
            "internalType": "address",
            "name": "token",
            "type": "address"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "totalAmount",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }, {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "daoPoolInfo": {
        "inputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "name": "poolInfo",
        "outputs": [{
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "getReserves": {
        "inputs": [],
        "name": "getReserves",
        "outputs": [{
            "internalType": "uint112",
            "name": "_reserve0",
            "type": "uint112"
        }, {
            "internalType": "uint112",
            "name": "_reserve1",
            "type": "uint112"
        }, {
            "internalType": "uint32",
            "name": "_blockTimestampLast",
            "type": "uint32"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [{
            "internalType": "address",
            "name": "",
            "type": "address"
        }],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [{
            "internalType": "address",
            "name": "",
            "type": "address"
        }],
        "stateMutability": "view",
        "type": "function"
    }
}

'''
'''--- projects/coinwind/index.js ---
const sdk = require('@defillama/sdk');
const { staking } = require('../helper/staking');
const { pool2 } = require('../helper/pool2');
const abi = require('./abi.json');
const { getChainTransform } = require('../helper/portedTokens')
const { unwrapLPsAuto } = require('../helper/unwrapLPs')

const ETH_POOL = "0x8ddc12f593F1c92122D5dda9244b5e749cBFB2e4"

const BSC_POOL = "0x6bA7d75eC6576F88a10bE832C56F0F27DC040dDD"
const BSC_POOL_LP = "0xAdA5598d0E19B4d3C64585b4135c5860d4A0881F"
const BSC_POOL_DAO = "0x4711D9b50353fa9Ff424ceCa47959dCF02b3725A"

const HECO_POOL = "0xAba48B3fF86645ca417f79215DbdA39B5b7cF6b5"
const HECO_POOL_LP = "0x94ad8542f3F1bBb6D0dFa4B91589a264FF9b0056"
const HECO_POOL_DAO = "0x031026064e8f0702a91318e660796139A69Cb89b"

const ethTvl = async (timestamp, ethBlock, { ethereum: block }) => {
  let chain = "ethereum"
  const transformAddress = await getChainTransform(chain)
  let balances = {}
  let pool = ETH_POOL
  await addPool(chain, block, pool, balances, transformAddress, abi['ethPoolInfo'])
  return unwrapLPsAuto({ balances, block, chain, transformAddress, });
};

const bscTvl = async (timestamp, ethBlock, { bsc: block }) => {
  let chain = "bsc"
  const transformAddress = await getChainTransform(chain)
  let balances = {}
  let pool = BSC_POOL
  await addPool(chain, block, pool, balances, transformAddress)
  pool = BSC_POOL_LP
  await addPool(chain, block, pool, balances, transformAddress)
  return unwrapLPsAuto({ balances, block, chain, transformAddress, });
};

const hecoTvl = async (timestamp, ethBlock, { heco: block }) => {
  let chain = "heco"
  const transformAddress = await getChainTransform(chain)
  let balances = {}
  let pool = HECO_POOL
  await addPool(chain, block, pool, balances, transformAddress)
  pool = HECO_POOL_LP
  await addPool(chain, block, pool, balances, transformAddress)
  return unwrapLPsAuto({ balances, block, chain, transformAddress, });
};

async function addPool(chain, block, pool, balances, transformAddress, poolInfo = abi['poolInfo']) {
  const poolLength = (await sdk.api.abi.call({ target: pool, abi: abi["poolLength"], block: block, chain: chain })).output
  const calls = []
  for (let index = 0; index < poolLength; index++)  calls.push({ params: [index]})
  const { output: data } = await sdk.api.abi.multiCall({
    target: pool,
    abi: poolInfo,
    calls: calls,
    chain, block,
  })

  data.forEach(i => sdk.util.sumSingleBalance(balances, transformAddress(i.output.token), i.output.totalAmount))
}

module.exports = {
  methodology: 'TVL counts deposits made to Lossless single asset pools on Ethereum, Heco and Binance Smart Chain and to the various LP farms available on Heco and BSC.',
  ethereum: { tvl: ethTvl },
  bsc: {
    staking: staking(BSC_POOL_DAO, "0x422e3af98bc1de5a1838be31a56f75db4ad43730", "bsc"),
    pool2: pool2(BSC_POOL_DAO, "0xf16d5142086dbf7723b0a57b8d96979810e47448", "bsc"),
    tvl: bscTvl
  },
  heco: {
    staking: staking(HECO_POOL_DAO, "0x80861a817106665bca173db6ac2ab628a738c737", "heco"),
    pool2: pool2(HECO_POOL_DAO, "0x3f57530bdba9bcd703c8ba75c57cf7de52014036", "heco"),
    tvl: hecoTvl
  },
};

'''
'''--- projects/colony/index.js ---
const sdk = require("@defillama/sdk");

const stakingV1Contract = "0x5B0d74C78F2588B3C5C49857EdB856cC731dc557";
const stakingV2Contract = "0x7CcDa6E26dCeD1Ba275c67CD20235790ed615A8D";
const colonyGovernanceToken = "0xec3492a2508DDf4FDc0cD76F31f340b30d1793e6";

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  const stakingV1 = (
    await sdk.api.erc20.balanceOf({
      block: chainBlocks.avax,
      target: colonyGovernanceToken,
      owner: stakingV1Contract,
      chain: "avax",
    })
  ).output;

  const stakingV2 = (
    await sdk.api.erc20.balanceOf({
      block: chainBlocks.avax,
      target: colonyGovernanceToken,
      owner: stakingV2Contract,
      chain: "avax",
    })
  ).output;

  sdk.util.sumSingleBalance(
    balances,
    `avax:${colonyGovernanceToken}`,
    stakingV1
  );

  sdk.util.sumSingleBalance(
    balances,
    `avax:${colonyGovernanceToken}`,
    stakingV2
  );

  return balances;
}

module.exports = {
  methodology:
    "Staking is calculated based on CLY tokens locked on Colony staking contracts",
  avalanche: {
    tvl: async () => ({}),
    staking,
  },
};

'''
'''--- projects/comb/index.js ---
const utils = require('../helper/utils');
const { toUSDTBalances } = require('../helper/balances');

function fetch() {
  return async () => {
    let tvl = 0;
    const pools = await utils.fetchURL('https://comb-breakdown.herokuapp.com/pools');
    const vaults = await utils.fetchURL('https://comb-breakdown.herokuapp.com/vaults');

    pools.data.forEach(pool => tvl += pool.tvl);
    vaults.data.forEach(vault => tvl += vault.tvl);

    return toUSDTBalances(tvl);
  }
}

function staking() {
  return async () => {
    let tvl = 0;
    const zcomb = await utils.fetchURL('https://comb-breakdown.herokuapp.com/zcomb');
    tvl += zcomb.data.tvl;
    return toUSDTBalances(tvl);
  }
}

module.exports = {
  methodology: 'Fetches pools (masterchef), vaults, and zcomb data from external APIs and sums up the total locked values (TVL). The TVLs are calculated by taking the lp balances and its price of the strategies and adding them up. The zcomb tvl is calculated by taking the total locked comb and multiplying it by its market value.',
  fantom: {
    tvl: fetch(),
    staking: staking()
  }
}

'''
'''--- projects/comet-finance/index.js ---
const { tombTvl } = require("../helper/tomb");

const token = "0xbeBB20cD6364998b8cAfc3d6B86f1ca6363fF910";
const share = "0xBAFDCFC3787BF7833BE6Be8E2D9e822B610255C9";
const rewardPool = "0x9C8C8EB95749dEE9E8cC68f3cAaa658Ea6D1E4bd";
const masonry = "0xA68a020fd0B68A0e4E3F4a97dD44EE3aa0280E7f";
const lps = [
    "0x06378DFab4d97ba1f67EbE68c94893e7fDDf9169",
    "0x6F5CA58FBd1B2f335d1B9489216490fBEDcAda7e"
]

module.exports = {
    ...tombTvl(token, share, rewardPool, masonry, lps, "fantom", undefined, false, lps[1])
}
'''
'''--- projects/comfymoney/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");
const { fixHarmonyBalances } = require("../helper/portedTokens");
const { getBlock } = require("../helper/getBlock");

const comfyTokenAddress = "0x702f78E81Cf3DfaE89648b5a9e2e1aa8db1De546";
const cshareTokenAddress = "0x3CB98cacd44Ee77eb35E99EB74Ace91bF550c964";
const comfyRewardPoolAddress = "0x893F07c9E10932349b01Db7A3833Fe756C2D59A8";
const cshareRewardPoolAddress = "0x53efc025d19270b899eBf89DD89a1F58CE1CD66f";
const zenDenAddress = "0x108426718E67da46e09E841bC4e8430A824BDaFc";
const treasuryAddress = "0xb44570F6b0C2B892BcB9d3620C820A10011abbFf";

const comfyWoneLp = "0xF2d9E493a280545699E3C07aEe22eaE9EF24DDb7";
const cshareWoneLp = "0x8fd44A4fB89e26A97B0eDf99535236D415D03E50";

const allLpPools = [
  { poolAddress: comfyRewardPoolAddress, tokenAddress: comfyWoneLp },
  { poolAddress: cshareRewardPoolAddress, tokenAddress: cshareWoneLp },
  { poolAddress: cshareRewardPoolAddress, tokenAddress: comfyWoneLp },
];

const callParams = allLpPools.map((pool) => {
  return { target: pool.tokenAddress, params: pool.poolAddress };
});

async function calcPool2(block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: callParams,
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );
  fixHarmonyBalances(balances);
  return balances;
}

async function onePool2(timestamp, block, chainBlocks) {
  return await calcPool2(chainBlocks.harmony, "harmony");
}

async function treasury(timestamp, block, chainBlocks) {
  const _block = await getBlock(timestamp, "harmony", chainBlocks, true);
  let balance = (
    await sdk.api.erc20.balanceOf({
      target: comfyTokenAddress,
      owner: treasuryAddress,
      block: _block,
      chain: "harmony",
    })
  ).output;

  return { [`harmony:${comfyTokenAddress}`]: balance };
}
module.exports = {
  methodology:
    "Pool2 deposits consist of COMFY/ONE and CSHARE/ONE LP tokens deposited in the MasterChef based contracts, whilst the staking TVL consists of the CSHARE tokens locked within the Zen Den contract(0x108426718E67da46e09E841bC4e8430A824BDaFc).",
  harmony: {
    tvl: async () => ({}),
    pool2: onePool2,
    staking: staking(zenDenAddress, cshareTokenAddress, "harmony"),
    treasury,
  },
};

'''
'''--- projects/complifi/abi.json ---
{
  "getAllVaults": {
    "inputs": [],
    "name": "getAllVaults",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  },
  "getVaultCollateral": {
    "inputs":[],
    "name":"collateralToken",
    "outputs":[
      {
        "internalType":"address",
        "name":"",
        "type":"address"
      }
    ],
    "stateMutability":"view",
    "type":"function",
    "constant": true
  },
  "getAllPools": {
    "inputs": [],
    "name": "getAllPools",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  },
  "getConfig": {
    "inputs": [],
    "name": "getConfig",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint256",
            "name": "minExitAmount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "protocolFee",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "feeWallet",
            "type": "address"
          },
          {
            "internalType": "contract IERC20",
            "name": "collateralToken",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "collateralOracle",
            "type": "address"
          },
          {
            "internalType": "contract IOracleIterator",
            "name": "collateralOracleIterator",
            "type": "address"
          },
          {
            "internalType": "contract IVolatilityEvolution",
            "name": "volatilityEvolution",
            "type": "address"
          },
          {
            "internalType": "contract IUnderlyingLiquidityValuer",
            "name": "underlyingLiquidityValuer",
            "type": "address"
          },
          {
            "internalType": "contract IExposure",
            "name": "exposure",
            "type": "address"
          },
          {
            "internalType": "contract IERC20MintedBurnable",
            "name": "poolShare",
            "type": "address"
          },
          {
            "internalType": "contract ITraderPortfolio",
            "name": "traderPortfolio",
            "type": "address"
          },
          {
            "internalType": "uint8",
            "name": "collateralDecimals",
            "type": "uint8"
          }
        ],
        "internalType": "struct IPoolConfigTypes.PoolConfig",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/complifi/index.js ---

const sdk = require('@defillama/sdk');
const abi = require('./abi.json');

const chainParams = {
  ethereum: {
    START_BLOCK: 12093712, // Mar-23-2021 07:22:04 AM +UTC
    VAULT_FACTORY_PROXY: '0x3269DeB913363eE58E221808661CfDDa9d898127',
  },
  polygon:{
    START_BLOCK: 14908452,
    VAULT_FACTORY_PROXY: '0xE970b0B1a2789e3708eC7DfDE88FCDbA5dfF246a',
  },
  polygon_v2:{
    START_BLOCK: 27563723,
    POOL_FACTORY_PROXY: '0x501FE5583f2ebC9f62fe9CD71637D746c7943686',
  }
}

function getChainTvlV2(chain){
  return async (timestamp, block, chainBlocks)=>chainTvlV2(chain, chainBlocks[chain], chain=='ethereum'?addr=>addr:addr=>`polygon:${addr}`)
}

async function chainTvlV2(chain, block, transformAddr) {
  let balances = {};

  let pools = await getPools(block, chain);

  let poolCollaterals = (await sdk.api.abi.multiCall({
    block,
    calls: pools.map((pool) => ({
      target: pool,
    })),
    chain,
    abi: abi['getConfig'],
  })).output.map(config => config['output']['collateralToken'])

  let poolBalances = await sdk.api.abi.multiCall({
    block,
    calls: pools.map((pool, index) => ({
      target: poolCollaterals[index],
      params: pool,
    })),
    chain,
    abi: 'erc20:balanceOf',
  });

  sdk.util.sumMultiBalanceOf(balances, poolBalances, true, transformAddr);

  return balances;
}

async function getPools(block, chain) {
  let chainParamsItem = chainParams[chain + '_v2'];
  if (block < chainParamsItem.START_BLOCK) {
    return [];
  }

  return (await sdk.api.abi.call({
    block,
    chain,
    target: chainParamsItem.POOL_FACTORY_PROXY,
    params: [],
    abi: abi['getAllPools'],
  })).output;
}

function getChainTvl(chain){
  return async (timestamp, block, chainBlocks)=>chainTvl(chain, chainBlocks[chain], chain=='ethereum'?addr=>addr:addr=>`polygon:${addr}`)
}

async function chainTvl(chain, block, transformAddr) {
  let balances = {};

  let vaults = await getVaults(block, chain);

  let vaultCollaterals = (await sdk.api.abi.multiCall({
    block,
    calls: vaults.map((vault) => ({
      target: vault,
    })),
    chain,
    abi: abi['getVaultCollateral'],
  })).output;

  let vaultBalances = await sdk.api.abi.multiCall({
    block,
    calls: vaults.map((vault,index) => ({
      target: vaultCollaterals[index].output,
      params: vault,
    })),
    chain,
    abi: 'erc20:balanceOf',
  });

  sdk.util.sumMultiBalanceOf(balances, vaultBalances, true, transformAddr);

  return balances;
}

async function getVaults(block, chain) {
  if (block < chainParams[chain].START_BLOCK) {
    return [];
  }

  return (await sdk.api.abi.call({
    block,
    chain,
    target: chainParams[chain].VAULT_FACTORY_PROXY,
    params: [],
    abi: abi['getAllVaults'],
  })).output;
}

module.exports = {
  ethereum:{
    tvl: getChainTvl('ethereum')
  },
  polygon: {
    tvl: sdk.util.sumChainTvls([ getChainTvl('polygon'), getChainTvlV2('polygon')]),
  }
}

'''
'''--- projects/complus/index.js ---
const { getChainTvl } = require('../helper/getUniSubgraphTvl');
const sdk = require('@defillama/sdk')

const graphUrls = {
  avax: 'https://api.thegraph.com/subgraphs/name/complusnetwork/subgraph-ava',
  bsc: 'https://api.thegraph.com/subgraphs/name/complusnetwork/bsc-subgraph',
  polygon: 'https://api.thegraph.com/subgraphs/name/complusnetwork/subgraph-matic',
  heco: 'https://hg2.bitcv.net/subgraphs/name/complusnetwork/subgraph-heco'
}
const chainTvl = getChainTvl(graphUrls, "complusFactories")

module.exports = {
  misrepresentedTokens: true,
  methodology: "Liquidity on the DEX, data comes from their subgraphs",
  /* outdated
  polygon: {
    tvl: chainTvl('polygon'),
  },
  bsc: {
    tvl: chainTvl('bsc'),
  },
  heco: {
    tvl: chainTvl('heco'),
  },
  */
  avalanche: {
    tvl: chainTvl('avax'),
  },
}
'''
'''--- projects/component/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const {staking} = require("../helper/staking");

const cmp = "0x9f20Ed5f919DC1C1695042542C13aDCFc100dcab";
const ethStakingPool = "0x79876b5062160C107e02826371dD33c047CCF2de";

const translateToken = {
    '0xFe7ed09C4956f7cdb54eC4ffCB9818Db2D7025b8': "0x1456688345527be1f37e9e627da0837d6f08c925",
    '0xFc8B2690F66B46fEC8B3ceeb95fF4Ac35a0054BC': "0x6b175474e89094c44da98b954eedeac495271d0f",
    '0xDACD011A71f8c9619642bf482f1D4CeB338cfFCf': "0x1456688345527be1f37e9e627da0837d6f08c925",
    '0x3129aC70c738D398d1D74c87EAB9483FD56D16f8': "0x1456688345527be1f37e9e627da0837d6f08c925",
    '0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E': "0x6b175474e89094c44da98b954eedeac495271d0f",
    '0x82f0B8B456c1A451378467398982d4834b6829c1': "0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3"
}

const ethPools = [
    //POOLS
    {
        token: "0x49519631B404E06ca79C9C7b0dC91648D86F08db",
        underlying: [
            "0xdAC17F958D2ee523a2206206994597C13D831ec7",
            "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
            "0x1456688345527bE1f37E9e627DA0837D6f08C925"
        ]
    },
    {
        token: "0x6477960dd932d29518D7e8087d5Ea3D11E606068",
        underlying: [
            "0x1456688345527bE1f37E9e627DA0837D6f08C925",
            "0x6B175474E89094C44Da98b954EedeAC495271d0F",
            "0x57Ab1ec28D129707052df4dF418D58a2D46d5f51"
        ]
    }
];

const xDaiPools = [
    //POOLS
    {
        token: "0x53De001bbfAe8cEcBbD6245817512F8DBd8EEF18",
        underlying: [
            "0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83",
            "0xFe7ed09C4956f7cdb54eC4ffCB9818Db2D7025b8",
            "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d"
        ]
    },
    {
        token: "0xF82fc0ecBf3ff8e253a262447335d3d8A72CD028",
        underlying: [
            "0xFc8B2690F66B46fEC8B3ceeb95fF4Ac35a0054BC",
            "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d"
        ]
    },
    {
        token: "0xfbbd0F67cEbCA3252717E66c1Ed1E97ad8B06377",
        underlying: [
            "0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83",
            "0xFc8B2690F66B46fEC8B3ceeb95fF4Ac35a0054BC",
            "0xD10Cc63531a514BBa7789682E487Add1f15A51E2",
            "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d"
        ]
    }
]

const bscPools = [
    //POOLS
    {
        token: "0xcf76a0ceDf50DA184FDef08A9d04E6829D7FefDF",
        underlying: [
            "0x55d398326f99059fF775485246999027B3197955",
            "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
            "0xDACD011A71f8c9619642bf482f1D4CeB338cfFCf"
        ]
    },
    {
        token: "0x3Bb6Bf6EcBC71f8f78D1Eec9c91de4f8Fd5C891c",
        underlying: [
            "0x55d398326f99059fF775485246999027B3197955",
            "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
            "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d"
        ]
    }
]

const ftmPools = [
    //POOLS
    {
        token: "0xdDCA02Ddd94f97eeFE07fCcde780fD2FbDc85b23",
        underlying: [
            "0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E",
            "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75",
            "0x3129aC70c738D398d1D74c87EAB9483FD56D16f8"
        ]
    },
    {
        token: "0x238139bF999f389063444e397cDfadF780ec57DB",
        underlying: [
            "0xdc301622e621166BD8E82f2cA0A26c13Ad0BE355",
            "0x82f0B8B456c1A451378467398982d4834b6829c1",
            "0x3129aC70c738D398d1D74c87EAB9483FD56D16f8"
        ]
    }
]

async function getTvlFromPools(balances, pools, block, chain) {
    for (let i in pools) {
        let underlyingBalances = (await sdk.api.abi.multiCall({
            calls: pools[i].underlying.map(p => ({
                target: p,
                params: pools[i].token
            })),
            abi: "erc20:balanceOf",
            block,
            chain
        })).output;
        for (let j in underlyingBalances) {
            if (underlyingBalances[j].input.target === "0xD10Cc63531a514BBa7789682E487Add1f15A51E2") {
                let bal = new BigNumber(underlyingBalances[j].output).div(10 ** 12).toFixed(0);
                sdk.util.sumSingleBalance(balances, "xdai:0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83", bal);
            }
            else if (underlyingBalances[j].input.target in translateToken) {
                sdk.util.sumSingleBalance(balances, translateToken[underlyingBalances[j].input.target], underlyingBalances[j].output);
            } else {
                sdk.util.sumSingleBalance(balances, `${chain}:${underlyingBalances[j].input.target}`, underlyingBalances[j].output);
            }
        }
    }
}

async function tvl(timestamp, block) {
    let balances = {};
    await getTvlFromPools(balances, ethPools, block, "ethereum");
    return balances;
}

async function xDaiTvl(timestamp, block, chainBlocks) {
    let balances = {};
    await getTvlFromPools(balances, xDaiPools, chainBlocks.xdai, "xdai");
    return balances;
}

async function bscTvl(timestamp, block, chainBlocks) {
    let balances = {};
    await getTvlFromPools(balances, bscPools, chainBlocks.bsc, "bsc");
    return balances;
}

async function ftmTvl(timestamp, block, chainBlocks) {
    let balances = {};
    await getTvlFromPools(balances, ftmPools, chainBlocks.fantom, "fantom");
    return balances;
}

module.exports = {
    ethereum: {
        tvl,
        staking: staking(ethStakingPool, cmp)
    },
    xdai: {
        tvl: xDaiTvl
    },
    bsc: {
        tvl: bscTvl
    },
    // fantom: {
    //     tvl: ftmTvl
    // },
}
'''
'''--- projects/composable/index.js ---
const {chainExports} = require('../helper/exports')
const { sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')
const sdk = require('@defillama/sdk')

const networks = {
    'ethereum': ['0xef4439f0fae7db0b5ce88c155fc6af50f1b38728', [
        '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', //usdc
        '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // eth
        '0xca3d75ac011bf5ad07a98d02f18225f9bd9a6bdf', // tricrypto
    ]],
    'arbitrum': ['0xEba8C2Bf0d1C9413543188fc42D7323690AED051',[
        '0xff970a61a04b1ca14834a43f5de4533ebddb5cc8', //usdc
        '0x82af49447d8a07e3bd95bd0d56f35241523fbab1' //eth
    ]],
    'polygon': ['0xcd8e7322dc2659b1ec447e5d52fdd9c67e8c3c01',[
        '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', //usdc
        '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619' //eth
    ]]
}

const abi = [{"inputs":[],"name":"token","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]
const rugPools = ['0x4a03ea61e543ec7141a3f90128b0c0c9514f8737', '0xf12da8470e2643ccb39a157e8577d9aa586a488f', '0x1941441d31809e9E1828Da0cE6d44175F657E215']

function chainTvl(chain){
    return async (_time, ethBlock, chainBlocks)=>{
        const balances = {}
        const [owner, tokens] = networks[chain]
        await sumTokensAndLPsSharedOwners(balances, tokens.map(t=>[t, false]), [owner], chainBlocks[chain], chain, addr=>`${chain}:${addr}`)
        if(chain === "ethereum"){
            for(const pool of rugPools){
                const token = await sdk.api.abi.call({
                    target: pool,
                    abi: abi[0],
                    block: ethBlock
                })
                const bal = await sdk.api.abi.call({
                    target: pool,
                    abi: abi[1],
                    block: ethBlock
                })
                sdk.util.sumSingleBalance(balances, token.output, bal.output)
            }
        }
        return balances
    }
}

module.exports=chainExports(chainTvl, Object.keys(networks))
'''
'''--- projects/compound-onchain/abi.json ---
{
  "markets": {
    "constant":true,
    "inputs":[
      {
        "name":"",
        "type":"address"
      }
    ],
    "name":"markets",
    "outputs":[
      {
        "name":"isSupported",
        "type":"bool"
      },
      {
        "name":"blockNumber",
        "type":"uint256"
      },
      {
        "name":"interestRateModel",
        "type":"address"
      },
      {
        "name":"totalSupply",
        "type":"uint256"
      },
      {
        "name":"supplyRateMantissa",
        "type":"uint256"
      },
      {
        "name":"supplyIndex",
        "type":"uint256"
      },
      {
        "name":"totalBorrows",
        "type":"uint256"
      },
      {
        "name":"borrowRateMantissa",
        "type":"uint256"
      },
      {
        "name":"borrowIndex",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "totalBorrows": {
    "constant":true,
    "inputs":[

    ],
    "name":"totalBorrows",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "borrowRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"borrowRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "supplyRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"supplyRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6f307dc3"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "signature": "0x3b1d21a2",
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xb0772d0b"
  }
}

'''
'''--- projects/compound-onchain/index.js ---

const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const v1abi = require('./v1Abi.json');
const BigNumber = require('bignumber.js');
const {lendingMarket} = require('../helper/methodologies')

// cache some data
const markets = [
  {
    underlying: '0x0D8775F648430679A709E98d2b0Cb6250d2887EF',
    symbol: 'BAT',
    decimals: 18,
    cToken: '0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E',
  },
  {
    underlying: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    symbol: 'DAI',
    decimals: 18,
    cToken: '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643',
  },
  {
    underlying: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    symbol: 'WETH',
    decimals: 18,
    cToken: '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5',
  }, //cETH => WETH
  {
    underlying: '0x1985365e9f78359a9B6AD760e32412f4a445E862',
    symbol: 'REP',
    decimals: 18,
    cToken: '0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1',
  },
  {
    underlying: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    symbol: 'USDC',
    decimals: 6,
    cToken: '0x39AA39c021dfbaE8faC545936693aC917d5E7563',
  },
  {
    underlying: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
    symbol: 'USDT',
    decimals: 6,
    cToken: '0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9',
  },
  {
    underlying: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
    symbol: 'WBTC',
    decimals: 8,
    cToken: '0xC11b1268C1A384e55C48c2391d8d480264A3A7F4',//cWBTC - legacy
  },
  {
    underlying: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
    symbol: 'WBTC',
    decimals: 8,
    cToken: '0xccf4429db6322d5c611ee964527d42e5d685dd6a'//cWBTC
  },
  {
    underlying: '0xE41d2489571d322189246DaFA5ebDe1F4699F498',
    symbol: 'ZRX',
    decimals: 18,
    cToken: '0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407',
  },
  {
    underlying: '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359',
    symbol: 'SAI',
    decimals: 18,
    cToken: '0xF5DCe57282A584D2746FaF1593d3121Fcac444dC',
  },
];

// ask comptroller for all markets array
async function getAllCTokens(block) {
  return (await sdk.api.abi.call({
    block,
    target: '0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b',
    params: [],
    abi: abi['getAllMarkets'],
  })).output;
}

async function getUnderlying(block, cToken) {
  if (cToken === '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5') {
    return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';//cETH => WETH
  }

  return (await sdk.api.abi.call({
    block,
    target: cToken,
    abi: abi['underlying'],
  })).output;
}

// returns {[underlying]: {cToken, decimals, symbol}}
async function getMarkets(block) {
  if (block < 10271924) {
    // the allMarkets getter was only added in this block.
    return markets;
  } else {
    let allCTokens = await getAllCTokens(block);
    // if not in cache, get from the blockchain
    await (
      Promise.all(allCTokens.map(async (cToken) => {
        let foundMarket = false;
        for (let market of markets) {
          if (market.cToken.toLowerCase() === cToken.toLowerCase()) {
            foundMarket = true;
          }
        }
        if (!foundMarket) {
          let underlying = await getUnderlying(block, cToken);
          markets.push({ underlying, cToken })
        }
      }))
    );

    return markets;
  }
}

const v1Contract = '0x3FDA67f7583380E67ef93072294a7fAc882FD7E7'
async function v1Tvl(balances, block, borrowed){
  const marketsLength = await sdk.api.abi.call({
    target: v1Contract,
    block,
    abi: v1abi.getCollateralMarketsLength
  });
  const underlyings = await sdk.api.abi.multiCall({
    calls: Array(Number(marketsLength.output)).fill().map((n, i)=>({
      target: v1Contract,
      params: [i]
    })),
    block,
    abi: v1abi.collateralMarkets
  });
  const markets = await sdk.api.abi.multiCall({
    calls: underlyings.output.map(m=>({
      target: v1Contract,
      params: [m.output]
    })),
    block,
    abi: v1abi.markets
  });
  markets.output.forEach(m=>{
    const token = m.input.params[0]
    let amount
    if(borrowed){
      amount = m.output.totalBorrows
    }
    sdk.util.sumSingleBalance(balances, token, amount)
  })
}

async function v2Tvl(balances, block, borrowed){
  let markets = await getMarkets(block);

  // Get V1 tokens locked
  let v1Locked = await sdk.api.abi.multiCall({
    block,
    calls: markets.map((market) => ({
      target: market.underlying,
      params: '0x3FDA67f7583380E67ef93072294a7fAc882FD7E7',
    })),
    abi: 'erc20:balanceOf',
  });

  sdk.util.sumMultiBalanceOf(balances, v1Locked);

  // Get V2 tokens locked
  let v2Locked = await sdk.api.abi.multiCall({
    block,
    calls: markets.map((market) => ({
      target: market.cToken,
    })),
    abi: borrowed?abi.totalBorrows: abi['getCash'],
  });

  markets.forEach((market) => {
    let getCash = v2Locked.output.find((result) => result.input.target === market.cToken);
      balances[market.underlying] = BigNumber(balances[market.underlying] || 0)
        .plus(getCash.output)
        .toFixed();
  });
  return balances;
}

async function borrowed(timestamp, block){
  const balances = {};
  await v1Tvl(balances, block, true)
  await v2Tvl(balances, block, true)
  return balances
}

async function tvl(timestamp, block) {
  let balances = {};

  // Get V1 tokens locked
  let v1Locked = await sdk.api.abi.multiCall({
    block,
    calls: markets.map((market) => ({
      target: market.underlying,
      params: v1Contract,
    })),
    abi: 'erc20:balanceOf',
  });

  sdk.util.sumMultiBalanceOf(balances, v1Locked);

  await v2Tvl(balances, block, false)
  return balances;
}

module.exports = {
  timetravel: true,
  ethereum: {
    tvl,
    borrowed
  },
  methodology: `${lendingMarket}. TVL is calculated by getting the market addresses from comptroller and calling the getCash() on-chain method to get the amount of tokens locked in each of these addresses, then we get the price of each token from coingecko.`,
};

'''
'''--- projects/compound-onchain/v1Abi.json ---
{
    "getCollateralMarketsLength": {
        "constant": true,
        "inputs": [],
        "name": "getCollateralMarketsLength",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "markets": {
        "constant": true,
        "inputs": [
            {
                "name": "",
                "type": "address"
            }
        ],
        "name": "markets",
        "outputs": [
            {
                "name": "isSupported",
                "type": "bool"
            },
            {
                "name": "blockNumber",
                "type": "uint256"
            },
            {
                "name": "interestRateModel",
                "type": "address"
            },
            {
                "name": "totalSupply",
                "type": "uint256"
            },
            {
                "name": "supplyRateMantissa",
                "type": "uint256"
            },
            {
                "name": "supplyIndex",
                "type": "uint256"
            },
            {
                "name": "totalBorrows",
                "type": "uint256"
            },
            {
                "name": "borrowRateMantissa",
                "type": "uint256"
            },
            {
                "name": "borrowIndex",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "collateralMarkets": {
        "constant": true,
        "inputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "collateralMarkets",
        "outputs": [
            {
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/concave/index.js ---
const sdk = require('@defillama/sdk')
const { ohmTvl } = require('../helper/ohm')
const { calculateUniTvl } = require('../helper/calculateUniTvl');
const { genericUnwrapCvx } = require('../helper/unwrapLPs');

// Treasury backing the CNV price, similar to OHM so using the ohm wrapper
const treasury = '0x226e7af139a0f34c6771deb252f9988876ac1ced' 
const etherAddress = '0x0000000000000000000000000000000000000000'
const cnv_token = '0x000000007a58f5f58e697e51ab0357bc9e260a04'
const stakingAddress = '0x0000000000000000000000000000000000000000'
const treasuryTokens = [
    ['0x6b175474e89094c44da98b954eedeac495271d0f', false], //DAI
    // ['0x0ab87046fBb341D058F17CBC4c1133F25a20a52f', false], //gOHM
]
const gemSwap_factory = '0x066a5cb7ddc6d55384e2f6ca13d5dd2cd2685cbd'

// Generic CRV position unwrapping, useful for a CVX position unwrapping
// CVX treasury position parameters
const cvxDOLA_3CRV_BaseRewardPool = '0x835f69e58087e5b6bffef182fe2bf959fe253c3c'

async function tvl(timestamp, ethBlock, chainBlocks) {
  // Count TVL of amm
  const balances = await calculateUniTvl(t=>t, ethBlock, 'ethereum', gemSwap_factory, 14300000, true);

  // Get ether balance
  balances[etherAddress] = (await sdk.api.eth.getBalance({ target: treasury, ethBlock })).output

  // Compute the balance of the treasury of the CVX position and unwrap
  await genericUnwrapCvx(balances, treasury, cvxDOLA_3CRV_BaseRewardPool, ethBlock, 'ethereum')

  return balances
};

module.exports = ohmTvl(treasury, treasuryTokens, 'ethereum', stakingAddress, cnv_token, undefined, undefined, true)
module.exports.ethereum.tvl = sdk.util.sumChainTvls([tvl, module.exports.ethereum.tvl])
delete module.exports.ethereum.staking
module.exports.methodology = 'Count the treasury assets backing the CNV price + LP assets in the AMM Gemswap'

'''
'''--- projects/concentrator/abis/AladdinCRV.json ---
{
    "totalUnderlying": {
        "inputs": [],
        "name": "totalUnderlying",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/concentrator/abis/AladdinConvexVault.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "totalUnderlying",
        "type": "uint128"
      },
      {
        "internalType": "uint128",
        "name": "totalShare",
        "type": "uint128"
      },
      {
        "internalType": "uint256",
        "name": "accRewardPerShare",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "convexPoolId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "crvRewards",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "withdrawFeePercentage",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "platformFeePercentage",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "harvestBountyPercentage",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "pauseDeposit",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "pauseWithdraw",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/concentrator/abis/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "address",
                "name": "lptoken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "gauge",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "crvRewards",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "stash",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "shutdown",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "coinsUint": {
        "name": "coins",
        "outputs": [
            {
                "type": "address",
                "name": ""
            }
        ],
        "inputs": [
            {
                "type": "uint256",
                "name": "arg0"
            }
        ],
        "stateMutability": "view",
        "type": "function",
        "gas": 2280
    },
    "coinsInt": {
        "name": "coins",
        "outputs": [
            {
                "type": "address",
                "name": "out"
            }
        ],
        "inputs": [
            {
                "type": "int128",
                "name": "arg0"
            }
        ],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 2190
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/concentrator/index.js ---
const sdk = require("@defillama/sdk");
const abi = require('./abis/abi.json')
const { default: BigNumber } = require("bignumber.js");

const AladdinConvexVaultABI = require('./abis/AladdinConvexVault.json')
const AladdinCRVABI = require('./abis/AladdinCRV.json')
const curvePools = require('./pools-crv.js');
const { createIncrementArray } = require('../helper/utils');
const { sumTokens2 } = require('../helper/unwrapLPs')

const concentratorVault = '0xc8fF37F7d057dF1BB9Ad681b53Fa4726f268E0e8';
const concentratorAcrv = '0x2b95A1Dcc3D405535f9ed33c219ab38E8d7e0884';
const cvxcrvAddress = '0x62b9c7356a2dc64a1969e19c23e4f579f9810aa7';

const concentratorNewVault = '0x3Cf54F3A1969be9916DAD548f3C084331C4450b5';
const addressZero = "0x0000000000000000000000000000000000000000"
const ethAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
const wethAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const replacements = [
  "0x99d1Fa417f94dcD62BfE781a1213c092a47041Bc",
  "0x9777d7E2b60bB01759D0E2f8be2095df444cb07E",
  "0x1bE5d71F2dA660BFdee8012dDc58D024448A0A59",
  "0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01",
  "0xd6aD7a6750A7593E092a9B218d66C0A814a3436e",
  "0x83f798e925BcD4017Eb265844FDDAbb448f1707D",
  "0x73a052500105205d34Daf004eAb301916DA8190f"
].map(i => i.toLowerCase())

async function tvl(timestamp, block) {
  let balances = {}

  const acrvTotalUnderlying = (await sdk.api.abi.call({
    target: concentratorAcrv,
    block,
    abi: AladdinCRVABI.totalUnderlying,
  })).output;
  const acrvTotalSupply = (await sdk.api.abi.call({
    target: concentratorAcrv,
    block,
    abi: AladdinCRVABI.totalSupply,
    params: []
  })).output;
  const rate = acrvTotalSupply * 1 ? BigNumber(acrvTotalUnderlying).div(acrvTotalSupply) : 1
  const cvxcrvBalance = BigNumber(acrvTotalUnderlying).multipliedBy(rate)
  sdk.util.sumSingleBalance(balances, cvxcrvAddress, BigNumber(cvxcrvBalance).toFixed(0))

  const oldPoolLength = (await sdk.api.abi.call({
    target: concentratorVault,
    abi: abi.poolLength,
    block
  })).output;
  const newPoolLength = (await sdk.api.abi.call({
    target: concentratorNewVault,
    abi: abi.poolLength,
    block
  })).output;

  await getVaultInfo(oldPoolLength, 'old', balances, block)
  await getVaultInfo(newPoolLength, 'New', balances, block)
  sdk.util.sumSingleBalance(balances, cvxcrvAddress, BigNumber(acrvTotalUnderlying).toFixed(0))
  return balances
}

async function getVaultInfo(poolLength, type, balances, block) {
  const _target = type == 'New' ? concentratorNewVault : concentratorVault;
  const paramsCalls = createIncrementArray(poolLength).map(i => ({ params: i }))
  const { output: poolInfos } = await sdk.api.abi.multiCall({
    target: _target,
    abi: AladdinConvexVaultABI.poolInfo,
    calls: paramsCalls,
    block,
  })
  const { output: totalSupplies } = await sdk.api.abi.multiCall({
    abi: 'erc20:totalSupply',
    calls: poolInfos.map(i => ({ target: i.output.lpToken })),
    block,
  })

  await Promise.all(poolInfos.map(async (_, i) => {
    const poolInfo = poolInfos[i];
    const poolData = curvePools.find(crvPool => crvPool.addresses.lpToken.toLowerCase() === poolInfo.output.lpToken.toLowerCase())

    if (poolData === undefined) {
      console.log(poolInfo.output, poolData,);
      throw new Error('Missing pool data');
    }

    const swapAddress = poolData.addresses.swap
    const coinCalls = createIncrementArray(poolData.coins.length).map(num => {
      return {
        target: swapAddress,
        params: [num]
      }
    });

    let coins = await sdk.api.abi.multiCall({
      abi: abi.coinsUint,
      calls: coinCalls,
      block
    })
    if (!coins.output[0].success) {
      coins = await sdk.api.abi.multiCall({
        abi: abi.coinsInt,
        calls: coinCalls,
        block
      })
    }

    let coinBalances = []
    const tokens = coins.output.map(i => {
      if (i.output.toLowerCase() == wethAddress.toLowerCase()) {
        return ethAddress
      }
      return i.output;
    })
    let tempBalances = await sumTokens2({ block, owner: swapAddress, tokens, })
    Object.entries(tempBalances).forEach(([coin, balance]) => coinBalances.push({ coin, balance }))
    const resolvedLPSupply = totalSupplies[i].output;

    coinBalances.map((coinBalance) => {
      let coinAddress = coinBalance.coin.toLowerCase()
      if (replacements.includes(coinAddress)) {
        coinAddress = "0x6b175474e89094c44da98b954eedeac495271d0f" // dai
      } else if (coinAddress === '0xFEEf77d3f69374f66429C91d732A244f074bdf74'.toLowerCase()) {
        coinAddress = '0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0' // replace cvxFXS -> FXS
      }
      const balance = BigNumber(poolInfo.output.totalUnderlying * coinBalance.balance / resolvedLPSupply);
      if (!balance.isZero()) {
        sdk.util.sumSingleBalance(balances, coinAddress, balance.toFixed(0))
      }
    })
  }))
}
module.exports = {
  doublecounted: true,
  ethereum: {
    tvl
  }
}

'''
'''--- projects/concentrator/pools-crv.js ---
const REFERENCE_ASSETS = {};
const coins = {};

module.exports = [
    {
        id: 'cvxcrv',
        name: 'cvxcrv',
        coins: [
            coins.crv,
            coins.cvxcrv,
        ],
        addresses: {
            swap: '0x9D0464996170c6B9e75eED71c68B99dDEDf279e8',
            lpToken: '0x9D0464996170c6B9e75eED71c68B99dDEDf279e8'
        }
    },
    {
        id: 'ib3crv',
        name: 'ib3crv',
        coins: [
            coins.cyDai,
            coins.cyUSDT,
            coins.cyUSDC,
        ],
        addresses: {
            swap: '0x2dded6da1bf5dbdf597c45fcfaa3194e53ecfeaf',
            lpToken: '0x5282a4eF67D9C33135340fB3289cc1711c13638C'
        }
    },
    {
        id: 'cvxfxs',
        name: 'cvxfxs',
        coins: [
            coins.fxs,
            coins.fxs,
        ],
        addresses: {
            swap: '0xd658A338613198204DCa1143Ac3F01A722b5d94A',
            lpToken: '0xF3A43307DcAFa93275993862Aae628fCB50dC768'
        }
    },

    {
        id: 'steth',
        name: 'steth',
        coins: [
            coins.eth,
            coins.steth,
        ],
        addresses: {
            swap: '0xDC24316b9AE028F1497c275EB9192a3Ea0f67022',
            lpToken: '0x06325440D014e39736583c165C2963BA99fAf14E',
        },
    },

    {
        id: 'frax',
        name: 'frax',
        coins: [
            coins.frax,
            coins.crv3pool
        ],
        addresses: {
            swap: '0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B',
            lpToken: '0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B',
        },
    },

    {
        id: 'tricrypto2',
        name: 'tricrypto2',
        coins: [
            coins.usdt,
            coins.wbtc,
            coins.eth,
        ],
        addresses: {
            swap: '0xD51a44d3FaE010294C616388b506AcdA1bfAAE46',
            lpToken: '0xc4AD29ba4B3c580e6D59105FFf484999997675Ff',
        },
    },

    {
        id: 'crveth',
        name: 'crveth',
        coins: [
            coins.eth,
            coins.crv,
        ],
        addresses: {
            swap: '0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511',
            lpToken: '0xEd4064f376cB8d68F770FB1Ff088a3d0F3FF5c4d',
        },
    },

    {
        id: 'cvxeth',
        name: 'cvxeth',
        coins: [
            coins.eth,
            coins.cvx,
        ],
        addresses: {
            swap: '0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4',
            lpToken: '0x3A283D9c08E8b55966afb64C515f5143cf907611',
        },
    },

    {
        id: 'crv3pool',
        name: 'crv3pool',
        coins: [
            coins.dai,
            coins.usdc,
            coins.usdt,
        ],
        addresses: {
            swap: '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7',
            lpToken: '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490',
        },
    },

    {
        id: 'ust-wormhole',
        name: 'ust-wormhole',
        coins: [
            coins.ust,
            coins.crv3pool
        ],
        addresses: {
            swap: '0xCEAF7747579696A2F0bb206a14210e3c9e6fB269',
            lpToken: '0xCEAF7747579696A2F0bb206a14210e3c9e6fB269',
        },
    },

    {
        id: 'rocketpooleth',
        name: 'rocketpooleth',
        coins: [
            coins.rETH,
            coins.wstETH,
        ],
        addresses: {
            swap: '0x447Ddd4960d9fdBF6af9a790560d0AF76795CB08',
            lpToken: '0x447Ddd4960d9fdBF6af9a790560d0AF76795CB08',
        },
    },

    {
        id: 'ren',
        name: 'ren',
        coins: [
            coins.renbtc,
            coins.wbtc
        ],
        addresses: {
            swap: '0x93054188d876f558f4a66B2EF1d97d16eDf0895B',
            lpToken: '0x49849C98ae39Fff122806C06791Fa73784FB3675',
        },
    },

    {
        id: 'pusd',
        name: 'pusd',
        coins: [
            coins.pusd,
            coins.crv3pool
        ],
        addresses: {
            swap: '0x8EE017541375F6Bcd802ba119bdDC94dad6911A1',
            lpToken: '0x8EE017541375F6Bcd802ba119bdDC94dad6911A1',
        },
    },

    {
        id: 'susd',
        name: 'susd',
        coins: [
            coins.dai,
            coins.usdc,
            coins.usdt,
            coins.SUSD
        ],
        addresses: {
            swap: '0xA5407eAE9Ba41422680e2e00537571bcC53efBfD',
            lpToken: '0xC25a3A3b969415c80451098fa907EC722572917F',
        },
    },

    {
        id: 'seth',
        name: 'seth',
        coins: [
            coins.eth,
            coins.seth
        ],
        addresses: {
            swap: '0xc5424b857f758e906013f3555dad202e4bdb4567',
            lpToken: '0xA3D87FffcE63B53E0d54fAa1cc983B7eB0b74A9c',
        },
    },

    {
        id: 'sbtc',
        name: 'sbtc',
        coins: [
            coins.renBTC,
            coins.wbtc,
            coins.sBTC
        ],
        addresses: {
            swap: '0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714',
            lpToken: '0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3',
        },
    },
    {
        id: 'fraxusdc',
        name: 'fraxusdc',
        coins: [
            coins.frax,
            coins.usdc
        ],
        addresses: {
            swap: '0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2',
            lpToken: '0x3175Df0976dFA876431C2E9eE6Bc45b65d3473CC',
        },
    },

    {
        id: 'mim',
        name: 'mim',
        coins: [
            coins.mim,
            coins.crv3pool
        ],
        addresses: {
            swap: '0x5a6A4D54456819380173272A5E8E9B9904BdF41B',
            lpToken: '0x5a6A4D54456819380173272A5E8E9B9904BdF41B',
        },
    },
    {
        id: 'fpifrax',
        name: 'fpifrax',
        coins: [
            coins.frax,
            coins.fpi
        ],
        addresses: {
            swap: '0xf861483fa7E511fbc37487D91B6FAa803aF5d37c',
            lpToken: '0x4704aB1fb693ce163F7c9D3A31b3FF4eaF797714',
        },
    },

    {
        id: 'alusd',
        name: 'alusd',
        coins: [
            coins.alUSD,
            coins.crv3pool
        ],
        addresses: {
            swap: '0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c',
            lpToken: '0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c',
        },
    },

    {
        id: 'Compound',
        name: 'Compound',
        coins: [
            coins.cdai,
            coins.cusdc
        ],
        addresses: {
            swap: '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56',
            lpToken: '0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2',
        },
    },

    {
        id: 'dola',
        name: 'dola',
        coins: [
            coins.DOLA,
            coins.crv3pool
        ],
        addresses: {
            swap: '0xAA5A67c256e27A5d80712c51971408db3370927D',
            lpToken: '0xAA5A67c256e27A5d80712c51971408db3370927D',
        },
    },

    {
        id: 'busdv2',
        name: 'busdv2',
        coins: [
            coins.busd,
            coins.crv3pool
        ],
        addresses: {
            swap: '0x4807862AA8b2bF68830e4C8dc86D0e9A998e085a',
            lpToken: '0x4807862AA8b2bF68830e4C8dc86D0e9A998e085a',
        },
    },

    {
        id: 'eursusd',
        name: 'eursusd',
        coins: [
            coins.eth,
            coins.usdc
        ],
        addresses: {
            swap: '0x98a7F18d4E56Cfe84E3D081B40001B3d5bD3eB8B',
            lpToken: '0x3D229E1B4faab62F621eF2F6A610961f7BD7b23B',
        },
    },

    {
        id: 'alETH',
        name: 'alETH',
        coins: [
            coins.eth,
            coins.eth
        ],
        addresses: {
            swap: '0xC4C319E2D4d66CcA4464C0c2B32c9Bd23ebe784e',
            lpToken: '0xC4C319E2D4d66CcA4464C0c2B32c9Bd23ebe784e',
        },
    },

    {
        id: '3eur-pool',
        name: '3eur-pool',
        coins: [
            coins.agEUR,
            coins.eurt,
            coins.EURS
        ],
        addresses: {
            swap: '0xb9446c4Ef5EBE66268dA6700D26f96273DE3d571',
            lpToken: '0xb9446c4Ef5EBE66268dA6700D26f96273DE3d571',
        },
    },

    {
        id: 'lusd',
        name: 'lusd',
        coins: [
            coins.lusd,
            coins.crv3pool,
        ],
        addresses: {
            swap: '0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA',
            lpToken: '0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA',
        },
    },

    {
        id: 'd3pool',
        name: 'd3pool',
        coins: [
            coins.frax,
            coins.alUSD,
            coins.fei,
        ],
        addresses: {
            swap: '0xBaaa1F5DbA42C3389bDbc2c9D2dE134F5cD0Dc89',
            lpToken: '0xBaaa1F5DbA42C3389bDbc2c9D2dE134F5cD0Dc89',
        },
    },

    {
        id: 'musd',
        name: 'musd',
        coins: [
            coins.mUSD,
            coins.crv3pool,
        ],
        addresses: {
            swap: '0x8474DdbE98F5aA3179B3B3F5942D724aFcdec9f6',
            lpToken: '0x1AEf73d49Dedc4b1778d0706583995958Dc862e6',
        },
    },
];
'''
'''--- projects/config/abis.js ---
let abis = {};

abis.minABI = [
  // balanceOf
  {
    constant: true,
    inputs: [{ name: "_owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "balance", type: "uint256" }],
    type: "function"
  },
  // decimals
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    type: "function"
  },
  //totalSupply
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    type: "function"
  }
];

// Basic yearn vault abi
abis.minYvV2 = [
  // balanceOf
  {
    constant: true,
    inputs: [{ name: "_owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "balance", type: "uint256" }],
    type: "function"
  },
  //pricePerShare
  {
    constant: true,
    inputs: [],
    name: "pricePerShare",
    outputs: [{ name: "", type: "uint256" }],
    type: "function"
  }
];
module.exports = {
  abis
};

'''
'''--- projects/config/bella/abis/bVault.js ---
module.exports = [
  {
    "constant": true,
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "underlyingBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/config/boringdao/abis.js ---

let abis = {};

abis.tunnel = [{"inputs":[{"internalType":"contract IAddressResolver","name":"_addrResolver","type":"address"},{"internalType":"bytes32","name":"_oTokenKey","type":"bytes32"},{"internalType":"bytes32","name":"_tunnelKey","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"address","name":"proposer","type":"address"},{"indexed":false,"internalType":"string","name":"assetAddress","type":"string"}],"name":"BurnOToken","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"PledgeSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"RedeemSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WithdrawUnlockSuccess","type":"event"},{"inputs":[],"name":"ADDRESS_BOOK","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BORINGDAO","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BURN_FEE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BURN_FEE_INSURANCE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BURN_FEE_PLEDGER","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DEV_ADDRESS","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"FEE_POOL","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"INSURANCE_POOL","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LIQUIDATION","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MINT_FEE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MINT_FEE_DEV","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MINT_FEE_PLEDGER","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MINT_FEE_TRUSTEE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NETWORK_FEE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ORACLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PARAM_BOOK","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PLEDGE_RATE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PLEDGE_TOKEN","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SATELLITE_POOL_FACTORY","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TRUSTEE_FEE_POOL","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"borPledgeInfo","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"assetAddress","type":"string"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"burnMiniLimit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"canIssueAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"issue","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"liquidate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"lockDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"lockInfo","outputs":[{"internalType":"uint256","name":"unlockTime","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"oTokenKey","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"pledge","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pledgeRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"redeem","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"redeemLockTxLimit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"setBurnMiniLimit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"duration","type":"uint256"}],"name":"setLockDuration","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"setRedeemLockTxLimit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalPledgeBOR","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTVL","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalValuePledge","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"tunnelKey","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"unpause","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"userLockAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"userLockLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdrawUnlock","outputs":[],"stateMutability":"nonpayable","type":"function"}]

module.exports = {
  abis
}

'''
'''--- projects/config/cover/cover.js ---
let abis = {};

abis.cover = [
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "newClaimNonce",
				"type": "uint256"
			}
		],
		"name": "ClaimAccepted",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "active",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_index",
				"type": "uint256"
			}
		],
		"name": "activeCovers",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "activeCoversLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_collateral",
				"type": "address"
			},
			{
				"internalType": "uint48",
				"name": "_timestamp",
				"type": "uint48"
			},
			{
				"internalType": "uint256",
				"name": "_amount",
				"type": "uint256"
			}
		],
		"name": "addCover",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_claimNonce",
				"type": "uint256"
			}
		],
		"name": "claimDetails",
		"outputs": [
			{
				"internalType": "uint16",
				"name": "_payoutNumerator",
				"type": "uint16"
			},
			{
				"internalType": "uint16",
				"name": "_payoutDenominator",
				"type": "uint16"
			},
			{
				"internalType": "uint48",
				"name": "_incidentTimestamp",
				"type": "uint48"
			},
			{
				"internalType": "uint48",
				"name": "_timestamp",
				"type": "uint48"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "claimNonce",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "claimRedeemDelay",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "claimsLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_collateral",
				"type": "address"
			}
		],
		"name": "collateralStatusMap",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "_status",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_index",
				"type": "uint256"
			}
		],
		"name": "collaterals",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "collateralsLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_collateral",
				"type": "address"
			},
			{
				"internalType": "uint48",
				"name": "_expirationTimestamp",
				"type": "uint48"
			}
		],
		"name": "coverMap",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint16",
				"name": "_payoutNumerator",
				"type": "uint16"
			},
			{
				"internalType": "uint16",
				"name": "_payoutDenominator",
				"type": "uint16"
			},
			{
				"internalType": "uint48",
				"name": "_incidentTimestamp",
				"type": "uint48"
			},
			{
				"internalType": "uint256",
				"name": "_protocolNonce",
				"type": "uint256"
			}
		],
		"name": "enactClaim",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint48",
				"name": "_expirationTimestamp",
				"type": "uint48"
			}
		],
		"name": "expirationTimestampMap",
		"outputs": [
			{
				"internalType": "bytes32",
				"name": "_name",
				"type": "bytes32"
			},
			{
				"internalType": "uint8",
				"name": "_status",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_index",
				"type": "uint256"
			}
		],
		"name": "expirationTimestamps",
		"outputs": [
			{
				"internalType": "uint48",
				"name": "",
				"type": "uint48"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "expirationTimestampsLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getProtocolDetails",
		"outputs": [
			{
				"internalType": "bytes32",
				"name": "_name",
				"type": "bytes32"
			},
			{
				"internalType": "bool",
				"name": "_active",
				"type": "bool"
			},
			{
				"internalType": "uint256",
				"name": "_claimNonce",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_claimRedeemDelay",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_noclaimRedeemDelay",
				"type": "uint256"
			},
			{
				"internalType": "address[]",
				"name": "_collaterals",
				"type": "address[]"
			},
			{
				"internalType": "uint48[]",
				"name": "_expirationTimestamps",
				"type": "uint48[]"
			},
			{
				"internalType": "address[]",
				"name": "_allCovers",
				"type": "address[]"
			},
			{
				"internalType": "address[]",
				"name": "_allActiveCovers",
				"type": "address[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "bytes32",
				"name": "",
				"type": "bytes32"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "noclaimRedeemDelay",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "_active",
				"type": "bool"
			}
		],
		"name": "setActive",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_claimRedeemDelay",
				"type": "uint256"
			}
		],
		"name": "updateClaimRedeemDelay",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_collateral",
				"type": "address"
			},
			{
				"internalType": "uint8",
				"name": "_status",
				"type": "uint8"
			}
		],
		"name": "updateCollateral",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint48",
				"name": "_expirationTimestamp",
				"type": "uint48"
			},
			{
				"internalType": "bytes32",
				"name": "_expirationTimestampName",
				"type": "bytes32"
			},
			{
				"internalType": "uint8",
				"name": "_status",
				"type": "uint8"
			}
		],
		"name": "updateExpirationTimestamp",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_noclaimRedeemDelay",
				"type": "uint256"
			}
		],
		"name": "updateNoclaimRedeemDelay",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]

abis.protocols = [{"inputs":[{"internalType":"address","name":"_protocolImplementation","type":"address"},{"internalType":"address","name":"_coverImplementation","type":"address"},{"internalType":"address","name":"_coverERC20Implementation","type":"address"},{"internalType":"address","name":"_governance","type":"address"},{"internalType":"address","name":"_treasury","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferCompleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferInitiated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"protocolAddress","type":"address"}],"name":"ProtocolInitiation","type":"event"},{"inputs":[{"internalType":"bytes32","name":"_name","type":"bytes32"},{"internalType":"bool","name":"_active","type":"bool"},{"internalType":"address","name":"_collateral","type":"address"},{"internalType":"uint48[]","name":"_timestamps","type":"uint48[]"},{"internalType":"bytes32[]","name":"_timestampNames","type":"bytes32[]"}],"name":"addProtocol","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"coverERC20Implementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"coverImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAllProtocolAddresses","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_protocolName","type":"bytes32"},{"internalType":"uint48","name":"_timestamp","type":"uint48"},{"internalType":"address","name":"_collateral","type":"address"},{"internalType":"uint256","name":"_claimNonce","type":"uint256"},{"internalType":"bool","name":"_isClaimCovToken","type":"bool"}],"name":"getCovTokenAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_protocolName","type":"bytes32"},{"internalType":"uint48","name":"_timestamp","type":"uint48"},{"internalType":"address","name":"_collateral","type":"address"},{"internalType":"uint256","name":"_claimNonce","type":"uint256"}],"name":"getCoverAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_name","type":"bytes32"}],"name":"getProtocolAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"name":"getProtocolNameAndAddress","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getRedeemFees","outputs":[{"internalType":"uint16","name":"_numerator","type":"uint16"},{"internalType":"uint16","name":"_denominator","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"protocols","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"redeemFeeDenominator","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"redeemFeeNumerator","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"treasury","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"updateClaimManager","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newImplementation","type":"address"}],"name":"updateCoverERC20Implementation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newImplementation","type":"address"}],"name":"updateCoverImplementation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint16","name":"_redeemFeeNumerator","type":"uint16"},{"internalType":"uint16","name":"_redeemFeeDenominator","type":"uint16"}],"name":"updateFees","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"updateGovernance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newImplementation","type":"address"}],"name":"updateProtocolImplementation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"updateTreasury","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]

module.exports = {
  abis
}

'''
'''--- projects/config/curve/abis.js ---

let abis = {};

abis.abiNew = [{"name":"TokenExchange","inputs":[{"type":"address","name":"buyer","indexed":true},{"type":"int128","name":"sold_id","indexed":false},{"type":"uint256","name":"tokens_sold","indexed":false},{"type":"int128","name":"bought_id","indexed":false},{"type":"uint256","name":"tokens_bought","indexed":false}],"anonymous":false,"type":"event"},{"name":"TokenExchangeUnderlying","inputs":[{"type":"address","name":"buyer","indexed":true},{"type":"int128","name":"sold_id","indexed":false},{"type":"uint256","name":"tokens_sold","indexed":false},{"type":"int128","name":"bought_id","indexed":false},{"type":"uint256","name":"tokens_bought","indexed":false}],"anonymous":false,"type":"event"},{"name":"AddLiquidity","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[2]","name":"token_amounts","indexed":false},{"type":"uint256[2]","name":"fees","indexed":false},{"type":"uint256","name":"invariant","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidity","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[2]","name":"token_amounts","indexed":false},{"type":"uint256[2]","name":"fees","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityOne","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256","name":"token_amount","indexed":false},{"type":"uint256","name":"coin_amount","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityImbalance","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[2]","name":"token_amounts","indexed":false},{"type":"uint256[2]","name":"fees","indexed":false},{"type":"uint256","name":"invariant","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"CommitNewAdmin","inputs":[{"type":"uint256","name":"deadline","indexed":true},{"type":"address","name":"admin","indexed":true}],"anonymous":false,"type":"event"},{"name":"NewAdmin","inputs":[{"type":"address","name":"admin","indexed":true}],"anonymous":false,"type":"event"},{"name":"CommitNewFee","inputs":[{"type":"uint256","name":"deadline","indexed":true},{"type":"uint256","name":"fee","indexed":false},{"type":"uint256","name":"admin_fee","indexed":false}],"anonymous":false,"type":"event"},{"name":"NewFee","inputs":[{"type":"uint256","name":"fee","indexed":false},{"type":"uint256","name":"admin_fee","indexed":false}],"anonymous":false,"type":"event"},{"name":"RampA","inputs":[{"type":"uint256","name":"old_A","indexed":false},{"type":"uint256","name":"new_A","indexed":false},{"type":"uint256","name":"initial_time","indexed":false},{"type":"uint256","name":"future_time","indexed":false}],"anonymous":false,"type":"event"},{"name":"StopRampA","inputs":[{"type":"uint256","name":"A","indexed":false},{"type":"uint256","name":"t","indexed":false}],"anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"type":"address","name":"_owner"},{"type":"address[2]","name":"_coins"},{"type":"address","name":"_pool_token"},{"type":"address","name":"_base_pool"},{"type":"uint256","name":"_A"},{"type":"uint256","name":"_fee"},{"type":"uint256","name":"_admin_fee"}],"stateMutability":"nonpayable","type":"constructor"},{"name":"A","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":5199},{"name":"A_precise","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":5161},{"name":"get_virtual_price","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":992460},{"name":"calc_token_amount","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256[2]","name":"amounts"},{"type":"bool","name":"is_deposit"}],"stateMutability":"view","type":"function","gas":3938567},{"name":"add_liquidity","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256[2]","name":"amounts"},{"type":"uint256","name":"min_mint_amount"}],"stateMutability":"nonpayable","type":"function","gas":6136485},{"name":"get_dy","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"}],"stateMutability":"view","type":"function","gas":2390018},{"name":"get_dy_underlying","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"}],"stateMutability":"view","type":"function","gas":2393224},{"name":"exchange","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"},{"type":"uint256","name":"min_dy"}],"stateMutability":"nonpayable","type":"function","gas":2617039},{"name":"exchange_underlying","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"},{"type":"uint256","name":"min_dy"}],"stateMutability":"nonpayable","type":"function","gas":2631854},{"name":"remove_liquidity","outputs":[{"type":"uint256[2]","name":""}],"inputs":[{"type":"uint256","name":"_amount"},{"type":"uint256[2]","name":"min_amounts"}],"stateMutability":"nonpayable","type":"function","gas":163158},{"name":"remove_liquidity_imbalance","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256[2]","name":"amounts"},{"type":"uint256","name":"max_burn_amount"}],"stateMutability":"nonpayable","type":"function","gas":6136334},{"name":"calc_withdraw_one_coin","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"_token_amount"},{"type":"int128","name":"i"}],"stateMutability":"view","type":"function","gas":4389},{"name":"remove_liquidity_one_coin","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"_token_amount"},{"type":"int128","name":"i"},{"type":"uint256","name":"_min_amount"}],"stateMutability":"nonpayable","type":"function","gas":3826262},{"name":"ramp_A","outputs":[],"inputs":[{"type":"uint256","name":"_future_A"},{"type":"uint256","name":"_future_time"}],"stateMutability":"nonpayable","type":"function","gas":151894},{"name":"stop_ramp_A","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":148655},{"name":"commit_new_fee","outputs":[],"inputs":[{"type":"uint256","name":"new_fee"},{"type":"uint256","name":"new_admin_fee"}],"stateMutability":"nonpayable","type":"function","gas":110491},{"name":"apply_new_fee","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":97272},{"name":"revert_new_parameters","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":21925},{"name":"commit_transfer_ownership","outputs":[],"inputs":[{"type":"address","name":"_owner"}],"stateMutability":"nonpayable","type":"function","gas":74663},{"name":"apply_transfer_ownership","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":60740},{"name":"revert_transfer_ownership","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":22015},{"name":"admin_balances","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"i"}],"stateMutability":"view","type":"function","gas":3511},{"name":"withdraw_admin_fees","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":9232},{"name":"donate_admin_fees","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":74995},{"name":"kill_me","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":38028},{"name":"unkill_me","outputs":[],"inputs":[],"stateMutability":"nonpayable","type":"function","gas":22165},{"name":"coins","outputs":[{"type":"address","name":""}],"inputs":[{"type":"uint256","name":"arg0"}],"stateMutability":"view","type":"function","gas":2250},{"name":"balances","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"arg0"}],"stateMutability":"view","type":"function","gas":2280},{"name":"fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2201},{"name":"admin_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2231},{"name":"owner","outputs":[{"type":"address","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2261},{"name":"token","outputs":[{"type":"address","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2291},{"name":"base_pool","outputs":[{"type":"address","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2321},{"name":"base_virtual_price","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2351},{"name":"base_cache_updated","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2381},{"name":"base_coins","outputs":[{"type":"address","name":""}],"inputs":[{"type":"uint256","name":"arg0"}],"stateMutability":"view","type":"function","gas":2520},{"name":"initial_A","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2441},{"name":"future_A","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2471},{"name":"initial_A_time","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2501},{"name":"future_A_time","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2531},{"name":"admin_actions_deadline","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2561},{"name":"transfer_ownership_deadline","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2591},{"name":"future_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2621},{"name":"future_admin_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2651},{"name":"future_owner","outputs":[{"type":"address","name":""}],"inputs":[],"stateMutability":"view","type":"function","gas":2681}]

abis.abisBTC = [{"name":"TokenExchange","inputs":[{"type":"address","name":"buyer","indexed":true},{"type":"int128","name":"sold_id","indexed":false},{"type":"uint256","name":"tokens_sold","indexed":false},{"type":"int128","name":"bought_id","indexed":false},{"type":"uint256","name":"tokens_bought","indexed":false}],"anonymous":false,"type":"event"},{"name":"AddLiquidity","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[3]","name":"token_amounts","indexed":false},{"type":"uint256[3]","name":"fees","indexed":false},{"type":"uint256","name":"invariant","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidity","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[3]","name":"token_amounts","indexed":false},{"type":"uint256[3]","name":"fees","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityOne","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256","name":"token_amount","indexed":false},{"type":"uint256","name":"coin_amount","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityImbalance","inputs":[{"type":"address","name":"provider","indexed":true},{"type":"uint256[3]","name":"token_amounts","indexed":false},{"type":"uint256[3]","name":"fees","indexed":false},{"type":"uint256","name":"invariant","indexed":false},{"type":"uint256","name":"token_supply","indexed":false}],"anonymous":false,"type":"event"},{"name":"CommitNewAdmin","inputs":[{"type":"uint256","name":"deadline","indexed":true,"unit":"sec"},{"type":"address","name":"admin","indexed":true}],"anonymous":false,"type":"event"},{"name":"NewAdmin","inputs":[{"type":"address","name":"admin","indexed":true}],"anonymous":false,"type":"event"},{"name":"CommitNewFee","inputs":[{"type":"uint256","name":"deadline","indexed":true,"unit":"sec"},{"type":"uint256","name":"fee","indexed":false},{"type":"uint256","name":"admin_fee","indexed":false}],"anonymous":false,"type":"event"},{"name":"NewFee","inputs":[{"type":"uint256","name":"fee","indexed":false},{"type":"uint256","name":"admin_fee","indexed":false}],"anonymous":false,"type":"event"},{"name":"RampA","inputs":[{"type":"uint256","name":"old_A","indexed":false},{"type":"uint256","name":"new_A","indexed":false},{"type":"uint256","name":"initial_time","indexed":false,"unit":"sec"},{"type":"uint256","name":"future_time","indexed":false,"unit":"sec"}],"anonymous":false,"type":"event"},{"name":"StopRampA","inputs":[{"type":"uint256","name":"A","indexed":false},{"type":"uint256","name":"t","indexed":false,"unit":"sec"}],"anonymous":false,"type":"event"},{"outputs":[],"inputs":[{"type":"address[3]","name":"_coins"},{"type":"address","name":"_pool_token"},{"type":"uint256","name":"_A"},{"type":"uint256","name":"_fee"}],"constant":false,"payable":false,"type":"constructor"},{"name":"A","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":5227},{"name":"get_virtual_price","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":1150488},{"name":"calc_token_amount","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256[3]","name":"amounts"},{"type":"bool","name":"deposit"}],"constant":true,"payable":false,"type":"function","gas":4526955},{"name":"add_liquidity","outputs":[],"inputs":[{"type":"uint256[3]","name":"amounts"},{"type":"uint256","name":"min_mint_amount"}],"constant":false,"payable":false,"type":"function","gas":6972762},{"name":"get_dy","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"}],"constant":true,"payable":false,"type":"function","gas":2687932},{"name":"get_dy_underlying","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"}],"constant":true,"payable":false,"type":"function","gas":2687745},{"name":"exchange","outputs":[],"inputs":[{"type":"int128","name":"i"},{"type":"int128","name":"j"},{"type":"uint256","name":"dx"},{"type":"uint256","name":"min_dy"}],"constant":false,"payable":false,"type":"function","gas":5499133},{"name":"remove_liquidity","outputs":[],"inputs":[{"type":"uint256","name":"_amount"},{"type":"uint256[3]","name":"min_amounts"}],"constant":false,"payable":false,"type":"function","gas":196975},{"name":"remove_liquidity_imbalance","outputs":[],"inputs":[{"type":"uint256[3]","name":"amounts"},{"type":"uint256","name":"max_burn_amount"}],"constant":false,"payable":false,"type":"function","gas":6972281},{"name":"calc_withdraw_one_coin","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"_token_amount"},{"type":"int128","name":"i"}],"constant":true,"payable":false,"type":"function","gas":15405},{"name":"remove_liquidity_one_coin","outputs":[],"inputs":[{"type":"uint256","name":"_token_amount"},{"type":"int128","name":"i"},{"type":"uint256","name":"min_amount"}],"constant":false,"payable":false,"type":"function","gas":4044074},{"name":"ramp_A","outputs":[],"inputs":[{"type":"uint256","name":"_future_A"},{"type":"uint256","unit":"sec","name":"_future_time"}],"constant":false,"payable":false,"type":"function","gas":151937},{"name":"stop_ramp_A","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":148697},{"name":"commit_new_fee","outputs":[],"inputs":[{"type":"uint256","name":"new_fee"},{"type":"uint256","name":"new_admin_fee"}],"constant":false,"payable":false,"type":"function","gas":110521},{"name":"apply_new_fee","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":97220},{"name":"revert_new_parameters","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":21955},{"name":"commit_transfer_ownership","outputs":[],"inputs":[{"type":"address","name":"_owner"}],"constant":false,"payable":false,"type":"function","gas":74632},{"name":"apply_transfer_ownership","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":60688},{"name":"revert_transfer_ownership","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":22045},{"name":"withdraw_admin_fees","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":17565},{"name":"kill_me","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":37998},{"name":"unkill_me","outputs":[],"inputs":[],"constant":false,"payable":false,"type":"function","gas":22135},{"name":"coins","outputs":[{"type":"address","name":""}],"inputs":[{"type":"int128","name":"arg0"}],"constant":true,"payable":false,"type":"function","gas":2310},{"name":"balances","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"int128","name":"arg0"}],"constant":true,"payable":false,"type":"function","gas":2340},{"name":"fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2171},{"name":"admin_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2201},{"name":"owner","outputs":[{"type":"address","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2231},{"name":"initial_A","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2261},{"name":"future_A","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2291},{"name":"initial_A_time","outputs":[{"type":"uint256","unit":"sec","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2321},{"name":"future_A_time","outputs":[{"type":"uint256","unit":"sec","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2351},{"name":"admin_actions_deadline","outputs":[{"type":"uint256","unit":"sec","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2381},{"name":"transfer_ownership_deadline","outputs":[{"type":"uint256","unit":"sec","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2411},{"name":"future_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2441},{"name":"future_admin_fee","outputs":[{"type":"uint256","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2471},{"name":"future_owner","outputs":[{"type":"address","name":""}],"inputs":[],"constant":true,"payable":false,"type":"function","gas":2501}];

abis.yTokens = [{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"constant":true,"inputs":[],"name":"aave","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"aaveToken","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"approveToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"apr","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceAave","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceCompound","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceCompoundInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceDydx","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceFulcrum","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"balanceFulcrumInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"calcPoolValueInToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"compound","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"dToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"deposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"dydx","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"fulcrum","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getAave","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getAaveCore","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getPricePerFullShare","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"isOwner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"pool","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"provider","outputs":[{"internalType":"enum yTUSD.Lender","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"rebalance","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"recommend","outputs":[{"internalType":"enum yTUSD.Lender","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_new_APR","type":"address"}],"name":"set_new_APR","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_new_COMPOUND","type":"address"}],"name":"set_new_COMPOUND","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_new_DTOKEN","type":"uint256"}],"name":"set_new_DTOKEN","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"supplyAave","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"supplyCompound","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"supplyDydx","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"supplyFulcrum","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"token","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"_shares","type":"uint256"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]

module.exports = {
  abis
}

'''
'''--- projects/config/defisaver/abis.js ---
module.exports = {
  "AaveSubscriptions": {
    "abi": [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"bool","name":"","type":"bool"}],"name":"ParamUpdates","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Subscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Unsubscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Updated","type":"event"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"changeIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getHolder","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSubscribers","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_page","type":"uint256"},{"internalType":"uint256","name":"_perPage","type":"uint256"}],"name":"getSubscribersByPage","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"isSubscribed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"kill","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"setOwnerByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint128","name":"_minRatio","type":"uint128"},{"internalType":"uint128","name":"_maxRatio","type":"uint128"},{"internalType":"uint128","name":"_optimalBoost","type":"uint128"},{"internalType":"uint128","name":"_optimalRepay","type":"uint128"},{"internalType":"bool","name":"_boostEnabled","type":"bool"}],"name":"subscribe","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"subscribers","outputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribersPos","outputs":[{"internalType":"uint256","name":"arrPos","type":"uint256"},{"internalType":"bool","name":"subscribed","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"unsubscribe","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"unsubscribeByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"withdrawStuckFunds","outputs":[],"stateMutability":"nonpayable","type":"function"}],
      "networks": {
      "1": {
        "createdBlock": 10386357,
          "address": "0xe08ff7a2badb634f0b581e675e6b3e583de086fc"
      }
    }
  },
  "AaveLoanInfo": {
    "abi": [{"inputs":[],"name":"AAVE_LENDING_POOL_ADDRESSES","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"AAVE_REFERRAL_CODE","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DISCOUNT_ADDR","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ETH_ADDR","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NINETY_NINE_PERCENT_WEI","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SERVICE_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"WALLET_ADDR","outputs":[{"internalType":"address payable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getCollFactors","outputs":[{"internalType":"uint256[]","name":"collFactors","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_tokenAddresses","type":"address[]"}],"name":"getFullTokensInfo","outputs":[{"components":[{"internalType":"address","name":"aTokenAddress","type":"address"},{"internalType":"address","name":"underlyingTokenAddress","type":"address"},{"internalType":"uint256","name":"supplyRate","type":"uint256"},{"internalType":"uint256","name":"borrowRate","type":"uint256"},{"internalType":"uint256","name":"totalSupply","type":"uint256"},{"internalType":"uint256","name":"availableLiquidity","type":"uint256"},{"internalType":"uint256","name":"totalBorrow","type":"uint256"},{"internalType":"uint256","name":"collateralFactor","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"bool","name":"usageAsCollateralEnabled","type":"bool"}],"internalType":"struct AaveLoanInfo.TokenInfoFull[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getLoanData","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowAmounts","type":"uint256[]"}],"internalType":"struct AaveLoanInfo.LoanData","name":"data","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getLoanDataArr","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowAmounts","type":"uint256[]"}],"internalType":"struct AaveLoanInfo.LoanData[]","name":"loans","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_borrowAddress","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"getMaxBorrow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_collateralAddress","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"getMaxCollateral","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getPrices","outputs":[{"internalType":"uint256[]","name":"prices","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getRatios","outputs":[{"internalType":"uint256[]","name":"ratios","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getSafetyRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"},{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getTokenBalances","outputs":[{"internalType":"uint256[]","name":"balances","type":"uint256[]"},{"internalType":"uint256[]","name":"borrows","type":"uint256[]"},{"internalType":"bool[]","name":"enabledAsCollateral","type":"bool[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_tokenAddresses","type":"address[]"}],"name":"getTokensInfo","outputs":[{"components":[{"internalType":"address","name":"aTokenAddress","type":"address"},{"internalType":"address","name":"underlyingTokenAddress","type":"address"},{"internalType":"uint256","name":"collateralFactor","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"}],"internalType":"struct AaveLoanInfo.TokenInfo[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"address","name":"_user","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"sendContractBalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"sendFullContractBalance","outputs":[],"stateMutability":"nonpayable","type":"function"}],
    "networks": {
      "1": {
        "createdBlock": 9927785,
        "address": "0x1Df7A99Bb19a09C2FF53D3c9240073B30ea72Bfa"
      }
    }
  },
  "CompoundSubscriptions": {
    "abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"bool","name":"","type":"bool"}],"name":"ParamUpdates","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Subscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Unsubscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Updated","type":"event"},{"constant":true,"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"changeIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getHolder","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder","name":"","type":"tuple"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getSubscribers","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder[]","name":"","type":"tuple[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"uint256","name":"_page","type":"uint256"},{"internalType":"uint256","name":"_perPage","type":"uint256"}],"name":"getSubscribersByPage","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct CompoundSubscriptions.CompoundHolder[]","name":"","type":"tuple[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"isSubscribed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByOwner","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"setOwnerByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint128","name":"_minRatio","type":"uint128"},{"internalType":"uint128","name":"_maxRatio","type":"uint128"},{"internalType":"uint128","name":"_optimalBoost","type":"uint128"},{"internalType":"uint128","name":"_optimalRepay","type":"uint128"},{"internalType":"bool","name":"_boostEnabled","type":"bool"}],"name":"subscribe","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"subscribers","outputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribersPos","outputs":[{"internalType":"uint256","name":"arrPos","type":"uint256"},{"internalType":"bool","name":"subscribed","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"unsubscribe","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"unsubscribeByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}],
      "networks": {
      "1": {
        "createdBlock": 8335635,
          "address": "0x52015effd577e08f498a0ccc11905925d58d6207"
      }
    }
  },
  "CompoundLoanInfo": {
    "abi": [{"constant":true,"inputs":[],"name":"CETH_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"COMPOUND_LOGGER","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"COMPOUND_ORACLE","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"COMPTROLLER","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DISCOUNT_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SERVICE_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"WALLET_ID","outputs":[{"internalType":"address payable","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"comp","outputs":[{"internalType":"contract ComptrollerInterface","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address[]","name":"_cTokens","type":"address[]"}],"name":"getCollFactors","outputs":[{"internalType":"uint256[]","name":"collFactors","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getLoanData","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowAmounts","type":"uint256[]"}],"internalType":"struct CompoundLoanInfo.LoanData","name":"data","type":"tuple"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getLoanDataArr","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowAmounts","type":"uint256[]"}],"internalType":"struct CompoundLoanInfo.LoanData[]","name":"loans","type":"tuple[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_cBorrowAddress","type":"address"}],"name":"getMaxBorrow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_cCollAddress","type":"address"}],"name":"getMaxCollateral","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address[]","name":"_cTokens","type":"address[]"}],"name":"getPrices","outputs":[{"internalType":"uint256[]","name":"prices","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getRatios","outputs":[{"internalType":"uint256[]","name":"ratios","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address[]","name":"_cTokenAddresses","type":"address[]"}],"name":"getTokensInfo","outputs":[{"components":[{"internalType":"address","name":"cTokenAddress","type":"address"},{"internalType":"address","name":"underlyingTokenAddress","type":"address"},{"internalType":"uint256","name":"collateralFactor","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"}],"internalType":"struct CompoundLoanInfo.TokenInfo[]","name":"tokens","type":"tuple[]"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"oracle","outputs":[{"internalType":"contract CompoundOracle","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"}],
    "networks": {
      "1": {
        "createdBlock": 8335635,
        "address": "0xb1f40b5109bba75c27a302c4e5d2afc30d5d1f30"
      }
    }
  },
  "McdSubscriptions": {
    "abi":[{"constant":true,"inputs":[],"name":"WETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"CDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getSubscribers","outputs":[{"components":[{"name":"minRatio","type":"uint128"},{"name":"maxRatio","type":"uint128"},{"name":"optimalRatioBoost","type":"uint128"},{"name":"optimalRatioRepay","type":"uint128"},{"name":"owner","type":"address"},{"name":"cdpId","type":"uint256"},{"name":"boostEnabled","type":"bool"},{"name":"nextPriceEnabled","type":"bool"}],"name":"","type":"tuple[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAVINGS_LOGGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"changeIndex","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"getCdpHolder","outputs":[{"name":"subscribed","type":"bool"},{"components":[{"name":"minRatio","type":"uint128"},{"name":"maxRatio","type":"uint128"},{"name":"optimalRatioBoost","type":"uint128"},{"name":"optimalRatioRepay","type":"uint128"},{"name":"owner","type":"address"},{"name":"cdpId","type":"uint256"},{"name":"boostEnabled","type":"bool"},{"name":"nextPriceEnabled","type":"bool"}],"name":"","type":"tuple"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PIP_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_owner","type":"address"}],"name":"setOwnerByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_ETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"OTC_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"IDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_ilk","type":"bytes32"},{"name":"_cdpId","type":"uint256"}],"name":"getIlkInfo","outputs":[{"name":"ilk","type":"bytes32"},{"name":"art","type":"uint256"},{"name":"rate","type":"uint256"},{"name":"spot","type":"uint256"},{"name":"line","type":"uint256"},{"name":"dust","type":"uint256"},{"name":"mat","type":"uint256"},{"name":"par","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"spotter","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"GAS_TOKEN_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"vat","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"VOX_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MANAGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MONITOR_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH2DAI_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"manager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"STUPID_EXCHANGE","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"subscribers","outputs":[{"name":"minRatio","type":"uint128"},{"name":"maxRatio","type":"uint128"},{"name":"optimalRatioBoost","type":"uint128"},{"name":"optimalRatioRepay","type":"uint128"},{"name":"owner","type":"address"},{"name":"cdpId","type":"uint256"},{"name":"boostEnabled","type":"bool"},{"name":"nextPriceEnabled","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_minRatio","type":"uint128"},{"name":"_maxRatio","type":"uint128"},{"name":"_optimalBoost","type":"uint128"},{"name":"_optimalRepay","type":"uint128"},{"name":"_boostEnabled","type":"bool"},{"name":"_nextPriceEnabled","type":"bool"}],"name":"subscribe","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"MIGRATION_ACTIONS_PROXY","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"minLimits","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SPOTTER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"subscribersPos","outputs":[{"name":"arrPos","type":"uint256"},{"name":"subscribed","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PROXY_REGISTRY_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PROXY_ACTIONS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MKR_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"FACTORY_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_page","type":"uint256"},{"name":"_perPage","type":"uint256"}],"name":"getSubscribersByPage","outputs":[{"components":[{"name":"minRatio","type":"uint128"},{"name":"maxRatio","type":"uint128"},{"name":"optimalRatioBoost","type":"uint128"},{"name":"optimalRatioRepay","type":"uint128"},{"name":"owner","type":"address"},{"name":"cdpId","type":"uint256"},{"name":"boostEnabled","type":"bool"},{"name":"nextPriceEnabled","type":"bool"}],"name":"","type":"tuple[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"unsubscribeByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"LOGGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAVER_EXCHANGE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MAKER_DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DISCOUNT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_admin","type":"address"}],"name":"setAdminByAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"JUG_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"unsubscribe","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"NEW_CDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SUBSCRIPTION_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"NEW_IDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"COMPOUND_DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"UNISWAP_FACTORY","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"OASIS_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"getSubscribedInfo","outputs":[{"name":"","type":"bool"},{"name":"","type":"uint128"},{"name":"","type":"uint128"},{"name":"","type":"uint128"},{"name":"","type":"uint128"},{"name":"","type":"address"},{"name":"coll","type":"uint256"},{"name":"debt","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_INTERFACE","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"VAT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DAI_JOIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ERC20_PROXY_0X","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"WALLET_ID","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SOLO_MARGIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"UNISWAP_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_admin","type":"address"}],"name":"setAdminByOwner","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"saverProxy","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_ilk","type":"bytes32"},{"name":"_newRatio","type":"uint256"}],"name":"changeMinRatios","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"TUB_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH_JOIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SCD_MCD_MIGRATION","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"admin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_saverProxy","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"cdpId","type":"uint256"}],"name":"Subscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"cdpId","type":"uint256"}],"name":"Unsubscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"cdpId","type":"uint256"}],"name":"Updated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"cdpId","type":"uint256"},{"indexed":false,"name":"","type":"uint128"},{"indexed":false,"name":"","type":"uint128"},{"indexed":false,"name":"","type":"uint128"},{"indexed":false,"name":"","type":"uint128"},{"indexed":false,"name":"boostEnabled","type":"bool"}],"name":"ParamUpdates","type":"event"}],
      "networks": {
      "1": {
        "createdBlock": 8335635,
          "address": "0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a"
      }
    }
  },
  "MCDSaverProxy": {
    "abi": [{"constant":true,"inputs":[],"name":"WETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"CDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAVINGS_LOGGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH_ILK","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PIP_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_ETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"OTC_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"IDAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"spotter","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_manager","type":"address"},{"name":"_cdpId","type":"uint256"}],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"GAS_TOKEN_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"vat","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"VOX_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MANAGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_manager","type":"address"},{"name":"_cdpId","type":"uint256"},{"name":"_ilk","type":"bytes32"}],"name":"getCdpInfo","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MONITOR_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH2DAI_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"manager","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"STUPID_EXCHANGE","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SERVICE_FEE","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SPOTTER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PROXY_REGISTRY_INTERFACE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MKR_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"FACTORY_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"LOGGER_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAVER_EXCHANGE_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MAKER_DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DISCOUNT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"JUG_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SUBSCRIPTION_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"daiJoin","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"COMPOUND_DAI_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SAI_SAVER_PROXY","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"UNISWAP_FACTORY","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"OASIS_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PETH_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"KYBER_INTERFACE","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"VAT_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"DAI_JOIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"WALLET_ID","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SOLO_MARGIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"UNISWAP_WRAPPER","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"TUB_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ETH_JOIN_ADDRESS","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"SCD_MCD_MIGRATION","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_joinAddr","type":"address"},{"name":"_amount","type":"uint256"},{"name":"_minPrice","type":"uint256"},{"name":"_exchangeType","type":"uint256"},{"name":"_gasCost","type":"uint256"}],"name":"repay","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_joinAddr","type":"address"},{"name":"_daiAmount","type":"uint256"},{"name":"_minPrice","type":"uint256"},{"name":"_exchangeType","type":"uint256"},{"name":"_gasCost","type":"uint256"}],"name":"boost","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_ilk","type":"bytes32"}],"name":"getMaxCollateral","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_ilk","type":"bytes32"}],"name":"getMaxDebt","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_ilk","type":"bytes32"}],"name":"getPrice","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"},{"name":"_ilk","type":"bytes32"}],"name":"getRatio","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_cdpId","type":"uint256"}],"name":"getCdpDetailedInfo","outputs":[{"name":"collateral","type":"uint256"},{"name":"debt","type":"uint256"},{"name":"price","type":"uint256"},{"name":"ilk","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"}],
    "networks": {
      "42": {
        "createdBlock": 14500373,
        "address": "0xDbfdfDBcA9f796Bf955B8B4EB2b46dBb51CaE30B"
      },
      "1": {
        "createdBlock": 8928152,
        "address": "0x260C1543743FD03cD98a1d1eDC3A4724af0A1Fce"
      }
    }
  },
  "AaveSubscriptionsV2": {
    "abi": [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"uint128","name":"","type":"uint128"},{"indexed":false,"internalType":"bool","name":"","type":"bool"}],"name":"ParamUpdates","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Subscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Unsubscribed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"}],"name":"Updated","type":"event"},{"inputs":[],"name":"NAME","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"changeIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"getHolder","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct AaveSubscriptionsV2.AaveHolder","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSubscribers","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct AaveSubscriptionsV2.AaveHolder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_page","type":"uint256"},{"internalType":"uint256","name":"_perPage","type":"uint256"}],"name":"getSubscribersByPage","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"internalType":"struct AaveSubscriptionsV2.AaveHolder[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"isSubscribed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"kill","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_admin","type":"address"}],"name":"setAdminByOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"setOwnerByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint128","name":"_minRatio","type":"uint128"},{"internalType":"uint128","name":"_maxRatio","type":"uint128"},{"internalType":"uint128","name":"_optimalBoost","type":"uint128"},{"internalType":"uint128","name":"_optimalRepay","type":"uint128"},{"internalType":"bool","name":"_boostEnabled","type":"bool"}],"name":"subscribe","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"subscribers","outputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"minRatio","type":"uint128"},{"internalType":"uint128","name":"maxRatio","type":"uint128"},{"internalType":"uint128","name":"optimalRatioBoost","type":"uint128"},{"internalType":"uint128","name":"optimalRatioRepay","type":"uint128"},{"internalType":"bool","name":"boostEnabled","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"subscribersPos","outputs":[{"internalType":"uint256","name":"arrPos","type":"uint256"},{"internalType":"bool","name":"subscribed","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"unsubscribe","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"}],"name":"unsubscribeByAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"withdrawStuckFunds","outputs":[],"stateMutability":"nonpayable","type":"function"}],
    "networks": {
      "1": {
        "address": "0x6B25043BF08182d8e86056C6548847aF607cd7CD"
      }
    }
  },
  "AaveLoanInfoV2": {
    "abi": [{"inputs":[],"name":"AAVE_REFERRAL_CODE","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"AUTOMATIC_SERVICE_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"BOT_REGISTRY_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DISCOUNT_ADDR","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ETH_ADDR","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MANUAL_SERVICE_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NINETY_NINE_PERCENT_WEI","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"STABLE_ID","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"VARIABLE_ID","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"WALLET_ADDR","outputs":[{"internalType":"address payable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"WETH_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getCollFactors","outputs":[{"internalType":"uint256[]","name":"collFactors","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_tokenAddresses","type":"address[]"}],"name":"getFullTokensInfo","outputs":[{"components":[{"internalType":"address","name":"aTokenAddress","type":"address"},{"internalType":"address","name":"underlyingTokenAddress","type":"address"},{"internalType":"uint256","name":"supplyRate","type":"uint256"},{"internalType":"uint256","name":"borrowRateVariable","type":"uint256"},{"internalType":"uint256","name":"borrowRateStable","type":"uint256"},{"internalType":"uint256","name":"totalSupply","type":"uint256"},{"internalType":"uint256","name":"availableLiquidity","type":"uint256"},{"internalType":"uint256","name":"totalBorrow","type":"uint256"},{"internalType":"uint256","name":"collateralFactor","type":"uint256"},{"internalType":"uint256","name":"liquidationRatio","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"bool","name":"usageAsCollateralEnabled","type":"bool"},{"internalType":"bool","name":"borrowinEnabled","type":"bool"},{"internalType":"bool","name":"stableBorrowRateEnabled","type":"bool"}],"internalType":"struct AaveLoanInfoV2.TokenInfoFull[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"getLoanData","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowStableAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowVariableAmounts","type":"uint256[]"}],"internalType":"struct AaveLoanInfoV2.LoanData","name":"data","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getLoanDataArr","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint128","name":"ratio","type":"uint128"},{"internalType":"address[]","name":"collAddr","type":"address[]"},{"internalType":"address[]","name":"borrowAddr","type":"address[]"},{"internalType":"uint256[]","name":"collAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowStableAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"borrowVariableAmounts","type":"uint256[]"}],"internalType":"struct AaveLoanInfoV2.LoanData[]","name":"loans","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getPrices","outputs":[{"internalType":"uint256[]","name":"prices","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"getRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_users","type":"address[]"}],"name":"getRatios","outputs":[{"internalType":"uint256[]","name":"ratios","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address","name":"_user","type":"address"}],"name":"getSafetyRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address","name":"_user","type":"address"},{"internalType":"address[]","name":"_tokens","type":"address[]"}],"name":"getTokenBalances","outputs":[{"components":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"borrowsStable","type":"uint256"},{"internalType":"uint256","name":"borrowsVariable","type":"uint256"},{"internalType":"uint256","name":"stableBorrowRate","type":"uint256"},{"internalType":"bool","name":"enabledAsCollateral","type":"bool"}],"internalType":"struct AaveLoanInfoV2.UserToken[]","name":"userTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_market","type":"address"},{"internalType":"address[]","name":"_tokenAddresses","type":"address[]"}],"name":"getTokensInfo","outputs":[{"components":[{"internalType":"address","name":"aTokenAddress","type":"address"},{"internalType":"address","name":"underlyingTokenAddress","type":"address"},{"internalType":"uint256","name":"collateralFactor","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"}],"internalType":"struct AaveLoanInfoV2.TokenInfo[]","name":"tokens","type":"tuple[]"}],"stateMutability":"view","type":"function"}],
    "networks": {
      "1": {
        "address": "0xd0C9ADDABbA270493A6503e74E62794435c8F1D3"
      }
    }
  },
}

'''
'''--- projects/config/ellipsis/abis.js ---
let abis = {}
abis.main = [{"name":"TokenExchange","inputs":[{"name":"buyer","type":"address","indexed":true},{"name":"sold_id","type":"int128","indexed":false},{"name":"tokens_sold","type":"uint256","indexed":false},{"name":"bought_id","type":"int128","indexed":false},{"name":"tokens_bought","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"AddLiquidity","inputs":[{"name":"provider","type":"address","indexed":true},{"name":"token_amounts","type":"uint256[3]","indexed":false},{"name":"fees","type":"uint256[3]","indexed":false},{"name":"invariant","type":"uint256","indexed":false},{"name":"token_supply","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidity","inputs":[{"name":"provider","type":"address","indexed":true},{"name":"token_amounts","type":"uint256[3]","indexed":false},{"name":"fees","type":"uint256[3]","indexed":false},{"name":"token_supply","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityOne","inputs":[{"name":"provider","type":"address","indexed":true},{"name":"token_amount","type":"uint256","indexed":false},{"name":"coin_amount","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"RemoveLiquidityImbalance","inputs":[{"name":"provider","type":"address","indexed":true},{"name":"token_amounts","type":"uint256[3]","indexed":false},{"name":"fees","type":"uint256[3]","indexed":false},{"name":"invariant","type":"uint256","indexed":false},{"name":"token_supply","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"CommitNewAdmin","inputs":[{"name":"deadline","type":"uint256","indexed":true},{"name":"admin","type":"address","indexed":true}],"anonymous":false,"type":"event"},{"name":"NewAdmin","inputs":[{"name":"admin","type":"address","indexed":true}],"anonymous":false,"type":"event"},{"name":"CommitNewFee","inputs":[{"name":"deadline","type":"uint256","indexed":true},{"name":"fee","type":"uint256","indexed":false},{"name":"admin_fee","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"NewFee","inputs":[{"name":"fee","type":"uint256","indexed":false},{"name":"admin_fee","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"RampA","inputs":[{"name":"old_A","type":"uint256","indexed":false},{"name":"new_A","type":"uint256","indexed":false},{"name":"initial_time","type":"uint256","indexed":false},{"name":"future_time","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"name":"StopRampA","inputs":[{"name":"A","type":"uint256","indexed":false},{"name":"t","type":"uint256","indexed":false}],"anonymous":false,"type":"event"},{"stateMutability":"nonpayable","type":"constructor","inputs":[{"name":"_owner","type":"address"},{"name":"_coins","type":"address[3]"},{"name":"_pool_token","type":"address"},{"name":"_A","type":"uint256"},{"name":"_fee","type":"uint256"},{"name":"_admin_fee","type":"uint256"},{"name":"_fee_converter","type":"address"}],"outputs":[]},{"stateMutability":"view","type":"function","name":"A","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":5106},{"stateMutability":"view","type":"function","name":"get_virtual_price","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":1132771},{"stateMutability":"view","type":"function","name":"calc_token_amount","inputs":[{"name":"amounts","type":"uint256[3]"},{"name":"deposit","type":"bool"}],"outputs":[{"name":"","type":"uint256"}],"gas":4506209},{"stateMutability":"nonpayable","type":"function","name":"add_liquidity","inputs":[{"name":"amounts","type":"uint256[3]"},{"name":"min_mint_amount","type":"uint256"}],"outputs":[],"gas":6950840},{"stateMutability":"view","type":"function","name":"get_dy","inputs":[{"name":"i","type":"int128"},{"name":"j","type":"int128"},{"name":"dx","type":"uint256"}],"outputs":[{"name":"","type":"uint256"}],"gas":2672568},{"stateMutability":"view","type":"function","name":"get_dy_underlying","inputs":[{"name":"i","type":"int128"},{"name":"j","type":"int128"},{"name":"dx","type":"uint256"}],"outputs":[{"name":"","type":"uint256"}],"gas":2672270},{"stateMutability":"nonpayable","type":"function","name":"exchange","inputs":[{"name":"i","type":"int128"},{"name":"j","type":"int128"},{"name":"dx","type":"uint256"},{"name":"min_dy","type":"uint256"}],"outputs":[],"gas":2816580},{"stateMutability":"nonpayable","type":"function","name":"remove_liquidity","inputs":[{"name":"_amount","type":"uint256"},{"name":"min_amounts","type":"uint256[3]"}],"outputs":[],"gas":192419},{"stateMutability":"nonpayable","type":"function","name":"remove_liquidity_imbalance","inputs":[{"name":"amounts","type":"uint256[3]"},{"name":"max_burn_amount","type":"uint256"}],"outputs":[],"gas":6947760},{"stateMutability":"view","type":"function","name":"calc_withdraw_one_coin","inputs":[{"name":"_token_amount","type":"uint256"},{"name":"i","type":"int128"}],"outputs":[{"name":"","type":"uint256"}],"gas":1162},{"stateMutability":"nonpayable","type":"function","name":"remove_liquidity_one_coin","inputs":[{"name":"_token_amount","type":"uint256"},{"name":"i","type":"int128"},{"name":"min_amount","type":"uint256"}],"outputs":[],"gas":4022793},{"stateMutability":"nonpayable","type":"function","name":"ramp_A","inputs":[{"name":"_future_A","type":"uint256"},{"name":"_future_time","type":"uint256"}],"outputs":[],"gas":151582},{"stateMutability":"nonpayable","type":"function","name":"stop_ramp_A","inputs":[],"outputs":[],"gas":148300},{"stateMutability":"nonpayable","type":"function","name":"commit_new_fee","inputs":[{"name":"new_fee","type":"uint256"},{"name":"new_admin_fee","type":"uint256"}],"outputs":[],"gas":110158},{"stateMutability":"nonpayable","type":"function","name":"apply_new_fee","inputs":[],"outputs":[],"gas":96939},{"stateMutability":"nonpayable","type":"function","name":"revert_new_parameters","inputs":[],"outputs":[],"gas":21592},{"stateMutability":"nonpayable","type":"function","name":"commit_transfer_ownership","inputs":[{"name":"_owner","type":"address"}],"outputs":[],"gas":74330},{"stateMutability":"nonpayable","type":"function","name":"apply_transfer_ownership","inputs":[],"outputs":[],"gas":60407},{"stateMutability":"nonpayable","type":"function","name":"revert_transfer_ownership","inputs":[],"outputs":[],"gas":21682},{"stateMutability":"view","type":"function","name":"admin_balances","inputs":[{"name":"i","type":"uint256"}],"outputs":[{"name":"","type":"uint256"}],"gas":3178},{"stateMutability":"nonpayable","type":"function","name":"withdraw_admin_fees","inputs":[],"outputs":[],"gas":28794},{"stateMutability":"nonpayable","type":"function","name":"kill_me","inputs":[],"outputs":[],"gas":37665},{"stateMutability":"nonpayable","type":"function","name":"unkill_me","inputs":[],"outputs":[],"gas":21802},{"stateMutability":"view","type":"function","name":"coins","inputs":[{"name":"arg0","type":"uint256"}],"outputs":[{"name":"","type":"address"}],"gas":1887},{"stateMutability":"view","type":"function","name":"balances","inputs":[{"name":"arg0","type":"uint256"}],"outputs":[{"name":"","type":"uint256"}],"gas":1917},{"stateMutability":"view","type":"function","name":"fee","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":1838},{"stateMutability":"view","type":"function","name":"admin_fee","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":1868},{"stateMutability":"view","type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address"}],"gas":1898},{"stateMutability":"view","type":"function","name":"fee_converter","inputs":[],"outputs":[{"name":"","type":"address"}],"gas":1928},{"stateMutability":"view","type":"function","name":"initial_A","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":1958},{"stateMutability":"view","type":"function","name":"future_A","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":1988},{"stateMutability":"view","type":"function","name":"initial_A_time","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2018},{"stateMutability":"view","type":"function","name":"future_A_time","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2048},{"stateMutability":"view","type":"function","name":"admin_actions_deadline","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2078},{"stateMutability":"view","type":"function","name":"transfer_ownership_deadline","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2108},{"stateMutability":"view","type":"function","name":"future_fee","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2138},{"stateMutability":"view","type":"function","name":"future_admin_fee","inputs":[],"outputs":[{"name":"","type":"uint256"}],"gas":2168},{"stateMutability":"view","type":"function","name":"future_owner","inputs":[],"outputs":[{"name":"","type":"address"}],"gas":2198}]

module.exports = {
  abis
}

'''
'''--- projects/config/finnexus/abis.js ---
let abis = {};

abis.fnxOracle = [{"constant":true,"inputs":[{"internalType":"address","name":"asset","type":"address"}],"name":"getPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getTotalCollateral","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}];
module.exports = {
    abis
}
'''
'''--- projects/config/flamincome/abis.js ---
module.exports = {
    "VaultBaseline": [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"available","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"balance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"controller","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"depositAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"earn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"reserve","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"harvest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"max","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"min","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"priceE18","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_controller","type":"address"}],"name":"setController","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_governance","type":"address"}],"name":"setGovernance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_min","type":"uint256"}],"name":"setMin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_shares","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawAll","outputs":[],"stateMutability":"nonpayable","type":"function"}]
}
'''
'''--- projects/config/hakka/abi.json ---
{
    "balanceOf": {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    "totalSupply": {
      "constant": true,
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    "pancakeUserInfo": {
      "inputs": [
        { "internalType": "uint256", "name": "", "type": "uint256" },
        { "internalType": "address", "name": "", "type": "address" }
      ],
      "name": "userInfo",
      "outputs": [
        { "internalType": "uint256", "name": "amount", "type": "uint256" },
        { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "alpacaUserInfo": {
      "inputs": [
        { "internalType": "uint256", "name": "", "type": "uint256" },
        { "internalType": "address", "name": "", "type": "address" }
      ],
      "name": "userInfo",
      "outputs": [
        { "internalType": "uint256", "name": "amount", "type": "uint256" },
        { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" },
        { "internalType": "uint256", "name": "bonusDebt", "type": "uint256" },
        { "internalType": "address", "name": "fundedBy", "type": "address" }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "beltUserInfo": {
      "inputs": [
        { "internalType": "uint256", "name": "", "type": "uint256" },
        { "internalType": "address", "name": "", "type": "address" }
      ],
      "name": "userInfo",
      "outputs": [
        { "internalType": "uint256", "name": "shares", "type": "uint256" },
        { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
  
'''
'''--- projects/config/hodltree/addresses.js ---
const {
    dexType,
    flashloan,
    lendBorrow,
    em
} = require('./types.js');

/**
 * @typedef {Object} ContractDef
 * @property {String} contractType
 * @property {String} address
 * @property {Object} miscInfo
 */

/**
 * @typedef {Object} Dex
 * @property {String} dexType
 * @property {ContractDef[]} contracts
 */

/**
 * @typedef {Dex[]} NetworkDex
 */

/**
 * @type {NetworkDex}
 */
const eth = [
    {
        dexType: dexType.lendBorrow,
        contracts: [{
            contractType: lendBorrow.lender,
            address: '0xb3e1912fa5d9d219da8c65cda407cc998849428b',
            miscInfo: {
                tokenIn: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
            }
        }, {
            contractType: lendBorrow.borrower,
            address: '0x8ac9425260b6da02db07da7980b09525ebf3b6a0',
            miscInfo: {
                tokenIn: '0xBcca60bB61934080951369a648Fb03DF4F96263C'
            }
        }, {
            contractType: lendBorrow.borrower,
            address: '0x45d5a790da3bfa305efca81eac652678ae3a90a6',
            miscInfo: {
                tokenIn: '0x028171bCA77440897B824Ca71D1c56caC55b68A3'
            }
        }]
    },
    {
        dexType: dexType.flashloan,
        contracts: [{
            contractType: flashloan.lp,
            address: '0x2e5a08c26cb22109e585784c4f99363bb3e199ab',
            miscInfo: {
                tokensIn: [
                    '0x57Ab1ec28D129707052df4dF418D58a2D46d5f51',
                    '0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd',
                    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
                    '0x6B175474E89094C44Da98b954EedeAC495271d0F',
                    '0x0000000000085d4780B73119b644AE5ecd22b376'
                ]
            }
        }]
    },
    {
        dexType: dexType.em,
        contracts: [{
            contractType: em.ep,
            address: '0x95142849d31eaa20b5b9ab746dff27ff400ce6bf',
            miscInfo: {
                token: '0x28e598846febb750effc384853fbce82988eaaa2'
            }
        }, {
            contractType: em.rp,
            address: '0xce596bf99d21e46fa91143c03d7a356682b67859',
            miscInfo: {
                token: '0x57Ab1ec28D129707052df4dF418D58a2D46d5f51'
            }
        }, {
            contractType: em.vps,
            address: '0xb7ead8c418f3d03bc22dd538c22600abe7209e72',
            miscInfo: {
                token: '0x57ab1ec28d129707052df4df418d58a2d46d5f51'
            }
        }, 
        
        {
            contractType: em.ep,
            address: '0x78E52d69fA8e0F036fFEF0BcDc4C289DB0DF63E2',
            miscInfo: {
                token: '0xba100000625a3754423978a60c9317c58a424e3D'
            }
        }, {
            contractType: em.rp,
            address: '0x87B46E49681E08E3adDF8A90F6a1fb5183079033',
            miscInfo: {
                token: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
            }
        }, {
            contractType: em.vps,
            address: '0xcB72e764Ab46535aAD13cbF55b1F06cB15347A95',
            miscInfo: {
                token: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
            }
        }]
    }
]

/**
 * @type {NetworkDex}
 */
const polygon = [
    {
        dexType: dexType.lendBorrow,
        contracts: [{
            contractType: lendBorrow.lender,
            address: '0x2F35d311fd2F0b0dA65FA268B86831279FB4fd98',
            miscInfo: {
                tokenIn: '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270'
            }
        }, {
            contractType: lendBorrow.borrower,
            address: '0xbfb5215aD157Cd6C8B22494dC54Ff4B74bA18C09',
            miscInfo: {
                tokenIn: '0x1a13f4ca1d028320a707d99520abfefca3998b7f'
            }
        }, {
            contractType: lendBorrow.borrower,
            address: '0x0Cf91744D15684b91E6705e56f6dC820647B3067',
            miscInfo: {
                tokenIn: '0x27f8d03b3a2196956ed754badc28d73be8830a6e'
            }
        }]
    },
    {
        dexType: dexType.flashloan,
        contracts: [{
            contractType: flashloan.lp,
            address: '0xCAFDa65B1031535F1766C6b1E3b5efF5520c7C0f',
            miscInfo: {
                tokensIn: [
                    '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
                    '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',
                    '0xc2132D05D31c914a87C6611C10748AEb04B58e8F'
                ]
            }
        }]
    }
]

module.exports = {
    eth,
    polygon
}
'''
'''--- projects/config/hodltree/index.js ---
const { eth, polygon } = require("./addresses");
const dexTypes = require('./types');

module.exports = {
    ethContracts: eth,
    polygonContracts: polygon,
    dexTypes
}
'''
'''--- projects/config/hodltree/types.js ---
const dexType = {
    lendBorrow: 'lendBorrow',
    flashloan: 'flashloan',
    em: 'em'
}

const lendBorrow = {
    lender: 'lender',
    borrower: 'borrower'
}

const flashloan = {
    lp: 'liquidityPool'
}

const em = {
    ep: 'elasticPool',
    vp: 'volatilePool',
    vps: 'volatilePoolStorage',
    rp: 'reservePool'
}

module.exports = {
    dexType,
    lendBorrow,
    flashloan,
    em
}
'''
'''--- projects/config/indexed/abis.js ---

let abis = {};
abis.main = [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"src","type":"address"},{"indexed":true,"internalType":"address","name":"dst","type":"address"},{"indexed":false,"internalType":"uint256","name":"amt","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"newDenorm","type":"uint256"}],"name":"LOG_DENORM_UPDATED","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"desiredDenorm","type":"uint256"}],"name":"LOG_DESIRED_DENORM_SET","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOut","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenAmountOut","type":"uint256"}],"name":"LOG_EXIT","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"tokenIn","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenAmountIn","type":"uint256"}],"name":"LOG_JOIN","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"maxPoolTokens","type":"uint256"}],"name":"LOG_MAX_TOKENS_UPDATED","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"minimumBalance","type":"uint256"}],"name":"LOG_MINIMUM_BALANCE_UPDATED","type":"event"},{"anonymous":false,"inputs":[],"name":"LOG_PUBLIC_SWAP_ENABLED","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"tokenIn","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOut","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenAmountIn","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokenAmountOut","type":"uint256"}],"name":"LOG_SWAP","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"swapFee","type":"uint256"}],"name":"LOG_SWAP_FEE_UPDATED","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"desiredDenorm","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"minimumBalance","type":"uint256"}],"name":"LOG_TOKEN_ADDED","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token","type":"address"}],"name":"LOG_TOKEN_READY","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"token","type":"address"}],"name":"LOG_TOKEN_REMOVED","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"src","type":"address"},{"indexed":true,"internalType":"address","name":"dst","type":"address"},{"indexed":false,"internalType":"uint256","name":"amt","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"VERSION_NUMBER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"src","type":"address"},{"internalType":"address","name":"dst","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"whom","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"controller","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"}],"name":"configure","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"decreaseApproval","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"poolAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"minAmountsOut","type":"uint256[]"}],"name":"exitPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"tokenAmountOut","type":"uint256"},{"internalType":"uint256","name":"maxPoolAmountIn","type":"uint256"}],"name":"exitswapExternAmountOut","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"poolAmountIn","type":"uint256"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"}],"name":"exitswapPoolAmountIn","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"extrapolatePoolValueFromToken","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"flashBorrow","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getController","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentDesiredTokens","outputs":[{"internalType":"address[]","name":"tokens","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentTokens","outputs":[{"internalType":"address[]","name":"tokens","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getDenormalizedWeight","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getMaxPoolTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getMinimumBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNumTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"}],"name":"getSpotPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSwapFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getTokenRecord","outputs":[{"components":[{"internalType":"bool","name":"bound","type":"bool"},{"internalType":"bool","name":"ready","type":"bool"},{"internalType":"uint40","name":"lastDenormUpdate","type":"uint40"},{"internalType":"uint96","name":"denorm","type":"uint96"},{"internalType":"uint96","name":"desiredDenorm","type":"uint96"},{"internalType":"uint8","name":"index","type":"uint8"},{"internalType":"uint256","name":"balance","type":"uint256"}],"internalType":"struct IIndexPool.Record","name":"record","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalDenormalizedWeight","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getUsedBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"gulp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"increaseApproval","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"balances","type":"uint256[]"},{"internalType":"uint96[]","name":"denorms","type":"uint96[]"},{"internalType":"address","name":"tokenProvider","type":"address"},{"internalType":"address","name":"unbindHandler","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"t","type":"address"}],"name":"isBound","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isPublicSwap","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"poolAmountOut","type":"uint256"},{"internalType":"uint256[]","name":"maxAmountsIn","type":"uint256[]"}],"name":"joinPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"tokenAmountIn","type":"uint256"},{"internalType":"uint256","name":"minPoolAmountOut","type":"uint256"}],"name":"joinswapExternAmountIn","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"poolAmountOut","type":"uint256"},{"internalType":"uint256","name":"maxAmountIn","type":"uint256"}],"name":"joinswapPoolAmountOut","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint96[]","name":"desiredDenorms","type":"uint96[]"},{"internalType":"uint256[]","name":"minimumBalances","type":"uint256[]"}],"name":"reindexTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"tokens","type":"address[]"},{"internalType":"uint96[]","name":"desiredDenorms","type":"uint96[]"}],"name":"reweighTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"maxPoolTokens","type":"uint256"}],"name":"setMaxPoolTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"minimumBalance","type":"uint256"}],"name":"setMinimumBalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"swapFee","type":"uint256"}],"name":"setSwapFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"tokenAmountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"uint256","name":"maxPrice","type":"uint256"}],"name":"swapExactAmountIn","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"uint256","name":"maxAmountIn","type":"uint256"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"tokenAmountOut","type":"uint256"},{"internalType":"uint256","name":"maxPrice","type":"uint256"}],"name":"swapExactAmountOut","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"src","type":"address"},{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]

module.exports = {
  abis
}

'''
'''--- projects/config/keys.js ---
let keys =
  {

    '0x514910771af9ca656af840dff83e8264ecf986ca': 'chainlink',
    '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'bitcoin',
    '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9': 'aave',
    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'stable',
    '0x0000000000085d4780B73119b644AE5ecd22b376': 'stable',
    '0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e': 'yearn-finance', //yfi
    '0x408e41876cccdc0f92210600ef50372656052a38': 'republic-protocol', //ren
    '0x80fB784B7eD66730e8b1DBd9820aFD29931aab03': 'ethlend', //lend
    '0x4fabb145d64652a948d72533023f6e7a623c7c53': 'stable', //busd
    '0xdac17f958d2ee523a2206206994597c13d831ec7': 'stable', //USDT
    '0x6b175474e89094c44da98b954eedeac495271d0f': 'stable', //DAI
    '0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2': 'maker', //makerdao
    '0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f': 'havven', //SNX
    '0x0f5d2fb29fb7d3cfee444a200298f468908cc942': 'decentraland', //MANA
    '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': 'uniswap', //uni
    '0xdd974d5c2e2928dea5f71b9825b8b646686bd200': 'kyber-network', //knc
    '0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c': 'enjincoin', //ENJ
    '0x0d8775f648430679a709e98d2b0cb6250d2887ef': 'basic-attention-token', //BAT
    '0x57ab1ec28d129707052df4df418d58a2d46d5f51': 'stable', //susd
    '0xe41d2489571d322189246dafa5ebde1f4699f498': '0x', //0x
    '0xd533a949740bb3306d119cc777fa900ba034cd52': 'curve-dao-token',
    '0xc00e94cb662c3520282e6f5717214004a7f26888': 'compound-governance-token',
    '0x04fa0d235c4abf4bcf4787af4cf447de572ef828': 'uma',
    '0xd26114cd6ee289accf82350c8d8487fedb8a0c07': 'omisego',
    '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359': 'sai',
    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'ethereum',
    '0x5d3a536e4d6dbd6114cc1ead35777bab948e3643': 'cdai',
    '0xbc396689893d065f41bc2c6ecbee5e0085233447': 'perpetual-protocol',
    '0x92e187a03b6cd19cb6af293ba17f2745fd2357d5': 'unit-protocol-duck',
    '0x2ba592f78db6436527729929aaf6c908497cb200': 'cream',
    '0x0ae055097c6d159879521c384f1d2123d1f195e6': 'xdai-stake',
    '0x1ceb5cb57c4d4e2b2433641b95dd330a33185a44': 'keep3rv1',
    '0x4e15361fd6b4bb609fa63c81a2be19d873717870': 'fantom',
    '0x6b3595068778dd592e39a122f4f5a5cf09c90fe2': 'sushi',
    '0x4688a8b1f292fdab17e9a90c8bc379dc1dbd8713': 'cover-protocol',
    '0x3472a5a71965499acd81997a54bba8d852c6e53d': 'badger-dao',
    '0xa3bed4e1c75d00fa6f4e5e6922db7261b5e9acd2': 'meta',
    '0xca1207647ff814039530d7d35df0e1dd2e91fa84': 'dhedge-dao',
    '0x1b40183efb4dd766f11bda7a7c3ad8982e998421': 'vesper-finance',
    '0x5f64ab1544d28732f0a24f4713c2c8ec0da089f0': 'dextf',
    '0x903bef1736cddf2a537176cf3c64579c3867a881': 'ichi-farm',
    '0xaac41ec512808d64625576eddd580e7ea40ef8b2': 'gameswap-org',
    '0x7240ac91f01233baaf8b064248e80feaa5912ba3': 'octofi',
    '0x8798249c2e607446efb7ad49ec89dd1865ff4272': 'xsushi',
    '0xb753428af26e81097e7fd17f40c88aaa3e04902c': 'saffron-finance',
    '0xc944e90c64b2c07662a292be6244bdf05cda44a7': 'the-graph',
    '0xc5bddf9843308380375a611c18b50fb9341f502a': 'vecrv-dao-yvault',
    '0x1337def16f9b486faed0293eb623dc8395dfe46a': 'armor',
    '0xd291e7a03283640fdc51b121ac401383a46cc623': 'rari-governance-token',
    '0xeb4c2781e4eba804ce9a9803c67d0893436bb27d': 'bitcoin', //renbtc
    '0xe1406825186D63980fd6e2eC61888f7B91C4bAe4': 'strudel-finance', // vBTC
  }

module.exports = {
  keys
}

'''
'''--- projects/config/mantra-dao/contracts/lp-staking-contracts.js ---
const lpStakingAssetsETH = [
  // LABS-ETH UNI LP simple staking
  {
    contract: "0x5f81a986611C600a3656d9adc202283186C6121D",
    pairAddress: "0x2d9fd51e896ff0352cb6d697d13d04c2cb85ca83",
    token1: "0x2D9FD51E896Ff0352Cb6D697D13D04C2CB85CA83",
    price1: "labs-group",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // LABS-ETH UNI LP staking with exit tollbooth
  {
    contract: "0xfc8e3b55897d8cef791451bbe69b204b9c58fc8a",
    pairAddress: "0x2d9fd51e896ff0352cb6d697d13d04c2cb85ca83",
    token1: "0x2D9FD51E896Ff0352Cb6D697D13D04C2CB85CA83",
    price1: "labs-group",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // MANTRA DAO OM-ETH LP staking
  {
    contract: "0x91fe14df53eae3a87e310ec6edcdd2d775e1a23f",
    pairAddress: "0xe46935ae80e05cdebd4a4008b6ccaa36d2845370",
    token1: "0x3593D125a4f7849a1B059E64F4517A86Dd60c95d",
    price1: "mantra-dao",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // ROYA-ETH LP staking
  {
    contract: "0x55e0F2cE66Fa8C86ef478fa47bA0bE978eFC2647",
    pairAddress: "0x6d9d2427cfa49e39b4667c4c3f627e56ae586f37",
    token1: "0x4Cd4c0eEDb2bC21f4e280d0Fe4C45B17430F94A9",
    price1: "royale",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // BITE-ETH LP staking
  {
    contract: "0xb12f0CbcC89457d44323139e6Bb0526Fd82f12F2",
    pairAddress: "0x1f07f8e712659087914b96db4d6f6e4fee32285e",
    token1: "0x4eed0fa8de12d5a86517f214c2f11586ba2ed88d",
    price1: "dragonbite",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // BITE-ETH LP staking w/ tollbooth
  {
    contract: "0x18Ba986ED3128fc7E3E86a09E902436e900a899c",
    pairAddress: "0x1f07f8e712659087914b96db4d6f6e4fee32285e",
    token1: "0x4eed0fa8de12d5a86517f214c2f11586ba2ed88d",
    price1: "dragonbite",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // BBANK-ETH LP staking
  {
    contract: "0x6406788d1CD4fdD823ef607A924c00a4244a841d",
    pairAddress: "0x2a182e532a379cb2c7f1b34ce3f76f3f7d3596f7",
    token1: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price1: "weth",
    token2: "0xf4b5470523ccd314c6b9da041076e7d79e0df267",
    price2: "blockbank",
  },
  // RAZE-ETH LP staking
  {
    contract: "0xe2a80A76B084B51CFAe5B2C3e0FF5232e0408201",
    pairAddress: "0x4fc47579ecf6aa76677ee142b6b75faf9eeafba8",
    token1: "0x5eaa69b29f99c84fe5de8200340b4e9b4ab38eac",
    price1: "raze-network",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
  // BCUBE-ETH LP staking
  {
    contract: "0xFF964d0bf9f81c401932A6B975EAE54129712eE5",
    pairAddress: "0xc62bf2c79f34ff24e2f97982af4f064161ed8949",
    token1: "0x93c9175e26f57d2888c7df8b470c9eea5c0b0a93",
    price1: "b-cube-ai",
    token2: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    price2: "weth",
  },
];

// BSC LP Staking
const lpStakingAssetsBSC = [
  // FINE-BNB LP staking
  {
    contract: "0xF25897a7EDf1Dfa9C65f5DB7Ec4Bad868873805B",
    pairAddress: "0xC309a6d2F1537922E06f15aA2eb21CaA1b2eEDb6",
    token1: "0x4e6415a5727ea08aae4580057187923aec331227",
    price1: "refinable",
    token2: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price2: "wbnb",
  },
  // OM-BNB LP staking
  {
    contract: "0xcbf42ace1dbd895ffdcabc1b841488542626014d",
    pairAddress: "0x49837a48abde7c525bdc86d9acba39f739cbe22c",
    token1: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price1: "wbnb",
    token2: "0xf78d2e7936f5fe18308a3b2951a93b6c4a41f5e2",
    price2: "mantra-dao",
  },
  // CBD-BNB LP staking
  {
    contract: "0x92fCe8AfFB2A68d418BaDF8E360E0CDe06c39356",
    pairAddress: "0x0b49580278b403ca13055bf4d81b6b7aa85fd8b9",
    token1: "0x0e2b41ea957624a314108cc4e33703e9d78f4b3c",
    price1: "greenheart-cbd",
    token2: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price2: "wbnb",
  },
  // BBANK-BNB LP staking
  {
    contract: "0x1E8BC897bf03ebac570Df7e5526561f8a42eCe05",
    pairAddress: "0x538e61bd3258304e9970f4f2db37a217f60436e1",
    token1: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price1: "wbnb",
    token2: "0xf4b5470523ccd314c6b9da041076e7d79e0df267",
    price2: "blockbank",
  },
  // BONDLY-BNB LP staking
  {
    contract: "0xD862866599CA681c492492E1B7B9aB80066f2FaC",
    pairAddress: "0xb8b4383b49d451bbea63bc4421466e1086da6f18",
    token1: "0x96058f8c3e16576d9bd68766f3836d9a33158f89",
    price1: "bondly",
    token2: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    price2: "wbnb",
  },
  // MIST-BNB LP staking
  {
    contract: "0x4F905f75F5576228eD2D0EA508Fb0c32a0696090",
    pairAddress: "0x5a26eb7c9c72140d01039eb172dcb8ec98d071bd",
    token1: "0x68e374f856bf25468d365e539b700b648bf94b67",
    price1: "mist",
    token2: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price2: "wbnb",
  },
  // ROSN-BNB LP staking
  {
    contract: "0x5B4463bBD7B2E870601e91161e0F1F7f84CDE214",
    pairAddress: "0x5548bd47293171d3bc1621edccd953bcc9b814cb",
    token1: "0x651Cd665bD558175A956fb3D72206eA08Eb3dF5b",
    price1: "roseon-finance",
    token2: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price2: "wbnb",
  },
  // MLT-BNB LP staking
  {
    contract: "0x398a5FEE22E0dEb67dA1bD15FA4841b6Aa64c471",
    pairAddress: "0x560b96f81a2190ff6ac84ebfd17788bab3679cbc",
    token1: "0x4518231a8fdf6ac553b9bbd51bbb86825b583263",
    price1: "media-licensing-token",
    token2: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price2: "wbnb",
  },
  // L3P-BNB LP staking
  {
    contract: "0x3ba3E2f3cACcDbE3C56D3046FFe859cc9deE08a0",
    pairAddress: "0xB62c57Bda4C126E21A726e3D28734bfb1151231e",
    token1: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    price1: "wbnb",
    token2: "0xdeF1da03061DDd2A5Ef6c59220C135dec623116d",
    price2: "lepricon",
  },
];

// POLYGON  LP Staking
const lpStakingAssetsPOLYGON = [
  // OM-WETH LP staking
  {
    contract: "0xCBf42Ace1dBD895FFDCaBC1b841488542626014d",
    pairAddress: "0xff2bbcb399ad50bbd06debadd47d290933ae1038",
    token1: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
    price1: "weth",
    token2: "0xC3Ec80343D2bae2F8E680FDADDe7C17E71E114ea",
    price2: "mantra-dao",
  },
  // GAMER-WETH LP staking
  {
    contract: "0x11c70CAA910647d820bD014d676Dcd97EDD64A99",
    pairAddress: "0x1dF661fC4319415a2f990bd5F49D5cA70EFDee1C",
    token1: "0x3f6b3595ecF70735D3f48D69b09C4E4506DB3F47",
    price1: "gamestation",
    token2: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
    price2: "weth",
  },
];

module.exports = {
  lpStakingAssetsETH,
  lpStakingAssetsBSC,
  lpStakingAssetsPOLYGON,
};

'''
'''--- projects/config/mantra-dao/contracts/naked-staking-contracts.js ---
const stakingAssetsETH = [
  // sOM POOL 1 - Staked OM
  {
    contract: "0x9E15Ad979919bB4db331Bfe864475Ae3BFFebA93",
    token: "0x3593D125a4f7849a1B059E64F4517A86Dd60c95d",
    price: "mantra-dao",
  },
  // sOM POOL 2 - Staked OM
  {
    contract: "0xa01892d97e9c8290c2c225fb0b756bfe26bc9802",
    token: "0x3593D125a4f7849a1B059E64F4517A86Dd60c95d",
    price: "mantra-dao",
  },
  // RFUEL Pool 2 - Staked RFUEL
  {
    contract: "0x456DF576962289256A92290C9E48EE116B8Cb413",
    token: "0xaf9f549774ecedbd0966c52f250acc548d3f36e5",
    price: "rio-defi",
  },
  // L3P - Staked Lepricon
  {
    contract: "0xdbc34d084393ed8d7b750FfCCea5A139EC7b9349",
    token: "0xdef1da03061ddd2a5ef6c59220c135dec623116d",
    price: "lepricon",
  },
  // ROYA - Staked royale
  {
    contract: "0x4Cd4c0eEDb2bC21f4e280d0Fe4C45B17430F94A9",
    token: "0x7eaF9C89037e4814DC0d9952Ac7F888C784548DB",
    price: "royale",
  },
  // Finxflo - Staked Finxflo
  {
    contract: "0x6BcDC61A7A6d86f7b7B66d461b7eF7fa268571a0",
    token: "0x8a40c222996f9F3431f63Bf80244C36822060f12",
    price: "finxflo",
  },
  // PKF - Staked Polkafoundry
  {
    contract: "0x1dfdb0fb85402dc7f8d72d92ada8fbbb3ffc8633",
    token: "0x4eed0fa8de12d5a86517f214c2f11586ba2ed88d",
    price: "polkafoundry",
  },
  // RAZE - Staked Raze
  {
    contract: "0x2d0ea72db9f9a63f4b185eab1ca74137d808ebfa",
    token: "0x5eaa69b29f99c84fe5de8200340b4e9b4ab38eac",
    price: "raze-network",
  },
  // KYL - Staked KYL
  {
    contract: "0x6ae05b5db520011bf76645ebb4d6a697e5b3774b",
    token: "0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c",
    price: "kylin-network",
  },
  // LABS Pool 1 - Staked LABS
  {
    contract: "0x6f0db359309CAD297D2e7952a4F5f081bDC1e373",
    token: "0x8b0e42f366ba502d787bb134478adfae966c8798",
    price: "labs-group",
  },
  // LABS Pool 2 - Staked LABS
  {
    contract: "0xb96e42c0de658ca26048b0e200f9a1e05ad89e0f",
    token: "0x8b0E42F366bA502d787BB134478aDfAE966C8798",
    price: "labs-group",
  },
  // BONDLY staking
  {
    contract: "0x39621A555554A7FF77F2b64185c53E04C90cD540",
    token: "0xd2dda223b2617cb616c1580db421e4cfae6a8a85",
    price: "bondly",
  },
  // BITE staking
  {
    contract: "0xa571309B1267676568Bf9f155606a08790896Fe2",
    token: "0x4eED0fa8dE12D5a86517f214C2f11586Ba2ED88D",
    price: "dragonbite",
  },
  // BCUBE staking
  {
    contract: "0xb19b94d53D362CDfC7360C951a85ca2c1d5400BA",
    token: "0x93C9175E26F57d2888c7Df8B470C9eeA5C0b0A93",
    price: "b-cube-ai",
  },
];

const stakingAssetsBSC = [
  // ROSN staking
  {
    contract: "0x7dd79e93dba1d677574d0b5e99721f2e4b45e297",
    token: "0x651cd665bd558175a956fb3d72206ea08eb3df5b",
    price: "roseon-finance",
  },
  // BONDLY staking
  {
    contract: "0x004c0908518e19aa8b27a55c171564097fa3c354",
    token: "0x96058f8c3e16576d9bd68766f3836d9a33158f89",
    price: "bondly",
  },
  // MLT staking
  {
    contract: "0xF0185520Cc773502f0f208433ca178f2f57157A9",
    token: "0x4518231a8fdf6ac553b9bbd51bbb86825b583263",
    price: "media-licensing-token",
  },
  // OM staking
  {
    contract: "0xEfc2d65302eb6345A7C0e212B791e0d45C2C3c91",
    token: "0xf78d2e7936f5fe18308a3b2951a93b6c4a41f5e2",
    price: "mantra-dao",
  },
];

const stakingAssetsPOLYGON = [
  // OM staking
  {
    contract: "0xCdD0f77A2A158B0C7cFe38d00443E9A4731d6ea6",
    token: "0xc3ec80343d2bae2f8e680fdadde7c17e71e114ea",
    price: "mantra-dao",
  },
  // GAMER staking
  {
    contract: "0xd1ecDC553651daB068486d9c4d066eCDC614416e",
    token: "0x3f6b3595ecf70735d3f48d69b09c4e4506db3f47",
    price: "gamestation",
  },
];

module.exports = {
  stakingAssetsETH,
  stakingAssetsBSC,
  stakingAssetsPOLYGON,
};

'''
'''--- projects/config/n3rd/abis.js ---
let minERC20 = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "account",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

let minVault = [
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_pid",
                "type": "uint256"
            }
        ],
        "name": "getLiquidityInfo",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "lpSupply",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "nerdAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalNerdAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "tokenAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalTokenAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lockedLP",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalLockedLP",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accNerdPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lockedPeriod",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "emergencyWithdrawable",
                "type": "bool"
            },
            {
                "internalType": "uint256",
                "name": "rewardsInThisEpoch",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "cumulativeRewardsSinceStart",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "startBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "epochCalculationStartBlock",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

let minRouter = [
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "internalType": "address[]",
                "name": "path",
                "type": "address[]"
            }
        ],
        "name": "getAmountsOut",
        "outputs": [
            {
                "internalType": "uint256[]",
                "name": "amounts",
                "type": "uint256[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

module.exports = {
    minERC20,
    minVault,
    minRouter
}

'''
'''--- projects/config/onx/avalanche/index.js ---
const BigNumber = require('bignumber.js');
const { ZERO, getVautsTvl, } = require('../../../helper/ankr/utils');
const { vaults } = require('./vaults');
const { request, gql } = require("graphql-request");

const getQuickQuery = (pairAddress) => gql`
  query pairs {
    pairs(where: { id: "${pairAddress}"} ) {
      id
      reserveUSD
      volumeUSD
      totalSupply
      }
    }`
;

const url = 'https://api.thegraph.com/subgraphs/name/traderjoe-xyz/exchange';

const getPairsData = async (pairAddress) => {
  try {
    const result = await request(url, getQuickQuery(pairAddress));
    const last = result.pairs.length;
    return result && result.pairs ? result.pairs[last - 1] : {};
  } catch (e) {
    console.error(e);
  }

  return {};
};

const getTraderJoePoolPrice = async (vault) => {
  if (!vault.pool) {
    return ZERO;
  }

  const data = await getPairsData(vault.pool);
  const { reserveUSD, totalSupply } = data;

  return reserveUSD && totalSupply ? new BigNumber(reserveUSD).div(totalSupply).div(1e18) : ZERO;
};

const getAvalancheTvl = async () => {
  return getVautsTvl(vaults, getTraderJoePoolPrice);
};

module.exports = {
  getAvalancheTvl,
}
'''
'''--- projects/config/onx/avalanche/vaults.js ---
const createVaultModel = (poolAddress, vaultAddress) => {
  return {
    pool: poolAddress,
    vault: vaultAddress,
    chain: 'avax',
  }
}

const vaults = [
  //usdcAvax
  {
    ...createVaultModel('0xa389f9430876455c36478deea9769b7ca4e3ddb1', '0x8025d4deDa0C7512d44438a7DC597612B4108F07'),
  },
  //wethAvax
  {
    ...createVaultModel('0xfe15c2695f1f920da45c30aae47d11de51007af9', '0xf7AcA362510b327bDAca693611353b6a837cBDB2'),
  },
  //avaxUsdte
  {
    ...createVaultModel('0xed8cbd9f0ce3c6986b22002f03c6475ceb7a6256', '0x897Fb124aCdF5A685d9258645ffee0058464817A'),
  },
  //joeAvax [not available]
  {
    ...createVaultModel('0x454e67025631c065d3cfad6d71e6892f74487a15', '0x02e9bc3EF29A3f51EdE6e4c4F70fdcb894CD6Cf5'),
  },
  //wBtcAvax
  {
    ...createVaultModel('0xd5a37dc5c9a396a03dd1136fc76a1a02b1c88ffa', '0x8922E41342C6160fAf4dC40f2c1fCFCd94E98779'),
  },
  //linkAvax
  {
    ...createVaultModel('0x6f3a0c89f611ef5dc9d96650324ac633d02265d3', '0x55F42961b3aD4E2A08f1780C7434dd8EC5f7FcE4'),
  },
  //joeUsdce
  {
    ...createVaultModel('0x67926d973cd8ee876ad210faaf7dffa99e414acf', '0xD9F63Cc588822cD3eF802D900808E946d13CE609'),
  },
  //bnbAvax
  {
    ...createVaultModel('0xeb8eb6300c53c3addbb7382ff6c6fbc4165b0742', '0x4decafaCD4591e52f85e8FE69F82F2400176BB33'),
  },
  //joeUsdte
  {
    ...createVaultModel('0x1643de2efb8e35374d796297a9f95f64c082a8ce', '0xfD127Bc3b6153b043fFD8d7f38272593700b124c'),
  },
  // //spellAvax [not available]
  // {
  //   ...createVaultModel('0x62cf16bf2bc053e7102e2ac1dee5029b94008d99', '0x9eE877279DFE8e5F20614db88e50CD72B4efDEAD'),
  // },
  // //xavaAvax [not available]
  // {
  //   ...createVaultModel('0x72c3438cf1c915ecf5d9f17a6ed346b273d5bf71', '0x54720637Fa477eD87Cd06F674247a649A5168eB6'),
  // },
  //linkeUsdce
  {
    ...createVaultModel('0xb9f425bc9af072a91c423e31e9eb7e04f226b39d', '0x62CA6F1640776070ECa70E09d9AF27352a43a5D8'),
  },
  //wethUsdce
  {
    ...createVaultModel('0x199fb78019a08af2cb6a078409d0c8233eba8a0c', '0x2C858E3181988f2E4458f14768aE204E5BF2Ee0e'),
  },
  //pefiAvax [not available]
  {
    ...createVaultModel('0xb78c8238bd907c42be45aebdb4a8c8a5d7b49755', '0x276F74C24Cc4443Ecb4967Db77572BE50aeD4117'),
  },
  //wbtceAvax
  {
    ...createVaultModel('0x62475f52add016a06b398aa3b2c2f2e540d36859', '0x008E6bf114D686713dC233487e360A158433e519'),
  },
  //aaveAvax
  {
    ...createVaultModel('0xc3e6d9f7a3a5e3e223356383c7c055ee3f26a34f', '0xE7c34e1946A10a3A28BEd4B0Cb5B7F0d85F5368D'),
  },
  //qiAvax
  {
    ...createVaultModel('0x2774516897ac629ad3ed9dcac7e375dda78412b9', '0x0240269d999301d03aAe390104584F7517f52ECd'),
  },
  // //avaxBoo [not available]
  // {
  //   ...createVaultModel('0xebf50b8089a0c5e7c5de23f644fcd723818f65b3', '0xB4a805Ad532BB92501507C9eAc27FD0BAe4d68A1'),
  // },
  // //maiAvax [not available]
  // {
  //   ...createVaultModel('0x23ddca8de11eccd8000263f008a92e10dc1f21e8', '0x2071fD6779B701aa71c4a48b8f37970160e5FE75'),
  // },
  // //h20Avax [not available]
  // {
  //   ...createVaultModel('0x9615a11eaa912eae869e9c1097df263fc3e105f3', '0x6b42A98af10C2E94a6951c94b8Ac5B5EEB23c8AF'),
  // },
]

module.exports = {
  vaults,
}
'''
'''--- projects/config/onx/constant.js ---
const tokenAddresses = {
  onx: "0xe0ad1806fd3e7edf6ff52fdb822432e847411033",
  sOnx: "0xa99f0ad2a539b2867fcfea47f7e71f240940b47c",
  onxFarm: "0x168f8469ac17dd39cd9a2c2ead647f814a488ce9",
  onxTripleFarm: "0x30D1A19EA928cCf46634cBC2944D2D89Be636f22",
  usdWethPair: "0x0d4a11d5eeaac28ec3f61d100daf4d40471f1852",
  onxWethSushiPair: "0x62f22A47e5D2F8b71cC44fD85863753618312f67",
  wethAethPair: "0x6147805e1011417b93e5d693424a62a70d09d0e5",
  ankrWethPair: "0x5201883feeb05822ce25c9af8ab41fc78ca73fa9",
  pool: "0x47F3E6C1Ef0cBe69502167095b592e61de108BaA",
  aethToken: "0xE95A203B1a91a908F9B9CE46459d101078c2c3cb",
  onsToken: "0xfC97C0c12438B6E4CF246cD831b02FeF4950DCAD",
  daiToken: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  fraxToken: "0x853d955acef822db058eb8505911ed77f175b99e",
  usdcToken: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  aethPairEth: "0x6147805e1011417B93e5D693424a62A70d09d0E5",
  aethPairOns: "0x5022BbC26B3Bc8c8d2F1F7dB9ee3A2B4631b9b18",
  aethPairOne: "0x5BD4D1f8D46Ad6ae1e6b694eb64f7583C1cB1A74",
  oneVault: "0x3BdF1977d87EDAD8e0617efCEa958F6d43A4C30E",
  wethToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  bondPairEth: "0xb17b1342579e4bce6b6e9a426092ea57d33843d9",
  sushiPairEth: "0xce84867c3c02b05dc570d0135103d3fb9cc19433",
  fantom: {
    usdcBooPair: '0xf8cb2980120469d79958151daa45eb937c6e1ed6',
  },
  onePools: [
    {
      title: 'aeth',
      address: '0x54c532E367031F56c401C6024aC4ABEfF2b03534',
    },
    {
      title: 'weth',
      address: '0xbc2346C3c7F3998A12A1c8E7Be44734EcC832763',
    },
    {
      title: 'onx',
      address: '0x5e60d73437aCCC3294a8Edf59639c1Dc1BaF0d75',
    },
    {
      title: 'dai',
      address: '0xe64796FCc97c33A2193Ba60f013F3fA5D4712d56',
    },
    {
      title: 'frax',
      address: '0xe659fA84e0C687760245046BA63329d44320997c',
    },
    {
      title: 'usdc',
      address: '0x19Eb6536777713aCdAcA8dd9A3AD9843D74E9E3b',
    },
  ],
  onsPools: [
    {
      title: 'aethPairOne',
      address: '0x1B72255a11DF705Bb598E670830E03A19F2D242f',
    },
    {
      title: 'aethPairOns',
      address: '0x7058EE5467edef417746aab0B8cabbbE36eF1798',
    },
    {
      title: 'aethPairEth',
      address: '0x9792eE4c36a622a8CF9566b037c57519A9fe8a56',
    },
  ]
};

module.exports = tokenAddresses;

'''
'''--- projects/config/onx/ethereum/farmTvl.js ---
const BigNumber = require('bignumber.js');
const { ZERO, getTotalSupplyOf, } = require('../../../helper/ankr/utils');;
const sdk = require("@defillama/sdk")

const getSymbolPrice = (
  symbol,
  wethPrice,
  onxPrice,
  aEthPrice,
  ankrPrice,
  sushiPrice = ZERO,
  bondPrice = ZERO,
) => {
  if (symbol === 'WETH' || symbol === 'ETH') {
    return wethPrice;
  }
  if (symbol === 'aETHc') {
    return aEthPrice;
  }
  if (symbol === 'ONX') {
    return onxPrice;
  }
  if (symbol === 'ANKR') {
    return ankrPrice;
  }
  if (symbol === 'SUSHI' || symbol === 'xSUSHI' || symbol === 'xSushi') {
    return sushiPrice;
  }
  if (symbol === 'BOND') {
    return bondPrice;
  }
  if (['USDC', 'DAI', 'FRAX'].includes(symbol)) {
    return new BigNumber(1);
  }
  return new BigNumber(0);
};

async function getUsdBalance(
  balance,
  farm,
  wEthPrice,
  onxPrice,
  aEthPrice,
  ankrPrice,
  sushiPrice,
  bondPrice,
) {
  let subSymbol2Decimal = 18;

  if (!farm.isLpToken) {
    return new BigNumber(balance)
      .times(getSymbolPrice(farm.title, wEthPrice, onxPrice, aEthPrice, ankrPrice, sushiPrice, bondPrice))
      .div(1e18);
  } else {
    const totalSupply = await getTotalSupplyOf(farm.address);

    if (!totalSupply.isZero()) {

      const { output: subBalance1 } = await sdk.api.erc20.balanceOf({ target: farm.subTokenAddresses1, owner: farm.address });
      const subSymbol1Price = getSymbolPrice(
        farm.subTokenSymbol1,
        wEthPrice,
        onxPrice,
        aEthPrice,
        ankrPrice,
        sushiPrice,
        bondPrice,
      );

      const { output: subBalance2 } = await sdk.api.erc20.balanceOf({ target: farm.subTokenAddresses2, owner: farm.address });
      const subSymbol2Price = getSymbolPrice(
        farm.subTokenSymbol2,
        wEthPrice,
        onxPrice,
        aEthPrice,
        ankrPrice,
        sushiPrice,
        bondPrice,
      );

      if (farm.subTokenSymbol2 === 'USDC') {
        subSymbol2Decimal = 6;
      }

      const sum = new BigNumber(subBalance1)
        .times(subSymbol1Price)
        .div(1e18)
        .plus(new BigNumber(subBalance2).times(subSymbol2Price).div(new BigNumber(10).pow(subSymbol2Decimal)));

      return BigNumber(balance).times(sum).div(totalSupply);
    } else {
      return ZERO;
    }
  }
}

module.exports = {
  getUsdBalance
}
'''
'''--- projects/config/onx/ethereum/farms.js ---
const UniswapV2PairContractAbi = require('../../../helper/ankr/abis/UniswapV2Pair.json');
const ERC20Abi = require('../../../helper/ankr/abis/ERC20.json');

const rawFarms = [
  {//0
    pid: 4,
    title: 'onxEthLp',
    address: '0x62f22A47e5D2F8b71cC44fD85863753618312f67',
    abi: UniswapV2PairContractAbi,
    isLpToken: true,
    subTokenSymbol1: 'ONX',
    subTokenSymbol2: 'WETH',
    subTokenAddresses1: '0xe0ad1806fd3e7edf6ff52fdb822432e847411033',
    subTokenAddresses2: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  },
  {//1
    pid: 1,
    title: 'aETHc',
    address: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
    abi: ERC20Abi,
    isLpToken: false,
    subTokenSymbol1: 'aETHc',
    subTokenSymbol2: 'aETHc',
    subTokenAddresses1: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
    subTokenAddresses2: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
  },
  {//2
    pid: 0,
    title: 'ANKR',
    address: '0x8290333ceF9e6D528dD5618Fb97a76f268f3EDD4',
    abi: ERC20Abi,
    isLpToken: false,
    subTokenSymbol1: 'ANKR',
    subTokenSymbol2: 'ANKR',
    subTokenAddresses1: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
    subTokenAddresses2: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  },
  {//3
    title: 'onxEthSlpMulti',
    address: '0x0652687E87a4b8b5370b05bc298Ff00d205D9B5f',
    abi: UniswapV2PairContractAbi,
    isLpToken: true,
    subTokenSymbol1: 'ONX',
    subTokenSymbol2: 'WETH',
    subTokenAddresses1: '0xe0ad1806fd3e7edf6ff52fdb822432e847411033',
    subTokenAddresses2: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    isCustomFarmContract: true,
  },
  {//4
    pid: 7,
    title: 'xSushi',
    address: '0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272',
    abi: ERC20Abi,
    isLpToken: false,
    subTokenSymbol1: 'xSushi',
    subTokenSymbol2: 'xSushi',
    subTokenAddresses1: '0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272',
    subTokenAddresses2: '0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272',
  },
  {//5
    pid: 8,
    title: 'BOND',
    address: '0x0391d2021f89dc339f60fff84546ea23e337750f',
    abi: ERC20Abi,
    isLpToken: false,
    subTokenSymbol1: 'BOND',
    subTokenSymbol2: 'BOND',
    subTokenAddresses1: '0x0391d2021f89dc339f60fff84546ea23e337750f',
    subTokenAddresses2: '0x0391d2021f89dc339f60fff84546ea23e337750f',
  },
  {//6
    pid: 6,
    title: 'onxEthSlp',
    address: '0x0652687E87a4b8b5370b05bc298Ff00d205D9B5f',
    abi: UniswapV2PairContractAbi,
    isLpToken: true,
    subTokenSymbol1: 'ONX',
    subTokenSymbol2: 'WETH',
    subTokenAddresses1: '0xe0ad1806fd3e7edf6ff52fdb822432e847411033',
    subTokenAddresses2: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  },
];

module.exports = {
  farms: rawFarms,
}
'''
'''--- projects/config/onx/ethereum/index.js ---
const BigNumber = require('bignumber.js');
const { toUSDTBalances } = require('./../../../helper/balances');
const sdk = require("@defillama/sdk");
const onxContractAbi = require('../../../helper/ankr/abis/OnxPool.json');
const tokenAddresses = require('../constant');
const { getVautsTvl, getBalanceOf, getReserves } = require('../../../helper/ankr/utils');
const { ZERO, vaults } = require('./vaults');
const { request, gql } = require("graphql-request");
const { getUsdBalance } = require('./farmTvl');
const { getWethPrice,
  getOnxPrice,
  getBondPrice,
  getAethPrice,
  getOnePrice,
  getOnsPrice,
  getAnkrPrice,
  getSushiPrice } = require('./prices');
const { farms } = require('./farms');

const getStakeTvl = async (onxPrice) => {
  const balance = new BigNumber(await getBalanceOf(tokenAddresses.sOnx, tokenAddresses.onx));
  return toUSDTBalances(onxPrice.times(balance).div(1e18));
}

const getEthereumStaking = async () => {
  const wethPrice = await getWethPrice();
  const onxPrice = (await getOnxPrice()).times(wethPrice);
  return getStakeTvl(onxPrice);
}

const getEthereumBorrows = async () => {
  const wethPrice = await getWethPrice();

  let { output: borrowsTvl } = await sdk.api.abi.call({
    target: tokenAddresses.pool,
    abi: onxContractAbi.find(i => i.name === 'totalBorrow')
  })
  borrowsTvl = new BigNumber(borrowsTvl).div(1e18);
  return toUSDTBalances(wethPrice.times(borrowsTvl));
}

const onsPoolLPs = {
  aethPairOne: tokenAddresses.aethPairOne,
  aethPairOns: tokenAddresses.aethPairOns,
  aethPairEth: tokenAddresses.aethPairEth,
}

const getOnePoolsTvl = async (price) => {
  let totalBalance = new BigNumber(0);
  let { onePools } = tokenAddresses;
  onePools = await Promise.all(
    onePools.map(async (farm) => {
      let balance = new BigNumber(0);
      let tokenBalance = new BigNumber();
      switch (farm.title) {
        case 'aeth':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.aethToken));
          balance = tokenBalance.times(price.aethPrice);
          break;
        case 'weth':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.wethToken));
          balance = tokenBalance.times(price.wethPrice);
          break;
        case 'onx':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.onx));
          balance = tokenBalance.times(price.onxPrice);
          break;
        case 'dai':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.daiToken));
          balance = tokenBalance.times(1);
          break;
        case 'frax':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.fraxToken));
          balance = tokenBalance.times(1);
          break;
        case 'usdc':
          tokenBalance = new BigNumber(await getBalanceOf(farm.address, tokenAddresses.usdcToken));
          balance = tokenBalance.times(1).div(1e6);
          break;
      }
      if (farm.title !== 'usdc') balance = balance.div(1e18);
      totalBalance = totalBalance.plus(balance);
    })
  );
  return totalBalance;
}

const getOnsPoolsTvl = async (price) => {
  let totalBalance = new BigNumber(0);
  let { onsPools } = tokenAddresses;
  onsPools = await Promise.all(
    onsPools.map(async (farm) => {
      let balance = new BigNumber(0);
      let sum = new BigNumber(0);
      const totalSupply = new BigNumber((await sdk.api.erc20.totalSupply({ target: onsPoolLPs[farm.title] })).output);
      const tokenBalance = new BigNumber((await sdk.api.erc20.balanceOf({ target: onsPoolLPs[farm.title], owner: farm.address })).output);
      const { reserve0, reserve1 } = await getReserves(onsPoolLPs[farm.title]);

      if (farm.title === 'aethPairOne') {
        sum = new BigNumber(reserve0).times(price.aethPrice).plus(new BigNumber(reserve1).times(price.onePrice));
      } else if (farm.title === 'aethPairOns') {
        sum = new BigNumber(reserve0).times(price.aethPrice).plus(new BigNumber(reserve1).times(price.onsPrice));
      } else if (farm.title === 'aethPairEth') {
        sum = new BigNumber(reserve0).times(price.wethPrice).plus(new BigNumber(reserve1).times(price.aethPrice));
      }
      balance = sum.times(tokenBalance).div(totalSupply).div(1e18);
      totalBalance = totalBalance.plus(balance);
    })
  );
  return totalBalance;
}

const getOneVaultTvl = async (wethPrice, aethPrice, onsPrice) => {
  const onsValue = new BigNumber(await getBalanceOf(tokenAddresses.oneVault, tokenAddresses.onsToken)
  ).times(onsPrice).div(1e18);
  const aEthValue = new BigNumber(await getBalanceOf(tokenAddresses.oneVault, tokenAddresses.aethToken)
  ).times(aethPrice).div(1e18);
  return onsValue.plus(aEthValue);
}

const getLendingTvl = async (wethPrice) => {
  let { output: totalStake } = await sdk.api.abi.call({
    target: tokenAddresses.pool,
    abi: onxContractAbi.find(i => i.name === 'totalStake')
  })
  let { output: totalBorrow } = await sdk.api.abi.call({
    target: tokenAddresses.pool,
    abi: onxContractAbi.find(i => i.name === 'totalPledge')
  })
  return new BigNumber(totalBorrow).plus(totalStake).times(wethPrice).div(1e18);
}

const getQuickQuery = (pairAddress) => gql`
  query pairs {
    pairs(where: { id: "${pairAddress}"} ) {
        id
        reserveUSD
        trackedReserveETH
        volumeUSD
        untrackedVolumeUSD
        totalSupply
      }
    }`
  ;

const url = 'https://api.thegraph.com/subgraphs/name/sushiswap/exchange';

const getPairsData = async (pairAddress) => {
  try {
    const result = await request(url, getQuickQuery(pairAddress));
    const last = result.pairs.length;
    return result && result.pairs ? result.pairs[last - 1] : {};
  } catch (e) {
    console.error(e);
  }

  return {};
};

const getSushiPoolPrice = async (vault) => {
  if (!vault.pool)
    return ZERO;

  const data = await getPairsData(vault.pool);
  const { reserveUSD, totalSupply } = data;

  return new BigNumber(reserveUSD).div(totalSupply).div(1e18);
};

const getEthereumVautsTvl = async () => {
  return getVautsTvl(vaults, getSushiPoolPrice);
};

const getFarmsTvl = async (price) => {
  const { wethPrice, onxPrice, aethPrice, ankrPrice, bondPrice, sushiPrice } = price;

  let totalBalance = new BigNumber(0);
  await Promise.all(
    farms.map(async (farm) => {
      const address = !farm.isCustomFarmContract ? tokenAddresses.onxFarm : tokenAddresses.onxTripleFarm;
      const balance = await getBalanceOf(address, farm.address);

      const usdBalance = await getUsdBalance(
        balance,
        farm,
        wethPrice,
        onxPrice,
        aethPrice,
        ankrPrice,
        sushiPrice,
        bondPrice
      );

      totalBalance = totalBalance.plus(usdBalance);
    })
  );
  return totalBalance;
}

const getOnxEthLpTvl = async () => {
  const wethPrice = await getWethPrice();
  const onxPrice = (await getOnxPrice()).times(wethPrice);
  const aethPrice = (await getAethPrice()).times(wethPrice);
  const ankrPrice = (await getAnkrPrice()).times(wethPrice);
  const bondPrice = (await getBondPrice()).times(wethPrice);
  const sushiPrice = (await getSushiPrice()).times(wethPrice);

  const farm = farms.find(farm => farm.pid === 4);

  const address = !farm.isCustomFarmContract ? tokenAddresses.onxFarm : tokenAddresses.onxTripleFarm;
  const balance = await getBalanceOf(address, farm.address);

  const tvl = await getUsdBalance(
    balance,
    farm,
    wethPrice,
    onxPrice,
    aethPrice,
    ankrPrice,
    sushiPrice,
    bondPrice
  );

  return toUSDTBalances(tvl);
}

const getOnxEthSLpTvl = async () => {
  return getVautsTvl(vaults.filter(vault => vault.title === 'OnxEthSlp'), getSushiPoolPrice);
}

function getEthereumPoolTvl() {
  return sdk.util.sumChainTvls([getOnxEthLpTvl, getOnxEthSLpTvl]);
}

const getEthereumTvl = async () => {
  let netTvl = new BigNumber(0);

  const wethPrice = await getWethPrice();
  const aethPrice = (await getAethPrice()).times(wethPrice)
  const [
    onxPrice,
    ankrPrice,
    bondPrice,
    sushiPrice,
    onePrice,
    onsPrice,
  ] = await Promise.all([
    (await getOnxPrice()).times(wethPrice),
    (await getAnkrPrice()).times(wethPrice),
    (await getBondPrice()).times(wethPrice),
    (await getSushiPrice()).times(wethPrice),
    (await getOnePrice()).times(aethPrice),
    (await getOnsPrice()).times(aethPrice),
  ])

  const [
    farmsTvl,
    onePoolsTvl,
    onsPoolsTvl,
    oneVaultTvl,
    lendingTvl,
  ] = await Promise.all([
    getFarmsTvl({ wethPrice, onxPrice, aethPrice, ankrPrice, bondPrice, sushiPrice }),
    getOnePoolsTvl({ aethPrice, wethPrice, onxPrice }),
    getOnsPoolsTvl({ aethPrice, onePrice, onsPrice, wethPrice }),
    getOneVaultTvl(wethPrice, aethPrice, onsPrice),
    getLendingTvl(wethPrice),
  ])

  const tvl = netTvl
    .plus(farmsTvl)
    .plus(lendingTvl)
    .plus(oneVaultTvl)
    .plus(onePoolsTvl)
    .plus(onsPoolsTvl);

  return toUSDTBalances(tvl);
}

function getEthereumTvlEx() {
  return sdk.util.sumChainTvls([
    getEthereumTvl,
     getEthereumVautsTvl
    ]);
}

module.exports = {
  getEthereumStaking,
  getEthereumTvl,
  getEthereumTvlEx,
  getEthereumPoolTvl,
  getEthereumBorrows,
  getEthereumVautsTvl
}
'''
'''--- projects/config/onx/ethereum/prices.js ---
const BigNumber = require('bignumber.js');
const { getReserves } = require('../../../helper/ankr/utils');

const tokenAddresses = require('../constant');

const getWethPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.usdWethPair);
  return new BigNumber(reserve1).times(1e12).div(new BigNumber(reserve0))
}

const getOnxPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.onxWethSushiPair);
  return new BigNumber(reserve0).div(new BigNumber(reserve1))
}

const getBondPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.bondPairEth);
  return new BigNumber(reserve1).div(new BigNumber(reserve0));
}

const getAethPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.wethAethPair);
  return new BigNumber(reserve0).div(new BigNumber(reserve1))
}

const getOnePrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.aethPairOne);
  return new BigNumber(reserve1).div(new BigNumber(reserve0))
}

const getOnsPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.aethPairOns);
  return new BigNumber(reserve0).div(new BigNumber(reserve1))
}

const getAnkrPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.ankrWethPair);
  return new BigNumber(reserve1).div(new BigNumber(reserve0));
}

const getSushiPrice = async () => {
  const { reserve0, reserve1 } = await getReserves(tokenAddresses.sushiPairEth);
  return new BigNumber(reserve1).div(new BigNumber(reserve0));
}

module.exports = {
  getWethPrice,
  getOnxPrice,
  getBondPrice,
  getAethPrice,
  getOnePrice,
  getOnsPrice,
  getAnkrPrice,
  getSushiPrice,
}
'''
'''--- projects/config/onx/ethereum/vaults.js ---
const createVaultModel = (poolAddress, vaultAddress) => {
  return {
    pool: poolAddress,
    vault: vaultAddress,
    chain: 'ethereum',
  }
}

const vaults = [
  {
    title: 'OnxEthSlp',
    ...createVaultModel('0x0652687e87a4b8b5370b05bc298ff00d205d9b5f', '0xAdb6d1cB866a52C5E8C1e79Ff8e0559c12F4D7a3'),
  },
  {
    title: 'WBtcWethSlp',
    ...createVaultModel('0xceff51756c56ceffca006cd410b03ffc46dd3a58', '0x2abCe7c4C77e215fcCc189E02Fc5D2A30b52a06a'),
  },
  {
    title: 'UsdcEthSlp',
    ...createVaultModel('0x397ff1542f962076d0bfe58ea045ffa2d347aca0', '0x637c871C559ade45b37074fCF3B8081Ec81c55FC'),
  },
  {
    title: 'UsdtEthSlp',
    ...createVaultModel('0x06da0fd433c1a5d7a4faa01111c044910a184553', '0xeAaE5CEfce1092eb3eA1DA7622B3cF4fb20B8b81'),
  },

  {
    title: 'SushiEthSlp',
    ...createVaultModel('0x795065dcc9f64b5614c407a6efdc400da6221fb0', '0xdC6f222c4504C43225a89b84E3aae15Ad0DFDF0F'),
  },
  {
    title: 'XsushiEthSlp',
    ...createVaultModel('0x36e2fcccc59e5747ff63a03ea2e5c0c2c14911e7', '0x10A8dc3C0Db7BDFE1Db36d113c2685e60daaFEb8'),
  },
  {
    title: 'AEthcEthSlp',
    ...createVaultModel('0xfa5bc40c3bd5afa8bc2fe6b84562fee16fb2df5f', '0x6901Aac9813f3EfAae32F44E9b579f08A12707AD'),
  },
  {
    title: 'AnkrEthSlp',
    ...createVaultModel('0x1241f4a348162d99379a23e73926cf0bfcbf131e', '0x121eF4eEc2bb4D5eD91347166F02c0763af1C49A'),
  },
  {
    title: 'YfiEthSlp',//0
    ...createVaultModel('0x088ee5007c98a9677165d78dd2109ae4a3d04d0c', '0x431b1F5356EcAc2D86b2313907B747B16D11066f'),
  },

  {
    title: 'DaiEthSlp',
    ...createVaultModel('0xc3d03e4f041fd4cd388c549ee2a29a9e5075882f', '0x5EA1b54C522f279ecC0182d9b35229d6435D42b7'),
  },
  {
    title: 'AaveEthSlp',//0
    ...createVaultModel('0xd75ea151a61d06868e31f8988d28dfe5e9df57b4', '0x9DB4AFCABdB25C89424c88e720dD47D6be43BdBe'),
  },
  {
    title: 'LinkEthSlp',
    ...createVaultModel('0xc40d16476380e4037e6b1a2594caf6a6cc8da967', '0xbd3a37e3690ad4e145c39983D0Aaf8bd5f5e2F29'),
  },
  {
    title: 'CompEthSlp',//0
    ...createVaultModel('0x31503dcb60119a812fee820bb7042752019f2355', '0x8d47f6fd4602B1ecF7928C0f1AEF9C215E3596b4'),
  },
  {
    title: 'CompEthSlp',//0
    ...createVaultModel('0x31503dcb60119a812fee820bb7042752019f2355', '0x8d47f6fd4602B1ecF7928C0f1AEF9C215E3596b4'),
  },

  {
    title: 'MkrEthSlp',//0
    ...createVaultModel('0xba13afecda9beb75de5c56bbaf696b880a5a50dd', '0x659217CdA99658AeBA399B4a79FB03D96B3c46bC'),
  },
  {
    title: 'AlphaEthSlp',
    ...createVaultModel('0xf55c33d94150d93c2cfb833bcca30be388b14964', '0xcedB7921013A012c5538C0d2925a90AA817Bef4D'),
  },
]

module.exports = {
  vaults,
}
'''
'''--- projects/config/onx/fantom/index.js ---
const tokenAddresses = require('../constant');
const BigNumber = require('bignumber.js');
const UniswapV2PairContractAbi = require('../../../helper/ankr/abis/UniswapV2Pair.json');
const { ZERO, fromWei, getVautsTvl, } = require('../../../helper/ankr/utils');
const { vaults } = require('./vaults');
const { EXCHANGE_TYPE } = require('../vault');
const { request, gql } = require("graphql-request");
const sdk = require("@defillama/sdk")

const getBooPrice = async () => {
  return fetchPriceData(tokenAddresses.fantom.usdcBooPair, true, 1e12);
};

const fetchPriceData = async (pairAddress, viceVersa = false, multiplier = 1,) => {
  const { reserve0, reserve1 } = await getReserves(pairAddress);
  const isValid = !new BigNumber(reserve0).eq(ZERO) && !new BigNumber(reserve1).eq(ZERO);

  if (isValid) {
    return (viceVersa
      ? new BigNumber(reserve0).div(new BigNumber(reserve1))
      : new BigNumber(reserve1).div(new BigNumber(reserve0))
    ).times(multiplier);
  } else {
    return ZERO;
  }
};

const getReserves = async (pairAddress) => {
  const { output: { _reserve0, _reserve1, _blockTimestampLast } } = await sdk.api.abi.call({
    chain: 'fantom',
    target: pairAddress,
    abi: UniswapV2PairContractAbi.find(i => i.name === 'getReserves')
  })
  return { reserve0: _reserve0, reserve1: _reserve1, blockTimestampLast: _blockTimestampLast };
};

const getUniPairQuery = (pairAddress) => gql`
query pairDayDatas {  
   pairDayDatas(first: 1000, skip: 0, orderBy: date, orderDirection: asc, where: {pairAddress: "${pairAddress}"}) {    
       id    
       date    
       dailyVolumeToken0    
       dailyVolumeToken1    
       dailyVolumeUSD    
       reserveUSD
       totalSupply    
       __typename  
   }
}
`;

const url = 'https://api.thegraph.com/subgraphs/name/eerieeight/spookyswap';

const getPairsData = async (pairAddress) => {
  try {
    const result = await request(url, getUniPairQuery(pairAddress));
    const last = result.pairDayDatas.length;
    return result && result.pairDayDatas ? result.pairDayDatas[last - 2] : {};
  } catch (e) {
    console.error(e);
  }

  return {};
};

const getSpookyPoolPrice = async (vault) => {
  if (!vault.pool) {
    return ZERO;
  }
  if (vault.exchangeType == EXCHANGE_TYPE.SPOOKYSWAP) {
    const data = await getPairsData(vault.pool);
    const { reserveUSD, totalSupply } = data;
    const result = totalSupply ? fromWei(new BigNumber(reserveUSD).div(totalSupply)) : ZERO;
    return result;
  } else if (vault.exchangeType == EXCHANGE_TYPE.SPOOKYSWAP_SINGLE) {
    return fromWei(await getBooPrice());
  } else {
    return ZERO;
  }
};

const getFantomTvl = async () => {
  return getVautsTvl(vaults, getSpookyPoolPrice);
};

module.exports = {
  getBooPrice,
  getFantomTvl,
}
'''
'''--- projects/config/onx/fantom/vaults.js ---
const { EXCHANGE_TYPE } = require('../vault');

const createVaultModel = (poolAddress, vaultAddress, exchangeType = EXCHANGE_TYPE.SPOOKYSWAP) => {
  return {
    pool: poolAddress,
    vault: vaultAddress,
    exchangeType,
    chain: 'fantom',
  }
}

const vaults = [
  //xBoo
  {
    ...createVaultModel('0x841fad6eae12c286d1fd18d1d525dffa75c7effe', '0x95d0d6A7D75A5b086d2823C38F6Dd80a50fD0d93', EXCHANGE_TYPE.SPOOKYSWAP_SINGLE),
  },
  //BooFtm
  {
    ...createVaultModel('0xec7178f4c41f346b2721907f5cf7628e388a7a58', '0x62CA6F1640776070ECa70E09d9AF27352a43a5D8'),
  },
  //UsdcFtm
  {
    ...createVaultModel('0x2b4c76d0dc16be1c31d4c1dc53bf9b45987fc75c', '0x6b42A98af10C2E94a6951c94b8Ac5B5EEB23c8AF'),
  },
  //fUsdtFtm
  {
    ...createVaultModel('0x5965E53aa80a0bcF1CD6dbDd72e6A9b2AA047410', '0xC033338F7605B1555b1d3FC2a3626b2b76a0E042'),
  },
  //DaiFtm
  {
    ...createVaultModel('0xe120ffBDA0d14f3Bb6d6053E90E63c572A66a428', '0xf1Ba3EF65262ee4058462E65A3A09a7571193400'),
  },
  //btc
  {
    ...createVaultModel('0xFdb9Ab8B9513Ad9E419Cf19530feE49d412C3Ee3', '0x0f16CBDaF6c8115cDde59876cF232903E95D488A'),
  },
  //eth
  {
    ...createVaultModel('0xf0702249F4D3A25cD3DED7859a165693685Ab577', '0x7396241a8a45E6252A2b5bBB571CBdfF599E16F1'),
  },
  //link
  {
    ...createVaultModel('0x89d9bC2F2d091CfBFc31e333D6Dc555dDBc2fd29', '0x8D20fB2F4F96E897Fed7E3E50f8A403aFc59dA23'),
  },
  //aave
  {
    ...createVaultModel('0xeBF374bB21D83Cf010cC7363918776aDF6FF2BF6', '0xE663F7d6AFB3A3Ef458D5c4a068E29368a46Eb87'),
  },
  //sushi
  {
    ...createVaultModel('0xf84E313B36E86315af7a06ff26C8b20e9EB443C3', '0x32B750721Ad93f62b21402526354d53ac46953C2'),
  },
  //crv
  {
    ...createVaultModel('0xB471Ac6eF617e952b84C6a9fF5de65A9da96C93B', '0x424B1AE0AF693d4577dde25081E970cb656013C7'),
  },
  //bnb
  {
    ...createVaultModel('0x956DE13EA0FA5b577E4097Be837BF4aC80005820', '0x1fA1B8D94B922e3C9821f66363a75237c36096af'),
  },
  //any
  {
    ...createVaultModel('0x5c021D9cfaD40aaFC57786b409A9ce571de375b4', '0xE41718b549B935358A2f62acbD289F3dcccABB18'),
  },
  //mim
  {
    ...createVaultModel('0x6f86e65b255c9111109d2D2325ca2dFc82456efc', '0xfB271303B157d2e3d91CF86C7956eb46180d62E5'),
  },
  //yfi
  {
    ...createVaultModel('0x0845c0bFe75691B1e21b24351aAc581a7FB6b7Df', '0x4CddFEf40f13F16520b7f98f269f772560A8fb9a'),
  },
  //btcEth
  {
    ...createVaultModel('0xEc454EdA10accdD66209C57aF8C12924556F3aBD', '0x58bC3B5949C6784819A606645d616D8D2dA7594B'),
  },
  //spell
  {
    ...createVaultModel('0x78f82c16992932EfDd18d93f889141CcF326DBc2', '0x4aFa2C780d0d2b139886A532d1D1959f4D316ee7'),
  },
  //joe
  {
    ...createVaultModel('0xd518737Ff601c2A7C67F55EbbEb0a4e3fF5C0C35', '0xbE0093F744287Ea0478cc75c6320043a8b79E845'),
  },
]

module.exports = {
  vaults,
}
'''
'''--- projects/config/onx/polygon/index.js ---
const BigNumber = require('bignumber.js');
const { ZERO, getVautsTvl, } = require('../../../helper/ankr/utils');
const { vaults } = require('./vaults');
const { request, gql } = require("graphql-request");

const getQuickQuery = (pairAddress) => gql`
  query pairs {
    pairs(where: { id: "${pairAddress}"} ) {
        id
        reserveUSD
        trackedReserveETH
        volumeUSD
        untrackedVolumeUSD
        totalSupply
      }
    }`
;

const url = 'https://polygon.furadao.org/subgraphs/name/quickswap';

const getPairsData = async (pairAddress) => {
  try {
    const result = await request(url, getQuickQuery(pairAddress));
    const last = result.pairs.length;
    return result && result.pairs ? result.pairs[last - 1] : {};
  } catch (e) {
    console.error(e);
  }

  return {};
};

const getQuickPoolPrice = async (vault) => {
  if (!vault.pool) {
    return ZERO;
  }

  const data = await getPairsData(vault.pool);
  const { reserveUSD, totalSupply } = data;

  return reserveUSD && totalSupply ? new BigNumber(reserveUSD).div(totalSupply).div(1e18) : ZERO;
};

const getPolygonTvl = async () => {
  return getVautsTvl(vaults, getQuickPoolPrice);
};

module.exports = {
  getPolygonTvl,
}
'''
'''--- projects/config/onx/polygon/vaults.js ---
const createVaultModel = (poolAddress, vaultAddress) => {
  return {
    pool: poolAddress,
    vault: vaultAddress,
    chain: 'polygon',
  }
}

const vaults = [
  //dualMaticUsdc
  {
    ...createVaultModel('0x6e7a5fafcec6bb1e78bae2a1f0b612012bf14827', '0x36D14424Cc5a18893e93A0f8FdD42DC40562887E'),
  },
  //dualMaticEth
  {
    ...createVaultModel('0xadbf1854e5883eb8aa7baf50705338739e558e5b', '0xfe51dE20719d05152Ace63a069446Bb5C89511DB'),
  },
  //dualMaticUsdt
  {
    ...createVaultModel('0x604229c960e5cacf2aaeac8be68ac07ba9df81c3', '0x067E7586Eb8733bF108167C15cBAbee4c629C37A'),
  },
  //dualMaticQuick
  {
    ...createVaultModel('0x019ba0325f1988213d448b3472fa1cf8d07618d7', '0x849031F78970639F8Dc9Dc3E962e0d0079D1051c'),
  },
  //EthUsdc
  {
    ...createVaultModel('0x853ee4b2a13f8a742d64c8f088be7ba2131f670d', '0x185A1cfdb7173b224d08E61F1Cb21Fd5Fd6ee8CD'),
  },
  //wBtcEth
  {
    ...createVaultModel('0xdc9232e2df177d7a12fdff6ecbab114e2231198d', '0xf1ba3ef65262ee4058462e65a3a09a7571193400'),
  },
  //ethUsdt
  {
    ...createVaultModel('0xf6422b997c7f54d1c6a6e103bcb1499eea0a7046', '0x353856185fBB65a098b971B6d492CC3c245D9a59'),
  },
  //quickEth
  {
    ...createVaultModel('0x1bd06b96dd42ada85fdd0795f3b4a79db914add5', '0x9767218525A443AE1B04A2a84Cf2f6D646C2fA06'),
  },
  //aaveEth
  {
    ...createVaultModel('0x90bc3e68ba8393a3bf2d79309365089975341a43', '0xbB760a23924a23e5270c659349c753d16e7C1078'),
  },
  //ethDai
  {
    ...createVaultModel('0x4a35582a710e1f4b2030a3f826da20bfb6703c09', '0x0d553115D2c1E2b734d66De1Eba4BAe1a88cB175'),
  },
  //wbtcUsdc
  {
    ...createVaultModel('0xf6a637525402643b0654a54bead2cb9a83c8b498', '0x248Eecc8286A8C6484B4A87e1F32f0bc2d7971D4'),
  },
  //linkEth
  {
    ...createVaultModel('0x5ca6ca6c3709e1e6cfe74a50cf6b2b6ba2dadd67', '0x58bC3B5949C6784819A606645d616D8D2dA7594B'),
  },
  //usdcQuick
  {
    ...createVaultModel('0x1f1e4c845183ef6d50e9609f16f6f9cae43bc9cb', '0x7E9dA60002dAF64778C78Ac90dD5bdc9391acb00'),
  },
  //usdcUsdt
  {
    ...createVaultModel('0x2cf7252e74036d1da831d11089d326296e64a728', '0x1a130be9a0E9046936E5461D3e8727b6aF7d0C2C'),
  },
  //avaxMatic
  {
    ...createVaultModel('0xeb477ae74774b697b5d515ef8ca09e24fee413b5', '0x8D20fB2F4F96E897Fed7E3E50f8A403aFc59dA23'),
  },
  //solMatic
  {
    ...createVaultModel('0x898386dd8756779a4ba4f1462891b92dd76b78ef', '0x0A1EfAF7dd833F9D8EF9f2f095bf1d6C725FF110'),
  },
  //bnbUsdc
  {
    ...createVaultModel('0x40a5df3e37152d4daf279e0450289af76472b02e', '0x43bE6849BC355735D77238AcfDBcEB7bE8673f02'),
  },
  //ftmMatic
  {
    ...createVaultModel('0xd2b61a42d3790533fedc2829951a65120624034a', '0xF020de990036D5aE107860592Bde0E53892F1531'),
  },
  //daiUsdc
  {
    ...createVaultModel('0xf04adbf75cdfc5ed26eea4bbbb991db002036bdd', '0x260e6fB68C787CdA2E9ea104f9e3a3923E4119f6'),
  },
  //daiUsdt
  {
    ...createVaultModel('0x59153f27eefe07e5ece4f9304ebba1da6f53ca88', '0x32B750721Ad93f62b21402526354d53ac46953C2'),
  },
]

module.exports = {
  vaults,
}
'''
'''--- projects/config/onx/vault.js ---
const EXCHANGE_TYPE = {
  SUSHISWAP: 'SUSHISWAP',
  AVALANCHE: 'AVALANCHE',
  UNISWAP: 'UNISWAP',
  QUICKSWAP: 'QUICKSWAP',
  QUICKSWAP_DUAL_MATIC: 'QUICKSWAP_DUAL_MATIC',
  SPOOKYSWAP: 'SPOOKYSWAP',
  SPOOKYSWAP_SINGLE: 'SPOOKYSWAP_SINGLE',
}

module.exports = {
  EXCHANGE_TYPE,
}
'''
'''--- projects/config/piedao/abi/IBCP.json ---
[
  {
    "inputs": [],
    "name": "getTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/config/piedao/abi/IPie.json ---
[
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
      }
    ],
    "name": "calcTokensForAmount",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "tokens",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "amounts",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/config/piedao/abi/IStakedToken.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "getFinalTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "tokens",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/config/piedao/abi/IStakingAll.json ---
[
  {
    "inputs": [],
    "name": "poolCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_poolId",
        "type": "uint256"
      }
    ],
    "name": "getPoolToken",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }]
'''
'''--- projects/config/piedao/abi/IStakingBalancer.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "uni",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/config/smoothy/abis.js ---
let abis = {};

abis.smoothy = [
    {
        "inputs": [],
        "name": "_ntokens",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "bTokenIdx",
                "type": "uint256"
            }
        ],
        "name": "getTokenStats",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "softWeight",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "hardWeight",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "balance",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "decimals",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
];

abis.tokens = [
    {
        symbol: "USDT",
        address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
        id: 0,
        decimals: 6,
    },
    {
        symbol: "USDC",
        address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        id: 1,
        decimals: 6,
    },
    {
        symbol: "DAI",
        address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        id: 2,
        decimals: 18,
    },
    {
        symbol: "TUSD",
        address: "0x0000000000085d4780B73119b644AE5ecd22b376",
        id: 3,
        decimals: 18,
    },
    {
        symbol: "sUSD",
        address: "0x57ab1ec28d129707052df4df418d58a2d46d5f51",
        id: 4,
        decimals: 18,
    },
    {
        symbol: "BUSD",
        address: "0x4fabb145d64652a948d72533023f6e7a623c7c53",
        id: 5,
        decimals: 18,
    },
    {
        symbol: "PAX",
        address: "0x8e870d67f660d95d5be530380d0ec0bd388289e1",
        id: 6,
        decimals: 18,
    },
    {
        symbol: "GUSD",
        address: "0x056fd409e1d7a124bd7017459dfea2f387b6d5cd",
        id: 7,
        decimals: 2,
    },
];

module.exports = {
    abis
}

'''
'''--- projects/config/uma/abis.js ---

let abis = {};

abis.uma = [{"inputs":[{"components":[{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"},{"internalType":"uint256","name":"withdrawalLiveness","type":"uint256"},{"internalType":"address","name":"collateralAddress","type":"address"},{"internalType":"address","name":"finderAddress","type":"address"},{"internalType":"address","name":"tokenFactoryAddress","type":"address"},{"internalType":"address","name":"timerAddress","type":"address"},{"internalType":"bytes32","name":"priceFeedIdentifier","type":"bytes32"},{"internalType":"string","name":"syntheticName","type":"string"},{"internalType":"string","name":"syntheticSymbol","type":"string"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"minSponsorTokens","type":"tuple"},{"internalType":"uint256","name":"liquidationLiveness","type":"uint256"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralRequirement","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"disputeBondPct","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"sponsorDisputeRewardPct","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"disputerDisputeRewardPct","type":"tuple"}],"internalType":"struct Liquidatable.ConstructorParams","name":"params","type":"tuple"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"}],"name":"ContractExpired","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"address","name":"liquidator","type":"address"},{"indexed":false,"internalType":"address","name":"disputer","type":"address"},{"indexed":false,"internalType":"uint256","name":"liquidationId","type":"uint256"},{"indexed":false,"internalType":"bool","name":"disputeSucceeded","type":"bool"}],"name":"DisputeSettled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint256","name":"originalExpirationTimestamp","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"shutdownTimestamp","type":"uint256"}],"name":"EmergencyShutdown","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"}],"name":"EndedSponsorPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FinalFeesPaid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"address","name":"liquidator","type":"address"},{"indexed":true,"internalType":"uint256","name":"liquidationId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"tokensOutstanding","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"lockedCollateral","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"liquidatedCollateral","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"liquidationTime","type":"uint256"}],"name":"LiquidationCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"address","name":"liquidator","type":"address"},{"indexed":true,"internalType":"address","name":"disputer","type":"address"},{"indexed":false,"internalType":"uint256","name":"liquidationId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"disputeBondAmount","type":"uint256"}],"name":"LiquidationDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint256","name":"withdrawalAmount","type":"uint256"},{"indexed":true,"internalType":"enum Liquidatable.Status","name":"liquidationStatus","type":"uint8"},{"indexed":false,"internalType":"uint256","name":"settlementPrice","type":"uint256"}],"name":"LiquidationWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"}],"name":"NewSponsor","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"tokenAmount","type":"uint256"}],"name":"PositionCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"tokenAmount","type":"uint256"}],"name":"Redeem","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"regularFee","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"lateFee","type":"uint256"}],"name":"RegularFeesPaid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldSponsor","type":"address"}],"name":"RequestTransferPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldSponsor","type":"address"}],"name":"RequestTransferPositionCanceled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldSponsor","type":"address"},{"indexed":true,"internalType":"address","name":"newSponsor","type":"address"}],"name":"RequestTransferPositionExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"}],"name":"RequestWithdrawal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"}],"name":"RequestWithdrawalCanceled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"}],"name":"RequestWithdrawalExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralReturned","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"tokensBurned","type":"uint256"}],"name":"SettleExpiredPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sponsor","type":"address"},{"indexed":true,"internalType":"uint256","name":"collateralAmount","type":"uint256"}],"name":"Withdrawal","type":"event"},{"inputs":[],"name":"cancelTransferPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"cancelWithdrawal","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"collateralCurrency","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"collateralRequirement","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractState","outputs":[{"internalType":"enum PricelessPositionManager.ContractState","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"numTokens","type":"tuple"}],"name":"create","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sponsor","type":"address"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"minCollateralPerToken","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"maxCollateralPerToken","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"maxTokensToLiquidate","type":"tuple"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"createLiquidation","outputs":[{"internalType":"uint256","name":"liquidationId","type":"uint256"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"tokensLiquidated","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"finalFeeBond","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"cumulativeFeeMultiplier","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"}],"name":"deposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sponsor","type":"address"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"}],"name":"depositTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"liquidationId","type":"uint256"},{"internalType":"address","name":"sponsor","type":"address"}],"name":"dispute","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"totalPaid","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"disputeBondPct","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"disputerDisputeRewardPct","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"emergencyShutdown","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"expirationTimestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"expire","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"expiryPrice","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"finder","outputs":[{"internalType":"contract FinderInterface","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"sponsor","type":"address"}],"name":"getCollateral","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"sponsor","type":"address"}],"name":"getLiquidations","outputs":[{"components":[{"internalType":"address","name":"sponsor","type":"address"},{"internalType":"address","name":"liquidator","type":"address"},{"internalType":"enum Liquidatable.Status","name":"state","type":"uint8"},{"internalType":"uint256","name":"liquidationTime","type":"uint256"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"tokensOutstanding","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"lockedCollateral","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"liquidatedCollateral","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"rawUnitCollateral","type":"tuple"},{"internalType":"address","name":"disputer","type":"address"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"settlementPrice","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"finalFee","type":"tuple"}],"internalType":"struct Liquidatable.LiquidationData[]","name":"liquidationData","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"liquidationLiveness","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"liquidations","outputs":[{"internalType":"address","name":"sponsor","type":"address"},{"internalType":"address","name":"liquidator","type":"address"},{"internalType":"enum Liquidatable.Status","name":"state","type":"uint8"},{"internalType":"uint256","name":"liquidationTime","type":"uint256"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"tokensOutstanding","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"lockedCollateral","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"liquidatedCollateral","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"rawUnitCollateral","type":"tuple"},{"internalType":"address","name":"disputer","type":"address"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"settlementPrice","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"finalFee","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minSponsorTokens","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"payRegularFees","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"totalPaid","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pfc","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"positions","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"tokensOutstanding","type":"tuple"},{"internalType":"uint256","name":"withdrawalRequestPassTimestamp","type":"uint256"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"withdrawalRequestAmount","type":"tuple"},{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"rawCollateral","type":"tuple"},{"internalType":"uint256","name":"transferPositionRequestPassTimestamp","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"priceIdentifier","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"rawLiquidationCollateral","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"rawTotalPositionCollateral","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"numTokens","type":"tuple"}],"name":"redeem","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"amountWithdrawn","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"remargin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"requestTransferPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"}],"name":"requestWithdrawal","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"time","type":"uint256"}],"name":"setCurrentTime","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"settleExpired","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"amountWithdrawn","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"sponsorDisputeRewardPct","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timerAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokenCurrency","outputs":[{"internalType":"contract ExpandedIERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalPositionCollateral","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"totalCollateral","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalTokensOutstanding","outputs":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newSponsorAddress","type":"address"}],"name":"transferPositionPassedRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"collateralAmount","type":"tuple"}],"name":"withdraw","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"amountWithdrawn","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"liquidationId","type":"uint256"},{"internalType":"address","name":"sponsor","type":"address"}],"name":"withdrawLiquidation","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"amountWithdrawn","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawPassedRequest","outputs":[{"components":[{"internalType":"uint256","name":"rawValue","type":"uint256"}],"internalType":"struct FixedPoint.Unsigned","name":"amountWithdrawn","type":"tuple"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"withdrawalLiveness","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]

module.exports = {
  abis
}

'''
'''--- projects/config/wepiggy/abi.json ---
{
  "decimals":
    {
      "constant": true,
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ,
  "getAllMarkets":
    {
      "constant": true,
      "inputs": [],
      "name": "getAllMarkets",
      "outputs": [
        {
          "internalType": "contract CToken[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ,
  "underlying":
    {
      "constant": true,
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ,
  "getCash":
    {
      "constant": true,
      "inputs": [],
      "name": "getCash",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ,
  "getUnderlyingPrice":
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "_pToken",
          "type": "address"
        }
      ],
      "name": "getUnderlyingPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    "oracle":
    {
      "inputs": [],
      "name": "oracle",
      "outputs": [
        {
          "internalType": "contract IPriceOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
}

'''
'''--- projects/connext/abi.json ---
{
  "totalChannelToken": {
    "constant": true,
    "inputs": [],
    "name": "totalChannelToken",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/connext/index.js ---
const { get } = require("../helper/http");
const { getBlock } = require("../helper/getBlock");
const { chainExports } = require("../helper/exports");
const sdk = require("@defillama/sdk");
const { getChainTransform, getFixBalances } = require("../helper/portedTokens");
const { sumTokens } = require("../helper/unwrapLPs");

// Includes some chains that are not yet live
const chainNameToChainId = {
  ethereum: 1,
  bsc: 56,
  boba: 288,
  polygon: 137,
  xdai: 100,
  fantom: 250,
  arbitrum: 42161,
  avax: 43114,
  optimism: 10,
  fuse: 122,
  moonbeam: 1284,
  moonriver: 1285,
  milkomeda: 2001,
  celo: 42220,
  aurora: 1313161554,
  harmony: 1666600000,
  cronos: 25,
  evmos: 9001,
  heco: 128,
};

let getContractsPromise

// Taken from @connext/nxtp-contracts
async function getContracts() {
  if (!getContractsPromise)
    getContractsPromise = get('https://raw.githubusercontent.com/connext/nxtp/v0.1.36/packages/contracts/deployments.json')
  return getContractsPromise
}

async function getDeployedContractAddress(chainId) {
  const contracts = await getContracts()
  const record = contracts[String(chainId)] || {}
  const name = Object.keys(record)[0];
  if (!name) {
    return undefined;
  }
  const contract = record[name]?.contracts?.TransactionManager;
  return contract ? contract.address : undefined;
}

let getAssetsPromise
// Taken from @connext/nxtp-utils
async function getAssetIds(chainId) {
  const url = "https://raw.githubusercontent.com/connext/chaindata/main/crossChain.json"
  if (!getAssetsPromise)
    getAssetsPromise = get(url)
  const data = await getAssetsPromise
  const chainData = data.find(item => item.chainId === chainId)
  return Object.keys(chainData.assetId).map(id => id.toLowerCase())
}

const nullAddress = '0x0000000000000000000000000000000000000000'

function chainTvl(chain) {
  return async (time, ethBlock, chainBlocks) => {
    const chainId = chainNameToChainId[chain]
    const contractAddress = await getDeployedContractAddress(chainId);
    if (!contractAddress)
      return {}
    const block = await getBlock(time, chain, chainBlocks, true);
    const chainTransform = await getChainTransform(chain);
    const fixBalances = await getFixBalances(chain);
    const balances = {};

    let assetIds = await getAssetIds(chainId)
    if (assetIds.includes(nullAddress)) {
      const balance = await sdk.api.eth.getBalance({ chain, block, target: contractAddress, })
      sdk.util.sumSingleBalance(balances, chainTransform(nullAddress), balance.output)
    }
    const tokensAndOwners = assetIds
      .filter(id => id !== nullAddress)
      .map(id => [id, contractAddress])
    await sumTokens(balances, tokensAndOwners, block, chain, chainTransform)
    fixBalances(balances)
    return balances
  };
}

const chains = [
  "ethereum",
  "bsc",
  "polygon",
  "moonriver",
  "fantom",
  "xdai",
  "avax",
  "optimism",
  "arbitrum",
  "moonbeam",
  "fuse",
  "cronos",
  "milkomeda",
  "boba",
  "evmos",
  "harmony",
  /*
  "okexchain",
  "metis",
  "heco",
  "aurora",
  */
];
module.exports = chainExports(chainTvl, Array.from(chains));

'''
'''--- projects/connext/old.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const BigNumber = require('bignumber.js')
const {getBlock} = require('../helper/getBlock')

// V1
const hubAddress = '0xdfa6edAe2EC0cF1d4A60542422724A48195A5071';
const tokenDenominationAddress = '0x6b175474e89094c44da98b954eedeac495271d0f';
//V3
const routers = ['0xe3cF69b86F274a14B87946bf641f11Ac837f4492', '0xe6887c0cc3c37cb2ee34Bc58AB258f36825CA910', '0xE540998865aFEB054021dc849Cc6191b8E09dC08', '0xC6C68811E75EfD86d012587849F1A1D30427361d']
const ethereumTokens = ['0xdAC17F958D2ee523a2206206994597C13D831ec7', '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', '0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0', '0x0f5d2fb29fb7d3cfee444a200298f468908cc942', '0x6b175474e89094c44da98b954eedeac495271d0f']
const bscTokens = ['0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3', '0x55d398326f99059fF775485246999027B3197955', '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d']
const polygonSettings = {
  nativeCoin: 'matic-network',
  tokens: [
    {
      address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',
      coingeckoId: 'dai',
    },
    {
      address: '0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4',
      coingeckoId: 'decentraland'
    },
    {
      address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
      coingeckoId: 'tether'
    },
    {
      address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',
      coingeckoId: 'usd-coin'
    }
  ]
}
const xdaiSettings = {
  nativeCoin: 'dai',
  tokens: [
    {
      address: '0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83',
      coingeckoId: 'usd-coin'
    },
    {
      address: '0x4ECaBa5870353805a9F068101A40E0f32ed605C6',
      coingeckoId: 'tether'
    },
  ]
}

function constructBalanceOfCalls(tokens, useAddressProp){
  const calls = []
  for(const router of routers){
    for(const token of tokens){
      const address = useAddressProp?token.address:token
      calls.push({
        target: address,
        params: [router]
      })
    }
  }
  return calls
}

async function getRouterBalances(timestamp, chain, settings, block){
  const routerBalances = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    block,
    calls: constructBalanceOfCalls(settings.tokens, true),
    chain
  })
  const tokenDecimals = await sdk.api.abi.multiCall({
    abi: 'erc20:decimals',
    block,
    calls: settings.tokens.map(token => ({
      target: token.address,
    })),
    chain
  })
  const nativeBalances = await sdk.api.eth.getBalances({
    targets: routers,
    block,
    chain,
  })
  const totalNativeBalance = nativeBalances.output.reduce((acc, output)=>acc.plus(output.balance), BigNumber(0))
  const balances = {}
  balances[settings.nativeCoin] = totalNativeBalance.div(1e18).toFixed(0)
  routerBalances.output.forEach((result)=>{
    const tokenIndex = settings.tokens.findIndex(token=>result.input.target.toLowerCase()===token.address.toLowerCase())
    const coingeckoId = settings.tokens[tokenIndex].coingeckoId
    const decimals = Number(tokenDecimals.output[tokenIndex].output)
    sdk.util.sumSingleBalance(balances, coingeckoId, BigNumber(result.output).div(10**decimals).toFixed(0))
  })
  return balances;
}

async function ethereum(timestamp, block) {
  // V1
  const totalChannelToken = (await sdk.api.abi.call({
    block,
    target: hubAddress,
    abi: abi['totalChannelToken'],
  })).output;

  const balances = { [tokenDenominationAddress]: totalChannelToken };

  // V2
  const routerBalances = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    block,
    calls: constructBalanceOfCalls(ethereumTokens, false)
  })
  sdk.util.sumMultiBalanceOf(balances, routerBalances);

  return balances
}

async function bsc(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.bsc
  const balances={}
  const routerBalances = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    block,
    chain:'bsc',
    calls: constructBalanceOfCalls(bscTokens, false)
  })
  routerBalances.output.forEach(result=>{
    sdk.util.sumSingleBalance(balances, `bsc:${result.input.target}`, result.output)
  })
  return balances
}

async function polygon(timestamp, ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, 'polygon', chainBlocks)
  return getRouterBalances(timestamp, 'polygon', polygonSettings, block)
}

async function xdai(timestamp, ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, 'xdai', chainBlocks)
  return getRouterBalances(timestamp, 'xdai', xdaiSettings, block)
}

module.exports = {
  start: 1552065900,  // 03/08/2019 @ 5:25pm (UTC)
  ethereum: {
    tvl: ethereum
  },
  polygon: {
    tvl: polygon
  },
  xdai: {
    tvl: xdai
  },
  bsc:{
    tvl: bsc
  }
};

'''
'''--- projects/convergence/index.js ---
const { calculateUniTvl } = require('../helper/calculateUniTvl')
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const ETH_FACTORY = '0x4eef5746ED22A2fD368629C1852365bf5dcb79f1';
const MOONBEAM_FACTORY = '0x9504d0d43189d208459e15c7f643aac1abe3735d';

async function ethTvl(timestamp, block) {
  return calculateUniTvl(id=>id, block, 'ethereum', ETH_FACTORY, 12449394, false)
}

module.exports = {
    start: 1621220505, //2021-05-17 00:00:00 +UTC
    misrepresentedTokens: true,
    timetravel: true,
    ethereum: {
      tvl: ethTvl
    },
    moonbeam: {
        tvl: calculateUsdUniTvl(
            MOONBEAM_FACTORY,
            "moonbeam",
            "0x81ecac0d6be0550a00ff064a4f9dd2400585fe9c",
            [
                "0x6a2d262d56735dba19dd70682b39f6be9a931d98",
                "0x1a93b23281cc1cde4c4741353f3064709a16197d",
                "0x8006320739fc281da67ee62eb9b4ef8add5c903a",
                "0x6959027f7850adf4916ff5fdc898d958819e5375"
            ],
            "tether",
            6
        ),
    }
};
'''
'''--- projects/convex/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "address",
                "name": "lptoken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "gauge",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "crvRewards",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "stash",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "shutdown",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "coinsUint": {
        "name": "coins",
        "outputs": [
            {
                "type": "address",
                "name": ""
            }
        ],
        "inputs": [
            {
                "type": "uint256",
                "name": "arg0"
            }
        ],
        "stateMutability": "view",
        "type": "function",
        "gas": 2280
    },
    "coinsInt": {
        "name": "coins",
        "outputs": [
            {
                "type": "address",
                "name": "out"
            }
        ],
        "inputs": [
            {
                "type": "int128",
                "name": "arg0"
            }
        ],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 2190
    },
    "coins":{
        "constant": true,
        "name": "coins",
        "outputs": [{
            "type": "address",
            "name": ""
        }],
        "inputs": [{
            "type": "uint256",
            "name": "arg0"
        }],
        "stateMutability": "view",
        "type": "function",
        "gas": 2280
    },
    "get_balances":{
        "constant": true,
        "name": "get_balances",
        "outputs": [{
            "type": "uint256[2]",
            "name": ""
        }],
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "gas": 2284
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "get_underlying_coins" : {
        "stateMutability": "view",
        "type": "function",
        "name": "get_underlying_coins",
        "inputs": [
            {
                "name": "_pool",
                "type": "address"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "address[8]"
            }
        ],
        "gas": 12194
    },
    "get_pool_from_lp_token" : {
        "stateMutability": "view",
        "type": "function",
        "name": "get_pool_from_lp_token",
        "inputs": [
            {
                "name": "arg0",
                "type": "address"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "address"
            }
        ],
        "gas": 2443
    },
    "get_coins" : {
        "stateMutability": "view",
        "type": "function",
        "name": "get_coins",
        "inputs": [
            {
                "name": "_pool",
                "type": "address"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "address[8]"
            }
        ],
        "gas": 12102
    },
    "get_underlying_balances" : {
        "stateMutability": "view",
        "type": "function",
        "name": "get_underlying_balances",
        "inputs": [
            {
                "name": "_pool",
                "type": "address"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "uint256[8]"
            }
        ],
        "gas": 162842
    },
    "lockedSupply":{"inputs":[],"name":"lockedSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/convex/index.js ---
const sdk = require("@defillama/sdk");
const ABI = require('./abi.json')
const { default: BigNumber } = require("bignumber.js");

const addressZero = "0x0000000000000000000000000000000000000000"
const ethAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
const boosterAddress = "0xF403C135812408BFbE8713b5A23a04b3D48AAE31";
const currentRegistryAddress = "0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5";
const cvxAddress = "0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B";
const cvxRewardsAddress = "0xCF50b810E57Ac33B91dCF525C6ddd9881B139332";
const cvxcrvAddress = "0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7";
const cvxfxsAddress = "0xFEEf77d3f69374f66429C91d732A244f074bdf74";
const wbtcAddress = "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599";

/*
These tokens still come up as UNKNOWN
-------------
sGBP: 0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F
sCHF: 0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d
sKRW: 0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B
sJPY: 0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d
EURN: 0x9fcf418B971134625CdF38448B949C8640971671

These tokens come up with 0 value
-----------
IBGBP
*/

const usdReplacements = [
  "0x99d1Fa417f94dcD62BfE781a1213c092a47041Bc",
  "0x9777d7E2b60bB01759D0E2f8be2095df444cb07E",
  "0x1bE5d71F2dA660BFdee8012dDc58D024448A0A59",
  "0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01",
  "0xd6aD7a6750A7593E092a9B218d66C0A814a3436e",
  "0x83f798e925BcD4017Eb265844FDDAbb448f1707D",
  "0x73a052500105205d34Daf004eAb301916DA8190f",
  "0xC2cB1040220768554cf699b0d863A3cd4324ce32",
  "0x26EA744E5B887E5205727f55dFBE8685e3b21951",
  "0xE6354ed5bC4b393a5Aad09f21c46E101e692d447",
  "0x04bC0Ab673d88aE9dbC9DA2380cB6B79C4BCa9aE"
]

const btcReplacements = [
  "0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3",
  "0x8751D4196027d4e6DA63716fA7786B5174F04C15"
]

const lpTokenToSwapAddress = {
  "0x3A283D9c08E8b55966afb64C515f5143cf907611":"0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4", //cvx-eth
  "0x6BA5b4e438FA0aAf7C1bD179285aF65d13bD3D90":"0x618788357D0EBd8A37e763ADab3bc575D54c2C7d", //rai-3pool
  "0xEd4064f376cB8d68F770FB1Ff088a3d0F3FF5c4d":"0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511", //crv-eth
}

async function tvl(timestamp, block) {
  console.log('convex start')
  var allCoins = {};

  const poolLength = (await sdk.api.abi.call({
    target: boosterAddress,
    abi: ABI.poolLength,
    block
  })).output;
  var poolInfo = [];
  var calldata = [];
  for (let i = 0; i < poolLength; i++) {
    calldata.push({
      target: boosterAddress,
      params: [i]
    })
  }
  var returnData = await sdk.api.abi.multiCall({
    abi: ABI.poolInfo,
    calls: calldata,
    block
  })
  for (let i = 0; i < poolLength; i++) {
    var pdata = returnData.output[i].output;
    poolInfo.push(pdata);
  }

  
  await Promise.all([...Array(Number(poolLength)).keys()].map(async i => {
    console.log("getting supplies and balances for pool " + i + "...");

    var convexsupply = await sdk.api.erc20.totalSupply({
      target: poolInfo[i].token,
      block
    });

    var totalsupply = await sdk.api.erc20.totalSupply({
      target: poolInfo[i].lptoken,
      block
    })

    var share = BigNumber(convexsupply.output).times(1e18).div(totalsupply.output).toFixed(0);

    var pool = await sdk.api.abi.call({
      target: currentRegistryAddress,
      block,
      abi: ABI.get_pool_from_lp_token,
      params: poolInfo[i].lptoken
    })

    var maincoins;

    if(pool.output == addressZero){
      console.log("pool " +i +" not in registry yet.")

      maincoins = {};
      maincoins.output = [];

      var swapPool = poolInfo[i].lptoken;
      if(lpTokenToSwapAddress[swapPool] != undefined){
        swapPool = lpTokenToSwapAddress[swapPool];
      }

      //i dont see a way to get number of coins..
      //loop until it fails
      for(let c=0; c < 10; c++){
        try {
          var coinX = await sdk.api.abi.call({
            target: swapPool,
            block,
            abi: ABI.coins,
            params: c
          });
          maincoins.output.push(coinX.output);
        } catch (error) {
          //console.error(error);
          break;
        }
      }
      
      if(maincoins.output.length == 0){
        console.log("could not get coins off of lptoken for pool " +i);
        return;
      }else{
        //coins successfully pulled from lptoken (factory pool, thus swap is same as lp token)
        console.log("pool " +i +" is a factory pool, use lptoken as swap address");
        pool.output = swapPool
      }
    }else{
      maincoins = await sdk.api.abi.call({
        target: currentRegistryAddress,
        block,
        abi: ABI.get_coins,
        params: pool.output
      });
    }

    var coins = [];

    for (var coinlist = 0; coinlist < maincoins.output.length; coinlist++) {
      var coin = maincoins.output[coinlist];
      if(coin == addressZero){
        continue;
      }

      if(coin != ethAddress ){
          var bal = await sdk.api.erc20.balanceOf({
            target: coin,
            owner: pool.output,
            block
          })
          coins.push({coin:coin, balance:bal.output});
      }else{
        var ethbal = await sdk.api.eth.getBalance({
          target: pool.output,
          block
        })
        //use zero address to represent eth
        coins.push({coin:addressZero, balance:ethbal.output})
      }
    }

    //conversion logic for ironbank tokens
    if(i == 29){
      const calls = coins.map(coinOutput=>({
        target: coinOutput.coin
      }))
      var underlying = await sdk.api.abi.multiCall({
        abi: ABI.underlying,
        block,
        calls
      })
      const exchangeRate = await sdk.api.abi.multiCall({
        abi: ABI.exchangeRateStored,
        block,
        calls
      })
      coins = coins.map((result, i)=>({
        coin: underlying.output[i].output,
        balance: BigNumber(result.balance).times(exchangeRate.output[i].output).div(1e18).toFixed(0),
      }))
    }

    //calc convex share of pool
    for (let c = 0; c < coins.length; c++) {
        var balanceShare = BigNumber(coins[c].balance.toString()).times(share).div(1e18).toFixed(0);

        var coinAddress = coins[c].coin;
        if(usdReplacements.includes(coinAddress)){
          coinAddress = "0x6b175474e89094c44da98b954eedeac495271d0f" // dai
        }

        //convert btc lp tokens to wbtc.  this is temp and should convert using virtual price
        //  ....or defillama supports their price feed.
        if(btcReplacements.includes(coinAddress)){
          coinAddress = wbtcAddress;
          //convert to 8 decimals
          balanceShare = BigNumber(balanceShare.toString()).div(1e10).toFixed(0);
        }

        sdk.util.sumSingleBalance(allCoins, coinAddress, balanceShare)
    }
  }))

  //cvxcrv supply
  var cvxcrvSupply = await sdk.api.erc20.totalSupply({
    target: cvxcrvAddress,
    block
  });

  sdk.util.sumSingleBalance(allCoins, cvxcrvAddress, cvxcrvSupply.output)

  //cvxfxs supply
  var cvxfxsSupply = await sdk.api.erc20.totalSupply({
    target: cvxfxsAddress,
    block
  });

  sdk.util.sumSingleBalance(allCoins, cvxfxsAddress, cvxfxsSupply.output)

  //TODO: all replacement coins need to queuery their actual balance
  //as the tokens have accrued interest, this means current tvl is under reporting
  // ....or defillama supports their price feed.

  console.log('convex end', allCoins)
  return allCoins;
}

async function staking(timestamp, block){
  const allCoins = {}
    //staked cvx
    var cvxStakedSupply = await sdk.api.erc20.totalSupply({
      target: cvxRewardsAddress,
      block
    });
  
    sdk.util.sumSingleBalance(allCoins, cvxAddress, cvxStakedSupply.output)
    return allCoins
}

module.exports = {
  doublecounted: true,
  timetravel: true,
  ethereum:{
    tvl,
    staking,
    //pool2: pool2("0x5F465e9fcfFc217c5849906216581a657cd60605", "0x05767d9ef41dc40689678ffca0608878fb3de906"),
  }
}

'''
'''--- projects/convex/pools-crv.js ---
const REFERENCE_ASSETS = {};
const coins = {};

module.exports = [{
    dataIndex: 0,
    id: 'compound',
    name: 'Compound',
    pageMetaData: {
        title: 'Compounded',
        description: 'A curve.fi portal for swapping cDAI/cUSDC',
    },
    lpTokenInfo: {
        name: 'cCurve',
        symbol: 'cCrv',
    },
    coingeckoInfo: {
        id: 'compound',
        symbol: 'COMP',
    },
    assets: 'cDAI+cUSDC',
    coins: [
        coins.cdai,
        coins.cusdc,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
    ],
    isLendingPool: true,
    addresses: {
        swap: '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56',
        lpToken: '0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2',
        gauge: '0x7ca5b0a2910B33e9759DC7dDB0413949071D7575',
        deposit: '0xeB21209ae4C2c9FF2a86ACA31E123764A3B6Bc06',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 1,
    id: 'usdt',
    name: 'USDT',
    pageMetaData: {
        title: 'Tethered',
        description: 'A curve.fi Tethered portal for swapping cDAI/cUSDC/USDT',
    },
    lpTokenInfo: {
        name: 'tCurve',
        symbol: 'tCrv',
    },
    coingeckoInfo: {
        id: 'tether',
        symbol: 'USDT',
    },
    assets: 'cDAI+cUSDC+USDT',
    coins: [
        coins.cdai,
        coins.cusdc,
        coins.usdt,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    isLendingPool: true,
    addresses: {
        swap: '0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C',
        lpToken: '0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23',
        gauge: '0xBC89cd85491d81C6AD2954E6d0362Ee29fCa8F53',
        deposit: '0xac795D2c97e60DF6a99ff1c814727302fD747a80',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 5,
    id: 'pax',
    name: 'PAX',
    lpTokenInfo: {
        name: 'pCurve',
        symbol: 'pCrv',
    },
    coingeckoInfo: {
        id: 'paxos-standard',
        symbol: 'PAX',
    },
    assets: 'ycDAI+ycUSDC+ycUSDT+PAX',
    coins: [
        coins.ycdai,
        coins.ycusdc,
        coins.ycusdt,
        coins.pax,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
        coins.pax,
    ],
    isLendingPool: true,
    // Additional context we might want to include for yctokens: `<router-link to='/yctokens'>ycTokens</router-link> are forked yTokens without owner and Compound lending available for ycUSDT`
    addresses: {
        swap: '0x06364f10B501e868329afBc005b3492902d6C763',
        lpToken: '0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8',
        gauge: '0x64E3C23bfc40722d3B649844055F1D51c1ac041d',
        deposit: '0xA50cCc70b6a011CffDdf45057E39679379187287',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 2,
    id: 'iearn',
    idAlias: 'y',
    name: 'Y',
    pageMetaData: {
        title: 'Yield',
        description: 'A curve.fi yTokens portal for swapping DAI/USDC/USDT/TUSD',
    },
    lpTokenInfo: {
        name: 'yCurve',
        symbol: 'yCrv',
    },
    coingeckoInfo: {
        id: 'yearn-finance',
        symbol: 'YFI',
    },
    assets: 'yDAI+yUSDC+yUSDT+yTUSD',
    coins: [
        coins.ydai,
        coins.yusdc,
        coins.yusdt,
        coins.ytusd,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
        coins.tusd,
    ],
    isLendingPool: true,
    addresses: {
        swap: '0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51',
        lpToken: '0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8',
        gauge: '0xFA712EE4788C042e2B7BB55E6cb8ec569C4530c1',
        deposit: '0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3',
        stakingRewards: '0x0001FB050Fe7312791bF6475b96569D83F695C9f',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 3,
    id: 'busd',
    name: 'BUSD',
    pageMetaData: {
        title: 'bUSD',
        description: 'A curve.fi portal for swapping BUSD and other stablecoins',
    },
    lpTokenInfo: {
        name: 'bCurve',
        symbol: 'bCrv',
    },
    coingeckoInfo: {
        id: 'binance-usd',
        symbol: 'BUSD',
    },
    assets: 'yDAI+yUSDC+yUSDT+yBUSD',
    coins: [
        coins.ydai,
        coins.yusdc,
        coins.yusdt,
        coins.ybusd,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
        coins.busd,
    ],
    isLendingPool: true,
    addresses: {
        swap: '0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27',
        lpToken: '0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B',
        gauge: '0x69Fb7c45726cfE2baDeE8317005d3F94bE838840',
        deposit: '0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 4,
    id: 'susdv2',
    name: 'sUSD',
    lpTokenInfo: {
        name: 'sCurve',
        symbol: 'sCrv',
    },
    coingeckoInfo: {
        id: 'nusd',
        symbol: 'SUSD',
    },
    assets: 'DAI+USDC+USDT+sUSD',
    coins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
        coins.susd,
    ],
    additionalRewards: [{
        name: 'SNX',
        amountDataKey: 'snxRewards',
        rewardTokenCoingeckoId: 'havven',
    }],
    addresses: {
        swap: '0xA5407eAE9Ba41422680e2e00537571bcC53efBfD',
        lpToken: '0xC25a3A3b969415c80451098fa907EC722572917F',
        gauge: '0xA90996896660DEcC6E997655E065b23788857849',
        deposit: '0xFCBa3E75865d2d561BE8D220616520c171F12851',
    },
    hasAMultiplier: false,
    isOldPool: true,
}, {
    dataIndex: 7,
    id: 'ren',
    name: 'ren',
    lpTokenInfo: {
        name: 'renCurve',
        symbol: 'renCrv',
    },
    coingeckoInfo: {
        id: 'renbtc',
        symbol: 'RENBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'renBTC+wBTC',
    coins: [
        coins.renbtc,
        coins.wbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    addresses: {
        swap: '0x93054188d876f558f4a66B2EF1d97d16eDf0895B',
        lpToken: '0x49849C98ae39Fff122806C06791Fa73784FB3675',
        gauge: '0xB1F2cdeC61db658F091671F5f199635aEF202CAC',
        adapter: '0x73aB2Bd10aD10F7174a1AD5AFAe3ce3D991C5047',
    },
    hasAMultiplier: false,
}, {
    dataIndex: 8,
    id: 'sbtc',
    name: 'sbtc',
    lpTokenInfo: {
        name: 'sbtcCurve',
        symbol: 'sbtcCrv',
    },
    coingeckoInfo: {
        id: 'sbtc',
        symbol: 'SBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'renBTC+wBTC+sBTC',
    coins: [
        coins.renbtc,
        coins.wbtc,
        coins.sbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    oldAdditionalRewards: [{
        name: 'SNX',
        rewardTokenCoingeckoId: 'havven',
    }],
    addresses: {
        swap: '0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714',
        lpToken: '0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3',
        gauge: '0x705350c4BcD35c9441419DdD5d2f097d7a55410F',
        stakingRewards: '0x13C1542A468319688B89E323fe9A3Be3A90EBb27',
        adapter: '0xAEade605D01FE9a8e9C4B3AA0130A90d62167029',
    },
    hasAMultiplier: false,
}, {
    dataIndex: 9,
    id: 'hbtc',
    name: 'hbtc',
    lpTokenInfo: {
        name: 'hbtcCurve',
        symbol: 'hbtcCrv',
    },
    coingeckoInfo: {
        id: 'huobi-btc',
        symbol: 'HBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'hBTC+wBTC',
    coins: [
        coins.hbtc,
        coins.wbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    addresses: {
        swap: '0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F',
        lpToken: '0xb19059ebb43466C323583928285a49f558E572Fd',
        gauge: '0x4c18E409Dc8619bFb6a1cB56D114C3f592E0aE79',
    },
    hasAMultiplier: false,
}, {
    dataIndex: 10,
    id: '3pool',
    name: '3pool',
    lpTokenInfo: {
        name: '3poolCurve',
        symbol: '3poolCrv',
    },
    assets: 'DAI+USDC+USDT',
    coins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7',
        lpToken: '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490',
        gauge: '0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A',
    },
    hasAMultiplier: false,
}, {
    dataIndex: 11,
    id: 'gusd',
    name: 'gusd',
    lpTokenInfo: {
        name: 'gusdCurve',
        symbol: 'gusdCrv',
    },
    coingeckoInfo: {
        id: 'gemini-dollar',
        symbol: 'GUSD',
    },
    assets: 'GUSD+3pool',
    isMetaPool: true,
    coins: [
        coins.gusd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x4f062658EaAF2C1ccf8C8e36D6824CDf41167956',
        lpToken: '0xD2967f45c4f384DEEa880F807Be904762a3DeA07',
        gauge: '0xC5cfaDA84E902aD92DD40194f0883ad49639b023',
        deposit: '0x64448B78561690B70E17CBE8029a3e5c1bB7136e',
    },
}, {
    dataIndex: 12,
    id: 'husd',
    name: 'husd',
    lpTokenInfo: {
        name: 'husdCurve',
        symbol: 'husdCrv',
    },
    coingeckoInfo: {
        id: 'husd',
        symbol: 'HUSD',
    },
    assets: 'HUSD+3pool',
    isMetaPool: true,
    coins: [
        coins.husd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x3eF6A01A0f81D6046290f3e2A8c5b843e738E604',
        lpToken: '0x5B5CFE992AdAC0C9D48E05854B2d91C73a003858',
        gauge: '0x2db0E83599a91b508Ac268a6197b8B14F5e72840',
        deposit: '0x09672362833d8f703D5395ef3252D4Bfa51c15ca',
    },
}, {
    dataIndex: 13,
    id: 'usdk',
    name: 'usdk',
    lpTokenInfo: {
        name: 'usdkCurve',
        symbol: 'usdkCrv',
    },
    coingeckoInfo: {
        id: 'usdk',
        symbol: 'USDK',
    },
    assets: 'USDK+3pool',
    isMetaPool: true,
    coins: [
        coins.usdk,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x3E01dD8a5E1fb3481F0F589056b428Fc308AF0Fb',
        lpToken: '0x97E2768e8E73511cA874545DC5Ff8067eB19B787',
        gauge: '0xC2b1DF84112619D190193E48148000e3990Bf627',
        deposit: '0xF1f85a74AD6c64315F85af52d3d46bF715236ADc',
    },
}, {
    dataIndex: 14,
    id: 'usdn',
    name: 'usdn',
    lpTokenInfo: {
        name: 'usdnCurve',
        symbol: 'usdnCrv',
    },
    coingeckoInfo: {
        id: 'neutrino',
        symbol: 'USDN',
    },
    assets: 'USDN+3pool',
    isMetaPool: true,
    coins: [
        coins.usdn,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x0f9cb53Ebe405d49A0bbdBD291A65Ff571bC83e1',
        lpToken: '0x4f3E8F405CF5aFC05D68142F3783bDfE13811522',
        gauge: '0xF98450B5602fa59CC66e1379DFfB6FDDc724CfC4',
        deposit: '0x094d12e5b541784701FD8d65F11fc0598FBC6332',
    },
}, {
    dataIndex: 15,
    id: 'linkusd',
    name: 'linkusd',
    lpTokenInfo: {
        name: 'linkusdCurve',
        symbol: 'linkusdCrv',
    },
    coingeckoInfo: {
        id: 'linkusd',
        symbol: 'LINKUSD',
    },
    assets: 'LINKUSD+3pool',
    isMetaPool: true,
    coins: [
        coins.linkusd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    isRiskier: true,
    hasNoGauge: true,
    addresses: {
        swap: '0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171',
        lpToken: '0x6D65b498cb23deAba52db31c93Da9BFFb340FB8F',
        deposit: '0x1de7f0866e2c4adAC7b457c58Cc25c8688CDa1f2',
    },
    riskLevel: 3,
}, {
    dataIndex: 16,
    id: 'musd',
    name: 'musd',
    lpTokenInfo: {
        name: 'musdCurve',
        symbol: 'musdCrv',
    },
    coingeckoInfo: {
        id: 'musd',
        symbol: 'MUSD',
    },
    assets: 'musd+3pool',
    isMetaPool: true,
    coins: [
        coins.musd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    oldAdditionalRewards: [{
        name: 'MTA',
        rewardTokenCoingeckoId: 'meta',
    }],
    addresses: {
        swap: '0x8474DdbE98F5aA3179B3B3F5942D724aFcdec9f6',
        lpToken: '0x1AEf73d49Dedc4b1778d0706583995958Dc862e6',
        gauge: '0x5f626c30EC1215f4EdCc9982265E8b1F411D1352',
        deposit: '0x803A2B40c5a9BB2B86DD630B274Fa2A9202874C2',
    },
}, {
    dataIndex: 17,
    id: 'rsv',
    name: 'rsv',
    lpTokenInfo: {
        name: 'rsvCurve',
        symbol: 'rsvCrv',
    },
    coingeckoInfo: {
        id: 'reserve',
        symbol: 'RSV',
    },
    assets: 'rsv+3pool',
    isMetaPool: true,
    coins: [
        coins.rsv,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    additionalRewards: [{
        name: 'RSR',
        amountDataKey: 'rsrRewards',
        rewardTokenCoingeckoId: 'reserve-rights-token',
    }],
    addresses: {
        swap: '0xC18cC39da8b11dA8c3541C598eE022258F9744da',
        lpToken: '0xC2Ee6b0334C261ED60C72f6054450b61B8f18E35',
        gauge: '0x4dC4A289a8E33600D8bD4cf5F6313E43a37adec7',
        deposit: '0xBE175115BF33E12348ff77CcfEE4726866A0Fbd5',
    },
}, {
    dataIndex: 18,
    id: 'tbtc',
    name: 'tbtc',
    lpTokenInfo: {
        name: 'tbtcCurve',
        symbol: 'tbtcCrv',
    },
    coingeckoInfo: {
        id: 'tbtc',
        symbol: 'TBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'tbtc+sbtcCrv',
    isMetaPool: true,
    coins: [
        coins.tbtc,
        coins.sbtccrv,
    ],
    metaCoins: [
        coins.renbtc,
        coins.wbtc,
        coins.sbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    oldAdditionalRewards: [{
        name: 'KEEP',
        rewardTokenCoingeckoId: 'keep-network',
    }],
    addresses: {
        swap: '0xC25099792E9349C7DD09759744ea681C7de2cb66',
        lpToken: '0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd',
        gauge: '0x6828bcF74279eE32f2723eC536c22c51Eed383C6',
        deposit: '0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c',
    },
}, {
    dataIndex: 19,
    id: 'dusd',
    name: 'dusd',
    lpTokenInfo: {
        name: 'dusdCurve',
        symbol: 'dusdCrv',
    },
    coingeckoInfo: {
        id: 'defidollar',
        symbol: 'DUSD',
    },
    assets: 'dusd+3pool',
    isMetaPool: true,
    coins: [
        coins.dusd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    additionalRewards: [{
        name: 'DFD',
        amountDataKey: 'dfdRewards',
        rewardTokenCoingeckoId: 'defidollar-dao',
    }],
    addresses: {
        swap: '0x8038C01A0390a8c547446a0b2c18fc9aEFEcc10c',
        lpToken: '0x3a664Ab939FD8482048609f652f9a0B0677337B9',
        gauge: '0xAEA6c312f4b3E04D752946d329693F7293bC2e6D',
        deposit: '0x61E10659fe3aa93d036d099405224E4Ac24996d0',
    },
}, {
    dataIndex: 20,
    id: 'pbtc',
    name: 'pbtc',
    lpTokenInfo: {
        name: 'pbtcCurve',
        symbol: 'pbtcCrv',
    },
    coingeckoInfo: {
        id: 'ptokens-btc',
        symbol: 'PBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'pbtc+sbtcCrv',
    isMetaPool: true,
    coins: [
        coins.pbtc,
        coins.sbtccrv,
    ],
    metaCoins: [
        coins.renbtc,
        coins.wbtc,
        coins.sbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    additionalRewards: [{
        name: 'PNT',
        amountDataKey: 'pntRewards',
        rewardTokenAddress: '0x89Ab32156e46F46D02ade3FEcbe5Fc4243B9AAeD',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'pnetwork',
    }],
    addresses: {
        swap: '0x7F55DDe206dbAD629C080068923b36fe9D6bDBeF',
        lpToken: '0xDE5331AC4B3630f94853Ff322B66407e0D6331E8',
        gauge: '0xd7d147c6Bb90A718c3De8C0568F9B560C79fa416',
        deposit: '0x11F419AdAbbFF8d595E7d5b223eee3863Bb3902C',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 21,
    id: 'bbtc',
    name: 'bbtc',
    lpTokenInfo: {
        name: 'bbtcCurve',
        symbol: 'bbtcCrv',
    },
    coingeckoInfo: {
        referenceAssetId: 'bitcoin',
    },
    assets: 'bbtc+sbtcCrv',
    isMetaPool: true,
    coins: [
        coins.bbtc,
        coins.sbtccrv,
    ],
    metaCoins: [
        coins.renbtc,
        coins.wbtc,
        coins.sbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    addresses: {
        swap: '0x071c661B4DeefB59E2a3DdB20Db036821eeE8F4b',
        lpToken: '0x410e3E86ef427e30B9235497143881f717d93c2A',
        gauge: '0xdFc7AdFa664b08767b735dE28f9E84cd30492aeE',
        deposit: '0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 22,
    id: 'obtc',
    name: 'obtc',
    lpTokenInfo: {
        name: 'obtcCurve',
        symbol: 'obtcCrv',
    },
    coingeckoInfo: {
        id: 'boringdao-btc',
        symbol: 'OBTC',
        referenceAssetId: 'bitcoin',
    },
    assets: 'obtc+sbtcCrv',
    isMetaPool: true,
    coins: [
        coins.obtc,
        coins.sbtccrv,
    ],
    metaCoins: [
        coins.renbtc,
        coins.wbtc,
        coins.sbtc,
    ],
    referenceAsset: REFERENCE_ASSETS.BTC,
    additionalRewards: [{
        name: 'BOR',
        amountDataKey: 'borRewards',
        rewardTokenAddress: '0x3c9d6c1C73b31c837832c72E04D3152f051fc1A9',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'boringdao',
    }],
    addresses: {
        swap: '0xd81dA8D904b52208541Bade1bD6595D8a251F8dd',
        lpToken: '0x2fE94ea3d5d4a175184081439753DE15AeF9d614',
        gauge: '0x11137B10C210b579405c21A07489e28F3c040AB1',
        deposit: '0xd5BCf53e2C81e1991570f33Fa881c49EEa570C8D',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 23,
    id: 'ust',
    name: 'ust',
    lpTokenInfo: {
        name: 'ustCurve',
        symbol: 'ustCrv',
    },
    coingeckoInfo: {
        id: 'terrausd',
        symbol: 'UST',
    },
    assets: 'ust+3pool',
    isMetaPool: true,
    coins: [
        coins.ust,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x890f4e345B1dAED0367A877a1612f86A1f86985f',
        lpToken: '0x94e131324b6054c0D789b190b2dAC504e4361b53',
        gauge: '0x3B7020743Bc2A4ca9EaF9D0722d42E20d6935855',
        deposit: '0xB0a0716841F2Fc03fbA72A891B8Bb13584F52F2d',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 24,
    id: 'eurs',
    name: 'eurs',
    lpTokenInfo: {
        name: 'eursCurve',
        symbol: 'eursCrv',
    },
    coingeckoInfo: {
        id: 'stasis-eurs',
        symbol: 'EURS',
        referenceAssetId: 'stasis-eurs', // Using stasis-eurs as the oracle for EUR/USD
    },
    assets: 'eurs+seur',
    coins: [
        coins.eurs,
        coins.seur,
    ],
    referenceAsset: REFERENCE_ASSETS.EUR,
    oldAdditionalRewards: [{
        name: 'SNX',
        rewardTokenAddress: '0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'havven',
    }],
    addresses: {
        swap: '0x0Ce6a5fF5217e38315f87032CF90686C96627CAA',
        lpToken: '0x194eBd173F6cDacE046C53eACcE9B953F28411d1',
        gauge: '0x90Bb609649E0451E5aD952683D64BD2d1f245840',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 25,
    id: 'seth',
    name: 'seth',
    lpTokenInfo: {
        name: 'sethCurve',
        symbol: 'eCrv',
    },
    coingeckoInfo: {
        id: 'seth',
        symbol: 'SETH',
        referenceAssetId: 'ethereum',
    },
    assets: 'eth+seth',
    coins: [
        coins.eth,
        coins.seth,
    ],
    referenceAsset: REFERENCE_ASSETS.ETH,
    addresses: {
        swap: '0xc5424b857f758e906013f3555dad202e4bdb4567',
        lpToken: '0xA3D87FffcE63B53E0d54fAa1cc983B7eB0b74A9c',
        gauge: '0x3C0FFFF15EA30C35d7A85B85c0782D6c94e1d238',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 26,
    id: 'aave',
    name: 'aave',
    lpTokenInfo: {
        name: 'aaveCurve',
        symbol: 'a3Crv',
    },
    coingeckoInfo: {
        id: 'aave',
        symbol: 'AAVE',
    },
    assets: 'aDAI+aUSDC+aUSDT',
    coins: [
        coins.adai,
        coins.ausdc,
        coins.ausdt,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    isLendingPool: true,
    isModernLendingPool: true,
    addresses: {
        swap: '0xDeBF20617708857ebe4F679508E7b7863a8A8EeE',
        lpToken: '0xFd2a8fA60Abd58Efe3EeE34dd494cD491dC14900',
        gauge: '0xd662908ADA2Ea1916B3318327A97eB18aD588b5d',
    },
    gaugeVersion: 2,
    additionalRewards: [{
        name: 'STKAAVE',
        amountDataKey: 'aaveRewards',
        rewardTokenAddress: '0x4da27a545c0c5b758a6ba100e3a049001de870f5',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'aave',
    }],
}, {
    dataIndex: 27,
    id: 'steth',
    name: 'steth',
    lpTokenInfo: {
        name: 'stethCurve',
        symbol: 'stethCrv',
    },
    coingeckoInfo: {
        id: 'staked-ether',
        symbol: 'STETH',
        referenceAssetId: 'ethereum',
    },
    assets: 'eth+steth',
    coins: [
        coins.eth,
        coins.steth,
    ],
    referenceAsset: REFERENCE_ASSETS.ETH,
    additionalRewards: [{
        name: 'LDO',
        amountDataKey: 'ldoRewards',
        rewardTokenAddress: '0x5a98fcbea516cf06857215779fd812ca3bef1b32',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'lido-dao',
    }],
    addresses: {
        swap: '0xDC24316b9AE028F1497c275EB9192a3Ea0f67022',
        lpToken: '0x06325440D014e39736583c165C2963BA99fAf14E',
        gauge: '0x182B723a58739a9c974cFDB385ceaDb237453c28',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 28,
    id: 'saave',
    name: 'saave',
    lpTokenInfo: {
        name: 'saaveCurve',
        symbol: 'saCrv',
    },
    coingeckoInfo: {
        id: 'aave',
        symbol: 'AAVE',
    },
    assets: 'aDAI+asUSD',
    coins: [
        coins.adai,
        coins.asusd,
    ],
    underlyingCoins: [
        coins.dai,
        coins.susd,
    ],
    isLendingPool: true,
    isModernLendingPool: true,
    addresses: {
        swap: '0xEB16Ae0052ed37f479f7fe63849198Df1765a733',
        lpToken: '0x02d341CcB60fAaf662bC0554d13778015d1b285C',
        gauge: '0x462253b8F74B72304c145DB0e4Eebd326B22ca39',
    },
    gaugeVersion: 2,
    additionalRewards: [{
        key: 'STKAAVES',
        name: 'STKAAVE',
        amountDataKey: 'saaveRewards',
        rewardTokenAddress: '0x4da27a545c0c5b758a6ba100e3a049001de870f5',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'aave',
    }],
}, {
    dataIndex: 29,
    id: 'ankreth',
    name: 'ankreth',
    lpTokenInfo: {
        name: 'ankrethCurve',
        symbol: 'aethCrv',
    },
    coingeckoInfo: {
        id: 'ankreth',
        symbol: 'AETH',
        referenceAssetId: 'ethereum',
    },
    assets: 'eth+ankreth',
    coins: [
        coins.eth,
        coins.ankreth,
    ],
    referenceAsset: REFERENCE_ASSETS.ETH,
    additionalRewards: [{
        name: 'ANKR',
        amountDataKey: 'ankrRewards',
        rewardTokenAddress: '0x8290333cef9e6d528dd5618fb97a76f268f3edd4',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'ankr',
    }, {
        name: 'ONX',
        amountDataKey: 'onxRewards',
        rewardTokenAddress: '0xe0ad1806fd3e7edf6ff52fdb822432e847411033',
        rewardTokenDecimals: 18,
        rewardTokenCoingeckoId: 'onx-finance',
    }],
    addresses: {
        swap: '0xA96A65c051bF88B4095Ee1f2451C2A9d43F53Ae2',
        lpToken: '0xaA17A236F2bAdc98DDc0Cf999AbB47D47Fc0A6Cf',
        gauge: '0x6d10ed2cf043e6fcf51a0e7b4c2af3fa06695707',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 30,
    id: 'usdp',
    name: 'usdp',
    lpTokenInfo: {
        name: 'usdpCurve',
        symbol: 'usdpCrv',
    },
    coingeckoInfo: {
        id: 'usdp',
        symbol: 'USDP',
    },
    assets: 'usdp+3pool',
    isMetaPool: true,
    coins: [
        coins.usdp,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0x42d7025938bEc20B69cBae5A77421082407f053A',
        lpToken: '0x7Eb40E450b9655f4B3cC4259BCC731c63ff55ae6',
        gauge: '0x055be5DDB7A925BfEF3417FC157f53CA77cA7222',
        deposit: '0x3c8cAee4E09296800f8D29A68Fa3837e2dae4940',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 31,
    id: 'ib',
    name: 'ironbank',
    lpTokenInfo: {
        name: 'ibCurve',
        symbol: 'ib3Crv',
    },
    coingeckoInfo: {
        id: 'cream-2',
        symbol: 'CREAM',
    },
    assets: 'cyDAI+cyUSDC+cyUSDT',
    coins: [
        coins.cydai,
        coins.cyusdc,
        coins.cyusdt,
    ],
    underlyingCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    isLendingPool: true,
    isModernLendingPool: true,
    addresses: {
        swap: '0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF',
        lpToken: '0x5282a4eF67D9C33135340fB3289cc1711c13638C',
        gauge: '0xF5194c3325202F456c95c1Cf0cA36f8475C1949F',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 32,
    id: 'link',
    name: 'link',
    lpTokenInfo: {
        name: 'linkCurve',
        symbol: 'linkCrv',
    },
    coingeckoInfo: {
        id: 'chainlink',
        symbol: 'LINK',
        referenceAssetId: 'chainlink',
    },
    referenceAsset: REFERENCE_ASSETS.LINK,
    assets: 'LINK+sLINK',
    coins: [
        coins.link,
        coins.slink,
    ],
    addresses: {
        swap: '0xF178C0b5Bb7e7aBF4e12A4838C7b7c5bA2C623c0',
        lpToken: '0xcee60cfa923170e4f8204ae08b4fa6a3f5656f3a',
        gauge: '0xfd4d8a17df4c27c1dd245d153ccf4499e806c87d',
    },
    gaugeVersion: 2,
}, {
    dataIndex: 33,
    id: 'tusd',
    name: 'tusd',
    lpTokenInfo: {
        name: 'tusdCurve',
        symbol: 'tusdCrv',
    },
    assets: 'tusd+3pool',
    isMetaPool: true,
    coins: [
        coins.tusd,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0xecd5e75afb02efa118af914515d6521aabd189f1',
        lpToken: '0xecd5e75afb02efa118af914515d6521aabd189f1',
        gauge: '0x359FD5d6417aE3D8D6497d9B2e7A890798262BA4',
        deposit: '0xA79828DF1850E8a3A3064576f380D90aECDD3359',
    },
    gaugeVersion: 2,
},{
    dataIndex: 34,
    id: 'frax',
    name: 'frax',
    lpTokenInfo: {
        name: 'fraxCurve',
        symbol: 'fraxCrv',
    },
    coingeckoInfo: {
        id: 'frax',
        symbol: 'FRAX',
    },
    assets: 'frax+3pool',
    isMetaPool: true,
    coins: [
        coins.frax,
        coins.tricrv,
    ],
    metaCoins: [
        coins.dai,
        coins.usdc,
        coins.usdt,
    ],
    addresses: {
        swap: '0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B',
        lpToken: '0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B',
        deposit: '0xA79828DF1850E8a3A3064576f380D90aECDD3359',
        gauge: '0x72e158d38dbd50a483501c24f792bdaaa3e7d55c'
    },
    isRiskier: true,
    riskLevel: 2,
  },{
      dataIndex: 35,
      id: 'lusd',
      name: 'lusd',
      lpTokenInfo: {
          name: 'lusdCurve',
          symbol: 'lusdCrv',
      },
      coingeckoInfo: {
          id: 'liquity-usd',
          symbol: 'LUSD',
      },
      assets: 'lusd+3pool',
      isMetaPool: true,
      coins: [
          coins.lusd,
          coins.tricrv,
      ],
      metaCoins: [
          coins.dai,
          coins.usdc,
          coins.usdt,
      ],
      addresses: {
          swap: '0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA',
          lpToken: '0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA',
          deposit: '0xA79828DF1850E8a3A3064576f380D90aECDD3359',
          gauge: '0x9b8519a9a00100720ccdc8a120fbed319ca47a14'
      },
      additionalRewards: [{
          name: 'LQTY',
          amountDataKey: 'lqtyRewards',
          rewardTokenCoingeckoId: 'liquity',
          rewardTokenAddress: '0x6dea81c8171d0ba574754ef6f8b412f2ed88c54d',
          rewardTokenDecimals: 18,
      }],
      gaugeVersion: 2,
    },{
        dataIndex: 36,
        id: 'busdv2',
        name: 'busdv2',
        lpTokenInfo: {
            name: 'busdCurve',
            symbol: 'busdCrv',
        },
        coingeckoInfo: {
            id: 'binance-usd',
            symbol: 'BUSD',
        },
        assets: 'busd+3pool',
        isMetaPool: true,
        coins: [
            coins.busd,
            coins.tricrv,
        ],
        metaCoins: [
            coins.dai,
            coins.usdc,
            coins.usdt,
        ],
        addresses: {
            swap: '0x4807862AA8b2bF68830e4C8dc86D0e9A998e085a',
            lpToken: '0x4807862AA8b2bF68830e4C8dc86D0e9A998e085a',
            gauge: '0xd4b22fedca85e684919955061fdf353b9d38389b',
            deposit: '0xA79828DF1850E8a3A3064576f380D90aECDD3359',
        },
        gaugeVersion: 2,
      },{
          dataIndex: 37,
          id: 'tricrypto',
          name: 'TriCrypto',
          lpTokenInfo: {
              name: '3CrvCrypto',
              symbol: '3CrvCrypto',
          },
          assets: 'usdt+weth+wbtc',
          coins: [
              coins.usdt,
              coins.wbtc,
              coins.weth,
          ],
          addresses: {
              swap: '0x80466c64868E1ab14a1Ddf27A676C3fcBE638Fe5',
              lpToken: '0xcA3d75aC011BF5aD07a98d02f18225F9bD9A6BDF',
          },
          gaugeVersion: 2,
          hasNoGauge: true,
          cryptoPool: true
        },{
        dataIndex: 38,
        id: 'alusd',
        name: 'alisd',
        lpTokenInfo: {
            name: 'alusdCurve',
            symbol: 'alusdCrv',
        },
        coingeckoInfo: {
            id: 'alchemix-usd',
            symbol: 'ALUSD',
        },
        assets: 'alusd+3pool',
        isMetaPool: true,
        coins: [
            coins.alusd,
            coins.tricrv,
        ],
        metaCoins: [
            coins.dai,
            coins.usdc,
            coins.usdt,
        ],
        addresses: {
            swap: '0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c',
            lpToken: '0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c',
            gauge: '0x9582C4ADACB3BCE56Fea3e590F05c3ca2fb9C477',
            deposit: '0xA79828DF1850E8a3A3064576f380D90aECDD3359',
        },
        gaugeVersion: 2,
      }, {
        dataIndex: 39,
        id: 'reth',
        name: 'reth',
        lpTokenInfo: {
            name: 'rethCurve',
            symbol: 'rethCrv',
        },
        coingeckoInfo: {
            id: 'reth',
            symbol: 'RETH',
            referenceAssetId: 'ethereum',
        },
        assets: 'eth+reth',
        coins: [
            coins.eth,
            coins.reth,
        ],
        referenceAsset: REFERENCE_ASSETS.ETH,
        additionalRewards: [{
            name: 'FIS',
            amountDataKey: 'rethRewards',
            rewardTokenAddress: '0xef3A930e1FfFFAcd2fc13434aC81bD278B0ecC8d',
            rewardTokenDecimals: 18,
            rewardTokenCoingeckoId: 'stafi',
        }],
        addresses: {
            swap: '0xF9440930043eb3997fc70e1339dBb11F341de7A8',
            lpToken: '0x53a901d48795C58f485cBB38df08FA96a24669D5',
            gauge: '0x824F13f1a2F29cFEEa81154b46C0fc820677A637',
        },
        gaugeVersion: 2,
    }

    ];

'''
'''--- projects/cookfinance/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking.js");
const { pool2, pool2s } = require("../helper/pool2");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs.js");
const yieldyakAbi = require("./yieldyakAbi.json");
const alpacaFinanceAbi = require("../alpaca-finance/abi.json");
const venusFinanceAbi = require("./venusFinanceAbi.json");
const BigNumber = require("bignumber.js");

const stakingContractHeco = "0xF0979F9692966D110E39d82a44655c9934F5cC73";
const COOK_heco = "0x74189862b069e2be5f7c8e6ff08ea8e1b1948519";

const stakingPool2ContractHeco = "0x275FC87A40222977E4E28Fd846e8CB9d80Add258";
const ETH_COOK_HMDXLP = "0x9275637737b56004312E50be0eaB20b7A20eAF3a";

const cookToken = "0xFF75CEd57419bcaEBe5F05254983b013B0646eF5";
const stakingPool = "0xcAFb07CCB524C957c835Be287f75c6F92db79CA3";

const vBNB = "0xA07c5b74C9B40447a954e1466938b865b6BBea36";
const wBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";

const ethPool2LPs = [
  "0xbdfe29d9e42ea541c581eef6cf3a2bb27b51e2c4", // COOK-ETH
];

const bscPool2LPs = [
  "0x48E29cacd1186A3264E9cfBaAc632c5Cb1F2df60", // COOK-BNB
];

const avaxPool2LPs = [
  "0x3fcd1d5450e63fa6af495a601e6ea1230f01c4e3", // Trader Joe COOK-WAVAX
  "0xf7ff4fb01c3c1ab0128a79953cd8b47526292fb2", // Pangolin COOK-WAVAX
];

const ethIndexes = [
  "0xA6156492fC79616035F644C71b01e3099819F8EC", // CLI
  "0x43633bDb2675aDaB99CE3059D734b92a1deDAb2b", // EDI
];

const alpacaComponents = new Set([
  "0xbfF4a34A4644a113E8200D7F1D79b3555f723AfE",
  "0x08FC9Ba2cAc74742177e0afC3dC8Aed6961c24e7",
  "0x7C9e73d4C71dae564d41F78d56439bB4ba87592f",
  "0x158Da805682BdC8ee32d52833aD41E74bb951E59",
  "0x800933D685E7Dc753758cEb77C8bd34aBF1E26d7",
  "0xd7D069493685A581d27824Fc46EdA46B7EfC0063"
]);

const venusComponents = new Set([
  "0x95c78222B3D6e262426483D42CfA53685A67Ab9D",
  "0xA07c5b74C9B40447a954e1466938b865b6BBea36"
]);

async function ethTvl(timestamp, block) {
  let balances = {};

  for (let i = 0; i < ethIndexes.length; i++) {
    let { output: components } = await sdk.api.abi.call({
      target: ethIndexes[i],
      abi: {
        inputs: [],
        name: "getComponents",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "view",
        type: "function",
      },
      block,
    });

    for (let j = 0; j < components.length; j++) {
      let { output: balance } = await sdk.api.erc20.balanceOf({
        target: components[j],
        owner: ethIndexes[i],
        block,
      });
      sdk.util.sumSingleBalance(balances, components[j], balance);
    }
  }

  return balances;
}

async function avaTvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.avax;
  const CONTROLLER_ADDRESS = "0xE565711e7a59800e110c959E156121988E6F4704";
  let balances = {};
  let { output: avaIndexes } = await sdk.api.abi.call({
    target: CONTROLLER_ADDRESS,
    abi: {
      inputs: [],
      name: "getCKs",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
    },
    chain: "avax",
    block,
  });
  for (let i = 0; i < avaIndexes.length; i++) {
    let { output: components } = await sdk.api.abi.call({
      target: avaIndexes[i],
      abi: {
        inputs: [],
        name: "getComponents",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "view",
        type: "function",
      },
      chain: "avax",
      block,
    });
    for (let j = 0; j < components.length; j++) {
      let { output: balance } = await sdk.api.erc20.balanceOf({
        target: components[j],
        owner: avaIndexes[i],
        chain: "avax",
        block,
      });
      let { output: symbol } = await sdk.api.erc20.symbol(
        components[j],
        "avax"
      );
      if (symbol === "YRT") {
        let { output: underlyingToken } = await sdk.api.abi.call({
          target: components[j],
          block,
          chain: "avax",
          abi: yieldyakAbi.depositToken,
        });
        if (underlyingToken === '0x0000000000000000000000000000000000000000') {
          // set underlyingToken to WAVAX whenever yieldYakVault.depositToken returns zero_address
          underlyingToken = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7'
        }
        let { output: underlyingTokenBalance } = await sdk.api.abi.call({
          target: components[j],
          block,
          params: [balance],
          chain: "avax",
          abi: yieldyakAbi.getDepositTokensForShares,
        });
        sdk.util.sumSingleBalance(
          balances,
          "avax:" + underlyingToken,
          underlyingTokenBalance
        );
      } else {
        sdk.util.sumSingleBalance(balances, "avax:" + components[j], balance);
      }
    }
  }
  return balances;
}

async function alpacaUnderlyingTokenAndBalance(component, componentBalance, block) {
  let { output: underlyingToken } = await sdk.api.abi.call({
    target: component,
    block,
    chain: "bsc",
    abi: alpacaFinanceAbi.token,
  });
  let {output: underlyingTokenTotalSupply} = await sdk.api.abi.call({
    target: component,
    block,
    chain: "bsc",
    abi: alpacaFinanceAbi.totalToken,
  });
  let {output: ibTokenTotalSupply} = await sdk.api.abi.call({
    target: component,
    block,
    chain: "bsc",
    abi: alpacaFinanceAbi.totalSupply,
  });
  componentBalance = new BigNumber(componentBalance);
  underlyingTokenTotalSupply = new BigNumber(underlyingTokenTotalSupply);
  ibTokenTotalSupply = new BigNumber(ibTokenTotalSupply);
  const underlyingTokenBalance = componentBalance.times(underlyingTokenTotalSupply).idiv(ibTokenTotalSupply).toNumber();
  return {
    'underlyingToken': underlyingToken,
    'underlyingTokenBalance': underlyingTokenBalance
  }
}

async function venusUnderlyingTokenAndBalance(component, componentBalance, block) {
  let underlyingToken;
  if (component === vBNB) {
    // set underlyingToken to WAVAX whenever yieldYakVault.depositToken returns zero_address
    underlyingToken = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'
  } else {
    let { output: underlyingTokenData } = await sdk.api.abi.call({
      target: component,
      block,
      chain: "bsc",
      abi: venusFinanceAbi.underlying,
    });
    underlyingToken = underlyingTokenData;
  }

  let {output: exchangeRateStored} = await sdk.api.abi.call({
    target: component,
    block,
    chain: "bsc",
    abi: venusFinanceAbi.exchangeRateStored,
  });
  componentBalance = new BigNumber(componentBalance);
  exchangeRateStored = new BigNumber(exchangeRateStored);
  const underlyingTokenBalance = componentBalance.times(exchangeRateStored).idiv(new BigNumber('1e+18')).toNumber();
  return {
    'underlyingToken': underlyingToken,
    'underlyingTokenBalance': underlyingTokenBalance
  }
}

async function bscTvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.bsc;
  const CONTROLLER_ADDRESS = "0x822aeB433A4Ea7A97b76287cB513C3985034a2Bd";
  let balances = {};
  let { output: bscIndexes } = await sdk.api.abi.call({
    target: CONTROLLER_ADDRESS,
    abi: {
      inputs: [],
      name: "getCKs",
      outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
      stateMutability: "view",
      type: "function",
    },
    chain: "bsc",
    block,
  });
  for (let i = 0; i < bscIndexes.length; i++) {
    let { output: components } = await sdk.api.abi.call({
      target: bscIndexes[i],
      abi: {
        inputs: [],
        name: "getComponents",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "view",
        type: "function",
      },
      chain: "bsc",
      block,
    });
    for (let j = 0; j < components.length; j++) {
      let { output: componentBalance } = await sdk.api.erc20.balanceOf({
        target: components[j],
        owner: bscIndexes[i],
        chain: "bsc",
        block,
      });
      if (alpacaComponents.has(components[j])) {
        const res = await alpacaUnderlyingTokenAndBalance(components[j], componentBalance, block)
        sdk.util.sumSingleBalance(
          balances,
          "bsc:" + res.underlyingToken,
          res.underlyingTokenBalance
        );
      } else if (venusComponents.has(components[j])) {
        const res = await venusUnderlyingTokenAndBalance(components[j], componentBalance, block)
        sdk.util.sumSingleBalance(
          balances,
          "bsc:" + res.underlyingToken,
          res.underlyingTokenBalance
        );
      } else {
        sdk.util.sumSingleBalance(balances, "bsc:" + components[j], componentBalance);
      }
    }
  }
  return balances;
}

module.exports = {
  methodology:
    "TVL are the tokens locked into the index contracts. Pool2 are the tokens locked into DEX LP. Staking are the tokens locked into the active staking contract.",
  ethereum: {
    tvl: ethTvl,
    pool2: pool2s(
      ["0x4b21da40dd8d9f4363e69a9a1620d7cdb49123be"],
      ethPool2LPs,
      "ethereum"
    ),
    staking: staking(stakingPool, cookToken),
  },
  avalanche: {
    tvl: avaTvl,
    pool2: pool2s(["0x35be7982bc5e40a8c9af39a639bddce32081102e", "0x188bED1968b795d5c9022F6a0bb5931Ac4c18F00"], avaxPool2LPs, "avax"),
    staking: staking(
      "0x35bE7982bC5E40A8C9aF39A639bDDcE32081102e",
      "0x637afeff75ca669ff92e4570b14d6399a658902f",
      "avax",
      //"avax:0x637afeff75ca669ff92e4570b14d6399a658902f"
    ),
  },
  bsc: {
    pool2: pool2s(
      ["0x47b517061841e6bFaaeB6336C939724F47e5E263"],
      bscPool2LPs,
      "bsc"
    ),
    staking: staking(
      "0x1Abeaa9D633162586a4c80389160c33327C9Aff5",
      "0x965b0df5bda0e7a0649324d78f03d5f7f2de086a",
      "bsc"
    ),
    tvl: bscTvl,
  },
  heco: {
    staking: staking(stakingContractHeco, COOK_heco, "heco"),
    pool2: pool2(stakingPool2ContractHeco, ETH_COOK_HMDXLP, "heco"),
  },
};

'''
'''--- projects/cookfinance/venusFinanceAbi.json ---
{
  "underlying": {
    "constant":true,
    "inputs":[

    ],
    "name":"underlying",
    "outputs":[
      {
        "internalType":"address",
        "name":"",
        "type":"address"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "exchangeRateStored": {
    "constant":true,
    "inputs":[

    ],
    "name":"exchangeRateStored",
    "outputs":[
      {
        "internalType":"uint256",
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  }
}

'''
'''--- projects/cookfinance/yieldyakAbi.json ---
{
  "depositToken": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [
      { "type": "address", "name": "", "internalType": "contract IERC20" }
    ],
    "name": "depositToken",
    "inputs": []
  },
  "getDepositTokensForShares": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }],
    "name": "getDepositTokensForShares",
    "inputs": [
      { "type": "uint256", "name": "amount", "internalType": "uint256" }
    ]
  }
}

'''
'''--- projects/core/abis/erc95/getTokenInfo.json ---
{
    "inputs": [
        {
            "internalType": "uint256",
            "name": "_id",
            "type": "uint256"
        }
    ],
    "name": "getTokenInfo",
    "outputs": [
        {
            "internalType": "address",
            "name": "address",
            "type": "address"
        },
        {
            "internalType": "uint256",
            "name": "reserve",
            "type": "uint256"
        },
        {
            "internalType": "uint256",
            "name": "amountWrapperPerUnit",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}
'''
'''--- projects/core/abis/erc95/numTokensWrapped.json ---
{
    "inputs": [],
    "name": "_numTokensWrapped",
    "outputs": [
        {
            "internalType": "uint8",
            "name": "",
            "type": "uint8"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}
'''
'''--- projects/core/abis/uniswap/getReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
    {
      "internalType": "uint112",
      "name": "reserve0",
      "type": "uint112"
    },
    {
      "internalType": "uint112",
      "name": "reserve1",
      "type": "uint112"
    },
    {
      "internalType": "uint32",
      "name": "blockTimestampLast",
      "type": "uint32"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/core/abis/uniswap/token0.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token0",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/core/abis/uniswap/token1.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token1",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/core/index.js ---

const sdk = require('@defillama/sdk');
const BigNumber = require("bignumber.js");
const getReserves = require('./abis/uniswap/getReserves.json');
const token0 = require('./abis/uniswap/token0.json');
const token1 = require('./abis/uniswap/token1.json');
const numTokensWrapped = require('./abis/erc95/numTokensWrapped.json');
const getTokenInfo = require('./abis/erc95/getTokenInfo.json');

const zero = new BigNumber(0);

const configs = {
  pairAddresses: [
    '0x32Ce7e48debdccbFE0CD037Cc89526E4382cb81b', // CORE/WETH
    '0x6fad7D44640c5cd0120DEeC0301e8cf850BecB68', // CORE/cBTC
    '0x01AC08E821185b6d87E68c67F9dc79A8988688EB', // coreDAI/wCORE
  ],
  erc95TokenAddresses: [
    '0x7b5982dcAB054C377517759d0D2a3a5D02615AB8', // cBTC
    '0x00a66189143279b6DB9b77294688F47959F37642', // coreDAI,
    '0x17B8c1A92B66b1CF3092C5d223Cb3a129023b669', // wCORE
  ],
}

/**
 * Retrieve all the Uniswap pair information.
 * 
 * @param {[String]} pairAddresses The uniswap pair addresses
 * @param {any} timestamp 
 * @param {any} block 
 * @returns {Promise<[{ token0: String,  token1: String, reserve0: String, reserve1: String }]>}
 */
async function getUniswapPairInfo(pairAddresses, timestamp, block) {
  const [token0Addresses, token1Addresses, reserves, totalSupplies] = await Promise.all([
    sdk.api.abi.multiCall({
      abi: token0,
      calls: pairAddresses.map((pairAddress) => ({
        target: pairAddress,
      })),
      block,
    })
      .then(({ output }) => output.map(value => value.output)),
    sdk.api.abi.multiCall({
      abi: token1,
      calls: pairAddresses.map((pairAddress) => ({
        target: pairAddress,
      })),
      block,
    })
      .then(({ output }) => output.map(value => value.output)),
    sdk.api.abi.multiCall({
      abi: getReserves,
      calls: pairAddresses.map((pairAddress) => ({
        target: pairAddress,
      })),
      block,
    })
      .then(({ output }) => output.map(value => value.output)),
    sdk.api.abi.multiCall({
      block,
      calls: pairAddresses.map(pairAddress => ({
        target: pairAddress
      })),
      abi: 'erc20:totalSupply',
    }).then(({ output }) => output.map(value => value.output))
  ]);
  return pairAddresses.map((_value, index) => {
    return {
      reserve0: reserves[index] ? reserves[index]['reserve0'] : null,
      reserve1: reserves[index] ? reserves[index]['reserve1'] : null,
      token0: token0Addresses[index],
      token1: token1Addresses[index],
      totalSupply: totalSupplies[index],
    }
  })
}

/**
 * Retrieve the underlying reserve of each token within a pair.
 * 
 * @param {{ token0: String, token1: String, reserve0: String, reserve1: String }} pairInfo Contains the information about a pair.
 * @param {any} timestamp 
 * @param {any} block
 * @returns {Promise<{ [String]: BigNumber }>}
 */
async function getPairUnderlyingReserves(pairInfo, timestamp, block) {
  return Promise.all([
    getTokenUnderlyingReserves(pairInfo.token0, pairInfo.reserve0, timestamp, block),
    getTokenUnderlyingReserves(pairInfo.token1, pairInfo.reserve1, timestamp, block)
  ]);
};

/**
 * Retrieve the token reserve and if it's an ERC95 token, retrieve
 * each underlying assets reserves.
 * 
 * @param {String} token Token address
 * @param {String} defaultReserve Default reserve amount to use when not a ERC95 token
 * @param {any} timestamp 
 * @param {any} block
 * @returns {Promise<{ [String]: BigNumber }>}
 */
async function getTokenUnderlyingReserves(token, defaultReserve, _timestamp, block) {
  if (configs.erc95TokenAddresses.indexOf(token) === -1) {
    return [{ [token]: defaultReserve }];
  }

  const numTokensWrappedResponse = await sdk.api.abi.call({
    target: token,
    abi: numTokensWrapped,
    block
  });

  const wrappedTokenCount = parseInt(numTokensWrappedResponse.output);
  const getTokenInfoCalls = []
  for (let i = 0;i < wrappedTokenCount; i++)
    getTokenInfoCalls.push({
      target: token,
      params: [i],
      abi: getTokenInfo,
      block
    })

  const tokenInfoResponse = await sdk.api.abi.multiCall({
    block,
    calls: getTokenInfoCalls,
    abi: getTokenInfo,
  });

  const reserves = tokenInfoResponse.output.map(info => ({
    [info.output.address]: info.output.reserve
  }));

  return reserves;
};

/**
 * Flatten and merge common underlying assets with their reserve sum.
 *
 * @param {[{[String]: BigNumber}]} underlyingReserves 
 * @returns {{[String]: [String]}} An object of the token address and its reserve.
 */
function flattenUnderlyingReserves(underlyingReserves) {
  const reserves = {};

  underlyingReserves.forEach(pairReserves => {
    pairReserves.forEach(tokenReserves => {
      tokenReserves.forEach(underlyingReserves => {
        Object.keys(underlyingReserves).forEach(address => {
          const tokenReserve = new BigNumber(underlyingReserves[address]);
          reserves[address] = (reserves[address] || zero).plus(tokenReserve);
        });
      });
    });
  });

  Object.keys(reserves).forEach(address => {
    reserves[address] = reserves[address].toFixed();
  });

  return reserves;
}

async function tvl(timestamp, block) {
  const pairInfo = await getUniswapPairInfo(configs.pairAddresses, timestamp, block);
  const underlyingReserves = await Promise.all(pairInfo.map(info => getPairUnderlyingReserves(info, timestamp, block)));
  const balances = flattenUnderlyingReserves(underlyingReserves);

  return balances;
}

module.exports = {
  start: 1601142406,    // 2020-09-26 17:46:46 (UTC)
  ethereum: { tvl }
};

'''
'''--- projects/corgiswap.js ---
const { calculateUsdUniTvl } = require('./helper/getUsdUniTvl');
const { stakingPricedLP } = require("./helper/staking");

const factory = "0x632F04bd6c9516246c2df373032ABb14159537cd"

const corisToken = '0x2a2cd8b1f69eb9dda5d703b3498d97080c2f194f'
const masterChef = '0x60E5Cf9111d046E8F986fC98e37d6703607d5Baf'

module.exports = {
  misrepresentedTokens: true,
  methodology: 'TVL accounts for the liquidity on all AMM pools, using the TVL chart on https://corgiswap.info/ as the source. Staking accounts for the CORIS locked in MasterChef (0x60E5Cf9111d046E8F986fC98e37d6703607d5Baf)',
  bsc: {
    tvl: calculateUsdUniTvl(factory, "bsc", "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", [corisToken], "wbnb", 18, true),
    staking: stakingPricedLP(masterChef, corisToken, "bsc", "0x1881bd6aba086da0c5cfed7247f216dea50e38ed", "wbnb", true)
  },
}

'''
'''--- projects/coslend/index.js ---
const { usdCompoundExports } = require("../helper/compound");
module.exports = {
  evmos: usdCompoundExports(
    "0x2C8b48Dc777C26dc857E1040D8ef3Bdd3B1ef499",
    "evmos",
    undefined, undefined, {
      blacklist: [
        '0x269bd2505045947d410582128bc65105d285e66e', // MockToken
      ]
    }
  ),
};

'''
'''--- projects/cotiTreasury.js ---
const axios = require("axios");
const retry = require("./helper/retry");

async function staking() {
  const response = (
    await retry(async (bail) => await axios.get("https://treasury-app.coti.io/get-total"))
  ).data;

  return { 
    'coti': Number(response.totalCotiInPool).toFixed(0),
  };
};

module.exports = {
  timetravel: false,
  coti: {
    tvl: async ()=> ({}),
    staking,
  }
};

'''
'''--- projects/cougarswap/index.js ---
const { masterChefExports } = require("../helper/masterchef");

// --- BSC Addresses ---
const MasterChefContractBsc = "0x8E934F14bD904A46e0C8aF7de6aEeAaaa0D8C2c5";
const CGS_Bsc = "0x26d88b1e61e22da3f1a1ba95a1ba278f6fcef00b";

// --- Polygon Addresses ---
const MasterChefContractPolygon = "0x9bFcf65e7De424a6D89Eef23B3dF8cdc965c654F";
const CGS_Polygon = "0x047fD3B3D2366F9babe105ade4598E263d6c699c";

// --- Fantom Addresses ---
const MasterChefContractFantom = "0x1CA27c8f19EF84F5f5A9cf2E2874E4Bf91fD38C4";
const CGS_Fantom = "0x5a2e451fb1b46fde7718315661013ae1ae68e28c";

// --- Harmony Addresses ---
const MasterChefContractHarmony = "0x1357521115A4dAA6524045215ac7F979e64d6079";
const CGS_Harmony = "0x6cc35220349c444c39b8e26b359757739aaec952";

// --- Avalanche Addresses ---
const MasterChefContractAvax = "0xa127A67D1429B3f8d33a4E0398347661c3737a12";
const CGS_Avax = "0x727C43b707C6Fe3ACD92f17EFAC8e05476DFa81c";

// --- Cronos Addresses ---
const MasterChefContractCronos = "0x07586393ed706e5dBf637195d8cf22F5844F234e";
const CGS_Cronos = "0x4e57e27e4166275Eb7f4966b42A201d76e481B03";

// --- Moonbeam Addresses ---
const MasterChefContractMoonbeam = "0xc5C772e21A39f88f0960172016Cf455Da6fF52Af";
const CGS_Moonbeam = "0x2Dfc76901bB2ac2A5fA5fc479590A490BBB10a5F";

module.exports = {
  misrepresentedTokens: true,
  ...masterChefExports(MasterChefContractBsc, "bsc", CGS_Bsc),
  ...masterChefExports(MasterChefContractPolygon, "polygon", CGS_Polygon),
  ...masterChefExports(MasterChefContractFantom, "fantom", CGS_Fantom),
  ...masterChefExports(MasterChefContractHarmony, "harmony", CGS_Harmony),
  ...masterChefExports(MasterChefContractAvax, "avax", CGS_Avax),
  ...masterChefExports(MasterChefContractCronos, "cronos", CGS_Cronos, false),
  ...masterChefExports(MasterChefContractMoonbeam, "moonbeam", CGS_Moonbeam, false),
  methodology:
    "TVL includes all Farms and Pools seccion through MasterChef Contracts"
};

'''
'''--- projects/coup-farm/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const token = "0xb2f9a4380ebca7e057db0c4572b7ac90c353ce7d";
const masterchef = "0x5b37fE841b505CEa35Fe93A6c080b5930a8155c0";

module.exports = {
    ...masterChefExports(masterchef, "avax", token, false)
}
'''
'''--- projects/cover.js ---
const sdk = require("@defillama/sdk");
const abis = require('./config/cover/cover.js')
const { sumTokens } = require('./helper/unwrapLPs');

async function tvl(ts, block) {

  let factory = '0xedfC81Bf63527337cD2193925f9C0cF2D537AccA';
  const { output: allProtocols } = await sdk.api.abi.call({
    block,
    target: factory,
    abi: abis.abis.protocols.find(i => i.name === 'getAllProtocolAddresses')
  })

  const calls = allProtocols.map(p => ({ target: p }))
  const { output: protocolDetails } = await sdk.api.abi.multiCall({
    block,
    calls,
    abi: abis.abis.cover.find(i => i.name === 'getProtocolDetails')
  })
  const toa = []

  protocolDetails.forEach(({ output }) => {
    output._allCovers.forEach(cover => toa.push(
      ['0x6b175474e89094c44da98b954eedeac495271d0f', cover],  // DAI
      ['0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01', cover],  // yearn DAI
    ))
  })
  return sumTokens({}, toa, block, undefined, undefined, { resolveYearn: true })
}

module.exports = {
  ethereum: {
    tvl
  }
}

'''
'''--- projects/cozy/index.js ---
const {compoundExports} = require('../helper/compound')

const transform = addr=>{
    if(addr==="0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"){
        return "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
    }
    return addr
}

module.exports={
    timetravel: true,
    doublecounted: false,
    methodology: "Count tokens the same way we count for compound",
    ethereum: compoundExports('0x895879b2c1fbb6ccfcd101f2d3f3c76363664f92', "ethereum", undefined, undefined, transform)
}
'''
'''--- projects/crabada/index.js ---
const { staking } = require("../helper/staking");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");

const stakingContract = "0xD2cd7a59Aa8f8FDc68d01b1e8A95747730b927d3";
const CRA = "0xa32608e873f9ddef944b24798db69d80bbb4d1ed";

const treasuryContracts = [
  //mains treasury
  "0x96DD95307295e2f72E6382Fc5130F1A8DB74042C",
  // Breeding fees
  "0x4e57A39Cac2499aBeafd3698F7164eCBFde008eE",
  // Marketplace fees
  "0x49F6fC3f882e2Cd915E38bA377f8e977c11e0F66",
  // Tavern fees
  "0x2BA9033E49EC1aa030fA46DE6d6793983945497E",
];

const lpTokens = [
  [CRA, false],
  ["0xf693248F96Fe03422FEa95aC0aFbBBc4a8FdD172", false], //TUS
  ["0x140CAc5f0e05cBEc857e65353839FddD0D8482C1", true], // WAVAX-CRA JLP
  ["0x565d20BD591b00EAD0C927e4b6D7DD8A33b0B319", true], // WAVAX-TUS JLP
  ["0x21889033414f652f0fD0e0f60a3fc0221d870eE4", true], // CRA-TUS JLP
  ["0x134905461773eF228b66CEBd5E1FF06D7CC79B12", true], // TUS-CRAM JLP
  ["0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664", false] // USDC
];

async function Treasury(timestamp, chainBlocks) {
  const balances = {};

  const transformAddress = await transformAvaxAddress();
  await sumTokensAndLPsSharedOwners(
    balances,
    lpTokens,
    treasuryContracts,
    chainBlocks["avax"],
    "avax",
    transformAddress
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  avax: {
    treasury: Treasury,
    staking: staking(stakingContract, CRA, "avax"),
    tvl: () =>({}),
  },
  methodology:
  "Counts liquidty of the assets(USDC) deposited through Treasury Contract; also Staking and Treasury parts",
};

'''
'''--- projects/crafting/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const contractStakingETH = "0x9353177049757A21f19a28C3055c03871e6428cf";
const ETH = "0x0000000000000000000000000000000000000000";

const contractAddresses = [
  //Staking Contract wbtc
  "0xF70A76AfFD4c368eD16a2593C4D9FAee3562a4Ba",
  //Staking Contract usdt
  "0x321Fd763B8220b5697E41862AcAa41AeB1e2556d",
  //Staking Contract bayc
  "0xF70A76AfFD4c368eD16a2593C4D9FAee3562a4Ba",
];

const tokens = [
  "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D",
];

const contractAddresses_aurora = [
  //Staking Contract aurora
  "0xB0D10De43eb7D6F43e376aA5dA9022A9baB4313C",
  // Staking Contract near
  "0x508df5aa4746bE37b5b6A69684DfD8BDC322219d",
];

const tokens_aurora = [
  "0x8BEc47865aDe3B172A928df8f990Bc7f2A3b9f79",
  "0xC42C30aC6Cc15faC9bD938618BcaA1a1FaE8501d",
];

async function ethTvl(timestamp, block) {
  const balances = {};

  for (let i = 0; i < tokens.length; i++) {
    await sumTokensAndLPsSharedOwners(
      balances,
      [[tokens[i], false]],
      [contractAddresses[i]]
    );
  }

  const ethBal = (
    await sdk.api.eth.getBalance({
      target: contractStakingETH,
      block
    })
  ).output;

  sdk.util.sumSingleBalance(balances, ETH, ethBal);

  return balances;
}

async function auroraTvl(timestamp, block, chainBlocks) {
  const balances = {};

  for (let i = 0; i < tokens_aurora.length; i++) {
    await sumTokensAndLPsSharedOwners(
      balances,
      [[tokens_aurora[i], false]],
      [contractAddresses_aurora[i]],
      chainBlocks["aurora"],
      "aurora",
      (addr) => `aurora:${addr}`
    );
  }

  return balances;
}

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
  aurora: {
    tvl: auroraTvl,
  },
  methodology:
    "Counts tvl of all the Assets staked through Staking Contracts",
};

'''
'''--- projects/cream/cerc20.json ---
{
    "getCash": {
        "constant": true,
        "inputs": [],
        "name": "getCash",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrows": {
        "constant": true,
        "inputs": [],
        "name": "totalBorrows",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "totalReserves": {
        "constant": true,
        "inputs": [],
        "name": "totalReserves",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cream/creth2.json ---
{
    "accumulated": {
        "constant": true,
        "inputs": [],
        "name": "accumulated",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cream/index.js ---
const sdk = require("@defillama/sdk");
const utils = require("../helper/utils");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { getCompoundV2Tvl, compoundExports } = require("../helper/compound");
const {  transformBscAddress } = require('../helper/portedTokens')

const abiCerc20 = require("./cerc20.json");
const abiCereth2 = require("./creth2.json");
const BigNumber = require("bignumber.js");

//
const wETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const CRETH2 = "0xcBc1065255cBc3aB41a6868c22d1f1C573AB89fd";
const crvIB = "0x27b7b1ad7288079A66d12350c828D3C00A6F07d7";

const replacements = {
  "0xe1237aA7f535b0CC33Fd973D66cBf830354D16c7": wETH, // yWETH -> WETH
  //'0x27b7b1ad7288079A66d12350c828D3C00A6F07d7': '0x6b175474e89094c44da98b954eedeac495271d0f', // yearn: yCRV-IB -> DAI
  "0x986b4AFF588a109c09B50A03f42E4110E29D353F": wETH, // yearn: yCRV/sETH
  "0xdCD90C7f6324cfa40d7169ef80b12031770B4325": wETH, // yearn: yCRV/stETH
  "0x9cA85572E6A3EbF24dEDd195623F188735A5179f":
    "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490", // yearn: y3Crv -> 3Crv
};

async function ethereumTvl(timestamp, block) {
  let balances = {};

  let tokens_ethereum = (
    await utils.fetchURL(
      "https://api.cream.finance/api/v1/crtoken?comptroller=eth"
    )
  ).data;

  //  --- Grab all the getCash values of crERC20 (Lending Contract Addresses) ---
  let cashValues = (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens_ethereum.map((token) => ({ target: token.token_address })),
      abi: abiCerc20["getCash"],
    })
  ).output;

  let underlyings = (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens_ethereum.map((token) => ({ target: token.token_address })),
      abi: abiCerc20["underlying"],
    })
  ).output;

  const lpPositions = [];
  cashValues.map((cashVal, idx) => {
    if (underlyings[idx].output === null) {
      // It's ETH
      sdk.util.sumSingleBalance(
        balances,
        "0x0000000000000000000000000000000000000000",
        cashVal.output
      );
    } else if (
      tokens_ethereum[idx].underlying_symbol === "UNI-V2" ||
      tokens_ethereum[idx].underlying_symbol === "SLP"
    ) {
      lpPositions.push({
        token: underlyings[idx].output,
        balance: cashVal.output,
      });
    } else if (underlyings[idx].output === crvIB) {
      return; // https://twitter.com/0xngmi/status/1398565590856515585
    } else {
      const token =
        replacements[underlyings[idx].output] || underlyings[idx].output;
      sdk.util.sumSingleBalance(balances, token, cashVal.output);
    }
  });
  await unwrapUniswapLPs(balances, lpPositions, block);

  // --- Grab the accumulated on CRETH2 (ETH balance and update proper balances key) ---
  const accumCRETH2 = (
    await sdk.api.abi.call({
      block,
      target: CRETH2,
      abi: abiCereth2["accumulated"],
    })
  ).output;

  /* 
    In theory the ETH deposited in `0xcBc1065255cBc3aB41a6868c22d1f1C573AB89fd` mints CRETH2 which later,
    but represents the same ETH portion, so we should deduct from the total value given by `accumulated()``
    the amount of ETH already deployed in the ethereum market place, otherwise it will account a certain %
    twice. Only certain portion can be considered "idle" in the eth deposit contract to account again as extra
    eth tvl
  */
  const iddleInETHDepositContract =
    BigNumber(accumCRETH2).minus(balances[CRETH2]);

  balances["0x0000000000000000000000000000000000000000"] = BigNumber(balances["0x0000000000000000000000000000000000000000"]).plus(iddleInETHDepositContract).toFixed(0);

  return balances;
}

async function lending(block, chain, borrowed){
  let balances = {};

  let tokens_bsc = (
    await utils.fetchURL(
      `https://api.cream.finance/api/v1/crtoken?comptroller=${chain}`
    )
  ).data;

  let cashValues = (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens_bsc.map((token) => ({ target: token.token_address })),
      abi: borrowed? abiCerc20.totalBorrows: abiCerc20["getCash"],
      chain,
    })
  ).output;

  let underlyings = (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens_bsc.map((token) => ({ target: token.token_address })),
      abi: abiCerc20["underlying"],
      chain,
    })
  ).output;

  const transformAdress = await transformBscAddress()
  const lpPositions = [];
  cashValues.map((cashVal, idx) => {
    if (tokens_bsc[idx].underlying_symbol === "Cake-LP") {
      lpPositions.push({
        token: underlyings[idx].output,
        balance: cashVal.output,
      });
    } else if (tokens_bsc[idx].symbol==="crBNB") {
      sdk.util.sumSingleBalance(
        balances,
        "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
        cashVal.output
      ); // BNB
    } else {
      const tokenAddr = underlyings[idx].output;
      sdk.util.sumSingleBalance(balances, transformAdress(tokenAddr), cashVal.output);
    }
  });
  await unwrapUniswapLPs(balances, lpPositions, block, 'bsc', transformAdress);
  return balances
}

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const block = chainBlocks["bsc"]; // req for the block type
  const balances = await lending(block, "bsc", false)

  // --- Staking bsc service ---
  const bsc_staking_service = await utils.fetchURL(
    "https://api.binance.org/v1/staking/chains/bsc/validators/bva1asktsxqny35hwxltpzqsvr64s5vr2ph2t2vlnw/"
  );

  sdk.util.sumSingleBalance(
    balances,
    "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", // -- Apparently it auto-merges balances (check on output) ---
    BigNumber(bsc_staking_service.data.votingPower)
      .multipliedBy(10 ** 18)
      .toFixed(0)
  );

  return balances;
};

const bscBorrowed = async (timestamp, ethBlock, chainBlocks) => {
  const block = chainBlocks["bsc"]; // req for the block type
  return lending(block, "bsc", true)
}

module.exports = {
  timetravel: false, // bsc and fantom api's for staked coins can't be queried at historical points
  start: 1599552000, // 09/08/2020 @ 8:00am (UTC)
  ethereum: {
    tvl: ethereumTvl,
  },
  bsc: {
    tvl: bscTvl,
    borrowed: bscBorrowed
    //getCompoundV2Tvl("0x589de0f0ccf905477646599bb3e5c622c84cc0ba", "bsc", addr=>`bsc:${addr}`,  "0x1Ffe17B99b439bE0aFC831239dDECda2A790fF3A", "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", true),
  },
  polygon:compoundExports("0x20ca53e2395fa571798623f1cfbd11fe2c114c24", "polygon"),
};

'''
'''--- projects/creamswap/abi.json ---
{
    "getCurrentTokens": {
        "constant": true,
        "inputs": [],
        "name": "getCurrentTokens",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "tokens",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "get_virtual_price": {
        "constant": true,
        "inputs": [],
        "name": "get_virtual_price",
        "outputs": [
            {
                "type": "uint256",
                "name": "out"
            }
        ],
        "payable": false,
        "signature": "0xbb7b8b80",
        "stateMutability": "view",
        "type": "function"
    },
    "getPricePerFullShare": {
        "constant": true,
        "inputs": [],
        "name": "getPricePerFullShare",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x77c7b8fc"
    },
    "balanceOfUnderlying": {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "balanceOfUnderlying",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x3af9e669"
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}

'''
'''--- projects/creamswap/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const sdk = require('@defillama/sdk');
  const abi = require('./abi.json');
  const BigNumber = require('bignumber.js');

  /*==================================================
  Settings
  ==================================================*/

  const wETH = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
  const usdt = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
  const yyCrv = '0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c';
  const yETH = '0xe1237aA7f535b0CC33Fd973D66cBf830354D16c7';
  const crYFI = '0xCbaE0A83f4f9926997c8339545fb8eE32eDc6b76';
  const crCREAM = '0x892B14321a4FCba80669aE30Bd0cd99a7ECF6aC0';
  const cryUSD = '0x4EE15f44c6F0d8d1136c83EfD2e8E4AC768954c6';
  const CRETH2 = '0xcBc1065255cBc3aB41a6868c22d1f1C573AB89fd';

/*==================================================
  TVL
  ==================================================*/

  function isCrToken(address) {
    const crTokens = [crYFI, crCREAM, cryUSD];
    return crTokens.includes(address);
  }

  async function tvl(timestamp, block) {
    let balances = {
      '0x0000000000000000000000000000000000000000': '0', // ETH
    };

    let poolLogs = (await Promise.all([
      sdk.api.util.getLogs({
        target: '0xf8062Eedf80D8D2527cE89435f670cb996aB4e54',
        topic: 'LOG_NEW_POOL(address,address)',
        keys: ['topics'],
        fromBlock: 10815298,
        toBlock: block
      }),

      block >= 11053389 ?
      sdk.api.util.getLogs({
          target: '0x136d6F80Bb3A853D151686BFED2c9309Aea6dDec',
          topic: 'LOG_NEW_POOL(address,address)',
          keys: ['topics'],
          fromBlock: 11053389,
          toBlock: block
        }) : Promise.resolve({ output: [] }),

      block >= 11099537 ?
      sdk.api.util.getLogs({
        target: '0x0d3303Ffaf107cD732396570Bf07b2dbd79B619f',
        topic: 'LOG_NEW_POOL(address,address)',
        keys: ['topics'],
        fromBlock: 11099537,
        toBlock: block
      }) : Promise.resolve({ output: []})
    ])).reduce((pools, subPools) => {
      let p = pools;
      p.output.push(...subPools.output);
      return p;
    })

    let poolCalls = [];

    let pools = poolLogs.output.map((poolLog) => {
      return `0x${poolLog[2].slice(26)}`
    });

    const poolTokenData = (await sdk.api.abi.multiCall({
      calls: pools.map((poolAddress) => ({ target: poolAddress })),
      abi: abi.getCurrentTokens,
    })).output;

    poolTokenData.forEach((poolToken) => {
      let poolTokens = poolToken.output;
      let poolAddress = poolToken.input.target;

      poolTokens.forEach((token) => {
        poolCalls.push({
          target: token,
          params: poolAddress,
        });
      })
    });

    let poolBalances = (await sdk.api.abi.multiCall({
      block,
      calls: poolCalls,
      abi: 'erc20:balanceOf'
    })).output;

    poolBalances.forEach((balanceOf) => {
        let balance = balanceOf.output;
        let address = balanceOf.input.target;

        if (BigNumber(balance).toNumber() <= 0) {
          return;
        }

        balances[address] = BigNumber(balances[address] || 0).plus(balance).toFixed();
    });

    let underlyingBalanceCalls = [];
    let underlyingAddressCalls = [];
    poolBalances.filter((poolBalance) => isCrToken(poolBalance.input.target)).forEach(pooBalance => {
      underlyingBalanceCalls.push({
        target: pooBalance.input.target,
        params: pooBalance.input.params,
      });
      underlyingAddressCalls.push({
        target: pooBalance.input.target,
        params: [],
      })
    })

    let [underlyingBalances, underlyingAddress, yVaultPrices, yCrvPrice] = await Promise.all([
      sdk.api.abi.multiCall({
        block,
        calls: underlyingBalanceCalls,
        abi: abi['balanceOfUnderlying']
      }),
      sdk.api.abi.multiCall({
        block,
        calls: underlyingAddressCalls,
        abi: abi['underlying']
      }),
      sdk.api.abi.multiCall({
        block,
        calls: [{target: yETH}, {target: yyCrv}],
        abi: abi['getPricePerFullShare'],
      }),
      sdk.api.abi.call({
        block,
        target: '0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51',
        params: [],
        abi: abi['get_virtual_price']
      })
    ]);

    underlyingBalances = underlyingBalances.output;
    underlyingAddress = underlyingAddress.output;
    yVaultPrices = yVaultPrices.output;
    yCrvPrice = yCrvPrice.output;

    // convert cTokens into underlying tokens
    underlyingBalances.forEach((underlying, i) => {
        let balance = underlying.output;
        let address = underlyingAddress[i].output;
        let cAddress = underlying.input.target;
        balances[address] = balance;
        delete balances[cAddress];
    })

    // convert vault tokens into underlying values
    poolBalances.forEach((balanceOf, i) => {
        let balance = balanceOf.output;
        let address = balanceOf.input.target;

        if (BigNumber(balance).toNumber() <= 0) {
          return;
        }
        // assume CRETH2:ETH  = 1:1
        if (address === CRETH2) {
          balances[wETH] = BigNumber(balances[wETH] || 0).plus(balances[CRETH2]).toFixed();
          delete balances[CRETH2];
        } else if (address === yyCrv) {
          const yyCrvCash = BigNumber(balance).multipliedBy(yCrvPrice).div(1e18).div(1e12).multipliedBy(yVaultPrices[1].output).div(1e18).integerValue();
          balances[usdt] = BigNumber(balances[usdt] || 0).plus(yyCrvCash).toFixed();
          delete balances[yyCrv];
        } else {
          balances[address] = BigNumber(balances[address] || 0).plus(balance).toFixed();
        }
    });
    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1599552000, // 09/08/2020 @ 8:00am (UTC)
    ethereum: { tvl }
  }

'''
'''--- projects/creditum/abi.json ---
{
    "token": {
		"inputs": [],
		"name": "token",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}
'''
'''--- projects/creditum/helper.js ---
const abi = require('./abi.json')
const sdk = require('@defillama/sdk')
const BigNumber = require('bignumber.js');
const getPricePerShare = require('../helper/abis/getPricePerShare.json')

async function handleYearnTokens(balances, tokens, owner, block, chain, transform) {
    let balance = (
      await sdk.api.abi.multiCall({
        calls: tokens.map((p) => ({
          target: p,
          params: owner,
        })),
        abi: "erc20:balanceOf",
        block,
        chain,
      })
    ).output;
    let pricePerShare = (
      await sdk.api.abi.multiCall({
        calls: tokens.map((p) => ({
          target: p,
        })),
        abi: getPricePerShare[1],
        block,
        chain,
      })
    ).output;
    let underlyingTokens = (
        await sdk.api.abi.multiCall({
          calls: tokens.map((p) => ({
            target: p,
          })),
          abi: abi.token,
          block,
          chain,
        })
      ).output;
    for (let i = 0; i < balance.length; i++) {
      let addr = transform(underlyingTokens[i].output.toLowerCase());
      const price = pricePerShare[i].output
      sdk.util.sumSingleBalance(
        balances,
        addr,
        BigNumber(balance[i].output)
          .times(price).div(10**Math.log10(price))
          .toFixed(0)
      );
    }
  }
module.exports = {
    handleYearnTokens
}
'''
'''--- projects/creditum/index.js ---
const { stakingPricedLP } = require("../helper/staking");
const { sumTokensSharedOwners } = require("../helper/unwrapLPs");
const { pool2 } = require("../helper/pool2");
const { handleYearnTokens } = require("./helper.js");

const lending = "0x04D2C91A8BDf61b11A526ABea2e2d8d778d4A534"

async function tvl(time, ethBlock, chainBlocks){
    const chain = 'fantom'
    const block = chainBlocks[chain]
    const balances = {}
    const transform = addr=> addr==="0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e"?"0x6b175474e89094c44da98b954eedeac495271d0f":`${chain}:${addr}`
    await sumTokensSharedOwners(balances, [
        "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
        "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
        "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e",
        "0x321162Cd933E2Be498Cd2267a90534A804051b11",
        "0x74b23882a30290451A17c44f4F05243b6b58C76d"
    ], [lending], block, chain, transform)
    await handleYearnTokens(balances, [
        "0x637ec617c86d24e421328e6caea1d92114892439",
        "0xef0210eb96c7eb36af8ed1c20306462764935607",
        "0x0dec85e74a92c52b7f708c4b10207d9560cefaf0"
    ], lending, block, chain, transform)
    return balances
}

module.exports={
    fantom:{
        tvl,
        staking: stakingPricedLP("0xd9e28749e80D867d5d14217416BFf0e668C10645", "0x77128dfdd0ac859b33f44050c6fa272f34872b5e", "fantom", "0x06F3Cb227781A836feFAEa7E686Bdc857e80eAa7", "wrapped-fantom"),
        pool2: pool2("0xe0c43105235c1f18ea15fdb60bb6d54814299938", "0x06f3cb227781a836fefaea7e686bdc857e80eaa7", "fantom"),
    },
}
'''
'''--- projects/credix/credix.json ---
{
  "version": "0.1.0",
  "name": "credix",
  "instructions": [
    {
      "name": "initializeMarket",
      "accounts": [
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "gatekeeperNetwork",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "liquidityPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "treasury",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "treasuryPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "baseTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "globalMarketSeed",
          "type": "string"
        },
        {
          "name": "interestFee",
          "type": {
            "defined": "Ratio"
          }
        },
        {
          "name": "withdrawalFee",
          "type": {
            "defined": "Ratio"
          }
        }
      ]
    },
    {
      "name": "depositFunds",
      "accounts": [
        {
          "name": "investor",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "gatewayToken",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "investorTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "liquidityPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "investorLpTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "baseTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "createDeal",
      "accounts": [
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "gatewayToken",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "borrower",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "borrowerInfo",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "deal",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "principal",
          "type": "u64"
        },
        {
          "name": "financingFeePercentage",
          "type": {
            "defined": "Ratio"
          }
        },
        {
          "name": "leverageRatio",
          "type": "u8"
        },
        {
          "name": "underwriterPerformanceFeePercentage",
          "type": {
            "defined": "Ratio"
          }
        },
        {
          "name": "timeToMaturityDays",
          "type": "u16"
        },
        {
          "name": "dealName",
          "type": "string"
        }
      ]
    },
    {
      "name": "activateDeal",
      "accounts": [
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "gatewayToken",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "deal",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "liquidityPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "borrower",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "borrowerTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "baseTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "makeDealRepayment",
      "accounts": [
        {
          "name": "borrower",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "gatewayToken",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "borrowerTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "deal",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "liquidityPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "treasuryPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "baseTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "repaymentType",
          "type": {
            "defined": "DealRepaymentType"
          }
        }
      ]
    },
    {
      "name": "withdrawFunds",
      "accounts": [
        {
          "name": "investor",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "gatewayToken",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "investorLpTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "investorTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "liquidityPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "treasuryPoolTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "baseTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "baseWithdrawalAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "createCredixPass",
      "accounts": [
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "passHolder",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "isUnderwriter",
          "type": "bool"
        },
        {
          "name": "isBorrower",
          "type": "bool"
        },
        {
          "name": "releaseTimestamp",
          "type": "i64"
        }
      ]
    },
    {
      "name": "updateCredixPass",
      "accounts": [
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "passHolder",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "credixPass",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "globalMarketState",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "isActive",
          "type": "bool"
        },
        {
          "name": "isUnderwriter",
          "type": "bool"
        },
        {
          "name": "isBorrower",
          "type": "bool"
        },
        {
          "name": "releaseTimestamp",
          "type": "i64"
        }
      ]
    },
    {
      "name": "freezeGlobalMarketState",
      "accounts": [
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "thawGlobalMarketState",
      "accounts": [
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "globalMarketState",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateLpTokenMetadata",
      "accounts": [
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "globalMarketState",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "metadataPda",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signingAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMetadataProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "name",
          "type": "string"
        },
        {
          "name": "symbol",
          "type": "string"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "BorrowerInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "numOfDeals",
            "type": "u16"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "Deal",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "borrower",
            "type": "publicKey"
          },
          {
            "name": "principal",
            "type": "u64"
          },
          {
            "name": "financingFeePercentage",
            "type": {
              "defined": "Ratio"
            }
          },
          {
            "name": "principalAmountRepaid",
            "type": "u64"
          },
          {
            "name": "interestAmountRepaid",
            "type": "u64"
          },
          {
            "name": "timeToMaturityDays",
            "type": "u16"
          },
          {
            "name": "goLiveAt",
            "type": "i64"
          },
          {
            "name": "createdAt",
            "type": "i64"
          },
          {
            "name": "leverageRatio",
            "type": "u8"
          },
          {
            "name": "underwriterPerformanceFeePercentage",
            "type": {
              "defined": "Ratio"
            }
          },
          {
            "name": "dealNumber",
            "type": "u16"
          },
          {
            "name": "bump",
            "type": "u8"
          },
          {
            "name": "lateFees",
            "type": "u64"
          },
          {
            "name": "lateFeesRepaid",
            "type": "u64"
          },
          {
            "name": "private",
            "type": "bool"
          },
          {
            "name": "defaulted",
            "type": "bool"
          }
        ]
      }
    },
    {
      "name": "GlobalMarketState",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "gatekeeperNetwork",
            "type": "publicKey"
          },
          {
            "name": "baseTokenMint",
            "type": "publicKey"
          },
          {
            "name": "lpTokenMint",
            "type": "publicKey"
          },
          {
            "name": "totalOutstandingCredit",
            "type": "u64"
          },
          {
            "name": "treasuryPoolTokenAccount",
            "type": "publicKey"
          },
          {
            "name": "signingAuthorityBump",
            "type": "u8"
          },
          {
            "name": "bump",
            "type": "u8"
          },
          {
            "name": "interestFee",
            "type": {
              "defined": "Ratio"
            }
          },
          {
            "name": "withdrawalFee",
            "type": {
              "defined": "Ratio"
            }
          },
          {
            "name": "frozen",
            "type": "bool"
          },
          {
            "name": "seed",
            "type": "string"
          }
        ]
      }
    },
    {
      "name": "CredixPass",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "bump",
            "type": "u8"
          },
          {
            "name": "isBorrower",
            "type": "bool"
          },
          {
            "name": "isUnderwriter",
            "type": "bool"
          },
          {
            "name": "active",
            "type": "bool"
          },
          {
            "name": "releaseTimestamp",
            "type": "i64"
          },
          {
            "name": "user",
            "type": "publicKey"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Ratio",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "numerator",
            "type": "u32"
          },
          {
            "name": "denominator",
            "type": "u32"
          }
        ]
      }
    },
    {
      "name": "DealRepaymentType",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Interest"
          },
          {
            "name": "Principal"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "DealCreationEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "borrower",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    },
    {
      "name": "DealActivationEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "borrower",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "liquidityPoolAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalOutstandingCredit",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    },
    {
      "name": "DealInterestRepaymentEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "borrower",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "liquidityPoolAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "treasuryAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    },
    {
      "name": "DealPrincipalRepaymentEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "borrower",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "liquidityPoolAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalOutstandingCredit",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    },
    {
      "name": "WithdrawEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "investor",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "liquidityPoolAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "investorLpTokenAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "lpTokenSupply",
          "type": "u64",
          "index": false
        },
        {
          "name": "treasuryAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    },
    {
      "name": "DepositEvent",
      "fields": [
        {
          "name": "timestamp",
          "type": "i64",
          "index": true
        },
        {
          "name": "investor",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "baseAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "liquidityPoolAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "investorLpTokenAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "lpTokenSupply",
          "type": "u64",
          "index": false
        },
        {
          "name": "globalMarketState",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "globalMarketStateSeed",
          "type": "string",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6000,
      "name": "InvalidPrincipalAmount",
      "msg": "This amount is not sufficient as a principal amount."
    },
    {
      "code": 6001,
      "name": "InvalidInterestAmount",
      "msg": "This amount is not sufficient as an interest amount."
    },
    {
      "code": 6002,
      "name": "DealNotLive",
      "msg": "This deal is not live yet."
    },
    {
      "code": 6003,
      "name": "InvalidDealRepaymentType",
      "msg": "Invalid deal repayment type."
    },
    {
      "code": 6004,
      "name": "NotEnoughLiquidity",
      "msg": "Not enough liquidity."
    },
    {
      "code": 6005,
      "name": "PrincipalRepaid",
      "msg": "Principal is already repaid."
    },
    {
      "code": 6006,
      "name": "InterestRepaid",
      "msg": "Interest is already repaid."
    },
    {
      "code": 6007,
      "name": "UnauthorizedSigner",
      "msg": "The Signer is not authorized to use this instruction."
    },
    {
      "code": 6008,
      "name": "CredixPassInvalid",
      "msg": "Credix pass is invalid for this request."
    },
    {
      "code": 6009,
      "name": "CredixPassInactive",
      "msg": "Credix pass is inactive at the moment."
    },
    {
      "code": 6010,
      "name": "Overflow",
      "msg": "Overflow occured."
    },
    {
      "code": 6011,
      "name": "Underflow",
      "msg": "Underflow occured."
    },
    {
      "code": 6012,
      "name": "ZeroDivision",
      "msg": "Tried to divide by zero."
    },
    {
      "code": 6013,
      "name": "ZeroDenominator",
      "msg": "Invalid Ratio: denominator can't be zero."
    },
    {
      "code": 6014,
      "name": "InvalidPreciseNumber",
      "msg": "Invalid u64 used as value for PreciseNumber."
    },
    {
      "code": 6015,
      "name": "PreciseNumberCastFailed",
      "msg": "Unable to cast PreciseNumber to u64"
    },
    {
      "code": 6016,
      "name": "NotEnoughLPTokens",
      "msg": "Not enough LP tokens."
    },
    {
      "code": 6017,
      "name": "NotEnoughBaseTokens",
      "msg": "Not enough Base tokens."
    },
    {
      "code": 6018,
      "name": "InterestBeforePrincipal",
      "msg": "Repay interest before principal."
    },
    {
      "code": 6019,
      "name": "MarketIsFrozen",
      "msg": "This market is currently frozen. Please try again later."
    },
    {
      "code": 6020,
      "name": "InvalidBorrowerTokenAccount",
      "msg": "Invalid Borrower Token Account."
    },
    {
      "code": 6021,
      "name": "InvalidBorrowerAccount",
      "msg": "Invalid Borrower Account."
    },
    {
      "code": 6022,
      "name": "InvalidGatewayToken",
      "msg": "Invalid Gateway token."
    },
    {
      "code": 6023,
      "name": "DealAlreadyActive",
      "msg": "Deal is already active."
    },
    {
      "code": 6024,
      "name": "InvalidInvestorTokenAccount",
      "msg": "Invalid Investor Token Account."
    },
    {
      "code": 6025,
      "name": "InvalidTokenAccountMint",
      "msg": "Invalid mint for Token Account."
    },
    {
      "code": 6026,
      "name": "InvalidMintAccount",
      "msg": "Invalid mint Account."
    },
    {
      "code": 6027,
      "name": "InvalidTreasuryAccount",
      "msg": "Invalid treasury Account for this market."
    },
    {
      "code": 6028,
      "name": "WithdrawalsLocked",
      "msg": "Not yet possible to withdraw funds."
    }
  ]
}
'''
'''--- projects/credix/index.js ---
const { PublicKey } = require('@solana/web3.js')
const { Program, utils } = require("@project-serum/anchor");
const { getAssociatedTokenAddress } = require("@solana/spl-token");
const IDL = require("./credix.json");
const { toUSDTBalances } = require('../helper/balances')
const { getProvider } = require('../helper/solana')

const programId = new PublicKey("CRDx2YkdtYtGZXGHZ59wNv1EwKHQndnRc1gT4p8i2vPX");

const encodeSeedString = (seedString) => Buffer.from(utils.bytes.utf8.encode(seedString));

const constructProgram = async (provider) => {
  return new Program(IDL, programId, provider);
};

const findPDA = async (seeds) => {
  return PublicKey.findProgramAddress(seeds, programId);
};

const findGlobalMarketStatePDA = async (globalMarketSeed) => {
  const seed = encodeSeedString(globalMarketSeed);
  return findPDA([seed]);
};

const findSigningAuthorityPDA = async (globalMarketSeed) => {
  const globalMarketStatePDA = await findGlobalMarketStatePDA(globalMarketSeed);
  const seeds = [globalMarketStatePDA[0].toBuffer()];
  return findPDA(seeds);
};

const getAssociatedBaseTokenAddressPK = async (publicKey) => {
  const baseMintPK = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"); //USDC
  return await getAssociatedTokenAddress(
    baseMintPK,
    publicKey,
    true
  );
};

async function tvl() {
  const globalMarketSeed = "credix-marketplace"
  const provider = getProvider();
  const signingAuthorityKey = await findSigningAuthorityPDA(globalMarketSeed)
  const liquidityPoolKey = await getAssociatedBaseTokenAddressPK(signingAuthorityKey[0]);
  const liquidityPool = await provider.connection.getTokenAccountBalance(liquidityPoolKey);
  const liquidityPoolBalance = liquidityPool.value.uiAmount;
  return toUSDTBalances(liquidityPoolBalance)
}

async function borrowed() {
  const globalMarketSeed = "credix-marketplace"
  const provider = getProvider();
  const program = await constructProgram(provider);
  const globalMarketStatePDA = await findGlobalMarketStatePDA(globalMarketSeed);
  const globalMarketStateAccountData = await program.account.globalMarketState.fetch(globalMarketStatePDA[0]);
  const totalOutstandingCredit = Number(globalMarketStateAccountData.totalOutstandingCredit) / 1000000;
  return toUSDTBalances(totalOutstandingCredit)
}

module.exports = {
  timetravel: false,
  solana: {
    tvl,
    borrowed
  }
};
'''
'''--- projects/crema.js ---
const retry = require("./helper/retry");
const axios = require("axios");

async function fetch() {
  const response = (
    await retry(
      async () => await axios.get("https://api.crema.finance/v1/swap/count")
    )
  ).data;
  const tvl = response.data.tvl_in_usd;
  return tvl;
}

module.exports = {
  timetravel: false,
  fetch,
};

'''
'''--- projects/croblanc/abi.json ---
{
    "getFarms": {
        "inputs": [],
        "name": "getFarms",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "want": {
        "inputs": [],
        "name": "want",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "stakedWant": {
        "inputs": [],
        "name": "stakedWant",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/croblanc/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { unwrapUniswapLPs, } = require("../helper/unwrapLPs");
const { getChainTransform } = require('../helper/portedTokens')

const treasury = "0xb20234c33337537111f4ab6f5EcaD400134aC143";
const WCRO = "0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23";

const croblancAlpha = "0x52a87ef19e4a0E8cc70aE69D22bc8254bc6fa0F9";

const pool2Farm = "0x4c1EC4Bf75CdFAF9b172e94cc85b7a8eA647F267";
const WCRO_CROBLANC_CronaLP = ["0xac23a7de083719c0e11d5c2efbcc99db5c73bb48"].map(addr => addr.toLowerCase())

const cronosTvl = async (_, _b, chainBlocks) => {
  const chain = 'cronos'
  const balances = {}
  const block = chainBlocks[chain]
  const abis = [abi.want, abi.stakedWant]
  const transformAddress = await getChainTransform(chain)

  const farms = (
    await sdk.api.abi.call({
      abi: abi.getFarms,
      target: croblancAlpha,
      chain, block,
    })
  ).output;
  
  const calls = farms.map(t => ({ target: t }))
  const [
    want,
    stakedWant
  ] = (await Promise.all(abis.map(abi => sdk.api.abi.multiCall({
    abi, calls, chain, block,
  })))).map(i => i.output)

  const lpPositions = []
  want.forEach(({ output }, idx) => {
    if (!WCRO_CROBLANC_CronaLP.includes(output.toLowerCase()))
      lpPositions.push({ token: output, balance: stakedWant[idx].output })
  })

  await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAddress);
  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  cronos: {
    treasury: staking(treasury, WCRO, "cronos"),
    pool2: pool2(pool2Farm, WCRO_CROBLANC_CronaLP[0], "cronos"),
    tvl: cronosTvl,
  },
  methodology:
    "Counts liquidity on all the Farms through CroblancAlpha Contract",
};

'''
'''--- projects/crodex/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0xe9c29cB475C0ADe80bE0319B74AD112F1e80058F) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  cronos: {
    tvl: calculateUsdUniTvl(
      "0xe9c29cB475C0ADe80bE0319B74AD112F1e80058F",
      "cronos",
      "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
      [
        "0xc21223249CA28397B4B6541dfFaEcC539BfF0c59",
        "0x66e428c3f67a68878562e79A0234c1F83c208770",
        "0xe243CCab9E66E6cF1215376980811ddf1eb7F689",
      ],
      "crypto-com-chain"
    ),
  },
}; // node test.js projects/crodex/index.js

'''
'''--- projects/croissant/index.js ---
const { stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");
const masterchef = "0x127A5b49E63FadFBA2bc370D44034F170d88C7e6";
const croissant = "0xa0C3c184493f2Fae7d2f2Bd83F195a1c300FA353";
const croi_mmf_lp = "0xde991150329dbe53389db41db459cae3ff220bac";

module.exports = {
	misrepresentedTokens: true,
	cronos: {
		staking: stakings([masterchef], croissant, 'cronos'),
		pool2: pool2s([masterchef], [croi_mmf_lp], 'cronos'),
		tvl: () => ({})
	},
	methodology: "LPs and tokens in masterchef",
};
'''
'''--- projects/cronaswap/index.js ---
const { staking } = require('../helper/staking')
const { getUniTVL } = require('../helper/unknownTokens')

module.exports={
    misrepresentedTokens: true,
    methodology: "Factory address (0x73A48f8f521EB31c55c0e1274dB0898dE599Cb11) is used to find the LP pairs. TVL is equal to the liquidity on the AMM, while staking is the amount of CRONA tokens found in the Masterchef(0x77ea4a4cF9F77A034E4291E8f457Af7772c2B254).",
    cronos: {
      tvl: getUniTVL({
        chain: 'cronos',
        factory: '0x73A48f8f521EB31c55c0e1274dB0898dE599Cb11',
        coreAssets: [
          '0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23', // wcro
        ],
        blacklist: [
          '0x5b5fe1238aca91c65683acd7f9d9bf922e271eaa', // SUS
        ]
      }),
        staking: staking("0x77ea4a4cF9F77A034E4291E8f457Af7772c2B254", "0xadbd1231fb360047525BEdF962581F3eee7b49fe", 'cronos')
    }
}
'''
'''--- projects/cronofi-finance/index.js ---
const {masterChefExports} = require('../helper/masterchef');

const masterchef = "0xdc0E1690c594dDD1654544e74036Ee0b0029573d";
const token = "0x3Df064069Ba2c8B395592E7834934dBC48BbB955";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "cronos", token, false)
}
'''
'''--- projects/cronus/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x20570b7bFf86B2f92068622D0805160f318554Be) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  evmos: {
    tvl: calculateUsdUniTvl(
      "0x20570b7bFf86B2f92068622D0805160f318554Be",
      "evmos",
      "0xD4949664cD82660AaE99bEdc034a0deA8A0bd517",
      [
        "0xe46910336479f254723710d57e7b683f3315b22b", //ceUSDC
        "0x51e44ffad5c2b122c8b635671fcc8139dc636e82", //USDC
        "0xe03494d0033687543a80c9b1ca7d6237f2ea8bd8", //FRAX        
      ],
      "evmos"
    ),
  },
}; // node test.js projects/cronus/index.js

'''
'''--- projects/cropper.js ---
const retry = require("./helper/retry");
const axios = require("axios");
const { toUSDTBalances } = require("./helper/balances");
const { getTokenBalance } = require("./helper/solana");

async function fetch() {
  const response = (
    await retry(async (bail) => await axios.get("https://api.cropper.finance/cmc/pools"))
  ).data;

  const liqArrPerPool = Object.values(response).map((pool) => pool.tvl);

  const dexTvl = liqArrPerPool.reduce((a, b) => a + b, 0)

  return toUSDTBalances(dexTvl);
}

async function fetchStaking() {
  return {
    cropperfinance: await getTokenBalance('DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz', '5mEH7a7abQwUEXqfusVepc3z9cHVQg8uhqTXdq47J91o')
  };
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  solana: {
    tvl: fetch,
    staking: fetchStaking
  }
};  // node test.js projects/cropper.js
'''
'''--- projects/crosschainbridge/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");

const getBridgeContract = (chain) => {
  switch (chain) {
    case 'avax':
      return '0x46325c7005F04900F8D74cD0eAB903597b6EFFFF';
    default:
      return '0xCBCe172d7af2616804ab5b2494102dAeC47B2635';
  }
}

const getRewardPools = (chain) => {
  switch (chain) {
    case 'avax':
      return '0xbAb537b7AE2Fcb00eeA7e91Fa4782EEbaD3B6d10';
    case 'fantom':
      return '0x6eBC0D4Ae955218195E6D016Fb9D4358Ee34d1F9';
    default:
      return '0x0BDC1f983bC82B8F6F6BCcbF9810A9cdC1FE455f';
  }
}

/*
 * TOKEN CONFIGURATION
 * ADD TOKENS AND NETWORKS HERE
 */

const tokens = {
  ethereum: {
    // Project tokens
    TXL: "0x8eEF5a82E6Aa222a60F009ac18c24EE12dBf4b41",
    BRIDGE: "0x92868a5255c628da08f550a858a802f5351c5223",
    // Stablecoins
    BUSD: "0x4Fabb145d64652a948d72533023f6E7A623C7C53",
    DAI: "0x6b175474e89094c44da98b954eedeac495271d0f",
    USDC: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    USDT: "0xdac17f958d2ee523a2206206994597c13d831ec7",
    // Network Tokens
    WETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    WMATIC: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    // Further tokens
    BULK: "0xa143ac515dca260a46c742c7251ef3b268639593",
    DAX: "0x77e9618179820961ee99a988983bc9ab41ff3112",
    GFX: "0x65ad6a2288b2dd23e466226397c8f5d1794e58fc",
    ISLAND: "0xa0dc5132c91ea4d94fcf1727c32cc5a303b34cfc",
    MNY: "0xA6F7645ed967FAF708A614a2fcA8D4790138586f",
    PMON: "0x1796ae0b0fa4862485106a0de9b654efe301d0b2",
    REALM: "0x464FdB8AFFC9bac185A7393fd4298137866DCFB8",
    UCT: "0x6d1DC3928604b00180Bb570BdAe94b9698d33b79",
    UNO: "0x474021845c4643113458ea4414bdb7fb74a01a77",
    UPR: "0xf720e38f678b29b243f7d53b56acbf5de98f2385",
    ZENIQ: "0x5b52bfb8062ce664d74bbcd4cd6dc7df53fd7233",
  },
  bsc: {
    // Project tokens
    TXL: "0x1ffd0b47127fdd4097e54521c9e2c7f0d66aafc5",
    BRIDGE: "0x92868a5255c628da08f550a858a802f5351c5223",
    // Stablecoins
    BUSD: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    DAI: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
    USDC: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
    USDT: "0x55d398326f99059fF775485246999027B3197955",
    // Network Tokens
    WETH: "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
    WMATIC: "0xcc42724c6683b7e57334c4e856f4c9965ed682bd",
    // Further tokens
    ARNX: "0x0c37bcf456bc661c14d596683325623076d7e283",
    BRKL: "0x66cafcf6c32315623c7ffd3f2ff690aa36ebed38",
    BULK: "0xa143ac515dca260a46c742c7251ef3b268639593",
    DAF: "0x8fb1a59ca2d57b51e5971a85277efe72c4492983",
    DAX: "0x2cb34f6a300813da9312b84ab566b2e51cc02921",
    GFX: "0x65ad6a2288b2dd23e466226397c8f5d1794e58fc",
    HAKA: "0xd85ad783cc94bd04196a13dc042a3054a9b52210",
    ISLAND: "0xa0dc5132c91ea4d94fcf1727c32cc5a303b34cfc",
    MNY: "0xA6F7645ed967FAF708A614a2fcA8D4790138586f",
    PMON: "0x1796ae0b0fa4862485106a0de9b654efe301d0b2",
    RACA: "0x12bb890508c125661e03b09ec06e404bc9289040",
    REALM: "0x464FdB8AFFC9bac185A7393fd4298137866DCFB8",
    UCT: "0x6d1dc3928604b00180bb570bdae94b9698d33b79",
    UNO: "0x474021845C4643113458ea4414bdb7fB74A01A77",
    ULTI: "0x42BFE4A3E023f2C90aEBFfbd9B667599Fa38514F",
    UPR: "0xf720e38f678b29b243f7d53b56acbf5de98f2385",
    TRON: "0x85eac5ac2f758618dfa09bdbe0cf174e7d574d5b",
    ZENIQ: "0x5b52bfb8062ce664d74bbcd4cd6dc7df53fd7233",
  },
  polygon: {
    // Project tokens
    TXL: "0x8eEF5a82E6Aa222a60F009ac18c24EE12dBf4b41",
    BRIDGE: "0x92868a5255c628da08f550a858a802f5351c5223",
    // Stablecoins
    BUSD: "0xdab529f40e671a1d4bf91361c21bf9f0c9712ab7",
    DAI: "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
    USDC: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
    USDT: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    // Network Tokens
    WETH: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
    WMATIC: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
    // Further tokens
    DAF: "0x2f0e07e881363bb1cdff32971b2f8c87ef8ff432",
    GFX: "0x65ad6a2288b2dd23e466226397c8f5d1794e58fc",
    PMON: "0x1796ae0b0fa4862485106a0de9b654efe301d0b2",
    ULTI: "0xa6516f07c5fc7169fca3149b188c37ca617f1d41",
  },
  avax: {
    // Project tokens
    BRIDGE: "0xC0367f9b1f84Ca8DE127226AC2A994EA4bf1e41b",
    // Stablecoins
    USDC: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
    USDT: "0xc7198437980c041c805a1edcba50c1ce5db95118",
    // Network Tokens
    WETH: "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
  },
  fantom: {
    // Project tokens
    BRIDGE: "0x92868A5255C628dA08F550a858A802f5351C5223",
    // Stablecoins
    USDC: "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75",
    USDT: "0x049d68029688eabf473097a2fc38ef61633a3c7a",
    // Network Tokens
    WETH: "0x74b23882a30290451A17c44f4F05243b6b58C76d",
  }
};

/*
 * END OF CONFIGURATION
 */

const getAddrPrefix = (chain) => (chain === "ethereum" ? "" : `${chain}:`);

const createTvlFunction = (chain) => async (timestamp, block, chainBlocks) => {
  const balances = {};
  const bridgeContract = getBridgeContract(chain);

  for (const [symbol, address] of Object.entries(tokens[chain])) {
    let tokenBalance = BigNumber(0);
    // Get balance of token in bridge contract
    const result = await sdk.api.erc20.balanceOf({
      target: address,
      owner: bridgeContract,
      chain,
      block: chainBlocks[chain],
    });
    tokenBalance = tokenBalance.plus(result.output);

    balances[`${getAddrPrefix(chain)}${address}`] = tokenBalance.toFixed();
  }
  return balances;
};

const createRewardPoolsTvlFunction = (chain) => async (timestamp, block, chainBlocks) => {
  const bridgeTokenAddress = tokens[chain].BRIDGE;
  const rewardPoolsContract = getRewardPools(chain);

  if (!bridgeTokenAddress) return 0;

  let tokenBalance = BigNumber(0);

  const resultRewardPools = await sdk.api.erc20.balanceOf({
    target: bridgeTokenAddress,
    owner: rewardPoolsContract,
    chain,
    block: chainBlocks[chain],
  });
  tokenBalance = tokenBalance.plus(resultRewardPools.output);

  return { [`${getAddrPrefix(chain)}${bridgeTokenAddress}`] : tokenBalance.toFixed() };
};

const toExport = {};
for (const network of Object.keys(tokens)) {
  toExport[network] = {
    tvl: createTvlFunction(network),
    staking: createRewardPoolsTvlFunction(network),
  };
}

module.exports = toExport;
// node test.js projects/crosschainbridge/index.js
'''
'''--- projects/crowfi/index.js ---
const {calculateUniTvl} = require("../helper/calculateUniTvl");

const crow = "0x285c3329930a3fd3C7c14bC041d3E50e165b1517";
const factory = "0xDdcf30c1A85e5a60d85310d6b0D3952A75a00db4"

const translate = {
    "0xfa9343c3897324496a05fc75abed6bac29f8a40f": "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", // BNB
}

async function tvl (timestamp, block, chainBlocks) {
    return await calculateUniTvl(addr=> {
        addr = addr.toLowerCase()
        if (translate[addr] !== undefined) {
            return translate[addr];
        }
        return `cronos:${addr}`
    }, chainBlocks.cronos, "cronos", factory, 0, true);
}

module.exports = {
    methodology: "TVL in factory contract",
    cronos: {
        tvl
    }
}
'''
'''--- projects/crown-finance/index.js ---

module.exports = {
  deadFrom: 1655582945, // we suspect that the project has rugged
  cronos: {
    tvl: () => ({}),
  }
}
'''
'''--- projects/crunchynetwork/index.js ---
const BigNumber = require("bignumber.js");
const { get } = require('../helper/http')
const { RPC_ENDPOINT } = require('../helper/tezos')
const { PromisePool } = require('@supercharge/promise-pool')

// crunchy farm address KT1KnuE87q1EKjPozJ5sRAjQA24FPsP57CE3
// TVL = sum(crunchFarm.poolBalance / quipuLP.total_supply * quipuLP.tez_pool * 2 * XTZUSD)
async function fetchFarmsTvl() {
    const farms = await get(RPC_ENDPOINT + '/v1/contracts/KT1KnuE87q1EKjPozJ5sRAjQA24FPsP57CE3/bigmaps/farms/keys?limit=1000')
    const items = farms.map(farm => [farm.value.poolToken.address, farm.value.poolBalance]);
    return getAllLPToTez(items);
}

// crunchy freezer address KT1LjcQ4h5hCy9RcveFz9Pq8LtmF6oun7vNd
// TVL = sum(cruchFreezer.amountLocked / quipuLP.total_supply * quipuLP.tez_pool * 2 * XTZUSD)
async function fetchDeepFreezersTvl() {
    const freezers = await get(RPC_ENDPOINT + '/v1/contracts/KT1LjcQ4h5hCy9RcveFz9Pq8LtmF6oun7vNd/bigmaps/locks/keys?limit=1000')
    const items = freezers.map(freezer => [freezer.value.token.address, freezer.value.amountLocked]);
    return getAllLPToTez(items);
}

async function getAllLPToTez(items) {
    const { results, errors } = await PromisePool.withConcurrency(10)
        .for(items)
        .process(async ([lpTokenAddress, lpTokens]) => lpToTez(lpTokenAddress, lpTokens))

    if (errors && errors.length)
        throw errors[0]

    return results.reduce((previous, current) => previous.plus(current), new BigNumber(0)).multipliedBy(2)
}

async function lpToTez(lpTokenAddress, lpTokens) {
    if (lpTokens === "0") {
        return new BigNumber(0);
    }

    const tokenStorage = await get(RPC_ENDPOINT + `/v1/contracts/${lpTokenAddress}/storage?limit=1000`);
    if (!tokenStorage.dex_lambdas) {
        return new BigNumber(0);
    }

    const tokenBalance = new BigNumber(lpTokens);
    const tokenTotalSupply = new BigNumber(tokenStorage.storage.total_supply);
    const lpTezValue = new BigNumber(tokenStorage.storage.tez_pool);
    return tokenBalance.dividedBy(tokenTotalSupply).multipliedBy(lpTezValue);
}

async function tvl() {
    const farmsTvl = await fetchFarmsTvl();
    const deepFreezersTvl = await fetchDeepFreezersTvl();
    return {
        tezos: farmsTvl.plus(deepFreezersTvl).shiftedBy(-6).toFixed(0)
    };
}

module.exports = {
    timetravel: false,
    tezos: {
        tvl
    }
};
'''
'''--- projects/cryptex-finance/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensSharedOwners} = require("../helper/unwrapLPs");
const { pool2s } = require("../helper/pool2");
const { staking } = require("../helper/staking");

const ctxToken = "0x321c2fe4446c7c963dc41dd58879af648838f98d";
const factory = "0x70236b36f86AB4bd557Fe9934E1246537B472918";

const ethStakingContracts = [
  "0xc8BB1cd417D20116387a5e0603e195cA4f3Cf59A", //TCAP-WETH
  "0xdC4cDd5dB9EE777EFD891690dc283638CB3A5f94" //CTX-WETH
];

const ethPool2s = [
  "0xa87E2c5D5964955242989B954474ff2EB08Dd2f5", // TACP-WETH
  "0x2A93167Ed63A31F35CA4788e2EB9fBd9fA6089D0", // CTX-WETH
]
const ethVaults = [
   "0x717170b66654292dfbd89c39f5ae6753d2ac1381", // WETH VAULT
   "0x443366a7a5821619D8d57405511E4fadD9964771", // DAI VAULT
]

const ethCollaterals = [
  "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
  "0x6B175474E89094C44Da98b954EedeAC495271d0F" // DAI
]

const optVaults = [
  "0xE0c99C503c4AE5eC50aC63C59C7eF4725C355fdD", // WETH VAULT
  "0x2C890633Db29f21fccbA57c68DcCEF09AB0D4763", // DAI VAULT
  "0x61925C38e28F60e688f7d05E65f63792166a5aFE", // LINK VAULT
  "0xc8BB1cd417D20116387a5e0603e195cA4f3Cf59A", // SNX VAULT
  "0x6fd9d7AD17242c41f7131d257212c54A0e816691" // UNI VAULT
]

const optCollaterals = [
  "0x4200000000000000000000000000000000000006", // WETH
  "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", // DAI
  "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6", // LINK
  "0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4", // SNX
  "0x6fd9d7AD17242c41f7131d257212c54A0e816691" // UNI
]

async function ethTvl(timestamp, block) {
  let balances = {};
  await sumTokensSharedOwners(balances, ethCollaterals, ethVaults, block);
  return balances;
}

async function optTvl(timestamp, block, chainBlocks) {
  let balances = {};
  await sumTokensSharedOwners(balances, optCollaterals, optVaults, chainBlocks.optimism, "optimism");
  return balances;
}

const treasuryAddress = "0xa54074b2cc0e96a43048d4a68472F7F046aC0DA8";
const treasuryContents = [
  "0x321C2fE4446C7c963dc41Dd58879AF648838f98D",
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
]
const optTreasury = "0x271901c3268D0959bbc9543DE4f073D3708C88F7";

async function treasury(timestamp, block) {
  let balances = {};
  const ethBal = (await sdk.api.eth.getBalance({
    target: treasuryAddress, 
    block,
  })).output;
  sdk.util.sumSingleBalance(balances, "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", ethBal);
  await sumTokensSharedOwners(balances, treasuryContents, [treasuryAddress], block);
  return balances;
}

module.exports = {
  methodology: "TVL includes collateral in vaults",
  ethereum: {
    tvl: ethTvl,
    pool2: pool2s(ethStakingContracts, ethPool2s),
    staking: staking(factory, ctxToken),
    treasury
  },
  optimism: {
    tvl: optTvl
  }
  
};

'''
'''--- projects/cryptex/cryptex-config.js ---
const chainIds = {
    bsc: 56,
    polygon: 137,
    fantom: 250,
    avax: 43114,
    xdai: 100,
    cronos: 25,
    aurora: 1313161554,
    moonriver: 1285,
}

const chainNameById = Object.keys(chainIds).reduce((acc, key) => {
    acc[chainIds[key]] = key;
    return acc;
}, {});

const cryptexConfig = {
    crxToken: "0x97a30C692eCe9C317235d48287d23d358170FC40",
    staking: {
        V1: "0x4Dc421AEc34397b447bA1469bcD2C4185224ceC4",
        V2: "0x2DA458781F0BAf868009deD0512a96989bEaE841"
    },
}

const swaps = {
    // BSC
    pancakeswap: 'pancakeswap',
    pancakeswapv2: 'pancakeswapv2',
    apeswap: 'apeswap',
    leonicornswap: 'leonicornswap',
    knightswap: 'knightswap',
    // FANTOM
    spookyswap: 'spookyswap',
    spiritswap: 'spiritswap',
    darkknightswap: 'darkknightswap',
    bombswap: 'bombswap',
    // avax
    pangolinswap: 'pangolinswap',
    traderjoe: 'traderjoe',
    // XDAI (Gnosis)
    honeyswap: 'honeyswap',
    // AURORA
    auroraswap: 'auroraswap',
    // CRONOS
    cronaswap: 'cronaswap',
    // CROSS-CHAINED
    sushiswap: 'sushiswap',
}

const swapConfigs = {
    [chainIds.bsc]: {
        [swaps.pancakeswap]: {
            key: swaps.pancakeswap,
            factory: '0xBCfCcbde45cE874adCB698cC183deBcF17952812',
        },
        [swaps.pancakeswapv2]: {
            key: swaps.pancakeswapv2,
            factory: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',
        },
        [swaps.apeswap]: {
            key: swaps.apeswap,
            factory: '0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6',
        },
        [swaps.leonicornswap]: {
            key: swaps.leonicornswap,
            factory: '0xeb10f4fe2a57383215646b4ac0da70f8edc69d4f',
        },
        [swaps.knightswap]: {
            key: swaps.knightswap,
            factory: '0xf0bc2E21a76513aa7CC2730C7A1D6deE0790751f',
        },
    },
    [chainIds.polygon]: {
        [swaps.sushiswap]: {
            key: swaps.sushiswap,
            factory: '0xc35DADB65012eC5796536bD9864eD8773aBc74C4',
        },
        [swaps.quickswap]: {
            key: swaps.quickswap,
            factory: '0x5757371414417b8c6caad45baef941abc7d3ab32',
        },
    },
    [chainIds.xdai]: {
        [swaps.sushiswap]: {
            key: swaps.sushiswap,
            factory: '0xc35DADB65012eC5796536bD9864eD8773aBc74C4',
        },
        [swaps.honeyswap]: {
            key: swaps.honeyswap,
            factory: '0xA818b4F111Ccac7AA31D0BCc0806d64F2E0737D7',
        }
    },
    [chainIds.fantom]: {
        [swaps.spiritswap]: {
            key: swaps.spiritswap,
            factory: '0xEF45d134b73241eDa7703fa787148D9C9F4950b0',
        },
        [swaps.spookyswap]: {
            key: swaps.spookyswap,
            factory: '0x152ee697f2e276fa89e96742e9bb9ab1f2e61be3',
        },
        [swaps.bombswap]: {
            key: swaps.bombswap,
            factory: '0xD9473A05b2edf4f614593bA5D1dBd3021d8e0Ebe',
        },
        [swaps.darkknightswap]: {
            key: swaps.darkknightswap,
            factory: '0x7d82F56ea0820A9d42b01C3C28F1997721732218',
        },
    },
    [chainIds.avax]: {
        [swaps.pangolinswap]: {
            key: swaps.pangolinswap,
            factory: '0xefa94DE7a4656D787667C749f7E1223D71E9FD88',
        },
        [swaps.traderjoe]: {
            key: swaps.traderjoe,
            factory: '0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10',
        },
    },
    [chainIds.cronos]: {
        [swaps.cronaswap]: {
            key: swaps.cronaswap,
            factory: '0x73A48f8f521EB31c55c0e1274dB0898dE599Cb11',
        }
    },
    [chainIds.aurora]: {
        [swaps.auroraswap]: {
            key: swaps.auroraswap,
            factory: '0xC5E1DaeC2ad401eBEBdd3E32516d90Ab251A3aA3',
        }
    },
    [chainIds.moonriver]: {
        [swaps.sushiswap]: {
            key: swaps.sushiswap,
            factory: '0xc35DADB65012eC5796536bD9864eD8773aBc74C4',
        }
    },
}

const chainConfigs = {
    [chainIds.bsc]: {
        vesting: {
            address: '0x0B07f109E7A08Ad41F99d409329851E968AbD231',
            deployBlock: 7134211,
        },
        lockers: [{
            version: 1,
            deployBlock: 5300329,
            address: '0x7f5EF2cE9150ffE2796F62F1177fc6f22a527E5F',
            swaps: [swaps.pancakeswap,],
        },{
            version: 2,
            deployBlock: 6966666,
            address: '0xe0c3ab2c69d8b43d8B0D922aFa224A0AB6780dE1',
            swaps: [swaps.pancakeswapv2,],
        },{
            version: 3,
            deployBlock: 7867793,
            address: '0x6773Be587556ABeb401aa712958879787e9131F9',
            swaps: [swaps.apeswap],
        },{
            version: 3,
            deployBlock: 12561149,
            address: '0x6e28D5c3C1886F6DA95a5eF9F048bccac3aB7E83',
            swaps: [swaps.leonicornswap,],
        },{
            version: 3,
            deployBlock: 13678367,
            address: '0xa134d366110Fcd89ec504AC9c1eB2A1d715a8B9B',
            swaps: [swaps.knightswap,],
        },{
            version: 4,
            deployBlock: 15335372,
            address: '0x3853a94acD9002B1f87eDB9267bef0702b3D9283',
            swaps: [
                swaps.pancakeswapv2,
                swaps.apeswap,
                swaps.leonicornswap,
                swaps.knightswap,
            ],
        }],
    },
    [chainIds.polygon]: {
        vesting: {
            address: '0x5F0D4Ec7293bB95E26Cc4f5bd0D95D39C5c8FD30',
            deployBlock: 16477018,
        },
        lockers: [{
            version: 3,
            deployBlock: 15681470,
            address: '0x698b50D22F6bc422162CaeDF75Ec29635a11A818',
            swaps: [
                swaps.quickswap
            ],
        },{
            version: 3,
            deployBlock: 15680659,
            address: '0xE239138d6d6e3048B05401c226B777Cd0234cD92',
            swaps: [
                swaps.sushiswap
            ],
        },{
            version: 4,
            deployBlock: 25070018,
            address: '0xBbd3660299f34D204d9aDf90acaD445ffACB4897',
            swaps: [
                swaps.quickswap,
                swaps.sushiswap,
            ],
        }]
    },
    [chainIds.xdai]: {
        vesting: {
            address: '0x24fCd667e0C55aa39ebcc3783Dc6d1eb754fa912',
            deployBlock: 17333151,
        },
        lockers: [{
            version: 3,
            deployBlock: 17315872,
            address: '0xeB32a3290aBa8b5e2A5C67A29C8aDd2D2D590614',
            swaps: [
                swaps.sushiswap,
            ],
        },{
            version: 3,
            deployBlock: 17316077,
            address: '0x8847A10864F0fBc309cC852A3e9850351bE4061e',
            swaps: [
                swaps.honeyswap
            ],
        },{
            version: 4,
            deployBlock: 20697471,
            address: '0x17400E59dB1EBc0E12F11D65127d2F97a87709c4',
            swaps: [
                swaps.sushiswap,
                swaps.honeyswap
            ],
        }],
    },
    [chainIds.fantom]: {
        vesting: {
            address: '0xd7BE08609bb6649fF30505c7b9Bb3D892763d0Aa',
            deployBlock: 18279805,
        },
        lockers: [{
            version: 3,
            deployBlock: 23709374,
            address: '0xB9486B932B9C6Dd14941101514f1B2a8224ec1D6',
            swaps: [
                swaps.bombswap,
            ],
        },{
            version: 3,
            deployBlock: 18268821,
            address: '0xE239138d6d6e3048B05401c226B777Cd0234cD92',
            swaps: [
                swaps.spookyswap,
            ],
        },{
            version: 3,
            deployBlock: 18268978,
            address: '0x698b50D22F6bc422162CaeDF75Ec29635a11A818',
            swaps: [
                swaps.spiritswap,
            ],
        },{
            version: 3,
            deployBlock: 25642123,
            address: '0x668Ab0A9a7B46840695a94E0b9E533CFD4fE0e53',
            swaps: [
                swaps.darkknightswap,
            ],
        },{
            version: 4,
            deployBlock: 31298572,
            address: '0x0DB68BEfbfcE88239068FAaA491d4Cb772dA6C7D',
            swaps: [
                swaps.bombswap,
                swaps.spookyswap,
                swaps.spiritswap,
                swaps.darkknightswap,
            ],
        },],
    },
    [chainIds.avax]: {
        vesting: {
            address: '0xFC382EF71f861633e31A866e689d772c1B99780d',
            deployBlock: 5218695,
        },
        lockers: [{
            version: 3,
            deployBlock: 5218223,
            address: '0x942e3012AA6f57dcde038e4206387946Eafb5F4E',
            swaps: [
                swaps.pangolinswap,
            ],
        },{
            version: 4,
            deployBlock: 11063865,
            address: '0x8d993129C4B426E72b23897B13Ce3dB471D1fd2D',
            swaps: [
                swaps.pangolinswap,
                swaps.traderjoe,
            ],
        },],
    },
    [chainIds.aurora]: {
        lockers: [{
            version: 4,
            deployBlock: 59767920,
            address: '0x942e3012AA6f57dcde038e4206387946Eafb5F4E',
            swaps: [
                swaps.auroraswap,
            ],
        },],
    },
    [chainIds.cronos]: {
        lockers: [{
            version: 4,
            deployBlock: 1643406,
            address: '0xE239138d6d6e3048B05401c226B777Cd0234cD92',
            swaps: [
                swaps.cronaswap,
            ],
        },],
    },
    [chainIds.moonriver]: {
        lockers: [{
            version: 4,
            deployBlock: 1509384,
            address: '0xE239138d6d6e3048B05401c226B777Cd0234cD92',
            swaps: [
                swaps.sushiswap,
            ],
        },],
    },
}

module.exports = {
    chainIds,
    chainNameById,
    cryptexConfig,
    swaps,
    swapConfigs,
    chainConfigs,
}
'''
'''--- projects/cryptex/cryptex-helper.js ---
const sdk = require("@defillama/sdk");
const token0 = require('../helper/abis/token0.json');
const token1 = require('../helper/abis/token1.json');
const getReserves = require('../helper/abis/getReserves.json');
const factoryAbi = require('../helper/abis/factory.json');

const requery = async (results, chain, block, abi) => {
    if (results.some(r => !r.success)) {
        const failed = results.map((r, i) => [r, i]).filter(r => !r[0].success)
        const newResults = await sdk.api.abi
            .multiCall({
                abi,
                chain,
                calls: failed.map((f) => f[0].input),
                block,
            }).then(({ output }) => output);
        failed.forEach((f, i) => {
            results[f[1]] = newResults[i]
        })
    }
}

const getVestInstances = async (vestingAddress, chain, startBlock = 0, endBlock = 0) => {
    let tokenAddresses;

    const logs = (
        await sdk.api.util.getLogs({
            keys: [],
            chain,
            fromBlock: startBlock,
            toBlock: endBlock,
            target: vestingAddress,
            topic: 'OnTokenLock(uint256,address,address,address,uint256,uint256)'
        })
    ).output;

    tokenAddresses = logs
        .map((log) => {
            if (typeof log === 'string') return log;
            return {
                token: `0x${log.topics[2].slice(26)}`,
                instance: `0x${log.data.slice(64 - 40 + 2, 64 + 2)}`,
                isLP: false, // TODO: detect if locked token is LP token
            }
        })

    return tokenAddresses;
}

const getLockerPairAddresses = async (lockerAddress, chain, startBlock = 0, endBlock = 0) => {
    let pairAddresses;

    const logs = (
        await sdk.api.util.getLogs({
            keys: [],
            chain,
            fromBlock: startBlock,
            toBlock: endBlock,
            target: lockerAddress,
            topic: 'OnTokenLock(uint256,address,address,uint256,uint256)',
        })
    ).output;
  
    pairAddresses = logs
        // sometimes the full log is emitted
        .map((log) =>
          typeof log === 'string' ? log : `0x${log.topics[2].slice(26)}`
        )
        // lowercase
        .map((pairAddress) => pairAddress.toLowerCase());

    return pairAddresses;
}

const getSwapPairAddresses = async (factory, chain, useMulticall = false) => {
    let pairAddresses;
    const pairLength = (await sdk.api.abi.call({
        target: factory,
        abi: factoryAbi.allPairsLength,
        chain,
    })).output
    if (pairLength === null) {
        throw new Error("allPairsLength() failed", factory)
    }
    const pairNums = Array.from(Array(Number(pairLength)).keys())
    const pairs = (await sdk.api.abi.multiCall({
        abi: factoryAbi.allPairs,
        chain,
        calls: pairNums.map(num => ({
            target: factory,
            params: [num]
        })),
    })).output
    await requery(pairs, chain, undefined, factoryAbi.allPairs);
    pairAddresses = pairs.map(result => result.output.toLowerCase());

    return pairAddresses;
}

module.exports = {
    getSwapPairAddresses,
    getLockerPairAddresses,
    getVestInstances
}
'''
'''--- projects/cryptex/index.js ---
const sdk = require("@defillama/sdk");
// const erc20Abi = require("../helper/abis/erc20.json");
// const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const {
    chainIds,
    chainNameById,
    cryptexConfig,
    chainConfigs,
} = require('./cryptex-config');

const { getLockerPairAddresses, getVestInstances } = require('./cryptex-helper');

/*
const fetchTVLByLPLocker = async (locker, chainId, block) => {
    const chainName = chainNameById[chainId];
    let balances = {};
    if (locker.address) {

        const pairs = await getLockerPairAddresses(
            locker.address,
            chainName,
            locker.deployBlock,
            block
        );

        const lpBalances = (await sdk.api.abi.multiCall({
            abi: erc20Abi.balanceOf,
            chain: chainName,
            calls: pairs.map(pair => ({
                target: pair,
                params: [locker.address],
            }))
        })).output;

        let lpPositions = [];
        
        lpBalances.forEach((p) => {
            lpPositions.push({
                balance: p.output,
                token: p.input.target,
            });
        });
        
        await unwrapUniswapLPs(
            balances,
            lpPositions,
            undefined,
            chainName,
            (addr) => `${chainName}:${addr}`
        );
    }

    return balances;
}

const fetchTVLByVestingLocker = async (vesting, chainId, block) => {
    const chainName = chainNameById[chainId];
    let balances = {};
    if (vesting.address) {
        const vestInstances = await getVestInstances(
            vesting.address,
            chainName,
            vesting.deployBlock,
            block
        );

        const instanceBalances = (await sdk.api.abi.multiCall({
            abi: erc20Abi.balanceOf,
            chain: chainName,
            calls: vestInstances.map(item => ({
                target: item.token,
                params: [item.instance],
            }))
        })).output;

        instanceBalances.forEach((item) => {
            sdk.util.sumSingleBalance(balances, `${chainName}:${item.input.target}`, item.output);; 
        })
    }

    return balances;
}

const fetchTVL = (chainId) => {
    return async (timestamp, ethBlock, chainBlocks) => {
        const lockers = (chainConfigs[chainId]?.lockers || []);
        const vesting = (chainConfigs[chainId]?.vesting || {})
        const chainName = chainNameById[chainId];
        const block = chainBlocks[chainName];
        const balances = {};

        const vestingBalances = await fetchTVLByVestingLocker(vesting, chainId, block);

        Object.keys(vestingBalances).forEach((key) => {
            sdk.util.sumSingleBalance(balances, key, vestingBalances[key]);
        });

        for (let i = 0; i < lockers.length; i++) {
            const locker = lockers[i];
            const data = await fetchTVLByLPLocker(locker, chainId, block);

            Object.keys(data).forEach((key) => {
                sdk.util.sumSingleBalance(balances, key, data[key]);
            });
        }

        return balances;
        
    }
}
*/
const fetchStaking = async (timestamp, block, chainBlocks) => {
    let balances = {};
    
    const v1Balance = (await sdk.api.erc20.balanceOf({
        target: cryptexConfig.crxToken,
        owner: cryptexConfig.staking.V1,
        chain: "bsc",
        block: chainBlocks.bsc
    })).output;

    const v2Balance = (await sdk.api.erc20.balanceOf({
        target: cryptexConfig.crxToken,
        owner: cryptexConfig.staking.V2,
        chain: "bsc",
        block: chainBlocks.bsc
    })).output;

    sdk.util.sumSingleBalance(balances, `bsc:${cryptexConfig.crxToken}`, v1Balance);
    sdk.util.sumSingleBalance(balances, `bsc:${cryptexConfig.crxToken}`, v2Balance);

    return balances;
}

// const excludedChains = [chainIds.bsc, chainIds.polygon];
/*
const chainCalcs = Object.keys(chainIds).reduce((acc, key) => {
    const chainId = chainIds[key];
    
    // if (excludedChains.indexOf(chainId) !== -1) return acc;

    const calcs = {
        tvl: fetchTVL(chainId),
    }

    if (chainId === 56) {
        calcs.staking = fetchStaking;
    }

    acc[key] = calcs;
    return acc;
}, {});
*/
module.exports = {
    methodology: "TVL includes locked LP tokens and vested team tokens",
    bsc: {
        tvl: ()=>({}),
        staking: fetchStaking
    }
};
'''
'''--- projects/cryptomate.js ---
const retry = require("./helper/retry");
const axios = require("axios");
async function tvl() {
  let balances = {};
  balances["blockstack"] = 0;
  balances["usd-coin"] = 0;

  let pools = (
    await retry(
      async (bail) =>
        await axios.get("https://api-finance.cryptomate.me/tokens/mainnet/pools")
    )
  ).data.pools;

  const tokensPrice = (
    await retry(
      async (bail) =>
        await axios.get("https://api-finance.cryptomate.me/tokens/mainnet/price")
    )
  ).data;

  const tokensMetadata = (
    await retry(
      async (bail) =>
        await axios.get("https://api-finance.cryptomate.me/tokens/mainnet/metadata")
    )
  ).data.metadata;
  pools = pools.filter(pool =>{

    return tokensMetadata[pool.x_token.split(".")[1]].name in tokensPrice
                              || tokensMetadata[pool.y_token.split(".")[1]].name in tokensPrice;
  })

  pools.map(pool => {
    const [tvlFt1,
           ft1Name,
           ft1Decimals,
           tvlFt2,
           ft2Name,
           ft2Decimals] = tokensMetadata[pool.x_token.split(".")[1]].name in tokensPrice
      ? [pool.tvl_x_token,
        tokensMetadata[pool.x_token.split(".")[1]].name,
        Math.pow(10, tokensMetadata[pool.x_token.split(".")[1]].decimals),
        pool.tvl_y_token,
        tokensMetadata[pool.y_token.split(".")[1]].name,
        Math.pow(10, tokensMetadata[pool.y_token.split(".")[1]].decimals)]
      : [pool.tvl_y_token,
        tokensMetadata[pool.y_token.split(".")[1]].name,
        Math.pow(10, tokensMetadata[pool.y_token.split(".")[1]].decimals),
        pool.tvl_x_token,
        tokensMetadata[pool.x_token.split(".")[1]].name,
        Math.pow(10, tokensMetadata[pool.x_token.split(".")[1]].decimals)];
    const token_type = ft1Name === "wrapped STX"? "blockstack": "usd-coin";
    balances[token_type] += ft1Name === "wrapped STX"? tvlFt1/ ft1Decimals: tokensPrice[ft1Name].price * tvlFt1/ft1Decimals;
    balances[token_type] += ft2Name === "wrapped STX"? tvlFt2/ ft2Decimals: tokensPrice[ft2Name].price * tvlFt2/ft2Decimals;
  })
  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  stacks: {
    tvl,
  },
};
'''
'''--- projects/cryptoswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology: 'The CryptoSwap subgraph and the CryptoSwap factory contract address are used to obtain the balance held in every LP pair.',
  bsc: {
    tvl: calculateUsdUniTvl(
      "0x4136A450861f5CFE7E860Ce93e678Ad12158695C",
      'bsc',
      "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      [
        "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "0xcC4b3EA1F25c8772D390dA1DB507832aBE4a9740"
      ],
      'wbnb'
    )
  },
  start: 1651494114, // Mon May 02 2022 12:21:54
};

'''
'''--- projects/cryptoyieldfocus/abi.json ---
{
    "type": "function",
    "stateMutability": "view",
    "outputs": [
        {
            "type": "address",
            "name": "lpToken",
            "internalType": "contract IBEP20"
        },
        {
            "type": "uint256",
            "name": "allocPoint",
            "internalType": "uint256"
        },
        {
            "type": "uint256",
            "name": "lastRewardBlock",
            "internalType": "uint256"
        },
        {
            "type": "uint256",
            "name": "accCyfPerShare",
            "internalType": "uint256"
        },
        {
            "type": "uint16",
            "name": "depositFeeBP",
            "internalType": "uint16"
        }
    ],
    "name": "poolInfo",
    "inputs": [
        {
            "type": "uint256",
            "name": "",
            "internalType": "uint256"
        }
    ]
}
'''
'''--- projects/cryptoyieldfocus/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { transformAvaxAddress } = require("../helper/portedTokens");
const {addFundsInMasterChef} = require('../helper/masterchef')
const {staking} = require('../helper/staking')
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')

const STAKING_CONTRACT = "0xaB0141F81b3129f03996D0679b81C07F6A24c435";
const cyf = "0x411491859864797792308723Fc417f11BbA18D1b"
const pool2s = [
  "0x8dcb95A8CD13A734A470A1808a2472bD6B3A7A56",
    "0x3437Bf22e261c79328e3B91a1F299e057fA12Cb6",
    "0x0e79B2F73461D682174b00e676b68237eF8583F7",
    "0x60ef780FB54373088b93db6600BbBAA90Eb14243"
]

const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const transformAddress = await transformAvaxAddress();
  await addFundsInMasterChef(balances, STAKING_CONTRACT, chainBlocks.avax, 'avax', transformAddress, abi, [
    cyf,
    ...pool2s
  ])

  return balances;
};

const pool2 = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const transformAddress = await transformAvaxAddress();
  await sumTokensAndLPsSharedOwners(balances, pool2s.map(p=>[p, true]), [STAKING_CONTRACT], chainBlocks.avax, 'avax', transformAddress)

  return balances;
};

module.exports = {
  avalanche: {
    tvl: avaxTvl,
    pool2,
    staking: staking(STAKING_CONTRACT, cyf, 'avax', `avax:${cyf}`)
  },
  methodology:
    "We add the tvl from the farming pools fetching from StakingContract",
};

'''
'''--- projects/crystalvale/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { staking } = require("../helper/staking");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x794C07912474351b3134E6D6B3B7b3b4A07cbAAa) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  dfk: {
    staking: staking("0x6E7185872BCDf3F7a6cBbE81356e50DAFFB002d2", "0x04b9dA42306B023f3572e106B11D82aAd9D32EBb", "dfk", "defi-kingdoms-crystal", 18),
    tvl: calculateUsdUniTvl(
      "0x794C07912474351b3134E6D6B3B7b3b4A07cbAAa",
      "dfk",
      "0xCCb93dABD71c8Dad03Fc4CE5559dC3D89F67a260",
      [
        "0xb57b60debdb0b8172bb6316a9164bd3c695f133a", // AVAX
        "0x3ad9dfe640e1a9cc1d9b0948620820d975c3803a", // USDC
      ],
      "defi-kingdoms"
    ),
  },
};

'''
'''--- projects/crystl/index.js ---
const sdk = require("@defillama/sdk");
const { get } = require("../helper/http");
const { getChainTransform } = require("../helper/portedTokens");
const { unwrapLPsAuto, sumTokens2, } = require("../helper/unwrapLPs");
const { stakings } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const CHAIN_DATA = {
  bsc: {
    name: "bsc",
    id: 56,
  },
  moonbeam: {
    name: "moonbeam",
    id: 1284,
  },
  polygon: {
    name: "polygon",
    id: 137,
    crystl_token: "0x76bF0C28e604CC3fE9967c83b3C3F31c213cfE64",
    masterhealer: "0xeBCC84D2A73f0c9E23066089C6C24F4629Ef1e6d",
    vaulthealer_v1: "0xDB48731c021bdB3d73Abb771B4D7aF0F43C0aC16",
    vaulthealer_v2: "0xD4d696ad5A7779F4D3A0Fc1361adf46eC51C632d",
    apeprice_getter: "0x05D6C73D7de6E02B3f57677f849843c03320681c",
    pools: "https://polygon.crystl.finance/data/pools.json",
  },
  cronos: {
    name: "cronos",
    id: 25,
    crystl_token: "0xCbDE0E17d14F49e10a10302a32d17AE88a7Ecb8B",
    masterhealer: "",
    vaulthealer_v1: "0x4dF0dDc29cE92106eb8C8c17e21083D4e3862533",
    vaulthealer_v2: "",
    apeprice_getter: "0x6993fFaB6FD7c483f33A5E3EFDFEA676425C8F31",
    pools: "https://cronos.crystl.finance/data/pools.json",
  },
};

const wantLockedTotalABI = {
  "inputs": [],
  "name": "wantLockedTotal",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

let _pools

async function getPools(chainData) {
  if (!_pools) _pools = _getPools()
  let p = (await _pools).filter(i => +i.chainId === chainData.id)
  const pObject = p.reduce((acc, i) => ({ ...acc, [i.strategyAddress]: i }), {})
  return Object.values(pObject)

  async function _getPools() {
    const poolsResponse = await Promise.all([
      'https://raw.githubusercontent.com/polycrystal/crystl-config/main/vaults/vaults.json',
      'https://raw.githubusercontent.com/polycrystal/crystl-config/main/vaults/vaultsV3.json',
      'https://raw.githubusercontent.com/polycrystal/crystl-config/main/pools/boostPools.json',
    ].map(get))

    const pools = poolsResponse.flat()

    pools.forEach(i => {
      if (!i.strategyAddress) i.strategyAddress = i.stratAddress
      if (!i.wantAddress) i.wantAddress = i.wantTokenAddress
    })
    return pools
  }
}

async function fetchChain(chainData, block) {
  let balances = {};
  const chain = chainData.name
  const pools = await getPools(chainData)
  const { output: totals } = await sdk.api.abi.multiCall({
    abi: wantLockedTotalABI,
    calls: pools.map(i => ({ target: i.strategyAddress })),
    chain, block,
  })
  const transform = await getChainTransform(chain)
  totals.forEach(({ output }, i) => sdk.util.sumSingleBalance(balances, transform(pools[i].wantAddress), output))
  await unwrapLPsAuto({ balances, chain, block, transformAddress: transform, })
  return balances;
}

async function polygon(timestamp, block, chainBlocks) {
  return fetchChain(CHAIN_DATA.polygon, chainBlocks.polygon);
}

async function cronos(timestamp, block, chainBlocks) {
  return fetchChain(CHAIN_DATA.cronos, chainBlocks.cronos);
}

async function bsc(timestamp, block, chainBlocks) {
  return fetchChain(CHAIN_DATA.bsc, chainBlocks.bsc);
}

async function moonbeam(timestamp, block, chainBlocks) {
  return fetchChain(CHAIN_DATA.moonbeam, chainBlocks.moonbeam);
}

function getTvl(chain, isPool2) {
  return async (_, _b, chainBlocks) => {
    const block = chainBlocks[chain]
    const poolUrl = CHAIN_DATA[chain].pools
    const chainId = CHAIN_DATA[chain].id
    const crystl = CHAIN_DATA[chain].crystl_token.toLowerCase()
    const toa = [];
    (await get(poolUrl)).forEach(i => {
      const token = i.stakingToken.address[chainId].toLowerCase()
      const contractAddress = i.contractAddress[chainId]
      const isStakingToken = token == crystl
      const addToken = isPool2 ? !isStakingToken : isStakingToken
      if (addToken) toa.push([token, contractAddress])
    })

    return sumTokens2({ chain, block, tokensAndOwners: toa, resolveLP: true, })
  }
}

module.exports = {
  polygon: {
    tvl: polygon,
    pool2: getTvl('polygon', true),
    staking: getTvl('polygon', false),
    // pool2: pool2('0x2aBaF1D78F57f87399B6Ffe76b959363a7C67D58', '0xb8e54c9ea1616beebe11505a419dd8df1000e02a', 'polygon'),
    // staking: stakings(['0xe9DA403d5250997e5484260993c3657B2AA0EF8D', '0x284B5F8fB9b25F195929905567f9B626F989A73a',], '0x76bF0C28e604CC3fE9967c83b3C3F31c213cfE64', 'polygon'),
  },
  cronos: {
    tvl: cronos,
    pool2: getTvl('cronos', true),
    staking: getTvl('cronos', false),
    // pool2: pool2('0x6E20BedB36E24DE4262E563E7Fc6b9789A92953D', '0xdEb28305D5c8d5Ce3B3bc5398Ba81012580a5A11', 'cronos'),
    // staking: stakings(['0x4cFcdCBEC3BD1C411fCf16a078b37630F5EA172A', '0x5053337Aa5bb7BE6062422c576F9e43553a1844B',], '0xcbde0e17d14f49e10a10302a32d17ae88a7ecb8b', 'cronos'),
  },
  bsc: {
    tvl: bsc,
  },
  moonbeam: {
    // tvl: moonbeam,
  },
  methodology:
    "Our TVL is calculated from the Total Value Locked in our Vaults, Farms, and Pools.",
};

'''
'''--- projects/cubfinance/abi.json ---
{
    "wantLockedTotal": {
        "inputs": [],
        "name": "wantLockedTotal",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "stateMutability": "view",
        "type": "function"
      },
    "poolLength": {
      "inputs": [],
      "name": "poolLength",
      "outputs": [
        { 
          "internalType": "uint256",
          "name": "", 
          "type": "uint256" 
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "poolInfo": {
      "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "name": "poolInfo",
      "outputs": [
        { "internalType": "address", "name": "lpToken", "type": "address" },
        { "internalType": "uint256", "name": "allocPoint", "type": "uint256" },
        {
          "internalType": "uint256",
          "name": "lastRewardBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "accCubPerShare",
          "type": "uint256"
        },
        { "internalType": "unit16", "name": "depositFeeBP", "type": "uint16" }
      ],
      "stateMutability": "view",
      "type": "function"
    },
	
	"balanceOf": {
      "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
      "name": "balanceOf",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    }
  }
  
  
  
'''
'''--- projects/cubfinance/abi_kingdom.json ---
{
    "wantLockedTotal": {
        "inputs": [],
        "name": "wantLockedTotal",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "stateMutability": "view",
        "type": "function"
      },
    "poolLength": {
      "inputs": [],
      "name": "poolLength",
      "outputs": [
        { 
          "internalType": "uint256",
          "name": "", 
          "type": "uint256" 
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "poolInfo": {
      "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "name": "poolInfo",
      "outputs": [
        { "internalType": "contract IERC20", "name": "want", "type": "address" },
        { "internalType": "uint256", "name": "allocPoint", "type": "uint256" },
        {
          "internalType": "uint256",
          "name": "lastRewardBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "accAQUAPerShare",
          "type": "uint256"
        },
        { "internalType": "address", "name": "strat", "type": "address" }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
  
  

    
'''
'''--- projects/cubfinance/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const abi_kingdom = require('./abi_kingdom.json');
const { unwrapUniswapLPs } = require('../helper/unwrapLPs')

const cubFarmAddress = '0x227e79c83065edb8b954848c46ca50b96cb33e16';
const cubKingdomFarmAddress = '0x2E72f4B196b9E5B89C29579cC135756a00E6CBBd';

const replacements = {
  "0xa8Bb71facdd46445644C277F9499Dd22f6F0A30C": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", //beltBNB -> wbnb
  "0x9cb73F20164e399958261c289Eb5F9846f4D1404": "0x55d398326f99059ff775485246999027b3197955", // 4belt -> usdt
  "0x51bd63F240fB13870550423D208452cA87c44444": "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c", //beltBTC->
  "0xAA20E8Cb61299df2357561C2AC2e1172bC68bc25": "0x2170ed0880ac9a755fd29b2688956bd959f933f8", //beltETH->
}

// Excluded farms/Kingdoms - These are the farms/Kingdoms that include the protocol token.
const farmsExcluded = [29, 27]; // 29 is CUB-BUSD, 27 is CUB-BNB
const kingdomsExcluded = [4]; // this is the CUB Kingdom

const first_pool = 25;
async function tvl(timestamp, ethBlock, chainBlocks) {
  let balances = {};
  // farms
  const poolLength = (await sdk.api.abi.call({
    target: cubFarmAddress,
    abi: abi['poolLength'],
    chain: 'bsc',
    block: chainBlocks.bsc
  })).output;

  const lps = []
  for (let i = first_pool; i < poolLength; i++) {
    if (!farmsExcluded.includes(i)) {
      const poolInfo = (await sdk.api.abi.call({
        target: cubFarmAddress,
        abi: abi['poolInfo'],
        chain: 'bsc',
        params: i,
        block: chainBlocks.bsc
      })).output;

      const strategyAddress = poolInfo['lpToken'];

      const poolTVL = (await sdk.api.abi.call({
        target: strategyAddress,
        params: cubFarmAddress,
        abi: abi['balanceOf'],
        chain: 'bsc',
        block: chainBlocks.bsc
      })).output;

      lps.push({
        token: strategyAddress,
        balance: poolTVL
      })
    }

  }
  // Kingdoms

  const poolLength_kingdom = (await sdk.api.abi.call({
    target: cubKingdomFarmAddress,
    abi: abi_kingdom['poolLength'],
    chain: 'bsc',
    block: chainBlocks.bsc
  })).output;

  for (let i = 0; i < poolLength_kingdom; i++) {
    if (!kingdomsExcluded.includes(i)) {

      const poolInfoKingdom = (await sdk.api.abi.call({
        target: cubKingdomFarmAddress,
        abi: abi_kingdom['poolInfo'],
        chain: 'bsc',
        params: i,
        block: chainBlocks.bsc
      })).output;

      const strategyAddressKingdom = poolInfoKingdom['strat'];
      const wantAddress = poolInfoKingdom['want']

      const wantSymbol = await sdk.api.erc20.symbol(wantAddress, "bsc")

      const poolTVLKingdom = (await sdk.api.abi.call({
        target: strategyAddressKingdom,
        abi: abi_kingdom['wantLockedTotal'],
        chain: 'bsc',
        block: chainBlocks.bsc
      })).output;
      if (wantSymbol.output.endsWith('LP')) {
        lps.push({
          token: wantAddress,
          balance: poolTVLKingdom
        })
      } else {
        let addr = replacements[wantAddress] ?? wantAddress
        sdk.util.sumSingleBalance(balances, 'bsc:' + addr, poolTVLKingdom)
      }
    }
  }

  await unwrapUniswapLPs(balances, lps, chainBlocks.bsc, 'bsc', addr => `bsc:${addr}`)
  return balances;
}

module.exports = {
  methodology: 'Cub Finance has farms and what are call kingdoms on the platform (which are auto-compounding farms of other platforms). All farms are included, except those that pool the CUB token. All kingdoms are included except one, which is the CUB token kingdom. Where the farm is an LP token, that is decomposed into its underlying assets, where it is a single asset farm, that asset is being used.',
  bsc: {
    tvl,
  },
}
'''
'''--- projects/cubo/index.js ---
const { sumTokens, unwrapCrv, } = require('../helper/unwrapLPs')

const chain = 'polygon'
const DAI = '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063'

const treasuryAddress = '0xb495ffc5acd7e2fd909c23c30d182e6719fbe9ec'
const oldDaoContract = '0xb05d0da5253e77a8ad37232e8235c712e10edee8'
const daoContract = '0xb8dc6634b7ac8ad3ae352ab92de51349e7b5e71c'

async function polygon_tvl(timestamp, ethBlock, { polygon: block }) {
  const daoTokens = [DAI,].map(token => [
    [token, oldDaoContract,],
    [token, daoContract,],
  ]).flat()

  const balances = {}
  const transformPolygonAddress = addr => `${chain}:${addr}`
  await sumTokens(
    balances,
    daoTokens,
    block,
    chain,
    transformPolygonAddress
  )
  return balances
}

async function polygon_treasury(timestamp, ethBlock, { polygon: block }) {

  const DRAGON_QUICK = '0xf28164a485b0b2c90639e47b0f377b4a438a16b1'
  const CUBO_TOKEN = '0x381d168DE3991c7413d46e3459b48A5221E3dfE4'
  const MOO_CRV_TriCrypto = '0x5A0801BAd20B6c62d86C566ca90688A6b9ea1d3f'
  const MOO_AM3CRV = '0xAA7C2879DaF8034722A0977f13c343aF0883E92e'
  const AM3CRV = '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171'
  const CRV_TriCrypto = '0xdad97f7713ae9437fa9249920ec8507e5fbb23d'

  const UnwrapTokenMapping = [
    { from: MOO_AM3CRV, unwrapTo: AM3CRV },
    { from: AM3CRV, unwrapTo: AM3CRV },
    { from: MOO_CRV_TriCrypto, unwrapTo: CRV_TriCrypto },
    { from: CRV_TriCrypto, unwrapTo: CRV_TriCrypto },
  ].reduce((mapping, { from, unwrapTo }) => {
    mapping[`${chain}:${from}`] = { type: 'crv', unwrapTo, }
    return mapping
  }, {})

  const treasuryTokens = [DAI, DRAGON_QUICK, CUBO_TOKEN, MOO_CRV_TriCrypto, MOO_AM3CRV,].map(token => [token, treasuryAddress,])

  const balances = {}
  const transformPolygonAddress = addr => `${chain}:${addr}`
  await sumTokens(
    balances,
    treasuryTokens,
    block,
    chain,
    transformPolygonAddress
  )

  // Handle wrapped pools in balances - like curvePools, etc
  for (let i = 0; i < 2; i++) { // since crvTriCrypto contains am3crv, unwrap twice
    for (const token of Object.keys(balances)) {
      if (Object.keys(UnwrapTokenMapping).includes(token) && balances[token] > 0) {
        if (UnwrapTokenMapping[token].type === 'crv') {
          await unwrapCrv(balances, UnwrapTokenMapping[token].unwrapTo, balances[token], block, chain, transformPolygonAddress)
        }
        delete balances[token]// Once unwrapped, remove from balance
      }
    }
  }
  return balances
}

module.exports = {
  polygon: {
    tvl: polygon_tvl,
    treasury: polygon_treasury,
  },
  methodology: `TVL on polygon is sum of all collateralTokens (dai only atm) provided to mint nodes`,
}

'''
'''--- projects/cupid/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const cupidchef = "0xBCec0e5736614D8Bd05502A240526836bA0bBFc5"
const cupid = "0xD4C000c09bfeF49ABBd5c3728fcec3a42c68eBa1"
const cupidFtmLP = "0x5853da628f4655d7d80f80501ab6b6faa241e38b"
const cupidUsdcLP = "0xd30ce73f7294be94f9d76d308d5400f3483e369f";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, cupidchef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [cupid, cupidFtmLP, cupidUsdcLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(cupidchef, cupid, "fantom"),
      pool2: pool2Exports(cupidchef, [cupidFtmLP, cupidUsdcLP], "fantom"),
  },
  
} 
'''
'''--- projects/curve/abi.json ---
{
    "get_registry": {
        "name": "get_registry",
        "outputs": [
            {
                "type": "address",
                "name": ""
            }
        ],
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "gas": 1061
    },
    "pool_list": {
        "stateMutability": "view",
        "type": "function",
        "name": "pool_list",
        "inputs": [
            {
                "name": "arg0",
                "type": "uint256"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "address"
            }
        ],
        "gas": 2217
    },
    "pool_count": {
        "stateMutability": "view",
        "type": "function",
        "name": "pool_count",
        "inputs": [],
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "gas": 2138
    },
    "get_n_coins": {
        "stableswap": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_n_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256[2]"
                }
            ],
            "gas": 1521
        },
        "stableFactory": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_n_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "gas": 2699
        },
        "crypto": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_n_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "gas": 2834
        },
        "cryptoFactory": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_n_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "gas": 2834
        }
    },
    "get_coins": {
        "stableswap": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address[8]"
                }
            ],
            "gas": 12102
        },
        "stableFactory": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address[4]"
                }
            ],
            "gas": 9164
        },
        "crypto": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address[8]"
                }
            ],
            "gas": 22975
        },
        "cryptoFactory": {
            "stateMutability": "view",
            "type": "function",
            "name": "get_coins",
            "inputs": [
                {
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address[2]"
                }
            ]
        }
    },
    "get_id_info": {
        "name": "get_id_info",
        "outputs": [
            {
                "type": "address",
                "name": "addr"
            },
            {
                "type": "bool",
                "name": "is_active"
            },
            {
                "type": "uint256",
                "name": "version"
            },
            {
                "type": "uint256",
                "name": "last_modified"
            },
            {
                "type": "string",
                "name": "description"
            }
        ],
        "inputs": [
            {
                "type": "uint256",
                "name": "arg0"
            }
        ],
        "stateMutability": "view",
        "type": "function",
        "gas": 12168
    }
}
'''
'''--- projects/curve/contracts.json ---
{
  "ethereum": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "CRV": "0xd533a949740bb3306d119cc777fa900ba034cd52",
    "veCRV": "0x5f3b5dfeb7b28cdbd7faba78963ee202a494e2a2",
    "wrapped": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "metapoolBases": {
      "3CRV": "0x6c3f90f043a72fa612cbac8115ee7e52bde6e490",
      "crvRenWSBTC": "0x075b1bb99792c9e1041ba13afef80c91a1e70fb3"
    },
    "yearnTokens": {
      "yDAI1": "0xc2cb1040220768554cf699b0d863a3cd4324ce32",
      "yUSDT1": "0xe6354ed5bc4b393a5aad09f21c46e101e692d447",
      "yDAI2": "0x16de59092dae5ccf4a1e6439d611fd0653f0bd01",
      "yUSDC": "0xd6ad7a6750a7593e092a9b218d66c0a814a3436e",
      "yUSDT2": "0x83f798e925bcd4017eb265844fddabb448f1707d",
      "ycDAI": "0x99d1fa417f94dcd62bfe781a1213c092a47041bc",
      "ycUSDC": "0x9777d7e2b60bb01759d0e2f8be2095df444cb07e",
      "ycUSDT": "0x1be5d71f2da660bfdee8012ddc58d024448a0a59"
    },
    "creamTokens": {
      "cyDAI": "0x8e595470ed749b85c6f7669de83eae304c2ec68f",
      "cyUSDC": "0x76eb2fe28b36b3ee97f3adae0c69606eedb2a37c",
      "cyUSDT": "0x48759f220ed983db51fa7a8c0d2aab8f3ce4166a"
    },
    "sdTokens": {
      "sdCrv": "0xd1b5651e55d4ceed36251c61c50c889b36f6abb5",
      "sdANGLE": "0x752b4c6e92d96467fe9b9a2522ef07228e00f87c",
      "sdFXS": "0x402f878bdd1f5c66fdaf0fababcf74741b68ac36",
      "sdBAL": "0xf24d8651578a55b0c119b9910759a351a3458895"
    },
    "fxTokens": {
      "ibKRW": {
        "address": "0x95dfdc8161832e4ff7816ac4b6367ce201538253",
        "currency": "KRW"
      }
    }
  },
  "polygon": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
    "metapoolBases": {
      "am3CRV": "0x19793b454d3afc7b454f206ffe95ade26ca6912c",
      "4eur-f": "0xad326c253a84e9805559b73a08724e11e49ca651"
    },
    "blacklist": [
      "0xd6d9bc8e2b894b5c73833947abdb5031cc7a4894",
      "0xa7fd7d83e2d63f093b71c5f3b84c27cff66a7802",
      "0xacfbe6979d58b55a681875fc9adad0da4a37a51b"
    ]
  },
  "arbitrum": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
    "metapoolBases": {
      "2CRV": "0xbf7e49483881c76487b0989cd7d9a8239b20ca41"
    }
  },
  "aurora": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0xc9bdeed33cd01541e1eed10f90519d2c06fe3feb",
    "metapoolBases": {
      "3CRV": "0xbf7e49483881c76487b0989cd7d9a8239b20ca41"
    }
  },
  "avax": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
    "metapoolBases": {
      "av3CRV": "0xb0d2eb3c2ca3c6916fab8dcbf9d9c165649231ae"
    }
  },
  "fantom": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
    "metapoolBases": {
      "2CRV": "0x27e611fd27b276acbd5ffd632e5eaebec9761e40",
      "g3CRV": "0xd4f94d0aaa640bbb72b5eec2d85f6d114d81a88e"
    },
    "creamTokens": {
      "iDAI": "0x04c762a5df2fa02fe868f25359e0c259fb811cfe",
      "iUSDC": "0x328a7b4d538a2b3942653a9983fda3c12c571141",
      "iFUSDT": "0x70fac71debfd67394d1278d98a29dea79dc6e57a",
      "scUSDC": "0xe45ac34e528907d0a0239ab5db507688070b20bf",
      "scDAI": "0x8d9aed9882b4953a0c9fa920168fa1fdfa0ebe75",
      "scFUSDT": "0x02224765bc8d54c21bb51b0951c80315e1c263f9",
      "scMIM": "0x90b7c21be43855afd2515675fc307c084427404f"
    },
    "yearnTokens": {}
  },
  "harmony": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
    "metapoolBases": {
      "3CRV": "0xc5cfada84e902ad92dd40194f0883ad49639b023"
    }
  },
  "optimism": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0x4200000000000000000000000000000000000006",
    "metapoolBases": {
      "3CRV": "0x061b87122ed14b9526a813209c8a59a633257bab"
    }
  },
  "xdai": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d",
    "metapoolBases": {
      "3CRV": "0x1337bedc9d22ecbe766df105c9623922a27963ec"
    }
  },
  "moonbeam": {
    "addressProvider": "0x0000000022D53366457F9d5E68Ec105046FC4383",
    "gasTokenDummy": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    "wrapped": "0x4244eb811d6e0ef302326675207a95113db4e1f8",
    "metapoolBases": {}
  }
}

'''
'''--- projects/curve/index.js ---
const { staking } = require("../helper/staking");
const utils = require("../helper/utils");

async function eth() {
  let staked = await utils.fetchURL("https://api.curve.fi/api/getTVL"); //base stable pools
  let factory = await utils.fetchURL(
    "https://api.curve.fi/api/getPools/ethereum/factory"
  ); //stable facto pools
  let factoryCrypto = await utils.fetchURL(
    "https://api.curve.fi/api/getFactoryCryptoPools/ethereum"
  ); //facto crypto pools
  let baseCrypto = await utils.fetchURL(
    "https://api.curve.fi/api/getTVLCrypto"
  ); //base crypto pools

  return (
    staked.data.data.tvl +
    factory.data.data.tvl +
    factoryCrypto.data.data.tvl +
    baseCrypto.data.data.tvl
  );
}

async function polygon() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLPolygon");
  return tvl.data.data.tvl;
}

async function aurora() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLAurora");
  return tvl.data.data.tvl;
}

async function fantom() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLFantom");
  return tvl.data.data.tvl;
}

async function xdai() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLxDai");
  return tvl.data.data.tvl;
}

async function arbitrum() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLArbitrum");
  return tvl.data.data.tvl;
}

async function avax() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLAvalanche");
  return tvl.data.data.tvl;
}

async function harmony() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLHarmony");
  return tvl.data.data.tvl;
}

async function optimism() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLOptimism");
  return tvl.data.data.tvl;
}

async function moonbeam() {
  const tvl = await utils.fetchURL("https://api.curve.fi/api/getTVLMoonbeam");
  return tvl.data.data.tvl;
}

async function fetch() {
  return (
    (await eth()) +
    (await polygon()) +
    (await fantom()) +
    (await xdai()) +
    (await arbitrum()) +
    (await avax()) +
    (await harmony()) +
    (await optimism())
  );
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  fantom: {
    fetch: fantom
  },
  ethereum: {
    staking: staking(
      "0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2",
      "0xD533a949740bb3306d119CC777fa900bA034cd52"
    ),
    fetch: eth
  },
  polygon: {
    fetch: polygon
  },
  xdai: {
    fetch: xdai
  },
  arbitrum: {
    fetch: arbitrum
  },
  avalanche: {
    fetch: avax
  },
  moonbeam: {
    fetch: moonbeam
  },
  harmony: {
    fetch: harmony
  },
  optimism: {
    fetch: optimism
  },
  aurora: {
    fetch: aurora
  },
  fetch
};

'''
'''--- projects/curve/onchain.js ---
const { unwrapYearn, sumTokensSharedOwners } = require("../helper/unwrapLPs");
const { getChainTransform } = require("../helper/portedTokens");
const { staking } = require("../helper/staking.js");
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const creamAbi = require("../helper/abis/cream.json");
const contracts = require("./contracts.json");
const { requery } = require("../helper/requery");
const { default: axios } = require("axios");
const retry = require("async-retry");
const { getBlock } = require("../helper/getBlock");
const chains = [
  "ethereum", //-200M
  "polygon", //-40M
  "arbitrum", //G
  "aurora", //G
  "avax", //-30M
  "fantom", //-80M
  "optimism", //-6M
  "xdai", //G
  "moonbeam"
]; // Object.keys(contracts);
const registryIds = {
  stableswap: 0,
  stableFactory: 3,
  crypto: 5,
  cryptoFactory: 6
};

async function getPools(block, chain) {
  const registries = (await sdk.api.abi.multiCall({
    block,
    chain,
    calls: Object.values(registryIds).map(r => ({
      params: r
    })),
    target: contracts[chain].addressProvider,
    abi: abi.get_id_info
  })).output.map(r => r.output.addr);

  const poolCounts = (await sdk.api.abi.multiCall({
    block,
    chain,
    calls: registries.map(r => ({
      target: r
    })),
    abi: abi.pool_count
  })).output;

  const pools = {};
  for (let i = 0; i < Object.values(registryIds).length; i++) {
    pools[Object.keys(registryIds)[i]] = (await sdk.api.abi.multiCall({
      calls: [...Array(Number(poolCounts[i].output)).keys()].map(n => ({
        target: poolCounts[i].input.target,
        params: [n]
      })),
      block,
      chain,
      abi: abi.pool_list
    })).output;
  }

  let allPools = {}
  Object.entries(pools).map(([key, list])=>{
    pools[key] = list.filter(p=>{
      if(allPools[p.output] === undefined){
        allPools[p.output] = true
        return true
      } else {
        return false
      }
    })
  })

  return pools;
}

function aggregateBalanceCalls(coins, nCoins, poolList, registry) {
  let calls = [];
  if (registry == "cryptoFactory") {
    coins.map((coin, i) =>
      [...Array(Number(coin.output.length)).keys()].map(n =>
        calls.push({
          params: [poolList[i].output],
          target: coin.output[n]
        })
      )
    );
  } else {
    coins.map((coin, i) =>
      [...Array(Number(nCoins[i].output[0])).keys()].map(n =>
        calls.push({
          params: [poolList[i].output],
          target: coin.output[n]
        })
      )
    );
  }
  return calls;
}

async function fixGasTokenBalances(poolBalances, block, chain) {
  for (let i = 0; i < poolBalances.output.length; i++) {
    if (
      poolBalances.output[i].success == false &&
      poolBalances.output[i].input.target.toLowerCase() ==
        contracts[chain].gasTokenDummy
    ) {
      const ethBalance = (await sdk.api.eth.getBalance({
        target: poolBalances.output[i].input.params[0],
        block,
        chain
      })).output;

      poolBalances.output[i].success = true;
      poolBalances.output[i].output = ethBalance;
      poolBalances.output[i].input.target = contracts[chain].wrapped;
    }
  }
}

async function fixWrappedTokenBalances(balances, block, chain, transform) {
  if ("yearnTokens" in contracts[chain]) {
    for (let token of Object.values(contracts[chain].yearnTokens)) {
      if (token in balances) {
        await unwrapYearn(balances, token, block, chain, transform);
      }
    }
  }

  if ("creamTokens" in contracts[chain]) {
    const creamTokens = Object.values(contracts[chain].creamTokens);
    await unwrapCreamTokens(balances, block, chain, creamTokens, transform);
  }

  if ("sdTokens" in contracts[chain]) {
    await unwrapSdTokens(balances, contracts[chain].sdTokens, chain);
  }

  const stDOT = "moonbeam:0xfa36fe1da08c89ec72ea1f0143a35bfd5daea108"
  if(stDOT in balances){
    balances["bsc:0x7083609fce4d1d8dc0c979aab8c869ea2c873402"] = BigNumber(balances[stDOT]).times(1e8).toFixed(0)
    delete balances[stDOT]
  }
}

async function unwrapCreamTokens(
  balances,
  block,
  chain,
  creamTokens,
  transform
) {
  const [exchangeRates, underlyingTokens] = await Promise.all([
    sdk.api.abi.multiCall({
      calls: creamTokens.map(t => ({
        target: t
      })),
      abi: creamAbi.exchangeRateStored,
      block,
      chain
    }),
    sdk.api.abi.multiCall({
      calls: creamTokens.map(t => ({
        target: t
      })),
      abi: creamAbi.underlying,
      block,
      chain
    })
  ]);
  for (let i = 0; i < creamTokens.length; i++) {
    if (!(creamTokens[i] in balances)) continue;
    const underlying = underlyingTokens.output[i].output;
    const balance = BigNumber(balances[creamTokens[i]])
      .times(exchangeRates.output[i].output)
      .div(1e18)
      .toFixed(0);
    sdk.util.sumSingleBalance(balances, transform(underlying), balance);
    delete balances[creamTokens[i]];
    delete balances[`${chain}:${creamTokens[i]}`];
  }
}

function deleteMetapoolBaseBalances(balances, chain) {
  for (let token of Object.values(contracts[chain].metapoolBases)) {
    if (!(token in balances || `${chain}:${token}` in balances)) continue;
    delete balances[token];
    delete balances[`${chain}:${token}`];
  }
}

function mapGaugeTokenBalances(calls, chain) {
  const mapping = {
    // token listed in coins() mapped to gauge token held in contract
    //"0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171": "0x19793b454d3afc7b454f206ffe95ade26ca6912c", // maybe not? 4 0s poly
    "0x7f90122bf0700f9e7e1f688fe926940e8839f353": {
      to: "0xbf7e49483881c76487b0989cd7d9a8239b20ca41",
      pools: ["0x30df229cefa463e991e29d42db0bae2e122b2ac7"],
      chains: []
    }, // need a pool conditional - only for (1) ['0x30dF229cefa463e991e29D42DB0bae2e122B2AC7']
    "0xd02a30d33153877bc20e5721ee53dedee0422b2f": {
      to: "0xd4f94d0aaa640bbb72b5eec2d85f6d114d81a88e",
      pools: [],
      chains: []
    },
    "0x1337bedc9d22ecbe766df105c9623922a27963ec": {
      to: "0x5b5cfe992adac0c9d48e05854b2d91c73a003858",
      pools: [],
      chains: ["avax"]
    },
    "0x7f90122bf0700f9e7e1f688fe926940e8839f353": {
      to: "0xbF7E49483881C76487b0989CD7d9A8239B20CA41",
      pools: [],
      chains: ["arbitrum"]
    },
    "0x27e611fd27b276acbd5ffd632e5eaebec9761e40": {
      to: "0x8866414733F22295b7563f9C5299715D2D76CAf4",
      pools: [],
      chains: ["fantom"]
    },
    "0xd02a30d33153877bc20e5721ee53dedee0422b2f": {
      to: "0xd4f94d0aaa640bbb72b5eec2d85f6d114d81a88e",
      pools: [],
      chains: ["fantom"]
    }
  };

  return calls.map(function(c) {
    let target = c.target;
    if (
      c.target.toLowerCase() in mapping &&
      (mapping[c.target.toLowerCase()].pools.includes(
        c.params[0].toLowerCase()
      ) ||
        mapping[c.target.toLowerCase()].chains.includes(chain))
    ) {
      target = mapping[c.target.toLowerCase()].to;
    }
    return { target, params: c.params };
  });
}

async function unwrapSdTokens(balances, sdTokens, chain) {
  const apiData = (await retry(
    async bail => await axios.get("https://lockers.stakedao.org/api/lockers")
  )).data.map(t => ({
    address: t.tokenReceipt.address.toLowerCase(),
    usdPrice: t.tokenPriceUSD,
    decimals: t.tokenReceipt.decimals
  }));

  for (let token of Object.values(sdTokens)) {
    if (token in balances) {
      const tokenInfo = apiData.filter(t => t.address == token)[0];

      sdk.util.sumSingleBalance(
        balances,
        "usd-coin",
        balances[token] * tokenInfo.usdPrice / 10 ** tokenInfo.decimals
      );
      delete balances[token];
      delete balances[`${chain}:{token}`];
    }
  }
}

async function handleUnlistedFxTokens(balances, chain) {
  if ("fxTokens" in contracts[chain]) {
    const tokens = Object.values(contracts[chain].fxTokens);
    for (let token of tokens) {
      if (token.address in balances) {
        const [{ data: rate }, { output: decimals }] = await Promise.all([
          retry(
            async bail =>
              await axios.get(
                `https://api.exchangerate.host/convert?from=${token.currency}&to=USD`
              )
          ),
          sdk.api.erc20.decimals(token.address, chain)
        ]);

        sdk.util.sumSingleBalance(
          balances,
          "usd-coin",
          balances[token.address] * rate.result / 10 ** decimals
        );
        delete balances[token.address];
        delete balances[`${chain}:${token.address}`];
      }
    }
  }
  return;
}

async function unwrapPools(
  balances,
  block,
  chain,
  transform,
  poolList,
  registry
) {
  const [{ output: nCoins }, { output: coins }] = await Promise.all([
    sdk.api.abi.multiCall({
      calls: poolList.map(p => ({
        target: p.input.target,
        params: [p.output]
      })),
      block,
      chain,
      abi: abi.get_n_coins[registry]
    }),
    sdk.api.abi.multiCall({
      calls: poolList.map(p => ({
        target: p.input.target,
        params: p.output
      })),
      block,
      chain,
      abi: abi.get_coins[registry]
    })
  ]);

  let calls = aggregateBalanceCalls(coins, nCoins, poolList, registry);
  calls = mapGaugeTokenBalances(calls, chain);

  let poolBalances = await sdk.api.abi.multiCall({
    calls,
    block,
    chain,
    abi: "erc20:balanceOf"
  });
  requery(poolBalances, chain, block, "erc20:balanceOf");
  await fixGasTokenBalances(poolBalances, block, chain);

  sdk.util.sumMultiBalanceOf(balances, poolBalances, false, transform);

  await fixWrappedTokenBalances(balances, block, chain, transform);
  await handleUnlistedFxTokens(balances, chain);
  deleteMetapoolBaseBalances(balances, chain);

  return balances;
} // node test.js projects/curve/index.js

function tvl(chain) {
  return async (_t, _e, chainBlocks) => {
    let balances = {};
    const transform = await getChainTransform(chain);
    const poolList = await getPools(chainBlocks[chain], chain);
    const block = await getBlock(_t, chain, chainBlocks, true)

    for (let registry of Object.keys(poolList)) {
      await unwrapPools(
        balances,
        block,
        chain,
        transform,
        poolList[registry],
        registry
      );
    }

    return balances;
  };
}

const chainTypeExports = chains => {
  let exports = chains.reduce(
    (obj, chain) => ({ ...obj, [chain]: { tvl: tvl(chain) } }),
    {}
  );
  exports.ethereum["staking"] = staking(
    contracts.ethereum.veCRV,
    contracts.ethereum.CRV
  );

  exports.harmony = {
    tvl: async (ts, ethB, chainB) => {
      const block = await getBlock(ts, "harmony", chainB, true)
      const balances = {}
      await sumTokensSharedOwners(balances, 
        ["0xef977d2f931c1978db5f6747666fa1eacb0d0339", "0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f"],
        ["0xC5cfaDA84E902aD92DD40194f0883ad49639b023"],
        block,
        "harmony",
        addr=>`harmony:${addr}`
      )
      return balances
    }
  }
  return exports;
};

module.exports = chainTypeExports(chains);

'''
'''--- projects/cvi/index.js ---
const sdk = require("@defillama/sdk");
const { staking, stakings } = require("../helper/staking");
const { pool2s, pool2 } = require("../helper/pool2");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { transformPolygonAddress } = require("../helper/portedTokens");

/*** Ethereum Addresses ***/
const stakingContract = "0xDb3130952eD9b5fa7108deDAAA921ae8f59beaCb";
const GOVI = "0xeeaa40b28a2d1b0b08f6f97bb1dd4b75316c6107";

const stakingPool2Contracts = [
  "0x936Dd3112a9D39Af39aDdA798503D9E7E7975Fb7",
  "0xcF05a60bCBC9c85cb2548DAfDC444c666A8F466a",
];

const lpPool2Addresses = [
  //WETH_GOVI_UNIV2
  "0x1EE312A6d5fe7b4B8c25f0a32fCA6391209eBEBF",
  //WETH_GOVI_SLP
  "0x7E6782E37278994d1e99f1a5d03309B4b249d919",
];

const ETHPlatform = "0x5005e8Dc0033E78AF80cfc8d10f5163f2FcF0E79";

const platformLiquidityContracts = [
  //USDTPlatform
  "0xe0437BeB5bb7Cf980e90983f6029033d710bd1da",
  //USDCPlatform
  "0x2167EEFB9ECB52fB6fCf1ff8f7dAe6F0121F4fBC",
  //ETHVIPlatform
  "0x0E0DA40101D8f6eB1b1d6b0215327e8452e0Bc60",
  //Liquidity Mining ETHVOL-USDC
  "0xa9f8754A34AeD9EfaB3d543ce199B4AaF6a506c7",
  //Liquidty Mining COTI-ETH
  "0xe6e5220291CF78b6D93bd1d08D746ABbC115C64b",
];

const USDT = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const ETHVOL_USDC_UNIV2 = "0x197e99bD87F98DFde461afE3F706dE36c9635a5D";
const WETH_COTI_UNIV2 = "0xA2b04F8133fC25887A436812eaE384e32A8A84F2";

/*** Polygon Addresses ***/
const stakingContracts_polygon = [
  "0x399b649002277d7a3502C9Af65DE71686F356f33",
  "0xD013FFC6Ed3B2c773051a3b83E763dF782D7b31f",
];

const GOVI_polygon = "0x43df9c0a1156c96cea98737b511ac89d0e2a1f46";

const stakingPool2Contract_polygon =
  "0x27792cDa195d07ffb36E94e253D67361661a16Dc";
const lpPool2Address_polygon = "0x1dAb41a0E410C25857F0f49B2244Cd089AB88DE6";

const platformLiquidityContracts_polygon = [
  //usdtPlatPolygon
  "0x88D01eF3a4D586D5e4ce30357ec57B073D45ff9d",
  //usdcPlatPolygon
  "0x3863D0C9b7552cD0d0dE99fe9f08a32fED6ab72f",
  //liquidty Mining CVOL-USDC
  "0xEA7b8DC5615e049417C80C795eA652556971c423",
];
const USDT_Polygon = "0xc2132d05d31c914a87c6611c10748aeb04b58e8f";
const USDC_Polygon = "0x2791bca1f2de4661ed88a30c99a7a9449aa84174";
const CVOL_USDC_QLP = "0x1dd0095a169e8398448A8e72f15A1868d99D9348";

/*** Arbitrum Addresses ***/
const stakingContract_arbitrum = "0xDb3e7deAb380B43189A7Bc291fa2AFeAA938dCc3";
const GOVI_arbitrum = "0x07e49d5de43dda6162fa28d24d5935c151875283";

async function ethTvl(timestamp, block) {
  const balances = {};

  const ethBalance = (
    await sdk.api.eth.getBalance({
      target: ETHPlatform,
      block
    })
  ).output;

  sdk.util.sumSingleBalance(balances, WETH, ethBalance);

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [USDT, false],
      [USDC, false],
      [ETHVOL_USDC_UNIV2, true],
      [WETH_COTI_UNIV2, true],
    ],
    platformLiquidityContracts,
    block
  );

  return balances;
}

async function polygonTvl(timestamp, block, chainBlocks) {
  const balances = {};

  const transformAddress = await transformPolygonAddress();
  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [USDT_Polygon, false],
      [USDC_Polygon, false],
      [CVOL_USDC_QLP, true],
    ],
    platformLiquidityContracts_polygon,
    chainBlocks.polygon,
    "polygon",
    transformAddress
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(stakingContract, GOVI),
    pool2: pool2s(stakingPool2Contracts, lpPool2Addresses),
    tvl: ethTvl,
  },
  polygon: {
    staking: stakings(stakingContracts_polygon, GOVI_polygon, "polygon", GOVI),
    pool2: pool2(
      stakingPool2Contract_polygon,
      lpPool2Address_polygon,
      "polygon"
    ),
    tvl: polygonTvl,
  },
  arbitrum: {
    staking: staking(stakingContract_arbitrum, GOVI_arbitrum, "arbitrum", GOVI),
  },
  methodology:
    "Counts liquidity on the Platforms and Staking seccions through Platfrom and Staking Contracts",
};

'''
'''--- projects/cyberdog-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const masterchef = "0x61bA12f76F7993115Fcf86Fd6147008A6790589D";
const cbrdog = "0x7a6a832eB5F58245F7d75eD980cED849D69A98FD";

module.exports = {
    ...masterChefExports(masterchef, "cronos", cbrdog, false)
}
'''
'''--- projects/cyberfantasyfembots/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0x844cC08183589D0D669fdCC223476a0FE9712F55";
const token = "0xe29E3D9Fa721dFA10ba879fbf0E947425dA611cB";

module.exports = {
    ...masterChefExports(masterchef, "polygon", token, false)
}
'''
'''--- projects/cybertime/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accCTFPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/cybertime/index.js ---
const abi = require("./abi.json");
const { pool2s } = require("../helper/pool2");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformBscAddress } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const pool2FarmContracts = [
  //CTFFarmV1
  "0x750c8Ee365b1EA4dAf114Bd73Aeb31fc5B742D8B",
  //CTFFarmV2
  "0x1F8f4492bd0D8004E323e0014f76c99e54D1242b",
  //CFTFarmV3 Old
  "0x08985ff15dE1ed66dDBfD08a2705A8B3612A61Fd",
  //CFTFarmV3
  "0xCE997537498793d25dAb0F289e161DB26914275A",
];

const lpPool2 = [
  //CFT-WBNB Old Cake LP
  "0x4709932b8a9a76187879856e8Fd13eadC6C68B08",
  //NFTL-WBNB Old Cake LP
  "0xab5F212D945c6109BE17A61a5598e2dD6F896Bdf",
  //NFTL-WBNB New0 Cake LP
  "0xf41395C4e748813c98E17263Ac0cCE15B54d5983",
  //CFT-WBNB New0 Cake LP
  "0x584B93f109B83D7A01DF4fF0d450915B97FAd790",
  //NFTL-WBNB New1 Cake LP
  "0x07c3e0B62A62133eaB8c5e759904350d254B9672",
  //CFT-WBNB New1 Cake LP
  "0x15CD39e9e494177f13A5Db7c36883BE1a5D95eD8",
  //CFT-WBNB V3 Ape LP
  "0x51535A61787EcbBCbAeFb2eEe0E2D4FeE2D57607",
  //CFT-WBNB V3 Old Ape LP
  "0x6f8daEC3f0764B19db745112D297bbea1E6D96e3",
];

const NFTL_V1 = "0x2f7b4c618dc8e0bba648e54cdadce3d8361f9816";
const CTF_V1 = "0x299bac24c8ad5635586fde6619eff7891a6c8969";

const NFTL_V2 = "0xE5904E9816b309d3eD4d061c922f5aa8f3B24C92";
const CTF_V2 = "0x410319197d3394652B7ddDc669E58fbe30B56090";

const CTF_V3 = "0x655A46cd88e18a338ECE048228a388c25BFdA9f3";
const CTF_V3_old = "0x398302C08EcF94AA6E55386182E50e335405a956";

const farms = [
  //NFTLFarmV1
  "0x57Bc258169b03047D7778c41014c9cF7779ACA76",
  //NFTLFarmV2
  "0x45Eec2D2f9b01D91eCC685945A904C895CAbB7a3",
  //CFTFarmV3 Old
  "0x08985ff15dE1ed66dDBfD08a2705A8B3612A61Fd",
  //CFTFarmV3
  "0xCE997537498793d25dAb0F289e161DB26914275A",
];

const Staking = async (chainBlocks) => {
  const balances = {};

  let transformAddress = await transformBscAddress();
  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [NFTL_V1, false],
      [CTF_V1, false],
      [NFTL_V2, false],
      [CTF_V2, false],
      [CTF_V3, false],
    ],
    farms,
    chainBlocks["bsc"],
    "bsc",
    transformAddress
  );
  
  return balances;
};

const bscTvl = async (chainBlocks) => {
  const balances = {};

  let transformAddress = await transformBscAddress();
  for (const farm of farms) {
    await addFundsInMasterChef(
      balances,
      farm,
      chainBlocks["bsc"],
      "bsc",
      transformAddress,
      abi.poolInfo,
      [CTF_V2],
      true,
      true,
      CTF_V3
    );
  }

  return balances;
};

module.exports = {
  timetravel: true,
  bsc: {
    staking: Staking,
    pool2: pool2s(pool2FarmContracts, lpPool2, "bsc"),
    tvl: bscTvl,
  },
  methodology:
    "We count liquidity on the Farms threw their Contracts",
};

'''
'''--- projects/cyclefinance/abi.json ---
{
    "LPtoken": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "address"
            }
        ],
        "name": "LPtoken",
        "inputs": []
    },
    "balanceLPinSystem": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "balanceLPinSystem",
        "inputs": []
    },
    "stakingToken": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "",
                "internalType": "contract IERC20"
            }
        ],
        "name": "stakingToken",
        "inputs": []
    }
}
'''
'''--- projects/cyclefinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const coreRewards = "0xE006716Ae6cAA486d77084C1cca1428fb99c877B";
const avaxRewards = "0x6140D3ED2426cbB24f07D884106D9018d49d9101";
const CYCLE = "0x81440C939f2C1E34fc7048E518a637205A632a74";

const vaults = [
  //Pangolin Rewards AVAX/PNG
  "0xccB42c29285754f441Dc6A4461De011efCD09F75",

  //Pangolin Rewards AVAX/ETH (closed)
  //"0xfB6e16A64ccC23848eB2951B1068a27B1d06791d",

  //Gondola Rewards AVAX/GDL
  "0x47de256F890d3707aad74A89C6b532eEAaAe54BA",

  //Penguin Rewards AVAX/PEFI
  "0x1ee6ed952E71cd3d1D473a596a6761B1a1D704e0",

  //Penguin Rewards PEFI/DAI
  "0xB0B55192aA1539f06eBAC509bf714261358A997a",

  //Olive Rewards AVAX/OLIVE
  "0xCD1eee22a0Ec06f5D169753cc1B1CC0C57513B24",

  //Baguette Rewards WAVAX/BAG (closed)
  //"0x8D6D3131B7d01F4acE7c74E7EA999d301524B9F8",

  //Pangolin Rewards AVAX/VSO (closed)
  //"0x1e8864b21C980AaB05F3566B74aB1Aa9ec7dE948",

  //Pangolin Rewards PNG/VSO (closed)
  //"0xbD87717eAAE4F13dD5b55734a46fA49C519f9404",

  //Avaware Rewards AVAX/AVE
  "0x950bF2fb93c4Cb8CaBc7A08eb8A70Ea3c4A2bcC2",

  //Olive Rewards AVAX/HUSKY (closed)
  //"0x661FD8d23433E38f009FBc1e79910Fc0cAb2bC6D",

  //Trader Joe Rewards AVAX/JOE
  "0xB19bFa46148636C97B0C00A68B24647f60C1995D",

  //Trader Joe Rewards AVAX/ETH (closed)
  //"0xe10F1567f0354F3d7394CaA42B4e30d0f19AF907",

  //Trader Joe Rewards AVAX/SNOB
  "0x16aB820ABB64BcE04d15de945c18c0CC31822514",

  //Trader Joe Rewards DAI/USDT (closed)
  //"0x36EBd37960F37Ffb8EDDc6165b304dbB362Cd112",

  //Olive Rewards AVAX/CYCLE
  "0x01181D0E43c1A77f111C7968BE5B7e40F1D6e106",

  //Trader Joe Rewards AVAX/SHERPA (closed)
  //"0xE80504EF78403AD1753b7DE62653c09c0f9de584",

  //Avaware Rewards AVE/CYCLE
  "0x4762baf391Ca1A18f71320a6A09bCD2067EA32cA",

  //Avaware Rewards AVE/SHERPA
  "0x60B9Fa802C2Bf85203b22c2aC0A68948632bf1f1",

  //Avaware Rewards AVE/YAK
  "0xaA76c50B510A668F48E612f980C45DC9691b647A",

  //Pangolin Rewards AVAX/XAVA
  "0x13C9810d32bA9B7e51FeEf9aeF3b3D479efCfACC",

  //Pangolin Rewards AVAX/WETH.e
  "0x056b234bE3Aaa56506d484e17721Db0098e52474",

  //Trader Joe Rewards AVAX/WETH.e
  "0xc2C215d9263592665993eEfc77976e70590f0DF1",

  //Trader Joe Rewards DAI.e/USDT.e (Closed)
  //"0x313b8d1ca1aAfae10273cdfCFA083b9a0E272d0E",

  //Pangolin Rewards AVAX/DAI.e
  "0x4Fbb4C6dBD68A609780C79A18C04e5Ac52dD622C",

  //Pangolin Rewards AVAX/USDT.e
  "0xD65B47A5b6B6A07CFf8798AB54F136A0f05ADFF6",

  //Pangolin Rewards AVAX/QI
  "0x7754Be84f3305A12558e631e5df2A4DF474Cc046",

  //Trader Joe Rewards AVAX/USDT.e
  "0x1058B8eAC995968DE18d6a8baf36B3F6536a2Ca1",

  //Trader Joe Rewards AVAX/DAI.e
  "0x226C4E8758D37A151Fd01a46505A1D3C0dba3a24",

  //Trader Joe Rewards USDT.e/DAI.e
  "0x49D4663dBC92f4AfD0BE0459Ceb20F8e9F5a7118",

  //Trader Joe Rewards AVAX/LINK.e
  "0xd7d9151D1cB958F55cAc94196D03Ba267bc7d0dB",

  //Trader Joe Rewards AVAX/WBTC.e
  "0xc732a6aA22B60cEAA5c2193EF81D008658a20623",

  //Trader Joe Rewards AVAX/YAK
  "0x970C251E85CE1cE0b714de9510135a5B9Cd80b02",

  //Trader Joe Rewards AVAX/USDC.e
  "0xb5a23bdF77a8926E732ce4b1F0885e7bB3b2Dfe9",

  //Trader Joe Rewards USDC.e/DAI.e
  "0x32bdcdDA8eb152759c2F27D71e1F8d242D46D9Ca",
];

/*** Staking of native token CYCLE and CYCLE/AVAX LP TVL Portion ***/
const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const staking_lpToken = (
    await sdk.api.abi.call({
      abi: abi.stakingToken,
      target: coreRewards,
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output;

  const cycleLpOrTokens = [
    [staking_lpToken, true],
    [CYCLE, false],
  ];

  const transformAddress = await transformAvaxAddress();

  for (const lpOrToken of cycleLpOrTokens) {
    await sumTokensAndLPsSharedOwners(
      balances,
      [lpOrToken],
      (lpOrToken[1] == true) ? [coreRewards] : [avaxRewards],
      chainBlocks["avax"],
      "avax",
      transformAddress
    );
  }
  return balances;
};

/*** vaults TVL portion ***/
const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const lpTokens = (
    await sdk.api.abi.multiCall({
      abi: abi.LPtoken,
      calls: vaults.map((vault) => ({
        target: vault,
      })),
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output.map((lp) => lp.output);

  const lpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: abi.balanceLPinSystem,
      calls: vaults.map((vault) => ({
        target: vault,
      })),
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output.map((lpb) => lpb.output);

  const lpPositions = [];
  for (let index = 0; index < vaults.length; index++) {
    lpPositions.push({
      token: lpTokens[index],
      balance: lpTokens_bal[index],
    });
  }

  const transformAddress = await transformAvaxAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["avax"],
    "avax",
    transformAddress
  );

  return balances;
};

module.exports = {
  doublecounted: true,
  misrepresentedTokens: true,
  avalanche: {
    tvl: avaxTvl,
    staking
  },
  methodology: `We add liquidity that is on the VAULTS threw their contracts and the portion of staking the native token (CYCLE) 
    && CYCLE/AVAX LP by coreRewards and avaxRewards contracts respectivly`,
};

'''
'''--- projects/cyclone/contracts.json ---
{
    "ethereum": {
        "pool2": {
            "address": "0xdc71bc29d12960a3ee5452fac6f033a1b8e756fb",
            "token": "0x37d9c7f451e5c619a7d4ca01e06761eb7dae6f89"
        },
        "latte": {
            "address": "0xd619c8da0a58b63be7fa69b4cc648916fe95fa1b",
            "token": ""
        },
        "doppio": {
            "address": "0x52609307f2f6c43b7df63364ef65718d299ac246",
            "token": ""
        },
        "arabica": {
            "address": "0xb6e9ea062a7719846bc9e3e3ae8712e74faad376",
            "token": ""
        },
        "espresso": {
            "address": "0xa38b6742cef9573f7f97c387278fa31482539c3d",
            "token": "0xdac17f958d2ee523a2206206994597c13d831ec7"
        },
        "coldbrew": {
            "address": "0x09f03488291063a8f3c67d2aab7002419d11c113",
            "token": "0x77777feddddffc19ff86db637967013e6c6a116c"
        }
    }, 
    "bsc": {
        "pool2": {
            "address": "0x92a737097d711bec4c31351997254e98e5f0d430",
            "token": "0xecf30fbecfa642012f54212a3be92eef1e48edac"
        },
        "staking": {
            "address": "0xD90a6BF8439EF7214cF00Da83E926068b6a507eC",
            "token": "0x810ee35443639348adbbc467b33310d2ab43c168"
        },"C3PO": {
            "address": "0x66b5e322dc31f8c7a33ffd23975163795f8d16c7",
            "token": ""
        },"BB8": {
            "address": "0x79459751F6882868D1299Bfa412428488b434541",
            "token": "0x9678e42cebeb63f23197d726b29b1cb20d0064e5"
        },"R2D2": {
            "address": "0xbe19d541389c9d3e03efc08f3d5008e8c9cc42a5",
            "token": "0xe9e7cea3dedca5984780bafc599bd69add087d56"
        }
    }, 
    "iotex": {
        "pool2": {
            "address": "0xacf00a84559f536ba64064a4c73b74698013ef36",
            "token": "0x1381b170681074fedaf1c4e35be1880bc4e85c4a"
        },
        "staking": {
            "address": "0xb80d026a7faa8c35def0e430f9b36163ac949c19",
            "token": "0x4d7b88403aa2f502bf289584160db01ca442426c"
        },
        "zm": {
            "address": "0xfa886fe8d27b284525974ddc6e2c0cb858a57251",
            "token": "0xf87aed04889a1dd0159d9c22b0d57b345ab16ddd"
        },
        "mcn": {
            "address": "0x0ad3bee1ee270339c921fb20686bfd90245ee5d8",
            "token": "0x3fe04320885e6124231254c802004871be681218"
        },
        "busd": {
            "address": "0xdfbdf24b8019ef44f321de54d456ddd216e73163",
            "token": "0x84abcb2832be606341a50128aeb1db43aa017449"
        }
    },
    "polygon": {
        "pool2": {
            "address": "0xa8c187d8773bc9e49a10554715ff49bdcf39d55d",
            "token": "0x6eA88502BC127EF1a7f45fAC6B7168fc0633Ba51"
        },
        "octagon": {
            "address": "0x3E2c1b4dfA868A6ffD8CdC20D7BFa9Abb4462284",
            "token": "0x831753dd7087cac61ab5644b308642cc1c33dc13"
        },
        "pentagon": {
            "address": "0x87059fDff1dC655ACf8652bA530d89f38de22f16",
            "token": ""
        },
        "hexagon": {
            "address": "0xb5AEE5f2743A9f4abcE9C964d1530e3E96725Be7",
            "token": "0x2791bca1f2de4661ed88a30c99a7a9449aa84174"
        }
    }
}
'''
'''--- projects/cyclone/index.js ---
const sdk = require("@defillama/sdk");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const { getBlock } = require("../helper/getBlock");
const { sumSingleBalance } = require("@defillama/sdk/build/generalUtil");
const { pool2 } = require("./../helper/pool2");
const { staking } = require(".././helper/staking.js");
const {
  sumLPWithOnlyOneTokenOtherThanKnown,
} = require("./../helper/unwrapLPs");

const iotx = "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69";
const mcn = "iotex:0x3fe04320885e6124231254c802004871be681218";
const wiotx = "0xA00744882684C3e4747faEFD68D283eA44099D03";

function tvl(chain, gasToken) {
  return async (timestamp, block, chainBlocks) => {
    block = await getBlock(timestamp, chain, chainBlocks);
    const transform = await getChainTransform(chain);
    let balances = {};

    for (let contract of Object.entries(contracts[chain])) {
      if (contract[0] == "pool2" || contract[0] == "staking") {
        continue;
      } else if (contract[1].token == "") {
        const balance = (
          await sdk.api.eth.getBalance({
            target: contract[1].address,
            block,
            chain,
          })
        ).output;
        await sumSingleBalance(balances, gasToken, balance);
      } else {
        const balance = (
          await sdk.api.erc20.balanceOf({
            target: contract[1].token,
            owner: contract[1].address,
            block,
            chain,
          })
        ).output;
        await sumSingleBalance(balances, transform(contract[1].token), balance);
      }
    }

    if (iotx in balances) {
      balances["iotex"] = balances[iotx] / 10 ** 18;
      delete balances[iotx];
    }
    if (mcn in balances) {
      balances["mcn-ventures"] = balances[mcn] / 10 ** 18;
      delete balances[mcn];
    }

    return balances;
  };
}

async function iotexPool2(timestamp, block, chainBlocks) {
  block = await getBlock(timestamp, "iotex", chainBlocks);
  const balances = {};
  let a = await sumLPWithOnlyOneTokenOtherThanKnown(
    balances,
    contracts.iotex.pool2.token,
    contracts.iotex.pool2.address,
    "0x4d7b88403aa2f502bf289584160db01ca442426c",
    block,
    "iotex"
  );
  return { iotex: balances[wiotx] / 10 ** 18 };
}

module.exports = {
  iotex: {
    tvl: tvl("iotex", "iotex"),
    pool2: iotexPool2,
    staking: staking(
      contracts.iotex.staking.address,
      contracts.iotex.staking.token,
      "iotex",
      "cyclone-protocol",
      18
    ),
  },
  ethereum: {
    tvl: tvl("ethereum", "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"),
    pool2: pool2(
      contracts.ethereum.pool2.address,
      contracts.ethereum.pool2.token,
      "ethereum"
    ),
  },
  bsc: {
    tvl: tvl("bsc", "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"),
    pool2: pool2(contracts.bsc.pool2.address, contracts.bsc.pool2.token, "bsc"),
    staking: staking(
      contracts.bsc.staking.address,
      contracts.bsc.staking.token,
      "bsc",
      "cyclone-protocol",
      18
    ),
  },
  polygon: {
    tvl: tvl("polygon", "polygon:0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270"),
    pool2: pool2(
      contracts.polygon.pool2.address,
      contracts.polygon.pool2.token,
      "polygon"
    ),
  },
};

'''
'''--- projects/cykura/index.js ---
const retry = require("../helper/retry");
const axios = require("axios");

async function fetch() {
  return (
    await retry(
      async () =>
        await axios.get(
          "https://asia-south1-cyclos-finance.cloudfunctions.net/stats"
        )
    )
  ).data.TVL;
};

module.exports = {
  timetravel: false,
  fetch,
};

'''
'''--- projects/dad/index.js ---
const axios = require("axios");
const sdk = require('@defillama/sdk');
const utils = require('../helper/utils');
const { unwrapDefiboxLiquidity, eosTokenString } = require("../defibox/utils");

const EOSFLARE_ENDPOINT = "https://api.eosflare.io";

async function getAccountBalances( balances, account ) {
  const response = await axios.default.post(EOSFLARE_ENDPOINT + "/v1/eosflare/get_account", {account});

  // sum EOS
  const { balance_total, tokens } = response.data.account;
  const EOS = { symbol: "4,EOS", contract: "eosio.token" }
  sdk.util.sumSingleBalance(balances, eosTokenString(EOS), Math.floor(balance_total * 10 ** 4) );

  // sum alt tokens
  for ( const token of tokens ) {
    if ( !token.balance ) continue;
    if ( token.contract == "lptoken.defi" ) await unwrapDefiboxLiquidity( balances, token ); // unwrap LP tokens
    else sdk.util.sumSingleBalance(balances, eosTokenString(token), Math.floor(token.balance * token.precision) );
  }
}

async function getSimplePrice( id, currency = "usd" ) {
  const response = await utils.fetchURL(`https://api.coingecko.com/api/v3/simple/price?ids=${id}&vs_currencies=${currency}`)
  if ( response.data ) return response.data[id].usd;
  return 0;
}

async function computeTvl( balances ) {
  let tvl = 0;
  const coingecko = {
    "eos:4,DAPP@dappservices": "dapp",
    'eos:4,EOS@eosio.token': "eos",
  }
  for ( const key of Object.keys(balances) ) {
    const [ chain, extended_symbol ] = key.split(":");
    const [ symbol, contract ] = extended_symbol.split("@");
    const [ precision, symbol_code ] = symbol.split(",");
    const coingecko_id = coingecko[key];
    if ( !coingecko_id ) continue; // ignore tokens that are not listed on CoinGecko
    const price = await getSimplePrice(coingecko_id);
    tvl += (balances[key] / 10 ** precision) * price;
  }
  return tvl;
}

async function timeout(ms) {
  return new Promise(resolve => setTimeout(() => resolve(), ms))
}

// https://superdad.finance/
// Staking Pools
async function fetch() {
  const balances = {};
  const accounts = [
    "depositpool1",
    "depositpool2",
    "depositpool3", // contains Defibox LP tokens (BOXVP)
    "depositpool4", // contains Defibox LP tokens (BOXWQ)
    "depositpool5",
    "depositpl111" // contains Defibox LP tokens (BOXAUO)
  ]
  for ( const account of accounts ) {
    await getAccountBalances(balances, account);
    await timeout(3000); // timeout 3s (EOSFlare rate limits)
  }
  return await computeTvl( balances );
}

module.exports = {
  methodology: `DAD TVL is achieved by querying token balances & unwrapping Defibox liquidity tokens from DAD's vaults via https://eosflare.io/api and https://defibox.io/.`,
  fetch
}
'''
'''--- projects/daomaker/contracts.json ---
{
    "chains": [
        "ethereum",
        "bsc",
        "polygon",
        "fantom",
        "celo"
    ],
    "stakingContractEth": "0xd07e86f68C7B9f9B215A3ca3E79E74Bf94D6A847",
    "stakingTokenEth": "0x0f51bb10119727a7e5eA3538074fb341F56B09Ad"
}
'''
'''--- projects/daomaker/index.js ---
const sdk = require("@defillama/sdk");
const { stakings } = require("../helper/staking");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const axios = require("axios");

async function fetchBalances(exports, contracts, transform, chainBlocks, chain) {
    if (!contracts[chain]) return 0;

    const balances = await sdk.api.abi.multiCall({
        calls: Object.keys(contracts[chain]).map(c => ({
            target: contracts[chain][c].tokenAddress,
            params: [ contracts[chain][c].tokenHolder ]
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain
    });

    sdk.util.sumMultiBalanceOf(exports, balances, false, transform);
};

// node test.js projects/daomaker/index.js
function tvl(chain) {
    return async (timestamp, block, chainBlocks) => {
        const balances = {};
        const transform = await getChainTransform(chain);

        const vestingContracts = (await axios.get("https://api.daomaker.com/get-all-vesting-contracts")).data;
        const clientVesting = {};
        for (const vestingContract of vestingContracts) {
            if (!clientVesting[vestingContract.chain_name]) {
                clientVesting[vestingContract.chain_name] = {};
            }
            clientVesting[vestingContract.chain_name][vestingContract.vesting_smart_contract_address] = {
                tokenHolder: vestingContract.vesting_smart_contract_address,
                tokenAddress: vestingContract.token_address
            };
        }

        await fetchBalances(
            balances, 
            clientVesting, 
            transform, 
            chainBlocks, 
            chain
        );

        return balances;
    };
};

const chainTVLObject = contracts.chains.reduce(
    (agg, chain) => ({ ...agg, [chain]: {tvl: tvl(chain) }}), {}
);

chainTVLObject.ethereum.staking = stakings(
    [ contracts.stakingContractEth ], 
    contracts.stakingTokenEth
);

module.exports = {
    ...chainTVLObject
};
'''
'''--- projects/daoventures/abi.json ---
{
  "getAllPoolInUSD": {
    "inputs": [],
    "name": "getAllPoolInUSD",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "getAllPoolInUSDProxy": {
    "inputs": [
      { "internalType": "bool", "name": "includeVestedILV", "type": "bool" }
    ],
    "name": "getAllPoolInUSD",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "getTotalValueInPool": {
    "inputs": [],
    "name": "getTotalValueInPool",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/daoventures/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const DAOvault = {
  Elon: "0x2D9a136cF87D599628BCBDfB6C4fe75Acd2A0aA8",
  Cuban: "0x2AD9F8d4c24652Ea9F8A954F7E1FdB50a3bE1DFD",
  Citadel: "0x8fE826cC1225B03Aa06477Ad5AF745aEd5FE7066",
  FAANG: "0x9ee54014e1E6CF10fD7E9290FdB6101fd0d5D416",
  Metaverse: "0x5b3ae8b672a753906b1592d44741f71fbd05ba8c",
  //MoneyPrinter: "0x3DB93e95c9881BC7D9f2C845ce12e97130Ebf5f2",
};

//timestamp, ethereumBlock, chainBlocks
async function tvl(timestamp, ethereumBlock, chainBlocks) {
  let block = await sdk.api.util.lookupBlock(timestamp);

  let [ElonTVL, CubanTVL, CitadelTVL, FAANGTVL, MetaverseTVL] =
    await Promise.all([
      sdk.api.abi.call({
        target: DAOvault.Elon, // contract address
        abi: abi.getAllPoolInUSD, // erc20:methodName
        block: block[block], // Current block number
      }),

      sdk.api.abi.call({
        target: DAOvault.Cuban, // contract address
        abi: abi.getAllPoolInUSD, // erc20:methodName
        block: block[block], // Current block number
      }),
      sdk.api.abi.call({
        target: DAOvault.Citadel, // contract address
        abi: abi.getAllPoolInUSD, // erc20:methodName
        block: block[block], // Current block number
      }),

      sdk.api.abi.call({
        target: DAOvault.FAANG, // contract address
        abi: abi.getTotalValueInPool, // erc20:methodName
        block: block[block], // Current block number
      }),

      sdk.api.abi.call({
        target: DAOvault.Metaverse, // contract address
        abi: abi.getAllPoolInUSDProxy, // erc20:methodName
        block: block[block], // Current block number
        params: [false],
      }),
    ]);

  ElonTVL = parseInt(ElonTVL.output) / 10 ** 6;
  CitadelTVL = parseInt(CitadelTVL.output) / 10 ** 6;
  CubanTVL = parseInt(CubanTVL.output) / 10 ** 6;
  MetaverseTVL = parseInt(MetaverseTVL.output) / 10 ** 18;
  FAANGTVL = parseInt(FAANGTVL.output) / 10 ** 18;

  const result = {
    "Elon Vault": ElonTVL,
    "Citadel Vault": CitadelTVL,
    "Cuban Vault": CubanTVL,
    "Metaverse Vault": MetaverseTVL,
    "FAANG Vault": FAANGTVL,
  };

  let balances = 0;
  for (const prop in result) {
    balances += result[prop];
  }
  //await unwrapYearn(balances);
  return { "usd-coin": balances };
}

// node test.js projects/daoventures/index.js
async function stakingTvl(timestamp, block) {
  let balances = {};
  let { output: balance } = await sdk.api.erc20.balanceOf({
    target: "0x77dce26c03a9b833fc2d7c31c22da4f42e9d9582",
    owner: "0x1193c036833B0010fF80a3617BBC94400A284338",
    block,
  });

  sdk.util.sumSingleBalance(
    balances,
    "0x77dce26c03a9b833fc2d7c31c22da4f42e9d9582",
    balance
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: tvl,
    staking: stakingTvl,
  },
};

'''
'''--- projects/darkcrypto/abi.json ---
{
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token0": {
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "token1": {
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "wantLockedTotal": {
    "inputs": [],
    "name": "wantLockedTotal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "want",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardTime",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "strategy",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "earlyWithdrawFee",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "earlyWithdrawTime",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/darkcrypto/farm-cronos.json ---
{
    "tokens": {
        "DARK": "0x83b2AC8642aE46FC2823Bc959fFEB3c1742c48B5",
        "SKY": "0x9D3BBb0e988D9Fb2d55d07Fe471Be2266AD9c81c",
        "CRO": "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23"
    },
    "farms": [
        {
            "masterChef": "0x42B652A523367e7407Fb4BF2fA1F430781e7db8C",
            "reward": "SKY",
            "pools": [
                {
                    "id": 0,
                    "lpToken": "0xA4AA24B8e855052071Df60E174219e6c8FEe45a3",
                    "token0": "DARK",
                    "token1": "CRO",
                    "rewardToken": "SKY"
                },
                {
                    "id": 1,
                    "lpToken": "0xaa0845ee17e4f1d4f3a8c22cb1e8102bacf56a77",
                    "token0": "SKY",
                    "token1": "CRO",
                    "rewardToken": "SKY"
                }
            ]
        }
    ]
}
'''
'''--- projects/darkcrypto/farm-utils.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');
const farmCronos = require('./farm-cronos.json');

const farmLPBalance = async (
  chain,
  block,
  masterChef,
  lpToken,
  token0,
  token1,
) => {
  const balances = (
    await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: [
        {
          target: token0,
          params: [lpToken],
        },
        {
          target: token1,
          params: [lpToken],
        },
        {
          target: lpToken,
          params: [masterChef],
        },
      ],
      block,
      chain: chain,
    })
  ).output;
    
    const lpTotalSuply = (
    await sdk.api.abi.call({
      target: lpToken,
      abi: 'erc20:totalSupply',
      chain: chain,
      block,
    })
  ).output;
  const token0Locked = (balances[2].output * balances[0].output) / lpTotalSuply;
  const token1Locked = (balances[2].output * balances[1].output) / lpTotalSuply;
  return [
    { token: `${chain}:${token0}`, locked: token0Locked },
    { token: `${chain}:${token1}`, locked: token1Locked },
  ];
};

const farmLocked = async (block) => {
  const balances = {};
  const tokens = farmCronos.tokens;

  const allPools = farmCronos.farms
    .map((t) => {
      return t.pools.map((pool) => {
        return Object.assign(pool, {
          masterChef: t.masterChef,
        });
      });
    })
    .reduce((acc, current) => [...acc, ...current], []);
  const promises = allPools.map((item) => {
    return  farmLPBalance(
          'cronos',
          block,
          item.masterChef,
          item.lpToken,
          tokens[item.token0],
          tokens[item.token1],
        );
  });

  const data = await Promise.all(promises);
  data.forEach((farm) => {
    farm.forEach((item) => {
      balances[item.token] = new BigNumber(balances[item.token] || 0)
        .plus(item.locked || 0)
        .toFixed(0);
    });
  });

  return balances;
};

module.exports = {
  farmLocked,
};

'''
'''--- projects/darkcrypto/index.js ---
const { addFundsInMasterChef } = require("../helper/masterchef");
const { stakingUnknownPricedLP } = require("../helper/staking");
const { pool2BalanceFromMasterChef } = require("../helper/pool2");
const farmUtils = require("./farm-utils");
const vaultUtils = require("./vault-utils")

const sdk = require("@defillama/sdk");
const dark = "0x83b2AC8642aE46FC2823Bc959fFEB3c1742c48B5";
const sky = "0x9D3BBb0e988D9Fb2d55d07Fe471Be2266AD9c81c";
const krx = "0xf0681bb7088ac68a62909929554aa22ad89a21fb";
const krx_usdc = "0x9504a7cEd300B2C79e64FC63f368fC27011Fe916";
const masterchefDark = "0x28d81863438F25b6EC4c9DA28348445FC5E44196";
const boardroom = "0x2e7d17ABCb9a2a40ec482B2ac9a9F811c12Bf630";

async function tvl(timestamp, block, chainBlocks) {
  let balances = await vaultUtils.vaultLocked(block, "cronos");

  //DARK POOL
  await addFundsInMasterChef(
    balances,
    masterchefDark,
    chainBlocks.cronos,
    "cronos",
    (addr) => `cronos:${addr}`,
    undefined,
    [dark, krx],
    true,
    true,
    dark,
  );
/*
  //get staking KRX token
  let krxBalance = await stakingUnknownPricedLP(
    masterchefDark,
    krx,
    "cronos",
    krx_usdc
  )(timestamp, block, chainBlocks);
  sdk.util.sumSingleBalance(
    balances,
    "cronos:0xc21223249CA28397B4B6541dfFaEcC539BfF0c59",
    krxBalance["cronos:0xc21223249CA28397B4B6541dfFaEcC539BfF0c59"]
  );

  

  //BoardRoom
  let boardroomBalance = await stakingUnknownPricedLP(
    boardroom,
    sky,
    "cronos",
    "0xaA0845EE17e4f1D4F3A8c22cB1e8102baCf56a77"
  )(timestamp, block, chainBlocks);
  sdk.util.sumSingleBalance(
    balances,
    "cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
    boardroomBalance["cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23"]
  );*/

  return balances;
}
async function pool2(timestamp, block, chainBlocks) {
  // SKY POOL
  const farmTvl = await farmUtils.farmLocked(chainBlocks["cronos"]);
  let balances = {};

  //add CRO balance in LP pool
  sdk.util.sumSingleBalance(
    balances,
    "cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
    farmTvl["cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23"]
  );

  //add Dark and Sky balance in LP pool
  sdk.util.sumSingleBalance(
    balances,
    "cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
    farmTvl["cronos:0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23"],
  );

  return balances;
}

async function vault(timestamp, block, chainBlocks){
  return await vaultUtils.vaultLocked(chainBlocks.cronos, 'cronos')
}

module.exports = {
  doublecounted: true,
  cronos: {
    tvl:vault,
    pool2: pool2,
    staking: stakingUnknownPricedLP(
      boardroom,
      sky,
      "cronos",
      "0xaA0845EE17e4f1D4F3A8c22cB1e8102baCf56a77"
    ),
    
  },
};

'''
'''--- projects/darkcrypto/vault-utils.js ---
const VAULT_ADDR = "0x66D586eae9B30CD730155Cb7fb361e79D372eA2a"
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const abi = require("./abi.json")
const farmLPBalance = async (
  chain,
  block,
  lpToken,
  lpLocked,
  token0,
  token1,
  pid
) => {
  const balances = (
    await sdk.api.abi.multiCall({
      abi: "erc20:balanceOf",
      calls: [
        {
          target: token0,
          params: [lpToken],
        },
        {
          target: token1,
          params: [lpToken],
        }
      ],
      block,
      chain: chain,
    })
  ).output;

  const lpTotalSuply = (
    await sdk.api.abi.call({
      target: lpToken,
      abi: "erc20:totalSupply",
      chain: chain,
      block,
    })
  ).output;
  const token0Locked = (lpLocked * balances[0].output) / lpTotalSuply;
  const token1Locked = (lpLocked * balances[1].output) / lpTotalSuply;
  const unknowPricePid = [0, 1];
  let whiteListToken = ["0x97749c9B61F878a880DfE312d2594AE07AEd7656"]
  whiteListToken = whiteListToken.map(addr=>addr.toLowerCase())
  if (unknowPricePid.includes(pid)) {
    if(whiteListToken.includes(token0.toLowerCase())){
      return [
        { token: `${chain}:${token0}`, locked: new BigNumber(token0Locked || 0).multipliedBy(2) },
      ]
    }
    return [
      { token: `${chain}:${token1}`, locked: new BigNumber(token1Locked || 0).multipliedBy(2) },
    ]
  }

  return [
    { token: `${chain}:${token0}`, locked: token0Locked },
    { token: `${chain}:${token1}`, locked: token1Locked },
  ];
};

const vaultLocked = async (block, chain) => {
  const balances = {};
  const { output: poolLength } = await sdk.api.abi.call({
    abi: abi["poolLength"],
    target: VAULT_ADDR,
    chain,
  })
  let arr = []
  for (let i = 0; i < poolLength; i++) {
    arr.push(i)
  }

  let poolInfos =
    await sdk.api.abi.multiCall({
      abi: abi["poolInfo"],
      calls: arr.map(pid => {
        return {
          target: VAULT_ADDR,
          params: [pid]
        }
      }),
      block,
      chain: chain,
    })
      .then(d => d.output).then(d => d.map(poolInfo => poolInfo.output));
  // console.log(poolInfos)
  let wanLockedTotals =
    await sdk.api.abi.multiCall({
      abi: abi["wantLockedTotal"],
      calls: poolInfos.map(poolInfo => {
        return {
          target: poolInfo.strategy,
          params: []
        }
      }),
      block,
      chain: chain,
    })
      .then(d => d.output).then(d => d.map(lock => lock.output));
  let token0Infos =
    await sdk.api.abi.multiCall({
      abi: abi["token0"],
      calls: poolInfos.map(poolInfo => {
        return {
          target: poolInfo.want,
          params: []
        }
      }),
      block,
      chain: chain,
    })
      .then(d => d.output).then(d => d.map(lock => lock.output));
  let token1Infos =
    await sdk.api.abi.multiCall({
      abi: abi["token1"],
      calls: poolInfos.map(poolInfo => {
        return {
          target: poolInfo.want,
          params: []
        }
      }),
      block,
      chain: chain,
    })
      .then(d => d.output).then(d => d.map(lock => lock.output));
  const promises = arr.map((i) => {
    return farmLPBalance(
      "cronos",
      block,
      poolInfos[i].want,
      wanLockedTotals[i],
      token0Infos[i],
      token1Infos[i],
      i
    );
  });
  const data = await Promise.all(promises);
  data.forEach((farm) => {
    farm.forEach((item) => {
      balances[item.token] = new BigNumber(balances[item.token] || 0)
        .plus(item.locked || 0)
        .toFixed(0);
    });
  });

  return balances;
};
module.exports = {
  vaultLocked,
};

'''
'''--- projects/darkmatter/index.js ---
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { unwrapLPsAuto } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");
const { pool2 } = require('../helper/pool2')

const chef = "0x7C36c64811219CF9B797C5D9b264d9E7cdade7a4"
const dmd = "0x90E892FED501ae00596448aECF998C88816e5C0F"
const dmdFtmLP = "0xF10F0EeB144Eb223DD8Ae7d5dd7f3327E63A3C94"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, undefined, [dmd, dmdFtmLP])
  await unwrapLPsAuto({ balances, block: chainBlocks.fantom, chain: 'fantom', transformAddress})
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom:{
    staking: staking(chef, dmd, "fantom"),
    pool2: pool2(chef, dmdFtmLP, "fantom"),
    tvl
  },
}
'''
'''--- projects/darkness/index.js ---
const { GraphQLClient, gql } = require('graphql-request')
const { toUSDTBalances } = require('../helper/balances');
const { getBlock } = require('../helper/getBlock');
const { stakingPricedLP } = require("../helper/staking");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { farmLPBalance } = require("./utils");

const masterChef = "0x63Df75d039f7d7A8eE4A9276d6A9fE7990D7A6C5";
const d3usd = "0x36B17c6719e09d98bB020608E9F79a0647d50A70";
const ness = "0xe727240728c1a5f95437b8b50afdd0ea4ae5f0c8";
const nessroom = "0xA93248C548Ac26152F3b4F201C9101f4e032074e";
const ness_cro = "0xbfAAB211C3ea99A2Db682fbc1D9a999861dCba2D";

async function getLiquidity(block) {
  // delayed by around 5 mins to allow subgraph to update
  block -= 25;
  var endpoint = `https://subgraph.darkness.finance/subgraphs/name/cronos/swapprod`
  var graphQLClient = new GraphQLClient(endpoint)
  var query = gql`
  query get_tvl($block: Int) {
    balancers(
      first: 5,
      block: { number: $block }
    ) {
      totalLiquidity,
      totalSwapVolume
    }
  }
  `;
  const results = await graphQLClient.request(query, {
    block
  })
  return results.balancers[0].totalLiquidity;
}

async function tvl(timestamp, block, chainBlocks) {
  let balances = toUSDTBalances(await getLiquidity(await getBlock(timestamp, "cronos", chainBlocks)));

  //Farm MEERKAT-LP on mm.finance
  await addFundsInMasterChef(
    balances,
    masterChef,
    chainBlocks.cronos,
    "cronos",
    (addr) => `cronos:${addr}`,
    undefined,
    [d3usd, ness], //Ignore D3USD because it has been counted in liquidity.
    true,
    true,
    ness,
  );

  return balances;
}

async function pool2(timestamp, block, chainBlocks) {
  const cro = "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23";

  return farmLPBalance(
    'cronos',
    block,
    masterChef,
    ness_cro,
    cro,
    ness,
  );
}

module.exports = {
  methodology: `DarkNess TVL is pulled from the DarkNess subgraph and MEERKAT-LP (on mm.finance) locked in MasterChef (0x63Df75d039f7d7A8eE4A9276d6A9fE7990D7A6C5) , excluded D3USD that has been counted in liquidity`,
  cronos: {
    tvl: tvl,
    pool2: pool2,
    staking: stakingPricedLP(
      nessroom,
      ness,
      "cronos",
      ness_cro,
      "darkness-share"
    ),
  }
};

'''
'''--- projects/darkness/utils.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');
const farmLPBalance = async (
    chain,
    block,
    masterChef,
    lpToken,
    token0,
    token1,
  ) => {
    const balances = (
      await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: [
          {
            target: token0,
            params: [lpToken],
          },
          {
            target: token1,
            params: [lpToken],
          },
          {
            target: lpToken,
            params: [masterChef],
          },
        ],
        block,
        chain: chain,
      })
    ).output;
      
      const lpTotalSuply = (
      await sdk.api.abi.call({
        target: lpToken,
        abi: 'erc20:totalSupply',
        chain: chain,
        block,
      })
    ).output;
    const token0Locked = new BigNumber(balances[2].output * balances[0].output).div(new BigNumber(lpTotalSuply));
    const token1Locked = new BigNumber(balances[2].output * balances[1].output).div(new BigNumber(lpTotalSuply));
    const result = {};
    result[`${chain}:${token0}`] = token0Locked.toFixed(0);
    result[`${chain}:${token1}`] = token1Locked.toFixed(0);
    return result;
  };

  module.exports = {
    farmLPBalance,
  };
'''
'''--- projects/darumadao/index.js ---
const sdk = require("@defillama/sdk")
const { default: BigNumber } = require("bignumber.js")
const { toUSDTBalances } = require('../helper/balances')

const chain = 'godwoken'
const STAKING_ADDRESS = '0x31A7D9c604C87F7aA490A350Ef8DF170dC2233AA'
const DRM_ADDRESS = '0x81E60A955DC8c4d25535C358fcFE979351d102B5'
const USDC_ADDRESS = '0xc3b946c53e2e62200515d284249f2a91d9df7954'
const DRM_USDC_LP_ADDRESS = '0x268aaeed47d031751db1cbba50930fe2991f0ed0'

async function tvl(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  const [
    { output: drmTokensStaked },
    { output: drmTokensLP },
    { output: usdcTokensLP },
    { output: usdcDecimals },
    { output: drmDecimals },
  ] = await Promise.all([
    await sdk.api.erc20.balanceOf({ owner: STAKING_ADDRESS, target: DRM_ADDRESS, block, chain }),
    await sdk.api.erc20.balanceOf({ owner: DRM_USDC_LP_ADDRESS, target: DRM_ADDRESS, block, chain }),
    await sdk.api.erc20.balanceOf({ owner: DRM_USDC_LP_ADDRESS, target: USDC_ADDRESS, block, chain }),
    await sdk.api.erc20.decimals(USDC_ADDRESS, chain),
    await sdk.api.erc20.decimals(DRM_ADDRESS, chain),
  ])

  const tokenPrice = BigNumber(usdcTokensLP).dividedBy(10 ** usdcDecimals).multipliedBy(10 ** drmDecimals).dividedBy(drmTokensLP)
  return toUSDTBalances(BigNumber(drmTokensStaked).multipliedBy(tokenPrice).dividedBy(10 ** drmDecimals).toFixed(0))
}

module.exports = {
  misrepresentedTokens: true,
  methodology: `Finds TVL by querying DRM contract for sDRM (Staked DRM) supply and the DRM price. TVL = sdrmSupply * drmPrice`,
  godwoken: {
    tvl: async ()=>({}),
    staking: tvl,
  }
}
'''
'''--- projects/dddx.js ---
const { calculateUsdUniTvl } = require("./helper/getUsdUniTvl");
const { stakings } = require("./helper/staking");

module.exports = {
    misrepresentedTokens: true,
    doublecounted: false,
    timetravel: true,
    incentivized: true,
    bsc: {
        tvl: calculateUsdUniTvl(
            "0xb5737A06c330c22056C77a4205D16fFD1436c81b",
            "bsc",
            "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
            [
                "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
                "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c"
            ],
            "binancecoin"
        ),
        staking: stakings(
            [
                '0x488f0252B4bEa5A851FE9C827894d08868D552C0',
                '0xAd8Ab2C2270Ab0603CFC674d28fd545495369f31',
                '0x37056DbB4352877C94Ef6bDbB8C314f749258fCA',

            ],
            '0x4B6ee8188d6Df169E1071a7c96929640D61f144f',
            'bsc'
        )
    }
};

'''
'''--- projects/ddex/index.js ---
/*==================================================
  Modules
  ==================================================*/

const sdk = require('@defillama/sdk');

const axios = require('axios');
const BigNumber = require('bignumber.js');
const ddexMarginContractAddress = '0x241e82c79452f51fbfc89fac6d912e021db1a3b7'

/*==================================================
  Helper Functions
  ==================================================*/

async function GenerateCallList() {
  let assets = await axios.get('https://api.ddex.io/v4/assets');
  assets = assets.data.data.assets;
  assets = assets.filter((asset) => {
    let symbol = asset.symbol;
    return symbol !== "ETH";
  });

  let calls = [];
  assets.forEach((asset) => {
    calls.push({
      target: asset.address,
      params: ddexMarginContractAddress
    })
  });

  return calls;
}

/*==================================================
  TVL
  ==================================================*/

async function tvl(timestamp, block) {
  let balances = {
    '0x0000000000000000000000000000000000000000': (await sdk.api.eth.getBalance({target: ddexMarginContractAddress, block})).output
  };

  let balanceOfResults = await sdk.api.abi.multiCall({
    block,
    calls: await GenerateCallList(),
    abi: 'erc20:balanceOf'
  });

  await sdk.util.sumMultiBalanceOf(balances, balanceOfResults);

  return balances;
}

/*==================================================
  Exports
  ==================================================*/

module.exports = {
  start: 1566470505, // 2019-08-22T18:41:45+08:00
  ethereum: { tvl }
}

'''
'''--- projects/debridge/index.js ---
const axios = require("axios");
const retry = require('../helper/retry');
const { chainExports } = require('../helper/exports');
const { sumTokens } = require("../helper/unwrapLPs");
const { getBlock } = require('../helper/getBlock');

const http_api_url = 'https://api.debridge.finance/api/Pairs/getForChain';
const debridgeGate = '0x43dE2d77BF8027e25dBD179B491e8d64f38398aA';
const chainIds = {
  ethereum: 1,
  bsc: 56,
  heco: 128,
  polygon: 137,
  arbitrum: 42161,
};

function chainTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};
    const block = await getBlock(timestamp, chain, chainBlocks);
    const transformAddress = id=>`${chain}:${id}`;

    const url = `${http_api_url}?chainId=${chainIds[chain]}`;
    const debridge_response = await retry(async () => await axios.get(url));
    // console.log(debridge_response)
    const tokensAndOwners = debridge_response.data
      .filter(t => !t.tokenName.startsWith('deBridge '))
      .map(t => [t.tokenAddress, debridgeGate]);

    await sumTokens(balances, tokensAndOwners, block, chain, transformAddress);
    
    return balances
  };
}

module.exports = chainExports(chainTvl, [
  'ethereum', 
  'bsc', 
  'heco',
  'polygon', 
  'arbitrum', 
]),
module.exports.methodology = 'Debridge TVL is made of token balances of the DebridgeGate contracts. The deployed tokens are retrieved using Debridge HTTP REST API.'

'''
'''--- projects/decubate/index.js ---
const sdk = require("@defillama/sdk");

const DCBToken = "0xEAc9873291dDAcA754EA5642114151f3035c67A2";
const stakingPool = "0x22B551fE288c93A3Ac9172aD998A1D9ce1A882e5";

async function staking (timestamp, block, chainBlocks) {
    let balances = {};

    let {output: balance} =  await sdk.api.erc20.balanceOf({
        target: DCBToken,
        owner: stakingPool,
        block: chainBlocks.bsc,
        chain: "bsc"
    });

    sdk.util.sumSingleBalance(balances, `bsc:${DCBToken}`, balance)

    return balances;
}

module.exports = {
    bsc: {
        tvl: async () => ({}), 
        staking
    },
    
}
'''
'''--- projects/deeplock/abi.json ---
{
    "depositId": {
        "inputs": [],
        "name": "depositId",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "lockedToken": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "lockedToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "withdrawalAddress",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenAmount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "unlockTime",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "withdrawn",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "symbol": {
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/deeplock/api.js ---
const { getExports } = require('../helper/heroku-api')
const indexExports = require('./index')
const chainKeys = Object.keys(indexExports).filter(chain => typeof indexExports[chain] === 'object' && indexExports[chain].tvl)

module.exports = {
  timetravel: false,
  ...getExports("deeplock", chainKeys),
}

module.exports.bsc.pool2 = indexExports.bsc.pool2
'''
'''--- projects/deeplock/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { pool2s } = require("../helper/pool2");
const { vestingHelper } = require("../helper/unknownTokens");

const deepLockLockerContractV1 = "0x10dD7FD1Bf3753235068ea757f2018dFef94B257";
const deepLockLockerContractV2 = "0x3f4D6bf08CB7A003488Ef082102C2e6418a4551e";

const stakingPool2Contracts = [
  "0x27F33DE201679A05A1a3ff7cB40a33b4aA28758e",
  "0x03dab688d32507B53Cc91265FA47760b13941250",
];
const lpAddresses = [
  "0xc1fccf4170fa9126d6fb65ffc0dd5a680a704094",
  "0x596e48cde23ba55adc2b8b00b4ef472184e2a9e3",
];

const bscTvl = async (ts, _b, { bsc: block }) => {
  const blacklist = [
    '0x25f4a012b06b43aff3918acbf0cc113119aea194',
    '0xce80ab50fca1564426ca09a977b029377c50c909',
    '0xa3f0a9ad24a749f3aa14f33c019b708259cfa514',
    '0xdde9e8d669115542eff4923c647c53b46c1735f9',
    '0x9f0eec882f958cbeef99cab17ea3cf5909c62e77',
    '0x168926cd2b2559c8359a7c0ffd2be7ad56e1f2a4',
    '0x7963deca5ec22ffc4629f4767de372e1c81ad8fa',
    '0xa6467d83a32452ab9091ca4e8edc3831f8aab088',
    '0xe18af4897e0fa706ca65ffefef24e5f8ee1d1cea',
    '0x19024b0ed8d4e4d5cbf7dfa94a82804bc9a79be3',
    '0x347c5b51449074c5487cc193459c5babeebcef07',
    '0x290183a09390a9d34c10171cf84c9c36b6cad9ed',
    '0xc0600c41273e71dc8736c5e2128c7979ce3bbbac',
    '0x5880a0aebd1af8c68497088293ca548c63fd7b0f',
    '0x3172057a27b0dbc48a99b8fe2222c4535d56b44c',
    '0xf2abb94b826199311d51706e6b32aa3bf8539c89',
    '0x7108955947e352b351c4bB20b0a31A3598E7FEEC',
    '0xa6124221ed6d2e2f18da78c3cce6f52a8eec1a69',
    '0x85a5879ed3b3d11bb370d94b79db80b984f5cbf9',
    '0x17a273794516390043814059dc7f29f789972d0a',
    '0x3f4D6bf08CB7A003488Ef082102C2e6418a4551e',
    '0x03a3cDa7F684Db91536e5b36DC8e9077dC451081',
    '0xd43b226d365d8b22ba472afc2fa769b356eb5d47',
    '0x8d98a4e36ca048b8e4616564e5a8ebb78895ddff',
    '0x1337ace33c2b3fc17d85f33dbd0ed73a896148b5',
    '0x486dccaf152b271630216d62c00188f2558f6bec',
    '0xf0ee026f572c4a229dc67a692244e90abac29ec2',
  ].map(i => i.toLowerCase())

  const chain = 'bsc'
  const balances = {}
  const contracts = [
    deepLockLockerContractV1,
    deepLockLockerContractV2,
  ]

  const { output: lengths } = await sdk.api.abi.multiCall({
    abi: abi.depositId,
    calls: contracts.map(i => ({ target: i })),
    chain, block,
  })

  const allBalances = await Promise.all(contracts.map((vault, i) => getBalances(vault, lengths[i].output)))
  allBalances.forEach(balance => {
    Object.entries(balance).forEach(([token, val]) => sdk.util.sumSingleBalance(balances, token, val))
  })

  delete balances['bsc:0x60de5f9386b637fe97af1cc05f25548e9baaee19'] // remove deeplock token from tvl calculation
  delete balances['bsc:0x64f36701138f0e85cc10c34ea535fdbadcb54147'] // remove Anon INU - incorrect price
  return balances;

  async function getBalances(vault, length) {
    const calls = []
    for (let i = 1; i <= length; i++)
      calls.push({ target: vault, params: i })
    const { output } = await sdk.api.abi.multiCall({
      abi: abi.lockedToken, requery: true,
      calls, chain, block,
    })
    const tokens = output.map(i => i.output.tokenAddress)
    return vestingHelper({
      coreAssets: [
        '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        '0xe9e7cea3dedca5984780bafc599bd69add087d56', // BUSD
        '0x55d398326f99059ff775485246999027b3197955', // USDT token
        '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC token
      ],
      blacklist,
      owner: vault,
      tokens,
      block, chain,
      log_coreAssetPrices: [
        300/ 1e18,
        1/ 1e18,
        1/ 1e18,
        1/ 1e18,
      ],
      log_minTokenValue: 1e6,
    })
  }
};

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    pool2: pool2s(stakingPool2Contracts, lpAddresses, "bsc"),
    tvl: bscTvl,
  },
  methodology:
    "Counts tvl of all the tokens locked on the locker through DeepLockLocker Contracts",
};

'''
'''--- projects/deepseadao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const sea = "0xb195af20a0fec7e2c95b22a1c5de86a2389e40d5";
const staking = "0x844e56e53839Dda19e85894C8e3C1c13d7Aa9463";
const treasury = "0x4db9Ca15EB32D205B7CD2927D5AE33924F4da22A";
const tokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
    ["0x4a99bca37a3e442ecc60ece9ae4d3bff3f9a423e", true] // SEA-MIM JLP
];

module.exports = {
    deadFrom: 1648765747,
    misrepresentedTokens: true,
    ...ohmTvl(treasury, tokens, "avax", staking, sea, undefined, undefined, false)
}

'''
'''--- projects/deerfi/abi.json ---
{
    "allPools": {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allPools",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "allPoolsLength": {
        "constant": true,
        "inputs": [],
        "name": "allPoolsLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "constant": true,
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "reserve": {
        "constant": true,
        "inputs": [],
        "name": "reserve",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/deerfi/index.js ---
/*** This Protocol seems hacked/rugged. It's a case for study and analyze ***/

const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const factoryContract = "0xa22F8cf50D9827Daef24dCb5BAC92C147a9D342e";

const ethTvl = async (timestamp, block) => {
  const balances = {};

  const lengthOfPools = (
    await sdk.api.abi.call({
      abi: abi.allPoolsLength,
      target: factoryContract,
      block,
    })
  ).output;

  for (let i = 0; i < lengthOfPools; i++) {
    const pool = (
      await sdk.api.abi.call({
        abi: abi.allPools,
        target: factoryContract,
        params: i,
        block,
      })
    ).output;

    const token = (
      await sdk.api.abi.call({
        abi: abi.token,
        target: pool,
        block,
      })
    ).output;

    const reserve = (
      await sdk.api.abi.call({
        abi: abi.reserve,
        target: pool,
        block,
      })
    ).output;

    sdk.util.sumSingleBalance(balances, token, reserve);
  }

  return balances;
};

module.exports = {
  deadFrom: 1648765747,
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology:
    "Counts tvl on all the Pools through Factory Contract",
};

'''
'''--- projects/defi-basket/abi.json ---
{
  "inputs": [],
  "name": "tokenCounter",
  "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/defi-basket/index.js ---
// Documentation and source code for API "get-tvl" method: github.com/defibasket/defibasket-api

const axios = require("axios");

async function fetch() {
    const tvl = await axios.get("https://defibasket.org/api/v1/get-tvl");    
    return tvl.data.tvl;
}

module.exports = {
  methodology: "The TVL is calculated by summing the value of all assets that are in the wallets deployed by the DeFiBasket contract.",
  fetch,
}
'''
'''--- projects/defi-swap/abis/getReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
    {
      "internalType": "uint112",
      "name": "_reserve0",
      "type": "uint112"
    },
    {
      "internalType": "uint112",
      "name": "_reserve1",
      "type": "uint112"
    },
    {
      "internalType": "uint32",
      "name": "_blockTimestampLast",
      "type": "uint32"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/defi-swap/abis/token0.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token0",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/defi-swap/abis/token1.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token1",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/defi-swap/constant.js ---
const ETH = "0x0000000000000000000000000000000000000000";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const DEFI_SWAP_LAUNCH_DATE = 1599523200; // Tuesday, 8 September 2020 00:00:00

const STARTING_BLOCK = 10828414;
const FACTORY_ADDRESS = "0x9DEB29c9a4c7A88a3C0257393b7f3335338D9A9D";

const SUPPORTING_TOKEN_LIST_URL =
  "https://crypto.com/defi/swap/tokenlist/mainnet";

module.exports = {
  ETH,
  WETH,
  DEFI_SWAP_LAUNCH_DATE,
  STARTING_BLOCK,
  FACTORY_ADDRESS,
  SUPPORTING_TOKEN_LIST_URL,
};

'''
'''--- projects/defi-swap/index.js ---
const BigNumber = require("bignumber.js");
const v2TVL = require("./v2");
const { ETH, WETH, DEFI_SWAP_LAUNCH_DATE } = require("./constant");

async function tvl(timestamp, block) {
  const [v2] = await Promise.all([v2TVL(timestamp, block)]);
  // replace WETH with ETH for v2
  v2[ETH] = v2[WETH];
  delete v2[WETH];

  const tokenAddresses = new Set(Object.keys(v2));

  const balances = Array.from(tokenAddresses).reduce(
    (accumulator, tokenAddress) => {
      const v2Balance = new BigNumber(v2[tokenAddress] || "0");
      accumulator[tokenAddress] = v2Balance.toFixed();

      return accumulator;
    },
    {}
  );

  return balances;
}

module.exports = {
  start: DEFI_SWAP_LAUNCH_DATE,
  tvl,
};

'''
'''--- projects/defi-swap/v2.js ---
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");
const token0 = require("./abis/token0.json");
const token1 = require("./abis/token1.json");
const getReserves = require("./abis/getReserves.json");
const axios = require("axios");
const {
  STARTING_BLOCK,
  FACTORY_ADDRESS,
  SUPPORTING_TOKEN_LIST_URL,
} = require("./constant");

module.exports = async function tvl(_, block) {
  
  const supportedTokens = (
    await axios.get(SUPPORTING_TOKEN_LIST_URL)
  ).data.tokens.map(({ address }) => address.toLowerCase());

  const logs = (
    await sdk.api.util.getLogs({
      keys: [],
      toBlock: block,
      target: FACTORY_ADDRESS,
      fromBlock: STARTING_BLOCK,
      topic: "PairCreated(address,address,address,uint256)",
    })
  ).output;

  const pairAddresses = logs.map((
    log // sometimes the full log is emitted
  ) =>
    typeof log === "string"
      ? log.toLowerCase()
      : `0x${log.data.slice(64 - 40 + 2, 64 + 2)}`.toLowerCase()
  );

  const [token0Addresses, token1Addresses] = await Promise.all([
    (
      await sdk.api.abi.multiCall({
        abi: token0,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
      })
    ).output,
    (
      await sdk.api.abi.multiCall({
        abi: token1,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
      })
    ).output,
  ]);

  const pairs = {};
  // add token0Addresses
  token0Addresses.forEach((token0Address) => {
      const tokenAddress = token0Address.output.toLowerCase();

      if (supportedTokens.includes(tokenAddress)) {
        const pairAddress = token0Address.input.target.toLowerCase();
        pairs[pairAddress] = {
          token0Address: tokenAddress,
        };
      }
  });

  // add token1Addresses
  token1Addresses.forEach((token1Address) => {
      const tokenAddress = token1Address.output.toLowerCase();
      if (supportedTokens.includes(tokenAddress)) {
        const pairAddress = token1Address.input.target.toLowerCase();
        pairs[pairAddress] = {
          ...(pairs[pairAddress] || {}),
          token1Address: tokenAddress,
        };
      }
  });

  const reserves = (
    await sdk.api.abi.multiCall({
      abi: getReserves,
      calls: Object.keys(pairs).map((pairAddress) => ({
        target: pairAddress,
      })),
      block,
    })
  ).output;

  return reserves.reduce((accumulator, reserve) => {
      const pairAddress = reserve.input.target.toLowerCase();
      const pair = pairs[pairAddress] || {};

      // handle reserve0
      if (pair.token0Address) {
        const reserve0 = new BigNumber(reserve.output["0"]);
        if (!reserve0.isZero()) {
          const existingBalance = new BigNumber(
            accumulator[pair.token0Address] || "0"
          );

          accumulator[pair.token0Address] = existingBalance
            .plus(reserve0)
            .toFixed();
        }
      }

      // handle reserve1
      if (pair.token1Address) {
        const reserve1 = new BigNumber(reserve.output["1"]);

        if (!reserve1.isZero()) {
          const existingBalance = new BigNumber(
            accumulator[pair.token1Address] || "0"
          );

          accumulator[pair.token1Address] = existingBalance
            .plus(reserve1)
            .toFixed();
        }
      }

    return accumulator;
  }, {});
};

'''
'''--- projects/defibox/index.js ---
const axios = require("axios");
const utils = require("../helper/utils");
const {get_account_tvl} = require('../helper/eos')
const {lendingMarket} = require("../helper/methodologies")

const eosEndpoint = "https://dapp.defibox.io/api/"
const bscEndpoint = "https://bsc.defibox.io/api/"

async function eos() {
  const eosPrice = (await utils.getPricesfromString("eos")).data.eos.usd;
  const swap = await utils.fetchURL(eosEndpoint + "swap/get24HInfo")
  const lend = await utils.fetchURL(eosEndpoint + "lend/getGlobalOpenPositionStat")
  const usn = await utils.fetchURL(eosEndpoint + "st/open/getGlobalOpenStat")
  const tvl = Number(swap.data.data.eosBalance) * eosPrice * 2 + // swap TVL
              lend.data.data.practicalBalance - lend.data.data.totalBorrowsVariable + // lend TVL
              usn.data.globalOpenStat.totalMortgage // usn (stable token) TVL
  return tvl
}

async function wax() {
  const tokens = [
    ["eosio.token", "WAX", "wax"],
    ["alien.worlds", "TLM", "alien-worlds"],
    // ["e.rplanet", "AETHER", null], // no CoinGecko price support
    // ["e.rplanet", "RDAO", null], // no CoinGecko price support
    // ["prospectorsw", "PGL", null], // no CoinGecko price support
  ];
  return await get_account_tvl("swap.box", tokens, "wax");
}

async function balancesToTvl( balances ) {
  let tvl = 0;
  for ( const [ key, balance ] of Object.entries(balances)) {
    const price = (await utils.getPricesfromString(key)).data[key].usd;
    tvl += price * balance;
  }
  return tvl;
}

async function bsc() {
  const bnbPrice = (await utils.getPricesfromString("binancecoin")).data.binancecoin.usd;
  const swap = await axios.default.post(bscEndpoint + "swap/get24HInfo", {}, { headers: { chainid: 56 }})
  const tvl = swap.data.data.usd_balance + swap.data.data.wbnb_balance * bnbPrice // swap TVL
  return tvl
}

async function fetch() {
  return await eos() + await bsc() + await balancesToTvl(await wax());
}

module.exports = {
  methodology: `${lendingMarket}. Defibox TVL is achieved by making a call to its API: https://dapp.defibox.io/api/.`,
  eos: {
    fetch: eos
  },
  bsc: {
    fetch: bsc
  },
  wax: {
    tvl: wax
  },
  fetch
}

'''
'''--- projects/defibox/utils.js ---
const sdk = require('@defillama/sdk');
const axios = require("axios");

const EOS_ENDPOINT = "https://eos.greymass.com";

function defiboxSymbolPairId( symbol ) {
    let id = 0;
    let depth = 0;
    const multiplier = 26
    const chars = symbol.replace(/^BOX/, "").split("").reverse();
    for ( const c of chars ) {
        const value = c.charCodeAt(0) - "A".charCodeAt(0) + 1;
        if ( depth ) id += multiplier ** depth * value
        else id += value;
        depth += 1;
    }
    return id;
  }

function sumDefiboxLiquidity( balances, reserve, token, ratio ) {
  const balance = Number(reserve.split(" ")[0]);
  const precision = Number(token.symbol.split(",")[0]);
  const amount = Math.floor(balance * ratio * 10 ** precision);
  sdk.util.sumSingleBalance( balances, eosTokenString(token), amount );
}

async function unwrapDefiboxLiquidity( balances, token ) {
  const pair_id = defiboxSymbolPairId( token.symbol );
  const data = { code: "swap.defi", scope: "swap.defi", table: "pairs", lower_bound: pair_id, upper_bound: pair_id, json: true };
  const response = await axios.default.post(EOS_ENDPOINT + "/v1/chain/get_table_rows", data);
  if ( response.data.rows ) {
    const { token0, token1, reserve0, reserve1, liquidity_token } = response.data.rows[0];
    const ratio = token.balance / liquidity_token;
    sumDefiboxLiquidity( balances, reserve0, token0, ratio );
    sumDefiboxLiquidity( balances, reserve1, token1, ratio );
  }
}

function eosTokenString( token ) {
  // ex: 4,EOS@eosio.token
  if ( typeof token.contract == 'undefined' ) throw new Error("tokenString: [token.contract] is required");
  if ( typeof token.symbol == 'undefined' ) throw new Error("tokenString: [token.symbol] is required");
  if ( token.symbol.match(",") ) return `eos:${token.symbol}@${token.contract}`
  return `eos:${normalizePrecision(token.precision)},${token.symbol}@${token.contract}`
}

// converts 10000 => 4
function normalizePrecision( precision ) {
  return (String(precision).match(/0/g) || []).length;
}

module.exports = {
  defiboxSymbolPairId,
  sumDefiboxLiquidity,
  unwrapDefiboxLiquidity,
  eosTokenString,
  normalizePrecision
}
'''
'''--- projects/defichain-dex.js ---
const utils = require('./helper/utils');

async function fetch() {
  const { data } = await utils.fetchURL('https://ocean.defichain.com/v0/mainnet/stats')
  return data.data.tvl.dex;
}

module.exports = {
  methodology: "Liquidity on the DEX",
  fetch
}

'''
'''--- projects/defichain-loans.js ---
const utils = require('./helper/utils');

async function fetch() {
  const { data } = await utils.fetchURL('https://ocean.defichain.com/v0/mainnet/stats')
  return data.data.tvl.loan;
}

module.exports = {
  methodology: "Collateral backing loans in the platform",
  fetch
}

'''
'''--- projects/defichain-staking.js ---
const utils = require('./helper/utils');

async function fetch() {
  const { data } = await utils.fetchURL('https://ocean.defichain.com/v0/mainnet/stats')
  return data.data.tvl.masternodes;
}

module.exports = {
  methodology: "Liquidity on the Staking",
  fetch
}

'''
'''--- projects/defidollar/abi.json ---
{
  "pricePerShare": {
    "inputs": [],
    "name": "pricePerShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "yCrvDistribution": {
    "constant": true,
    "inputs": [],
    "name": "yCrvDistribution",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "here",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "total",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/defidollar/index.js ---
const abi = require("./abi.json");
const sdk = require('@defillama/sdk')
const BigNumber = require('bignumber.js')

const IBBTC = "0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F";

const yCRV = "0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8";
const yCrvPeak = "0xA89BD606d5DadDa60242E8DEDeebC95c41aD8986"

async function tvl(_timestamp, block) {
  const [ yCrvDistribution, ibbtcSupply, pps ] = await Promise.all([
    sdk.api.abi.call({
      block,
      target: yCrvPeak,
      abi: abi.yCrvDistribution
    }),
    sdk.api.erc20.totalSupply({
      target: IBBTC,
      block
    }),
    sdk.api.abi.call({
      target: IBBTC,
      abi: abi.pricePerShare,
      block
    })
  ]);

  const bitcoinBalance = BigNumber(ibbtcSupply.output).times(pps.output).div(10**36).toNumber()
  return {
    [yCRV]: yCrvDistribution.output.total,
    'bitcoin': bitcoinBalance
  }
}

module.exports = {
  ethereum:{
    tvl
  },
};

'''
'''--- projects/defihalal/index.js ---
const {getLiquityTvl} = require('../helper/liquity')

//USDH TOKEN ADDRESS ON POLYGON MAINNET
const USDH_TOKEN_ADDRESS = "0x92B27abe3C96d3B1266f881b3B0886e68645F51F";

module.exports = {
  methodology: "Deposited Matic and USDH, USDH is not listed on CoinGecko and has been replaced with TUSD",
  polygon:{
    tvl: getLiquityTvl("0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "0xd8a3e8c70091d6231a63e671a6ce8ea44e143d24", "polygon")
  }
};

'''
'''--- projects/defikingdoms/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { staking } = require("../helper/staking");
const { getBlock } = require("../helper/getBlock");
const { fixHarmonyBalances, transformHarmonyAddress } = require("../helper/portedTokens");

/*
const { request, gql } = require("graphql-request");
const graphUrl =
  "https://graph.defikingdoms.com/subgraphs/name/defikingdoms/dex";
const graphQuery = gql`
  query get_tvl($block: Int) {
    uniswapFactory(
      id: "0x9014B937069918bd319f80e8B3BB4A2cf6FAA5F7"
      block: { number: $block }
    ) {
      totalLiquidityUSD
    }
  }
`;

const transforms = {
  "0x224e64ec1bdce3870a6a6c777edd450454068fec": "0xa47c8bf37f92abed4a126bda807a7b7498661acd", // ust
  "0xb12c13e66ade1f72f71834f2fc5082db8c091358": "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", //avax
  "0x735abe48e8782948a37c7765ecb76b98cde97b0f": "0x4e15361fd6b4bb609fa63c81a2be19d873717870", //ftm
  "0xfbdd194376de19a88118e84e279b977f165d01b8": "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", //matic
  // missing luna
}
*/

const factory = "0x9014B937069918bd319f80e8B3BB4A2cf6FAA5F7"
async function tvl(timestamp, _ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, "harmony", chainBlocks, true);
  const balances = await calculateUniTvl(
      addr => `harmony:${addr}`,
      block,
      "harmony",
      factory,
      0,
      true
  );
  fixHarmonyBalances(balances)
  delete balances["harmony:0xed0b4b0f0e2c17646682fc98ace09feb99af3ade"]

  return balances

}

module.exports = {
  harmony: {
    tvl,
    staking: staking("0xa9ce83507d872c5e1273e745abcfda849daa654f", "0x72cb10c6bfa5624dd07ef608027e366bd690048f", "harmony"),
  },
};

'''
'''--- projects/defil/abi.json ---
{
    "constant": true,
    "inputs": [],
    "name": "totalBorrows",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
}
'''
'''--- projects/defil/contracts.json ---
{
    "ethereum": {
        "holders": {
            "DFL": "0xb685bfdad9da7093168ab75204bbcadf0c69c823",
            "eFIL": "0x036cf3821ea246e935feef1c29ed8ddffac1dbb0",
            "FILST-USDT": "0x9e08bd9a1e3880902688b32d563046cab74d2f2f",
            "FILST-EFIL": "0x312c6ffe7743b964be6da9131e662af5bac55199",
            "FILST": "0x01aabbad98a7638b7f8d65e7ec42560f1afbbf0c"
        },
        "pool2": "0x6b0c7d013cc0b461490287cc20aa9f34f950a6a6",
        "tokens": {
            "DFL": {
                "address": "0x09ce2b746c32528b7d864a1e3979bd97d2f095ab",
                "isLP": false
            },
            "eFIL": {
                "address": "0x2a2cB9bA73289D4D068BD57D3c26165DaD5Cb628",
                "isLP": false
            },
            "DFL-USDT": {
                "address": "0xd372a3221021Df72eDa38f77117d3A95f057e163",
                "isLP": true
            },
            "FILST-USDT": {
                "address": "0xa2f6a219a51B4682E34a13a94C160d6c79cDcA35",
                "isLP": true
            },
            "FILST-EFIL": {
                "address": "0x7393aa9DE6585ae2EC5e18aBfFe1eD07123d0E87",
                "isLP": true
            },
            "FILST": {
                "address": "0x7346aD4c8cD1886Ff6D16072bCeA5DFC0bc24Ca2",
                "isLP": false
            }
        }
    },
    "bsc": {
        "holders": {
            "DFL": "0x272257bb03a2b99978a1e6badeba7ccba444d285",
            "eFIL": "0x22b475f3e93390b7e523873ad7073337f4e56c2c",
            "FILST-USDT": "0xde6239b3138910c68f318e799b3d332925e9929f",
            "FILST-EFIL": "0x6b9ee349810e660dda9e3557c7a7412e5424ea39",
            "FILST": "0x6c753ca90bad578504314699580c8b01e067a765"
        },
        "pool2": "0x6b6811a710f07b8ac430f6e172833e87c4bd8716",
        "tokens": {
            "DFL": {
                "address": "0x6ded0F2c886568Fb4Bb6F04f179093D3D167c9D7",
                "isLP": false
            },
            "eFIL": {
                "address": "0x22B475f3e93390b7E523873ad7073337f4E56C2c",
                "isLP": false
            },
            "DFL-USDT": {
                "address": "0x3558C47C0f2309197857689d84Cb620405E2c54D",
                "isLP": true
            },
            "FILST-USDT": {
                "address": "0xecf6aA34b19e31311eB92768888bdDd25aa72933",
                "isLP": true
            },
            "FILST-EFIL": {
                "address": "0x3ce2669c9aaf8e717c739b1e9100fa792ad23835",
                "isLP": true
            },
            "FILST": {
                "address": "0x899e2a220CBC6eb1Ab154211353EDED74BC1e266",
                "isLP": false
            }
        }
    }
}
'''
'''--- projects/defil/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');
const { getChainTransform } = require('../helper/portedTokens');
const { staking } = require("../helper/staking.js");
const { pool2 } = require('../helper/pool2');
const contracts = require('./contracts.json');
const abi = require('./abi.json');

function tvl(chain) {
    return async (timestamp, block, chainBlocks) => {
        const balances = {};
        const transform = await getChainTransform(chain);
        const tokens = Object.values(contracts[chain].tokens);

        const calls = Object.values(contracts[chain].holders).map(
            function (h, i) {
                return {
                    target: tokens[i].address,
                    params: [h]
                }
            }
        );

        const poolBalances = await sdk.api.abi.multiCall({
            abi: 'erc20:balanceOf',
            calls,
            block: chainBlocks[chain],
            chain
        });

        sdk.util.sumMultiBalanceOf(
            balances,
            poolBalances,
            true,
            transform
        );

        const lpPositions = [];
        for (let i = 0; i < poolBalances.output.length; i++) {
            if (tokens[i].isLP) {
                lpPositions.push(
                    {
                        balance: poolBalances.output[i].output,
                        token: tokens[i].address
                    }
                );
            };
        };

        delete balances[contracts.ethereum.tokens.DFL.address];

        await unwrapUniswapLPs(
            balances,
            lpPositions,
            chainBlocks[chain],
            chain,
            transform
        );

        return balances;
    };
};
function borrowed(chain) {
    return async (timestamp, block, chainBlocks) => {
        return { 
            [contracts.ethereum.tokens.eFIL.address]: (
                await sdk.api.abi.call({
                    target: contracts[chain].holders.eFIL,
                    abi,
                    chain,
                    block: chainBlocks[chain]
                })).output 
            };
    };
};
module.exports = {
    bsc: {
        tvl: tvl('bsc'),
        staking: staking(
            contracts.bsc.holders.DFL,
            contracts.bsc.tokens.DFL.address,
            'bsc',
            contracts.ethereum.tokens.DFL.address
        ),
        pool2: pool2(
            contracts.bsc.pool2, 
            contracts.bsc.tokens['DFL-USDT'].address, 
            'bsc'
        ),
    },
    ethereum: {
        tvl: tvl('ethereum'),
        staking: staking(
            contracts.ethereum.holders.DFL,
            contracts.ethereum.tokens.DFL.address
        ),
        pool2: pool2(
            contracts.ethereum.pool2, 
            contracts.ethereum.tokens['DFL-USDT'].address, 
            'ethereum'
        ),
        borrowed: borrowed('ethereum')
    }
};
'''
'''--- projects/defilyio/index.js ---
const utils = require("../helper/utils");
const { staking } = require("../helper/staking");

const stakingContract_BSC = "0x75A2145510b7CeefB812d5Afa1b20f94eC0BAf57";
const stakingContract_KARDIA = "0x0245a1f57Ee84b55Cf489Eb5F3d27355014e57f8";
const stakingContract_Harmony = "0x3b441bf2522927BCf41c1c24786E7a8E9a56B234";

const DFL = "0xD675fF2B0ff139E14F86D87b7a6049ca7C66d76e";
const DFL_Harmony = "0xfea7a6a0b346362bf88a9e4a88416b77a57d6c2a";

const fetch = async () => {
  const tvl = (await utils.fetchURL("https://api.defily.io/v1/statistics")).data
    .payload.totalValueLocked.total;
  return tvl;
};

module.exports = {
  bsc: {
    staking: staking(stakingContract_BSC, DFL, "bsc"),
  },
  kardia: {
    staking: staking(stakingContract_KARDIA, DFL, "kardia"),
  },
  harmony: {
    staking: staking(stakingContract_Harmony, DFL_Harmony, "harmony", `kardia:${DFL}`),
  },
  fetch,
};

'''
'''--- projects/definer/abi.json ---
{
  "global:tokenInfoRegistry": {
    "constant": true,
    "inputs": [],
    "name": "tokenInfoRegistry",
    "outputs": [
      {
        "internalType": "contract TokenRegistry",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "global:bank": {
    "constant": true,
    "inputs": [],
    "name": "bank",
    "outputs": [
      {
        "internalType": "contract Bank",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "tokenRegistry:getTokens": {
    "constant": true,
    "inputs": [],
    "name": "getTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "tokenRegistry:getCToken": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "getCToken",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "bank:getPoolAmount": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "getPoolAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "bank:getTokenState": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "getTokenState",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "deposits",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "loans",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "collateral",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "bank:getCapitalUtilizationRatio": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "getCapitalUtilizationRatio",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "bank:getCapitalCompoundRatio": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "getCapitalCompoundRatio",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "ctoken:supplyRatePerBlock": {
    "constant": true,
    "inputs": [],
    "name": "supplyRatePerBlock",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xae9d70b0"
  },
  "ctoken:borrowRatePerBlock": {
    "constant": true,
    "inputs": [],
    "name": "borrowRatePerBlock",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xf8f9da28"
  }
}
'''
'''--- projects/definer/index.js ---
const sdk = require("@defillama/sdk");

const abi = require("./abi.json");
const contracts = {
  ethereum: {
    DEPLOY_BLOCK: 10819469,
    GLOBAL_CONFIG_ADDRESS: "0xa13B12D2c2EC945bCAB381fb596481735E24D585",
    SAVINGS_ADDRESS: "0x7a9E457991352F8feFB90AB1ce7488DF7cDa6ed5",
    CETH: "0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5",
  },
  okexchain: {
    DEPLOY_BLOCK: 3674844,
    GLOBAL_CONFIG_ADDRESS: "0xAdD7b91FA4DC452A9C105F218236B28F17562555",
    SAVINGS_ADDRESS: "0xF3c87c005B04a07Dc014e1245f4Cff7A77b6697b",
    CETH: "0x621CE6596E0B9CcF635316BFE7FdBC80C3029Bec",
  },
  polygon: {
    DEPLOY_BLOCK: 22745105,
    GLOBAL_CONFIG_ADDRESS: "0x8dceE8E1555e1881fB16a546E86310aB573a6808",
    SAVINGS_ADDRESS: "0x7C6e294E6555cD70D02D53735C6860AD03A6b34F",
    CETH: "0xC1B02E52e9512519EDF99671931772E452fb4399",
  },
};

const utility = {
  // get the latest TokenRegistry address through the GlobalConfig contract
  async getTokenRegistryAddressByGlobalConfig(block, chain) {
    return (
      await sdk.api.abi.call({
        block: block,
        chain: chain,
        target: contracts[chain].GLOBAL_CONFIG_ADDRESS,
        params: [],
        abi: abi["global:tokenInfoRegistry"],
      })
    ).output;
  },

  // Get the latest Bank address through the GlobalConfig contract
  async getBankAddressByGlobalConfig(block, chain) {
    return (
      await sdk.api.abi.call({
        block: block,
        chain: chain,
        target: contracts[chain].GLOBAL_CONFIG_ADDRESS,
        params: [],
        abi: abi["global:bank"],
      })
    ).output;
  },

  // Get the TokenRegistry contract
  async getTokenRegistryContract(block, ads, chain) {
    return (
      await sdk.api.abi.call({
        block: block,
        chain: chain,
        target: ads,
        params: [],
        abi: abi["tokenRegistry:getTokens"],
      })
    ).output;
  },

  // Get all tokens
  async getMarkets(block, chain) {
    // Get TokenRegistry Address
    let tokenRegistryAddress =
      await utility.getTokenRegistryAddressByGlobalConfig(block, chain);

    // Get latest markets
    let currentMarkets = await utility.getTokenRegistryContract(
      block,
      tokenRegistryAddress,
      chain
    );
    return currentMarkets;
  },

  async getBankPoolAmounts(block, markets, chain) {
    let bankAddress = await utility.getBankAddressByGlobalConfig(block, chain);
    let callsArray = [];
    markets.forEach((element) => {
      callsArray.push({
        target: bankAddress,
        params: element,
      });
    });
    return (
      await sdk.api.abi.multiCall({
        block: block,
        chain: chain,
        abi: abi["bank:getPoolAmount"],
        calls: callsArray,
      })
    ).output;
  },

  async getBankContractTokenState(block, markets, chain) {
    let bankAddress = await utility.getBankAddressByGlobalConfig(block, chain);
    let callsArray = [];
    markets.forEach((element) => {
      callsArray.push({
        target: bankAddress,
        params: element,
      });
    });
    return (
      await sdk.api.abi.multiCall({
        block: block,
        chain: chain,
        abi: abi["bank:getTokenState"],
        calls: callsArray,
      })
    ).output;
  },

  // Get Token Value
  async getCtokenValue(block, ctoken, chain) {
    let cEthToken = await sdk.api.abi.call({
      block: block,
      chain: chain,
      target: ctoken,
      params: contracts[chain].SAVINGS_ADDRESS,
      abi: "erc20:balanceOf",
    });
    return cEthToken.output;
  },
  
  // Get cTokens
  async getCTokens(block, markets, chain) {
    let tokenRegistryAddress =
      await utility.getTokenRegistryAddressByGlobalConfig(block, chain);
    let callsArray = [];
    let allTokenObj = {};
    markets.forEach((token_address) => {
      allTokenObj[token_address] = "";
      callsArray.push({
        target: tokenRegistryAddress,
        params: token_address,
      });
    });
    let cToken = (
      await sdk.api.abi.multiCall({
        block: block,
        chain: chain,
        abi: abi["tokenRegistry:getCToken"],
        calls: callsArray,
      })
    ).output;

    let zeroCTokenAddress = "0x0000000000000000000000000000000000000000";
    cToken.forEach((item) => {
        allTokenObj[item.input.params[0]] =
          item.output === zeroCTokenAddress ? "" : item.output;
    });
    return allTokenObj;
  },
  //
};

async function ethereumTvl(timestamp, blockETH, chainBlocks) {
  const block = blockETH;
  const chain = "ethereum";
  return await getTvlByChain(timestamp, block, chain);
}
async function okexchainTvl(timestamp, blockETH, chainBlocks) {
  const block = chainBlocks["okexchain"];
  const chain = "okexchain";
  return await getTvlByChain(timestamp, block, chain);
}
async function polygonTvl(timestamp, blockETH, chainBlocks) {
  const block = chainBlocks["polygon"];
  const chain = "polygon";
  return await getTvlByChain(timestamp, block, chain);
}

async function getTvlByChain(timestamp, block, chain) {
  let config = contracts[chain];

  let balances = {};
  let networkAddressSymbol = chain === "ethereum" ? "" : `${chain}:`;
  if (!block || block > config.DEPLOY_BLOCK) {
    // Get all Tokens in the market
    let markets = await utility.getMarkets(block, chain);

    // Get Bank
    let banksPoolAmounts = await utility.getBankPoolAmounts(
      block,
      markets,
      chain
    );
    banksPoolAmounts.forEach((result) => {
        balances[networkAddressSymbol + result.input.params] = result.output;
    });

    // cETH value
    balances[networkAddressSymbol + config.CETH] = await utility.getCtokenValue(
      block,
      config.CETH,
      chain
    );
  }
  return balances;
}

module.exports = {
  ethereum: {
    tvl: ethereumTvl,
  },
  okexchain: {
    tvl: okexchainTvl,
  },
  polygon: {
    tvl: polygonTvl,
  },
};

'''
'''--- projects/definix.js ---
const retry = require("./helper/retry");
const axios = require("axios");

async function klaytn() {
  const response = await retry(
    async (bail) =>
      await axios.get(
        "https://database-s3public-g8ignhbbbk6e.s3.ap-southeast-1.amazonaws.com/definix/tvl.json"
      )
  );
  return response.data.caverTVL;
}
async function bsc() {
  const response = await retry(
    async (bail) =>
      await axios.get(
        "https://database-s3public-g8ignhbbbk6e.s3.ap-southeast-1.amazonaws.com/definix/tvl.json"
      )
  );
  return response.data.web3TVL;
}
module.exports = {
  klaytn: {
    fetch: klaytn,
  },
  bsc: {
    fetch: bsc,
  },
  fetch: async () => (await bsc()) + (await klaytn()),
};
// node test.js projects/definix.js

'''
'''--- projects/defiplaza.js ---
const { request, gql } = require('graphql-request');
const { toUSDTBalances } = require('./helper/balances');

const graphUrl = 'https://api.thegraph.com/subgraphs/name/omegasyndicate/defiplaza';
const graphQuery = gql`
   query get_tvl($timestamp: Int) {
      hourlies(first: 1, orderBy: date, orderDirection: desc, where:{date_lte: $timestamp}) {
			totalValueLockedUSD
		}
   }
`;

async function tvl(timestamp, block) {
   const { hourlies } = await request(graphUrl, graphQuery, {
      timestamp,
   });
   const usdTvl = Number(hourlies[0].totalValueLockedUSD);

   return toUSDTBalances(usdTvl);
}

module.exports = {
   ethereum: {
      tvl,
   },
};

'''
'''--- projects/defirex/index.js ---
const { tokenHolderBalances } = require('../helper/tokenholders')

module.exports = {
    tvl: tokenHolderBalances([
        {
            tokens: ['0xdac17f958d2ee523a2206206994597c13d831ec7' /*USDT*/, '0x6b175474e89094c44da98b954eedeac495271d0f'/*DAI*/],
            holders: '0xb942ca22e0eb0f2524F53f999aE33fD3B2D58E3E',      // Strategy controller contract
            checkETHBalance: true,
        },
        {
            tokens: ['0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643'/*cDAI*/, '0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5'/*cETH*/],
            holders: '0x0BCbAb2FeCC30B7341132B4Ebb36d352E035f1bD',      // Wallet strategy contract with user funds deposited in Compound
        },
        {
            tokens: ['0x6b175474e89094c44da98b954eedeac495271d0f' /*DAI*/],
            holders: '0x65D4853d663CeE114A0aA1c946E95479C53e78c2',      // user rewards in DAI token
        }]
    ),
}
'''
'''--- projects/defisaver.js ---
const BigNumber = require("bignumber.js");
const defisaverABIs = require("./config/defisaver/abis");
const utils = require("./helper/utils");
const sdk = require('@defillama/sdk')

const usdtAddress = "0xdac17f958d2ee523a2206206994597c13d831ec7"

const {
  AaveSubscriptions,
  AaveLoanInfo,
  CompoundSubscriptions,
  CompoundLoanInfo,
  McdSubscriptions,
  MCDSaverProxy,
  AaveSubscriptionsV2,
  AaveLoanInfoV2,
} = defisaverABIs;

function getAddress(defisaverConfig) {
  return defisaverConfig.networks['1'].address
}

function getAbi(defisaverConfig, abiName) {
  return defisaverConfig.abi.find(obj => obj.name === abiName)
}

// Configs
const coins = {
  ETH: 18,
  WETH: 18,
  cETH: 8,
  DAI: 18,
  cDAI: 8,
  iDAI: 18,
  MKR: 18,
  BAT: 18,
  cBAT: 8,
  ZRX: 18,
  KNC: 18,
  cZRX: 8,
  REP: 18,
  REPv2: 18,
  cREP: 8,
  USDC: 6,
  cUSDC: 8,
  WBTC: 8,
  cWBTC: 8,
  DGD: 9,
  USDT: 6,
  cUSDT: 8,
  SAI: 18,
  COMP: 18,
  aETH: 18,
  aDAI: 18,
  aUSDC: 18,
  aSUSD: 18,
  SUSD: 18,
  aTUSD: 18,
  TUSD: 18,
  aUSDT: 18,
  aBUSD: 18,
  BUSD: 18,
  aBAT: 18,
  aKNC: 18,
  aLEND: 18,
  LEND: 18,
  aLINK: 18,
  LINK: 18,
  aMANA: 18,
  MANA: 18,
  aMKR: 18,
  aREP: 18,
  aSNX: 18,
  SNX: 18,
  aWBTC: 18,
  aZRX: 18,
  aENJ: 18,
  ENJ: 18,
  aREN: 18,
  REN: 18,
  CRV: 18,
  YFI: 18,
  aYFI: 18,
  PAXUSD: 18,
  DPI: 18,
  UNI: 18,
  cUNI: 8,
  LRC: 18,
  cCOMP: 8,
  aUNI: 18,
  AAVE: 18,
  aAave: 18,
  BAL: 18,
  GUSD: 2,
  RENBTC: 18,
  MATIC: 18,
};

const keys = [
  {
    ETH: "ethereum",
    WETH: "ethereum",
    cETH: "ethereum",
    DAI: "dai",
    cDAI: "cdai",
    iDAI: "dai",
    MKR: "maker",
    BAT: "basic-attention-token",
    cBAT: "compound-basic-attention-token",
    ZRX: "0x",
    cZRX: "compound-0x",
    KNC: "kyber-network",
    REP: "augur",
    REPv2: "augur",
    cREP: "compound-augur",
    USDC: "usd-coin",
    cUSDC: "compound-usd-coin",
    WBTC: "wrapped-bitcoin",
    cWBTC: "compound-wrapped-btc",
    DGD: "digixdao",
    USDT: "tether",
    cUSDT: "compound-usdt",
    SAI: "sai",
    COMP: "compound-coin",
    aETH: "aave-eth",
    aDAI: "aave-dai",
    aUSDC: "aave-usdc",
    aSUSD: "aave-susd",
    SUSD: "nusd",
    aTUSD: "aave-tusd",
    TUSD: "true-usd",
    aUSDT: "aave-usdt",
    aBUSD: "aave-busd",
    BUSD: "binance-usd",
    aBAT: "aave-bat",
    aKNC: "aave-k",
    aLEND: "aave-lend",
    LEND: "ethlend",
    aLINK: "aave-link",
    LINK: "chainlink",
    aMANA: "aave-mana",
    MANA: "decentraland",
    aMKR: "aave-mkr",
    aREP: "aave-rep",
    aSNX: "aave-snx",
    SNX: "havven",
    aWBTC: "aave-wbtc",
    aZRX: "aave-zrx",
    aENJ: "aave-enj",
    ENJ: "enjincoin",
    aREN: "aave-ren",
    REN: "renbtc",
    CRV: "curve-dao-token",
    YFI: "yearn-finance",
    aYFI: "ayfi",
    PAXUSD: "paxos-standard",
    DPI: "defipulse-index",
    UNI: "uniswap",
    cUNI: "compound-uniswap",
    LRC: "loopring",
    cCOMP: "ccomp",
    aUNI: "uniswap",
    AAVE: "aave",
    aAave: "aave",
    BAL: "balancer",
    GUSD: "gemini-dollar",
    RENBTC: "renbtc",
    WSTETH: "staked-ether",
    MATIC: "matic-network",
  },
];

// Utils
const bytesToString = (hex) =>
  Buffer.from(hex.replace(/^0x/, ""), "hex").toString().replace(/\x00/g, "");

const ilkToAsset = (ilk) =>
  (ilk.substr(0, 2) === "0x" ? bytesToString(ilk) : ilk).replace(/-.*/, "");

const assetAmountInEth = (amount, asset = "ETH") => {
  let decimals;
  if (asset.substr(0, 4) === "MCD-") decimals = 18;
  else if (asset === "USD") decimals = 18;
  else decimals = coins[asset];
  return new BigNumber((amount && amount.toString()) || 0)
    .div(10 ** decimals)
    .toString();
};

async function tvl(ts, block) {
  const balances = {}
  const prices = (await utils.getPrices(keys)).data;
  await getCompoundData()
  await getAaveV2Data()
  await getMakerData()
  return balances

  async function getCompoundData() {
    let { output: compoundSubs } = await sdk.api.abi.call({
      target: getAddress(CompoundSubscriptions),
      abi: getAbi(CompoundSubscriptions, 'getSubscribers'),
      block,
    })
    let { output: subData } = await sdk.api.abi.call({
      target: getAddress(CompoundLoanInfo),
      abi: getAbi(CompoundLoanInfo, 'getLoanDataArr'),
      params: [compoundSubs.map((s) => s.user)],
      block,
    })
    const activeSubs = subData.map((sub) => {
      let sumBorrowUsd = 0;
      let sumCollUsd = 0;

      sub.borrowAmounts.forEach((amount, i) => {
        if (sub.borrowAddr[i] === "0x0000000000000000000000000000000000000000")
          return;
        const borrowUsd = assetAmountInEth(amount);
        sumBorrowUsd += parseFloat(borrowUsd);
      });

      sub.collAmounts.forEach((amount, i) => {
        if (sub.collAddr[i] === "0x0000000000000000000000000000000000000000")
          return;
        const collUsd = assetAmountInEth(amount);
        sumCollUsd += parseFloat(collUsd);
      });

      return { sumBorrowUsd, sumCollUsd };
    }).filter(({ sumBorrowUsd }) => sumBorrowUsd);

    activeSubs.forEach(sub => addToBalances(sub.sumCollUsd))
  }

  async function getAaveV2Data() {
    const defaultMarket = "0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5";
    let { output: aaveSubs } = await sdk.api.abi.call({
      target: getAddress(AaveSubscriptionsV2),
      abi: getAbi(AaveSubscriptionsV2, 'getSubscribers'),
      block,
    })
    let subData = [];

    for (let i = 0; i < subData.length; i += 30) {
      let userAddresses = aaveSubs.map((s) => s.user).slice(i, i + 30)
      subData = subData.concat(
        (await sdk.api.abi.call({
          target: getAddress(AaveLoanInfoV2),
          abi: getAbi(AaveLoanInfoV2, 'getLoanDataArr'),
          params: [defaultMarket, userAddresses],
          block,
        })
        ).output
      )
    }

    const activeSubs = subData.map((sub) => {
      let sumBorrowUsd = 0;
      let sumCollUsd = 0;

      sub.borrowStableAmounts.forEach((amount, i) => {
        if (sub.borrowAddr[i] === "0x0000000000000000000000000000000000000000")
          return;
        const borrowUsd = assetAmountInEth(amount) * prices.ethereum.usd;
        sumBorrowUsd += borrowUsd;
      });

      sub.borrowVariableAmounts.forEach((amount, i) => {
        if (sub.borrowAddr[i] === "0x0000000000000000000000000000000000000000")
          return;
        const borrowUsd = assetAmountInEth(amount) * prices.ethereum.usd;
        sumBorrowUsd += borrowUsd;
      });

      sub.collAmounts.forEach((amount, i) => {
        if (sub.collAddr[i] === "0x0000000000000000000000000000000000000000")
          return;
        const collUsd = assetAmountInEth(amount) * prices.ethereum.usd;
        sumCollUsd += collUsd;
      });

      return { sumBorrowUsd, sumCollUsd };
    }).filter(({ sumBorrowUsd }) => sumBorrowUsd);

    activeSubs.forEach(sub => addToBalances(sub.sumCollUsd))
  }

  async function getMakerData() {
    let { output: makerSubs } = await sdk.api.abi.call({
      target: getAddress(McdSubscriptions),
      abi: getAbi(McdSubscriptions, 'getSubscribers'),
      block,
    })

    const getCdpDetailedInfoABI = getAbi(MCDSaverProxy, 'getCdpDetailedInfo')

    const calls = [];
    for (const cdp of makerSubs) {
      calls.push({
        target: getAddress(MCDSaverProxy),
        params: [cdp.cdpId,],
      });
    }
    const { output: callResults } = await sdk.api.abi.multiCall({
      abi: getCdpDetailedInfoABI,
      calls,
      block,
    })
    const results = {}
    callResults.forEach(result => results[result.input.params[0]] = result.output)

    let data = [];

    makerSubs.forEach((cdp, i) => {
      const asset = ilkToAsset(results[cdp.cdpId].ilk)
      const debt = assetAmountInEth(results[cdp.cdpId].debt, 'DAI')
      const collateral = assetAmountInEth(results[cdp.cdpId].collateral, `MCD-${asset}`)
      data.push({ debt, collateralUsd: parseFloat(collateral) * parseFloat(prices[keys[0][asset]].usd), })
    });
    const activeSubs = data.filter(({ debt }) => parseFloat(debt));
    activeSubs.forEach(sub => addToBalances(sub.collateralUsd))
  }

  function addToBalances(usdValue) {
    sdk.util.sumSingleBalance(balances, usdtAddress, parseFloat(usdValue) * (10 ** 6))
  }
}

module.exports = {
  ethereum: {
    tvl
  },
};

'''
'''--- projects/defiyieldprotocol/index.js ---
const { tokenHolderBalances } = require('../helper/tokenholders')
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs')

const contractFarms = {
	ethereum: [
		"0xa7d6F5fa9b0be0e98b3b40E6aC884e53F2F9460e",
		"0x0b0A544AE6131801522E3aC1FBAc6D311094c94c",
		"0x16cAaD63BDFC3Ec4A2850336B28efE17e802b896",
		"0x512FF8739d39e55d75d80046921E7dE20c3e9BFf",
		"0xeF71DE5Cb40f7985FEb92AA49D8e3E84063Af3BB",
		"0x8B0e324EEdE360CaB670a6AD12940736d74f701e",
		"0x78e2dA2eda6dF49BaE46E3B51528BAF5c106e654",
		"0x350F3fE979bfad4766298713c83b387C2D2D7a7a",
		"0x2b5D7a865A3888836d15d69dCCBad682663DCDbb",
		"0xa52250f98293c17C894d58cf4f78c925dC8955d0",
		"0x924BECC8F4059987E4bc4B741B7C354FF52c25e4",
		"0xbE528593781988974D83C2655CBA4c45FC75c033",
		"0x4a76Fc15D3fbf3855127eC5DA8AAf02DE7ca06b3",
		"0xF4abc60a08B546fA879508F4261eb4400B55099D",
		"0x13F421Aa823f7D90730812a33F8Cac8656E47dfa",
		"0x86690BbE7a9683A8bAd4812C2e816fd17bC9715C",
		"0x7Fc2174670d672AD7f666aF0704C2D961EF32c73",
		"0x036e336eA3ac2E255124CF775C4FDab94b2C42e4",
		"0x0A32749D95217b7Ee50127E24711c97849b70C6a",
		"0x82df1450eFD6b504EE069F5e4548F2D5Cb229880",
		"0xe5262f38bf13410a79149cb40429f8dc5e830542"
	],
	bsc: [
		"0x8a607e099e835bdbc4a606acb600ef475414f450",
		"0x34dd0d25fa2e3b220d1eb67460c45e586c61c2bb",
		"0xb07c67b65e6916ba87b6e3fa245aa18f77b4413e",
		"0x52adfbb5bc9f9fee825bd56feb11f1fc90e0b47e",
		"0xb4338fc62b1de93f63bfedb9fd9bac455d50a424",
		"0x2c1411d4f1647b88a7b46c838a3760f925bac83b",
		"0x2c51df297a2aa972a45ed52110afd24591c6f302",
		"0xd7180d6fea393158d42d0d0cd66ab93048f581e3",
		"0x111ae4ca424036d09b4e0fc9f1de5e6dc90d586b",
		"0x7637fa253180556ba486d2fa5d2bb328eb0aa7ca",
		"0x2f3c4a08dad0f8a56ede3961ab654020534b8a8c",
		"0x417538f319afddd351f33222592b60f985475a21",
		"0x350f3fe979bfad4766298713c83b387c2d2d7a7a",
		"0xf13aDbEb27ea9d9469D95e925e56a1CF79c06E90",
		"0xaF411BF994dA1435A3150B874395B86376C5f2d5",
		"0x9af074cE714FE1Eb32448052a38D274E93C5dc28",
		"0xDBfb96e2899d52B469C1a1C35eD71fBBa228d2cC",
		"0xc794cDb8D6aC5eB42d5ABa9c1E641ae17c239c8c",
		"0x23609B1f5274160564e4afC5eB9329A8Bf81c744",
		"0x264922696b9972687522b6e98Bf78A0430E2163C",
		"0x9DF0A645BeB6F7aDFaDC56f3689E79405337EFE2",
		"0xbd574278fEbad04b7A0694C37DeF4f2ecFa9354A",
		"0x537DC4fee298Ea79A7F65676735415f1E2882F92",
		"0x219717BF0bC33b2764A6c1A772F75305458BDA3d",
		"0xD1151a2434931f34bcFA6c27639b67C1A23D93Af",
		"0xed869Ba773c3F1A1adCC87930Ca36eE2dC73435d",
		"0x415B1624710296717FA96cAD84F53454E8F02D18",
	],
	avax: [
		"0x499c588146443235357e9c630a66d6fe0250caa1",
		"0xd8af0591be4fba56e3634c992b7fe4ff0a90b584",
		"0xbebe1fe1444a50ac6ee95ea25ba80adf5ac7322c",
		"0x79be220ab2dfcc2f140b59a97bfe6751ed1579b0",
		"0x4c7e0cbb0276a5e963266e6b9f34db73a1cb73f3"
	]
}

const dyp = "0x961C8c0B1aaD0c0b10a51FeF6a867E3091BCef17"

const lps = {
	ethereum: [
		"0xba7872534a6c9097d805d8bee97e030f4e372e54",
		"0x44b77e9ce8a20160290fcbaa44196744f354c1b7",
		"0xabd9c284116b2e757e3d4f6e36c5050aead24e0c",
		"0x76911e11fddb742d75b83c9e1f611f48f19234e4",
	],
	bsc: [
		"0x2fcf1b0d83f83135b6e5e2e231e07ae89c235f68",
		"0x87c546525cf48f28d73ea218c625d6f748721717",
		"0xc7a4d04699a9539d33e86ce746e88553149c8528",
		"0x1bC61d08A300892e784eD37b2d0E63C85D1d57fb"
	],
	avax: [
		"0x497070e8b6C55fD283D8B259a6971261E2021C01"
	]
}

function transform(chain) {
	return (addr) => {
		if (addr === dyp) {
			return dyp
		}
		return chain + ':' + addr
	}
}

function staking(chain) {
	return async (time, ethBlock, chainBlocks) => {
		const balances = {}
		await sumTokensAndLPsSharedOwners(balances, [[dyp, false]], contractFarms[chain], chainBlocks[chain], chain, transform(chain))
		return balances
	}
}

function pool2(chain) {
	return async (time, ethBlock, chainBlocks) => {
		const balances = {}
		await sumTokensAndLPsSharedOwners(balances, lps[chain].map(lp => [lp, true]), contractFarms[chain], chainBlocks[chain], chain, transform(chain))
		return balances
	}
}

module.exports = {
	start: 1619654324,        // Apr-28-2021 23:58:44 PM +UTC
	avalanche: {
		staking: staking("avax"),
		pool2: pool2("avax"),
	},
	bsc: {
		staking: staking("bsc"),
		pool2: pool2("bsc"),
	},
	ethereum: {
		staking: staking("ethereum"),
		pool2: pool2("ethereum"),
		tvl: tokenHolderBalances([
			{
				tokens: [
					'0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5', // cETH Token
					'0xccF4429DB6322D5C611ee964527D42E5d685DD6a', // cWBTC Token
					'0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9', // cUSDT Token
					'0x39AA39c021dfbaE8faC545936693aC917d5E7563', // cUSDC Token
					'0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643', // cDAI Token
				],
				holders: [
					'0x01de5bCe5C5Ee4F92e8f4183f6F4E4f12f9a86cd', // cETH Vault 3 Days Lock
					'0x3e488684c40D63Ff2b9963DFBb805Bbb3Da9b1c6', // cETH Vault 30 Days Lock
					'0x480c83Be2694BFB91F40d951424330c9123b9066', // cETH Vault 60 Days Lock
					'0xdC68450BfE4E16d74B20c44DdA83662cF2F5F0c0', // cETH Vault 90 Days Lock
					'0xe5c5a452A0f7B2d5266010Bf167A7Ee2eDF54533', // cWBTC Vault 3 Days Lock
					'0x8Ae8eC53712017EeB3378Ee112082D57da98E792', // cWBTC Vault 30 Days Lock
					'0x2D4b96e3C6176E833c013088aEcC7640af977e20', // cWBTC Vault 60 Days Lock
					'0xb95Ec2cB2D61d12c86a05e0c995d007Aec8f2850', // cWBTC Vault 90 Days Lock
					'0x18d2a323675BbE1f9d03e273a186Aea8ADf7f5c5', // cUSDT Vault 3 Days Lock
					'0xfB55dcc985517d111C65004f0EAabC1f6CE23cF1', // cUSDT Vault 30 Days Lock
					'0x8CE610eC56cE3ad3678C426f0Dfc965568Db6DdC', // cUSDT Vault 60 Days Lock
					'0x7CCFF41652eD12278E02E18de06d40Aaf5F1769B', // cUSDT Vault 90 Days Lock
					'0x94226Ae99C786b2830d27aC6e8fCdb4b0c4cc73a', // cUSDC Vault 3 Days Lock
					'0xaaC6814a1aCFE8F7Ea1f718148daC614d5323c85', // cUSDC Vault 30 Days Lock
					'0xe19328D2A528B765E30f9BC47faBb81e0f510ea9', // cUSDC Vault 60 Days Lock
					'0xE728874B81Bd0b7a9c3505949935e67D0e7136aD', // cUSDC Vault 90 Days Lock
					'0x8c1d0FD28b5FEac7f5521d05D53d7E1560A7CBCC', // cDAI Vault 30 Days Lock
					'0xF73baaC19eEEB7C4B7Cc211F3eDF88BB9F1d40f9', // cDAI Vault 30 Days Lock
					'0x8Fb2c9F8c07FaCf0aF442a1900cD2Cfe1940971B', // cDAI Vault 60 Days Lock
					'0x8ad8e5FA0f2781dA3327275049B5469275A1042E', // cDAI Vault 90 Days Lock
				],
				checkETHBalance: true,
			}
		]),

	}
}

'''
'''--- projects/defrost/abi.json ---
{
  "totalSupply": {
    "constant": true,
    "inputs": [],
    "name": "getTvl",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/defrost/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');

const abi = require('./abi');
const {gql, request} = require('graphql-request')
const {getApiTvl} = require('../helper/historicalApi')

const avaxpool = '0x34f2fe77a14afac8a7b7f18ed1e3b2c5a1e0ccbc';

const url = "https://api.thegraph.com/subgraphs/name/jeffqg123/defrost-finance-mainnet"

async function avax(timestamp) {
  return getApiTvl(timestamp, async ()=>{
    const data = await request(url, gql`
    {
      entityLp2H2OColUsdTvls(first: 1, orderBy: TimeStamp, orderDirection: desc) {
        id
        TimeStamp
        UsdValue
        __typename
      }
    }`)
    return data.entityLp2H2OColUsdTvls[0].UsdValue / 1e4
  }, async ()=>{
    const data = await request(url, gql`
    {
      entityLp2H2OColUsdTvls(first: 1000, orderBy: TimeStamp, orderDirection: asc) {
        id
        TimeStamp
        UsdValue
        __typename
      }
    }`)
    return data.entityLp2H2OColUsdTvls.map(t=>({
      date: t.TimeStamp,
      totalLiquidityUSD: t.UsdValue/1e4,
    }))
  })
}

async function staking(time, ethBlock, chainBlocks){
  const stk = await sdk.api.abi.call({
    target: "0x1e93b54AC156Ac2FC9714B91Fa10f1b65e2daFD9",
    block: chainBlocks.avax,
    chain: "avax",
    abi: {"constant":true,"inputs":[],"name":"totalStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}
  })
  return {
    "avax:0x47eb6f7525c1aa999fbc9ee92715f5231eb1241d": stk.output
  }
}

module.exports = {
  start: 6965653, 
  avax:{
    tvl: avax,
    staking
  }
};

'''
'''--- projects/defyswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl.js");
const { stakingUnknownPricedLP } = require("../helper/staking.js");

const factory = "0xAffdbEAE1ec595cba4C262Bdb52A6083aEc2e2a6";
const masterchef = "0x53e986884c55c9AEDB7f003583f350EE789505D0";
const ftm = "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83";
const dfy = "0x84b0b7718f8480a9eda3133fd385d7edf2b1d1c4";
const whitelist = [
  dfy,
  "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
  "0x321162cd933e2be498cd2267a90534a804051b11",
];

module.exports = {
  misrepresentedTokens: true,
  timetravel: true,
  doublecounted: false,
  fantom: {
    tvl: calculateUsdUniTvl(factory, "fantom", ftm, whitelist, "fantom"),
    staking: stakingUnknownPricedLP(
      masterchef,
      dfy,
      "fantom",
      "0x46c1dccC44c3255A22B8041856cff0dE8f5958D6",
      (addr) => `fantom:${addr}`
    ),
  },
};

'''
'''--- projects/degenerative/index.js ---
const sdk = require('@defillama/sdk')
const axios = require('axios')

const collaterals = {
    'WETH': '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    'USDC': '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
}

async function tvl(timestamp, block) {
    const assetsRaw = await axios.get('https://raw.githubusercontent.com/yam-finance/synths-sdk/master/src/assets.json')
    const assets =  Object.values(assetsRaw.data).map(b=>Object.values(b)).flat().flat()
    const balances = {}
    const collateralBalances = await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        block,
        calls:assets.map(asset=>({
            target: collaterals[asset.collateral],
            params: [asset.emp.address]
        }))
    })
    sdk.util.sumMultiBalanceOf(balances, collateralBalances)
  
    return balances
  }

  module.exports = {
    ethereum:{
        tvl
    },
  }

'''
'''--- projects/degenhaus/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')
const {transformFantomAddress} = require('../helper/portedTokens.js')
const {staking, stakingPricedLP} = require('../helper/staking')

const factory = '0xA01C3d760738c79e10334408aE59684Aa36B1131'
async function tvl(_timestamp, _ethBlock, chainBlocks){
  const transform = await transformFantomAddress();

  const balances = await calculateUniTvl(transform, chainBlocks['fantom'], 'fantom', factory, 3795376, true);
  return balances
}

module.exports = {
  fantom:{
    tvl,
    staking: stakingPricedLP("0x72A7A3770B4BC999026F3663F1534581E0c59f2a", "0xd948efcc99be419ca9bdace89b2bec31edf13adb", 'fantom', "0x1758d21f2915583f49cc2b3e583df3e55f0dd2c0", "fantom")
  },
}

'''
'''--- projects/dehive/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "address",
        "name": "assetToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "poolSupply",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "paused",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getUnderlyingsAmountsFromClusterAmount": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_clusterAmount",
        "type": "uint256"
      }
    ],
    "name": "getUnderlyingsAmountsFromClusterAmount",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getUnderlyings": {
    "inputs": [],
    "name": "getUnderlyings",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "impulseMultiPoolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "address",
        "name": "assetToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "poolSupply",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "paused",
        "type": "bool"
      },
      {
        "internalType": "address",
        "name": "strategy",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "wantLockedTotal": {
    "inputs": [],
    "name": "wantLockedTotal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "listUnderlying": {
    "inputs": [],
    "name": "listUnderlying",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "wantPriceInUnderlying": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_wantAmt",
        "type": "uint256"
      }
    ],
    "name": "wantPriceInUnderlying",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "wantPriceInUsd": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_wantAmt",
        "type": "uint256"
      }
    ],
    "name": "wantPriceInUsd",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "usdToken": {
    "inputs": [],
    "name": "usdToken",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/dehive/assetsInfo.js ---
// Auto generated at 9-2-2022 16:14
module.exports = {
  'ethereum' : [
    {//DHV (solo)
      meta: {
        stakingAddress: '0x04595f9010F79422a9b411ef963e4dd1F7107704', // StakingDHV
        tokenAddress: '0x62Dc4817588d53a056cBbD18231d91ffCcd34b2A', // DHV
        poolId: 0
      },
      tvl: "stakingDhvTvl"
    },
    {//DHV/ETH (lp)
      meta: {
        stakingAddress: '0x4964B3B599B82C3FdDC56e3A9Ffd77d48c6AF0f0', // StakingPools
        lpAddress: '0x60c5bf43140d6341bebfe13293567fafbe01d65b', // UNI-DHV-WETH
        dhvToken: '0x62Dc4817588d53a056cBbD18231d91ffCcd34b2A',
        underlying: [
          '0x62Dc4817588d53a056cBbD18231d91ffCcd34b2A', // DHV
          '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // WETH
        ],
        isPool2: true,
        poolId: 0
      },
      tvl: "lpStakingTvl"
    },
    {//DECR (cluster)
      meta: {
        clusterAddress: '0x6Bc3F65Fc50E49060e21eD6996be96ee4B404752', // DECR
      },
      tvl: "clusterTvl"
    },
  ],
  'polygon' : [
    {//DHV (solo)
      meta: {
        stakingAddress: '0x88cFC1bc9aEb80f6C8f5d310d6C3761c2a646Df7', // StakingDHV
        tokenAddress: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26', // DHV
        poolId: 0
      },
      tvl: "stakingDhvTvl"
    },
    {//Stable Curve 3-Pool (impulse-multiple)
      meta: {
        stakingAddress: '0xE6E6982fb5dDF4fcc74cCCe4e4eea774E002D17F', // ImpulseMultiStaking
        poolId: 1
      },
      tvl: "crvStakingTvl"
    },
    {//Curve 5-Pool (impulse-multiple)
      meta: {
        stakingAddress: '0xE6E6982fb5dDF4fcc74cCCe4e4eea774E002D17F', // ImpulseMultiStaking
        poolId: 0
      },
      tvl: "crvStakingTvl"
    },
    {//DHV/QUICK (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0xfd0E242c95b271844bf6860D4bC0E3e136bC0f7C', // QCK-DHV-QUICK
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26', // DHV
          '0x831753DD7087CaC61aB5644b308642cc1c33Dc13', // QUICK
        ],
        poolId: 0
      },
      tvl: "impulseStakingTvl"
    },
    {//WETH/DAI (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0x4A35582a710E1F4b2030A3F826DA20BfB6703C09', // QCK-WETH-DAI
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
          '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', // DAI
        ],
        poolId: 1
      },
      tvl: "impulseStakingTvl"
    },
    // COMMENTED THIS OUT BECAUSE 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    // {//USDC/QUICK (impulse)
    //   meta: {
    //     stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
    //     lpAddress: '0x1F1E4c845183EF6d50E9609F16f6f9cAE43BC9Cb', // QCK-USDC-QUICK
    //     dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
    //     underlying: [
    //       '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC
    //       '0x831753DD7087CaC61aB5644b308642cc1c33Dc13', // QUICK
    //     ],
    //     poolId: 2
    //   },
    //   tvl: "impulseStakingTvl"
    // },
    // COMMENTED THIS OUT BECAUSE 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    // {//USDT/MAI (impulse)
    //   meta: {
    //     stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
    //     lpAddress: '0xE89faE1B4AdA2c869f05a0C96C87022DaDC7709a', // QCK-MAI-USDT
    //     dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
    //     underlying: [
    //       '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', // USDT
    //       '0xa3fa99a148fa48d14ed51d610c367c61876997f1', // MAI
    //     ],
    //     poolId: 4
    //   },
    //   tvl: "impulseStakingTvl"
    // },
    {//AVAX/WETH (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0x1274De0DE2e9D9b1d0E06313c0E5EdD01CC335eF', // SUSHI-AVAX-WETH
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x2C89bbc92BD86F8075d1DEcc58C7F4E0107f286b', // AVAX
          '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
        ],
        poolId: 5
      },
      tvl: "impulseStakingTvl"
    },
    {//WMATIC/WETH (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0xc4e595acDD7d12feC385E5dA5D43160e8A0bAC0E', // SUSHI-WMATIC-WETH
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', // WMATIC
          '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
        ],
        poolId: 6
      },
      tvl: "impulseStakingTvl"
    },
    {//CRV/WETH (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0x396E655C309676cAF0acf4607a868e0CDed876dB', // SUSHI-CRV-WETH
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x172370d5Cd63279eFa6d502DAB29171933a610AF', // CRV
          '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
        ],
        poolId: 7
      },
      tvl: "impulseStakingTvl"
    },
    {//SNX/WETH (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0x116Ff0d1Caa91a6b94276b3471f33dbeB52073E7', // SUSHI-SNX-WETH
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x50B728D8D964fd00C2d0AAD81718b71311feF68a', // SNX
          '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
        ],
        poolId: 8
      },
      tvl: "impulseStakingTvl"
    },
    {//WMATIC/GHST (impulse)
      meta: {
        stakingAddress: '0xf4feb23531EdBe471a4493D432f8BB29Bf0A3868', // ImpulseStaking
        lpAddress: '0xf69e93771F11AECd8E554aA165C3Fe7fd811530c', // SUSHI-WMATIC-GHST
        dhvToken: '0x5fCB9de282Af6122ce3518CDe28B7089c9F97b26',
        underlying: [
          '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', // WMATIC
          '0x385eeac5cb85a38a9a07a70c73e0a3271cfb54a7', // GHST
        ],
        poolId: 9
      },
      tvl: "impulseStakingTvl"
    },
    {//DPOL (cluster)
      meta: {
        clusterAddress: '0x4964B3B599B82C3FdDC56e3A9Ffd77d48c6AF0f0', // DPOL
      },
      tvl: "clusterTvl"
    },
    {//DGAME (cluster)
      meta: {
        clusterAddress: '0x589Ea336092184d9eD74b8263c4eecA73Ed0cE7a', // DGAME
      },
      tvl: "clusterTvl"
    },
  ],
  'bsc' : [
    {//DHV (solo)
      meta: {
        stakingAddress: '0x35f28aA0B2F34eFF17d2830135312ab2a777De36', // StakingDHV
        tokenAddress: '0x58759dd469ae5631c42cf8a473992335575b58d7', // DHV
        poolId: 0
      },
      tvl: "stakingDhvTvl"
    },
    {//DHV/BUSD (lp)
      meta: {
        stakingAddress: '0xF2e8CD1c40C766FEe73f56607fDffa526Ba8fa6c', // StakingPools
        lpAddress: '0x72ba008B631D9FD5a8E8013023CB3c05E19A7CA9', // PANCAKE-DHV-BUSD
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x58759dd469ae5631c42cf8a473992335575b58d7', // DHV
          '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', // BUSD
        ],
        isPool2: true,
        poolId: 0
      },
      tvl: "lpStakingTvl"
    },
    {//CAKE/BUSD (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x804678fa97d91B974ec2af3c843270886528a9E6', // PANCAKE-CAKE-BUSD
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', // CAKE
          '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', // BUSD
        ],
        poolId: 0
      },
      tvl: "impulseStakingTvl"
    },
    {//USDT/USDC (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0xEc6557348085Aa57C72514D67070dC863C0a5A8c', // PANCAKE-BUSDT-USDC
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x55d398326f99059fF775485246999027B3197955', // BUSDT
          '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', // BUSDC
        ],
        poolId: 1
      },
      tvl: "impulseStakingTvl"
    },
    {//USDT/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE', // PANCAKE-BUSDT-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x55d398326f99059fF775485246999027B3197955', // BUSDT
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 2
      },
      tvl: "impulseStakingTvl"
    },
    {//XVS/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x7EB5D86FD78f3852a3e0e064f2842d45a3dB6EA2', // PANCAKE-XVS-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63', // XVS
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 3
      },
      tvl: "impulseStakingTvl"
    },
    {//ALPACA/BUSD (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x7752e1FA9F3a2e860856458517008558DEb989e3', // PANCAKE-ALPACA-BUSD
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F', // ALPACA
          '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', // BUSD
        ],
        poolId: 4
      },
      tvl: "impulseStakingTvl"
    },
    {//LINK/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x824eb9faDFb377394430d2744fa7C42916DE3eCe', // PANCAKE-LINK-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD', // LINK
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 5
      },
      tvl: "impulseStakingTvl"
    },
    {//CAKE/USDT (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0xA39Af17CE4a8eb807E076805Da1e2B8EA7D0755b', // PANCAKE-CAKE-BUSDT
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', // CAKE
          '0x55d398326f99059fF775485246999027B3197955', // BUSDT
        ],
        poolId: 6
      },
      tvl: "impulseStakingTvl"
    },
    {//DODO/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0xA9986Fcbdb23c2E8B11AB40102990a08f8E58f06', // PANCAKE-DODO-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x67ee3Cb086F8a16f34beE3ca72FAD36F7Db929e2', // DODO
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 7
      },
      tvl: "impulseStakingTvl"
    },
    {//BANANA/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0xF65C1C0478eFDe3c19b49EcBE7ACc57BB6B1D713', // APE-BANANA-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95', // BANANA
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 8
      },
      tvl: "impulseStakingTvl"
    },
    {//BANANA/BUSD (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x7Bd46f6Da97312AC2DBD1749f82E202764C0B914', // APE-BANANA-BUSD
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95', // BANANA
          '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', // BUSD
        ],
        poolId: 9
      },
      tvl: "impulseStakingTvl"
    },
    {//TWT/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x4c48D692e3de076C7b844B956b28cdd1DD5C0945', // APE-TWT-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x4B0F1812e5Df2A09796481Ff14017e6005508003', // TWT
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 10
      },
      tvl: "impulseStakingTvl"
    },
    {//AVAX/WBNB (impulse)
      meta: {
        stakingAddress: '0xA9c97Ff825dB9dd53056d65aE704031B4959d99a', // ImpulseStaking
        lpAddress: '0x40aFc7CBd0Dc2bE5860F0035b717d20Afb4827b2', // APE-AVAX-WBNB
        dhvToken: '0x58759dd469ae5631c42cf8a473992335575b58d7',
        underlying: [
          '0x1CE0c2827e2eF14D5C4f29a091d735A204794041', // AVAX
          '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        ],
        poolId: 11
      },
      tvl: "impulseStakingTvl"
    },
    {//DBSC (cluster)
      meta: {
        clusterAddress: '0x0a684421ef48b431803BFd75F38675EAb1e38Ed5', // DBSC
      },
      tvl: "clusterTvl"
    },
  ],
  'xdai' : [
    {//DHV (solo)
      meta: {
        stakingAddress: '0x589Ea336092184d9eD74b8263c4eecA73Ed0cE7a', // StakingDHV
        tokenAddress: '0xFbdd194376de19a88118e84E279b977f165d01b8', // DHV
        poolId: 0
      },
      tvl: "stakingDhvTvl"
    },
    {//DHV/XDAI (lp)
      meta: {
        stakingAddress: '0xa4E7BE054000603B82B79208aC3eE5428554CaF6', // StakingPools
        lpAddress: '0x14EE6d20B8167eacb885F4F2F45C3Bf2d4FD06f4', // HONEY-DHV-WXDAI
        dhvToken: '0xFbdd194376de19a88118e84E279b977f165d01b8',
        underlying: [
          '0xFbdd194376de19a88118e84E279b977f165d01b8', // DHV
          '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // WXDAI
        ],
        isPool2: true,
        poolId: 1
      },
      tvl: "lpStakingTvl"
    },
    {//Stable Curve 3-Pool (impulse-multiple)
      meta: {
        stakingAddress: '0xfa7Ca14a28CD419a69E45e8416cA4FA87457aCE8', // ImpulseMultiStaking
        poolId: 0
      },
      tvl: "crvStakingTvl"
    },
    {//DXDC (cluster)
      meta: {
        clusterAddress: '0xF557B2B73b872E6d2F43826f9D77B7402A363Bc0', // DXDC
      },
      tvl: "clusterTvl"
    },
    {//DXIN (cluster)
      meta: {
        clusterAddress: '0xA6C090c5572f54d529B0839b8fd2D50a4afB1E6B', // DXIN
      },
      tvl: "clusterTvl"
    },
  ],
};

'''
'''--- projects/dehive/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const abi = require('./abi.json')

const assetsInfo = require("./assetsInfo");

const EXPORT_TYPE_TVL = 0;
const EXPORT_TYPE_DHV_STAKING = 1;
const EXPORT_TYPE_POOL2 = 2;

async function stakingTvl(chain, meta, ethBlock) {
    return (await sdk.api.abi.call({
        target: meta.stakingAddress,
        abi: abi.poolInfo,
        params: meta.poolId,
        chain,
        block: ethBlock
    })).output.poolSupply;
}

async function stakingDhvTvl(chain, meta, ethBlock) {
    return (await sdk.api.abi.call({
        target: meta.tokenAddress,
        abi: abi.balanceOf,
        params: meta.stakingAddress,
        chain,
        block: ethBlock
    })).output;
}

async function lpStakingTvl(chain, meta, ethBlock) {
    const { poolSupply } = (await sdk.api.abi.call({
        target: meta.stakingAddress,
        abi: abi.poolInfo,
        params: meta.poolId,
        chain,
        block: ethBlock
    })).output;
    const poolSupplyBN = new BigNumber(poolSupply);

    const lpTotalSupply = (await sdk.api.abi.call({
        target: meta.lpAddress,
        abi: abi.totalSupply,
        chain,
        block: ethBlock
    })).output;
    const lpTotalSupplyBN = new BigNumber(lpTotalSupply);

    const tvl = [];
    for (let i = 0; i < meta.underlying.length; i++) {
        const underlyingLpBalance = (await sdk.api.abi.call({
            target: meta.underlying[i],
            abi: abi.balanceOf,
            params: meta.lpAddress,
            chain,
            block: ethBlock
        })).output;
        const underlyingLpBalanceBN = new BigNumber(underlyingLpBalance);
        const underlyingTvl = poolSupplyBN.multipliedBy(underlyingLpBalanceBN).div(lpTotalSupplyBN);

        tvl.push([meta.underlying[i], underlyingTvl.integerValue().toFixed()]);
    }

    if (meta.dhvToken) {
        const dhvBalance = (await sdk.api.abi.call({
            target: meta.dhvToken,
            abi: abi.balanceOf,
            params: meta.stakingAddress,
            chain,
            block: ethBlock
        })).output;
        tvl.push([meta.dhvToken, dhvBalance]);
    }
    return tvl;
}

async function crvStakingTvl(chain, meta, ethBlock) {
    const { strategy } = (await sdk.api.abi.call({
        target: meta.stakingAddress,
        abi: abi.impulseMultiPoolInfo,
        params: meta.poolId,
        chain,
        block: ethBlock
    })).output;

    const wantLockedTotal = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.wantLockedTotal,
        chain,
        block: ethBlock
    })).output;

    const underlyingList = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.listUnderlying,
        chain,
        block: ethBlock
    })).output;

    const underlyingAmount = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.wantPriceInUnderlying,
        params: wantLockedTotal,
        chain,
        block: ethBlock
    })).output;

    return underlyingList.map((_, i) => [underlyingList[i], underlyingAmount[i]]);
}

async function impulseStakingTvl(chain, meta, ethBlock) {
    if (chain === 'bsc') {
        return await lpStakingTvl(chain, meta, ethBlock); // from staking pool
    }
    const { strategy } = (await sdk.api.abi.call({
        target: meta.stakingAddress,
        abi: abi.impulseMultiPoolInfo,
        params: meta.poolId,
        chain,
        block: ethBlock
    })).output;

    const wantLockedTotal = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.wantLockedTotal,
        chain,
        block: ethBlock
    })).output;

    const usdToken = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.usdToken,
        chain,
        block: ethBlock
    })).output;

    const wantPrice = (await sdk.api.abi.call({
        target: strategy,
        abi: abi.wantPriceInUsd,
        params: wantLockedTotal,
        chain,
        block: ethBlock
    })).output;

    let tvl = await lpStakingTvl(chain, meta, ethBlock); // from staking pool
    tvl.push([usdToken, wantPrice]); // from strategy

    return tvl;
}

async function clusterTvl(chain, meta, ethBlock) {
    const poolSupply = (await sdk.api.abi.call({
        target: meta.clusterAddress,
        abi: "erc20:totalSupply",
        chain,
        block: ethBlock
    })).output;

    const underlyingList = (await sdk.api.abi.call({
        target: meta.clusterAddress,
        abi: abi.getUnderlyings,
        chain,
        block: ethBlock
    })).output;

    const underlyingAmount = (await sdk.api.abi.call({
        target: meta.clusterAddress,
        abi: abi.getUnderlyingsAmountsFromClusterAmount,
        params: poolSupply,
        chain,
        block: ethBlock
    })).output;

    return underlyingList.map((_, i) => [underlyingList[i], underlyingAmount[i]]);
}

async function chainTvl(chain, chainBlocks, exportType) {
    const tvl = {};
    const transform = addr => `${chain}:${addr}`
    const block = chainBlocks[chain]
    for (const staking of assetsInfo[chain]) {
        let calculateTvlFunction = undefined;
        switch (staking.tvl) {
            case "stakingTvl":
                calculateTvlFunction = stakingTvl;
                break;
            case "stakingDhvTvl":
                calculateTvlFunction = stakingDhvTvl;
                break;
            case "lpStakingTvl":
                calculateTvlFunction = lpStakingTvl;
                break;
            case "crvStakingTvl":
                calculateTvlFunction = crvStakingTvl;
                break;
            case "clusterTvl":
                calculateTvlFunction = clusterTvl;
                break;
            case "impulseStakingTvl":
                calculateTvlFunction = impulseStakingTvl;
                break;
            default:
                console.log('unknown tvl type', JSON.stringify(staking, null,4));
                continue;
        }
        if (
          (staking.tvl === "stakingDhvTvl" && exportType !== EXPORT_TYPE_DHV_STAKING)
          || (staking.tvl !== "stakingDhvTvl" && exportType === EXPORT_TYPE_DHV_STAKING)
          || (staking.tvl === "lpStakingTvl" && exportType === EXPORT_TYPE_POOL2 && (staking.isPool2 !== true))
          || (staking.tvl === "lpStakingTvl" && exportType !== EXPORT_TYPE_POOL2 && (staking.isPool2 === true))
        ) {
            continue;
        }
        const tvls = await calculateTvlFunction(chain, staking.meta, block);
        if (typeof tvls === 'string') {
            sdk.util.sumSingleBalance(tvl, transform(staking.meta.tokenAddress), tvls)
        } else {
            for (let i = 0; i < tvls.length; i++) {
                sdk.util.sumSingleBalance(tvl, transform(tvls[i][0]), tvls[i][1])
            }
        }
    }
    return tvl
}

async function ethereumTvl(timestamp, ethBlock, chainBlocks) {
    return chainTvl('ethereum', chainBlocks, EXPORT_TYPE_TVL);
}

async function polygonTvl(timestamp, ethBlock, chainBlocks) {
    return chainTvl('polygon', chainBlocks, EXPORT_TYPE_TVL);
}

async function bscTvl(timestamp, ethBlock, chainBlocks) {
    return chainTvl('bsc', chainBlocks, EXPORT_TYPE_TVL);
}

async function xdaiTvl(timestamp, ethBlock, chainBlocks) {
    return chainTvl('xdai', chainBlocks, EXPORT_TYPE_TVL);
}

async function ethereumStaking(timestamp, ethBlock, chainBlocks) {
    return chainTvl('ethereum', chainBlocks, EXPORT_TYPE_DHV_STAKING);
}

async function polygonStaking(timestamp, ethBlock, chainBlocks) {
    return chainTvl('polygon', chainBlocks, EXPORT_TYPE_DHV_STAKING);
}

async function bscStaking(timestamp, ethBlock, chainBlocks) {
    return chainTvl('bsc', chainBlocks, EXPORT_TYPE_DHV_STAKING);
}

async function xdaiStaking(timestamp, ethBlock, chainBlocks) {
    return chainTvl('xdai', chainBlocks, EXPORT_TYPE_DHV_STAKING);
}

async function ethereumPool2(timestamp, ethBlock, chainBlocks) {
    return chainTvl('ethereum', chainBlocks, EXPORT_TYPE_POOL2);
}

async function polygonPool2(timestamp, ethBlock, chainBlocks) {
    return chainTvl('polygon', chainBlocks, EXPORT_TYPE_POOL2);
}

async function bscPool2(timestamp, ethBlock, chainBlocks) {
    return chainTvl('bsc', chainBlocks, EXPORT_TYPE_POOL2);
}

async function xdaiPool2(timestamp, ethBlock, chainBlocks) {
    return chainTvl('xdai', chainBlocks, EXPORT_TYPE_POOL2);
}

module.exports = {
    ethereum: {
        tvl: ethereumTvl,
        pool2: ethereumPool2,
        staking: ethereumStaking
    },
    polygon: {
        tvl: polygonTvl,
        pool2: polygonPool2,
        staking: polygonStaking
    },
    bsc: {
        tvl: bscTvl,
        pool2: bscPool2,
        staking: bscStaking
    },
    xdai: {
        tvl: xdaiTvl,
        pool2: xdaiPool2,
        staking: xdaiStaking
    }
};

'''
'''--- projects/delta/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const { staking } = require("../helper/staking");

const vaultStakingContract = "0x9fE9Bb6B66958f2271C4B0aD23F6E8DDA8C221BE";
const rebasingContract = "0xfcfC434ee5BfF924222e084a8876Eee74Ea7cfbA";
const DELTA_WETH_SLP = "0x1498bd576454159Bb81B5Ce532692a8752D163e8";

const DELTA = "0x9EA3b5b4EC044b70375236A281986106457b20EF";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";

async function Pool2(timestamp, block) {
  const balances = {};

  const totalSupply_slp = (
    await sdk.api.erc20.totalSupply({
      target: DELTA_WETH_SLP,
    })
  ).output;

  const totalSupply_rlp = (
    await sdk.api.erc20.totalSupply({
      target: rebasingContract,
    })
  ).output;

  const balance_slp = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: DELTA_WETH_SLP,
      params: rebasingContract,
      block
    })
  ).output;

  const balance_rlp = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: rebasingContract,
      params: vaultStakingContract,
      block
    })
  ).output;

  const underlyingsBalance = (
    await sdk.api.abi.multiCall({
      calls: [DELTA, WETH].map((token) => ({
        target: token,
        params: DELTA_WETH_SLP,
      })),
      abi: 'erc20:balanceOf',
      block
    })
  ).output;

  underlyingsBalance.forEach((call) => {
    const underlyingSetBalance = BigNumber(call.output)
      .times(balance_slp)
      .div(totalSupply_slp)
      .times(balance_rlp)
      .div(totalSupply_rlp);

    sdk.util.sumSingleBalance(
      balances,
      call.input.target,
      underlyingSetBalance.toFixed(0)
    );
  });

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(vaultStakingContract, DELTA),
    pool2: Pool2,
    tvl: async () => ({})
  },
  methodology: "Counts liquidty on the Staking and Pool2",
};

'''
'''--- projects/deltatheta/factory.abi.js ---
module.exports = {
  pairsLength: {
    inputs: [],
    name: 'pairsLength',
    outputs: [
      {
        internalType: 'uint16',
        name: '',
        type: 'uint16',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  pairsList: {
    inputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
    name: 'pairsList',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
};

'''
'''--- projects/deltatheta/index.js ---
const sdk = require('@defillama/sdk');
const {
  transformBscAddress,
  transformPolygonAddress,
} = require('../helper/portedTokens');
const { getTokens } = require('../helper/getTokens');

// Delta.theta Factory ABI (for needed calls)
const factoryABI = require('./factory.abi');

// Delta.theta Factory Address (On all chains)
const FACTORY_ADDRESS = '0x000000000092126dc1bcec881165f92169733106';

// Idk why, but convenient [...Array(10).keys()] method is not working in adapter testing
const range = (n) => Array.from({ length: n }, (_, i) => i);

// TVL function generator (for BSC & POLYGON chains)
function tvl(chain) {
  const balances = {};

  return async (_, __, chainBlocks) => {
    // Prepare transform function for the selected chain
    const transform = await (
      chain === 'bsc'
        ? transformBscAddress()
        : transformPolygonAddress()
    );

    // Parse factory's pairs length
    const pairsLength = (await sdk.api.abi.call({
      abi: factoryABI.pairsLength,
      chain,
      target: FACTORY_ADDRESS,
      params: [],
      block: chainBlocks[chain],
    })).output;

    const pairsOutput = (await sdk.api.abi.multiCall({
      abi: factoryABI.pairsList,
      chain,
      calls: range(pairsLength).map((index) => ({
        target: FACTORY_ADDRESS,
        params: [index]
      })),
      block: chainBlocks[chain],
      requery: true
    })).output
    const pairs = pairsOutput.map(result => result.output.toLowerCase())

    await Promise.all(range(pairsLength).map(
      async (i) => {
        // Parse tokens list for each of pair addresses
        const tokens = await getTokens(pairs[i], chain);

        // Parse all balances
        const balancesOutput = (await sdk.api.abi.multiCall({
          abi: 'erc20:balanceOf',
          chain,
          calls: tokens.map((token) => ({
            target: token,
            params: [pairs[i]]
          })),
          block: chainBlocks[chain],
          requery: true,
        }));

        // Sum all balances
        await sdk.util.sumMultiBalanceOf(
          balances,
          balancesOutput,
          true,
          transform,
        );
      }
    ));

    return balances;
  };
}
module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology: 'Parsing the balances of all tokens on the pair addresses of decentralized exchange Delta.theta',
  start: 0,
  bsc: {
    tvl: tvl('bsc'),
  },
  polygon: {
    tvl: tvl('polygon'),
  },
};

'''
'''--- projects/demeter.js ---
const retry = require('./helper/retry')
const axios = require("axios");
const sdk = require('@defillama/sdk');
const { transformHecoAddress } = require('./helper/portedTokens');
const { unwrapUniswapLPs } = require("./helper/unwrapLPs");
const { getBlock } = require('./helper/getBlock')

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  const transform = await transformHecoAddress();

  let liquidity = (await retry(async bail => 
    await axios.get('https://demeter.xyz/app/api/market_global_data', {
        headers: { 'x-chain-id': '128' }
    }))).data.data.marketList;

  for (let i = 0; i < liquidity.length; i++) {
    sdk.util.sumSingleBalance(
        balances, 
        transform(liquidity[i].assetToken), 
        liquidity[i].availableLiquidity
    );
  };

  return balances;
};

async function staking(timestamp, block, chainBlocks) {
    let balances = {};
    const transform = await transformHecoAddress();
    block = await getBlock(timestamp, 'heco', chainBlocks);

    let liquidity = (await retry(async bail => 
      await axios.get('https://demeter.xyz/app/api/staking_global_data', {
          headers: { 'x-chain-id': '128' }
      }))).data.data;
  
    for (let i = 0; i < liquidity.eip20Pools.length; i++) {
        try {
            await unwrapUniswapLPs(balances, 
                [{ 
                    token: liquidity.eip20Pools[i].stakingToken,
                    balance: liquidity.eip20Pools[i].totalBalance 
                }], 
                block, 
                'heco', 
                transform);

        } catch { 
            sdk.util.sumSingleBalance(
                balances, 
                transform(liquidity.eip20Pools[i].stakingToken), 
                liquidity.eip20Pools[i].totalBalance
            );
        }
    };

    sdk.util.sumSingleBalance(
        balances, 
        transform(liquidity.daoStakingToken), 
        liquidity.globalDaoData.totalBalance
    );

    return balances;
};

// node test.js projects/demeter.js
module.exports = {
    heco: {
        tvl,
        staking
    }
};
'''
'''--- projects/demeter/index.js ---
const retry = require('async-retry')
const axios = require("axios");

async function fetch() {
  let results = await retry(async bail => await axios.get('https://farming-api.cerestoken.io/get-supply-data'));
  return results.data.tvl;
}

module.exports = {
  fetch
}
'''
'''--- projects/demodyfi/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const wGLMR = "0x5f6c5C2fB289dB2228d159C69621215e354218d7";
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");

async function dmodBscStakingPool(timestamp, block, chainBlocks) {
  const stakingBalance = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:balanceOf",
        chain: "bsc",
        target: "0x002D8563759f5e1EAf8784181F3973288F6856e4",
        params: ["0xc94e085E2E2D92A950fa4A6B923263C0B47c6dBa"],
        block: chainBlocks["bsc"],
      })
    ).output
  );

  const decimals = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:decimals",
        chain: "bsc",
        target: "0x002D8563759f5e1EAf8784181F3973288F6856e4",
        params: [],
        block: chainBlocks["bsc"],
      })
    ).output
  );

  return { 'demodyfi': stakingBalance.div(new BigNumber(10).pow(decimals)).toFixed(0) };
}
async function dmodEthereumStakingPool(timestamp, block, chainBlocks) {
  const stakingBalance = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:balanceOf",
        chain: "ethereum",
        target: "0x5f6c5c2fb289db2228d159c69621215e354218d7",
        params: ["0x024D59Ac0Bb03dEd28B9A16cd50B3d242B43a683"],
        block
      })
    ).output
  );

  const decimals = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:decimals",
        chain: "ethereum",
        target: "0x5f6c5c2fb289db2228d159c69621215e354218d7",
        params: [],
        block
      })
    ).output
  );

  return { 'demodyfi': stakingBalance.div(new BigNumber(10).pow(decimals)).toFixed(0) };
}
async function dmodBscLPPool(timestamp, block, chainBlocks) {
  const transform = await transformBscAddress();
  const balances = {};

  const lpTokenbalance = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:balanceOf",
        chain: "bsc",
        target: "0x0f35d854C267D29C0E418F561b75aE09B9E413D4",
        params: ["0xc94e085E2E2D92A950fa4A6B923263C0B47c6dBa"],
        block: chainBlocks["bsc"],
      })
    ).output
  );

  await unwrapUniswapLPs(
    balances,
    [
      {
        balance: lpTokenbalance,
        token: "0x0f35d854C267D29C0E418F561b75aE09B9E413D4",
      },
    ],
    chainBlocks["bsc"],
    "bsc",
    transform
  );

  return balances;
}
async function dmodEthereumLPPool(timestamp, block, chainBlocks) {
  const balances = {};

  const lpTokenbalance = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: "erc20:balanceOf",
        chain: "ethereum",
        target: "0xD5B1Cd8D245A93E0697707AEe82497388508b132",
        params: ["0x024D59Ac0Bb03dEd28B9A16cd50B3d242B43a683"],
        block
      })
    ).output
  );

  await unwrapUniswapLPs(
    balances,
    [
      {
        balance: lpTokenbalance,
        token: "0xD5B1Cd8D245A93E0697707AEe82497388508b132",
      },
    ],
    block,
    "ethereum"
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: () => ({}),
    staking: dmodEthereumStakingPool,
    pool2: dmodEthereumLPPool
  },
  bsc: {
    tvl: () => ({}),
    staking: dmodBscStakingPool,
    pool2: dmodBscLPPool
  },
  moonbeam: {
    tvl: calculateUsdUniTvl(
      "0x61999fAb7fdcEe1B26b82b5c2f825BCC8F8c2458",
      "moonbeam",
      wGLMR,
      [],
      "moonbeam"
    ),
  },
};
// node test.js projects/demodyfi/index.js
'''
'''--- projects/depth/index.js ---
const sdk = require('@defillama/sdk');

const formalDeposit = {
    "coins": {
        "name": "coins",
        "outputs": [{ "type": "address", "name": "out" }],
        "inputs": [{ "type": "int128", "name": "arg0" }],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 1680
    },
    "curve": {
        "name": "curve",
        "outputs": [{ "type": "address", "name": "out" }],
        "inputs": [],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 1541
    },
    "underlying_coins": {
        "name": "underlying_coins",
        "outputs": [{ "type": "address", "name": "out" }],
        "inputs": [{ "type": "int128", "name": "arg0" }],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 1710
    }
};
const formalSwapPool = {
    "balances": {
        "name": "balances",
        "outputs": [{ "type": "uint256", "name": "out" }],
        "inputs": [{ "type": "int128", "name": "arg0" }],
        "constant": true,
        "payable": false,
        "type": "function",
        "gas": 2430
    }
};
const erc20 = {
    "decimals": {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
};
const cToken = {
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
};
const mdexRouter = {
    "getAmountsOut": {
        "inputs": [{
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
        }, { "internalType": "address[]", "name": "path", "type": "address[]" }],
        "name": "getAmountsOut",
        "outputs": [{ "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }],
        "stateMutability": "view",
        "type": "function"
    },
    "getAmountsIn": {
        "inputs": [{
            "internalType": "uint256",
            "name": "amountOut",
            "type": "uint256"
        }, { "internalType": "address[]", "name": "path", "type": "address[]" }],
        "name": "getAmountsIn",
        "outputs": [{ "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }],
        "stateMutability": "view",
        "type": "function"
    }
};

const vaultAbi = {
    "getSelfUnderlying":{"inputs":[],"name":"getSelfUnderlying","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    "balance":{"inputs":[],"name":"balance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}
const daoAbi={"sharesAndRewardsInfo":{"inputs":[],"name":"sharesAndRewardsInfo","outputs":[{"internalType":"uint256","name":"activeShares","type":"uint256"},{"internalType":"uint256","name":"pendingSharesToAdd","type":"uint256"},{"internalType":"uint256","name":"pendingSharesToReduce","type":"uint256"},{"internalType":"uint256","name":"rewards","type":"uint256"},{"internalType":"uint256","name":"claimedRewards","type":"uint256"},{"internalType":"uint256","name":"lastUpdatedEpochFlag","type":"uint256"}],"stateMutability":"view","type":"function"}}

const swapPoolAbiV2 ={
    "balances":{"name":"balances","outputs":[{"type":"uint256","name":""}],"inputs":[{"type":"uint256","name":"arg0"}],"stateMutability":"view","type":"function","gas":2220},
    "coins":{"name":"coins","outputs":[{"type":"address","name":""}],"inputs":[{"type":"uint256","name":"arg0"}],"stateMutability":"view","type":"function","gas":2190}
}

const channels = '0x11bFEE9D8625ac4cDa6Ce52EeBF5caC7DC033d15';
const filda = '0xE796c55d6af868D8c5E4A92e4fbCF8D8F88AcDED';
const lendhub = '0xdA0519AA3F097A3A5b1325cb1D380C765d8F1D70';
const lendhubeth = '0x15155042F8d13Db274224AF4530397f640f69274';

const fildaSwapV2Address="0xa7a0EA0C5D2257e44Ad87d10DB90158c9c5c54b3"

const vaultGroup=[
    {
        "IsHUSD": false,
        "Vaults": [
            {
                "Name": "Filda",
                "ContractAddress": "0x6FF92A0e4dA9432a79748A15c5B8eCeE6CF0eE66",
                "TokenName": "dfUSDT"
            },
            {
                "Name": "Channels",
                "ContractAddress": "0x95c258E41f5d204426C33628928b7Cc10FfcF866",
                "TokenName": "dcUSDT"
            },
            {
                "Name": "Lendhub",
                "ContractAddress": "0x70941A63D4E24684Bd746432123Da1fE0bFA1A35",
                "TokenName": "dlUSDT"
            },
            {
                "Name": "Back",
                "ContractAddress": "0x22BAd7190D3585F6be4B9fCed192E9343ec9d5c7",
                "TokenName": "dbUSDT"
            },
            {
                "Name": "Pilot",
                "ContractAddress": "0xB567bd78A4Ef08EE9C08762716B1699C46bA5ea3",
                "TokenName": "plUSDT"
            },
            {
                "Name": "CoinWind",
                "ContractAddress": "0xd96e3FeDbF4640063F2B20Bd7B646fFbe3c774FF",
                "TokenName": "cwUSDT"
            }
        ]
    },
    {
        "IsHUSD": true,
        "Vaults": [
            {
                "Name": "Lendhub",
                "ContractAddress": "0x80Da2161a80f50fea78BE73044E39fE5361aC0dC",
                "TokenName": "dlHUSD"
            },
            {
                "Name": "Filda",
                "ContractAddress": "0xE308880c215246Fa78753DE7756F9fc814D1C186",
                "TokenName": "dfHUSD"
            },
            {
                "Name": "Channels",
                "ContractAddress": "0x9213c6269Faed1dE6102A198d05a6f9E9D70e1D0",
                "TokenName": "dcHUSD"
            },
            {
                "Name": "Back",
                "ContractAddress": "0x996a0e31508E93EB53fd27d216E111fB08E22255",
                "TokenName": "dbHUSD"
            },
            {
                "Name": "Pilot",
                "ContractAddress": "0x9bd25Ed64F55f317d0404CCD063631CbfC4fc90b",
                "TokenName": "plHUSD"
            },
            {
                "Name": "CoinWind",
                "ContractAddress": "0x7e1Ac905214214c1E339aaFBA72E2Ce29a7bEC22",
                "TokenName": "cwHUSD"
            }
        ]
    }
]

const VaultGroupBsc= [
    {
      "CoinName": "USDT",
      "Vaults": [
        {
          "Name": "Alpaca",
          "ContractAddress": "0xcB08DA2339d562b66b314d2bBfB580CB87FFBD76",
          "TokenName": "alUSDT",
          "Pid": 11
        },
        {
          "Name": "Venus",
          "ContractAddress": "0x3253041F27416c975FFb0100b08734187F82c8A2",
          "TokenName": "vUSDT",
          "Pid": 10
        },
        {
          "Name": "Coinwind",
          "ContractAddress": "0x0B28a55dbBd6c5DdD4D1d7157361e9D6D0CcEfC0",
          "TokenName": "cwUSDT",
          "Pid": 8
        }
      ]
    },
    {
      "CoinName": "BUSD",
      "Vaults": [
        {
          "Name": "Alpaca",
          "ContractAddress": "0xAf996B5E33007ed5EB33eaAe817ad8E1310CCebc",
          "TokenName": "alBUSD",
          "Pid": 5
        },
        {
          "Name": "Venus",
          "ContractAddress": "0x2E128EB2EE787428307A7B246d02C1801788e1A6",
          "TokenName": "vBUSD",
          "Pid": 4
        },
        {
          "Name": "Coinwind",
          "ContractAddress": "0x9F4198C4a73c103Bc9b1c34D1f680d4E43D901AF",
          "TokenName": "cwBUSD",
          "Pid": 7
        }
      ]
    },
    {
      "CoinName": "BNB",
      "Vaults": [
        {
          "Name": "Alpaca",
          "ContractAddress": "0x024F05c70F203fb77f27b00422534cC33E1FB69d",
          "TokenName": "alBNB",
          "Pid": 12
        },
        {
          "Name": "Coinwind",
          "ContractAddress": "0xcd8EF3E3A7b25741cE5B8C728F582cF748b60b1A",
          "TokenName": "cwBNB",
          "Pid": 9
        }
      ]
    }
  ]
async function exchangeRateStored(depositContractAddress, coinId) {
    const coinAddress = await sdk.api.abi.call({
        target: depositContractAddress,
        abi: formalDeposit['coins'],
        chain: "heco",
        params: coinId,
    });
    const rate = await sdk.api.abi.call({
        target: coinAddress.output,
        abi: cToken['exchangeRateStored'],
        chain: 'heco',
    });
    return rate.output
}

async function getBalance(contractAddress, coinId) {
    const swapContract = await sdk.api.abi.call({
        target: contractAddress,
        abi: formalDeposit['curve'],
        chain: "heco",
    });
    const balance = await sdk.api.abi.call({
        target: swapContract.output,
        abi: formalSwapPool['balances'],
        chain: "heco",
        params: coinId,

    });
    return balance.output
}

async function getDecimals(contractAddress, coinId) {
    const underlyingCoinsAddress = await sdk.api.abi.call({
        target: contractAddress,
        abi: formalDeposit['underlying_coins'],
        chain: "heco",
        params: coinId,
    });
    const decimals = await sdk.api.abi.call({
        target: underlyingCoinsAddress.output,
        abi: erc20['decimals'],
        chain: "heco",
    });
    return decimals.output
}

async function swapV2GetBalance(contractAddress, coinId) {
    const balance = await sdk.api.abi.call({
        target: contractAddress,
        abi: swapPoolAbiV2['balances'],
        chain: "heco",
        params: coinId,

    });
    return balance.output
}

async function swapV2GetDecimals(contractAddress, coinId) {
    const underlyingCoinsAddress = await sdk.api.abi.call({
        target: contractAddress,
        abi: swapPoolAbiV2['coins'],
        chain: "heco",
        params: coinId,
    });
    const decimals = await sdk.api.abi.call({
        target: underlyingCoinsAddress.output,
        abi: erc20['decimals'],
        chain: "heco",
    });
    return decimals.output
}
async function getTokenPrice(contractAddress) {
    const underlyingCoinsAddress = await sdk.api.abi.call({
        target: contractAddress,
        abi: formalDeposit['underlying_coins'],
        chain: "heco",
        params: 0,
    });

    const getAmountsIn = await sdk.api.abi.call({
        target: "0xED7d5F38C79115ca12fe6C0041abb22F0A06C300",
        abi: mdexRouter['getAmountsIn'],
        chain: "heco",
        params: [1e8, ['0xa71edc38d189767582c38a3145b5873052c3e47a', underlyingCoinsAddress.output]],
    });

    return getAmountsIn.output[0] / Math.pow(10, 26 - 18)
}

async function poolUnderlyingCoinBalance(contractAddress, coinId) {
    const rate = await exchangeRateStored(contractAddress, coinId)
    const balance = await getBalance(contractAddress, coinId)
    const decimals = await getDecimals(contractAddress, coinId)
    const tvlPool = rate * balance / 1e18 / Math.pow(10, decimals)
    return tvlPool
}
async function swapV2PoolUnderlyingCoinBalance(contractAddress, coinId) {
    const balance = await swapV2GetBalance(contractAddress, coinId)
    const decimals = await swapV2GetDecimals(contractAddress, coinId)
    const tvlPool =  balance  / Math.pow(10, decimals)
    return tvlPool
}

/*
	dc18 := decimal.NewFromFloat(1e18)
	dc8 := decimal.NewFromFloat(1e8)
	activeShares := decimal.NewFromBigInt(out.ActiveShares, 0).Div(dc18)
	pendingSharesToAdd := decimal.NewFromBigInt(out.PendingSharesToAdd, 0).Div(dc18)
	pendingSharesToReduce := decimal.NewFromBigInt(out.PendingSharesToReduce, 0).Div(dc18)
	rewards := decimal.NewFromBigInt(out.Rewards, 0).Div(dc8)
	return activeShares, pendingSharesToAdd, pendingSharesToReduce, rewards, nil
 */

async function getPrice(contractAddress,dc) {

    const getAmountsIn = await sdk.api.abi.call({
        target: "0xED7d5F38C79115ca12fe6C0041abb22F0A06C300",
        abi: mdexRouter['getAmountsOut'],
        chain: "heco",
        params: [1e8, [contractAddress,'0xa71edc38d189767582c38a3145b5873052c3e47a']],
    });

    return getAmountsIn.output[1] / Math.pow(10, 26 - dc)
}

async function getDaoSharesAndRewards() {
    const out= await sdk.api.abi.call({
        target: "0xfbac8c66d9b7461eefa7d8601568887c7b6f96ad",
        abi: daoAbi['sharesAndRewardsInfo'],
        chain: "heco",
    });
    const price=await getPrice("0x48C859531254F25e57D1C1A8E030Ef0B1c895c27",18)
    let dao=out.output.activeShares/ Math.pow(10, 18)+out.output.pendingSharesToAdd/ Math.pow(10, 18)-out.output.pendingSharesToReduce/ Math.pow(10, 18)
    return dao*price
}

async function getVaultTotalDeposit(){
    let totalSelfUnderlying=0
    for(let i=0;i<vaultGroup.length;i++){
        for(let j=0;j<vaultGroup[i].Vaults.length;j++) {
            const out= await sdk.api.abi.call({
                target: vaultGroup[i].Vaults[j].ContractAddress,
                abi: vaultAbi['balance'],
                chain: "heco",
            });
            if(vaultGroup[i].IsHUSD){
                totalSelfUnderlying= totalSelfUnderlying+out.output/ Math.pow(10, 8)
            }else{
                totalSelfUnderlying= totalSelfUnderlying+out.output/ Math.pow(10, 18)
            }

        }

    }
    return totalSelfUnderlying
}

async function swapV2GetBalanceBsc(contractAddress, coinId) {
    const balance = await sdk.api.abi.call({
        target: contractAddress,
        abi: swapPoolAbiV2['balances'],
        chain: "bsc",
        params: coinId,

    });
    return balance.output
}

async function getBnbPrice() {

    const getAmountsIn = await sdk.api.abi.call({
        target: "0x10ed43c718714eb63d5aa57b78b54704e256024e",
        abi: mdexRouter['getAmountsOut'],
        chain: "bsc",
        params: [1e8, ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c","0x55d398326f99059ff775485246999027b3197955"]],
    });
    return getAmountsIn.output[1] / Math.pow(10, 26 - 18)
}

async function swapV2PoolUnderlyingCoinBalanceBsc(contractAddress) {
    const balance0 = await swapV2GetBalanceBsc(contractAddress, 0)
    const balance1 = await swapV2GetBalanceBsc(contractAddress, 1)
    const balance2 = await swapV2GetBalanceBsc(contractAddress, 2)

    const tvlPool =  balance0  / Math.pow(10, 18)+ balance1  / Math.pow(10, 18)+ balance2 / Math.pow(10, 18)
    return tvlPool
}

async function getVaultTotalDepositBsc(){
    let totalSelfUnderlying=0
    for(let i=0;i<VaultGroupBsc.length;i++){
        for(let j=0;j<VaultGroupBsc[i].Vaults.length;j++) {
            const out= await sdk.api.abi.call({
                target: VaultGroupBsc[i].Vaults[j].ContractAddress,
                abi: vaultAbi['balance'],
                chain: "bsc",
            });
            if(VaultGroupBsc[i].CoinName==="BNB"){

                const bnbPrice=await getBnbPrice()
                totalSelfUnderlying=totalSelfUnderlying+out.output/ Math.pow(10, 18)*bnbPrice
            }else{
                totalSelfUnderlying= totalSelfUnderlying+out.output/ Math.pow(10, 18)
            }

        }

    }
    return totalSelfUnderlying
}

//heco tvl
async function fetchHeco() {

    let balances = {};

    const channelsBalances1 = await poolUnderlyingCoinBalance(channels, 0)
    const channelsBalances2 = await poolUnderlyingCoinBalance(channels, 1)
    const fildaBalances1 = await poolUnderlyingCoinBalance(filda, 0)
    const fildaBalances2 = await poolUnderlyingCoinBalance(filda, 1)
    const lendhubBalances1 = await poolUnderlyingCoinBalance(lendhub, 0)
    const lendhubBalances2 = await poolUnderlyingCoinBalance(lendhub, 1)
    const lendhubethBalances1 = await poolUnderlyingCoinBalance(lendhubeth, 0)
    const lendhubethBalances2 = await poolUnderlyingCoinBalance(lendhubeth, 1)
    const price = await getTokenPrice(lendhubeth)

    const fildaSwapV2Balances1 = await swapV2PoolUnderlyingCoinBalance(fildaSwapV2Address, 0)
    const fildaSwapV2Balances2 = await swapV2PoolUnderlyingCoinBalance(fildaSwapV2Address, 1)

    balances[channels] = channelsBalances1 + channelsBalances2;
    balances[filda] = fildaBalances1 + fildaBalances2;
    balances[lendhub] = lendhubBalances1 + lendhubBalances2;
    balances[lendhubeth] = (lendhubethBalances1 + lendhubethBalances2) * price;

    balances[fildaSwapV2Address] = fildaSwapV2Balances1 + fildaSwapV2Balances2;

    let total = 0
    for (var key in balances) {
        total += balances[key];
    }
    let dao=await getDaoSharesAndRewards()
    let vault=await getVaultTotalDeposit()

    return total+dao+vault
}

//bsc tvl
async function fetchBsc() {
    const swapTvl=await swapV2PoolUnderlyingCoinBalanceBsc("0xc57220b65dd9200562aa73b850c06be7bd632b57")
    const vaultTvl=await getVaultTotalDepositBsc()
    return swapTvl+vaultTvl
}

module.exports = {
    heco:{
        fetch: fetchHeco
    },
    bsc:{
        fetch: fetchBsc
    },
    fetch: async ()=>{return (await fetchHeco())+(await fetchBsc())}
}

'''
'''--- projects/deri/abi.json ---
{
  "getLengths": {
    "inputs": [],
    "name": "getLengths",
    "outputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" },
      { "internalType": "uint256", "name": "", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBToken": {
    "inputs": [
      { "internalType": "uint256", "name": "bTokenId", "type": "uint256" }
    ],
    "name": "getBToken",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "bTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "swapperAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "oracleAddress",
            "type": "address"
          },
          { "internalType": "uint256", "name": "decimals", "type": "uint256" },
          { "internalType": "int256", "name": "discount", "type": "int256" },
          { "internalType": "int256", "name": "liquidity", "type": "int256" },
          { "internalType": "int256", "name": "pnl", "type": "int256" },
          {
            "internalType": "int256",
            "name": "cumulativePnl",
            "type": "int256"
          }
        ],
        "internalType": "struct IPerpetualPool.BTokenInfo",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "v3Liquidity": {
    "inputs": [],
    "name": "liquidity",
    "outputs": [{ "internalType": "int256", "name": "", "type": "int256" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/deri/index.js ---
const sdk = require("@defillama/sdk");
const { transformPolygonAddress } = require("../helper/portedTokens");
const abi = require("./abi");

async function perpetualPool(
  block,
  chain,
  pool,
  balances,
  transform = (a) => a
) {
  const { output: counts } = await sdk.api.abi.call({
    block,
    target: pool,
    params: [],
    abi: abi["getLengths"],
    chain,
  });

  const bTokenCount = counts[0];
  let bTokenIds = [];
  for (let i = 0; i < parseInt(bTokenCount); i++) {
    bTokenIds.push(i.toString());
  }

  const bTokens = (
    await sdk.api.abi.multiCall({
      calls: bTokenIds.map((bTokenId) => ({
        target: pool,
        params: bTokenId,
      })),
      block,
      abi: abi["getBToken"],
      chain,
    })
  ).output.map((value) => value.output);

  for (let i = 0; i < bTokens.length; i++) {
    let tokenBalance = (
      await sdk.api.erc20.balanceOf({
        block,
        chain,
        target: bTokens[i].bTokenAddress,
        owner: pool,
      })
    ).output;
    sdk.util.sumSingleBalance(
      balances,
      transform(bTokens[i].bTokenAddress),
      tokenBalance
    );
  }
}
async function perpetualPoolLite(
  block,
  chain,
  pool,
  token,
  balances,
  transform = (a) => a
) {
  let tokenBalance = (
    await sdk.api.erc20.balanceOf({
      block,
      chain,
      target: token,
      owner: pool,
    })
  ).output;
  sdk.util.sumSingleBalance(balances, transform(token), tokenBalance);
}

async function v3Pool(
  block,
  chain,
  pool,
  token,
  balances,
  transform = (a) => a,
  decimals = 18
) {
  let liquidity = (
    await sdk.api.abi.call({
      block,
      target: pool,
      params: [],
      abi: abi["v3Liquidity"],
      chain,
    })
  ).output;
  if (decimals !== 18) {
    // fix arbitrum usdc token with decimals 6
    liquidity = liquidity / 10**(18 - decimals)
  }
  sdk.util.sumSingleBalance(balances, transform(token), liquidity);
}

let bscContracts = {
  a: {
    bTokenSymbol: "0x4fabb145d64652a948d72533023f6e7a623c7c53",
    pool: "0x66f501dda450C8978c4A1115D7b2A7FAa7702F05",
  },
  b: {
    bTokenSymbol: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    pool: "0x574022307e60bE1f07da6Ec1cB8fE23d426e5831",
    lite: true,
  },
  everlastingOption: {
    bTokenSymbol: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    pool: "0x08aD0E0b4458183758fC5b9b6D27c372965fB780",
    lite: true,
  },
  deriPool: {
    bTokenSymbol: "0xe60eaf5a997dfae83739e035b005a33afdcc6df5",
    pool: "0x26bE73Bdf8C113F3630e4B766cfE6F0670Aa09cF",
    lite: true,
  },
  option: {
    bTokenSymbol: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    pool: "0x243681B8Cd79E3823fF574e07B2378B8Ab292c1E",
    v3: true,
  },
  futureMain: {
    bTokenSymbol: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    pool: "0x4ad5cb09171275A4F4fbCf348837c63a91ffaB04",
    v3: true,
  },
  futureInno: {
    bTokenSymbol: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    pool: "0xD2D950e338478eF7FeB092F840920B3482FcaC40",
    v3: true,
  },
};
let polygonContracts = {
  a: {
    bTokenSymbol: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    pool: "0x4Db087225C920Bec55B2dCEAa629BDc5782623D9",
  },
  b: {
    bTokenSymbol: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    pool: "0xA8769A4Fb0Ca82eb474448B1683DCA3c79798B69",
    lite: true,
  },
  deriPool: {
    bTokenSymbol: "0x3d1d2afd191b165d140e3e8329e634665ffb0e5e",
    pool: "0xdDfCA16Cd80Ae3aeeb7C7ef743924Ac39A94cC9c",
    lite: true,
  },
};

let arbitrumContracts = {
  futureMain: {
    bTokenSymbol: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
    pool: "0xDE3447Eb47EcDf9B5F90E7A6960a14663916CeE8",
    v3: true,
  },
};
async function bsc(timestamp, ethBlock, chainBlocks) {
  let balances = {};
  const transform = (a) => `bsc:${a}`;
  for (let [key, contract] of Object.entries(bscContracts)) {
    if (contract.lite === true) {
      await perpetualPoolLite(
        chainBlocks["bsc"],
        "bsc",
        contract.pool,
        contract.bTokenSymbol,
        balances,
        transform
      );
    } else if (contract.v3 === true) {
      await v3Pool(
        chainBlocks["bsc"],
        "bsc",
        contract.pool,
        contract.bTokenSymbol,
        balances,
        transform
      );
    } else {
      await perpetualPool(
        chainBlocks["bsc"],
        "bsc",
        contract.pool,
        balances,
        transform
      );
    }
  }
  return balances;
}
async function polygon(timestamp, ethBlock, chainBlocks) {
  let balances = {};
  const transform = await transformPolygonAddress();
  for (let [key, contract] of Object.entries(polygonContracts)) {
    if (contract.lite === true) {
      await perpetualPoolLite(
        chainBlocks["polygon"],
        "polygon",
        contract.pool,
        contract.bTokenSymbol,
        balances,
        transform
      );
    } else {
      await perpetualPool(
        chainBlocks["polygon"],
        "polygon",
        contract.pool,
        balances,
        transform
      );
    }
  }
  return balances;
}
async function arbitrum(timestamp, ethBlock, chainBlocks) {
  let balances = {};
  const transform = (a) => `arbitrum:${a}`;
  for (let [key, contract] of Object.entries(arbitrumContracts)) {
    if (contract.v3 === true) {
      await v3Pool(
        chainBlocks["arbitrum"],
        "arbitrum",
        contract.pool,
        contract.bTokenSymbol,
        balances,
        transform,
        6,                      // bToken decimals
      );
    }
    return balances;
  }
}
// node test.js projects/deri/index.js
module.exports = {
  bsc: {
    tvl: bsc,
  },
  polygon: {
    tvl: polygon,
  },
  arbitrum: {
    tvl: arbitrum,
  },
};

'''
'''--- projects/derivadex/index.js ---
/*==================================================
  Modules
  ==================================================*/

const sdk = require("@defillama/sdk");

/*==================================================
    Settings
    ==================================================*/

const addressList = ["0x6fb8aa6fc6f27e591423009194529ae126660027"];

//TODO: DYNAMICALLY FETCH
const tokenAddresses = [
  "0xdac17f958d2ee523a2206206994597c13d831ec7", //usdtAddress:
  "0xf650c3d88d12db855b8bf7d11be6c55a4e07dcc9", //cusdtAddress:
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", //usdcAddress:
  "0x39aa39c021dfbae8fac545936693ac917d5e7563", //cusdcAddress:
  "0xdf574c24545e5ffecb9a659c229253d4111d87e1", //husdAddress
  "0x056fd409e1d7a124bd7017459dfea2f387b6d5cd", //gusdAddress
  //   "0x0000000000000000000000000000000000000000", // ausdtAddress:
  //   "0x0000000000000000000000000000000000000000", //ausdcAddress:
];

/*==================================================
    TVL
    ==================================================*/

async function tvl(timestamp, block) {
  let balances = {};

  let calls = [];

  addressList.forEach((address) => {
    tokenAddresses.forEach((tokenAddress) => {
      calls.push({
        target: tokenAddress,
        params: address,
      });
    });
  });

  let balanceOfMulticall = await sdk.api.abi.multiCall({
    block,
    calls,
    abi: "erc20:balanceOf",
  });

  sdk.util.sumMultiBalanceOf(balances, balanceOfMulticall);

  return balances;
}

/*==================================================
    Exports
    ==================================================*/

module.exports = {
  start: 1607126400, // 12/5/2020 00:00:00 utc
  ethereum: { tvl }
};

'''
'''--- projects/deusfi/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const { pool2, pool2s } = require("../helper/pool2");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const {
  transformPolygonAddress,
  transformFantomAddress,
} = require("../helper/portedTokens");

const poolUSDC = "0xa0F395aD5df1Fceb319e162CCf1Ef6645dE8508f"; // same address for all chains
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const USDC_polygon = "0x2791bca1f2de4661ed88a30c99a7a9449aa84174";
const USDC_fantom = "0x04068da6c83afcfa0e13ba15a6696662335d5b75";

const stakingPool2Contracts = [
  "0x4e5D8794f08F2792DC51016d0a4b9A205cAFc63A", //same dei-deus for all chains
  "0x4C48f1421F62d923d9130834135FB4A58E2F4298", //same deus-weth except polygon -> deus-wmatic
];
const DEI_DEUS_UNIV2 = "0xd6dd359B8C9d18CCB3FE8627060F88D1776d2993";
const DEUS_WETH_UNIV2 = "0x367E2D443988E4b222FBFdAFDb35eeB7ddA9FBB7";

const DEI_DEUS_UNIV2_polygon = "0x2Bc3ce6D7cfc0B476E60aDaA1B27DE76DB95EE4e";
const DEUS_WMATIC_UNIV2_polygon = "0x6152943b506211ce1FA872702a1b0bc594Cfa2d2";

const DEI_DEUS_SPIRITLP_fantom = "0xdDC92fcEd95e913728CBc8f197A4E058062Bd4b6";

const stakingPool2Contracts_fantom = [
  "0x372b584D4f5Dc77256b18e34692B0881451bf25E", //farm dei-usdc
  "0x3CB9ae281E511759832a074A92634d2486E6a886", //farm deus-wftm
];

const DEI_USDC_SPIRITLP_fantom = "0x8eFD36aA4Afa9F4E157bec759F1744A7FeBaEA0e";
const DEUS_WFTM_SPIRITLP_fantom = "0x2599Eba5fD1e49F294C76D034557948034d6C96E";

const stakingPool2Contract = "0xa78Ea447ce5AA4669A5f0cD8D27bF5883E1Bf20f"; // for all chains
const DEI_USDC_UNIV2 = "0xD4F9134ba896FB6901CD6A5EA4EEB683eb1c15c6"; // dei-usdc for polygon
const DEI3CRV = "0x6870f9b4dd5d34c7fc53d0d85d9dbd1aab339bf7";
const DEI = "0xde12c7959e1a72bbe8a5f7a1dc8f8eef9ab011b3";
const CRV3 = "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490";
const DEUS = "0xde5ed76e7c05ec5e4572cfc88d1acea165109e44";

async function Pool2() {
  const balances = {};

  const totalSupply_slp = (
    await sdk.api.erc20.totalSupply({
      target: DEI3CRV,
    })
  ).output;

  const balance_slp = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: DEI3CRV,
      params: stakingPool2Contract,
    })
  ).output;

  const underlyingsBalance = (
    await sdk.api.abi.multiCall({
      calls: [DEI, CRV3].map((token) => ({
        target: token,
        params: DEI3CRV,
      })),
      abi: 'erc20:balanceOf',
    })
  ).output;

  underlyingsBalance.forEach((call) => {
    const underlyingSetBalance = BigNumber(call.output)
      .times(balance_slp)
      .div(totalSupply_slp);

    sdk.util.sumSingleBalance(
      balances,
      call.input.target,
      underlyingSetBalance.toFixed(0)
    );
  });

  return balances;
}

async function ethTvl() {
  const balances = {};

  await sumTokensAndLPsSharedOwners(balances, [[USDC, false]], [poolUSDC]);

  return balances;
}

async function polygonTvl(timestamp, chainBlocks) {
  const balances = {};

  const transformAddress = await transformPolygonAddress();
  await sumTokensAndLPsSharedOwners(
    balances,
    [[USDC_polygon, false]],
    [poolUSDC],
    chainBlocks["polygon"],
    "polygon",
    transformAddress
  );

  return balances;
}

async function fantomTvl(timestamp, chainBlocks) {
  const balances = {};

  const transformAddress = await transformFantomAddress();
  await sumTokensAndLPsSharedOwners(
    balances,
    [[USDC_fantom, false]],
    [poolUSDC],
    chainBlocks["fantom"],
    "fantom",
    transformAddress
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
    pool2: sdk.util.sumChainTvls([
      Pool2,
      pool2s(stakingPool2Contracts, [DEI_DEUS_UNIV2, DEUS_WETH_UNIV2]),
    ]),
  },
  polygon: {
    tvl: polygonTvl,
    pool2: sdk.util.sumChainTvls([
      pool2s(
        stakingPool2Contracts,
        [DEI_DEUS_UNIV2_polygon, DEUS_WMATIC_UNIV2_polygon],
        "polygon"
      ),
      pool2(stakingPool2Contract, DEI_USDC_UNIV2, "polygon"),
    ]),
  },
  fantom: {
    tvl: fantomTvl,
    pool2: sdk.util.sumChainTvls([
      pool2(
        stakingPool2Contracts[0],
        DEI_DEUS_SPIRITLP_fantom,
        "fantom",
        (id) => id
      ),
      pool2s(
        stakingPool2Contracts_fantom,
        [DEI_USDC_SPIRITLP_fantom, DEUS_WFTM_SPIRITLP_fantom],
        "fantom"
      ),
    ]),
  },
  methodology:
    "Counts liquidty of Minted assets(USDC) through PoolUSDC Contracts; and Pool2s from Farm seccions",
};

'''
'''--- projects/dev.js ---
const sdk = require("@defillama/sdk")

const ADDRESS_CONFIG_ADDRESS = '0x1D415aa39D647834786EB9B5a333A50e9935b796'
const TOKEN_ADDRESS = '0x5cAf454Ba92e6F2c929DF14667Ee360eD9fD5b26'

const ADDRESS_CONFIG_ABI = [
  {
    constant: true,
    inputs: [],
    name: 'lockup',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address',
      },
    ],
    payable: false,
    stateMutability: 'view',
    type: 'function',
  },
]

const LOCKUP_ABI = [
  {
    constant: true,
    inputs: [],
    name: 'getAllValue',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
    payable: false,
    stateMutability: 'view',
    type: 'function',
  },
]

async function staking(ts, block) {
  const { output: lockupAddress } = await sdk.api.abi.call({
    block,
    target: ADDRESS_CONFIG_ADDRESS,
    abi: ADDRESS_CONFIG_ABI.find(i => i.name === 'lockup')
  })
  const { output: allValue } = await sdk.api.abi.call({
    block,
    target: lockupAddress,
    abi: LOCKUP_ABI.find(i => i.name === 'getAllValue')
  })
  return {
    [TOKEN_ADDRESS]: allValue
  }
}

module.exports = {
  ethereum: {
    tvl: () => ({}),
    staking,
  }
}

'''
'''--- projects/deversifi/index.js ---
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')
const sdk = require('@defillama/sdk')

const deversifiStarkAddr = '0x5d22045daceab03b158031ecb7d9d06fad24609b';
const listedTokens = [
  '0xdac17f958d2ee523a2206206994597c13d831ec7',
  '0x6B175474E89094C44Da98b954EedeAC495271d0F',
  '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07',
  '0x940a2db1b7008b6c776d4faaca729d6d4a4aa551',
  '0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e',
  '0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2',
  '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
  '0xe41d2489571d322189246dafa5ebde1f4699f498',
  '0xcc80c051057b774cd75067dc48f8987c4eb97a5e',
  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
  '0x419d0d8bdd9af5e606ae2232ed285aff190e711b',
  '0x93ed3fbe21207ec2e8f2d3c3de6e058cb73bc04d',
  '0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e',
  '0xba100000625a3754423978a60c9317c58a424e3d',
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
  '0xc00e94cb662c3520282e6f5717214004a7f26888',
  '0xec67005c4e498ec7f55e092bd1d35cbc47c91892',
  '0x0d8775f648430679a709e98d2b0cb6250d2887ef',
  '0x514910771af9ca656af840dff83e8264ecf986ca',
  '0x93ed3fbe21207ec2e8f2d3c3de6e058cb73bc04d',
  '0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f',
  '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9',
  '0xeef9f339514298c6a857efcfc1a762af84438dee',
  '0xa117000000f279d81a1d3cc75430faa017fa5a2e',
  '0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b',
  '0xf650c3d88d12db855b8bf7d11be6c55a4e07dcc9',
  '0x5a98fcbea516cf06857215779fd812ca3bef1b32',
  '0xdddddd4301a082e62e84e43f474f044423921918',
  '0xaaaebe6fe48e54f431b0c390cfaf0b017d09d42d',
  '0x6b3595068778dd592e39a122f4f5a5cf09c90fe2',
  '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0',
  '0x0a0e3bfd5a8ce610e735d4469bc1b3b130402267',
  '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE',
  '0xD533a949740bb3306d119CC777fa900bA034cd52',
  '0x03ab458634910aad20ef5f1c8ee96f1d6ac54919',
  '0x0391d2021f89dc339f60fff84546ea23e337750f',
  '0x2e9d63788249371f1dfc918a52f8d799f4a38c94',
  '0x33349b282065b0284d756f0577fb39c158f935e6',
  '0x767fe9edc9e0df98e07454847909b5e959d7ca0e',
  '0x25f8087ead173b73d6e8b84329989a8eea16cf73',
  '0xdddd0e38d30dd29c683033fa0132f868597763ab'
];
const weth = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
const aust = "0xa8De3e3c934e2A1BB08B010104CcaBBD4D6293ab"

async function tvl(timestamp, ethBlock){
    const balances = {}
    await sumTokensAndLPsSharedOwners(balances, listedTokens.map(t=>[t, false]), [deversifiStarkAddr], ethBlock)
    const eth = await sdk.api.eth.getBalance({
        target: deversifiStarkAddr,
        block: ethBlock
    })
    const austBalance = await sdk.api.abi.call({
        target: aust,
        params: deversifiStarkAddr,
        abi: 'erc20:balanceOf',
        block: ethBlock
    })
    sdk.util.sumSingleBalance(balances, weth, eth.output)
    sdk.util.sumSingleBalance(balances, 'anchorust', austBalance.output / 1e18)
    return balances
}

module.exports = {
    methodology: `Counts the tokens on ${deversifiStarkAddr}`,
    ethereum: {
      tvl
    }
}

'''
'''--- projects/devil-finance/index.js ---
const retry = require("../helper/retry");
const axios = require("axios");

function tvl(type) {
  return async () => {
    var response = await retry(
      async (_) => await axios.get("https://devilfinance.io/api/tvls")
    );

    return response.data[type];
  };
};

module.exports = {
  fantom: {
    fetch: tvl("nonNative"),
  },
  pool2: {
    fetch: tvl("nativeLP"),
  },
  staking: {
    fetch: tvl("native"),
  },
  fetch: tvl("nonNative"),
};

'''
'''--- projects/dexpad/abis.js ---

const getNumLockedTokens = {
  "inputs": [],
  "name": "getNumLockedTokens",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

const lockedTokensLength = {
  "inputs": [],
  "name": "lockedTokensLength",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

const getLockedTokenAtIndex =  {
  "inputs": [
    {
      "internalType": "uint256",
      "name": "_index",
      "type": "uint256"
    }
  ],
  "name": "getLockedTokenAtIndex",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

const lockedToken = {
  "inputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "name": "lockedTokens",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

module.exports = {
  getLockedTokenAtIndex,
  getNumLockedTokens,
  lockedTokensLength,
  lockedToken
}
'''
'''--- projects/dexpad/api.js ---
const { getExports } = require('../helper/heroku-api')
const indexExports = require('./index')
const chainKeys = Object.keys(indexExports).filter(chain => typeof indexExports[chain] === 'object' && indexExports[chain].tvl)

module.exports = {
  timetravel: false,
  ...getExports("dexpad", chainKeys),
}
'''
'''--- projects/dexpad/config.js ---
// const { ethereum } = require(".")

const { getNumLockedTokens, getLockedTokenAtIndex} = require('./abis')

const coreTokenWhitelist = {
  cronos: [
    '0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23',  // WCRO
    '0xc21223249ca28397b4b6541dffaecc539bff0c59',  // usdc
    '0x66e428c3f67a68878562e79a0234c1f83c208770',  // usdt
    '0xf2001b145b43032aaf5ee2884e456ccd805f677d',  // dai
  ],
  kava: [
    '0xc86c7c0efbd6a49b35e8714c5f59d99de09a225b',  // WKAVA
    '0xfa9343c3897324496a05fc75abed6bac29f8a40f',  // usdc
    '0xb44a9b6905af7c801311e8f4e76932ee959c663c',  // usdt
    '0x765277eebeca2e31912c9946eae1021199b39c61',  // dai
    '0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d' //WETH
  ],
    polygon: [
    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',  // wmatic
    '0x2791bca1f2de4661ed88a30c99a7a9449aa84174',  // usdc
    '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619'], // weth
    avalanche: [
    '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7',  // wavax
    '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e',  // usdc
    '0xc7198437980c041c805a1edcba50c1ce5db95118'], // usdt
  }
  

const config = {
  kavaLocker: {
    chain: 'kava',
    locker: '0x99d17986fcffeb42700f6a9fcd15927bf1fd0df3', 
    factory: '0x4FD2c40c25Dd40e9Bf0CE8479bA384178b8671b5',
    startingBlock: 34954
  },
  cronosLockerV1: {
    chain: 'cronos',
    locker: '0x16678dd963D3C17DD5232c0eE9568e19a9ACB2B6', //v1 Contract 
    factory: '0x462C98Cae5AffEED576c98A55dAA922604e2D875',
    startingBlock: 8037  
  },
  cronosLockerV2: {
    chain: 'cronos',
    locker: '0x09Abe30F5E0E01AC12618eF9eD378aA95dF0aE2D', //V2 Contract 
    factory: '0x462C98Cae5AffEED576c98A55dAA922604e2D875',
    startingBlock: 343983 
  },
  polygonLocker: {
    chain: 'polygon',
    locker: '0x36CdC42a5e9DFCeB3a5cC240c7B477645d4E894a',
    factory: '0x5757371414417b8c6caad45baef941abc7d3ab32',
    startingBlock: 23891396
  },
  avaxLocker: {
    chain: 'avax',
    locker: '0xE7e840Be67B9381D164AbA4CDf30E491d7E36201',
    factory: '0x091d35d7F63487909C863001ddCA481c6De47091',
    startingBlock: 9771636 
  },
}

const kavaContractData = [
  { // KavaLocker
    chain: config.kavaLocker.chain,
    contract: config.kavaLocker.locker,
    getNumLockedTokensABI: getNumLockedTokens,
    getLockedTokenAtIndexABI: getLockedTokenAtIndex,
    trackedTokens: coreTokenWhitelist.kava,
    factory: config.kavaLocker.factory
  }
]
const cronosContractData = [
  { // cronosLockerV1
    chain: config.cronosLockerV1.chain,
    contract: config.cronosLockerV1.locker,
    getNumLockedTokensABI: getNumLockedTokens,
    getLockedTokenAtIndexABI: getLockedTokenAtIndex,
    trackedTokens: coreTokenWhitelist.cronos,
    factory: config.cronosLockerV1.factory,
  },
  { // cronosLockerV2
    chain: config.cronosLockerV2.chain,
    contract: config.cronosLockerV2.locker,
    getNumLockedTokensABI: getNumLockedTokens,
    getLockedTokenAtIndexABI: getLockedTokenAtIndex,
    trackedTokens: coreTokenWhitelist.cronos,
    factory: config.cronosLockerV2.factory,
  },
]
const polygonContractData = [
  { // Polygon Locker
    chain: config.polygonLocker.chain,
    contract: config.polygonLocker.locker, 
    getNumLockedTokensABI: getNumLockedTokens,
    getLockedTokenAtIndexABI: getLockedTokenAtIndex,
    trackedTokens: coreTokenWhitelist.polygon,
    factory: config.polygonLocker.factory
  },
]

const avalancheContractData = [
  { // AvaxLocker
    chain: config.avaxLocker.chain,
    contract: config.avaxLocker.locker, 
    getNumLockedTokensABI: getNumLockedTokens,
    getLockedTokenAtIndexABI: getLockedTokenAtIndex,
    trackedTokens: coreTokenWhitelist.avalanche,
    factory: config.avaxLocker.factory
  },
  
] 

module.exports = {
  kavaContractData,
  cronosContractData,
  polygonContractData,
  avalancheContractData
}
'''
'''--- projects/dexpad/index.js ---
const {polygonContractData, 
  avalancheContractData, cronosContractData, kavaContractData } = require('./config')
const { vestingHelper } = require("../helper/unknownTokens")
const sdk = require('@defillama/sdk')

function tvl(args){
  return async (timestamp, ethBlock, chainBlocks) => {
    let totalBalances = {}
    for (let i = 0; i < args.length; i++) {
      const chain = args[i].chain
      const contract = args[i].contract
      let block = chainBlocks[chain]
      const { output: totalDepositId } = await sdk.api.abi.call({
        target: contract,
        abi: args[i].getNumLockedTokensABI,
        chain, block,
      })

      let tokens = [];
      const allDepositId = Array.from(Array(+totalDepositId).keys());
      const lpAllTokens = (
        await sdk.api.abi.multiCall({
          abi: args[i].getLockedTokenAtIndexABI,
          calls: allDepositId.map((num) => ({
            target: contract,
            params: num,
          })),
          chain: chain,
          block: block
        })
      ).output

      lpAllTokens.forEach(lp => {
        if (!lp.success) return;
        const lpToken = lp.output
        tokens.push(lpToken)
      })

      const blacklist = [...(args[i].pool2 || [])]

      if (chain === 'ethereum')
        blacklist.push('0x72E5390EDb7727E3d4e3436451DADafF675dBCC0') // HANU

      let balances = await vestingHelper({
        chain, block,
        owner: contract,
        coreAssets: args[i].trackedTokens,
        blacklist,
        tokens,
      })

      for (const [token, balance] of Object.entries(balances))
        sdk.util.sumSingleBalance(totalBalances, token, balance)
    }
    return totalBalances
  }
}
module.exports = {
  timetravel: true,
  methodology: 
  `Counts each LP pair's native token and 
   stable balance, adjusted to reflect locked pair's value. 
   Balances and merged across multiple 
   locker and staking contracts to return sum TVL per chain`,
  cronos: {
    tvl: tvl(cronosContractData)
  },
  polygon: {
    tvl: tvl(polygonContractData)
  },
  avax: {
    tvl: tvl(avalancheContractData)
  },
  kava:{
    tvl: tvl(kavaContractData)
  }
}

'''
'''--- projects/dextf/abis/getPositions.json ---
{
  "inputs": [],
  "name": "getPositions",
  "outputs": [
    {
      "components": [
        {
          "internalType": "address",
          "name": "component",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "unit",
          "type": "int256"
        },
        {
          "internalType": "uint8",
          "name": "positionState",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "internalType": "struct ISetToken.Position[]",
      "name": "",
      "type": "tuple[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/dextf/abis/getReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
    {
      "internalType": "uint112",
      "name": "_reserve0",
      "type": "uint112"
    },
    {
      "internalType": "uint112",
      "name": "_reserve1",
      "type": "uint112"
    },
    {
      "internalType": "uint32",
      "name": "_blockTimestampLast",
      "type": "uint32"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/dextf/abis/getSets.json ---
{
  "inputs": [],
  "name": "getSets",
  "outputs": [
    {
      "internalType": "address[]",
      "name": "",
      "type": "address[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/dextf/abis/totalSupply.json ---
{
  "inputs": [],
  "name": "totalSupply",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/dextf/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const TVLV1 = require('./v1');
  const TVLV2 = require('./v2');

  const BigNumber = require('bignumber.js');

/*==================================================
  TVL
  ==================================================*/

  async function tvl(timestamp, block) {
    const [v1, v2] = await Promise.all([
      TVLV1(timestamp, block), TVLV2(timestamp, block)]);

    const tokenAddresses = new Set(Object.keys(v1).concat(Object.keys(v2)));

    const balances = (
      Array
        .from(tokenAddresses)
        .reduce((accumulator, tokenAddress) => {
          const v1Balance = new BigNumber(v1[tokenAddress] || '0');
          const v2Balance = new BigNumber(v2[tokenAddress] || '0');

          accumulator[tokenAddress] = v1Balance.plus(v2Balance).toFixed(0);

          return accumulator
        }, {})
    );

    delete balances['0xa9859874e1743a32409f75bb11549892138bba1e'];  // removing IETH because the balance was 8637200000 at ts: 1608768000 which resulted in the DexTF tvl being $6698B

    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1595853825,  // 27/07/2020 @ 12:43:45am (UTC)
    ethereum: { tvl }
  }

'''
'''--- projects/dextf/v1.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');

const axios = require('axios');

/*==================================================
Settings
==================================================*/
const vaultAddress = "0x86C077092018077Df34FF44D5D7d3f9A2DF03bEf";

const cTokenDecimalScale = BigNumber("10").pow(18);
const cTokensMap = {
  '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5': '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // cETH: WETH
  '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643': '0x6B175474E89094C44Da98b954EedeAC495271d0F',  // cDAI: DAI
  '0xC11b1268C1A384e55C48c2391d8d480264A3A7F4' : '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599'  // cWBTC: WBTC
}

/*==================================================
  TVL
  ==================================================*/

module.exports = async function tvl(timestamp, block) {

  // Fetch list of token supported by the protocol
  let tokensList = [];
  let response = await axios.get('https://api.dextf.com/dp/assets', {
  });
  for (var i = 0; i < response.data.assets.length; i++) {
    tokensList.push(response.data.assets[i].contract);
  }

  let balances = {};

  // Vault Asset Balances
  let balanceOfResults = await sdk.api.abi.multiCall({
    block,
    calls: tokensList.map((token) => {
      return {
        target: token,
        params: vaultAddress
      }
    }),
    abi: 'erc20:balanceOf'
  });

  // cToken Exchange Rates
  let cTokenConversionRatesMap = (await sdk.api.abi.multiCall({
    block,
    calls: Object.keys(cTokensMap).map((cToken) => {
      return {
        target: cToken
      }
    }),
    abi: {
      "constant": true,
      "type": "function",
      "inputs": [],
      "name": "exchangeRateStored",
      "outputs": [
        {
          "name":"",
          "type":"uint256"
        }
      ]
    }
  })).output.reduce(function(map, object) {
    map[object.input.target] = object.output;
    return map;
  }, {});

  // Compute Balances
  balanceOfResults.output.forEach((balanceOf) => {
      let address = balanceOf.input.target

      if (address in cTokensMap) {
        let addressOfUnderlying = cTokensMap[address];
        let conversionRate = BigNumber(cTokenConversionRatesMap[address]);
        let balanceOfUnderlying = BigNumber(balanceOf.output).times(conversionRate).div(cTokenDecimalScale);

        balances[addressOfUnderlying] = BigNumber(balances[addressOfUnderlying] || 0).plus(balanceOfUnderlying || 0).toFixed();
      } else {
        balances[address] = BigNumber(balances[address] || 0).plus(balanceOf.output || 0).toFixed();
      }
  });

  return balances;
};

'''
'''--- projects/dextf/v2.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');

const SUPPLY_SCALE = BigNumber("10").pow(18)
const START_BLOCK = 12783638;
const EXTERNAL_POSITION = '1';

const getSets = require('./abis/getSets.json');
const getPositions = require('./abis/getPositions.json');
const totalSupply = require('./abis/totalSupply.json');
const getReserves = require('./abis/getReserves.json');

const pairAddresses = {
  '0xBb2b8038a1640196FbE3e38816F3e67Cba72D940': [
    '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
  ],
  '0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11': [
    '0x6B175474E89094C44Da98b954EedeAC495271d0F',
    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
  ],
};

/*==================================================
  TVL
  ==================================================*/

module.exports = async function tvl(timestamp, block) {
  let balances = {};

  if (block <= START_BLOCK) {
    return balances;
  }

  const setAddresses = (await sdk.api.abi
    .call({
      abi: getSets,
      target: '0xE0CF093Ce6649Ef94fe46726745346AFc25214D8',
      block,
    })).output;

  let supplies = (await sdk.api.abi.multiCall({
    abi: totalSupply,
    block,
    calls: setAddresses.map((setAddress) => {
      return {
        target: setAddress,
      }
    }),
  })).output;

  let positionsForSets = (await sdk.api.abi.multiCall({
    abi: getPositions,
    block,
    calls: setAddresses.map((setAddress) => {
      return {
        target: setAddress,
      }
    }),
  })).output;

  let uniswapPositions = {};
  positionsForSets.forEach(function(positionForSet, i) {
    const setSupply = BigNumber(supplies[i].output);
    positionForSet.output.forEach((position) => {
      const componentAddress = position[0];
      const positionUnits = BigNumber(position[2]);

      const isExternalPosition = position[3] == EXTERNAL_POSITION;
      if (isExternalPosition) {
        uniswapPositions[componentAddress] = BigNumber(uniswapPositions[componentAddress] || 0).plus((positionUnits).times(setSupply)).toFixed();
      } else {
        balances[componentAddress] = BigNumber(balances[componentAddress] || 0).plus((positionUnits).times(setSupply).div(SUPPLY_SCALE)).toFixed();
      }
    });
  });

  const reserves = (await sdk.api.abi
    .multiCall({
      abi: getReserves,
      calls: Object.keys(uniswapPositions).map((pairAddress) => ({
        target: pairAddress,
      })),
      block,
    })).output;

  let reserveSupplies = (await sdk.api.abi.multiCall({
    abi: totalSupply,
    block,
    calls: Object.keys(uniswapPositions).map((pairAddress) => {
      return {
        target: pairAddress,
      }
    }),
  })).output;

  reserves.forEach(function(reserve, i) {
    const pairAddress = reserve.input.target;
    const tokenPair = pairAddresses[pairAddress];
    const setSupplyRatio = new BigNumber(uniswapPositions[pairAddress]).div(new BigNumber(reserveSupplies[i].output)).div(SUPPLY_SCALE);

    // handle reserve0
    if (tokenPair[0]) {
      const reserve0 = new BigNumber(reserve.output['0']);
      if (!reserve0.isZero()) {
        const existingBalance = new BigNumber(
          balances[tokenPair[0]] || '0'
        );

        balances[tokenPair[0]] = existingBalance
          .plus(reserve0.times(setSupplyRatio))
          .toFixed()
      }
    }

    // handle reserve1
    if (tokenPair[1]) {
      const reserve1 = new BigNumber(reserve.output['1']);

      if (!reserve1.isZero()) {
        const existingBalance = new BigNumber(
          balances[tokenPair[1]] || '0'
        );

        balances[tokenPair[1]] = existingBalance
          .plus(reserve1.times(setSupplyRatio))
          .toFixed()
      }
    }
  });

  return balances;
};

'''
'''--- projects/dforce/abi.json ---
{
  "getBaseData": {
    "constant": false,
    "inputs": [],
    "name": "getBaseData",
    "outputs": [{
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  "balanceOfUnderlying":{
		"inputs": [
			{
				"internalType": "address",
				"name": "_account",
				"type": "address"
			}
		],
		"name": "balanceOfUnderlying",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "balanceOf":{
		"constant": true,
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "totalSupply":{
		"constant": true,
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "exchangeRateCurrent":{
	"inputs": [],
	"name": "exchangeRateCurrent",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "underlying":{
	"inputs": [],
	"name": "underlying",
	"outputs": [
	  {
		"internalType": "address",
		"name": "",
		"type": "address"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "getUnderlyingPrice":{
	"inputs": [
	  {
		"internalType": "address",
		"name": "_asset",
		"type": "address"
	  }
	],
	"name": "getUnderlyingPrice",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "getAlliTokens": {
	"inputs": [],
	"name": "getAlliTokens",
	"outputs": [
	  {
		"internalType": "address[]",
		"name": "_alliTokens",
		"type": "address[]"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "isiToken":{
	"inputs": [],
	"name": "isiToken",
	"outputs": [
	  {
		"internalType": "bool",
		"name": "",
		"type": "bool"
	  }
	],
	"stateMutability": "pure",
	"type": "function"
  },
  "getCurrentExchangeRate": {
	"inputs": [],
	"name": "getCurrentExchangeRate",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "_exchangeRate",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "oracle":
  {
	"inputs": [],
	"name": "priceOracle",
	"outputs": [
	  {
		"internalType": "address",
		"name": "",
		"type": "address"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  }
}

'''
'''--- projects/dforce/index.js ---
  const sdk = require('@defillama/sdk');

  const BigNumber = require('bignumber.js');
  const abi = require('./abi.json');
  const BASE = BigNumber(10 ** 18)
  const Double = BASE * BASE;
  const mappingTokens = require("./tokenMapping.json");
  const {sumTokensSharedOwners} = require('../helper/unwrapLPs')
  const {getCompoundV2Tvl,getCompoundUsdTvl} = require('../helper/compound')
  const {generalizedChainExports} = require('../helper/exports')

/*==================================================
  Ethereum Settings
  ==================================================*/
const DAI = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
const PAX = "0x8E870D67F660D95d5be530380D0eC0bd388289E1";
const TUSD = "0x0000000000085d4780B73119b644AE5ecd22b376";
const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const USDT = "0xdAC17F958D2ee523a2206206994597C13D831ec7";
const USDx = "0xeb269732ab75A6fD61Ea60b06fE994cD32a83549";

/*==================================================
  USDx
  ==================================================*/
const usdxReservedTokens = [PAX, TUSD, USDC];
const dUSDC = "0x16c9cF62d8daC4a38FB50Ae5fa5d51E9170F3179";

const usdxPool = "0x7FdcDAd3b4a67e00D9fD5F22f4FD89a5fa4f57bA"; // USDx Stablecoin Pool

/*==================================================
  GOLDx Protocol
  ==================================================*/
const goldxReserve = "0x45804880De22913dAFE09f4980848ECE6EcbAf78"; // PAXG
const goldxProtocol = "0x355C665e101B9DA58704A8fDDb5FeeF210eF20c0"; // GOLDx

/*==================================================
  BSC Settings
  ==================================================*/
const BSC_BUSD = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";
const BSC_DAI = "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3";
const BSC_USDC = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d";
const BSC_USDT = "0x55d398326f99059fF775485246999027B3197955";

let oracles = {
  ethereum: "0x34BAf46eA5081e3E49c29fccd8671ccc51e61E79",
  bsc: "0x7DC17576200590C4d0D8d46843c41f324da2046C",
  arbitrum: "0xc3FeD5f21EB8218394f968c86CDafc66e30e259A",
  optimism: "0x4f9312A21F8853384E0f6141F3F9fB855d860161",
  polygon: "0x9E8B68E17441413b26C2f18e741EAba69894767c",
  avax: "0x5237d212F9BbC83d91c2cbd810D2b07808d94f08",
  kava: "0xe04cea4d02261923769D79Dd24D188C2cB29dB4A"
};

let allControllers = {
  ethereum: [
    "0x8B53Ab2c0Df3230EA327017C91Eb909f815Ad113", // dForce general pool
    "0x1E96e916A64199069CcEA2E6Cf4D63d30a61b93d", // dForce vault pool: USX/3CRV
    "0x8f1f15DCf4c70873fAF1707973f6029DEc4164b3", // liqee general pool
  ],
  bsc: [
    "0x0b53E608bD058Bb54748C35148484fD627E6dc0A", // dForce general pool
    "0x6d290f45A280A688Ff58d095de480364069af110" // liqee general pool
  ],
  arbitrum: [
    "0x8E7e9eA9023B81457Ae7E6D2a51b003D421E5408", // dForce general pool
    "0x50210A88217d1dD9e7FBc3E4a927Cc55829a38eB", // dForce vault pool: USX/2CRV
  ],
  optimism: ["0xA300A84D8970718Dac32f54F61Bd568142d8BCF4"],
  polygon: ["0x52eaCd19E38D501D006D2023C813d7E37F025f37"],
  avax: ["0x078ad8d6faeD9DAeE55f5d446C80E0C81230DE6b"],
  kava: ["0xFBf64A8cAEA1D641affa185f850dbBF90d5c84dC"],
};

let yieldMarkets = {
  ethereum: [
    "0x02285AcaafEB533e03A7306C55EC031297df9224", // dDAI
    "0x109917F7C3b6174096f9E1744e41ac073b3E1F72", // dUSDx
    "0x16c9cF62d8daC4a38FB50Ae5fa5d51E9170F3179", // dUSDC
    "0x868277d475E0e475E38EC5CdA2d9C83B5E1D9fc8" // dUSDT
  ],
  bsc: [
    "0xce14792a280b20c4f8E1ae76805a6dfBe95729f5", // dBUSD
    "0x4E0B5BaFC52D09A8F18eA0b7a6A7dc23A1096f99", // dDAI
    "0x6c0F322442D10269Dd557C6e3A56dCC3a1198524", // dUSDC
    "0x6199cC917C12E4735B4e9cEfbe29E9F0F75Af9E5" // dUSDT
  ]
};

let yieldUnderlyingTokens = {
  ethereum: {
    "0x02285AcaafEB533e03A7306C55EC031297df9224": DAI,
    "0x109917F7C3b6174096f9E1744e41ac073b3E1F72": USDx,
    "0x16c9cF62d8daC4a38FB50Ae5fa5d51E9170F3179": USDC,
    "0x868277d475E0e475E38EC5CdA2d9C83B5E1D9fc8": USDT
  },
  bsc: {
    "0xce14792a280b20c4f8E1ae76805a6dfBe95729f5": BSC_BUSD,
    "0x4E0B5BaFC52D09A8F18eA0b7a6A7dc23A1096f99": BSC_DAI,
    "0x6c0F322442D10269Dd557C6e3A56dCC3a1198524": BSC_USDC,
    "0x6199cC917C12E4735B4e9cEfbe29E9F0F75Af9E5": BSC_USDT
  }
};

const excludeAlliTokens = {
  ethereum: [
    "0x1adc34af68e970a93062b67344269fd341979eb0", // General pool USX
    "0x44c324970e5cbc5d4c3f3b7604cbc6640c2dcfbf", // General pool EUX
    "0xf54954ba7e3cdfda23941753b48039ab5192aea0", // Stock pool USX
    "0xab9c8c81228abd4687078ebda5ae236789b08673", // Stock pool EUX
    "0xa5d65e3bd7411d409ec2ccfa30c6511ba8a99d2b", // Liqee qUSX
    "0x4c3f88a792325ad51d8c446e1815da10da3d184c" // Liqee iMUSX
  ],
  // Optimism
  optimism: [
    "0x7e7e1d8757b241aa6791c089314604027544ce43" // iUSX
  ],
  // BNB-Chain
  bsc: [
    "0x7b933e1c1f44be9fb111d87501baada7c8518abe", // General pool USX
    "0x983a727aa3491ab251780a13acb5e876d3f2b1d8", // General pool EUX
    "0x911f90e98d5c5c3a3b0c6c37bf6ea46d15ea6466", // Stock pool USX
    "0x8af4f25019e00c64b5c9d4a49d71464d411c2199", // Stock pool EUX
    "0x450e09a303aa4bcc518b5f74dd00433bd9555a77", // Liqee qUSX
    "0xee0d3450b577743eee2793c0ec6d59361eb9a454" // Liqee iMUSX
  ],
  // Polygon
  polygon: [
    "0xc171ebe1a2873f042f1dddd9327d00527ca29882" // iUSX
  ],
  // Arbitrum
  arbitrum: [
    "0x0385f851060c09a552f1a28ea3f612660256cbaa", // iUSX
    "0x5675546eb94c2c256e6d7c3f7dcab59bea3b0b8b" // iEUX
  ],
  avax: [
    "0x73c01b355f2147e5ff315680e068354d6344eb0b" // iUSX
  ],
  kava: [
    "0x9787af345e765a3fbf0f881c49f8a6830d94a514" // iUSX
  ]
};

// DF staking pool: sDF
const dfStakingPools = "0x41602ccf9b1F63ea1d0Ab0F0A1D2F4fd0da53f60";

const USXs = {
  "ethereum": "0x0a5e677a6a24b2f1a2bf4f3bffc443231d2fdec8",
  "bsc": "0xb5102cee1528ce2c760893034a4603663495fd72",
  "arbitrum": "0x641441c631e2f909700d2f41fd87f0aa6a6b4edb",
  "polygon": "0xCf66EB3D546F0415b368d98A95EAF56DeD7aA752",
  "avax": "0x853ea32391AaA14c112C645FD20BA389aB25C5e0",
  "kava": "0xDb0E1e86B01c4ad25241b1843E407Efc4D615248",
};

async function getDFStakingValue(block) {
  // Mainnet DF
  const DF = "0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0";

  const { output: stakingExchangeRate } = await sdk.api.abi.call({
    block,
    target: dfStakingPools,
    abi: abi["getCurrentExchangeRate"],
    chain: "ethereum"
  });

  const { output: stakingTotalSupply } = await sdk.api.abi.call({
    block,
    target: dfStakingPools,
    abi: abi["totalSupply"],
    chain: "ethereum"
  });

  const lockedDF = BigNumber(stakingExchangeRate.toString()).times(BigNumber(stakingTotalSupply.toString())).div(BASE);

  return {
    [DF]:lockedDF
  };
}

async function getUnderlyingPrice(chain, token, block) {
  const { output: iTokenPrices } = await sdk.api.abi.call({
    block,
    target: oracles[chain],
    params: mappingTokens[token] ? mappingTokens[token] : token,
    abi: abi["getUnderlyingPrice"],
    chain: chain
  });

  return iTokenPrices;
}

async function getTVLOfdToken(chain, block, dTokenBalances) {
  let dTokenTVL = BigNumber("0");
  let dTokens = yieldMarkets[chain];
  let dTokenUnderlyings = yieldUnderlyingTokens[chain];
  await
  Promise.all(dTokens.map(async dToken => {
      let { output: marketTVL } = await sdk.api.abi.call({
        block,
        target: dToken,
        abi: abi["getBaseData"],
        chain: chain
      });

      const _balance = marketTVL["4"] || 0;

      dTokenBalances[dTokenUnderlyings[dToken]] = _balance;

      let assetPrice = await getUnderlyingPrice(chain, dTokenUnderlyings[dToken], block);

      dTokenTVL = dTokenTVL.plus(BigNumber(_balance).times(BigNumber(assetPrice)).div(Double)
      )})
  );

  return {
    dTokenBalances,
    dTokenTVL
  };
}

function getTVLByChain(chain) {
  return async (time, ethBlock, chainBlocks) => {
    const block = chainBlocks[chain];
    const balances = {};
    if (chain == "ethereum") {
      // 1. get balance and tvl of the USDx token.
      await sumTokensSharedOwners(balances, usdxReservedTokens, [usdxPool], block, chain)
      // 2. get backing of GOLDx token.
      await sumTokensSharedOwners(balances, [goldxReserve], [goldxProtocol], block, chain)
    }

    if (chain === "ethereum" || chain === "bsc") {
      // 3. get balance and tvl of the dToken protocol.
      let {
        dTokenBalances: dTokenDetails,
        dTokenTVL: dTokenTVL
      } = await getTVLOfdToken(chain, block, balances);
    }

    return balances
  }
}

function getLendingTvl(chain, borrowed){
  return sdk.util.sumChainTvls(allControllers[chain].map(controller =>
    getCompoundUsdTvl(controller, chain, "0x5ACD75f21659a59fFaB9AEBAf350351a8bfaAbc0", borrowed,
      {
        oracle: abi['oracle'],
        underlyingPrice: abi['getUnderlyingPrice'],
        getAllMarkets: abi['getAlliTokens']
      }, {
      blacklist: excludeAlliTokens[chain].concat([USXs[chain] ?? ""]),
    })
  ))
}

function chainTvl(chain) {
  return {
    tvl: sdk.util.sumChainTvls([getLendingTvl(chain, false), getTVLByChain(chain)]),
    borrowed: getLendingTvl(chain, true),
  };
}

async function staking(timestamp, ethBlock, chainBlocks) {
  return getDFStakingValue(ethBlock);
}

module.exports = {
  ethereum: {
    ...chainTvl("ethereum"),
    staking,
  },
  ...generalizedChainExports(chainTvl, ["bsc", "arbitrum", "optimism", "polygon", "avax", "kava"]),
  start: 1564165044, // Jul-27-2019 02:17:24 AM +UTC
}

'''
'''--- projects/dforce/tokenMapping.json ---
{
    "0x0000000000085d4780B73119b644AE5ecd22b376": "0x6E6a689a5964083dFf9FD7A0f788BAF620ea2DBe",
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48": "0x2f956b2f801c6dad74E87E7f45c94f6283BF0f45",
    "0x8E870D67F660D95d5be530380D0eC0bd388289E1": "0x24677e213DeC0Ea53a430404cF4A11a6dc889FCe",
    "0x355C665e101B9DA58704A8fDDb5FeeF210eF20c0": "0x164315EA59169D46359baa4BcC6479bB421764b6",
    "0x6B175474E89094C44Da98b954EedeAC495271d0F": "0x298f243aD592b6027d4717fBe9DeCda668E3c3A8",
    "0xdAC17F958D2ee523a2206206994597C13D831ec7": "0x1180c114f7fAdCB6957670432a3Cf8Ef08Ab5354",
    "0xeb269732ab75A6fD61Ea60b06fE994cD32a83549": "0x6E6a689a5964083dFf9FD7A0f788BAF620ea2DBe",
    "0x0a5E677a6A24b2F1A2Bf4F3bFfC443231d2fDEc8": "0x1AdC34Af68e970a93062b67344269fD341979eb0",
    "0xb986F3a2d91d3704Dc974A24FB735dCc5E3C1E70": "0x44c324970e5CbC5D4C3F3B7604CbC6640C2dcFbF",
    "0x527Ec46Ac094B399265d1D71Eff7b31700aA655D": "0x4013e6754634ca99aF31b5717Fa803714fA07B35",
    "0x8d2Cb35893C01fa8B564c84Bd540c5109d9D278e": "0x237C69E082A94d37EBdc92a84b58455872e425d6",
    "0xc4Ba45BeE9004408403b558a26099134282F2185": "0x3481E1a5A8014F9C7E03322e4d4532D8ec723409",
    "0x966E726853Ca97449F458A3B012318a08B508202": "0xaab2BAb88ceeDCF6788F45885155B278faD09110",
    "0x32F9063bC2A2A57bCBe26ef662Dc867d5e6446d1": "0xb0ffBD1E81B60C4e8a8E19cEF3A6A92fe18Be86D",
    "0x8dc6987F7D8E5aE9c39F767A324C5e46C1f731eB": "0xa4C13398DAdB3a0A7305647b406ACdCD0689FCC5",
    "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56": "0x5511b64Ae77452C7130670C79298DEC978204a47",
    "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3": "0xAD5Ec11426970c32dA48f58c92b1039bC50e5492",
    "0x55d398326f99059fF775485246999027B3197955": "0x0BF8C72d618B5d46b055165e21d661400008fa0F",
    "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d": "0xAF9c10b341f55465E8785F0F81DBB52a9Bfe005d",
    "0xCf66EB3D546F0415b368d98A95EAF56DeD7aA752": "0xc171EBE1A2873F042F1dDdd9327D00527CA29882",
    "0x853ea32391AaA14c112C645FD20BA389aB25C5e0": "0x73C01B355F2147E5FF315680E068354D6344Eb0b",
    "0xDb0E1e86B01c4ad25241b1843E407Efc4D615248": "0x9787aF345E765a3fBf0F881c49f8A6830D94A514"
}

'''
'''--- projects/dfs/index.js ---
const { get_account_tvl } = require("../helper/eos");

const tokens = [
  ["eosio.token", "EOS", "eos"],
  ["tethertether", "USDT", "tether"],
  ["btc.ptokens", "PBTC", "ptokens-btc"],
  ["token.defi", "BOX", "defibox"],
  ["minedfstoken", "DFS", "defis-network"],
  ["emanateoneos", "EMT", "emanate"],
  ["token.newdex", "DEX", "newdex-token"],
  ["chexchexchex", "CHEX", "chex-token"],
  ["everipediaiq", "IQ", "everipedia"],
  ["eosiotptoken", "TPT", "token-pocket"],
  ["core.ogx", "OGX", "organix"],
]

// https://apps.defis.network/
// AMM swap
async function eos() {
  return await get_account_tvl("defisswapcnt", tokens);
}

module.exports = {
  methodology: `DFS TVL is achieved by querying token balances from DFS's AMM swap liquidity smart contract.`,
  eos: {
    tvl: eos
  },
}

'''
'''--- projects/dfx/contracts.json ---
{
  "usdc": {
    "ethereum": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "polygon": "0x2791bca1f2de4661ed88a30c99a7a9449aa84174"
  },
  "ethereum": [
    {
      "address": "0xa6c0cbcaebd93ad3c6c94412ec06aaa37870216d",
      "token": "0xcadc0acd4b445166f12d2c07eac6e2544fbe2eef"
    },
    {
      "address": "0x1a4ffe0dcbdb4d551cfca61a5626afd190731347",
      "token": "0xdb25f211ab05b1c97d595516f45794528a807ad8"
    },
    {
      "address": "0x2bab29a12a9527a179da88f422cdaaa223a90bd5",
      "token": "0x70e8de73ce538da2beed35d14187f6959a8eca96"
    },
    {
      "address": "0xdD39379AB7C93b9bAAE29E6eC03795d0bC99a889",
      "token": "0xebf2096e01455108badcbaf86ce30b6e5a72aa52"
    },
    {
      "address": "0xE9669516e09f5710023566458F329cCE6437AaaC",
      "token": "0xda446fad08277b4d2591536f204e018f32b6831c",
      "currency": "NZDS"
    },
    {
      "address": "0xC574A613A3900e4314da13eB2287f13689A5b64D",
      "token": "0x2c537e5624e4af88a7ae4060c022609376c8d0eb",
      "currency": "TRYb"
    }
  ],
  "polygon": [
    {
      "address": "0x288Ab1b113C666Abb097BB2bA51B8f3759D7729e",
      "token": "0x5d146d8b1dacb1ebba5cb005ae1059da8a1fbf57",
      "currency": "CADC"
    },
    {
      "address": "0xB72d390E07F40D37D42dfCc43E954Ae7c738Ad44",
      "token": "0xe111178a87a3bff0c8d18decba5798827539ae99",
      "currency": "EURS"
    },
    {
      "address": "0x8e3e9cB46E593Ec0CaF4a1Dcd6DF3A79a87b1fd7",
      "token": "0x769434dca303597c8fc4997bf3dab233e961eda2",
      "currency": "XSGD"
    },
    {
      "address": "0xea75cd0b12a8b48f5bddad37ceb15f8cb3d2cc75",
      "token": "0x4fb71290ac171e1d144f7221d882becac7196eb5",
      "currency": "TRYb"
    },
    {
      "address": "0x931d6a6cc3f992beee80a1a14a6530d34104b000",
      "token": "0xeafe31cd9e8e01c8f0073a2c974f728fb80e9dce",
      "currency": "NZDs"
    }
  ]
}
'''
'''--- projects/dfx/index.js ---
const sdk = require("@defillama/sdk");
const { transformPolygonAddress } = require("../helper/portedTokens");
const contracts = require('./contracts.json');

// node test.js projects/dfx/index.js
function tvl(chain) {
  return async (timestamp, block, chainBlocks) => {
    const transform =
      chain == "polygon" ? await transformPolygonAddress() : (a) => a;
    const balances = {};

    const [tokenBalances, usdcBalances] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: contracts[chain].map((c) => ({
          target: c.token,
          params: [c.address],
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain,
      }),

      sdk.api.abi.multiCall({
        calls: contracts[chain].map((c) => ({
          target: contracts.usdc[chain],
          params: [c.address],
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain,
      }),
    ]);

    await Promise.all([
      sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transform),
      sdk.util.sumMultiBalanceOf(balances, usdcBalances, true, transform),
    ]);

    return balances;
  };
};

module.exports = {
  ethereum: {
    tvl: tvl("ethereum"),
  },
  polygon: {
    tvl: tvl("polygon"),
  },
};

'''
'''--- projects/dfyn/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
  polygon:{
    tvl: getUniTVL({
      chain: 'polygon',
      factory: '0xE7Fb3e833eFE5F9c441105EB65Ef8b261266423B',
      coreAssets: [
        '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC
        '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
        '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619', // WETH
      ],
    }),
  },
  okexchain:{
    tvl: getUniTVL({
      factory: '0xE7Fb3e833eFE5F9c441105EB65Ef8b261266423B',
      chain: 'okexchain',
      coreAssets: [
        '0x382bb369d343125bfb2117af9c149795c6c65c50', // tether
        "0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85", // usdc
        "0x8f8526dbfd6e38e3d8307702ca8469bae6c56c15", // wokt
      ]
    }),
  },
  fantom:{
    tvl: getUniTVL({
      factory: '0xd9820a17053d6314B20642E465a84Bf01a3D64f5',
      chain: 'fantom',
      coreAssets: [
        '0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83', // wftm
        '0x04068da6c83afcfa0e13ba15a6696662335d5b75', // USDC
        '0x049d68029688eabf473097a2fc38ef61633a3c7a', // USDT
        '0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e', // DAI
      ],
    }),
  },
}

'''
'''--- projects/dhedge.js ---
const utils = require('./helper/utils');
const { GraphQLClient, gql } = require('graphql-request');

/* * * * * * * *
 * ==> Correct adapter needs to be created.
 *
 *****************/

const STATS_URL = 'https://us-central1-dh-alpha.cloudfunctions.net/stats';

async function fetch() {
  var totalTvl = await utils.fetchURL(STATS_URL);
  return totalTvl.data.protocolStats.totalAssetUnderManagement;
}

async function ethereum() {
  var totalTvl = await utils.fetchURL(STATS_URL);
  return totalTvl.data.protocolStats.ethereum.totalAumEthereum;
}

async function polygon() {
  var totalTvl = await utils.fetchURL(STATS_URL);
  return totalTvl.data.protocolStats.polygon.totalAumPolygon;
}

async function optimism() {
  var totalTvl = await utils.fetchURL(STATS_URL);
  return totalTvl.data.protocolStats.optimism.totalAumOptimism;
}

async function staking() {
  var endpoint = 'https://api.thegraph.com/subgraphs/name/dhedge/dht-staking';
  var graphQLClient = new GraphQLClient(endpoint);

  var query = gql`
    {
      stakingContracts {
        id
        balance
      }
    }
  `;

  const data = await graphQLClient.request(query);
  const balance = data.stakingContracts[0].balance;

  return {
    'dhedge-dao': balance / 10 ** 18
  }
}

module.exports = {
  ethereum: {
    fetch: ethereum,
    staking, 
  },
  polygon: {
    fetch: polygon,
  },
  optimism: {
    fetch: optimism,
  },
  fetch,
};

'''
'''--- projects/diamond-coin/index.js ---
const sdk = require("@defillama/sdk");
const {pool2Exports} = require("../helper/pool2");

const token = "0xDDa0F0E1081b8d64aB1D64621eb2679F93086705";
const emissionRewardPool = "0xDDa0F0E1081b8d64aB1D64621eb2679F93086705";

const DiamondLPs = [
    "0xf5e8B220843EC7114B91AfF0D25342c24eB953b5", // DIAMOND-FTM 
    "0x2f1569094CB256fB745901fa92e57aF011D32B2C" // BOMB-DIAMOND 
]

module.exports = {
    fantom: {
        tvl: async () => ({}),
        pool2: pool2Exports(emissionRewardPool, DiamondLPs, "fantom", addr=>`fantom:${addr}`)
    }
}

'''
'''--- projects/diamond/abi.json ---
{
    "totalAsset": {
        "inputs": [],
        "name": "totalAsset",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalAssets": {
        "inputs": [],
        "name": "totalAssets",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/diamond/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { transformOptimismAddress } = require("../helper/portedTokens");

// Ethereum
const ETH_BULL_VAULT = "0xad48a8261b0690c71b70115035eb14afd9a43242";
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";

// Optimism
const BASIS_TRADING_VAULT = "0xD576bE0d3CC1c0184d1ea3F1778A4A9Dec523859";
const OPT_USDC = "0x7F5c764cBc14f9669B88837ca1490cCa17c31607";

async function ethTvl(block) {
  return {
    [WETH]: (
      await sdk.api.abi.call({
        target: ETH_BULL_VAULT,
        block,
        abi: abi.totalAsset,
        chain: "ethereum",
      })
    ).output,
  };
}

async function optTvl(block) {
  const transform = await transformOptimismAddress();
  return {
    [transform(OPT_USDC)]: (
      await sdk.api.abi.call({
        target: BASIS_TRADING_VAULT,
        block,
        abi: abi.totalAssets,
        chain: "optimism",
      })
    ).output,
  };
}

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
  optimism: {
    tvl: optTvl,
  },
};

'''
'''--- projects/dibs-money/index.js ---
const { tombTvl } = require("../helper/tomb");

const dibs = "0xfd81ef21ea7cf1dc00e9c6dd261b4f3be0341d5c";
const dshare = "0x26d3163b165be95137cee97241e716b2791a7572";
const rewardPool = "0x8f75dfc6a598b00cc18edce9e458451f3742007d";
const masonry = "0xf65c374a91f47f8732a86acc49c74df4db8b2f1f";

const lps = [
    "0x9bebe118018d0de55b00787b5eeabb9eda8a9e0a",
    "0x5998af8868e5e4fbd7c60da221b76b201e441612"
];

module.exports = {
    ...tombTvl(dibs, dshare, rewardPool, masonry, lps, "bsc")
}
'''
'''--- projects/diffusionfi/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { stakingUnknownPricedLP } = require("../helper/staking");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x6abdda34fb225be4610a2d153845e09429523cd2) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  evmos: {
    tvl: calculateUsdUniTvl(
      "0x6abdda34fb225be4610a2d153845e09429523cd2",
      "evmos",
      "0xD4949664cD82660AaE99bEdc034a0deA8A0bd517",
      [
        "0x63743ACF2c7cfee65A5E356A4C4A005b586fC7AA", // dai
        "0x5842C5532b61aCF3227679a8b1BD0242a41752f2", //weth
        "0x51e44FfaD5C2B122C8b635671FCC8139dc636E82", //usdc
        "0x7FF4a56B32ee13D7D4D405887E0eA37d61Ed919e", //usdt
        "0xD4949664cD82660AaE99bEdc034a0deA8A0bd517", //wevmos
      ],
      "evmos"
    ),
    staking: stakingUnknownPricedLP('0x75aeE82a16BD1fB98b11879af93AB7CE055f66Da', '0x3f75ceabcdfed1aca03257dc6bdc0408e2b4b026', "evmos", "0x5b575e84e4921A93D57301cB75C9635BA12D50e2")
  },
}; // node test.js projects/diffusionfi/index.js
'''
'''--- projects/dinoexchange/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js');
const { staking } = require("../helper/staking.js");

const DINO_TOKEN = '0xf317932ee2c30fa5d0e14416775977801734812d'
const MASTER_DINO = '0x26CB55795Cff07Df3a1Fa9Ad0f51d6866a80943b'
const FACTORY_DINO = "0x35E9455c410EacD6B4Dc1D0ca3144031f6251Dc2";

async function bscTvl(timestamp, block, chainBlocks) {
  var rs = calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks['bsc'], 'bsc', FACTORY_DINO, 0, true);
  return rs;
}

module.exports = {
  bsc:{
    tvl: bscTvl,
    staking: staking(MASTER_DINO, DINO_TOKEN, "bsc")
  },
}
'''
'''--- projects/dinopool/index.js ---
const sdk = require("@defillama/sdk")

const { tombTvl } = require('../helper/tomb')

const bond = "0x7091002B330D8054cb8584e5057451Ba983b975E";
const share = "0xC21718b8a93529d33E7b5dCdFF439402c47428aC";
const boardroom = "0x2fa7259b002ac24e24f27bc5b83f186e37738b75";
const rewardPool = "0xd04b9FCF5bC9Cd046233f4ead8aDdcD56D2eA453";

const lps = [
  "0x0526467a2cB9DF86e1FA8f0abA3E4ab090126324",
  "0xFc8281ddAE23612D60A242c10c35EE5E0a4c1541",
];

module.exports = {
    ...tombTvl(bond, share, rewardPool, boardroom, lps, "cronos", undefined, false, lps[1])
};

'''
'''--- projects/dinosaureggs/index.js ---
const {calculateUniTvl} = require("../helper/calculateUniTvl");

const factory = "0x73d9f93d53505cb8c4c7f952ae42450d9e859d10";

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  return calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks.bsc, "bsc", factory, 0, true);
};

module.exports = {
  tvl: bscTvl
};

'''
'''--- projects/dinoswap/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accDinoPerShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/dinoswap/index.js ---
const abi = require("./abi.json");
const {masterChefExports} = require('../helper/masterchef');

const MASTERCHEF_CONTRACT = "0x1948abC5400Aa1d72223882958Da3bec643fb4E5";
const token = "0xAa9654BECca45B5BDFA5ac646c939C62b527D394";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(MASTERCHEF_CONTRACT, "polygon", token, true, abi.poolInfo)
}
'''
'''--- projects/diosfinance/index.js ---
const { ohmTvl } = require("../helper/ohm");

const dios = "0x08eEcF5d03bDA3dF2467F6AF46b160c24D931DE7";
const diosStaking = "0x36c8a6E7436EDd850752E09539a519a369D95096";

const treasury = "0x98eE3F3629aCFA6fDDB49028C494030E5dFA349a";
const busd = "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56";
const diosBusdLP = "0x2D7A5e9d85F62ADbaea9d48B11F5947F3AC57FC8";

module.exports = {
  ...ohmTvl(
    treasury,
    [
      [busd, false],
      [diosBusdLP, true],
    ],
    "bsc",
    diosStaking,
    dios
  ),
};

'''
'''--- projects/dmd/index.js ---
const { get_account_tvl } = require("../helper/eos");

const tokens = [
    ["eosio.token", "EOS", "eos"],
    ["tethertether", "USDT", "tether"],
    ["organixtoken", "OGX", "organix"],

];

const accounts = [
    "eosdmdpool11",
    "eosdmdpool12",
    "eosdmdpool13",
]

// DMD Finance
// https://dmd.finance/
async function eos() {
  return await get_account_tvl(accounts, tokens);
}

module.exports = {
  methodology: `DMD Finance's TVL is achieved by querying token balances from DMD staking smart contract(s).`,
  eos: {
    tvl: eos
  },
}
'''
'''--- projects/dmmexchange/abi.json ---
{
    "allPools": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allPools",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "allPoolsLength": {
        "inputs": [],
        "name": "allPoolsLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getReserves": {
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {
                "internalType": "uint112",
                "name": "_reserve0",
                "type": "uint112"
            },
            {
                "internalType": "uint112",
                "name": "_reserve1",
                "type": "uint112"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/dmmexchange/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const factory = "0x833e4083B7ae46CeA85695c4f7ed25CDAd8886dE";

const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const poolLength = Number(
    (
      await sdk.api.abi.call({
        target: factory,
        abi: abi.allPoolsLength,
        block: ethBlock,
      })
    ).output
  );

  const allPoolNums = Array.from(Array(poolLength).keys());

  const poolAddresses = (
    await sdk.api.abi.multiCall({
      abi: abi.allPools,
      calls: allPoolNums.map((num) => ({
        target: factory,
        params: [num],
      })),
      block: ethBlock,
    })
  ).output.map((el) => el.output);

  for (let i = 0; i < poolAddresses.length; i++) {
    const token0 = (
      await sdk.api.abi.call({
        target: poolAddresses[i],
        abi: abi.token0,
        block: ethBlock,
      })
    ).output;

    const token1 = (
      await sdk.api.abi.call({
        target: poolAddresses[i],
        abi: abi.token1,
        block: ethBlock,
      })
    ).output;

    const getReserves = (
      await sdk.api.abi.call({
        target: poolAddresses[i],
        abi: abi.getReserves,
        block: ethBlock,
      })
    ).output;

    sdk.util.sumSingleBalance(balances, token0, getReserves[0]);

    sdk.util.sumSingleBalance(balances, token1, getReserves[1]);
  }

  return balances;
};

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
};

'''
'''--- projects/dnadollar/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTime",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accDSharePerShare",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "isStarted",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/dnadollar/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const treasuryContract = "0x1420287565FD5Ebec8FbD720c17Cd911600449d3";

const FundDAO = "0x3e1Aa19FA59c9B474f6d2F37976a84DeD64af4Bf";
const USDT = "0x66e428c3f67a68878562e79a0234c1f83c208770";
const USDC = "0xc21223249ca28397b4b6541dffaecc539bff0c59";
const USDC_DSHARE_meerkatLP = "0xFe0F0d50175789C1F69B41dB797cc9ABd8Ab0120";

const DShareRewardPool = "0x1A4bb8E03C35e2B672A0fcE18cab920aa023d7FC";
// node test.js projects/dnadollar/index.js
const stakingContracts = [
  "0xed94536A27922e2BD0eE661abF5fB030228d9D72",
  FundDAO,
  DShareRewardPool,
];
const DSHARE = "0x0e98dc462ff438b802fad0d68ff7f111a0674bb5";
const DNA = "0xcc57f84637b441127f2f74905b9d99821b47b20c";

async function Staking(timestamp, chainBlocks) {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [DNA, false],
      [DSHARE, false],
    ],
    stakingContracts,
    chainBlocks["cronos"],
    "cronos",
    (addr) => `cronos:${addr}`
  );

  return balances;
}

const pool2 = async (chainBlocks) => {
  const balances = {};

  const lpPositions = [];
  for (let i = 0; i < 5; i++) {
    const token = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: DShareRewardPool,
        params: i,
        chain: "cronos",
        block: chainBlocks["cronos"],
      })
    ).output.token;

    const getTokenBalance = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: token,
        params: DShareRewardPool,
        chain: "cronos",
        block: chainBlocks["cronos"],
      })
    ).output;

    lpPositions.push({
      token: token,
      balance: getTokenBalance,
    });
  }

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["cronos"],
    "cronos",
    (addr) => `cronos:${addr}`
  );

  return balances;
};

async function cronosTvl(timestamp, chainBlocks) {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [USDT, false],
      [USDC, false],
      [USDC_DSHARE_meerkatLP, true],
    ],
    [FundDAO],
    chainBlocks["cronos"],
    "cronos",
    (addr) => `cronos:${addr}`
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  cronos: {
    treasury: staking(treasuryContract, DNA, "cronos"),
    staking: Staking,
    pool2: pool2,
    tvl: cronosTvl,
  },
  methodology: "Counts liquidity of the tokens deposited on the DAO Fund through the wallet Address; and Pool2s and Staking parts through DShareRewardPool and Laboratory Contracts.",
};

'''
'''--- projects/dodo/index.js ---
const { request, gql } = require("graphql-request");
const sdk = require('@defillama/sdk');
const { transformArbitrumAddress } = require('../helper/portedTokens')
const { getBlock } = require('../helper/getBlock')

const graphEndpoints = {
    'ethereum': "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2",
    "bsc": "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-bsc",
    "heco": "https://q.hg.network/subgraphs/name/dodoex/heco",
    "polygon": "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-polygon",
    "arbitrum": "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-arbitrum",
    "aurora": "https://api.thegraph.com/subgraphs/name/dodoex/dodoex-v2-aurora"
}
const graphQuery = gql`
query get_pairs($lastId: String) {
    pairs(
      first: 1000,
      where: {id_gt: $lastId}
    ) {
        id
        baseReserve
        quoteReserve
        baseToken{
          id
          symbol
          usdPrice
        }
        quoteToken{
          id
          symbol
          usdPrice
        }
    }
}
`

async function getChainTvl(chain, block, transformAddr) {
    let allPairs = []
    let lastId = ""
    let response;
    do {
        response = await request(
            graphEndpoints[chain],
            graphQuery,
            {
                lastId
            }
        );
        allPairs = allPairs.concat(response.pairs)
        lastId = response.pairs[response.pairs.length - 1].id
    } while (response.pairs.length >= 1000);

    const balanceCalls = allPairs.map(pair => {
        if (pair.id.includes('-')) {
            return null
        }
        return [{
            target: pair.quoteToken.id,
            params: [pair.id]
        }, {
            target: pair.baseToken.id,
            params: [pair.id]
        }]
    }).filter(pair => pair !== null).flat().filter(call =>
        ![
            '0xd79d32a4722129a4d9b90d52d44bf5e91bed430c', 
            '0xdb1e780db819333ea79c9744cc66c89fbf326ce8', // this token is destroyed
            '0x738076a6cb6c30d906bcb2e9ba0e0d9a58b3292e', // SRSB is absuredly priced 
        ].includes(call.target.toLowerCase())
    )

    let balanceResults = await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: balanceCalls,
        block,
        chain,
        requery: true,
    })
    const balances = {}
    sdk.util.sumMultiBalanceOf(balances, balanceResults, true, transformAddr)
    return balances
}

function bsc(timestamp, ethBlock, chainBlocks) {
    return getChainTvl('bsc', chainBlocks['bsc'], addr => `bsc:${addr}`)
}

function eth(timestamp, ethBlock, chainBlocks) {
    return getChainTvl('ethereum', ethBlock, addr => addr)
}

function polygon(timestamp, ethBlock, chainBlocks) {
    return getChainTvl('polygon', chainBlocks['polygon'], addr => `polygon:${addr}`)
}

async function arbitrum(timestamp, ethBlock, chainBlocks) {
    const block = await getBlock(timestamp, "arbitrum", chainBlocks)
    const transform = await transformArbitrumAddress()
    return getChainTvl('arbitrum', block, transform)
}

async function aurora(timestamp, ethBlock, chainBlocks) {
    return getChainTvl('aurora', await getBlock(timestamp, 'aurora', chainBlocks), addr => `aurora:${addr}`)
}

async function heco(timestamp, ethBlock, chainBlocks) {
    return getChainTvl('heco', await getBlock(timestamp, 'heco', chainBlocks), addr => `heco:${addr}`)
}

module.exports = {
    ethereum: {
        tvl: eth,
    },
    bsc: {
        tvl: bsc
    },
    polygon: {
        tvl: polygon
    },
    arbitrum: {
        tvl: arbitrum
    },
    aurora: {
        tvl: aurora
    }
    // We don't include heco because their subgraph is outdated
}

'''
'''--- projects/dogeswap/index.js ---
const { sumTokens, } = require('../helper/unwrapLPs')

async function staking(timestamp, block) {

  const DOGE_STAKING_CONTRACT = '0xd688F6223c11F601420d716d88d8C1AD018711B8'
  const DOGES_TOKEN = '0xb4FBed161bEbcb37afB1Cb4a6F7cA18b977cCB25'
  const PUPPY_STAKING_CONTRACT = '0x7a455859C5Bbe2a87c9c76FB684174B6cd31242E'
  const PUPPY_TOKEN = '0xa9fb117df8d8a8e3db2f456078320548d6e107fa'

  const balances = {}
  await sumTokens(
    balances,
    [
      [DOGES_TOKEN, DOGE_STAKING_CONTRACT, ],
      [PUPPY_TOKEN, PUPPY_STAKING_CONTRACT, ],
    ],
    block,
  )

  return balances
}

module.exports = {
  ethereum: {
    staking,
    tvl: () => ({})
  },
}

'''
'''--- projects/dogsofelon/index.js ---
const { stakings } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const stakingContracts = [
  "0x60C6b5DC066E33801F2D9F2830595490A3086B4e", // DOE earning
  "0xaEbA219f6bf8Ec703a1CF1C4bA540cD4Bafa2fBe", // SHIB earning
];
const DOE = "0xf8e9f10c22840b613cda05a0c5fdb59a4d6cd7ef";

const stakingPool2Contract = "0x3C40601f73fbf50b81a72edbf2786f14EBb7371b";
const DOE_WETH_SLP = "0xd2696e995a2ef33c9b4a3c47f6aa2651beb48b21";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, DOE),
  },
  arbitrum: {
    pool2: pool2(stakingPool2Contract, DOE_WETH_SLP, "arbitrum"),
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking and pool2 only",
};

'''
'''--- projects/dokidoki/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const doki = "0x9cEB84f92A0561fa3Cc4132aB9c0b76A59787544";
const azuki = "0x910524678C0B1B23FFB9285a81f99C29C11CBaEd";
const polyDoki = "0x5C7F7Fe4766fE8f0fa9b41E2E4194d939488ff1C";
const polyAzuki = "0x7CdC0421469398e0F3aA8890693d86c840Ac8931";

// STAKING
const ethStakingPools = [
  {
    pool: "0x0CE0f2b998C0a1b0280Dcc95935108781d18E65b",
    token: "0x9cEB84f92A0561fa3Cc4132aB9c0b76A59787544",
  }, // DOKI
  {
    pool: "0x4a5573eE3F333260DB50A385F6fFDAc440fc80b1",
    token: "0x9cEB84f92A0561fa3Cc4132aB9c0b76A59787544",
  }, // DOKI
  {
    pool: "0xdf4F609134a84aae1D18dCe8d863b099c6455598",
    token: "0x910524678C0B1B23FFB9285a81f99C29C11CBaEd",
  }, // AZUKI
];

// POOL2 LPS
const ethPool2LPs = [
  {
    owner: "0x95583A6F7aAAA56C48b27413d070219e22844435",
    pool: "0x1D4b2B2a2Ca8762410801b51f128B73743439E39",
  }, // DOKI-ETH
  {
    owner: "0xB89cf3528A3a62C2f58BDbcFd7C15312a33ce91D",
    pool: "0x1D4b2B2a2Ca8762410801b51f128B73743439E39",
  }, // aDOKI-ETH
  {
    owner: "0x27599F0b45008dAD28899e8E278ab191673C9179",
    pool: "0x654def3E97C3F4218C3f49ace81687483C361b2b",
  }, // AZUKI-ETH
];

// POOLS
const ethPools = [
  {
    pool: "0xb3a2AF499aF8f717BB3431968f8e0b038C975686",
    token: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
  }, // WBTC
  {
    pool: "0xde846827cE3022EcD5eFD6ed316a2dEf9AB299B8",
    token: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  }, // WETH
];

// POLYGON POOL2 LPS
const polyPool2LPs = [
  {
    owner: "0xc0a1dFb85734E465C5dadc5683DE58358C906598",
    pool: "0xd0985A2E8410c03B3bB0D7997DA433428D58342f"
  }, // AZUKI-MUST
  {
    owner: "0x69Cb6f98E45c13A230d292bE0a6aF93a6521c39B",
    pool: "0x92Bb3233F59561FC1fEC53EfC3339E4Af8E917F4"
  }, // AZUKI-ETH
  {
    owner: "0x2146baC214D9BF2Da56c3d4A69b9149e457F9d8c",
    pool: "0x9cb31B03089eca4C0f42554256d0217326D15AE7"
  }, // DOKI-MUST
  {
    owner: "0xBbDC1681e43549d3871CF1953D1dD9afF320feF0",
    pool: "0xcCeD5cB001D6081c4561bf7911F11Ccd9aAA1474"
  } // DOKI-ETH
];

const polyStakingPools = [
  {
    pool: "0xE699FFCeD532BB43BD2A84C82c73C858758d12cC",
    token: "0x5C7F7Fe4766fE8f0fa9b41E2E4194d939488ff1C"
  } // DOKI
]

async function calcTvl(balances, chainBlocks, chain, pool) {
  let tokenBalance = (
    await sdk.api.abi.multiCall({
      calls: pool.map((p) => ({
        target: p.token,
        params: p.pool,
      })),
      abi: "erc20:balanceOf",
      block: chainBlocks[chain],
      chain: chain
    })
  ).output;
  tokenBalance.forEach((i) => {
    if (chain !== "ethereum") {
      sdk.util.sumSingleBalance(balances, `${chain}:${i.input.target}`, i.output);
    } else {
      sdk.util.sumSingleBalance(balances, i.input.target, i.output);
    }
  });
  return balances;
}

async function pool2(balances, chainBlocks, chain, pool) {
  let lpPositions = [];
  let lpBalances = (
    await sdk.api.abi.multiCall({
      calls: pool.map((p) => ({
        target: p.pool,
        params: p.owner,
      })),
      abi: "erc20:balanceOf",
      block: chainBlocks[chain],
      chain: chain
    })
  ).output;
  lpBalances.forEach((i) => {
    lpPositions.push({
      balance: i.output,
      token: i.input.target,
    });
  });
  await unwrapUniswapLPs(balances, lpPositions, chainBlocks[chain], chain, addr=>`${chain}:${addr}`);
  return balances;
}

async function ethTvl(timestamp, block) {
  let balances = {};
  await calcTvl(balances, block, "ethereum", ethPools);
  return balances;
}

async function ethStaking(timestamp, block) {
  let balances = {};
  await calcTvl(balances, block ,"ethereum", ethStakingPools);
  return balances;
}

async function ethPool2(timestamp, block) {
  let balances = {};
  await pool2(balances, block, "ethereum", ethPool2LPs);
  return balances;
}

async function polygonStaking(timestamp, block, chainBlocks) {
  let balances = {};
  await calcTvl(balances, chainBlocks.polygon, "polygon", polyStakingPools);
  return balances;
}

async function polygonPool2(timestamp, block, chainBlocks) {
  let balances = {};
  await pool2(balances, chainBlocks.polygon, "polygon", polyPool2LPs);
  return balances;
}

module.exports = {
  ethereum: {
    tvl: ethTvl,
    staking: ethStaking,
    pool2: ethPool2
  },
  polygon: {
    tvl: async () => ({}),
    staking: polygonStaking,
    pool2: polygonPool2
  },
};

'''
'''--- projects/dolphinswap/index.js ---
const { get_account_tvl } = require("../helper/eos");

const tokens = [
    ["eosio.token", "EOS", "eos"],
    ["tethertether", "USDT", "tether"],
    ["btc.ptokens", "PBTC", "ptokens-btc"],
    ["organixtoken", "OGX", "organix"],
    ["eosdmdtokens", "DMD", "dmd"],

];

// DMD Finance
// https://dmd.finance/
async function eos() {
  return await get_account_tvl("dolphinsswap", tokens);
}

module.exports = {
  methodology: `DolphinSwap's TVL is achieved by querying token balances from Swap smart contract.`,
  eos: {
    tvl: eos
  },
}
'''
'''--- projects/domfi/abi.js ---

const address = {
  "internalType": "address",
  "name": "",
  "type": "address"
};

const erc20Address = {
  "internalType": "contract IERC20",
  "name": "",
  "type": "address"
};

module.exports = {
  "LongShortPair.collateralToken": {
    "type": "function",
    "name": "collateralToken",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [erc20Address],
  },

  "LongShortPair.longToken": {
    "type": "function",
    "name": "longToken",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [erc20Address],
  },

  "LongShortPair.shortToken": {
    "type": "function",
    "name": "shortToken",
    "stateMutability": "view",
    "inputs": [],
    "outputs": [erc20Address],
  },

  "UniswapFactory.getPair": {
    "type": "function",
    "name": "getPair",
    "constant": true,
    "stateMutability": "view",
    "inputs": [address, address],
    "outputs": [address],
  }
};
'''
'''--- projects/domfi/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens, unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformPolygonAddress, transformBobaAddress } = require("../helper/portedTokens");
const { getBlock } = require("../helper/getBlock");
const abi = require("./abi");
const { Chain, lsps, uniswapFactory, ZERO_ADDRESS, usdc } = require("./registry");

const makeUniswapReserves = (chain, makeAddressTransform) => {
  return async (timestamp, block, chainBlocks) => {
    const balances = {};
    const transform = await makeAddressTransform?.();
    block = await getBlock(timestamp, chain, chainBlocks);

    const getLongToken = abi["LongShortPair.longToken"];
    const getShortToken = abi["LongShortPair.shortToken"];

    const [longTokens, shortTokens] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: lsps[chain].map(x => ({ target: x.address })),
        block,
        chain,
        abi: getLongToken,
        requery: true,
      }),

      sdk.api.abi.multiCall({
        calls: lsps[chain].map(x => ({ target: x.address })),
        block,
        chain,
        abi: getShortToken,
        requery: true,
      }),
    ]);

    const syntheticTokens = [
      ...longTokens.output.map(x => x.output),
      ...shortTokens.output.map(x => x.output),
    ];

    const getPair = abi["UniswapFactory.getPair"];
    const pairAddresses = await sdk.api.abi.multiCall({
      calls: syntheticTokens.map(syntheticAddress => ({ 
        target: uniswapFactory[chain],
        params: [
          usdc[chain], // NOTE: This is referenced below when summing tokens
          syntheticAddress,
        ]
      })),
      block,
      chain,
      abi: getPair,
      requery: true,
    });

    for (const result of pairAddresses.output) {
      if (result.output === ZERO_ADDRESS) {
        throw new Error(`Failed to get Uniswap-like pair address on chain '${chain}' for pair [${result.input.params.join(", ")}]`);
      }
    }

    await sumTokens(
      balances,
      pairAddresses.output
        .filter((x) => x.output !== null)
        .map((x) => [
          /* target: */ x.input.params[0],
          /* owner:  */ x.output
        ]),
      block,
      chain,
      transform,
    );

    return balances;
  }
}

const makeLspTvl = (chain, makeAddressTransform) => {
  return async (timestamp, block, chainBlocks) => {
    const balances = {};
    const transform = await makeAddressTransform?.();
    block = await getBlock(timestamp, chain, chainBlocks);

    const getCollateralToken = abi["LongShortPair.collateralToken"];
    const collaterals = await sdk.api.abi.multiCall({
      calls: lsps[chain].map(x => ({ target: x.address })),
      block,
      chain,
      abi: getCollateralToken,
      requery: true,
    });
    
    await sumTokens(
      balances,
      collaterals.output
        .filter((x) => x.output !== null)
        .map((x) => [x.output, x.input.target]),
      block,
      chain,
      transform,
    );

    return balances;
  }
}

const transformers = {
  [Chain.ETHEREUM]: undefined,
  [Chain.POLYGON]: transformPolygonAddress,
  [Chain.BOBA]: transformBobaAddress,
}

const run = (chain, f) => {
  const transform = transformers[chain];
  return f(chain, transform);
}

const runAll = (chain, fs) => {
  return fs.map(f => run(chain, f));
};

const tvlSources = [makeLspTvl, makeUniswapReserves];

module.exports = {
  ethereum: {
    tvl: sdk.util.sumChainTvls(runAll(Chain.ETHEREUM, tvlSources)),
  },
  polygon: {
    tvl: sdk.util.sumChainTvls(runAll(Chain.POLYGON, tvlSources)),
  },
  boba: {
    tvl: sdk.util.sumChainTvls(runAll(Chain.BOBA, tvlSources)),
  },
};

'''
'''--- projects/domfi/registry.js ---

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

const Chain = {
  ETHEREUM: 'ethereum',
  POLYGON: 'polygon',
  BOBA: 'boba',
}

const usdc = {
  [Chain.ETHEREUM]: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  [Chain.POLYGON]: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
  [Chain.BOBA]: "0x66a2A913e447d6b4BF33EFbec43aAeF87890FBbc",
}

const lsps = {
  [Chain.ETHEREUM]: [
    // BTCDOM
    {
      address: "0x3e75DCadDf32571d082da914c471180636f9567d",
    },

    // ETHDOM
    {
      address: "0x94E653AF059550657e839a5DFCCA5a17fD17EFdf",
    },

    // USDTDOM
    {
      address: "0xD3a0e00f11A91DA9797eEf5B74dF8fc325FC50e0",
    }
  ],

  [Chain.POLYGON]: [
    // BTCDOM
    {
      address: "0x12CcE472430f7F5071375Cc0A1Aab717310bE116",
    },

    // ETHDOM
    {
      address: "0x2771322091C9f86F1f770E2A633C66c068644100",
    },

    // USDTDOM
    {
      address: "0x514b3C2761Edc2487F320392EDF094d65E20C9Ee",
    },
  ],
  
  [Chain.BOBA]: [
    // BTCDOM-JUN20
    { address: "0x3C77d0130Eb6AfF1DED8C72fb7a5F383B7961c03" },
    // ETHDOM-JUN20
    { address: "0xCAB14a130cDB3143aD81657D552a7Cee1917a18e" },
    // USDTDOM-JUN20
    { address: "0x5B9f3B4648b1C7573d9c2A068020Bb34AEC67589" },

    // BTCDOM-JUN40
    { address: "0x156a4595b87cc204dc96d05f366ac3fcdff30bec" },
    // ETHDOM-JUN40
    { address: "0xF123b661d80e755ec26BC0C0CCaAFDD258a102d6" },
    // USDTDOM-JUN40
    { address: "0x6cafFBf5697c8744713956fdAf84d6a0613Ce20f" },
  ]
}

const uniswapFactory = {
  ethereum: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  polygon: "0x5757371414417b8c6caad45baef941abc7d3ab32",
  boba: "0x7DDaF116889D655D1c486bEB95017a8211265d29",
}

module.exports = {
  Chain,
  ZERO_ADDRESS,
  lsps,
  uniswapFactory,
  usdc,
};

'''
'''--- projects/donkey/abi.json ---
{
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/donkey/index.js ---
const sdk = require('@defillama/sdk');
const { getChainTransform } = require('../helper/portedTokens')
const abi = require('./abi.json')

const controllerAddress = {
  ethereum: '0x55e41bc3a99aa24E194D507517b1e8b65eFdAa9e',
  klaytn: '0x35dc04eE1D6E600C0d13B21FdfB5C83D022CEF25'
}

const mainDTokenAddress = {
  ethereum: '0xEc0D3f28D37a3393cf09ee3aD446c485b6afDaA3',
  klaytn: '0xACC72a0cA4E85f79876eD4C5E6Ea29BE1cD26c2e'
}

const stakings = [
  '0x4f2ED52bC4CbdE54e2b3547D3758474A21598D7c',
  '0x024510151204DeC56Cc4D54ed064f62efAC264d5',
  '0x2EacD2D7cF5Cba9dA031C0a9C5d7FDeDc056216C',
  '0x8c9886Aca8B6984c10F988078C5e1D91976dFD16',
  '0x63D21dBD5A30940C605d77882D065736e8fffC94',
]

const DONKEY_TOKEN = '0x4576E6825B462b6916D2a41E187626E9090A92c6'
const ETH = "0x0000000000000000000000000000000000000000";

async function staking(timestamp, block) {
  const balances = {}
  const donkeyTokens = await sdk.api.abi.multiCall({
    block,
    calls: stakings.map(address => ({ target: DONKEY_TOKEN, params: address })),
    abi: 'erc20:balanceOf',
  })
  sdk.util.sumMultiBalanceOf(balances, donkeyTokens)
  return balances;
}

function getChainTVL(chain) {
  return async function (timestamp, ethBlock, chainBlocks) {
    const block = chainBlocks[chain]
    const transform = await getChainTransform(chain)
    const balances = {}
    const ethMarkets = (await sdk.api.abi.call({ chain, block, target: controllerAddress[chain], abi: abi.getAllMarkets, })).output
    const promises = []

    for (let i = 0; i < ethMarkets.length; i++) {
      promises.push((async () => {
        const marketAddress = ethMarkets[i];
        if (marketAddress === mainDTokenAddress[chain]) {

          let ethBal = await sdk.api.eth.getBalance({ chain, target: marketAddress, block, });
          let balance, token
          if (chain === 'ethereum') {
            token = ETH
            balance = ethBal.output
          } else {
            token = 'klay-token'
            balance = ethBal.output / 1e18
          }
          sdk.util.sumSingleBalance(balances, token, balance)
          return;
        }

        const underlyingAddress = (await sdk.api.abi.call({ chain, block, target: marketAddress, abi: abi.underlying, })).output;
        let cash = (await sdk.api.abi.call({ chain, block, target: underlyingAddress, params: marketAddress, abi: 'erc20:balanceOf', })).output;
        const token = transform(underlyingAddress)
        if (token === 'ripple')
          cash = +cash / 1e6
        sdk.util.sumSingleBalance(balances, token, cash)
      })())
    }
    await Promise.all(promises)
    return balances
  }
}

module.exports = {
  ethereum: {
    staking,
    tvl: getChainTVL('ethereum'),
  },
  klaytn: {
    tvl: getChainTVL('klaytn')
  },
}

'''
'''--- projects/dopex/abi.json ---
{
  "currentEpoch": {
    "inputs": [],
    "name": "currentEpoch",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalEpochDeposits": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "totalEpochDeposits",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getLpPrice": {
    "inputs": [],
    "name": "getLpPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "vbnbToBnb": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "vbnbAmount",
        "type": "uint256"
      }
    ],
    "name": "vbnbToBnb",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/dopex/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { pool2s } = require("../helper/pool2");
const { default: BigNumber } = require("bignumber.js");

// ETH Addresses
const dpx = "0xeec2be5c91ae7f8a338e1e5f3b5de49d07afdc81";
const rdpx = "0x0ff5a8451a839f5f0bb3562689d9a44089738d11";

const univ2lps = [
  "0xf64af01a14c31164ff7381cf966df6f2b4cb349f",
  "0x0bf46ba06dc1d33c3bd80ff42497ebff13a88900"
];

const stakingRewards = [
  "0x2A52330Be21D311A7a3f40dAcbFEE8978541B74a",
  "0x175029c85B14C326C83c9f83D4A21Ca339F44Cb5"
];

// Arbitrum Addresses
const arbDpx = "0x6c2c06790b3e3e3c38e12ee22f8183b37a13ee55";
const arbRdpx = "0x32eb7902d4134bf98a28b963d26de779af92a212";
const dpxStakingRewards = "0xc6D714170fE766691670f12c2b45C1f34405AAb6";
const rdpxStakingRewards = "0x125Cc7CCE81A809c825C945E5aA874E60ccCB6Bb";
 
const slps = [
  "0x0C1Cf6883efA1B496B01f654E247B9b419873054",
  "0x7418F5A2621E13c05d1EFBd71ec922070794b90a"
];

const slpStakingRewards = [
  "0x96B0d9c85415C69F4b2FAC6ee9e9CE37717335B4",
  "0x03ac1Aa1ff470cf376e6b7cD3A3389Ad6D922A74"
];

const ssovs = [
  ["0xbB741dC1A519995eac67Ec1f2bfEecbe5C02f46e", "0x6C2C06790b3E3E3c38e12Ee22F8183b37a13EE55"],
  ["0x6A1142681b74fbeA5dEA07258f573484D80e4435", "0x32eb7902d4134bf98a28b963d26de779af92a212"],
  ["0x2c9C1E9b4BDf6Bf9CB59C77e0e8C0892cE3A9d5f", "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"],
  ["0x54552CB564F4675bCEda644e47dE3E35D1c88E1b", "0x8D9bA570D6cb60C7e3e0F31343Efe75AB8E65FB1"],
  ["0x5bE3c77ED3Cd42fc2c702C9fcd665f515862B0AE", "0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a"],
];

const crvPools = [
  "0xB73feD58a603Fe6bE5b3403174c9b9598A3272A1",
  "0x9D973C4C04df928F18081e952B407D718D2dAE4E",
  "0xc8067b488A77D84e85AeDBb2dE5d094A5e1c469A",
  "0x4F06645416a38a020CfFaa97cE4DAD04c1Be9906",
  "0x29d5D552bde776abF45C75Fe4fE01A3B59F26798",
  "0x920063B722d4FA90866f2aA3c150d129a10546ff",
  "0xf8Ce3cF6371bDAe43a260445E6dE61575334391c",
  "0x85e1Aa4B34e772153ECB8969d991ceb8F1bC137e"
];

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  const chain = "arbitrum";
  block = chainBlocks.arbitrum;

  const stakingBalances = (await sdk.api.abi.multiCall({
    calls: [
      {
        target: arbDpx,
        params: dpxStakingRewards
      },
      {
        target: arbRdpx,
        params: rdpxStakingRewards
      }
    ],
    abi: "erc20:balanceOf",
    block,
    chain
  })).output;

  stakingBalances.forEach(p => {
    sdk.util.sumSingleBalance(balances, `arbitrum:${p.input.target}`, p.output);
  });

  return balances;
}

async function ssovTvl(balances, ssov, block, chain) {

  const currentEpochs = (await sdk.api.abi.multiCall({
    calls: ssov.map(p => ({
      target: p[0]
    })),
    abi: abi.currentEpoch,
    block,
    chain
  })).output;

  const totalEpochDeposits = (await sdk.api.abi.multiCall({
    calls: currentEpochs.map(p => ({
      target: p.input.target,
      params: p.output
    })),
    abi: abi.totalEpochDeposits,
    block,
    chain
  })).output;

  for (let i = 0; i < ssov.length; i++) {
    const token = `${chain}:${ssov[i][1]}`;
    const balance = totalEpochDeposits[i].output;
    sdk.util.sumSingleBalance(balances, token, balance);
  }
}

async function crvTvls(balances, crvPools, block, chain) {
  
  const currentEpochs = (await sdk.api.abi.multiCall({
    calls: crvPools.map(p => ({
      target: p
    })),
    abi: abi.currentEpoch,
    block,
    chain
  })).output;

  const totalEpochDeposits = (await sdk.api.abi.multiCall({
    calls: currentEpochs.map(p => ({
      target: p.input.target,
      params: p.output
    })),
    abi: abi.totalEpochDeposits,
    block,
    chain
  })).output;

  const lpPrices = (await sdk.api.abi.call({
    target: crvPools[0],
    abi: abi.getLpPrice,
    block,
    chain
  })).output;

  for (let i = 0; i < crvPools.length; i++) {
    const balance = BigNumber(Number(lpPrices) / 1e18).times(Number(totalEpochDeposits[i].output)).div(1e12).toFixed(0);
    sdk.util.sumSingleBalance(balances, "0xdac17f958d2ee523a2206206994597c13d831ec7", balance);
  }
}

async function arbTvl(timestamp, block, chainBlocks) {
  let balances = {};

  await ssovTvl(balances, ssovs, chainBlocks.arbitrum, "arbitrum");
  await crvTvls(balances, crvPools, chainBlocks.arbitrum, "arbitrum");
  return balances;
}

// BSC Addresses
const bscSsovs = [
  ["0x818ced3d446292061913f1f74b2eaee6341a76ec", "0xa07c5b74c9b40447a954e1466938b865b6bbea36"]
];

async function bscTvl(timestamp, block, chainBlocks) {
  let balances = {};

  await ssovTvl(balances, bscSsovs, chainBlocks.bsc, "bsc");

  const bnbAmount = (await sdk.api.abi.call({
    target: "0x818ced3d446292061913f1f74b2eaee6341a76ec",
    params: balances["bsc:0xa07c5b74c9b40447a954e1466938b865b6bbea36"],
    abi: abi.vbnbToBnb,
    block: chainBlocks.bsc,
    chain: "bsc" 
  })).output;

  sdk.util.sumSingleBalance(balances, "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", bnbAmount);
  delete balances["bsc:0xa07c5b74c9b40447a954e1466938b865b6bbea36"];

  return balances;
}

// AVAX Addresses
const avaxSsovs = [
  ["0x5540FEa353dF6302611DA1d57988104e43A4B6b6", "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"]
];

async function avaxTvl(timestamp, block, chainBlocks) {
  let balances = {};

  await ssovTvl(balances, avaxSsovs, chainBlocks.avax, "avax");

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: async () => ({}),
    pool2: pool2s(stakingRewards, univ2lps)
  },
  arbitrum: {
    tvl: arbTvl,
    pool2: pool2s(slpStakingRewards, slps, "arbitrum"),
    staking
  },
  bsc: {
    tvl: bscTvl
  },
  avalanche: {
    tvl: avaxTvl
  }
}
'''
'''--- projects/dopplefinance/index.js ---
const { sumTokens2 } = require('../helper/unwrapLPs')

const assetsOnExchange = {
  bsc: [
    // * KUSD
    '0x940Ff63e82d15fb47371BFE5a4ed7D7D183dE1A5',
    // * BUSD
    "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
    // * USDT
    "0x55d398326f99059fF775485246999027B3197955",
    // * USDC
    "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",
    // * DAI
    "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3",
    // * UST
    "0x23396cF899Ca06c4472205fC903bDB4de249D6fC",
    // * BTCB
    "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c",
    // * renBTC
    '0xfCe146bF3146100cfe5dB4129cf6C82b0eF4Ad8c',
    // * USDN
    '0x03ab98f5dc94996F8C33E15cD4468794d12d41f9',
    // * TUSD
    '0x14016E85a25aeb13065688cAFB43044C2ef86784',
    // * DOLLY
    "0xfF54da7CAF3BC3D34664891fC8f3c9B6DeA6c7A5"
  ],
  fantom: [
    // * USDC
    '0x04068da6c83afcfa0e13ba15a6696662335d5b75',
    // * fUSDT
    '0x049d68029688eabf473097a2fc38ef61633a3c7a',
    // * DAI
    '0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e',
    // * MIM
    '0x82f0b8b456c1a451378467398982d4834b6829c1',
  ],
  harmony: [
    // * KUSD
    '0x60d717d69f964f4b67de9786e1796a4cf0d89940',
    // * 1USDC
    '0x985458e523db3d53125813ed68c274899e9dfab4',
    // * 1USDT
    '0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f',
    // * 1BUSD,
    '0xe176ebe47d621b984a73036b9da5d834411ef734',
    // * bscUSDC
    '0x44cED87b9F1492Bf2DCf5c16004832569f7f6cBa',
    // * bscUSDT
    '0x9A89d0e1b051640C6704Dde4dF881f73ADFEf39a',
    // * bscBUSD
    '0x0aB43550A6915F9f67d0c454C2E90385E6497EaA',
  ]
}

async function bscTVL(_, _b, { bsc: block }) {
  const chain = 'bsc'
  const pools = [
    '0x5162f992EDF7101637446ecCcD5943A9dcC63A8A',
    '0x449256e20ac3ed7f9ae81c2583068f7508d15c02',
    '0x61f864a7dfe66cc818a4fd0baabe845323d70454',
    '0x215b3616730020a7f3e075526588d0cdaa057dca',
    '0x36e04b29169313d93a056289109ba8a8291e69ab',
    '0xbc42fadcc37994c65a559fb7803ed60d90994e9f',
    '0xf8af8659a2af27d65bb3e705f0e97b321886031d',
    '0x830e287ac5947b1c0da865dfb3afd7cdf7900464',
  ]
  const toa = [
    ['0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', '0xa275769Fb6fF34A1a01C8CE61D0182f5d36AD27A',], // USDC collateral for minting KUSD
  ]
  assetsOnExchange.bsc.forEach(t => pools.forEach(o => toa.push([t, o])))
  return sumTokens2({ tokensAndOwners: toa, chain, block, })
}

async function fantom(_, _b, { fantom: block }) {
  const chain = 'fantom'
  const pools = [
    '0x5162f992EDF7101637446ecCcD5943A9dcC63A8A',
  ]
  const toa = []
  assetsOnExchange.fantom.forEach(t => pools.forEach(o => toa.push([t, o])))
  return sumTokens2({ tokensAndOwners: toa, chain, block, })
}

async function harmony(_, _b, { fantom: block }) {
  const chain = 'harmony'
  const pools = [
    '0xccb7c3166729fe92c914fb38b850696748d83db8',
    '0x44a783b046f012287a233e4e51949f47a2279dee',
  ]
  const toa = []
  assetsOnExchange.harmony.forEach(t => pools.forEach(o => toa.push([t, o])))
  return sumTokens2({ tokensAndOwners: toa, chain, block, })
}

module.exports = {
  bsc: {
    tvl: bscTVL,
  },
  fantom: {
    tvl: fantom,
  },
  harmony: {
    tvl: harmony,
  },
}

'''
'''--- projects/dotdot/index.js ---
const utils = require('../helper/utils');
const {toUSDTBalances} = require('../helper/balances');
const sdk = require('@defillama/sdk')

async function tvl() {
  var totalTvl = await utils.fetchURL('https://api.dotdot.finance/api/tvl')
  return toUSDTBalances(totalTvl.data.data.dddLpTvl);
}

async function staking() {
  var stakedTvl = await utils.fetchURL('https://api.dotdot.finance/api/tvl')
  return toUSDTBalances(stakedTvl.data.data.dddSupplyLockedUSD);
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  bsc:{
    tvl,
    staking
  }
}

'''
'''--- projects/double/abis.json ---
{
    "locked": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "locked",
        "outputs": [
            {
                "internalType": "int128",
                "name": "amount",
                "type": "int128"
            },
            {
                "internalType": "uint256",
                "name": "end",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalBalances": {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "totalBalances",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "allPairsLength": {
        "inputs": [],
        "name": "allPairsLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "allPairs": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allPairs",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/double/index.js ---
const sdk = require("@defillama/sdk");
const { transformBscAddress } = require('../helper/portedTokens');
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');
const abis = require("./abis.json");

const DDDX = '0x4B6ee8188d6Df169E1071a7c96929640D61f144f';
const excludedTokens = [
    '0x15330196e88a09637bd2a8d206c7c85fe99594d0',
    '0x4b6ee8188d6df169e1071a7c96929640d61f144f',
];

async function staking(timestamp, block, chainBlocks) {
    return {
        [`bsc:${DDDX}`]: (await sdk.api.abi.call({
            target: '0xFe9e21e78089094E1443169c4c74bBBBcBb13DE0', //ve
            abi: abis.locked,
            params: [8],
            block: chainBlocks.bsc,
            chain: 'bsc'
        })).output.amount
    };
};

function tvl(pool2 = false) {
    return async (timestamp, block, chainBlocks) => {
        const balances = {};
        const transform = await transformBscAddress();

        const noPairs = (await sdk.api.abi.call({
            target: '0xb5737A06c330c22056C77a4205D16fFD1436c81b', // BaseV1Factory
            abi: abis.allPairsLength,
            block: chainBlocks.bsc,
            chain: 'bsc'
        })).output;

        const pairAddresses = (await sdk.api.abi.multiCall({
            target: '0xb5737A06c330c22056C77a4205D16fFD1436c81b',  // BaseV1Factory
            calls: Array.from({ length: Number(noPairs) }, (_, k) => ({
                params: k,
            })),
            abi: abis.allPairs,
            block: chainBlocks.bsc,
            chain: 'bsc'
        })).output;

        let pairBalances = (await sdk.api.abi.multiCall({
            target: '0x89BEda6E5331CdDEe6c9a5Ad1B789ce6dFEBe6c7', // LpDepositor
            calls: pairAddresses.map(a => ({
                params: a.output
            })),
            abi: abis.totalBalances,
            block: chainBlocks.bsc,
            chain: 'bsc'
        })).output;

        const [token0s, token1s] = await Promise.all([
            sdk.api.abi.multiCall({
                calls: pairAddresses.map(a => ({
                    target: a.output
                })),
                abi: abis.token0,
                block: chainBlocks.bsc,
                chain: "bsc"
            }),
            sdk.api.abi.multiCall({
                calls: pairAddresses.map(a => ({
                    target: a.output
                })),
                abi: abis.token0,
                block: chainBlocks.bsc,
                chain: "bsc"
            })
        ]);

        let lpPositions = [];
        let pool2Positions = [];
        for (let i = 0; i < pairBalances.length; i++) {
            if (
                pairAddresses[i].output &&
                excludedTokens.includes(pairAddresses[i].output.toLowerCase())
            ) {
                continue;
            };
            if (excludedTokens.includes(token0s.output[i].output.toLowerCase()) ||
                excludedTokens.includes(token1s.output[i].output.toLowerCase())) {
                pool2Positions.push({
                    balance: pairBalances[i].output,
                    token: pairAddresses[i].output
                });
            } else {
                lpPositions.push({
                    balance: pairBalances[i].output,
                    token: pairAddresses[i].output
                });
            };
        };

        await unwrapUniswapLPs(
            balances,
            pool2 ? pool2Positions : lpPositions,
            chainBlocks.bsc,
            'bsc',
            transform
        );

        return balances;
    };
};

module.exports = {
    doublecounted: true,
    bsc: {
        tvl: tvl(),
        pool2: tvl(true),
        staking
    }
};

'''
'''--- projects/drachma/contracts.json ---
{
    "usdc": {
      "metis": "0xEA32A96608495e54156Ae48931A7c20f0dcc1a21"
    },
    "metis": [
      {
        "address": "0xF3f03c110e01dE844fE8a608063bDC9b6c6cdC9f",
        "token": "0xbB06DCA3AE6887fAbF931640f67cab3e3a16F4dC",
        "currency": "m.USDT"
      }
    ]
  }
'''
'''--- projects/drachma/index.js ---
const sdk = require("@defillama/sdk");
const { transformMetisAddress } = require("../helper/portedTokens");
const contracts = require('./contracts.json');

const { compoundExports } = require("../helper/compound");
const comptroller = "0xB6ef08Ffbbb0691a3D9E6c41db4b1d2F97D8D49a";

//tvl for drachma farm
const { tvl: drachmaTvl, borrowed: drachmaBorrowed } = compoundExports(
  comptroller,
  "metis"
);

//tvl for drachma app
function tvl(chain) {
  return async (timestamp, block, chainBlocks) => {
    const transform = await transformMetisAddress()
    const balances = {};

    const [tokenBalances, usdcBalances] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: contracts[chain].map((c) => ({
          target: c.token,
          params: [c.address],
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain,
      }),

      sdk.api.abi.multiCall({
        calls: contracts[chain].map((c) => ({
          target: contracts.usdc[chain],
          params: [c.address],
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain,
      }),
    ]);

    await Promise.all([
      sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transform),
      sdk.util.sumMultiBalanceOf(balances, usdcBalances, true, transform),
    ]);

    return balances;
  };
};

module.exports = {
  timetravel: true,
  incentivized: true,
  misrepresentedTokens: true,
  metis: {
    tvl: sdk.util.sumChainTvls([drachmaTvl, tvl("metis")]),
    borrowed: drachmaBorrowed,
  },
};

'''
'''--- projects/draco-finance/index.js ---
const { tombTvl } = require("../helper/tomb");

const draco = "0x37863ea4bf6ef836bC8bE909221BAF09A2aF43d7";
const sdraco = "0x713A18d059EA1D12E5bE134a864C075E47d5FEFA";
const rewardpool = "0x14b9189c9a7f31Fda0eed6B8D8afe91E098B303b";
const masonry = "0x39AEd2eC961AA9da9D778C80B6f90CD80dBFAE16";
const lps = [
    "0xa7207b4de8ba1f01adb7c59558ebebf8c4e48c53",
    "0xf4b787e9319ec4a83ac4fabc88ae1705c2c64031"
]

module.exports = {
    ...tombTvl(draco, sdraco, rewardpool, masonry, lps, "fantom", undefined, false, lps[1])
}
'''
'''--- projects/draco-story/index.js ---
const { masterChefExports, } = require("../helper/masterchef")

const token = "0x01d3569eedd1dd32a698cab22386d0f110d6b548";
const masterchef = "0xAedCc6E2710d2E47b1477A890C6D18f7943C0794";

module.exports = {
    ...masterChefExports(masterchef, "fantom", token, false)
}

'''
'''--- projects/dracoforce/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0x3D45191668dC53FFD60ea86F664716F4b320c372"
const draco = "0x8d05B42749428C26613deB12f8989Cb8D1f5c17f"
const dracoFtmLP = "0xe6d47e140385bbdb3aac60b87b5f51e0d6340871"
const dracoUsdcLP = "0x8562e3032753edf3edf5f4d11bc079b43c9b224c";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [draco, dracoFtmLP, dracoUsdcLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, draco, "fantom"),
      pool2: pool2Exports(chef, [dracoFtmLP, dracoUsdcLP], "fantom"),
  },
  
} 
'''
'''--- projects/dracula.js ---
const utils = require("./helper/utils");

/* * * * * * * *
 * ==> Correct adapter needs to be created.
 *
 *****************/
async function fetch() {
  var tvl = 0;
  var staked = await utils.fetchURL("https://dracula.sucks/api-v2.1/stats");
  staked.data.victimPools.map((pool) => {
    tvl += pool.tvl;
  });
  return tvl;
}

async function staking() {
  var tvl = 0;
  var staked = await utils.fetchURL("https://dracula.sucks/api-v2.1/stats");
  staked.data.stakingPools.map((pool) => {
    tvl += pool.tvl;
  });
  return tvl;
}

module.exports = {
  fetch,
  staking: {
    fetch: staking,
  },
};

'''
'''--- projects/drift.js ---
const {getTokenAccountBalance} = require('./helper/solana')

async function tvl(){
    const usdcLocked = await getTokenAccountBalance("6W9yiHDCW9EpropkFV8R3rPiL8LVWUHSiys3YeW6AT6S")
    const liqInsurance = await getTokenAccountBalance("Bzjkrm1bFwVXUaV9HTnwxFrPtNso7dnwPQamhqSxtuhZ")
    const totalTvl = liqInsurance + usdcLocked
    return {
        "usd-coin": totalTvl
    }
}

module.exports={
    timetravel: false,
    methodology: "Calculate the USDC on 6W9yiHDCW9EpropkFV8R3rPiL8LVWUHSiys3YeW6AT6S through on-chain calls & add the USDC on Bzjkrm1bFwVXUaV9HTnwxFrPtNso7dnwPQamhqSxtuhZ which is the insurance fund for liquidations",
    solana:{
        tvl
    }
}

'''
'''--- projects/drip/index.js ---
const { staking } = require("../helper/staking");

const TOKEN_CONTRACT = "0x20f663CEa80FaCE82ACDFA3aAE6862d246cE0333";
const VAULT_CONTRACT = "0xBFF8a1F9B5165B787a00659216D7313354D25472";

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology:
    "Counts the native tokens staked in the vault contract as staking.",
  bsc: {
    tvl: async () => ({}),
    staking: staking(VAULT_CONTRACT, TOKEN_CONTRACT, "bsc"),
  },
};

'''
'''--- projects/drops/index.js ---
const { usdCompoundExports } = require("../helper/compound")
const { mergeExports, } = require("../helper/utils")
const { staking, } = require("../helper/staking")
const { pool2, } = require("../helper/pool2")

const tokensAddress = {
  masterchef: "0x8A78011bf2c42df82cC05F198109Ea024B554df9",
  drop: '0x6bB61215298F296C55b19Ad842D3Df69021DA2ef',
  ndr: '0x739763a258640919981F9bA610AE65492455bE53',
  lp: '0x00aa1c57e894c4010fe44cb840ae56432d7ea1d1',
};

module.exports = mergeExports([{
  ethereum: {
    staking: staking(tokensAddress.masterchef, tokensAddress.drop),
    pool2: pool2(tokensAddress.masterchef, tokensAddress.lp),
  }
}, {
  ethereum: {
    staking: staking(tokensAddress.masterchef, tokensAddress.ndr),
  }
},
{
  ethereum: usdCompoundExports("0x7312a3bc8733b068989ef44bac6344f07cfcde7f", undefined, '0x05231980914B702083B9Ac08002325654F6eb95B'),
},
{
  ethereum: usdCompoundExports("0x79b56CB219901DBF42bB5951a0eDF27465F96206", undefined, '0x4aE7413182849D062B72518928a4b2DE87F0e411'),
},
{
  ethereum: usdCompoundExports("0xB70FB69a522ed8D4613C4C720F91F93a836EE2f5", undefined, '0xD72929e284E8bc2f7458A6302bE961B91bccB339'),
},
])

'''
'''--- projects/dual/idl.json ---
{
  "version": "0.1.0",
  "name": "dual_market",
  "instructions": [
    {
      "name": "initializeMints",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "vaultMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "optionMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "premiumUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "priceAndExpiration",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultMintBump",
          "type": "u8"
        },
        {
          "name": "optionMintBump",
          "type": "u8"
        },
        {
          "name": "vaultSplBump",
          "type": "u8"
        },
        {
          "name": "vaultUsdcBump",
          "type": "u8"
        },
        {
          "name": "premiumBump",
          "type": "u8"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "initializeMintsAndVaultSplTokenAccount",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "vaultMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "optionMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "premiumUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "mmOptionTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "mmPk",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "priceAndExpiration",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultMintBump",
          "type": "u8"
        },
        {
          "name": "optionMintBump",
          "type": "u8"
        },
        {
          "name": "vaultSplBump",
          "type": "u8"
        },
        {
          "name": "vaultUsdcBump",
          "type": "u8"
        },
        {
          "name": "premiumBump",
          "type": "u8"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "deposit",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "userSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userVaultTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultMintSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "premiumUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "premiumUsdcSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "optionTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "optionMintSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "mmOptionTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pythPrice",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultMintBump",
          "type": "u8"
        },
        {
          "name": "premiumUsdcBump",
          "type": "u8"
        },
        {
          "name": "optionMintBump",
          "type": "u8"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "initForDepositWithLso",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "vaultTokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "userVaultTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "userUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lsoMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "recipientLsoAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "depositWithLso",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "userSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userVaultTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultMintSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "premiumUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "premiumUsdcSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "optionTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "optionMintSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "mmOptionTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pythPrice",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "stakingOptionsProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "lsoMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "recipientLsoAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lsoMintSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "activeLsoMints",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultMintBump",
          "type": "u8"
        },
        {
          "name": "premiumUsdcBump",
          "type": "u8"
        },
        {
          "name": "optionMintBump",
          "type": "u8"
        },
        {
          "name": "lsoMintBump",
          "type": "u8"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdraw",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "userSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userVaultTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultTokenMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccountSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultUsdcSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "usdcMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultSplBump",
          "type": "u8"
        },
        {
          "name": "vaultUsdcBump",
          "type": "u8"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "exerciseOption",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "vaultUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "mmUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "mmOptionTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "optionMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "mmSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultSplTokenAccountSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "splMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "vaultSplBump",
          "type": "u8"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "strikePrice",
          "type": "u64"
        },
        {
          "name": "expiration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "depositPremiums",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "premiumUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userUsdcTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "closePricingAndExpiration",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "priceAndExpiration",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "PriceAndExpiration",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "strikePrice",
            "type": "u64"
          },
          {
            "name": "expiration",
            "type": "u64"
          },
          {
            "name": "splMint",
            "type": "publicKey"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "ErrorCode",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "TokensStillLocked"
          },
          {
            "name": "DepositExpirationInPast"
          },
          {
            "name": "ExerciseAfterExpiration"
          },
          {
            "name": "UnauthorizedInitMints"
          },
          {
            "name": "IncorrectAddressForOption"
          },
          {
            "name": "WrongLSOMint"
          }
        ]
      }
    }
  ],
  "metadata": {
    "address": "EFhLFkx6r2NdhFmAraZacRzxX8SFLbM9KuyVpaUUpR5k"
  }
}
'''
'''--- projects/dual/index.js ---
const {
  PublicKey,
} = require("@solana/web3.js");
const { Program, web3, utils } = require("@project-serum/anchor");
const DualIdl = require("./idl.json");
const axios = require("axios");
const { MintLayout } = require("@solana/spl-token")
const { toUSDTBalances } = require("../helper/balances");
const { getConnection, getProvider, } = require("../helper/solana");

async function getPriceWithTokenAddress(mintAddress) {
  const { data } = await axios.post("https://coins.llama.fi/prices", {
    coins: mintAddress.map((a) => `solana:${a}`),
  });
  return data.coins;
}

function toBytes(x) {
  let y = Math.floor(x / 2 ** 32);
  return Uint8Array.from(
    [y, y << 8, y << 16, y << 24, x, x << 8, x << 16, x << 24].map(
      (z) => z >>> 24
    )
  );
}

async function tvl() {
  const connection =  getConnection();
  const anchorProvider = getProvider();
  const dualProgramID = new PublicKey(
    "DiPbvUUJkDhV9jFtQsDFnMEMRJyjW5iS6NMwoySiW8ki"
  );
  const VAULT_MINT_ADDRESS_SEED = "vault-mint";
  const program = new Program(DualIdl, dualProgramID, anchorProvider);

  const prices = await getPriceWithTokenAddress([
    "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E", // BTC
    "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs", // ETH
    "So11111111111111111111111111111111111111112", // SOL
  ]);

  let programAccounts = await program.account.priceAndExpiration.all();

  let mints = [];
  let mintToSplToken = {};
  for (const account of programAccounts) {
    // Expired vaults do not count for tvl
    if (account.account.expiration * 1000 < Date.now()) {
      continue;
    }

    const [vaultTokenMint, _vaultMintBump] =
      await web3.PublicKey.findProgramAddress(
        [
          Buffer.from(utils.bytes.utf8.encode(VAULT_MINT_ADDRESS_SEED)),
          toBytes(Number(account.account.strikePrice)),
          toBytes(Number(account.account.expiration)),
          account.account.splMint.toBuffer(),
        ],
        dualProgramID
      );
    mintToSplToken[vaultTokenMint] = account.account.splMint;
    mints.push(vaultTokenMint);
  }

  let tvl = 0.0;

  // Each vault token is redeemable for one locked token of that type.
  const mintInfos = await getMultipleMintInfo(connection, mints);
  for (const mintInfo of mintInfos) {
    const key = mintInfo.key;
    const supply = mintInfo.data.supply;
    const tokenName = mintToSplToken[key];
    const vaultTvl =
      (Number(supply) / 10 ** 6) *
      prices[`solana:${tokenName.toBase58()}`].price;
    if (vaultTvl) {
      tvl += vaultTvl;
    }
  }

  return toUSDTBalances(tvl);
}

const getMultipleMintInfo = async (connection, pubKeys) => {
  const info = await connection.getMultipleAccountsInfo(pubKeys);
  if (info === null) {
    throw new Error("Failed to find mint account");
  }

  return info.map((v) => {
    if (v != null) {
      const data = Buffer.from(v.data);
      return {
        key: pubKeys[info.indexOf(v)].toBase58(),
        data: deserializeMint(data),
      };
    }
    return null;
  });
};

const deserializeMint = (data) => {
  if (data.length !== MintLayout.span) {
    throw new Error("Not a valid Mint");
  }

  const mintInfo = MintLayout.decode(data);

  if (mintInfo.mintAuthorityOption === 0) {
    mintInfo.mintAuthority = null;
  } else {
    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
  }

  mintInfo.isInitialized = mintInfo.isInitialized !== 0;

  if (mintInfo.freezeAuthorityOption === 0) {
    mintInfo.freezeAuthority = null;
  } else {
    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
  }

  return mintInfo;
};

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  solana: {
    tvl,
  },
};

'''
'''--- projects/duckydefi/index.js ---
const {uniTvlExport} = require("../helper/calculateUniTvl")

const degg = "0xFD71FC52D34eD1Cfc8363e5528285B12b6b942c2";
const duckyFactory = "0x796E38Bb00f39a3D39ab75297D8d6202505f52e2";

module.exports = {
    cronos: {
        tvl: uniTvlExport(duckyFactory, "cronos")
    }
}

'''
'''--- projects/duet/abis/collateral-reader.json ---
{
  "depositVaultValues": {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "_vaults",
        "type": "address[]"
      },
      {
        "internalType": "bool",
        "name": "_dp",
        "type": "bool"
      }
    ],
    "name": "depositVaultValues",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "amounts",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/duet/index.js ---
const axios = require("axios");
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");
const collateralReaderContractABI = require("./abis/collateral-reader.json");

const COLLATERAL_READER_CONTRACT = "0xFfB8FD0E5eA13bb71401B19e00f9F934746f0b7A";
const TOKEN_LIST_URL = "https://app.duet.finance/tokens-v0.json";

async function fetch() {
  const ret = await axios.get(TOKEN_LIST_URL);
  const tokens = ret.data;
  const vaultList = [];
  for (const token of tokens) {
    if (!token.vaults || token.vaults.length < 1) {
      continue;
    }
    vaultList.push(...token.vaults);
  }
  const uniqueVaults = new Set(vaultList.filter(vault => vault.displayPosition !== "DASSETS").map(vault => vault.vaultAddress && vault.vaultAddress.trim()).filter(Boolean));
  const { 1: tokenTVLs } = (await sdk.api.abi.call({
    abi: collateralReaderContractABI.depositVaultValues,
    chain: "bsc",
    target: COLLATERAL_READER_CONTRACT,
    params: [[...uniqueVaults], false]
  })).output;

  return tokenTVLs.reduce((previous, current) => previous.plus(current), new BigNumber(0)).div(Math.pow(10, 8));
}

module.exports = {
  methodology: "TVL is the sum of the USD value of all tokens in the staking pool",
  fetch
};

'''
'''--- projects/duneswap.js ---
const { calculateUsdUniTvl } = require('./helper/getUsdUniTvl');
module.exports = {
    oasis: {
        tvl: calculateUsdUniTvl(
            '0x9dd422B52618f4eDD13E08c840f2b6835F3C0585',
            'oasis',
            '0x5C78A65AD6D0eC6618788b6E8e211F31729111Ca',
            [
                '0xaC5487bFE2502eCc06e057912b6F4946471093b9',
            ],
            'oasis-network'
        )
    }
}
'''
'''--- projects/dungeonswap/index.js ---
const sdk = require("@defillama/sdk");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformBscAddress } = require("../helper/portedTokens");

const MasterChefContract = "0x3720F1F9a02BFB4dD6afb9030eB826B4392D321F";

const bscTvl = async (chainBlocks) => {
  const balances = {};

  let transformAddress = await transformBscAddress();

  await addFundsInMasterChef(
    balances,
    MasterChefContract,
    chainBlocks["bsc"],
    "bsc",
    transformAddress,
  );

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: bscTvl,
  },
  methodology:
    "We count liquidity on the Farms and Pools seccions through MasterChef Contract",
};

'''
'''--- projects/dxsale/abis.js ---
const getStorageLPLockDataV33 ={
  "inputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "name": "AllLockRecord",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "createdOn",
      "type": "uint256"
    },
    {
      "internalType": "address",
      "name": "lockOwner",
      "type": "address"
    },
    {
      "internalType": "address",
      "name": "lockedLPTokens",
      "type": "address"
    },
    {
      "internalType": "uint256",
      "name": "lockTime",
      "type": "uint256"
    },
    {
      "internalType": "address",
      "name": "lpLockContract",
      "type": "address"
    },
    {
      "internalType": "bool",
      "name": "locked",
      "type": "bool"
    },
    {
      "internalType": "string",
      "name": "logo",
      "type": "string"
    },
    {
      "internalType": "uint256",
      "name": "lockedAmount",
      "type": "uint256"
    },
    {
      "internalType": "uint256",
      "name": "countID",
      "type": "uint256"
    },
    {
      "internalType": "bool",
      "name": "exists",
      "type": "bool"
    },
    {
      "internalType": "address",
      "name": "token0Addr",
      "type": "address"
    },
    {
      "internalType": "address",
      "name": "token1Addr",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

const getStorageLockCountV33 = {
  inputs: [],
  name: "lockerIDCount",
  outputs: [
    {
      internalType: "uint256",
      name: "",
      type: "uint256",
    },
  ],
  stateMutability: "view",
  type: "function",
};

const getLockCountPerContractV3 = {
  inputs: [],
  name: "lockerNumberOpen",
  outputs: [
    {
      internalType: "uint256",
      name: "",
      type: "uint256",
    },
  ],
  stateMutability: "view",
  type: "function",
};

const getLockerWalletWithIdV3 = {
  inputs: [
    {
      internalType: "uint256",
      name: "",
      type: "uint256",
    },
  ],
  name: "LockerRecord",
  outputs: [
    {
      internalType: "address",
      name: "",
      type: "address",
    },
  ],
  stateMutability: "view",
  type: "function",
};

const getLockerLPDataV3 = {
  inputs: [
    {
      internalType: "address",
      name: "",
      type: "address",
    },
    {
      internalType: "uint256",
      name: "",
      type: "uint256",
    },
  ],
  name: "DXLOCKERLP",
  outputs: [
    {
      internalType: "bool",
      name: "exists",
      type: "bool",
    },
    {
      internalType: "bool",
      name: "locked",
      type: "bool",
    },
    {
      internalType: "string",
      name: "logo",
      type: "string",
    },
    {
      internalType: "uint256",
      name: "lockedAmount",
      type: "uint256",
    },
    {
      internalType: "uint256",
      name: "lockedTime",
      type: "uint256",
    },
    {
      internalType: "uint256",
      name: "startTime",
      type: "uint256",
    },
    {
      internalType: "address",
      name: "lpAddress",
      type: "address",
    },
  ],
  stateMutability: "view",
  type: "function",
};

const getLockerPerWalletV3 = {
  inputs: [
    {
      internalType: "address",
      name: "",
      type: "address",
    },
  ],
  name: "UserLockerCount",
  outputs: [
    {
      internalType: "uint256",
      name: "",
      type: "uint256",
    },
  ],
  stateMutability: "view",
  type: "function",
};

module.exports = {
  getStorageLPLockDataV33,
  getLockCountPerContractV3,
  getLockerPerWalletV3,
  getLockerWalletWithIdV3,
  getLockerLPDataV3,
  getStorageLockCountV33,
};

'''
'''--- projects/dxsale/api.js ---
const { getExports } = require('../helper/heroku-api')
const indexExports = require('./index')
const chainKeys = Object.keys(indexExports).filter(chain => typeof indexExports[chain] === 'object' && indexExports[chain].tvl)

module.exports = {
  timetravel: false,
  ...getExports("dxsale", chainKeys),
}

'''
'''--- projects/dxsale/config.js ---
const LockersV3 = {
  empty: ['0xEb3a9C56d963b971d320f889bE2fb8B59853e449'],
  bsc: [
    "0xEb3a9C56d963b971d320f889bE2fb8B59853e449",
    "0x8655E5c4D701186D16765d1CDcef6D5287E4679a",
    "0x5b5e94485c9628793B01A38762921Dc37B6829b6",
    // "0x2D045410f002A95EFcEE67759A92518fA3FcE677",
    // "0x81E0eF68e103Ee65002d3Cf766240eD1c070334d",
  ],
  ethereum: [
    "0x1Ba00C14F9E8D1113028a14507F1394Dc9310fbD",
    "0xe74083baFE69cd74519C6a40a3Ad0723BD360BDD",
    "0xc68C522682614A9F1D336f756c0C0D71352925D3",
    // "0x916a8C33B784f6399Ce8b7aff59d4AAD29386B8E",
    // "0xBae21D4247dd3818f720ab4210C095E84e980D96",
  ],
  arbitrum: [
    "0x51f411d40641475576622c8fba77F1e917e96Df4",
    // "0xdf17aC098Fa81373625e102061844C02ECCEc645",
  ],
  celo: [
    "0xC7065e692D2caCF7173C7BC08c6849eb9Ef48b38",
    // "0xdf17aC098Fa81373625e102061844C02ECCEc645",
  ],
  kucoin: [
    // "0x3052b62d39624f341D44b195D2E4b865f074B656",
    "0xd5071536d1A2AfF6dB130917B4c1FA7b8Daf47ff",
    "0x1C8aB27b538b5e43c151460cBc6D271cB9EeE4aF",
    "0x020B4f43BD0fb82cFe9427F81E0E5FCCE433f3f5",
  ],
  harmony: [
    "0xd5F1593D585cbAC2d5bCae2dbae4fc159375C6dD",
    "0xB3C0Bc5D284c9f01a0d4c4eab8546D4D124612cD",
    "0x4B170Bb56032Ca068fF0Ee03943a9B9bc1554C9A",
    // "0xadC5caC1E3CD46Fe8d5b98DB4Ea6eE241a19dCEE",
    // "0x13455DeE5199691f11ffBb4AAf59Af56F23b95aE",
  ],
  avax: [
    "0x69275e94cC431e380EebCbda6FB8e19f931cD359",
    "0x77D054b8e61A141CE51fc9Cc3E9E2C3B79F57809",
    // "0xadC5caC1E3CD46Fe8d5b98DB4Ea6eE241a19dCEE",
    // "0x10f485B855bE8E7D377fbE60E5D5676d88817b95",
  ],
  xdai: [
    // "0x77D054b8e61A141CE51fc9Cc3E9E2C3B79F57809",
    "0x832CcF861059Cb352515E89Cc54F1b13C6620D37",
    "0xeA8d06F70E1a5BD1Bf6cE927e62C8E370f5aAfC1",
    // "0x63d20Bf9Aa36b8bE580b19B024dD8b62a9f11F3b",
    // "0x554d523a54471F12dDE2152A7F33E159404d199e",
  ],
  fantom: [
    "0x318Aa10323Bb8DDD163AdB61F0C54Cfa85b4132e",
    "0xc1E3f48e23D899A326C31df6A2850457F50710F8",
    "0x832CcF861059Cb352515E89Cc54F1b13C6620D37",
    // "0x1C8aB27b538b5e43c151460cBc6D271cB9EeE4aF",
    // "0xb5566a206a89bd9C004230e6F6ac7335C77043cd",
  ],
  polygon: [
    "0xEb3a9C56d963b971d320f889bE2fb8B59853e449",
    "0x6FCC2e4Efb4E05DdfC2154AbE209356d5A687666",
    "0x036063706396Ad5Dc49241451E955fbE05899cDe",
    // "0x2D045410f002A95EFcEE67759A92518fA3FcE677",
    // "0xb5566a206a89bd9C004230e6F6ac7335C77043cd",
  ],
};

const LockerV33 = {
  bsc: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  ethereum: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  arbitrum: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  celo: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  kucoin: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  harmony: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  avax: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  xdai: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  fantom: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  polygon: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  okexchain: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  cronos: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },

  moonriver: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: [
      // "0xFEE2A3f4329e9A1828F46927bD424DB2C1624985",
    ],
  },

  heco: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },
  smartbch: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0xFEE2A3f4329e9A1828F46927bD424DB2C1624985"],
  },
  milkomeda: {
    tokenStorage: ["0x983b00a2C3d8925cEDfC9f3eb5Df1aE121Ff6B9F"],
    lpStorage: ["0x6E573D464416a81A9F82207F1dFD6a42e4b21066"],
  },
};

const protocolPairs = {
  sale_BNB: "0x61cA6ae520b9c9Cfab0B66aFaD78FF7127bA37B6",
  sale_ETH: "0xAAe5f80BaC0c7fA0cAd6c2481771a3B17aF21455",
  sale_HT: "0x4A677fF39B731861AfBA6051b95755B6704FB5eA",
  sale_MATIC_sushi: "0x5a2bA689663fD35eC111676294055bd9FA47fdE8",
  sale_MATIC_quick: "0xf2f46CFC363ff5554801Eb38944148cF3D40d82F",
};

const tokens = {
  sale_BSC: "0x04F73A09e2eb410205BE256054794fB452f0D245",
  sale_ETH: "0xf063fe1ab7a291c5d06a86e14730b00bf24cb589",
  sale_Heco: "0x2665375a48A76BB49F6b375844eB88390840C0B8",
  sale_MATIC: "0x8f6196901a4a153d8ee8f3fa779a042f6092d908",
};

const bscArchives = {
  chain: "bsc",
  locks: LockersV3.bsc,
  storageTokenLocks: LockerV33.bsc.tokenStorage,
  storageLiquidityLocks: LockerV33.bsc.lpStorage,
  coreAssets: [
    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // wbnb
    '0xe9e7cea3dedca5984780bafc599bd69add087d56', // busd
    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC
    '0x55d398326f99059ff775485246999027b3197955', // USDT
    '0x2170ed0880ac9a755fd29b2688956bd959f933f8', // ETH
  ],
};

const ethereumArchives = {
  chain: "ethereum",
  locks: LockersV3.ethereum,
  storageTokenLocks: LockerV33.ethereum.tokenStorage,
  storageLiquidityLocks: LockerV33.ethereum.lpStorage,
  coreAssets: [
    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
  ]
};

const polygonArchives = {
  chain: "polygon",
  locks: LockersV3.polygon,
  storageTokenLocks: LockerV33.polygon.tokenStorage,
  storageLiquidityLocks: LockerV33.polygon.lpStorage,
  coreAssets: [
    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // WMATIC
    '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC
    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
    '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063', // DAI
  ],
};

const arbitrumArchives = {
  chain: "arbitrum",
  locks: LockersV3.arbitrum,
  storageTokenLocks: LockerV33.arbitrum.tokenStorage,
  storageLiquidityLocks: LockerV33.arbitrum.lpStorage,
  coreAssets: [
    '0x82af49447d8a07e3bd95bd0d56f35241523fbab1', // ETH
    "0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f", // wbtc
    "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8", // usdc
    "0xf97f4df75117a78c1a5a0dbb814af92458539fb4", // link
    "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9", // usdt
  ]
};

const celoArchives = {
  chain: "celo",
  locks: LockersV3.celo,
  storageTokenLocks: LockerV33.celo.tokenStorage,
  storageLiquidityLocks: LockerV33.celo.lpStorage,
  coreAssets: [
    '0x471EcE3750Da237f93B8E339c536989b8978a438', // celo
  ]
};

const kucoinArchives = {
  chain: "kcc",
  locks: LockersV3.kucoin,
  storageTokenLocks: LockerV33.kucoin.tokenStorage,
  storageLiquidityLocks: LockerV33.kucoin.lpStorage,
  coreAssets: [
    '0x4446fc4eb47f2f6586f9faab68b3498f86c07521', // wkcs
  ]
};

const harmonyArchives = {
  chain: "harmony",
  locks: LockersV3.harmony,
  storageTokenLocks: LockerV33.harmony.tokenStorage,
  storageLiquidityLocks: LockerV33.harmony.lpStorage,
  coreAssets: [
    '0x6983D1E6DEf3690C4d616b13597A09e6193EA013', // WETH
    '0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a', // WHARMONY
    '0x985458e523db3d53125813ed68c274899e9dfab4', // USDC
    '0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f', // USDT
    '0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1', // DAI
  ],
};

const avaxArchives = {
  chain: "avax",
  locks: LockersV3.avax,
  storageTokenLocks: LockerV33.avax.tokenStorage,
  storageLiquidityLocks: LockerV33.avax.lpStorage,
  coreAssets: [
    '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7', // wavax
    '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC
    '0xc7198437980c041c805a1edcba50c1ce5db95118', // USDT
  ],
};

const xdaiArchives = {
  chain: "xdai",
  locks: LockersV3.xdai,
  storageTokenLocks: LockerV33.xdai.tokenStorage,
  storageLiquidityLocks: LockerV33.xdai.lpStorage,
  coreAssets: [
    '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // WXDAI
    '0xddafbb505ad214d7b80b1f830fccc89b60fb7a83', // USDC
  ]
};

const fantomArchives = {
  chain: "fantom",
  locks: LockersV3.fantom,
  storageTokenLocks: LockerV33.fantom.tokenStorage,
  storageLiquidityLocks: LockerV33.fantom.lpStorage,
  coreAssets: [
    '0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83', // wftm
    '0x04068da6c83afcfa0e13ba15a6696662335d5b75', // USDC
    '0x049d68029688eabf473097a2fc38ef61633a3c7a', // USDT
    '0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e', // DAI
  ],
};

const hecoArchives = {
  chain: "heco",
  locks: [],
  storageTokenLocks: LockerV33.heco.tokenStorage,
  storageLiquidityLocks: LockerV33.heco.lpStorage,
  coreAssets: [
    '0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f', // wheco
  ],
};

const okexchainArchives = {
  chain: "okexchain",
  locks: [],
  storageTokenLocks: LockerV33.okexchain.tokenStorage,
  storageLiquidityLocks: LockerV33.okexchain.lpStorage,
  coreAssets: [
    '0x382bb369d343125bfb2117af9c149795c6c65c50', // tether
    "0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85", // usdc
    "0x8f8526dbfd6e38e3d8307702ca8469bae6c56c15", // wokt
  ]
};

const cronosArchives = {
  chain: "cronos",
  locks: [],
  storageTokenLocks: LockerV33.cronos.tokenStorage,
  storageLiquidityLocks: LockerV33.cronos.lpStorage,
  coreAssets: [
    '0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23'
  ]
};

const moonriverArchives = {
  chain: "moonriver",
  locks: [],
  storageTokenLocks: LockerV33.moonriver.tokenStorage,
  storageLiquidityLocks: LockerV33.moonriver.lpStorage,
  coreAssets: [
    '0xf50225a84382c74CbdeA10b0c176f71fc3DE0C4d', // moonriver
    "0xb44a9b6905af7c801311e8f4e76932ee959c663c", // usdt
    "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d", // usdc
    "0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c", // eth
  ]
};

const smartbchArchives = {
  chain: "smartbch",
  locks: [],
  storageTokenLocks: LockerV33.smartbch.tokenStorage,
  storageLiquidityLocks: LockerV33.smartbch.lpStorage,
  coreAssets: [
    '0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04', // smartbch
  ]
};

const milkomedaArchives = {
  chain: "milkomeda",
  locks: [],
  storageTokenLocks: LockerV33.milkomeda.tokenStorage,
  storageLiquidityLocks: LockerV33.milkomeda.lpStorage,
  coreAssets: [
    '0xAE83571000aF4499798d1e3b0fA0070EB3A3E3F9',
    '0x80A16016cC4A2E6a2CACA8a4a498b1699fF0f844',
    '0x8d50a024B2F5593605d3cE8183Ca8969226Fcbf8',
    '0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8',
    '0x3795C36e7D12A8c252A20C5a7B455f7c57b60283'
  ],
};

module.exports = {
  milkomedaArchives,
  smartbchArchives,
  moonriverArchives,
  cronosArchives,
  okexchainArchives,
  hecoArchives,
  polygonArchives,
  bscArchives,
  ethereumArchives,
  arbitrumArchives,
  celoArchives,
  kucoinArchives,
  harmonyArchives,
  avaxArchives,
  xdaiArchives,
  fantomArchives,
};

'''
'''--- projects/dxsale/index.js ---
const sdk = require("@defillama/sdk");
const {
  polygonArchives,
  bscArchives,
  ethereumArchives,
  fantomArchives,
  xdaiArchives,
  avaxArchives,
  harmonyArchives,
  arbitrumArchives,
  celoArchives,
  kucoinArchives,
  okexchainArchives,
  hecoArchives,
  cronosArchives,
  moonriverArchives,
  milkomedaArchives,
  smartbchArchives,
} = require("./config");
const {
  getStorageLPLockDataV33,
  getLockCountPerContractV3,
  getLockerPerWalletV3,
  getLockerWalletWithIdV3,
  getLockerLPDataV3,
  getStorageLockCountV33,
} = require("./abis");
const { sumUnknownTokens, vestingHelper, } = require("../helper/unknownTokens");
const { createIncrementArray, } = require("../helper/utils");

function getTVLTotal(args) {
  return async (timestamp, ethBlock, chainBlocks) => {
    let balances = {};
    const chain = args.chain;
    const block = chainBlocks[chain];

    const tokensAndOwners = []

    await addV3Lps()

    //Get Locks from Archives
    for (const lock of args.locks)
      await addlockLPs(lock)

    return balances;

    async function addlockLPs(lockContract) {
      const walletIdSet = new Set()
      //Get Amount of Locks on Contract
      const { output: totalLocks } = await sdk.api.abi.call({
        target: lockContract,
        abi: getLockCountPerContractV3,
        chain,
        block,
      });
      const walletIdCalls = createIncrementArray(totalLocks).map(i => ({ params: [i] }))
      const { output: walletIdsAll } = await sdk.api.abi.multiCall({
        target: lockContract,
        abi: getLockerWalletWithIdV3,
        calls: walletIdCalls,
        chain, block,
      })

      walletIdsAll.forEach(({ output }) => walletIdSet.add(output))

      const walletIds = [...walletIdSet]
      const walletLockCountCalls = walletIds.map(i => ({ params: i }))
      const { output: countRes } = await sdk.api.abi.multiCall({
        target: lockContract,
        abi: getLockerPerWalletV3,
        calls: walletLockCountCalls,
        chain, block,
      })

      const calls = walletIds.map((wallet, i) => {
        return createIncrementArray(countRes[i].output).map(j => ({ params: [wallet, j] }))
      }).flat()

      const { output: returnFromDataStruct } = await sdk.api.abi.multiCall({
        target: lockContract,
        abi: getLockerLPDataV3,
        calls, chain, block,
      })

      const tokenSet = new Set()

      returnFromDataStruct.forEach(({ output, success }) => {
        if (!success || !output.lpAddress) return;
        tokenSet.add(output.lpAddress)
      })

      const tempBalances = await vestingHelper({ coreAssets: args.coreAssets, owner: lockContract, tokens: [...tokenSet], chain, block, })

      Object.entries(tempBalances).forEach(([token, bal]) => sdk.util.sumSingleBalance(balances, token, bal))
    }

    async function addV3Lps() {
      //Get Liquidity Locks new from storage
      for (let i = 0; i < args.storageLiquidityLocks.length; i++) {
        //Get Amount of Locks on Contract
        const { output: totalLocks } = await sdk.api.abi.call({
          target: args.storageLiquidityLocks[i],
          abi: getStorageLockCountV33,
          chain,
          block,
        })

        const calls = createIncrementArray(totalLocks).map(i => ({ params: [i] }))
        const { output: lpData } = await sdk.api.abi.multiCall({
          target: args.storageLiquidityLocks[i],
          abi: getStorageLPLockDataV33,
          calls,
          chain, block,
        })

        lpData.forEach(({ output: { lockedLPTokens, lpLockContract } }) => tokensAndOwners.push([lockedLPTokens, lpLockContract]))
      }

      const tempBalances = await sumUnknownTokens({
        chain, block, tokensAndOwners, coreAssets: args.coreAssets, balances,
      })

      Object.entries(tempBalances).forEach(([token, bal]) => sdk.util.sumSingleBalance(balances, token, bal))
    }
  };
}

module.exports = {
  polygon: {
    tvl: getTVLTotal(polygonArchives),
  },
  bsc: {
    tvl: getTVLTotal(bscArchives),
  },
  ethereum: {
    tvl: getTVLTotal(ethereumArchives),
  },
  arbitrum: {
    tvl: getTVLTotal(arbitrumArchives),
  },
  celo: {
    tvl: getTVLTotal(celoArchives),
  },
  kcc: {
    tvl: getTVLTotal(kucoinArchives),
  },
  harmony: {
    tvl: getTVLTotal(harmonyArchives),
  },
  avax: {
    tvl: getTVLTotal(avaxArchives),
  },
  xdai: {
    tvl: getTVLTotal(xdaiArchives),
  },
  fantom: {
    tvl: getTVLTotal(fantomArchives),
  },
  heco: {
    tvl: getTVLTotal(hecoArchives),
  },
  okexchain: {
    tvl: getTVLTotal(okexchainArchives),
  },
  cronos: {
    tvl: getTVLTotal(cronosArchives),
  },
  moonriver: {
    tvl: getTVLTotal(moonriverArchives),
  },
  milkomeda: {
    tvl: getTVLTotal(milkomedaArchives),
  },
  smartbch: {
    tvl: getTVLTotal(smartbchArchives),
  },
};

'''
'''--- projects/dydx/index.js ---
  const sdk = require('@defillama/sdk');

  const BigNumber = require("bignumber.js");

  const contracts = [
    '0x5199071825CC1d6cd019B0D7D42B08106f6CF16D',
    '0x1e0447b19bb6ecfdae1e4ae1694b0c3659614e4e',
    '0xD54f502e184B6B739d7D27a6410a67dc462D69c8'
  ];

  const tokens = [
    '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359',
    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    '0x6B175474E89094C44Da98b954EedeAC495271d0F'
  ];

  async function tvl (timestamp, block) {
    const balances = {};

    let balanceOfCalls = [];
    contracts.forEach((contract) => {
      balanceOfCalls = [
        ...balanceOfCalls,
        ...tokens.map((token) => ({
          target: token,
          params: contract
        }))
      ];
    });

    const balanceOfResult = (await sdk.api.abi.multiCall({
      block,
      calls: balanceOfCalls,
      abi: 'erc20:balanceOf',
    }));

    sdk.util.sumMultiBalanceOf(balances, balanceOfResult, true)

    return balances;
  }

  module.exports = {
    start: 1538179200,  // 09/29/2018 @ 12:00am (UTC)
    ethereum: { tvl },
   hallmarks:[
    [1611630974, "Series B $10M"],
    [1623726974, "Series C $65M"],
    [1627960574, "dydx token"],
    [1632798974, "$250k Trading Comp"],
  ]
  };

'''
'''--- projects/dystopia/index.js ---
const {uniTvlExport} = require('../helper/calculateUniTvl.js')

module.exports = {
  polygon:{
    tvl: uniTvlExport("0x1d21Db6cde1b18c7E47B0F7F42f4b3F68b9beeC9", "polygon"),
  },
}

'''
'''--- projects/earnmos/index.js ---
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");

const { getChainTransform, getFixBalances } = require("../helper/portedTokens");
const { unwrapLPsAuto } = require("../helper/unwrapLPs");
const { fetchURL } = require("../helper/utils");

const abi = require("../agora/abi.json");

const chain = "evmos";

module.exports = {
  evmos: {
    tvl: async (ts, _block, { evmos: block }) => {
      const balances = {};
      const transform = await getChainTransform(chain);

      const res = await fetchURL("https://app.earnmos.fi/api/defi-config.json");

      const vaults = res?.data?.vaults || [];
      const stakeVaults = res?.data?.stakeVaults || [];

      const vaultsCalls = vaults.map(i => ({ target: i }));
      const stakeVaultCalls = stakeVaults.map(({address}) => ({ target: address }));
      const stakeVaultMap = stakeVaults.reduce((agg, {address, vaultAddress}) => ({...agg, [address]: vaultAddress}), {});

      const calls = [...vaultsCalls, ...stakeVaultCalls];
      let { output: sharePrice } = await sdk.api.abi.multiCall({ calls, abi: abi.balance, block, chain });

      let { output: underlying } = await sdk.api.abi.multiCall({ calls: vaultsCalls, abi: abi.want, block, chain });

      const turnToMap = (agg, { input, output }) => ({ ...agg, [input.target]: output });
      sharePrice = sharePrice.reduce(turnToMap, {});
      underlying = underlying.reduce(turnToMap, {});

      Object.keys(sharePrice).forEach(key => {
        const balance = BigNumber(sharePrice[key]).toFixed(0);
        sdk.util.sumSingleBalance(balances, transform(underlying[key] || underlying[stakeVaultMap[key]]), balance);
      });
      await unwrapLPsAuto({ balances, block, chain });
      const fixBalances = await getFixBalances(chain);
      fixBalances(balances);
      return balances;
    }
  }
}

'''
'''--- projects/echidna/abi.json ---
{
    "userInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "userInfo",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "rewardDebt",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTimestamp",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accPtpPerShare",
                "type": "uint256"
            },
            {
                "internalType": "contract IRewarder",
                "name": "rewarder",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "sumOfFactors",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accPtpPerFactorShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "underlyingBalance": {"inputs":[],"name":"underlyingTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    "underlyingToken": {
        "inputs": [],
        "name": "underlyingToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/echidna/index.js ---
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");
const { transformAvaxAddress } = require("../helper/portedTokens");
const abi = require("./abi.json");
const depositor = '0xC204501F33eC40B8610BB2D753Dd540Ec6EA2646';
const { pool2s } = require("../helper/pool2");
const { staking } = require("../helper/staking");

async function addMasterchefFunds(balances, masterChef, block, transform){
    const poolLength = (await sdk.api.abi.call({
        target: masterChef,
        abi: abi.poolLength,
        block,
        chain: 'avax'
    })).output;

    const poolInfo = (await sdk.api.abi.multiCall({
        calls: [...Array(Number(poolLength)).keys()].map(n => ({
            target: masterChef,
            params: [n]
        })),
        abi: abi.poolInfo,
        block: block,
        chain: "avax"
    })).output;

    const userInfo = (await sdk.api.abi.multiCall({
        calls: [...Array(Number(poolLength)).keys()].map(n => ({
            target: masterChef,
            params: [n, depositor]
        })),
        abi: abi.userInfo,
        block: block,
        chain: "avax"
    })).output;

    const totalSupply = (await sdk.api.abi.multiCall({
        calls: poolInfo.map(p => ({
            target: p.output.lpToken,
        })),
        abi: abi.totalSupply,
        block: block,
        chain: "avax"
    })).output;

    const underlyingBalance = (await sdk.api.abi.multiCall({
        calls: poolInfo.map(p => ({
            target: p.output.lpToken,
        })),
        abi: abi.underlyingBalance,
        block: block,
        chain: "avax"
    })).output;

    const underlyingToken = (await sdk.api.abi.multiCall({
        calls: poolInfo.map(p => ({
            target: p.output.lpToken,
        })),
        abi: abi.underlyingToken,
        block: block,
        chain: "avax"
    })).output;

    for (let i = 0; i < userInfo.length; i++) {
        sdk.util.sumSingleBalance(
            balances,
            transform(underlyingToken[i].output),
            BigNumber(userInfo[i].output.amount).times(underlyingBalance[i].output).div(totalSupply[i].output).toFixed(0)
        );
    };
}

async function tvl(timestamp, ethBlock, chainBlocks) {
    const balances = {};
    const transform = await transformAvaxAddress();
    const block = chainBlocks.avax
    await addMasterchefFunds(balances, "0xb0523f9f473812fb195ee49bc7d2ab9873a98044", block, transform)
    await addMasterchefFunds(balances, "0x68c5f4374228BEEdFa078e77b5ed93C28a2f713E", block, transform)

    const vePTPRate = await sdk.api.abi.call({
        target: '0x5857019c749147EEE22b1Fe63500F237F3c1B692',
        abi: {"inputs":[],"name":"generationRate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
        block: block,
        chain: "avax"
    })

    balances['avax:0x22d4002028f537599be9f666d1c4fa138522f9c8'] = new BigNumber((await sdk.api.abi.call({
        target: '0x5857019c749147EEE22b1Fe63500F237F3c1B692',
        params: [depositor],
        abi: 'erc20:balanceOf',
        block: block,
        chain: "avax"
    })).output).div(vePTPRate.output).times(1e12).toFixed(0);

    return balances;
};

const pool2LPs = ["0x218e6A0AD170460F93eA784FbcC92B57DF13316E","0xc8898e2eEE8a1d08742bb3173311697966451F61"]

module.exports = {
    doublecounted: true,
    avax: {
        tvl,
        pool2: pool2s(["0xc9AA91645C3a400246B9D16c8d648F5dcEC6d1c8"], pool2LPs, "avax", addr=>`avax:${addr}`),
        staking: staking("0x721C2c768635D2b0147552861a0D8FDfde55C032","0xeb8343D5284CaEc921F035207ca94DB6BAaaCBcd", "avax")
    }
};
'''
'''--- projects/ecodefi/babyRouterAbi.json ---
{"getAmountsOut":{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}}

'''
'''--- projects/ecodefi/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');
const stakingAbi = require('./stakingAbi.json');
const babyRouterAbi = require('./babyRouterAbi.json');
const { toUSDTBalances } = require('../helper/balances');
const { compoundExports } = require('../helper/compound');
const BASE = BigNumber(10 ** 18);
const Double = BASE * BASE;

let EsgStaking = {
  "bsc": "0x55839fe60742c7789DaBcA85Fd693f1cAbaeDd69", // ESG staking contract  
}

let EsgToken = {
  "bsc": "0x0985205D53D575CB07Dd4Fba216034dc614eab55", // ESG Token
}

let BabySwapRouter = {
  "bsc": "0x325E343f1dE602396E256B67eFd1F61C3A6B38Bd", // Router
}

let USDT = {
  "bsc": "0x55d398326f99059fF775485246999027B3197955", // USDT in BSC
}
/*==================================================
  TVL
  ==================================================*/

async function getESGStakingValue(chain, block) {
  const { output: totalStaked } = await sdk.api.abi.call({
    block,
    target: EsgStaking[chain],
    abi: stakingAbi['total_deposited'],
    chain: chain
  });

  const { output: esgPrice } = await sdk.api.abi.call({
    block,
    target: BabySwapRouter[chain],
    abi: babyRouterAbi['getAmountsOut'],
    params: [BASE.toString(), [EsgToken[chain], USDT[chain]]],
    chain: chain
  });

  let stakedValue = BigNumber(totalStaked.toString()).times(BigNumber(esgPrice[1].toString())).div(Double);

  return stakedValue;
}

async function staking(timestamp, ethBlock, chainBlocks) {
  let staked = await getESGStakingValue('bsc', chainBlocks['bsc']);
  return toUSDTBalances(staked);
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology: 'counts the number of Total value locked in ESG protocol.',
  bsc: {
    ...compoundExports('0xfd1f241ba25b8966a14865cb22a4ea3d24c92451', 'bsc'),
    staking,
  },
  start: 15307794, // Feb-16-2022 01:49:31 PM +UTC
}

'''
'''--- projects/ecodefi/stakingAbi.json ---
{"total_deposited":{"constant":true,"inputs":[],"name":"total_deposited","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}}

'''
'''--- projects/ecurve/index.js ---
// const utils = require("../helper/utils");

async function fetch() {
    // https://ecurve.finance/
    // const stats = await utils.fetchURL("https://iit9dyqn3h.execute-api.us-east-1.amazonaws.com/GetEcurveStats")
    // const tvl = stats.data.reduce((previous, row) => previous + row.tvl, 0 );
    return 0;
}

module.exports = {
  methodology: `eCurve TVL is achieved by making a call to its eCurve API.`,
  fetch
}
'''
'''--- projects/edgeprotocol.js ---
const { request, gql } = require("graphql-request");

function getCoinGeckoId(apiId) {
    return {
        'terra14z56l0fp2lsf86zy3hty2z47ezkhnthtr9yq76': 'anchor-protocol',
        'terra15gwkyepfc6xgca5t5zefzwy42uts8l2m4g40k6': 'mirror-protocol',
        'terra17y9qkl8dfkeg4py7n0g5407emqnemc3yqk5rup': 'stader-lunax',
        'terra1hzh9vpxhsk8253se0vv5jj6etdvxu3nv8z07zu': 'anchorust',
        'terra1kc87mu460fwkqte29rquh4hc20m54fxwtsx7gp': 'bonded-luna',
        'uluna': 'terra-luna',
        'uusd': 'terrausd'
    }[apiId]
};

const graphUrl = `https://mantle.terra.dev/`
const query = gql`
query ($poolQuery: String!) {
  markets: WasmContractsContractAddressStore(
    ContractAddress: "terra1pcxwtrxppj9xj7pq3k95wm2zztfr9kwfkcgq0w"
    QueryMsg: $poolQuery
  ) {
    Result
  },
}
`

async function getMarkets() {
    const { markets: { Result } } = await request(graphUrl, query, { poolQuery: JSON.stringify({ market_lists: {} }) })
    return Result
}

async function tvl() {
    const balances = {};
    const markets = await getMarkets()
    JSON.parse(markets).forEach(m => {
        balances[getCoinGeckoId(m.underlying)] = (m.total_credit - m.total_insurance) / 10 ** 6;
    });
    return balances;
};

async function borrowed() {
    const balances = {};
    const markets = await getMarkets()
    JSON.parse(markets).forEach(m => {
        balances[getCoinGeckoId(m.underlying)] = m.total_loan / 10 ** 6;
    });
    return balances;
};

module.exports = {
    timetravel: false,
    methodology: `We query Edge's Genesis Pool smart contracts to get the amount of assets deposited and borrowed, we then use Coingecko to price the assets in USD.`,
    terra: {
        tvl,
        borrowed
    },
};

'''
'''--- projects/eggtartswap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

module.exports={
    harmony: {
        tvl:calculateUsdUniTvl("0x65CED3c0Af7CDcC64Fb3eE5F021F9b4E65467812", "harmony", "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a", [], "harmony")
    }
} 
'''
'''--- projects/eight/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0xe35737c865968a6fcb13e536adcaa37d9be0c7eb"
module.exports = {
    hallmarks: [
        [1638748800, "protocol compromised keys"]
    ],
    misrepresentedTokens: true,
    ...ohmTvl(treasury, [
    ["0xef977d2f931c1978db5f6747666fa1eacb0d0339", false],
    ["0xc97d37434766eec69d606c9038abaf8a6428e7da", true],
   ], "harmony", "0x6a4a847e83e923ab587cb3f395baaf1983f54bd6",
   "0xcda2fdeee5c382e401c04dc929e53ababf6c8109", addr=>`harmony:${addr}`, id=>id, false)
}
'''
'''--- projects/eklipse/index.js ---
const sdk = require('@defillama/sdk')
const BigNumber = require('bignumber.js')
const { getChainTransform, getFixBalances, } = require('../helper/portedTokens')
const { toUSDTBalances } = require('../helper/balances')
const { sumTokens } = require('../helper/unwrapLPs')
const vaults = require('./vaults')
const chain = 'klaytn'
const EKL_TOKEN = '0x807c4e063eb0ac21e8eef7623a6ed50a8ede58ca'
const STAKING_ADDRESS = '0xD067C3b871ee9E07BA4205A8F96c182baBBA6c58'
const USDT_TOKEN = '0xceE8FAF64bB97a73bb51E115Aa89C17FfA8dD167'
const POOL2_ADDRESS = '0x625ae9043e8730c4a1e30b36838502fb90e1d3c2'
const USDT_PAIR = '0x219ee5d76593f5bd639125b6411a17d309e3ad31'
const KLAY_PAIR = '0x5db231ac93faaad876155dc0853bb11a2f4b0fb2'
const W_KLAY_ADDRESS = '0xd7a4d10070a4f7bc2a015e78244ea137398c3b74'

const TOKENS = {
  kDAI: {
    address: '0x5c74070fdea071359b86082bd9f9b3deaafbe32b',
    decimal: 18
  },
  kBUSD: {
    address: '0x210bc03f49052169d5588a52c317f71cf2078b85',
    decimal: 18
  },
  kUSDC: {
    decimal: 6,
    address: '0x754288077d0ff82af7a5317c7cb8c444d421d103'
  },
  KSD: {
    address: '0x4fa62f1f404188ce860c8f0041d6ac3765a72e67',
    decimal: 18
  },
  KASH: {
    address: '0xce40569d65106c32550626822b91565643c07823',
    decimal: 18
  },
  EKL: {
    decimal: 18,
    address: '0x807c4e063eb0ac21e8eef7623a6ed50a8ede58ca'
  },
  kUSDT: {
    decimal: 6,
    address: '0xcee8faf64bb97a73bb51e115aa89c17ffa8dd167'
  },
  pUSD: {
    decimal: 18,
    address: '0x168439b5eebe8c83db9eef44a0d76c6f54767ae4'
  },
  USDK: {
    decimal: 18,
    address: '0xd2137fdf10bd9e4e850c17539eb24cfe28777753'
  }
}

async function tvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks[chain]
  const transformAddress = await getChainTransform(chain)
  const balances = {}
  const tokensAndOwners = []

  vaults.forEach(({ lpAddress: owner, tvlTokenList }) => {
    tvlTokenList.forEach(token => {
      if (!TOKENS[token]) return;
      tokensAndOwners.push([TOKENS[token].address, owner])
    })
  })

  await sumTokens(balances, tokensAndOwners, block, chain, transformAddress)

  return balances
}

async function staking(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks[chain]
  const transformAddress = await getChainTransform(chain)
  const balances = {}

  await sumTokens(balances, [[EKL_TOKEN, STAKING_ADDRESS]], block, chain, transformAddress)

  const data = (await sdk.api.erc20.balanceOf({ target: EKL_TOKEN, owner: STAKING_ADDRESS, block, chain, })).output
  const value = BigNumber(data).multipliedBy(await getElkPrice()).toFixed(0)
  return toUSDTBalances(value, 1e-12)
}

async function pool2(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks[chain]
  const transformAddress = await getChainTransform(chain)
  const fixBalances = await getFixBalances(chain)
  const balances = {}

  // Unwrap USDT-EKL LP position
  const USDT_LP_Tokens = (await sdk.api.erc20.balanceOf({ target: USDT_PAIR, owner: POOL2_ADDRESS, block, chain, })).output
  const USDT_Tokens = (await sdk.api.erc20.balanceOf({ target: USDT_TOKEN, owner: USDT_PAIR, block, chain, })).output
  const USDT_LP_totalSupply = (await sdk.api.erc20.totalSupply({ target: USDT_PAIR, block, chain, })).output
  balances[transformAddress(USDT_TOKEN)] = BigNumber(USDT_Tokens).multipliedBy(2).multipliedBy(USDT_LP_Tokens).dividedBy(USDT_LP_totalSupply).toFixed(0)

  // Unwrap USDT-EKL LP position
  const KLAY_LP_Tokens = (await sdk.api.erc20.balanceOf({ target: KLAY_PAIR, owner: POOL2_ADDRESS, block, chain, })).output
  const KLAY_Tokens = (await sdk.api.eth.getBalance({ target: KLAY_PAIR, block, chain, })).output
  const KLAY_LP_totalSupply = (await sdk.api.erc20.totalSupply({ target: KLAY_PAIR, block, chain, })).output
  balances[transformAddress(W_KLAY_ADDRESS)] = BigNumber(KLAY_Tokens).multipliedBy(2).multipliedBy(KLAY_LP_Tokens).dividedBy(KLAY_LP_totalSupply).toFixed(0)

  fixBalances(balances)
  return balances
}

let elkPrice

async function getElkPrice(block) {
  if (elkPrice) return elkPrice
  elkPrice = _getEklUsdtLpPrice(block)
  return elkPrice

  async function _getEklUsdtLpPrice(block) {
    const USDT_Tokens = (await sdk.api.erc20.balanceOf({ target: USDT_TOKEN, owner: USDT_PAIR, block, chain, })).output
    const totalSupply = (await sdk.api.abi.call({ target: USDT_PAIR, abi: 'erc20:totalSupply', block, chain, })).output
    return BigNumber(USDT_Tokens).multipliedBy(2).dividedBy(totalSupply)
  }
}

module.exports = {
  klaytn: {
    tvl,
    staking,
    pool2,
  },
}

'''
'''--- projects/eklipse/vaults.js ---
module.exports = [
  {
    id: 'kDAI_kUSDT_kUSDC',
    name: '3Moon',
    tvName: 'threemoon',
    pid: 0,
    lpAddress: '0x4F5d9F3b17988aA047e6F1Bc511fEc0BF25691f4',
    lpTokenAddress: '0xd83b9dFa49D6C6d2A69554576e712E45A8A13E49',
    lpTokenDecimal: 18,
    farmAddress: '0xCeAAF9f6C8147B2A7Cd8bD4E9fA8955b430Eb423',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    tvlTokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    order: 0
  },
  {
    id: 'pUSD_3Moon',
    name: '3Moon-pUSD',
    tvName: 'pusd3moon',
    pid: 1,
    order: 1,
    lpAddress: '0xe59234EeDC854b3b37D48EFd8a529069C3990F83',
    lpTokenAddress: '0x63C7d72963ED6e0C255835B606BEF55EBEB1b5f8',
    lpTokenDecimal: 18,
    farmAddress: '0x0B9932F158509671f7A70b0FB45e58BCdC6fe083',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC',
      'pUSD'
    ],
    tvlTokenList: [
      '3Moon',
      'pUSD'
    ]
  },
  {
    id: 'kBUSD_3Moon',
    name: '3Moon-BUSD',
    tvName: 'busd3moon',
    pid: 2,
    order: 2,
    lpAddress: '0xddA06aaB425a1A390c131F790A56AB3380e3B7EC',
    lpTokenAddress: '0x9EE1cE4ccF4c0379e675d9A326d21aacDbB55F72',
    lpTokenDecimal: 18,
    farmAddress: '0x71143d3f2491c3956f3b4b8A329472af31963c51',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC',
      'kBUSD'
    ],
    tvlTokenList: [
      '3Moon',
      'kBUSD'
    ]
  },
  {
    id: 'KSD_3Moon',
    tvName: 'ksd3moon',
    name: '3Moon-KSD',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC',
      'KSD'
    ],
    tvlTokenList: [
      '3Moon',
      'KSD'
    ],
    lpAddress: '0x7f352a4332fAD433D381d700118f8C9b0A1E1abb',
    lpTokenAddress: '0xa4D48E724c7F2267918B5155094FB01437980604',
    lpTokenDecimal: 18,
    farmAddress: '0x1daD4757f1DE9e090724A39b765f154760E3f62A',
    pid: 3,
    order: 3
  },
  {
    id: 'KASH_3Moon',
    tvName: 'kash3moon',
    name: '3Moon-KASH',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC',
      'KASH'
    ],
    tvlTokenList: [
      '3Moon',
      'KASH'
    ],
    lpAddress: '0xB1b782f2D30505e9984e37e00C6494437d94c223',
    lpTokenAddress: '0x9D5b7671CdDbA4bb82E99fBcedf60C4D001Fe2EF',
    lpTokenDecimal: 18,
    farmAddress: '0x789fc46319e51D956b003f1F552E04F922dCB035',
    pid: 4,
    order: 4
  },
  {
    id: 'USDK_3Moon',
    tvName: 'usdk3moon',
    name: '3Moon-USDK',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC',
      'USDK'
    ],
    tvlTokenList: [
      '3Moon',
      'USDK'
    ],
    lpAddress: '0x75Dc33f8247245E8E08852E68E7f275E2a41fD40',
    lpTokenAddress: '0xc4ACf4ddd4838E9A727cCDb75ae62Af1706a7173',
    lpTokenDecimal: 18,
    farmAddress: '0x85338F94844673b636e632eb21575E1e21864cbc',
    pid: 5,
    order: 5
  },
  {
    id: 'd_kDAI_kUSDT_kUSDC',
    name: '3Moon',
    pid: 0,
    lpTokenDecimal: 18,
    lpAddress: '0x4F5d9F3b17988aA047e6F1Bc511fEc0BF25691f4',
    lpTokenAddress: '0xd83b9dFa49D6C6d2A69554576e712E45A8A13E49',
    farmAddress: '0xC322B6c5D35112bE004f02039D3e07d5AF0b95D6',
    tokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    tvlTokenList: [
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    isDeprecated: !0,
    deprecated: 'Deprecated',
    isFarmOnly: !0,
    order: 1
  },
  {
    id: 'd_kBUSD_3Moon',
    name: 'BUSD-3Moon',
    pid: 1,
    order: 2,
    lpTokenDecimal: 18,
    lpAddress: '0x323fdda29fa2B8028eF9Fb48c1D45e5A39214D9A',
    lpTokenAddress: '0x9f055b5fbde5d6e693752e489d3d71f04810b4d4',
    farmAddress: '0xC322B6c5D35112bE004f02039D3e07d5AF0b95D6',
    tokenList: [
      'kBUSD',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    tvlTokenList: [
      'kBUSD',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    deprecated: 'Deprecated',
    isDeprecated: !0
  },
  {
    id: 'd_KSD_3Moon',
    name: 'KSD-3Moon',
    tokenList: [
      'KSD',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    tvlTokenList: [
      'KSD',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    lpAddress: '0x5B4ed8321ea13047195104037798f29257EAc28c',
    lpTokenAddress: '0x72a35eb0d8a8d0301a5f92c9b6191bcb7ea232e0',
    farmAddress: '0xC322B6c5D35112bE004f02039D3e07d5AF0b95D6',
    lpTokenDecimal: 18,
    pid: 2,
    deprecated: 'Deprecated',
    isDeprecated: !0,
    order: 3
  },
  {
    id: 'd_KASH_3Moon',
    name: 'KASH-3Moon',
    tokenList: [
      'KASH',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    tvlTokenList: [
      'KASH',
      'kDAI',
      'kUSDT',
      'kUSDC'
    ],
    lpAddress: '0x29c6Eb808020Ef4889A9f25d35b69edBAfB0C78e',
    lpTokenAddress: '0xC49Ba500A20B26D7A5407E22d7A7fC08E1E2f31A',
    farmAddress: '0xC322B6c5D35112bE004f02039D3e07d5AF0b95D6',
    lpTokenDecimal: 18,
    pid: 3,
    deprecated: 'Deprecated',
    isDeprecated: !0,
    order: 3
  }
]

'''
'''--- projects/electrikfinance/abi/addressBook.json ---
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_poolStat",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_vault",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "_isActive",
        "type": "bool"
      }
    ],
    "name": "addAddressBook",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "_poolStats",
        "type": "address[]"
      },
      {
        "internalType": "address[]",
        "name": "_vaults",
        "type": "address[]"
      },
      {
        "internalType": "bool[]",
        "name": "_isActives",
        "type": "bool[]"
      }
    ],
    "name": "addAddressBookBulk",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "addressInfo",
    "outputs": [
      {
        "internalType": "address",
        "name": "poolStat",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "vault",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "isActive",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "addressLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_index",
        "type": "uint256"
      }
    ],
    "name": "getTvl",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "tvl",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "initilize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_index",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "_poolStat",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_vault",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "_isActive",
        "type": "bool"
      }
    ],
    "name": "updateAddressBook",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/electrikfinance/abi/poolstat.json ---
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "vaultAddress",
        "type": "address"
      }
    ],
    "name": "tvl",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "vaultAddress",
        "type": "address"
      }
    ],
    "name": "apr",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "vaultAddress",
        "type": "address"
      }
    ],
    "name": "getPricePerLP",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_lp",
        "type": "address"
      }
    ],
    "name": "_getPricePerLP",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function",
    "constant": true
  }
]

'''
'''--- projects/electrikfinance/index.js ---
const sdk = require("@defillama/sdk")
const chain = 'klaytn'
const addressBookAbi = require("./abi/addressBook.json");
const { toUSDTBalances } = require("../helper/balances");

const addressBook = "0x380814144fA550B83A2Be6367c71e60660494cAa";
async function klaytn(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  let klaytnTVL = 0;

  const { output: poolLength } = await sdk.api.abi.call({
    chain, block,
    target: addressBook,
    abi: addressBookAbi.find(i => i.name === 'addressLength')
  })

  const calls = []
  for (let i = 0; i < poolLength; i++)
    calls.push({ params: i})

  const { output: tvl } = await sdk.api.abi.multiCall({
    chain, block,
    target: addressBook,
    abi: addressBookAbi.find(i => i.name === 'getTvl'),
    calls
  })

  tvl.forEach(i => klaytnTVL += Number(i.output))

  klaytnTVL = klaytnTVL / 1e18;
  return toUSDTBalances(klaytnTVL);
}
module.exports = {
  klaytn: {
    tvl: klaytn,
  },
};

'''
'''--- projects/elementfi/abi.json ---
{
  "underlying": {
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "tranche": {
    "inputs": [],
    "name": "tranche",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "valueSupplied": {
    "inputs": [],
    "name": "valueSupplied",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getPoolId": {
    "inputs": [],
    "name": "getPoolId",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getPoolTokens": {
    "inputs": [
      { "internalType": "bytes32", "name": "poolId", "type": "bytes32" }
    ],
    "name": "getPoolTokens",
    "outputs": [
      {
        "internalType": "contract IERC20[]",
        "name": "tokens",
        "type": "address[]"
      },
      { "internalType": "uint256[]", "name": "balances", "type": "uint256[]" },
      {
        "internalType": "uint256",
        "name": "lastChangeBlock",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/elementfi/index.js ---
const sdk = require("@defillama/sdk");
const abi = require('./abi.json');
const bn = require('bignumber.js')

const { unwrapCrv } = require('../helper/unwrapLPs')
const trancheFactoryAddress = "0x62F161BF3692E4015BefB05A03a94A40f520d1c0";
const ccpFactory = '0xb7561f547F3207eDb42A6AfA42170Cd47ADD17BD';
const balVault = '0xBA12222222228d8Ba445958a75a0704d566BF2C8'

const wps = [
    '0xD5D7bc115B32ad1449C6D0083E43C87be95F2809',
    '0xDe620bb8BE43ee54d7aa73f8E99A7409Fe511084',
    '0x67F8FCb9D3c463da05DE1392EfDbB2A87F8599Ea',
    '0xF94A7Df264A2ec8bCEef2cFE54d7cA3f6C6DFC7a',
    '0xE54B3F5c444a801e61BECDCa93e74CdC1C4C1F90',
    '0x2D6e3515C8b47192Ca3913770fa741d3C4Dac354',
    '0xd16847480D6bc218048CD31Ad98b63CC34e5c2bF',
    '0x7320d680Ca9BCE8048a286f00A79A2c9f8DCD7b3',
    '0x9e030b67a8384cbba09D5927533Aa98010C87d91'
]

async function tvl(timestamp, block) {
    let balances = {};
    let tranches = [];

    const trancheLogs = (await sdk.api.util.getLogs({
        target: trancheFactoryAddress,
        topic: 'TrancheCreated(address,address,uint256)',
        keys: [],
        fromBlock: 12685765,
        toBlock: block,
    })).output;

    for (let log of trancheLogs) {
        let tranche = `0x${log.topics[1].substr(-40)}`
        tranches.push(tranche.toLowerCase());
        let underlying = (await sdk.api.abi.call({
            block,
            target: tranche,
            abi: abi['underlying']
        })).output;
        let valueSupplied = (await sdk.api.abi.call({
            block,
            target: tranche,
            abi: abi['valueSupplied']
        })).output;
        balances[underlying.toLowerCase()] = balances[underlying.toLowerCase()] ? new bn(balances[underlying.toLowerCase()]).plus(valueSupplied) : valueSupplied
    };

    // wp tvl
    for (let wp of wps) {
        try {
            let poolId = (await sdk.api.abi.call({
                block,
                target: wp,
                abi: abi['getPoolId'],
            })).output;
    
            let poolTokens = (await sdk.api.abi.call({
                block,
                target: balVault,
                abi: abi['getPoolTokens'],
                params: poolId
            })).output;
            
            for (let i = 0; i < poolTokens.tokens.length; i++) {
                let token = poolTokens.tokens[i];
                let tranche;
                try {
                    tranche = (await sdk.api.abi.call({
                        block,
                        target: token,
                        abi: abi['tranche']
                    })).output;
                } catch (e) {
                }
                if (tranche && tranches.indexOf(tranche.toLowerCase()) >= 0) {
                    continue;
                }
                
                balances[token.toLowerCase()] = balances[token.toLowerCase()] ? new bn(balances[token.toLowerCase()]).plus(poolTokens.balances[i]) : poolTokens.balances[i];
            }
        } catch (e) {
            console.log(e)
        }
    }

    // // // cc tvl
    let ccLogs = (await sdk.api.util
        .getLogs({
          keys: [],
          toBlock: block,
          target: ccpFactory,
          fromBlock: 12686198,
          topic: 'PoolCreated(address)',
        })).output;
        
    for (let log of ccLogs) {
        if (block < log.blockNumber) continue;
        let cc = `0x${log.topics[1].substr(-40)}`;
        let poolId = (await sdk.api.abi.call({
            block,
            target: cc,
            abi: abi['getPoolId'],
        })).output;

        let poolTokens = (await sdk.api.abi.call({
            block,
            target: balVault,
            abi: abi['getPoolTokens'],
            params: poolId
        })).output;

        for (let i = 0; i < poolTokens.tokens.length; i++) {
            let token = poolTokens.tokens[i];
            if (tranches.indexOf(token.toLowerCase()) >= 0) {
                continue;
            }
            
            balances[token.toLowerCase()] = balances[token.toLowerCase()] ? new bn(balances[token.toLowerCase()]).plus(poolTokens.balances[i]) : poolTokens.balances[i];
        }
    }
    for (let [token, balance] of Object.entries(balances)) {
        await unwrapCrv(balances, token, balance, block);
    };
    return balances;
}
module.exports  = {
        tvl
    };
'''
'''--- projects/elephantdex/index.js ---
const { getBlock } = require("../helper/getBlock");
const { transformHarmonyAddress } = require("../helper/portedTokens");
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { getUniTVL } = require("../helper/unknownTokens");

const wONE = "bsc:0xdE976f3344cd9F06E451aF3A94a324afC3E154F4";
async function tvl(timestamp, block, chainBlocks) {
  block = await getBlock(timestamp, "harmony", chainBlocks);
  const transform = await transformHarmonyAddress();

  let balances = await calculateUniTvl(
    transform,
    block,
    "harmony",
    "0x0Dea90EC11032615E027664D2708BC292Bbd976B",
    18105518,
    true
  );

  balances["harmony"] = balances[wONE] / 10 ** 18;
  delete balances[wONE];
  return balances;
}

module.exports = {
  harmony: {
    tvl: getUniTVL({
      chain: 'harmony',
      coreAssets: [
        '0xdAC17F958D2ee523a2206206994597C13D831ec7',   // USDT
        '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',   // USDC
        '0x6B175474E89094C44Da98b954EedeAC495271d0F',   // DAI
      ],
      factory: '0x0Dea90EC11032615E027664D2708BC292Bbd976B',
    })
  },
};

'''
'''--- projects/elephantmoney/index.js ---
const sdk = require("@defillama/sdk");
const { pool2s } = require("../helper/pool2");
const { stakings } = require("../helper/staking");

const contracts = {
  BUSD: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
  TRUNK: '0xdd325C38b12903B727D16961e61333f4871A70E0',
  treasury: '0xCb5a02BB3a38e92E591d323d6824586608cE8cE4',
  LP_TRUNK: '0xf15A72B15fC4CAeD6FaDB1ba7347f6CCD1E0Aede',
  LP_ELEPHANT_BNB: '0x1cea83ec5e48d9157fcae27a19807bef79195ce1',
  LP_ELEPHANT_BUSD: '0x647bc907d520c3f63be38d01dbd979f5606bec48',
  staking: '0xAF0980A0f52954777C491166E7F40DB2B6fBb4Fc',
  ELEPHANT: '0xE283D0e3B8c102BAdF5E8166B73E02D96d92F688'
};

const LPs = [contracts.LP_TRUNK, contracts.LP_ELEPHANT_BNB, contracts.LP_ELEPHANT_BUSD]

async function tvl(timestamp, block, chainBlocks) {
  return { [`bsc:${contracts.BUSD}`] : (await sdk.api.erc20.balanceOf({
    target: contracts.BUSD,
    owner: contracts.treasury,
    block: chainBlocks.bsc,
    chain: 'bsc'
  })).output };
};

module.exports = {
  bsc: {
    pool2: pool2s([contracts.TRUNK, contracts.ELEPHANT], LPs, "bsc"),
    tvl: tvl,
    staking: stakings([contracts.staking], contracts.ELEPHANT, 'bsc')
  }
};
'''
'''--- projects/elevenfinance/index.js ---
const utils = require('../helper/utils');

const apiUrl = 'https://eleven.finance/api.json';

const excludedPools = {
    'polygon': [
        'ELE ',
        'ELE-MUST cLP',
        'ELE-QUICK qLP',
        'ELE-MATIC cLP',
        'ELE-MATIC qLP',
        'ELE-MATIC SLP',
        'ELE-MATIC WLP',
        'ELE-USDC DLP',
        'ELE-DFYN DLP',
    ],
    'fantom': [
        'ELE-WFTM SLP',
    ],
    'bsc': [
        'ELE',
        'ELE-BNB WLP',
        'ELE-BNB LP V2',
    ],
    'avax': [
        'ELE-WAVAX TLP',
        'ELE-WAVAX PLP',
        'ELE-PNG PLP',
        'ELE  ',
    ],
    'okexchain': [
        'ELE-USDT PLP',
    ],
};

function fetchChain(chainId) {
    return async()=>{
    const response = await utils.fetchURL(apiUrl);
    let tvl = parseFloat(response.data.tvlinfo[chainId]);

    if (excludedPools[chainId] !== undefined) {
        excludedPools[chainId].forEach((pool) => {
            tvl -= parseFloat(response.data[pool]?.tvl ?? 0);
        })
    }

    return Math.round(tvl);
    }
}

async function fetch() {
    const response = await utils.fetchURL(apiUrl);
    let tvl = parseFloat(response.data.totalvaluelocked);

    const chains = Object.keys(excludedPools)
    chains.forEach((chainId) => {
        if (excludedPools[chainId] === undefined) {
            return;
        }

        excludedPools[chainId].forEach((pool) => {
            tvl -= parseFloat(response.data[pool]?.tvl ?? 0);
        })
    })

    return Math.round(tvl);
}

module.exports = {
    bsc: {
        fetch: fetchChain('bsc'),
    },
    polygon: {
        fetch: fetchChain('polygon'),
    },
    fantom: {
        fetch: fetchChain('fantom'),
    },
    avalanche: {
        fetch: fetchChain('avax'),
    },
    okexchain: {
        fetch: fetchChain('okexchain'),
    },
    fetch,
}

'''
'''--- projects/elf-finance/index.js ---
const { tombTvl } = require("../helper/tomb");

const elfTokenAddress = "0x300f03050271E33501973Ef00b320F4e9a1a68E2";
const giftTokenAddress = "0x1a01505f6D6f2d693efa06eA66a205c552f82818";
const giftRewardPoolAddress = "0xBB692cad44e39359b38299f63a13490Edb975CB3";
const boardroomAddress = "0xA57235aD899D686285726a8821A99C610Cd5eA78";
const usdcLPs = [
  "0x0AC627348E0b852A99b2F025E8b644033629DAA8", // elfUsdcLpAddress
  "0x0b450366b48b0B8D3a7D6157cf7DaFF7E216a635", //giftUsdcLpAddress
];

module.exports = {
    ...tombTvl(elfTokenAddress, giftTokenAddress, giftRewardPoolAddress, boardroomAddress, usdcLPs, "fantom", undefined, false, usdcLPs[1])
}
'''
'''--- projects/elkfinance/index.js ---
const sdk = require('@defillama/sdk');
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl');
const { getBlock } = require('../helper/getBlock');
const { chainExports: getChainExports } = require('../helper/exports');

function elkAddress(chain) {
  switch(chain) {
    case 'iotex': 
    return '0xa00744882684c3e4747faefd68d283ea44099d03';
    default:
      return '0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE';
  }
} 

function geckoId(chain) {
  switch(chain) {
    case 'iotex': 
    return 'iotex';
    default:
      return 'elk-finance';
  }
}

function whitelist(chain) {
  switch(chain) {
    case 'iotex': 
    return ["0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE", "0x3b2bf2b523f54c4e454f08aa286d03115aff326c"];
    default:
      return [];
  }
}
const stakingContracts = {
  "heco": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "polygon": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "bsc": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "avax": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "fantom": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "xdai": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "okexchain": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "elastos": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "hoo": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "moonriver": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "kcc": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "harmony": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "cronos": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "telos": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "fuse": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
  "iotex": "0x57A1CE7686F3B2AB61F5191c76361F985b57E0fa",
};
// node test.js projects/elkfinance/index.js

const factories = {
  xdai: "0xCB018587dA9590A18f49fFE2b85314c33aF3Ad3B",
  polygon: "0xE3BD06c7ac7E1CeB17BdD2E5BA83E40D1515AF2a",
  fantom: "0x7Ba73c99e6f01a37f3e33854c8F544BbbadD3420",
  bsc: "0x31aFfd875e9f68cd6Cd12Cee8943566c9A4bBA13",
  heco: "0x997fCE9164D630CC58eE366d4D275B9D773d54A4",
  avax: "0x091d35d7F63487909C863001ddCA481c6De47091",
  kcc: "0x1f9aa39001ed0630dA6854859D7B3eD255648599",
  harmony: "0xCdde1AbfF5Ae3Cbfbdb55c1e866Ac56380e18720",
  okexchain: "0x1116f8B82028324f2065078b4ff6b47F1Cc22B97",
  moonriver: "0xd45145f10fD4071dfC9fC3b1aefCd9c83A685e77",
  cronos: "0xEEa0e2830D09D8786Cb9F484cA20898b61819ef1",
  telos: "0x47c3163e691966f8c1b93B308A236DDB3C1C592d",
  hoo: "0x9c03E724455306491BfD2CE0805fb872727313eA",
  elastos: "0x440a1B8b8e968D6765D41E6b92DF3cBb0e9D2b1e",
  fuse: "0x779407e40Dad9D70Ba5ADc30E45cC3494ec71ad2",
  iotex: "0xF96bE66DA0b9bC9DFD849827b4acfA7e8a6F3C42",
  ethereum: "0x6511eBA915fC1b94b2364289CCa2b27AE5898d80", 
  optimism: "0xedfad3a0F42A8920B011bb0332aDe632e552d846",
  arbitrum: "0xA59B2044EAFD15ee4deF138D410d764c9023E1F0"
}

function chainTvl(chain){
  return calculateUsdUniTvl(
    factories[chain], 
    chain, 
    elkAddress(chain), 
    whitelist(chain),
    geckoId(chain),
    18,
    true
  )
}

const chainExports = getChainExports(chainTvl, Object.keys(factories))
chainExports.misrepresentedTokens= true;
chainExports.timetravel= true
/*
Object.entries(stakingContracts).forEach(contract=>{
  chainExports[contract[0] === "avax"?"avalanche":contract[0]].staking = chainStaking(contract[0], contract[1])
})
*/

module.exports = chainExports

'''
'''--- projects/ellipsis/abi.json ---
{
    "balancesBasePool": {
        "stateMutability": "view",
        "type": "function",
        "name": "balances",
        "inputs": [
            {
                "name": "arg0",
                "type": "uint256"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "gas": 1917
    },
    "balancesMetaPool": {
        "stateMutability": "view",
        "type": "function",
        "name": "balances",
        "inputs": [
            {
                "name": "arg0",
                "type": "uint256"
            }
        ],
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "gas": 1977
    },
    "lockedSupply": {
        "inputs": [],
        "name": "lockedSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupplyLP": {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}

'''
'''--- projects/ellipsis/index.js ---
const utils = require('../helper/utils');
const {toUSDTBalances} = require('../helper/balances');
const sdk = require('@defillama/sdk')

async function tvl() {
  var totalTvl = await utils.fetchURL('https://api.ellipsis.finance/api/getAll')
  return toUSDTBalances(totalTvl.data.data.getTotalTVL);
}

const lockedSupply = {"inputs":[],"name":"lockedSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
const stakingContract = "0x4076cc26efee47825917d0fec3a79d0bb9a6bb5c"
const eps = "0xa7f552078dcc247c2684336020c03648500c6d9f"
async function staking(time, ethBlock, chainBlocks){
  const locked = await sdk.api.abi.call({
    target: stakingContract,
    block: chainBlocks.bsc,
    chain: 'bsc',
    abi: lockedSupply
  })
  return {
    ["bsc:"+eps]: locked.output
  }
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  bsc:{
    tvl,
    staking
  }
}

'''
'''--- projects/ellipsis/onchain.js ---
const sdk = require("@defillama/sdk");
const axios = require('axios');
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');
const abi = require('./abi.json');

function getBSCAddress(address) {
  return `bsc:${address}`
}

// list of missing tokens
const replaceable = {
  "0x049d68029688eAbF473097a2fC38ef61633A3C7A": "0xdac17f958d2ee523a2206206994597c13d831ec7", //fUSDT -> USDT
  '0xeD28A457A5A76596ac48d87C0f577020F6Ea1c4C': '0x5228a22e72ccc52d415ecfd199f99d0665e7733b', //pBTC -> pBTC on ETH
  '0x54261774905f3e6E9718f2ABb10ed6555cae308a': '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', //anyBTC -> WBTC
  '0x03ab98f5dc94996f8c33e15cd4468794d12d41f9': '0x674c6ad92fd080e4004b2312b45f796a192d27a0', //USDN -> USDN on ETH
};

const endpoint = 'https://api.ellipsis.finance/api/getPools'

const epsPool = '0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c';
const epsContract = '0xa7f552078dcc247c2684336020c03648500c6d9f';
const epsBnbLP = '0xf9045866e7b372def1eff3712ce55fac1a98daf0';

async function tvl(timestamp, block, chainBlocks) {

  let balances = {};

  let allPools = (await axios.get(endpoint)).data.data
  const basePools = allPools.basePools
  const metaPools = allPools.metaPools

  await Promise.all(basePools.map(async (element) => {

    await Promise.all(element.tokens.map(async (token) => {
      const balance = await sdk.api.abi.call({
        abi: abi.balancesBasePool,
        target: element.address,
        params: token.index,
        block: chainBlocks['bsc'],
        chain: 'bsc'
      });
      balances[getBSCAddress(token.erc20address)] = balance.output
    }));
  }));

  await Promise.all(metaPools.map(async (element) => {

    const balance = await sdk.api.abi.call({
      abi: abi.balancesMetaPool,
      target: element.address,
      params: 0,
      block: chainBlocks['bsc'],
      chain: 'bsc'
    });
    if (Object.keys(replaceable).includes(element.token.address)) {
      sdk.util.sumSingleBalance(balances, replaceable[element.token.address], balance.output)
    } else {
      balances[getBSCAddress(element.token.address)] = balance.output
    }
  }));
  return balances;
}

async function pool2(timestamp, block, chainBlocks) {
  let balances = {}

  //Staked and locked EPS
  const staked = await sdk.api.abi.call({
    abi: abi.totalSupply,
    target: epsPool,
    block: chainBlocks['bsc'],
    chain: 'bsc'
  });
  const locked = await sdk.api.abi.call({
    abi: abi.lockedSupply,
    target: epsPool,
    block: chainBlocks['bsc'],
    chain: 'bsc'
  });
  const epsStakedTotal = parseInt(staked.output) + parseInt(locked.output);

  balances[getBSCAddress(epsContract)] = + epsStakedTotal;
  return balances
}

async function staking(timestamp, block, chainBlocks) {
  let balances = {}

  //EPS/BNB LP
  const transformAdress = addr=>'bsc:'+addr;

  const lpBalance = await sdk.api.abi.call({
    abi: abi.totalSupplyLP,
    target: epsBnbLP,
    block: chainBlocks['bsc'],
    chain: 'bsc'
  });

  await unwrapUniswapLPs(
    balances,
    [{
      token: epsBnbLP,
      balance: parseInt(lpBalance.output),
    }],
    chainBlocks['bsc'],
    'bsc',
    transformAdress
  );

  return balances
}

module.exports = {
  methodology: "pool2 is where eps is and eps/bnb staked. ffUSDT and anyBTC has been replaced with USDT and WBTC in the TVL calculation respectively",
  bsc: {
    tvl
  },
  tvl,
  pool2: {
    tvl: pool2
  },
  staking: {
    tvl: staking
  }
};

'''
'''--- projects/elysia/apiInfo.json ---
{
  "elyfi-subgraph": {
    "method": "POST",
    "endpoint": "https://api.studio.thegraph.com/query/862/elyfi/v0.0.4",
    "body": {
      "query": "{\n    reserves {\n      id\n      lTokenInterestIndex\n      lastUpdateTimestamp\n      borrowAPY\n      depositAPY\n      totalBorrow\n      totalDeposit\n      lTokenUserBalanceCount\n      dTokenUserBalanceCount\n      deposit {\n        id\n      }\n      incentivePool {\n        id\n      }\n      borrow {\n        id\n        amount\n        timestamp\n        tokenId\n      }\n      repay {\n        id\n        userDTokenBalance\n        feeOnCollateralServiceProvider\n        timestamp\n        tokenId\n      }\n      reserveHistory(orderBy: timestamp) {\n        id\n        timestamp\n        borrowAPY\n        depositAPY\n        totalBorrow\n        totalDeposit\n      }\n      lToken {\n        id\n      }\n    }\n  }"
    }
  },
  "elyfi-subgraph-bsc": {
    "method": "POST",
    "endpoint": "https://api.thegraph.com/subgraphs/name/donguks/elyfi-bsc",
    "body": {
      "query": "{\n    reserves {\n      id\n      lTokenInterestIndex\n      lastUpdateTimestamp\n      borrowAPY\n      depositAPY\n      totalBorrow\n      totalDeposit\n      lTokenUserBalanceCount\n      dTokenUserBalanceCount\n      deposit {\n        id\n      }\n      incentivePool {\n        id\n      }\n      borrow {\n        id\n        amount\n        timestamp\n        tokenId\n      }\n      repay {\n        id\n        userDTokenBalance\n        feeOnCollateralServiceProvider\n        timestamp\n        tokenId\n      }\n      reserveHistory(orderBy: timestamp) {\n        id\n        timestamp\n        borrowAPY\n        depositAPY\n        totalBorrow\n        totalDeposit\n      }\n      lToken {\n        id\n      }\n    }\n  }"
    }
  }
}

'''
'''--- projects/elysia/index.js ---
const sdk = require("@defillama/sdk");
const axios = require("axios");
const apiInfo = require("./apiInfo.json");
const { stakings } = require("../helper/staking");

const addresses = {
  elfi: "0x4da34f8264cb33a5c9f17081b9ef5ff6091116f4",
  el: "0x2781246fe707bb15cee3e5ea354e2154a2877b16",
  elStaking: "0x3F0c3E32bB166901AcD0Abc9452a3f0c5b8B2C9D",
  dai: "0x6b175474e89094c44da98b954eedeac495271d0f",
  usdt: "0xdac17f958d2ee523a2206206994597c13d831ec7",
  busd: "0x4fabb145d64652a948d72533023f6e7a623c7c53",
  usdc: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  elfiStaking: [
    "0xb41bcd480fbd986331eeed516c52e447b50dacb4",
    "0xCD668B44C7Cf3B63722D5cE5F655De68dD8f2750",
    "0x24a7fb55e4ac2cb40944bc560423b496dfa8803f",
  ],
  bscElfi: "0x6C619006043EaB742355395690c7b42d3411E8c0",
  bscElfiStaking: [
    "0x73653254ED0F28D6E5A59191bbB38B06C899fBcA",
    "0x861c2221e4d73a97cd94e64c7287fd968cba03e4",
  ],
};

async function getEthereumTvl(timestamp, block, chainBlocks) {
  const balances = {};

  const reserves = (
    await axios.post(
      apiInfo["elyfi-subgraph"].endpoint,
      apiInfo["elyfi-subgraph"].body
    )
  ).data.data.reserves;

  const elStakingValue = (
    await sdk.api.abi.call({
      target: addresses.el,
      params: addresses.elStaking,
      abi: "erc20:balanceOf",
      block,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, addresses.el, elStakingValue);
  sdk.util.sumSingleBalance(balances, addresses.dai, reserves[0].totalDeposit);
  sdk.util.sumSingleBalance(balances, addresses.usdc, reserves[1].totalDeposit);
  sdk.util.sumSingleBalance(balances, addresses.usdt, reserves[2].totalDeposit);

  return balances;
}

async function getBscTvl(timestamp, block, chainBlocks) {
  const balances = {};

  const reserves = (
    await axios.post(
      apiInfo["elyfi-subgraph-bsc"].endpoint,
      apiInfo["elyfi-subgraph-bsc"].body
    )
  ).data.data.reserves;

  sdk.util.sumSingleBalance(balances, addresses.busd, reserves[0].totalDeposit);

  return balances;
}

module.exports = {
  timetravel: false,
  ethereum: {
    tvl: getEthereumTvl, // el staking + dai deposit + usdt deposit
    staking: stakings(addresses.elfiStaking, addresses.elfi),
  },
  bsc: {
    tvl: getBscTvl,
    staking: stakings(addresses.bscElfiStaking, addresses.bscElfi, "bsc"),
  },
}; // node test.js projects/elysia/index.js

'''
'''--- projects/emberswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { stakingPricedLP } = require('../helper/staking')

const EMBER = "0x6BAbf5277849265b6738e75AEC43AEfdde0Ce88D";
const VAULT = "0xFFbE92fDA81f853bcf00d3c7686d5DAd5A6600bB";
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04";
const FACTORY = "0xE62983a68679834eD884B9673Fb6aF13db740fF0";

const EMBER_WBCH_PAIR = "0x52c656FaF57DCbDdDd47BCbA7b2ab79e4c232C28"

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0xE62983a68679834eD884B9673Fb6aF13db740fF0) is used to find the LP pairs. TVL is equal to the liquidity on the AMM. Ember tokens sent to vault are counted towards staking.",
  smartbch: {
    tvl: calculateUsdUniTvl(
      FACTORY,
      "smartbch",
      WBCH,
      [EMBER],
      "bitcoin-cash"
    ),
    staking: stakingPricedLP(VAULT, EMBER, "smartbch", EMBER_WBCH_PAIR, "bitcoin-cash", 18)
  }
};

'''
'''--- projects/embr/index.js ---

const { graphQuery } = require('../helper/http')

const endpoint = 'https://graph.embr.finance/graphql'
const query = '{ embrGetProtocolData { totalLiquidity } }'
let _response

async function fetch() {
  if (!_response) _response = graphQuery(endpoint, query)
  const response = await _response
  return +response.embrGetProtocolData.totalLiquidity
}

module.exports = {
  avalanche: {
    fetch
  },
  fetch
}
'''
'''--- projects/emeraldswap/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const token = "0xC3B538219B73efd57b75f616e909a728bE945bBb";
const masterchef = "0xa72Aa0909f3471D2d360aBBc65B6D30fC7b51844";

module.exports = {
    deadFrom: 1648765747,
    ...masterChefExports(masterchef, "bsc", token, false)
}

'''
'''--- projects/emiswap/index.js ---
const sdk = require("@defillama/sdk")
const { post } = require('../helper/http')
const { toUSDTBalances } = require('../helper/balances')
const { sumTokens } = require("../helper/unwrapLPs")
const { getChainTransform, getFixBalances } = require("../helper/portedTokens")
const abi = require("../mooniswap/abi.json")

const query = factory => `query emiswapFactories {  emiswapFactories(where: {id: "${factory}"}) {    id    totalLiquidityUSD  }}`

const chainConfig = {
  ethereum: {
    factory: '0x1771dff85160768255F0a44D20965665806cBf48',
    url: 'https://api.thegraph.com/subgraphs/name/lombardi22/emiswap8'
  },
  kcc: {
    factory: '0x945316F2964ef5C6C84921b435a528DD1790E93a',
    url: 'https://thegraph.kcc.network/subgraphs/name/emiswap/emiswap1'
  },
  polygon: {
    factory: '0x23c1b313152e276e0CF61665dc3AC160b3c5aB19',
    url: 'https://api.thegraph.com/subgraphs/name/lombardi22/polygon',
  },
  shiden: {
    factory: '0x7449314B698f918E98c76279B5570613b243eECf',
    url: 'https://shiden-graph.emiswap.com/subgraphs/name/shiden',
  },
  avax: {
    factory: '0xaD6b9b31832A88Bb59dB4ACD820F8df2CfA84f0f',
  },
  astar: {
    factory: '0xb4BcA5955F26d2fA6B57842655d7aCf2380Ac854',
  },
  aurora: {
    factory: '0x979e5d41595263f6Dfec4F4D48419C555B80D95c',
    url: 'https://api.thegraph.com/subgraphs/name/lombardi22/aurora',
  },
}

const moduleExports = {}

Object.keys(chainConfig).forEach(chain => {
  const { factory, url } = chainConfig[chain]
  async function tvl() {
    const body = { query: query(factory), operationName: "emiswapFactories", variables: {} }
    const response = await post(url, body)
    return toUSDTBalances(response.data.emiswapFactories[0].totalLiquidityUSD)
  }

  async function computeTvl(ts, _block, chainBlocks) {
    const balances = {}
    const block = chainBlocks[chain]
    const transformAddress = await getChainTransform(chain)
    const fixBalances = await getFixBalances(chain)

    const getAllpools = (await sdk.api.abi.call({ abi: abi.getAllPools, target: factory, block, chain, })).output
    const getTokens = (await sdk.api.abi.multiCall({ abi: abi.getTokens, calls: getAllpools.map(pool => ({ target: pool })), block, chain, })).output
    const tokensAndOwners = []
    getTokens.forEach(({ output: tokens }, i) => {
      const owner = getAllpools[i]
      tokens.forEach(token => tokensAndOwners.push([token, owner]))
    })

    await sumTokens(balances, tokensAndOwners, block, chain, transformAddress)
    fixBalances(balances)
    return balances
  }

  moduleExports[chain] = { tvl: url ? tvl : computeTvl }
})
const eswToken = "0x5a75a093747b72a0e14056352751edf03518031d";
const stakingPool = "0xe094E3E16e813a40E2d6cC4b89bfeAe0142044e1";

async function ethStaking(timestamp, block) {
  let balances = {};

  let { output: balance } = await sdk.api.erc20.balanceOf({
    target: eswToken,
    owner: stakingPool,
    block,
  });
  sdk.util.sumSingleBalance(balances, eswToken, balance);

  return balances;
}

moduleExports.ethereum.staking = ethStaking

module.exports = {
  methodology: "ETH and KCC TVL are the total liquidity from the LPs according to the subgraph. Staking TVL would be ESW value in the staking pool.",
  ...moduleExports
};
'''
'''--- projects/empiredex/index.js ---
const { getChainTvl } = require("../helper/getUniSubgraphTvl");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { getUniTVL } = require("../helper/unknownTokens")

const graphUrls = {
  //bsc: "https://api.thegraph.com/subgraphs/name/trnhgquan/empiredexbsc",
  //xdai: "https://api.thegraph.com/subgraphs/name/zikyfranky/empire-xdai",
  //polygon: "https://api.thegraph.com/subgraphs/name/zikyfranky/empire-polygon",
  //fantom: "https://api.thegraph.com/subgraphs/name/zikyfranky/empire-exchange",
  //avax: "https://api.thegraph.com/subgraphs/name/zikyfranky/empire-subgraph-avax",
};

const chainTvl = getChainTvl(graphUrls, "uniswapFactories");

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "bsc",
      "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      [
        "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        "0x55d398326f99059ff775485246999027b3197955",
        "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
      ],
      "wbnb"
    ),
  },
  cronos: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "cronos",
      "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
      [
        "0xc83859C413a6bA5ca1620cD876c7E33a232c1C34"
      ],
      "crypto-com-chain"
    ),
  },
  xdai: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "xdai",
      "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d",
      [
        "0xc83859C413a6bA5ca1620cD876c7E33a232c1C34"
      ],
      "xdai"
    ),
  },
  polygon: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "polygon",
      "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
      [
        "0xc83859C413a6bA5ca1620cD876c7E33a232c1C34"
      ],
      "matic-network"
    ),
  },
  fantom: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "fantom",
      "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
      [
        "0xc83859C413a6bA5ca1620cD876c7E33a232c1C34",
        "0x04068da6c83afcfa0e13ba15a6696662335d5b75"
      ],
      "fantom"
    ),
  },
  avax: {
    tvl: calculateUsdUniTvl(
      "0x06530550A48F990360DFD642d2132354A144F31d",
      "avax",
      "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      [
        "0xc83859C413a6bA5ca1620cD876c7E33a232c1C34"
      ],
      "avalanche-2"
    ),
  },
  ethereum: {
    tvl: calculateUsdUniTvl(
      "0xd674b01E778CF43D3E6544985F893355F46A74A5",
      "ethereum",
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
      [
        "0x2302f393690487a4fc5927bbef63ff113e0c479d"
      ],
      "ethereum"
    ),
  },
  kava: {
    tvl: getUniTVL({
        factory: '0x06530550A48F990360DFD642d2132354A144F31d',
        chain: 'kava',
        coreAssets: [
            '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b'
        ]
    }),
  },
  
  methodology: "Factory address(0x06530550A48F990360DFD642d2132354A144F31d) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
};

'''
'''--- projects/empyrean/index.js ---
const { staking } = require("../helper/staking");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const empyreanStaking = "0xD080CBc2885c64510923Ac6F5c8896011f86a6aF";
const EMPYR = "0xE9F226a228Eb58d408FdB94c3ED5A18AF6968fE1";

const treasuryAddress = "0x4606f4e6D43d501b86Fc583f44ae27097A1F9EA7";
const USDC = "0xB12BFcA5A55806AaF64E99521918A4bf0fC40802";
const EMPYR_USDC_TLP = "0x6e46c69FE35eF5BB78D7f35d92645C74245a6567";

/*** Bonds TVL Portion (Treasury) ***
 * Treasury TVL consists of USDC and Trisolaris TLP balances
 ***/
async function auroraTvl(timestamp, chainBlocks) {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [USDC, false],
      [EMPYR_USDC_TLP, true],
    ],
    [treasuryAddress],
    chainBlocks["aurora"],
    "aurora",
    (addr) => `aurora:${addr}`
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  aurora: {
    staking: staking(empyreanStaking, EMPYR, "aurora"),
    tvl: auroraTvl,
  },
  methodology:
    "Counts USDC and TLP (EMPYR-USDC) on the treasury",
};

'''
'''--- projects/energiswap.js ---
const { getUniTVL } = require('./helper/unknownTokens')

module.exports = {
  energi: {
    tvl: getUniTVL({
      chain: 'energi',
      factory: '0x875aDBaF8109c9CC9AbCC708a42607F573f594E4',
      coreAssets: [
        '0x7A86173daa4fDA903c9A4C0517735a7d34B9EC39', // wnrg
        '0xa55f26319462355474a9f2c8790860776a329aa4', // wnrg
      ]
    }),
  },
}

'''
'''--- projects/enso-finance/index.js ---
const sdk = require('@defillama/sdk');
const { request, gql } = require('graphql-request');
 
// Enso finance TVL lies for now in the index tokens held by the liquidityMigration contracts
const liquidityMigrationV2_contract = '0x0c6D898ac945E493D25751Ea43BE2c8Beb881D8C';
const graphUrl = 'https://api.thegraph.com/subgraphs/name/ensofinance/enso-liquidity-migration'
const graphQuery = gql`
query GET_WHITELISTED_TOKENS($block: Int) {
  tokens (
    first: 1000
    skip: 0
    block: { number: $block }
  ) {
    id
    name
    stakedAmount
  }
}`

async function tvl(timestamp, block) {
  const { tokens } = await request(
    graphUrl,
    graphQuery, 
    {block}
  );
  const tokens_contracts = tokens.map(t => t.id)
  
  const tokenBalances = await sdk.api.abi.multiCall({
    calls: tokens_contracts.map((t) => ({
      target: t,
      params: [liquidityMigrationV2_contract],
    })),
    abi: 'erc20:balanceOf',
    block,
    chain: 'ethereum',
  })

  const balances = {};
  sdk.util.sumMultiBalanceOf(balances, tokenBalances);
  return balances;
}

module.exports = {
  ethereum: {
    tvl,
  },
  methodology:
    `Get the list of whitelisted index tokens from accepted adapters - TokenSet IndexCoop Indexed PowerPool and PieDAO - and query the amounts held by the vampire LiquidityMigrationV2 contract`,
};
'''
'''--- projects/enterdao/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const StakingContract = "0x3F148612315AaE2514AC630D6FAf0D94B8Cd8E33";
const USDC_ENTR_SUSHI_LP = "0x83b546e10917432a722444672504f0d459472171";
const yieldFarms = [
  "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2", //SUSHI
  "0xbb0e17ef65f82ab018d8edd776e8dd940327b28b", //AXS
  "0x0391D2021f89DC339F60Fff84546EA23E337750f", //BOND
  "0x0f5d2fb29fb7d3cfee444a200298f468908cc942", //MANA
  "0x618679df9efcd19694bb1daa8d00718eacfa2883", //XYZ
  "0x767fe9edc9e0df98e07454847909b5e959d7ca0e", //ILV
  "0x3845badAde8e6dFF049820680d1F14bD3903a5d0", //SAND
  "0x83b546e10917432a722444672504f0d459472171", //SUSHI-LP
];

const ethTvl = async () => {
  const balances = {};

  for (const yieldFarm of yieldFarms) {
    await sumTokensAndLPsSharedOwners(
      balances,
      yieldFarm == USDC_ENTR_SUSHI_LP
        ? [[yieldFarm, true]]
        : [[yieldFarm, false]],
      [StakingContract]
    );
  }

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology: "We count as TVL all the Yield Farms through Staking Contract",
};

'''
'''--- projects/entropyfi/abi.json ---
{
  "allPools": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "allPools",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "allPoolsLength": {
    "inputs": [],
    "name": "allPoolsLength",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "aToken": {
    "inputs": [],
    "name": "aToken",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "poolTokensInfo": {
    "inputs": [],
    "name": "poolTokensInfo",
    "outputs": [
      { "internalType": "address", "name": "longToken", "type": "address" },
      { "internalType": "address", "name": "shortToken", "type": "address" },
      { "internalType": "address", "name": "sponsorToken", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "status": {
    "inputs": [],
    "name": "status",
    "outputs": [
      {
        "internalType": "bool",
        "name": "isShortLastRoundWinner",
        "type": "bool"
      },
      { "internalType": "bool", "name": "isFirstUser", "type": "bool" },
      { "internalType": "bool", "name": "isFirstRound", "type": "bool" },
      { "internalType": "uint256", "name": "gameRound", "type": "uint256" },
      {
        "internalType": "uint256",
        "name": "durationOfGame",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "durationOfBidding",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastUpdateTimestamp",
        "type": "uint256"
      },
      { "internalType": "int256", "name": "initialPrice", "type": "int256" },
      { "internalType": "int256", "name": "endPrice", "type": "int256" },
      {
        "internalType": "enum ILosslessV2Pool.PoolStatus",
        "name": "currState",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/entropyfi/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { sumTokens } = require("../helper/unwrapLPs");
const { pool2 } = require("../helper/pool2");
const transformPolygonAddress = (id) => `polygon:${id}`;

const entropyV1Factory = "0xeff87121ab94457789495918eef5a5904eb04419";
const ERP_USDC_quickswap = "0xc4bf2a012af69d44abc4bbe2b1875a222c1c32e1";
const stakingContract = "0x7ace9872ee80145ad7b4d93cf8d84d664c450ea5";
// const vesting = '0x02f1410457ceb105ca8aed71b7654fb05cb61417'
// const sponsorFarm = '0xb956B861BD97bf5195Eb4AA09d5c5EAD1B2e4514'

const poolsTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const block = chainBlocks["polygon"];

  // Get Entropy pool count, andd retrieve their addresses
  const { output: allPoolsLength } = await sdk.api.abi.call({
    target: entropyV1Factory,
    abi: abi["allPoolsLength"],
    chain: "polygon",
    block,
  });
  const poolsCalls = [...Array(parseInt(allPoolsLength)).keys()].map((i) => ({
    target: entropyV1Factory,
    params: i,
  }));
  const { output: allPoolsOutput } = await sdk.api.abi.multiCall({
    calls: poolsCalls,
    abi: abi["allPools"],
    chain: "polygon",
    block,
  });
  console.log(`Number of entropy pools: ${allPoolsLength}`);

  // Get aTokens used as collateral in each pool, and retrieve the amount of aTokens held by each pool
  const allPools = allPoolsOutput.map((o) => o.output);
  const { output: poolsaTokens } = await sdk.api.abi.multiCall({
    calls: allPools.map((o) => ({ target: o })),
    abi: abi["aToken"],
    chain: "polygon",
    block,
  });
  const tokensAndOwners = allPools.map((pool, idx) => [
    poolsaTokens[idx].output,
    pool,
  ]);
  // console.log(tokensAndOwners)
  await sumTokens(
    balances,
    tokensAndOwners,
    block,
    "polygon",
    transformPolygonAddress
  );
  return balances;
};

module.exports = {
  polygon: {
    tvl: poolsTvl,
    pool2: pool2(
      stakingContract,
      ERP_USDC_quickswap,
      "polygon",
      transformPolygonAddress
    ),
  },
  methodology:
    "Entropy Pools store the users collateral as aave aTokens in each pool. Quickswap LP is also staked and accounted for in pool2.",
};

'''
'''--- projects/enzyme/index.js ---
const retry = require('async-retry')
const axios = require('axios')
const { sumTokens } = require('../helper/unwrapLPs')
const cwADA_ETH = '0x64875aaa68d1d5521666c67d692ee0b926b08b2f'
const cwADA_POLY = 'polygon:0x64875aaa68d1d5521666c67d692ee0b926b08b2f'
const cwDOGE_ETH = '0xf9e293d5d793ddc1ae4f778761e0b3e4aa7cf2dd'
const cwDOGE_POLY = 'polygon:0x9bd9ad490dd3a52f096d229af4483b94d63be618'

async function getData() {
  return retry(async bail => await axios.get('https://app.enzyme.finance/api/v1/network-asset-balances?network=ethereum'))
}

async function tvl(ts, block) {
  const tokens = (await getData()).data
  const tokensAndOwners = []
  const balances = {}
  const vaultsObj = {}
  tokens.forEach(({ id, vaults }) => {
    vaults.forEach(vault => {
      tokensAndOwners.push([id, vault])
      vaultsObj[vault] = true
    })
  })
  await sumTokens(balances, tokensAndOwners, block, undefined, undefined, { resolveCrv: true, resolveLP: true, resolveYearn: true })
  
  if (balances[cwADA_ETH]) {
    balances[cwADA_POLY] = balances[cwADA_ETH]
    delete balances[cwADA_ETH]
  }

  if (balances[cwDOGE_ETH]) {
    balances[cwDOGE_POLY] = balances[cwDOGE_ETH]
    delete balances[cwDOGE_ETH]
  }
  return balances
}

module.exports = {
  timetravel: false,
  ethereum: { tvl }
}

'''
'''--- projects/epns/index.js ---
const { staking } = require('../helper/staking')
const { pool2 } = require('../helper/pool2')

const PUSH = '0xf418588522d5dd018b425e472991e52ebbeeeeee'
const PUSH_WETH_LP = '0xaf31fd9c3b0350424bf96e551d2d1264d8466205'
const staking_contract = '0xb72ff1e675117bedeff05a7d0a472c3844cfec85'

module.exports = {
  methodology: `TVL for PUSH consists of the staking of PUSH and pool2 of uni-v2 LP.`, 
  ethereum:{
    tvl: () => ({}),
    staking: staking(staking_contract, PUSH, 'ethereum'), 
    pool2: pool2(staking_contract, PUSH_WETH_LP, 'ethereum'), 
  }
}
'''
'''--- projects/epsylon/abi.json ---
{
  "totalAssets": {
    "inputs": [],
    "name": "totalAssets",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/epsylon/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { default: BigNumber } = require("bignumber.js");

const USDC_VAULT = "0x756d09263483dC5A6A0023bb80933db2C680703E";
const USDC_2_VAULT = "0x69e475b67052987707E953b684c7d437e15AC511";
const WFTM_VAULT = "0x22c538c1EeF31B662b71D5C8DB47847d30784976";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const WFTM = "0x4e15361fd6b4bb609fa63c81a2be19d873717870";

async function tvl() {
  let balances = {};

  const usdcVaultTVL = await sdk.api.abi.call({
    target: USDC_VAULT,
    abi: abi["totalAssets"],
    chain: "fantom",
  });

  const usdcVault2TVL = await sdk.api.abi.call({
    target: USDC_2_VAULT,
    abi: abi["totalAssets"],
    chain: "fantom",
  });

  const wftmVaultTVL = await sdk.api.abi.call({
    target: WFTM_VAULT,
    abi: abi["totalAssets"],
    chain: "fantom",
  });

  balances[USDC] = new BigNumber(usdcVaultTVL.output).plus(
    new BigNumber(usdcVault2TVL.output)
  );
  balances[WFTM] = wftmVaultTVL.output;

  return balances;
}

module.exports = {
  timetravel: false,
  methodology: `Track the yield generated and deposits made to the vaults`,
  fantom: {
    tvl,
  },
};

'''
'''--- projects/equilibrium/index.js ---
const { get_account_tvl } = require("../helper/eos");

const accounts = [
  "eosdtcntract", // EOS collateral
  "eosdtpbtcpos", // PBTC collateral
  "eosdtstfund1", // Stability Fund
  "eosdtstfund2", // Stability Fund
  "eosdtstfund3", // Stability Fund
]

const tokens = [
  ["btc.ptokens", "PBTC", "ptokens-btc"],
  ["eosio.token", "EOS", "eos"]
];

// Equilibrium
// https://eosdt.com
// https://equilibrium.io
async function eos() {
  return await get_account_tvl(accounts, tokens);
}

module.exports = {
  methodology: `Equilibrium TVL is achieved by querying token balances from EOSDT stable token smart contracts.`,
  eos: {
    tvl: eos
  },
}

'''
'''--- projects/erasure/abi.json ---
{
  "getInstanceCount": {
    "constant": true,
    "inputs": [],
    "name": "getInstanceCount",
    "outputs": [
      {
        "name": "count",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getPaginatedInstances": {
    "constant": true,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endIndex",
        "type": "uint256"
      }
    ],
    "name": "getPaginatedInstances",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "instances",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/erasure/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const sdk = require("@defillama/sdk");

  const BigNumber = require("bignumber.js");

  const abi = require('./abi.json');

/*==================================================
  Settings
  ==================================================*/

  const instanceCountPerCall = 1000;

  const registryAddresses = [
    '0xa6cf4Bf00feF8866e9F3f61C972bA7C687C6eDbF', // Erasure Agreements
    '0x409EA12E73a10EF166bc063f94Aa9bc952835E93', // Erasure Escrows
    '0x348FA9DcFf507B81C7A1d7981244eA92E8c6Af29' // Erasure Posts
  ];

  const tokenAddresses = [
    '0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671', // NMR
    '0x6B175474E89094C44Da98b954EedeAC495271d0F' // DAI
  ]

/*==================================================
  TVL
  ==================================================*/

  async function tvl(timestamp, block) {
    let balances = {};

    // instances count for each registry
    const instanceCounts = (
      await sdk.api.abi.multiCall({
        calls: registryAddresses.map((registryAddress) => {
          return {
            target: registryAddress
          }
        }),
        abi: abi.getInstanceCount
      })
    ).output;

    let paginatedInstancesCalls = [];

    instanceCounts.forEach((instanceCount) => {
      const registryAddress = instanceCount.input.target;
      const count = Number(instanceCount.output);

      for(let i = 0; i < count; i += instanceCountPerCall) {
        const from = i;
        let to = i + instanceCountPerCall;

        if(to > count) {
          to = count;
        }

        paginatedInstancesCalls.push({
          target: registryAddress,
          params: [from, to]
        })
      }
    });

    // instances for each registry
    const paginatedInstances = (
      await sdk.api.abi.multiCall({
        calls: paginatedInstancesCalls,
        abi: abi.getPaginatedInstances
      })
    ).output;

    let instanceAddresses = [];

    paginatedInstances.forEach((instances) => {
      instanceAddresses = [
        ...instanceAddresses,
        ...instances.output
      ]
    });

    instanceAddresses = [... new Set(instanceAddresses)]

    let balanceOfCalls = [];

    instanceAddresses.forEach((instanceAddress) => {
      tokenAddresses.forEach((tokenAddress) => {
        balanceOfCalls.push({
          target: tokenAddress,
          params: [instanceAddress]
        });
      });
    });

    // call all balances
    const balanceOfResults = await sdk.api.abi.multiCall({
      block,
      calls: balanceOfCalls,
      abi: "erc20:balanceOf"
    });

    // sum token balances across contracts
    balanceOfResults.output.forEach(balanceOf => {
        let balance = balanceOf.output;
        let address = balanceOf.input.target;

        balances[address] = BigNumber(balances[address] || 0)
          .plus(balance)
          .toFixed();
    });

    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1566518400, // 08/23/2019 @ 12:00am (UTC)
    ethereum: { tvl }
  };

'''
'''--- projects/ergodex.js ---
const utils = require('./helper/utils');
const {toUSDTBalances} = require('./helper/balances')

async function tvl() {
  var totalTvl = await utils.fetchURL('https://api.ergodex.io/v1/amm/platform/stats');
  return toUSDTBalances(totalTvl.data.tvl.value/100);
}

module.exports = {
    misrepresentedTokens: true,
    timetravel: false,
    ergo:{
        tvl
    },
    methodology: `ErgoDEX TVL is achieved by making a call to its API: https://api.ergodex.io/v1/amm/platform/stats.`
}
'''
'''--- projects/ergodex/index.js ---
const utils = require("../helper/utils");

const api_ergo = "https://api.ergodex.io/v1/amm/platform/stats?";

async function fetch() {
  const data = (await utils.fetchURL(api_ergo)).data.tvl;
  return data.value / 10 ** data.units.currency.decimals;
}

module.exports = {
  fetch,
};

'''
'''--- projects/ergopad/index.js ---
const utils = require('../helper/utils');

async function staking() {
  const { data: { 'Total amount staked': totalStaked } } = await utils.fetchURL('https://ergopad.io/api/staking/status');
  const price = await getErgopadPrice()
  return {
    ergo: totalStaked * price
  }
}

async function getErgopadPrice() {
  const { data: { lockedX, lockedY, } } = await utils.fetchURL('https://api.ergodex.io/v1/amm/pool/d7868533f26db1b1728c1f85c2326a3c0327b57ddab14e41a2b77a5d4c20f4b2/stats');
  let ergQuantity, padQunatity

  const ergId = '0000000000000000000000000000000000000000000000000000000000000000'
  if (lockedX.id === ergId) {
    ergQuantity = getQuantity(lockedX)
    padQunatity = getQuantity(lockedY)
  } else {
    ergQuantity = getQuantity(lockedY)
    padQunatity = getQuantity(lockedX)
  }

  function getQuantity({ amount, decimals }) {
    return amount / 10 ** decimals
  }

  return ergQuantity / padQunatity

}

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  ergo: {
    tvl: () => ({}),
    staking
  },
  methodology: `Ergopad TVL is achieved by making a call to its API: https://ergopad.io/api/blockchain/tvl/d71693c49a84fbbecd4908c94813b46514b18b67a99952dc1e6e4791556de413 and consists of both staked ergopad tokens.`
}

'''
'''--- projects/eris-protocol/index.js ---
const axios = require("axios");
const { queryContract, } = require('../helper/terra')

const contracts = {
  terra2_hub:
    "terra10788fkzah89xrdm27zkj5yvhj9x3494lxawzm5qq3vvxcqz2yzaqyd3enk",
};

async function terra2Tvl() {
  const res = await queryContract({ isTerra2: true, contract: contracts.terra2_hub, data: { state: { }}})

  return {
    "terra-luna-2": +res.tvl_uluna / 1e6,
  };
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: false,
  methodology: "Liquid Staking and Arbitrage Protocol",
  terra2: { tvl: terra2Tvl },
};

'''
'''--- projects/ester/abi.json ---
{
    "poolInfoStaking": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTime",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accESTPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "want",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTime",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accESTPerShare",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "strat",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "wantLockedTotal": {
        "inputs": [],
        "name": "wantLockedTotal",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "symbol": {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/ester/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformFantomAddress } = require("../helper/portedTokens");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const esterStakingChefContract = "0x78e9D247541ff7c365b50D2eE0defdd622016498";
const EST = "0x181f3f22c9a751e2ce673498a03e1fdfc0ebbfb6";
const WFTM_EST_SPIRITLP = "0x0c9043cb1B994C8e4a8024e2F037Ea50b7025a82";

const esterVaultFarmContract = "0xA6151b608f49Feb960e951F1C87F4C766850de31";

const ftmTvl = async (chainBlocks) => {
    const balances = {};

    let transformAddress = await transformFantomAddress();

    await addFundsInMasterChef(
        balances,
        esterStakingChefContract,
        chainBlocks["fantom"],
        "fantom",
        transformAddress,
        abi.poolInfoStaking,
        [EST, WFTM_EST_SPIRITLP]
    );

    const poolLength = (
        await sdk.api.abi.call({
            abi: abi.poolLength,
            target: esterVaultFarmContract,
            chain: "fantom",
            block: chainBlocks["fantom"],
        })
    ).output;

    const lpPositions = [];

    for (let index = 0; index < poolLength; index++) {
        const strat = (
            await sdk.api.abi.call({
                abi: abi.poolInfo,
                target: esterVaultFarmContract,
                params: index,
                chain: "fantom",
                block: chainBlocks["fantom"],
            })
        ).output.strat;

        const want = (
            await sdk.api.abi.call({
                abi: abi.poolInfo,
                target: esterVaultFarmContract,
                params: index,
                chain: "fantom",
                block: chainBlocks["fantom"],
            })
        ).output.want;

        const strat_bal = (
            await sdk.api.abi.call({
                abi: abi.wantLockedTotal,
                target: strat,
                chain: "fantom",
                block: chainBlocks["fantom"],
            })
        ).output;

        const symbol = (
            await sdk.api.abi.call({
                abi: abi.symbol,
                target: want,
                chain: "fantom",
                block: chainBlocks["fantom"],
            })
        ).output;

        if (symbol.includes("LP")) {
            lpPositions.push({
                token: want,
                balance: strat_bal,
            });
        } else {
            sdk.util.sumSingleBalance(balances, `fantom:${want}`, strat_bal);
        }
    }

    await unwrapUniswapLPs(
      balances,
      lpPositions,
      chainBlocks["fantom"],
      "fantom",
      transformAddress
    );

    return balances;
};

module.exports = {
    misrepresentedTokens: true,
    fantom: {
        staking: staking(esterStakingChefContract, EST, "fantom"),
        pool2: pool2(esterStakingChefContract, WFTM_EST_SPIRITLP, "fantom"),
        tvl: ftmTvl,
    },
    methodology:
        "We count liquidity on all the Vaults through EsterStakingChef and EsterVaultFarmt Contracts",
};

'''
'''--- projects/ethalend/abi.json ---
{
    "underlying":{"inputs":[],"name":"underlying","outputs":[{"internalType":"contract IERC20Detailed","name":"","type":"address"}],"stateMutability":"view","type":"function"},
    "calcTotalValue": {"inputs":[],"name":"calcTotalValue","outputs":[{"internalType":"uint256","name":"underlyingAmount","type":"uint256"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/ethalend/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const {unwrapUniswapLPs} = require('../helper/unwrapLPs')
const {staking} = require('../helper/staking')
const {pool2} = require('../helper/pool2')
const {fetchURL} = require('../helper/utils')
const {gql, request} = require('graphql-request')
const { default: BigNumber } = require('bignumber.js')

/*
const vaults = [
    "0x4e5b645B69e873295511C6cA5B8951c3ff4F74F4",
    "0xb56AAb9696B95a75A6edD5435bc9dCC4b07403b0",
    "0x8dE8637412e70916Ee2CAA3b62C569d9A88391A3",
    "0xa5eefafa4f5cd64e3f6e97f6fa1301434d544775",
    "0x04D5bc0fdD251484A7a2224cEE818C7ce2412dbc",
    "0xF125B8d7D0DCCbb810c9187e6361804B895C91B5",
]
*/
const curvePool = "0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171"

const globalDataQuery = gql`
  query($block: Int) {
    globalDatas(first: 100, 
        block: { number: $block }
    ) {
      symbol
      address
      type
      totalUnderlying
      totalVolumeUSD
    }
  }
`;

async function tvl(time, ethBlock, chainBlocks){
    const chain = "polygon"
    const block = chainBlocks[chain]
    const balances = {}
    const globalData = (await request("https://api.thegraph.com/subgraphs/name/ethalend/etha-v1", globalDataQuery, {block:block-100})).globalDatas
    await Promise.all(globalData.filter(v=>v.type==="lending").map(async v=>{
        if(v.address==="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"){
         v.address = "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270"   
        }
        const decimals = await sdk.api.erc20.decimals(v.address, chain)
        sdk.util.sumSingleBalance(balances, chain+':'+ v.address, BigNumber(v.totalUnderlying).times(10**decimals.output).toFixed(0))
    }))
    let vaults = (await fetchURL("https://ethalend.com/api/vaults/vaultInfo")).data.vaults.map(v=>v.poolAddress)
    vaults = Array.from(new Set(vaults)) // remove duplicates
    const [underlyings, totals] = await Promise.all([abi.underlying, abi.calcTotalValue].map(abi=>sdk.api.abi.multiCall({
        abi,
        block,
        chain,
        calls: vaults.map(v=>({target:v}))
    })))
    const lpPositions = []
    for(let i=0; i<vaults.length; i++){
        const underlying = underlyings.output[i].output
        const total = totals.output[i].output
        if(underlying === curvePool){
            sdk.util.sumSingleBalance(balances, "polygon:0x2e1ad108ff1d8c782fcbbb89aad783ac49586756", total)
        } else {
            lpPositions.push({
                token: underlying,
                balance: total
            })
        }
    }
    await unwrapUniswapLPs(balances, lpPositions, block, chain, addr=>`${chain}:${addr}`)
    return balances
}

module.exports={
    polygon:{
        tvl,
        staking: staking("0x85e6A965950ACa02fdf680d4b087DdD64DF28a81", "0x59e9261255644c411afdd00bd89162d09d862e38", "polygon", "0x59e9261255644c411afdd00bd89162d09d862e38"),
        pool2: pool2("0x2f4de75a8e591cbd4d2c0d3aee7c36fe62a64f79", "0xb417da294ae7c5cbd9176d1a7a0c7d7364ae1c4e", "polygon", 
            addr=>addr.toLowerCase()==="0x59e9261255644c411afdd00bd89162d09d862e38"?"0x59e9261255644c411afdd00bd89162d09d862e38":`polygon:${addr}`)
    }
}
'''
'''--- projects/ethernity/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');

const ernToken = '0xBBc2AE13b23d715c30720F079fcd9B4a74093505';
const stonesFarm = '0xEdFE9aC42a511e1C523E067DB8345711419d4f14';
const ernLPFarm = '0x34a77Aa9AE42ff9a9B2078E450651D112D5BE908';
const ernLP = '0x570febdf89c07f256c75686caca215289bb11cfc';

async function tvl(timestamp, block) {
    const balances = {};

    const balanceStones = await sdk.api.erc20.balanceOf({
        target: ernToken,
        owner: stonesFarm,
        block: block,
    });
    balances[ernToken] = balanceStones.output;

    //get balance of LP tokens on ern farm
    const balanceErnLP = await sdk.api.erc20.balanceOf({
        target: ernLP,
        owner: ernLPFarm,
        block: block,
    });

    //unrwap the lp tokens to get the amount of each coin in the lp
    await unwrapUniswapLPs(balances, [{
        token: ernLP,
        balance: balanceErnLP.output,
    }],
        block);

    return balances;
}

module.exports = {
    ethereum:{
        tvl
    },
}

'''
'''--- projects/euler/abi.json ---
{
  "underlyingToAssetConfig": {"inputs":[{"internalType":"address","name":"underlying","type":"address"}],"name":"underlyingToAssetConfig","outputs":[{"components":[{"internalType":"address","name":"eTokenAddress","type":"address"},{"internalType":"bool","name":"borrowIsolated","type":"bool"},{"internalType":"uint32","name":"collateralFactor","type":"uint32"},{"internalType":"uint32","name":"borrowFactor","type":"uint32"},{"internalType":"uint24","name":"twapWindow","type":"uint24"}],"internalType":"struct Storage.AssetConfig","name":"","type":"tuple"}],"stateMutability":"view","type":"function"}, 
  "getEnteredMarkets": {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"getEnteredMarkets","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/euler/index.js ---
const { sumTokens } = require('../helper/unwrapLPs')
const { GraphQLClient, gql } = require('graphql-request')

const contracts = {
  euler: "0x27182842E098f60e3D576794A5bFFb0777E025d3",
  markets: '0xE5d0A7A3ad358792Ba037cB6eE375FfDe7Ba2Cd1',
  markets_proxy: '0x3520d5a913427E6F0D6A83E07ccD4A4da316e4d3',
}

// Graphql endpoint to query markets
const graphql_url = 'https://api.thegraph.com/subgraphs/name/euler-xyz/euler-mainnet'

async function ethereum(timestamp, ethBlock) {
  var graphQLClient = new GraphQLClient(graphql_url)

  const markets_query = gql`query {
      eulerMarketStores {
        markets {
          id
        }
        
      }
    }`

  const results = await graphQLClient.request(markets_query)
  const markets = results.eulerMarketStores[0].markets
  const markets_underlyings = markets.map(market => market.id)

  // use markets_underlyings or markets_underlyings_nographql
  const tokensAndOwners = markets_underlyings.map(underlying => [underlying, contracts.euler])
  return sumTokens({}, tokensAndOwners, ethBlock)
}

module.exports = {
  methodology: `Collateral (supply minus borrows) in the balance of the euler contract`,
  ethereum: {
    tvl: ethereum,
    // staking: staking(EULstaking, EUL),
  }
}

'''
'''--- projects/euphoria/index.js ---
const { staking } = require('../helper/staking');
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs');
const { transformHarmonyAddress } = require('../helper/portedTokens');
const { getBlock } = require('../helper/getBlock');
const { fixHarmonyBalances } = require('../helper/portedTokens');

const wagmiAddresses = {
  staking: '0x95066025af40F7f7832f61422802cD1e13C23753',
  wagmi: '0x0dc78c79B4eB080eaD5C1d16559225a46b580694',
  treasury: '0x1A9Be7D6f94D3Ba8c37568E08D8D8780AAD128E6',
};

const wagmiReserves = {
  single: {
    dai: '0xEf977d2f931C1978Db5F6747666fa1eACB0d0339',
    ust: '0x224e64ec1BDce3870a6a6c777eDd450454068FEC',
    usdc: '0x985458e523db3d53125813ed68c274899e9dfab4',
    busd: '0xe176ebe47d621b984a73036b9da5d834411ef734',
  },
  lp: {
    wagmiDai: '0xb8F4c06dD0C2f9eb5e67B4FAA2d56Ff3543d6765',
    wagmiUst: '0xd7E332b4C9f97eA6D05Db8C38F133307ad8847F3',
    wagmiOne: '0x29c1e9fc7a4c19c8fcaf2d2b2de213ef0f323f0c',
  },
};

async function tvl(time, ethBlock, chainBlocks) {
  const balances = {};
  const transform = await transformHarmonyAddress();
  const block = await getBlock(time, 'harmony', chainBlocks, true);

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [wagmiReserves.single.dai, false],
      [wagmiReserves.lp.wagmiDai, true],
      [wagmiReserves.single.ust, false],
      [wagmiReserves.lp.wagmiUst, true],
      [wagmiReserves.single.usdc, false],
      [wagmiReserves.single.busd, false],
      [wagmiReserves.lp.wagmiOne, true],
    ],
    [wagmiAddresses.treasury],
    block,
    'harmony',
    transform
  );

  fixHarmonyBalances(balances);

  return balances;
}

module.exports = {
  harmony: {
    tvl,
    staking: staking(wagmiAddresses.staking, wagmiAddresses.wagmi, 'harmony'),
  },
  methodology:
    'Counts tokens in the treasury for tvl and staked WAGMI for staking',
};

'''
'''--- projects/everestdao/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require('bignumber.js')
const { pool2s } = require("../helper/pool2");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");

const stakingContracts = [
  //pEVRT
  "0x451D00AF6E751537a9A2cFF40CdFB1119cd1fA7d",
  //pEVRT Farm
  "0x13B2e894E3e7D60c0E084ab5Cc47552d7cfE40C4",
];
const EVRT = "0x3ACa5545e76746A3Fe13eA66B24BC0eBcC51E6b4";
const pEVRT = "0x451D00AF6E751537a9A2cFF40CdFB1119cd1fA7d";

const pool2Contracts = [
  //EVRT/LYD Contract
  "0xE34E22bC053D529c649EA3808Bbc1caA43687cdb",
  //EVRT/AVAX Contract
  "0xD81Bbd31D6dA2b0D52f8c02B276940Be9423c1d3",
  //EVRT/AVAX Contract
  "0x6f34201abc4fFAA2d3C86563Bc603bc3c0BD8f7f",
  //EVRT/AVAX Contract
  "0xbA6B26AE795C68770A86C6D020e952B60a48da5f",
];
const pool2Lps = [
  //EVRT/LYD Lydia-LP
  "0x3b4656d0e149686fad8d1568898beed1e2d16998",
  //EVRT/AVAX Lydia-LP
  "0x26bbbf5104f99dd1d6e61ff54980e78edcb0ba29",
  //EVRT/AVAX JLP
  "0xfda31e6c2bae47f9e7bd9f42933ace1d28ff537b",
  //EVRT/AVAX PGL
  "0x7ece5fc08050f8007188897c578483aabd953bc2",
];

async function Staking(chainBlocks) {
  const balances = {};

  let transformAddress = await transformAvaxAddress();

  await sumTokensAndLPsSharedOwners(
    balances,
    [[EVRT, false]],
    stakingContracts,
    chainBlocks["avax"],
    "avax",
    transformAddress
  );

  const balancepEVRT = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: pEVRT,
      params: stakingContracts[1],
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output;

  const totalBalance = BigNumber(balancepEVRT * 1.3403).toFixed(0)

  sdk.util.sumSingleBalance(balances, `avax:${EVRT}`, totalBalance);

  return balances;
}

module.exports = {
  deadFrom: 1648765747,
  avax: {
    staking: Staking,
    pool2: pool2s(pool2Contracts, pool2Lps, "avax"),
    tvl: async () => ({}),
  },
  methodology:
    "Counts liquidity on the Farms through their Contracts",
};

'''
'''--- projects/everipedia/index.js ---
const { staking } = require("../helper/staking");

const stakingContracthiIQ = "0x1bF5457eCAa14Ff63CC89EFd560E251e814E16Ba";
const IQ = "0x579cea1889991f68acc35ff5c3dd0621ff29b0c9";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(stakingContracthiIQ, IQ), 
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking only",
};

'''
'''--- projects/everlend/index.js ---
const axios = require('axios');
const retry = require('async-retry')

async function fetch() {
  const response = (
    await retry(
      async () => await axios.get('https://api.everlend.finance/api/v1/info')
    )
  ).data;

  return response.tvl;
}

module.exports = {
  timetravel: false,
  solana: {
    fetch
  },
  fetch,
};

'''
'''--- projects/everrise/abi.json ---
{
	"everRiseAddress": {
		"inputs": [],
		"name": "everRiseAddress",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"getStats": {
		"inputs": [],
		"name": "getStats",
		"outputs": [
			{
				"components": [
					{
						"internalType": "uint256",
						"name": "reservesBalance",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "liquidityToken",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "liquidityCoin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "staked",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "aveMultiplier",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "rewards",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "volumeTransfers",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "volumeBuy",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "volumeSell",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "volumeTrade",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "bridgeVault",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "tokenPriceCoin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "coinPriceStable",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "tokenPriceStable",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "marketCap",
						"type": "uint256"
					},
					{
						"internalType": "uint128",
						"name": "blockNumber",
						"type": "uint128"
					},
					{
						"internalType": "uint32",
						"name": "holders",
						"type": "uint32"
					},
					{
						"internalType": "uint8",
						"name": "tokenDecimals",
						"type": "uint8"
					},
					{
						"internalType": "uint8",
						"name": "coinDecimals",
						"type": "uint8"
					},
					{
						"internalType": "uint8",
						"name": "stableDecimals",
						"type": "uint8"
					},
					{
						"internalType": "uint8",
						"name": "multiplierDecimals",
						"type": "uint8"
					}
				],
				"internalType": "struct EverRiseStaked.Stats",
				"name": "stats",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"wrappedCoinAddress": {
		"inputs": [],
		"name": "wrappedCoinAddress",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}
'''
'''--- projects/everrise/index.js ---
const sdk = require('@defillama/sdk');
const http = require('../helper/http');
const BigNumber = require("bignumber.js");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { getChainTransform } = require("../helper/portedTokens");

const zeroAddress = '0x0000000000000000000000000000000000000000'
const BRIDGE_CONTROLLER = '0x0Dd4A86077dC53D5e4eAE6332CB3C5576Da51281';
const RESERVES = '0x78b939518f51b6da10afb3c3238Dd04014e00057';
const TOKEN = '0xC17c30e98541188614dF99239cABD40280810cA3';
const STAKE_HOLDING_API = 'https://app.everrise.com/bridge/api/v1/stats'
const chainConfig = {
  ethereum: {
    chainId: '1',
    LPs: [
      {
        owner: "0x78ab99dae7302ea91e36962f4b23418a89d3a69d", // EverOwn DAO Locked LP
        pool: "0x7250f7e97a4338d2bd72abc4b010d7a8477dc1f9",
      }, // RISE-ETH
    ],
    reserveTokens: [
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
      TOKEN,
    ],
  },
  bsc: {
    chainId: '56',
    LPs: [
      {
        owner: "0x89dd305ffbd8e684c77758288c48cdf4f4abe0f4", // EverOwn DAO Locked LP
        pool: "0x10dA269F5808f934326D3Dd1E04B7E7Ca78bb804",
      }, // RISE-BNB
    ],
    reserveTokens: [
      "0x55d398326f99059fF775485246999027B3197955", // USDT
      "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", // USDC
      "0xe9e7cea3dedca5984780bafc599bd69add087d56", // BUSD
      TOKEN,
    ],
  },
  polygon: {
    chainId: '137',
    LPs: [
      {
        owner: "0x7dd45e9be23219fd8ccfc584b652775aba62fdef", // EverOwn DAO Locked LP
        pool: "0xf3c62dbbfec92a2e73d676d62ebec06a6bc224e2",
      }, // RISE-MATIC
    ],
    reserveTokens: [
      "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", // USDT
      "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", // USDC
      TOKEN,
    ],
  },
  avax: {
    chainId: '43114',
    LPs: [
      {
        owner: "0x22a8e3f957fcdd4883cfcbc67c5e14cf2bb6477d", // EverOwn DAO Locked LP
        pool: "0x5472e98d22b0fb7ec5c3e360788b8700419370b5",
      }, // RISE-AVAX
    ],
    reserveTokens: [
      "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", // USDT
      "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", // USDC
      TOKEN,
    ],
  },
  fantom: {
    chainId: '250',
    LPs: [
      {
        owner: "0x59503632ab8a093c266509c797c957e063f4d32b", // EverOwn DAO Locked LP
        pool: "0xde62a6cdd8d5a3988495317cffac9f3fed299383",
      }, // RISE-FTM
    ],
    reserveTokens: [
      "0x04068da6c83afcfa0e13ba15a6696662335d5b75", // USDC
      TOKEN,
    ],
  },
}

async function staking(timestamp, block, chainId, chain, token) {

  const stakedAmounts = await ((await fetch(STAKE_HOLDING_API)).json());

  let stakedAmount = 0;
  for (let i = 0, ul = stakedAmounts.length; i < ul; i++) {
    if (stakedAmounts[i].id === chainId) {
      stakedAmount = BigNumber(stakedAmounts[i].amount).multipliedBy(BigNumber(10).pow(18));
    }
  }

  return stakedAmount;
}

const chainExports = {}

Object.keys(chainConfig).forEach(chain => {

  async function tvl(ts, _block, chainBlocks) {
    let balances = {}
    const block = chainBlocks[chain]
    const transformAddress = await getChainTransform(chain)

    const results = (await sdk.api.eth.getBalances({
      targets: [TOKEN, BRIDGE_CONTROLLER, RESERVES],
      chain, block
    }))

    for (const c of results.output)
      sdk.util.sumSingleBalance(balances, transformAddress(zeroAddress), c.balance)

    // Get reserve token balances
    let migrateBalances = (
      await sdk.api.abi.multiCall({
        calls: chainConfig[chain].reserveTokens.map((token) => ({
          target: token,
          params: RESERVES,
        })),
        abi: "erc20:balanceOf",
        block, chain,
      })
    ).output;

    migrateBalances.forEach((i) => {
      // Only include positive balances
      if (i.output > 0)
        balances[i.input.target] = i.output
    });

    return balances
  }

  async function pool2(ts, _block, chainBlocks) {
    let balances = {}
    const block = chainBlocks[chain]
    const transformAddress = await getChainTransform(chain)
    const { LPs } = chainConfig[chain]

    let lpPositions = [];
    let lpBalances = (
      await sdk.api.abi.multiCall({
        calls: LPs.map((p) => ({
          target: p.pool,
          params: p.owner,
        })),
        abi: "erc20:balanceOf",
        block, chain,
      })
    ).output;
    lpBalances.forEach((i) => {
      lpPositions.push({
        balance: i.output,
        token: i.input.target,
      });
    });
    await unwrapUniswapLPs(balances, lpPositions,  block, chain, transformAddress);
    return balances
  }

  async function staking() {
    const { chainId } = chainConfig[chain]
    const stakedAmounts = await http.get(STAKE_HOLDING_API)
    let stakedAmount = stakedAmounts.find(({ id }) => id === chainId)

    return {
      'everrise': stakedAmount ? stakedAmount.amount : 0
    }
  }

  chainExports[chain] = {
    tvl,
    pool2,
    staking,
  }
})

module.exports = {
  ...chainExports,
  timetravel: false,
  methodology: "TVL comes from the buyback reserves, other token migration vaults and cross-chain bridge vaults",
};
'''
'''--- projects/evmoswap/index.js ---
const sdk = require('@defillama/sdk');
const { getChainTransform} = require("../helper/portedTokens")
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const madDAI = "0x63743ACF2c7cfee65A5E356A4C4A005b586fC7AA"
const madUSDC = "0x51e44FfaD5C2B122C8b635671FCC8139dc636E82"
const madUSDT = "0x7FF4a56B32ee13D7D4D405887E0eA37d61Ed919e"
const madWETH = "0x5842C5532b61aCF3227679a8b1BD0242a41752f2"
const madWBTC = "0xF80699Dc594e00aE7bA200c7533a07C1604A106D"

//////////////////////////// UNI AMM ////////////////////////////////////
const evmoswapTvl = calculateUsdUniTvl(
  "0xF24E36e53628C3086493B9EfA785ab9DD85232EB",
  "evmos",
  "0xD4949664cD82660AaE99bEdc034a0deA8A0bd517",
  [ madDAI, madUSDC, madUSDT, madWETH, madWBTC ],
  "evmos"
);

//////////////////////////// STABLE AMM ////////////////////////////////////
const poolAddressesEvmos = [
  "0xf0a5b0fa1531C94754241911A2E6D94506336321", // 3pool
];

async function stableAMMTvl(timestamp, chainBlocks) {
  const balances = {};
  const transformAddress = await getChainTransform("evmos");
  await sumTokensAndLPsSharedOwners(
      balances,
      [
        [madDAI, false],
        [madUSDC, false],
        [madUSDT, false],
      ],
      poolAddressesEvmos,
      chainBlocks["evmos"],
      "evmos",
      transformAddress
  );
  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0xF24E36e53628C3086493B9EfA785ab9DD85232EB) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  evmos: {
    tvl: sdk.util.sumChainTvls([evmoswapTvl, stableAMMTvl]),
  },
}; // node test.js projects/evmoswap/index.js

'''
'''--- projects/evolutionland/index.js ---
const BigNumber = require('bignumber.js')
const sdk = require('@defillama/sdk')

const gold = {
  "ethereum": "0x358dBA28848cca268BA8a76B65E5b3eF9Ef92238",
  "heco": "0xFB371c8B99ba0b239E66E0a66bB6296b00dCD09f",
  "polygon": "0x56746a8099a7e6D962802A23e01FeDdc1282cDAe",
  "crab": "0x701A7d67B824D1Bc713FC5E77bE1C475Ec93106d",
}
const wood = {
  "ethereum": "0xD4B784Ae5c12153D11Ca55853d832D2a2D514a08",
  "heco": "0xcA3749C8C3aF04278D596a3fBe461481B6aa1b01",
  "polygon": "0xe97C7F83ec91E29569f1a08De95ad3Bb0e8B6B3A",
  "crab": "0xbA91F2d6d78953881A912f3DF71a541cD30eb980",
}
const hoo = {
  "ethereum": "0x19E22a73A046f19eCB51a46ACe4cA7A4bB7c20c6",
  "heco": "0x56746a8099a7e6D962802A23e01FeDdc1282cDAe",
  "polygon": "0x81989cD57271565DBFfe9807E917Afc098B30c9A",
  "crab": "0x54Eb408696E6b3Cc1795Caaf53B22F38F24200Fa",
}
const fire = {
  "ethereum": "0x8469A695D70033EcD170c82BE1253842162AA77e",
  "heco": "0xe97C7F83ec91E29569f1a08De95ad3Bb0e8B6B3A",
  "polygon": "0x8216981a3eF2b45C705119644D0D48AcF7d14472",
  "crab": "0xEd969c03e8881371754231FE1C8f1D4fE4AF2082",
}
const sioo = {
  "ethereum": "0x1320994fA466E19F17b143995999C7275EAe50E1",
  "heco": "0x81989cD57271565DBFfe9807E917Afc098B30c9A",
  "polygon": "0x2D8822a54fe8966891cEF3aC5A29d3B916393739",
  "crab": "0x9AC045F4B69C2DB58fDF70D4bEF8228ef5A2C5a8",
}
const ring = {
  "ethereum": "0x9469D013805bFfB7D3DEBe5E7839237e535ec483",
  "heco": "0x15e65456310ecb216B51EfBd8a1dBf753353DcF9",
  "polygon": "0x9C1C23E60B72Bc88a043bf64aFdb16A02540Ae8f",
  "crab": "0x7399Ea6C9d35124d893B8d9808930e9d3F211501",
}
const weth = {
  "ethereum": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "heco": "0x5545153CCFcA01fbd7Dd11C0b23ba694D9509A6F",
  "polygon": "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
  "crab": "0x2D2b97EA380b0185e9fDF8271d1AFB5d2Bf18329",
}

const lpGOLD = {
  "ethereum": "0x9504b4A2d5f2E88fD9a5D30AEe307573EA03Bea0",
  "heco": "0x8C318CD47D8DD944d969307B1249062197267564",
  "polygon": "0x2D489AeA7b643B49108dffd948891A4D88040ef1",
  "crab": "0x8e97f45bD127E7af3034d82a34d665746d348841",
}
const lpWOOD = {
  "ethereum": "0xf79e6890D3B78b5E04Ad405376C1064e3DAb0d85",
  "heco": "0x2Fbe5228a08260DB7bFed841cd4b340C88E13b9A",
  "polygon": "0x9686f71715134ccB38367849c049A58f6552C668",
  "crab": "0x3710F045307d7e0906F1Fbd0B0dF12c0Bc787382",
}
const lpHOO = {
  "ethereum": "0xdf2cdD051EF8835b25231f61dCeb5DF5F3A27274",
  "heco": "0xc8f8ba346781447a3e060eE913f56C2323fa83E5",
  "polygon": "0x98b0e9849D610394a29a0FC33476cA497315f1c3",
  "crab": "0xdb279D65225162280fACae2F3Ca8A3D2F63ea9BF",
}
const lpFIRE = {
  "ethereum": "0xd446E044d62392afED6bA4a40a0Ac8bdB0d91F07",
  "heco": "0xDD6F102f7044f5a8635AA9DaAC1483C5ce5265A3",
  "polygon": "0x90e3653a7aDb60E9184622B640dBf0A6EDA06858",
  "crab": "0x15f2fBD98a0657e2afcAB08922632e58B1cC9FdD",
}
const lpSIOO = {
  "ethereum": "0x31BF5eaA7C761871c83d9748b00a2277657cD6f5",
  "heco": "0x31BF5eaA7C761871c83d9748b00a2277657cD6f5",
  "polygon": "0xA1b2216DB6Dbb4fCead88180b753dA0EcC42b626",
  "crab": "0x1E4b46582bbA7E5Ddb107d3a640e441774980525",
}
const lpETH = {
  "ethereum": "0xa32523371390b0cc4e11f6bb236ecf4c2cdea101",
  "heco": "0x55C643AcA8b4cBaB1dBA05393fc0687bFbb9A98d",
  "polygon": "0x610A9007FD86C960ccB717783f88347A2c154D4E",
  "crab": "0xF157c9393255Db1728bC6483c3545Ca8a1655a0F",
}

async function crabTvl(timestamp, blocks) {
  let block = blocks["crab"];

  if (block === undefined) {
    block = (await sdk.api.util.lookupBlock(timestamp, { chain: "crab" }))
      .block;
  }
  const lps = [
    {
      "target": ring.crab,
      "params": lpGOLD.crab
    },
    {
      "target": ring.crab,
      "params": lpWOOD.crab
    },
    {
      "target": ring.crab,
      "params": lpHOO.crab
    },
    {
      "target": ring.crab,
      "params": lpFIRE.crab
    },
    {
      "target": ring.crab,
      "params": lpSIOO.crab
    },
    {
      "target": ring.crab,
      "params": lpETH.crab
    },
  ]
  let balances = await stakingBalanceTvl(timestamp, block, "crab", lps)
  balances[ring.ethereum] = balances[ring.crab] + '000000000'
  delete balances[ring.crab]
  return balances
}

async function polygonTvl(timestamp, blocks) {
  let block = blocks["polygon"];

  if (block === undefined) {
    block = (await sdk.api.util.lookupBlock(timestamp, { chain: "polygon" }))
      .block;
  }
  const lps = [
    {
      "target": ring.polygon,
      "params": lpGOLD.polygon
    },
    {
      "target": ring.polygon,
      "params": lpWOOD.polygon
    },
    {
      "target": ring.polygon,
      "params": lpHOO.polygon
    },
    {
      "target": ring.polygon,
      "params": lpFIRE.polygon
    },
    {
      "target": ring.polygon,
      "params": lpSIOO.polygon
    },
    {
      "target": ring.polygon,
      "params": lpETH.polygon
    },
  ]
  let balances = await stakingBalanceTvl(timestamp, block, "polygon", lps)
  balances[ring.ethereum] = balances[ring.polygon]
  delete balances[ring.polygon]
  return balances
}

async function hecoTvl(timestamp, blocks) {
  let block = blocks["heco"];

  if (block === undefined) {
    block = (await sdk.api.util.lookupBlock(timestamp, { chain: "heco" }))
      .block;
  }
  const lps = [
    {
      "target": ring.heco,
      "params": lpGOLD.heco
    },
    {
      "target": ring.heco,
      "params": lpWOOD.heco
    },
    {
      "target": ring.heco,
      "params": lpHOO.heco
    },
    {
      "target": ring.heco,
      "params": lpFIRE.heco
    },
    {
      "target": ring.heco,
      "params": lpSIOO.heco
    },
    {
      "target": ring.heco,
      "params": lpETH.heco
    },
  ]
  let balances = await stakingBalanceTvl(timestamp, block, "heco", lps)
  balances[ring.ethereum] = balances[ring.heco]
  delete balances[ring.heco]
  return balances
}

async function ethTvl(timestamp, blocks) {
  let block = blocks["ethereum"];

  const lps = [
    {
      "target": ring.ethereum,
      "params": lpGOLD.ethereum
    },
    {
      "target": ring.ethereum,
      "params": lpWOOD.ethereum
    },
    {
      "target": ring.ethereum,
      "params": lpHOO.ethereum
    },
    {
      "target": ring.ethereum,
      "params": lpFIRE.ethereum
    },
    {
      "target": ring.ethereum,
      "params": lpSIOO.ethereum
    },
    {
      "target": ring.ethereum,
      "params": lpETH.ethereum
    },
    {
      "target": weth.ethereum,
      "params": lpETH.ethereum
    },
  ]
  return await stakingBalanceTvl(timestamp, block, "ethereum", lps)
}

async function stakingBalanceTvl(timestamp, block, chain, lps) {

  const balancesOfResult = await sdk.api.abi.multiCall({
    calls: lps.map((lp) => ({
      target: lp.target,
      params: lp.params
    })),
    abi: 'erc20:balanceOf',
    block,
    chain
  })
  let balances = {}
  sdk.util.sumMultiBalanceOf(balances, balancesOfResult);
  return balances
}

module.exports = {
  ethereum: {
    tvl: ethTvl
  },
  heco: {
    tvl: hecoTvl
  },
  polygon: {
    tvl: polygonTvl
  },
  crab: {
    tvl: crabTvl
  },
}

'''
'''--- projects/excalibur/index.js ---
const {uniTvlExport} = require('../helper/calculateUniTvl')

function transformFantomAddress(addr){
  return ((addr) => {
    if(addr === "0x846e4d51d7e2043c1a87e0ab7490b93fb940357b"){ // UST address
      return 'ethereum:0xa693b19d2931d498c5b318df961919bb4aee87a5'
    }
    return `fantom:${addr}`;
  })
}

module.exports={
    fantom:{
        tvl: uniTvlExport("0x08b3CCa975a82cFA6f912E0eeDdE53A629770D3f", "fantom", transformFantomAddress)
    }
}

'''
'''--- projects/exinswap/index.js ---
const retry = require('async-retry');
const axios = require("axios");
const BigNumber = require("bignumber.js");

const APIs = {
  exinswap: 'https://app.exinswap.com/api/v1/statistic/total',
}

async function fetch() {
  const resp = await retry(async bail => await axios.get(APIs.exinswap))
  let result = new BigNumber(0);
  const tvl = resp.data.data.totalUsdtBalance;
  result = parseFloat(tvl);
  return result.toFixed(2);
}

module.exports = {
  fetch
}
'''
'''--- projects/exodia/index.js ---
const { sumTokens } = require("../helper/unwrapLPs");
const sdk = require('@defillama/sdk');
const { transformFantomAddress } = require("../helper/portedTokens");
const { request, gql } = require("graphql-request");

const ExodStaking = "0x8b8d40f98a2f14e2dd972b3f2e2a2cc227d1e3be"
const exod = "0x3b57f3feaaf1e8254ec680275ee6e7727c7413c7"
const wsexod = "0xe992C5Abddb05d86095B18a158251834D616f0D1"
const gohm = "0x91fa20244fb509e8289ca630e5db3e9166233fdc"
const mai = "0xfb98b335551a418cd0737375a2ea0ded62ea213b"
const treasury = "0x6a654d988eebcd9ffb48ecd5af9bd79e090d8347"
const dai = "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e"
const wftm = "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83"
const beetsvault = "0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce"
const poolid = "0xa216aa5d67ef95dde66246829c5103c7843d1aab000100000000000000000112"

function compareAddresses(a, b) {
  return a.toLowerCase() === b.toLowerCase();
}

const getPoolTokens = async (block) => {
  const poolTokens = (await sdk.api.abi.call({
    target: beetsvault,
    abi: {"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"}],"name":"getPoolTokens","outputs":[{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"balances","type":"uint256[]"},{"internalType":"uint256","name":"lastChangeBlock","type":"uint256"}],"stateMutability":"view","type":"function"},
    params: poolid,
    block,
    chain: 'fantom',
  })).output

  const output = {}

  poolTokens.tokens.forEach((t, i) => {
    if (compareAddresses(mai, t)) {
      output[mai] = Number(poolTokens.balances[i])
    } else if (compareAddresses(wftm, t)) {
      output[wftm] = Number(poolTokens.balances[i])
    } else if (compareAddresses(gohm, t)) {
      output[gohm] = Number(poolTokens.balances[i])
    } else if (compareAddresses(exod, t)) {
      output[exod] = Number(poolTokens.balances[i])
    } else if (compareAddresses(wsexod, t)) {
      output[wsexod] = Number(poolTokens.balances[i])
    }
  })

  const tokens = [mai, dai, wftm, gohm]

  const balances = (await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    calls: tokens.map(t => ({
      target: t,
      params: treasury,
    })),
    block,
    chain: 'fantom',          
  })).output

  balances.forEach((balance, idx) => {
    output[tokens[idx]] = output[tokens[idx]] ? output[tokens[idx]] + Number(balance.output) : Number(balance.output)
  })

  return output
}

const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const transformAddress = await transformFantomAddress();

  await sumTokens(balances, [[exod, ExodStaking]], chainBlocks.fantom, 'fantom', transformAddress)

  return balances;
};

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transformAddress = await transformFantomAddress();

  const treasuryBalances = await getPoolTokens(chainBlocks.fantom)
  const tokens = [mai, dai, wftm, gohm, exod, wsexod]

  tokens.forEach(token => {
    sdk.util.sumSingleBalance(balances, transformAddress(token), treasuryBalances[token])
  })
  
  return balances;
}

module.exports = {
  fantom: {
    tvl,
    staking
  },
  methodology:
    "Counts tokens on the treasury for TVL and staked EXOD for staking",
};
'''
'''--- projects/fabric/index.js ---
const sdk = require("@defillama/sdk");
const utils = require("../helper/utils");
const { toUSDTBalances } = require("../helper/balances");

const API_url = "https://api.fsynth.io/.netlify/functions/pools";

async function solonaTvl() {
  let totalLiquidityUSD = 0;

  (await utils.fetchURL(API_url)).data.data
    .filter((x) => x.hasEnded === false)
    .map((sup) => sup.liquidity)
    .forEach(function (sup) {
      totalLiquidityUSD += sup;
    });

  return toUSDTBalances(totalLiquidityUSD);
}

module.exports = {
  timetravel: false,
  solana: {
    tvl: () => ({}),
  },
  methodology:
    "Project is shutdown: https://twitter.com/crypto_notte/status/1545387251143741441/photo/1",
};

'''
'''--- projects/fairyswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  methodology: `Uses factory(0xA9a6E17a05c71BFe168CA972368F4b98774BF6C3) address and whitelisted tokens address to find and price Liquidity Pool pairs`,
  findora: {
    tvl: calculateUsdUniTvl(
      "0xA9a6E17a05c71BFe168CA972368F4b98774BF6C3",
      "findora",
      "0x0000000000000000000000000000000000001000",
      [
        "0x93EDFa31D7ac69999E964DAC9c25Cd6402c75DB3",
        "0x008A628826E9470337e0Cd9c0C944143A83F32f3",
        "0xABc979788c7089B516B8F2f1b5cEaBd2E27Fd78b",
        "0xdA33eF1A7b48beBbF579eE86DFA735a9529C4950",
        "0xE80EB4a234f718eDc5B76Bb442653827D20Ebb2d",
        "0x07EfA82E00E458ca3D53f2CD5B162e520F46d911"
      ],
      "findora"
    ),
  },
};
'''
'''--- projects/fantOHM/BalancerVaultBeets.json ---
{
  "getPoolTokens" : {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "poolId",
        "type": "bytes32"
      }
    ],
    "name": "getPoolTokens",
    "outputs": [
      {
        "internalType": "contract IERC20[]",
        "name": "tokens",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "balances",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256",
        "name": "lastChangeBlock",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/fantOHM/BalancerWeightedPoolBeets.json ---
{
  "totalSupply" : {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/fantOHM/MasterChefBeets.json ---
{
	"userInfo" : {
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "userInfo",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "rewardDebt",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"pendingBeets" : {
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_pid",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "_user",
				"type": "address"
			}
		],
		"name": "pendingBeets",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "pending",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}

'''
'''--- projects/fantOHM/index.js ---
const sdk = require("@defillama/sdk");
const {staking} = require("../helper/staking");
const {sumTokensAndLPsSharedOwners} = require("../helper/unwrapLPs");
const index = require('./index.json')
const MasterChefBeets = require('./MasterChefBeets.json')
const BalancerVaultBeets = require('./BalancerVaultBeets.json')
const BalancerWeightedPoolBeets = require('./BalancerWeightedPoolBeets.json')
const {default: BigNumber} = require("bignumber.js");

const fantomFhm = "0xfa1FBb8Ef55A4855E5688C0eE13aC3f202486286";
const fantomStaking = "0xcb9297425C889A7CbBaa5d3DB97bAb4Ea54829c2";
const fantomTreasuryContract = "0xA3b52d5A6d2f8932a5cD921e09DA840092349D71";
const moonriverFhm = "0xfa1FBb8Ef55A4855E5688C0eE13aC3f202486286";
const moonriverStaking = "0xF5C7D63C5Fc0aD4b7Cef7d8904239860725Ebc87";
const moonriverTreasuryContract = "0x5E983ff70DE345de15DbDCf0529640F14446cDfa";
const ethTreasuryContract = "0x9042E869BedCD2BB3EEa241aC0032cadAE8DF006";

// addreses of gnosis safe's according to: https://fantohm.com/#security
const fantomGnosisContract = "0x34F93b12cA2e13C6E64f45cFA36EABADD0bA30fC";
const moonriverGnosisContract = "0xE3CD5475f18a97D3563307B4e1A6467470237927";
const ethGnosisContract = "0x66a98CfCd5A0dCB4E578089E1D89134A3124F0b1";
const bscGnosisContract = "0x3538Acb37Cf5a92eBE7091714975b2f8dDd5c6C1";
const fantohmDaoDeployerWallet = "0x3381e86306145b062cEd14790b01AC5384D23D82";

const ethTradfi3mContract = "0xCD8A46dC7EE4488b441Ae1CD3b5BCa48d5389C12";
const ethTradfi6mContract = "0xD9fDd86ecc03e34DAf9c645C40DF670406836816";
const ftmTradfi3mContract = "0xEFbe7fe9E8b407a3F0C0451E7669E70cDD0C4C77";
const ftmTradfi6mContract = "0xB1c77436BC180009709Be00C9e852246476321A3";
const masterChefContract = "0x4897EB3257A5391d80B2f73FB0748CCd4150b586";

//
// Moonriver TVL should consist of - treasury value and investments on gnosis safe
//
const movr_transforms = {
	"0x748134b5f553f2bcbd78c6826de99a70274bdeb3": "ethereum:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
	"0xe936caa7f6d9f5c9e907111fcaf7c351c184cda7": "ethereum:0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
	"0xfa1fbb8ef55a4855e5688c0ee13ac3f202486286": "fantom:0xfa1FBb8Ef55A4855E5688C0eE13aC3f202486286", // FHM
}

async function moonriverTvl(timestamp, block, chainBlocks) {
	let balances = {};

	// treasury value
	await sumTokensAndLPsSharedOwners(balances, [
				["0x748134b5f553f2bcbd78c6826de99a70274bdeb3", false], // USDC.m
				["0xE936CAA7f6d9F5C9e907111FCAf7c351c184CDA7", false], // USDT.m
				["0x0b6116bb2926d996cdeba9e1a79e44324b0401c9", true], // HB LP
			], [moonriverTreasuryContract], block, "moonriver",
			addr => (movr_transforms[addr.toLowerCase()] ? movr_transforms[addr.toLowerCase()] : `moonriver:${addr}`));

	// investments
	await Promise.all([
		balanceOf(moonriverGnosisContract, "0x98878B06940aE243284CA214f92Bb71a2b032B8A", "moonriver:0x98878B06940aE243284CA214f92Bb71a2b032B8A", balances, chainBlocks.moonriver, "moonriver"), // wMOVR
	]);

	return balances;
}

//
// Fantom TVL should consist of - treasury value and investments on gnosis safe
//
const fantom_transforms = {
	"0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e": "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
	"0x04068DA6C83AFCFA0e13ba15A6696662335D5B75": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
}

async function fantomTvl(timestamp, block, chainBlocks) {
	let balances = {};

	// treasury value
	await sumTokensAndLPsSharedOwners(balances, [
				["0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e", false], // DAI
				["0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83", false], // wFTM
				["0x6fc9383486c163fa48becdec79d6058f984f62ca", false], // USDB
				["0x04068DA6C83AFCFA0e13ba15A6696662335D5B75", false], // USDC
				["0xd77fc9c4074b56ecf80009744391942fbfddd88b", true],  // DAI/FHM
			], [fantomTreasuryContract], block, "fantom",
			addr => (fantom_transforms[addr.toLowerCase()] ? fantom_transforms[addr.toLowerCase()] : `fantom:${addr}`))

	// treasury values
	await Promise.all([
		balanceOfStablePool(fantomTreasuryContract, "0xD5E946b5619fFf054c40D38c976f1d06C1e2fA82", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", "fantom:0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e", balances, block), // USDB-DAI stable pool
	]);

	// investments
	await Promise.all([
		balanceOf(fantomGnosisContract, "0x6fc9383486c163fa48becdec79d6058f984f62ca", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block), // USDB
		balanceOf(fantomGnosisContract, "0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E", "0x6b175474e89094c44da98b954eedeac495271d0f", balances, block), // DAI
		beetsFtm_BeetsLp(fantohmDaoDeployerWallet, balances, block), // beets/wftm LP
		lqdrFtm_BeetsLp(fantohmDaoDeployerWallet, balances, block), // lqdr/wftm LP
	]);

	// usdbalance.com
	await Promise.all([
		balanceOf(ftmTradfi3mContract, "0x6fc9383486c163fa48becdec79d6058f984f62ca", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block), // USDB
		balanceOf(ftmTradfi6mContract, "0x6fc9383486c163fa48becdec79d6058f984f62ca", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block), // USDB

		balanceOfStablePool(masterChefContract, "0xD5E946b5619fFf054c40D38c976f1d06C1e2fA82", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", "fantom:0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e", balances, block), // USDB-DAI stable pool
	]);

	return balances;
}

//
// ETH TVL consists of investments on gnosis safe
//
async function ethTvl(timestamp, block, chainBlocks) {
	let balances = {};

	// investments
	await Promise.all([
		balanceOf(ethGnosisContract, "0xd2877702675e6cEb975b4A1dFf9fb7BAF4C91ea9", "ethereum:0xd2877702675e6cEb975b4A1dFf9fb7BAF4C91ea9", balances, block, "ethereum"), // wLUNA
		balanceOf(ethGnosisContract, "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", "ethereum:0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", balances, block, "ethereum"), // wBTC
		balanceOf(ethGnosisContract, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "ethereum:0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", balances, block, "ethereum"), // wETH
		balanceOf(ethGnosisContract, "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0", "ethereum:0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0", balances, block, "ethereum"), // MATIC
		balanceOf(ethGnosisContract, "0x940a2db1b7008b6c776d4faaca729d6d4a4aa551", "ethereum:0x940a2db1b7008b6c776d4faaca729d6d4a4aa551", balances, block, "ethereum"), // DUSK
	]);

	// usdbalance.com
	await Promise.all([
		balanceOf(ethGnosisContract, "0x02B5453D92B730F29a86A0D5ef6e930c4Cf8860B", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block, "ethereum"), // USDB
		balanceOf(ethGnosisContract, "0x6b175474e89094c44da98b954eedeac495271d0f", "ethereum:0x6b175474e89094c44da98b954eedeac495271d0f", balances, block, "ethereum"), // DAI

		balanceOf(ethTreasuryContract, "0x02B5453D92B730F29a86A0D5ef6e930c4Cf8860B", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block, "ethereum"), // USDB

		balanceOf(ethTradfi3mContract, "0x02B5453D92B730F29a86A0D5ef6e930c4Cf8860B", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block, "ethereum"), // USDB
		balanceOf(ethTradfi6mContract, "0x02B5453D92B730F29a86A0D5ef6e930c4Cf8860B", "fantom:0x6fc9383486c163fa48becdec79d6058f984f62ca", balances, block, "ethereum"), // USDB
	]);

	return balances;
}

//
// BOBA TVL consists of investment on FantOHM DAO Deployer wallat
//
async function bobaTvl(timestamp, block, chainBlocks) {
	let balances = {};

	// BOBA
	const balance = (await sdk.api.erc20.balanceOf({
		chain: "boba",
		block: chainBlocks.boba,
		target: "0xa18bf3994c0cc6e3b63ac420308e5383f53120d7",
		owner: fantohmDaoDeployerWallet,
	})).output;

	sdk.util.sumSingleBalance(balances, `ethereum:0x42bbfa2e77757c645eeaad1655e0911a7553efbc`, balance);

	return balances;
}

//
// BSC TVL consists of investment on gnosis safe
//
async function bscTvl(timestamp, block, chainBlocks) {
	let balances = {};

	// DOT
	let balance = (await sdk.api.erc20.balanceOf({
		chain: "bsc",
		block: chainBlocks.bsc,
		target: "0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402",
		owner: bscGnosisContract,
	})).output;

	sdk.util.sumSingleBalance(balances, `bsc:0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402`, balance);
	return balances;
}

async function balanceOf(owner, ca, countAsCa, balances, block, chain="fantom") {
	const balance = (await sdk.api.erc20.balanceOf({
		chain: chain,
		block: block,
		target: ca,
		owner: owner,
	})).output;

	sdk.util.sumSingleBalance(balances, countAsCa, balance);
}

async function balanceOfStablePool(owner, ca, countHalfAsCa1, countHalfAsCa2, balances, block, chain="fantom") {
	const balance = (await sdk.api.erc20.balanceOf({
		chain: chain,
		block: block,
		target: ca,
		owner: owner,
	})).output;

	const half = BigNumber(Math.floor(balance / 2));

	sdk.util.sumSingleBalance(balances, countHalfAsCa1, half.toString(10));
	sdk.util.sumSingleBalance(balances, countHalfAsCa2, BigNumber(balance).minus(half.toString(10)).toString(10));
}

async function beetsFtm_BeetsLp(owner, balances, block) {
	const beetsMasterChef = "0x8166994d9ebBe5829EC86Bd81258149B87faCfd3";
	const beetsVault = "0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce";
	const beetsBalancerWeightedPool = "0xcde5a11a4acb4ee4c805352cec57e236bdbc3837";
	const poolId = "0xcde5a11a4acb4ee4c805352cec57e236bdbc3837000200000000000000000019";

	const beets = "0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e";
	const wftm = "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83";

	const fBeetsBalance = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsMasterChef,
		abi: MasterChefBeets.userInfo,
		params: [22, owner],
	})).output[0];

	const beetsPendingBalance = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsMasterChef,
		abi: MasterChefBeets.pendingBeets,
		params: [22, owner],
	})).output;

	const beetsBalance = (await sdk.api.erc20.balanceOf({
		chain: "fantom",
		block: block,
		target: beets,
		owner: owner,
	})).output;

	const totalSupply = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsBalancerWeightedPool,
		abi: BalancerWeightedPoolBeets.totalSupply,
	})).output;

	const poolTokens = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsVault,
		abi: BalancerVaultBeets.getPoolTokens,
		params: [poolId],
	})).output[1];

	const bptBalance = new BigNumber(fBeetsBalance * 1.0152).toString(10);
	const beetsFtmShare = bptBalance / totalSupply;

	sdk.util.sumSingleBalance(balances, "fantom:"+beets, new BigNumber(poolTokens[1] * beetsFtmShare).plus(beetsPendingBalance).plus(beetsBalance).toString(10));
	sdk.util.sumSingleBalance(balances, "fantom:"+wftm, new BigNumber(poolTokens[0] * beetsFtmShare).toString(10));
}

async function lqdrFtm_BeetsLp(owner, balances, block) {
	const beetsMasterChef = "0x8166994d9ebBe5829EC86Bd81258149B87faCfd3";
	const beetsVault = "0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce";
	const beetsBalancerWeightedPool = "0x5E02aB5699549675A6d3BEEb92A62782712D0509";
	const poolId = "0x5e02ab5699549675a6d3beeb92a62782712d0509000200000000000000000138";

	const lqdr = "0x10b620b2dbAC4Faa7D7FFD71Da486f5D44cd86f9";
	const beets = "0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e";
	const wftm = "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83";

	const lqdrFtmBalance = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsMasterChef,
		abi: MasterChefBeets.userInfo,
		params: [36, owner],
	})).output[0];

	const beetsPendingBalance = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsMasterChef,
		abi: MasterChefBeets.pendingBeets,
		params: [36, owner],
	})).output;

	const totalSupply = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsBalancerWeightedPool,
		abi: BalancerWeightedPoolBeets.totalSupply,
	})).output;

	const poolTokens = (await sdk.api.abi.call({
		chain: "fantom",
		block: block,
		target: beetsVault,
		abi: BalancerVaultBeets.getPoolTokens,
		params: [poolId],
	})).output[1];

	const lqdrFtmShare = lqdrFtmBalance / totalSupply;

	sdk.util.sumSingleBalance(balances, "fantom:"+lqdr, new BigNumber(poolTokens[0] * lqdrFtmShare).toString(10));
	sdk.util.sumSingleBalance(balances, "fantom:"+wftm, new BigNumber(poolTokens[1] * lqdrFtmShare).toString(10));
	sdk.util.sumSingleBalance(balances, "fantom:"+beets, beetsPendingBalance);
}

module.exports = {
	fantom: {
		tvl: fantomTvl,
		staking: staking(fantomStaking, fantomFhm, "fantom")
	},
	moonriver: {
		tvl: moonriverTvl,
		staking: staking(moonriverStaking, moonriverFhm, "moonriver", "fantom:0xfa1FBb8Ef55A4855E5688C0eE13aC3f202486286")
	},
	ethereum: {
		tvl: ethTvl
	},
	bsc: {
		tvl: bscTvl
	},
	boba: {
		tvl: bobaTvl
	},
}

'''
'''--- projects/fantOHM/index.json ---
{
	"index": {
		"inputs": [],
		"name": "index",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}

'''
'''--- projects/fantasm/abi.json ---
{
  "bank": {
    "usableFtmBalance": {
      "inputs": [],
      "name": "usableCollateralBalance",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    }
  },
  "bankV1": {
    "usableFtmBalance": {
      "inputs": [],
      "name": "usableFtmBalance",
      "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
      "stateMutability": "view",
      "type": "function"
    }
  },
  "multiFeeDistribution": {
    "totalSupply": {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  }
}

'''
'''--- projects/fantasm/index.js ---
const Abis = require("./abi.json");
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");

const Contracts = {
  fantomV1: {
    wftm: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
    fsm: "0xaa621D2002b5a6275EF62d7a065A865167914801",
    bank: "0x880672AB1d46D987E5d663Fc7476CD8df3C9f937",
    multiFeeDistribution: "0x348634Ea9367690383716FbCa8f225366bbC5966",
    chef: "0x7aeE1FF33E1b7F6D874D488fb2533a79419ca240",
    lps: [
      "0x457C8Efcd523058dd58CF080533B41026788eCee", // FSM_FTM_LP
      "0x128aff18EfF64dA69412ea8d262DC4ef8bb3102d", // XFTM_FTM_LP
      "0xbEa8E843c0fD428f79a166EaE2671E3a8Cc39A0a", // FSM_XFTM_LP
    ],
  },
  fantom: {
    wftm: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
    fxm: "0x132b56763C0e73F95BeCA9C452BadF89802ba05e",
    bank: "0xa3B99CdFdDe2216AfB1D58D6108cC93fea413A76",
    multiFeeDistribution: "0xC4510604504Fd50f64499fF6186AEf1F740dE38B",
    chef: "0x9c09eA872582bA02E0008C4853eAA5199bF8D0a7",
    lps: [
      "0x664D417B404404268C4E571975B4eC77157B8aC4", // FXM_FTM_LP
      "0x215c8E1452681be980Bce575cF719029581Ef263", // FTMX_FTM_LP
    ],
  },
};

async function calcTvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.fantom;
  const chain = "fantom";

  const bankBalance = await sdk.api.abi.call({
    target: Contracts.fantom.bank,
    abi: Abis.bank.usableFtmBalance,
    chain: chain,
    block,
  });

  const bankBalanceV1 = await sdk.api.abi.call({
    target: Contracts.fantomV1.bank,
    abi: Abis.bankV1.usableFtmBalance,
    chain: chain,
    block,
  });

  return {
    [`fantom:${Contracts.fantom.wftm}`]:
      +bankBalance.output + +bankBalanceV1.output,
  };
}

async function calcStakingTvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.fantom;
  const chain = "fantom";

  const stakingData = await sdk.api.abi.call({
    target: Contracts.fantom.multiFeeDistribution,
    abi: Abis.multiFeeDistribution.totalSupply,
    chain: chain,
    block,
  });

  const stakingDataV1 = await sdk.api.abi.call({
    target: Contracts.fantomV1.multiFeeDistribution,
    abi: Abis.multiFeeDistribution.totalSupply,
    chain: chain,
    block,
  });

  return {
    [`fantom:${Contracts.fantom.fxm}`]: stakingData.output,
    [`fantom:${Contracts.fantomV1.fsm}`]: stakingDataV1.output,
  };
}

async function calcPool2(masterchef, lps, block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.map((p) => ({
        target: p,
        params: masterchef,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );
  return balances;
}

async function ftmPool2(timestamp, block, chainBlocks) {
  const farm = await calcPool2(
    Contracts.fantom.chef,
    Contracts.fantom.lps,
    chainBlocks.fantom,
    "fantom"
  );

  const farmV1 = await calcPool2(
    Contracts.fantomV1.chef,
    Contracts.fantomV1.lps,
    chainBlocks.fantom,
    "fantom"
  );
  return { ...farm, ...farmV1 };
}

module.exports = {
  fantom: {
    tvl: calcTvl,
    pool2: ftmPool2,
    staking: calcStakingTvl,
  },
};

'''
'''--- projects/fantom.js ---
const retry = require("./helper/retry");
const axios = require("axios");
const { GraphQLClient, gql } = require("graphql-request");
const BigNumber = require("bignumber.js");

async function fetch() {
  const endpoint = "https://xapi3.fantom.network/api";
  const graphQLClient = new GraphQLClient(endpoint);

  const query = gql`
    query getToken($token: Address!) {
      erc20Token(token: $token) {
        address
        name
        symbol
        decimals
        totalSupply
        totalDeposit
        totalDebt
      }
    }
  `;

  var tokens = [
    {
      address: "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
      symbol: "WFTM",
    },
    {
      address: "0x69c744d3444202d35a2783929a0f930f2fbb05ad",
      symbol: "SFTM",
    },
    {
      address: "0xad84341756bf337f5a0164515b1f6f993d194e1f",
      symbol: "FUSD",
    },
  ];

  let price_feed = await retry(
    async (bail) =>
      await axios.get(
        "https://api.coingecko.com/api/v3/simple/price?ids=fantom&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true"
      )
  );

  const wData = await graphQLClient.request(query, {
    token: tokens[0].address,
  });
  const sData = await graphQLClient.request(query, {
    token: tokens[1].address,
  });
  const fData = await graphQLClient.request(query, {
    token: tokens[2].address,
  });

  let tvl = new BigNumber(wData.erc20Token.totalDeposit)
    .plus(new BigNumber(sData.erc20Token.totalDeposit))
    .div(10 ** 18)
    .toNumber();
  const result = (
    tvl * price_feed.data.fantom.usd +
    new BigNumber(fData.erc20Token.totalSupply).div(10 ** 18).toNumber()
  ).toFixed(2);

  return result;
}

module.exports = {
  fetch,
};

'''
'''--- projects/fantompup/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0xCFD389eFCD11aB30933F46e493da08cE5ebAf233"
const fpup = "0x900825EA297c7c5D1F6fA54146849BC41EdDAf29"
const fPupFwingsFtmLP = "0xF0cE83239ac341941eDe0Fe9Acef8ae22d271709"
const fPupFwingsUsdcLP = "0xE2fA732C69F7Ca59944f8007d87c5906AFEb6b8F";
const fPupSpookyLP = "0xc2F40ba0cfdAe59E4E16727862C7a0f249fcAaF2";

async function tvl(timestamp, block, chainBlocks) {
    const balances = {}
    const transformAddress = await transformFantomAddress();
    await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [fpup, fPupFwingsFtmLP, fPupFwingsUsdcLP, fPupSpookyLP]);
    return balances;
}

module.exports = {
    methodology: "TVL includes all farms in MasterChef contract",
    fantom: {
        tvl,
        staking: staking(chef, fpup, "fantom"),
        pool2: pool2Exports(chef, [fPupFwingsFtmLP, fPupFwingsUsdcLP, fPupSpookyLP], "fantom"),
    },

}
'''
'''--- projects/farmersonly/index.js ---
const { default: axios } = require("axios");
const { toUSDTBalances } = require("../helper/balances");
const retry = require("../helper/retry");

const farmApi = "https://api.elision.farm/getFarmStats/harmony/farmersonlyfi";
const vaultApi = "https://api.elision.farm/getFarmStats/harmony/farmersonlyfi-vault";

async function getFarmTvl(category) {
  let { data: farms } = await retry(async (bail) => await axios.get(farmApi));
  let tvl = getTvl(farms, category);
  return tvl;
}

async function getVaultTvl(category) {
  let { data: vaults } = await retry(async (bail) => await axios.get(vaultApi));
  let tvl = getTvl(vaults, category);
  return tvl;
}

async function getTvl(data, category) {
  let tvl = 0;
  for (let i = 0; i < data.length; i++) {
    switch (category) {
      case "pool2":
        if (data[i].name.startsWith("FOX")) {
          tvl += data[i].farm_liquidity_usd;
        }
        break;
      case "staking":
        if (data[i].name === "FOX POOL") {
          return data[i].farm_liquidity_usd;
        }
        break;
      default:
        if (data[i].name !== "FOX POOL" && !data[i].name.startsWith("FOX")) {
          tvl += data[i].farm_liquidity_usd;
        }
        break;
    }
  }
  return tvl;
}

async function harmonyTvl() {
  let farmTvl = await getFarmTvl();
  let vaultTvl = await getVaultTvl();
  return toUSDTBalances(farmTvl + vaultTvl);
}

async function pool2() {
  let farmTvl = await getFarmTvl("pool2");
  let vaultTvl = await getVaultTvl("pool2");
  return toUSDTBalances(farmTvl + vaultTvl);
}

async function staking() {
  let farmTvl = await getFarmTvl("staking");
  let vaultTvl = await getVaultTvl("staking");
  return toUSDTBalances(farmTvl + vaultTvl);
}

module.exports = {
  harmony: {
    tvl: harmonyTvl,
    pool2,
    staking
  },
};

'''
'''--- projects/farmhero/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "address",
                "name": "want",
                "type": "address"
            },
            {
                "internalType": "enum HeroFarmV3.PoolType",
                "name": "poolType",
                "type": "uint8"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardTime",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accHEROPerShare",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "strat",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "symbol": {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/farmhero/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const {
  transformBscAddress,
  transformPolygonAddress,
  transformOkexAddress,
} = require("../helper/portedTokens");

// --- BSC Addresses ---
const masterChefContractBsc = "0xDAD01f1d99191a2eCb78FA9a007604cEB8993B2D";
const HERO = "0x9b26e16377ad29a6ccc01770bcfb56de3a36d8b2";

const stakingContractBsc = [
  // Staking + vesting
  "0x6626c38b1cc5693e6a415fD1790F31DCD38B551A",
  // Staking Pool 1
  "0xF306F74Cc0669f02f280282F8F043F0239c37B0E",
  // Staking Pool 2
  "0x2fed5c1d16dec8c29f28a241d59350cbec21ee18",
  // Staking Pool 3
  "0x4a1645deb84bcd2bdfd234b4be7750306638f566",
  // Staking Pool 4
  "0xe403baa1e35ac50f2b2cbe4124c85e9f2823f0d6",
  // Staking Pool 5
  "0xd00751ebe4c273dc42456a8ce88a79ad5e867d87",
  // Boardroom 1
  "0xAFDe7b2D6498F278C6E95059b15b6a41ba7eA1a8",
  // Boardroom 2
  "0xaa0863882b9387ff1114da8841204179B2C5dC60",
  masterChefContractBsc,
];

const excludePool2Bsc = [
  "0x35BC504e05fa91f17552A9c3a6A2E7E9651A0622",
  "0x4BcaA3bd33fF733a581dF027aAd1EBDbDDb55CC2",
  "0x2d9108475B4c0795727546caA8aa7b75D18779F9",
];

const pool2StratsBsc = [
  "0x9cC7B6Ec33a9c42CA301eBe47773B5221A8F2083",
  "0xCA162Ffc19Bc445F215Cc40C74398691DD723B14",
  "0x1e2FC439a4235ce680C33e82fD2488617e53c443",
];

// --- Polygon Addresses ---
const masterChefContractPolygon = "0x8e5860DF653A467D1cC5b6160Dd340E8D475724E";
const HONOR = "0xb82a20b4522680951f11c94c54b8800c1c237693";

const stakingContractPolygon = [
  // Staking + vesting
  "0x047e7D6E8f4b6dEBa0537A7c7e852C4272981075",
  // Staking Pool 1
  "0x253f5089165579b86ddcae96143f871c1ec79031",
  // Staking Pool 2
  "0xfc4bf0c319d62844d4aff048439e678d76471c28",
  // Staking Pool 3
  "0xd06c448ab1570143054703a2cd317681c3c31ae8",
  // Staking Pool 4
  "0x102a30579e56eca4a2ef1b27dca141786bab3a5c",
  // Staking Pool 5
  "0xe9b8f2c454125d2bbc5a93e297f5a846ed921ae6",
  // Staking Pool 6
  "0x4ef76bbe7f942c69e8e7961339ee70654efc97c7",
  // Staking Pool 7
  "0x78f4a1e514af96d72a25a40ae4ebf80bb25bf300",
  // Staking Pool 8
  "0x600ef4e67a09188868603db0f2f12cfc606d8512",
  // Staking Pool 9
  "0x5c6e0756615e4a951f8fe4b4b30cbf2ea6c50aeb",
  // Staking Pool 10
  "0x2645a5865b20be653deceb8729fdcf8930b3ffac",
  // Staking Pool 11
  "0x20058fa67761ee0929b63e0adfd6793f6fafb2e8",
  // Staking Pool 12
  "0xafb3dc6934cf9474c1d5b85058001710b8e8dcfa",
  // Boardroom 1
  "0xDCfc3b59b74567083A76308b6D84Aef483148689",
  // Boardroom 2
  "0xf9f8E6C33Cc5BD633D6E5494c52BA6D8f9aB6452",
  // Boardroom 3
  "0x376D053876fDb5601cb87a342eE200e86704da62",
  masterChefContractPolygon,
];

const excludePool2Polygon = [
  "0x46489f825f11d7473D20279699b108aCAA246e73",
  "0x4Bd5dF4300b7c5309cB1A0143e4A6d0184B878e1",
];

const pool2StratsPolygon = [
  "0xC0148789554b38052a5c53115662B89BA9C40508",
  "0x545Fbc2b724b3A1F6Ca0925C1CB6E9c1f41bA891",
];

// --- OKEX Addresses ---
const masterChefContractOkex = "0xDb457E7fA88C9818f6134afD673941fCE777F92F";
const GLORY = "0xC3BdFEe6186849D5509601045af4Af567A001C94";
const stakingContractOkex = [
  // Staking + Vesting
  "0x76eB6494158eE62f99112b6316BA4cBAA8eF6ad4",
  // Boardroom 1
  "0x659b4414Df05F2c53264887E1a06D202EB1B04DF",
  // Boardroom 2
  "0xa9ae07c4f1e953912b15bac72e52b9c548e7dc47",
  // Pool Staking 1
  "0x8c37cd30d64cc9360a9beae7c896e805cac3ef54",
  // Pool Staking 2
  "0x94af3e9d4d82275a833dd367420d34ec3b4cc07b",
  masterChefContractOkex,
];

const excludePool2Okex = [
  "0x04C3aF284BEd636dE5400ddB24d7698dB457CE34",
  "0x5f6D4ADDC1D00e8e8565c07425C12c6E2DCbACe3",
];

const pool2StratsOkex = [
  "0xecEC29CC2bBD46AeBD7f84d18d3A360cdCb58170",
  "0xfa065195657A07f9c9F0A0a5e16DcD0Dff4AF11a",
];

const calcTvl = async (
  balances,
  chain,
  block,
  masterchef,
  transformAddress,
  excludePool2
) => {
  const poolLength = (
    await sdk.api.abi.call({
      abi: abi.poolLength,
      target: masterchef,
      chain,
      block,
    })
  ).output;

  const lpPositions = [];

  for (let index = 0; index < poolLength; index++) {
    const strat = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: masterchef,
        params: index,
        chain,
        block,
      })
    ).output.strat;
   
    const want = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: masterchef,
        params: index,
        chain,
        block,
      })
    ).output.want;
  
    const strat_bal = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: want,
        params: strat,
        chain,
        block,
      })
    ).output;
  
    const symbol = (
      await sdk.api.abi.call({
        abi: abi.symbol,
        target: want,
        chain,
        block,
      })
    ).output;
 
    if (
      excludePool2.some((addr) => addr.toLowerCase() === want.toLowerCase()) ||
      symbol.includes("HC") ||
      symbol.includes("GC") ||
      symbol.includes("HERO") ||
      symbol.includes("HONOR")
    ) {
    } else if (symbol.includes("LP") || symbol.includes("UNI-V2")) {
      lpPositions.push({
        token: want,
        balance: strat_bal,
      });
    } else {
      sdk.util.sumSingleBalance(balances, `${chain}:${want}`, strat_bal);
    }
  }

  await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAddress);
};

const bscTvl = async (chainBlocks) => {
  const balances = {};

  const transformAddress = await transformBscAddress();

  await calcTvl(
    balances,
    "bsc",
    chainBlocks["bsc"],
    masterChefContractBsc,
    transformAddress,
    excludePool2Bsc
  );

  return balances;
};

const polygonTvl = async (chainBlocks) => {
  const balances = {};

  const transformAddress = await transformPolygonAddress();

  await calcTvl(
    balances,
    "polygon",
    chainBlocks["polygon"],
    masterChefContractPolygon,
    transformAddress,
    excludePool2Polygon
  );

  return balances;
};

const okexTvl = async (chainBlocks) => {
  const balances = {};

  const transformAddress = await transformOkexAddress();

  await calcTvl(
    balances,
    "okexchain",
    chainBlocks["okexchain"],
    masterChefContractOkex,
    transformAddress,
    excludePool2Okex
  );

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: bscTvl,
    staking: stakings(stakingContractBsc, HERO, "bsc"),
    pool2: pool2s(pool2StratsBsc, excludePool2Bsc, "bsc"),
  },
  polygon: {
    tvl: polygonTvl,
    staking: stakings(stakingContractPolygon, HONOR, "polygon"),
    pool2: pool2s(pool2StratsPolygon, excludePool2Polygon, "polygon"),
  },
  okexchain: {
    tvl: okexTvl,
    staking: stakings(stakingContractOkex, GLORY, "okexchain"),
    pool2: pool2s(pool2StratsOkex, excludePool2Okex, "okexchain"),
  },
  methodology:
    "We count liquidity on the Farms through MasterChef contracts",
};

'''
'''--- projects/farmton.js ---
const { masterChefExports } = require("./helper/masterchef")

const token = "0x4243cCC302A98B577678d87A53c75593199315A3";
const masterchef = "0x87F68799eB8fC579eDDC6381331882A3ee4e997e";

module.exports = {
    ...masterChefExports(masterchef, "fantom", token, false)
}; // node test.js projects/farmton.js
'''
'''--- projects/fastyield/abi.json ---
{
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "poolInfo",
    "outputs": [
      { "internalType": "contract IERC20", "name": "want", "type": "address" },
      { "internalType": "uint256", "name": "allocPoint", "type": "uint256" },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accNATIVEPerShare",
        "type": "uint256"
      },
      { "internalType": "address", "name": "strat", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "wantLockedTotal": {
    "inputs": [],
    "name": "wantLockedTotal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "symbol": {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/fastyield/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { stakings, staking } = require("../helper/staking");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformFantomAddress } = require("../helper/portedTokens");
// node test.js projects/fastyield/index.js
const NATIVE_CONTRACT = "0xe5AFC91CEA5df74748A2b07e1d48E4e01aacF52B";

const fantomTvl = async (timestamp, block, chainBlocks) => {
  const balances = {};

  const poolLenth = (
    await sdk.api.abi.call({
      abi: abi.poolLength,
      target: NATIVE_CONTRACT,
      chain: "fantom",
      block: chainBlocks["fantom"],
    })
  ).output;

  const lpPositions = [];

  for (let index = 2; index < poolLenth; index++) {
    const poolInfo = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: NATIVE_CONTRACT,
        params: index,
        chain: "fantom",
        block: chainBlocks["fantom"],
      })
    ).output;

    const wantBalance = (
      await sdk.api.abi.call({
        abi: abi.wantLockedTotal,
        target: poolInfo[4],
        chain: "fantom",
        block: chainBlocks["fantom"],
      })
    ).output;

    try {
      const symbol = (
        await sdk.api.abi.call({
          abi: abi.symbol,
          target: poolInfo[0],
          chain: "fantom",
          block: chainBlocks["fantom"],
        })
      ).output;

      if (symbol == "fWINGS-LP" || symbol == "spLP" || symbol == "SPIRIT-LP" || symbol == "dKnight-LP") {
        lpPositions.push({
          token: poolInfo[0],
          balance: wantBalance,
        });
      } else {
        sdk.util.sumSingleBalance(balances, `fantom:${poolInfo[0]}`, wantBalance);
      }
    } catch (err) {
      console.error(err);
    }
  }

  const transformAddress = await transformFantomAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["fantom"],
    "fantom",
    transformAddress
  );

  return balances;
};

async function pool2(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformFantomAddress();

  const lpBalance = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: '0xe836997c9f3665986580fe98f79999fa876fc271',
      params: '0xc0c84eFeB8290BA5Ac6bed682Cfdf2896cf26566',
      chain: "fantom",
      block: chainBlocks["fantom"],
    })
  ).output;

  await unwrapUniswapLPs(
    balances,
    [{balance: lpBalance, token: '0xe836997c9f3665986580fe98f79999fa876fc271' }],
    chainBlocks["fantom"],
    "fantom",
    transform
  );

  balances['0x4e15361fd6b4bb609fa63c81a2be19d873717870'] *= 2;
  delete balances['fantom:0x0299461ee055bbb6de11fafe5a0636a0c3bd5e8d'];
  return balances;
};
module.exports = {
  fantom: {
    tvl: fantomTvl,
    staking: stakings(['0x1Fb33cB822bD554890242F4765505FA6340B1Fb9'], '0x0299461ee055bbb6de11fafe5a0636a0c3bd5e8d', 'fantom'),
    pool2
  },
};

'''
'''--- projects/fatex/index.js ---
const { stakingUnknownPricedLP } = require('../helper/staking')
const { getUniTVL } = require('../helper/unknownTokens')

const FACTORY_CONTRACT = "0x937e0c67d21Df99eaEa0e6a1055A5b783291DC8f";
const FATE_TOKEN = "0x4853365bC81f8270D902076892e13F27c27e7266";
const FATE_USDC_PAIR_TOKEN = "0x69c894Dce6FA2E3b89D3111d29167F0484AC0b2A";
const X_FATE_TOKEN = "0x56BE76031A4614370fA1f188e01e18a1CF16E642";

module.exports = {
  polygon: {
    tvl: getUniTVL({
      factory: FACTORY_CONTRACT,
      chain: 'polygon',
      coreAssets: [
        '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // WMATIC
        '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC
        '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
        '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063', // DAI
      ],
    }),
    staking: stakingUnknownPricedLP(X_FATE_TOKEN, FATE_TOKEN, 'polygon', FATE_USDC_PAIR_TOKEN)
  },
}

'''
'''--- projects/fatfire/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const chef = "0xf908ed281f008eE3FcEaCfF2FdfbC2dADf213811"
const fatfire = "0xa5ee311609665Eaccdbef3BE07e1223D9dBe51de"

module.exports = {
  ...masterChefExports(chef, "fantom", fatfire, false),
} // node test.js projects/fatfire/index.js
'''
'''--- projects/fdoge/index.js ---
const { tombTvl } = require("../helper/tomb");

const token = "0xEb0a2D1b1a33D95204af5d00f65FD9e349419878";
const shares = "0xBda29437C8e5dC8BF6a2305D442A3742da7FB033";
const masonry = "0xDd1Fa691D2fd01FE9206b15350462b712B4AE371";
const rewardPool = "0x5331bE243A6AA35253b8bAe3E12157C6F5B61aDE";
const pool2LPs = [
    "0xd0EE9183F8717819c071bD3BDB77df37B7D4d16B", // FDOGE-WFTM spLP
    "0xbc9eF8F482ACf57CDa927f6Af39f5c513593aDFb", // SDOGE-WFTM spLP
];

module.exports = {
    deadFrom: 1648765747,
    misrepresentedTokens: true,
    ...tombTvl(token, shares, rewardPool, masonry, pool2LPs, "fantom", undefined, false, pool2LPs[1])
}

'''
'''--- projects/feederfinance/index.js ---
const axios = require("axios");
const retry = require("async-retry");
const { toUSDTBalances } = require("../helper/balances");

async function getPlatformData() {
  const response = await retry(async (_) =>
    axios.get("https://api.feeder.finance/v1/tvl")
  );
  return response.data;
}

async function staking() {
  return toUSDTBalances((await getPlatformData()).stakeTvlUsd);
}

async function pool2() {
  return toUSDTBalances((await getPlatformData()).farmTvlUsd);
}

async function bscTvl() {
  return toUSDTBalances((await getPlatformData()).bscVaultTvlUsd);
}

async function fantomTvl() {
  return toUSDTBalances((await getPlatformData()).fantomVaultTvlUsd);
}

async function tvl() {
  return toUSDTBalances((await getPlatformData()).totalVaultTvlUsd);
}

module.exports = {
  methodology:
    "All data is pulled from feeder's API. TVL counts the tokens deposited to the Vault strategies, Pool2 counts the deposits made to FEED farming and staking sums the deposits made to FEED staking.",
  misrepresentedTokens: true,
  bsc: {
    tvl:bscTvl,
    pool2,
    staking,
  },
  fantom: {
    tvl:fantomTvl,
  },
};

'''
'''--- projects/fees-wtf/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const WTF = "0xA68Dd8cB83097765263AdAD881Af6eeD479c4a33";
const stakingContract = "0x0bf0e1678eaa36cd2d705cab3ce8020de443056c";
const WTF_ETH_univ2 = '0xab293dce330b92aa52bc2a7cd3816edaa75f890b'
const WTF_ETH_univ2_staking = '0xf0c51dc9a85d00c1c1bebfbb2d1465a39f4702d8'

module.exports = {
  methodology: `TVL for fees.wtf consists of the staking of WTF and pool2 of uni-v2 WTF-WETH.`, 
  ethereum:{
    tvl: () => ({}),
    staking: staking(stakingContract, WTF, "ethereum"), 
    pool2: pool2(WTF_ETH_univ2_staking, WTF_ETH_univ2, "ethereum"), 
  }
}
'''
'''--- projects/fegex/index.js ---
const { staking } = require("../helper/staking");

const stakingContractETH = "0x4a9D6b95459eb9532B7E4d82Ca214a3b20fa2358";
const FEG_ETH = "0x389999216860ab8e0175387a0c90e5c52522c945";

const stakingContractBSC = "0xF8303c3ac316b82bCbB34649e24616AA9ED9E5F4";
const FEG_BSC = "0xacfc95585d80ab62f67a14c566c1b7a49fe91167";

module.exports = {
  timetravel:true,
  misrepresentedTokens: true,
  ethereum: {
    staking: staking(stakingContractETH, FEG_ETH)
  },
  bsc: {
    staking: staking(stakingContractBSC, FEG_BSC, "bsc"),
  },
  tvl: async ()=>({}),
  methodology:
    "We count liquidity of FEG token staked on ETHEREUM and BSC chains through their Staking Contracts",
};

'''
'''--- projects/fei/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs')

const weth = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'

async function tvl(timestamp, block) {
  const balances = {}
  const owners = [
    '0xBFfB152b9392e38CdDc275D818a3Db7FE364596b', // GenesisGroup.sol [OLD]
    '0xa08A721dFB595753FFf335636674D76C455B275C', // EthReserveStabilizer.sol [OLD]
    '0x17305f0e18318994a57b494078CAC866A857F7b6', // EthReserveStabilizer.sol
    '0xe1578B4a32Eaefcd563a9E6d0dc02a4213f673B7', // EthBondingCurve.sol [OLD]
    '0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F', // EthBondingCurve.sol
    '0xDa079A280FC3e33Eb11A78708B369D5Ca2da54fE', // EthPCVDripper.sol [OLD]

    // Holders of FEI-ETH Uni V2 LP 
    '0x15958381E9E6dc98bD49655e36f524D2203a28bD', // EthUniswapPCVDeposit.sol
    '0x5d6446880fcd004c851ea8920a628c70ca101117', // EthUniswapPCVDepost.sol [OLD]
    '0x9b0C6299D08fe823f2C0598d97A1141507e4ad86', // EthUniswapPCVDeposit.sol [OLD]

    // Holders of stETH
    '0xAc38Ee05C0204A1E119C625d0a560D6731478880', // EthLidoPCVDeposit.sol

    // Holders of aWETH
    '0x5B86887e171bAE0C2C826e87E34Df8D558C079B9', // AavePCVDeposit.sol

    // Holders of cETH
    '0x4fCB1435fD42CE7ce7Af3cB2e98289F79d2962b3', // EthCompoundPCVDeposit.sol  

    // Holders of cDAI
    '0xe0f73b8d76D2Ad33492F995af218b03564b8Ce20', // DaiCompoundPCVDeposit.sol

    // Holders of INDEX
    '0x0ee81df08B20e4f9E0F534e50da437D24491c4ee', // IndexSnapshotDelegator.sol

    // Holders of aRAI
    '0xd2174d78637a40448112aa6B30F9B19e6CF9d1F9', // AaveRaiPCVDeposit.sol

    // Holders of RAI in fuse pool 9
    '0x9aAdFfe00eAe6d8e59bB4F7787C6b99388A6960D', // RaiFusePcvDeposit.sol

    // Holders of FEI-DPI Sushi LP
    '0x902199755219A9f8209862d09F1891cfb34F59a3', // DpiSushiPcvDeposit.sol

    // Holders of DPI in Fuse pool 19
    '0x3dD3d945C4253bAc5B4Cc326a001B7d3f9C4DD66', // DpiFusePcvDeposit.sol
  ]
  await sumTokensAndLPsSharedOwners(balances, [
    ['0x94b0a3d511b6ecdb17ebf877278ab030acb0a878', true], // FEI-ETH Uni V2 LP (NOTE: this counts both FEI and ETH, but only the FEI doesn't count as PCV)
    ['0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84', false], // stETH
    ['0x030ba81f1c18d280636f32af80b9aad02cf0854e', false], // aWETH
    ['0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5', false], // cETH
    ['0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643', false], // cDAI
    ['0x0954906da0Bf32d5479e25f46056d22f08464cab', false], // INDEX
    ['0xc9BC48c72154ef3e5425641a3c747242112a46AF', false], // aRAI
    ['0x752F119bD4Ee2342CE35E2351648d21962c7CAfE', false], // RAI in Fuse pool 9
    ['0x8775aE5e83BC5D926b6277579c2B0d40c7D9b528', true], // FEI-DPI Sushi LP (NOTE: this counts both the FEI and the DPI, but only the FEI doesn't count as PCV)
    ['0xF06f65a6b7D2c401FcB8B3273d036D21Fe2a5963', false], // DPI in Fuse pool 19
  ], owners, block)
  const directETH = await sdk.api.eth.getBalances({
    targets: owners,
    block
  })
  directETH.output.forEach(eth => {
    sdk.util.sumSingleBalance(balances, weth, eth.balance)
  })
  return balances
}

module.exports = {
  timetravel: true,
  tvl
}
'''
'''--- projects/fenrirfinance/index.js ---
const {fullCoumpoundExports} = require('../helper/compound');

const replace = {
  "0x250632378e573c6be1ac2f97fcdf00515d0aa91b": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // beth->weth
  "0xfb6115445bff7b52feb98650c87f44907e58f802": "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9", // aave
}

module.exports = fullCoumpoundExports("0x56b4B49f31517be8DacC2ED471BCc20508A0e29D", "bsc", "0x444ADC2D487090A660ebFdDd934d0E962410d8Cc", "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", addr=>{
  return replace[addr.toLowerCase()] || `bsc:${addr}`
})

'''
'''--- projects/ferro/index.js ---
const { sumTokens2 } = require('../helper/unwrapLPs')
const { getBlock } = require('../helper/getBlock');

const threeFerPoolAddress = '0xe8d13664a42B338F009812Fa5A75199A865dA5cD';
const chain = 'cronos'

const tokens = {
  // DAI
  "0xF2001B145b43032AAF5Ee2884e456CCd805F677D": [
    threeFerPoolAddress,
  ],
  // USDC
  "0xc21223249CA28397B4B6541dfFaEcC539BfF0c59": [
    threeFerPoolAddress,
  ],
  // USDT
  "0x66e428c3f67a68878562e79A0234c1F83c208770": [
    threeFerPoolAddress,
  ],
};

async function tvl(timestamp, ethBlock, chainBlocks) {
  const block = await getBlock(timestamp, 'cronos', chainBlocks);
  const tokensAndOwners = Object.entries(tokens).map(([token, owners]) => owners.map(owner => [token, owner])).flat()
  return sumTokens2({ chain, block, tokensAndOwners })
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology: 'sum of ferro stablecoin pool contracts balance',
  start: 1651218360,
  cronos: {
    tvl,
  }
}

'''
'''--- projects/ferrum/index.js ---
const { stakings } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const stakingContracts = [
  //Staking v1.0
  "0x71f3e1a61c14d6f4b6d2a72a13fc6fe13d8a86a9",
  "0x16BBCf93a0f4bB27a15eE8937B58928D6158eBe9",
  "0x41ea5097f3ea49c00ccfb35e74763d29766daddf",
  //Staking v2.0
  "0x45972d73d35a315c0d8357846303209991b84ccb",
  "0xeee410b42bc3a71271f191579858cf7e3cbb2e70",
  "0xbD5c104AD40EF137D6810E6CCC0b2b7185410374",
  "0x143D7eE3Fab601264248C2C3F45bE430451e353f",
  //Staking v3.0
  "0x4eccea6360a4fc63ab4b37d4895bcc64e40cd9c4",
  "0xa9ac39abc7fcfac10321ceba05050f099afb8042",
  "0x840f8f2978521cafa659f390532de235633a15ec",
  "0x1f4bccd90c65135e17287058b667c0a004f443cd",
  //Staking v3.1
  "0x08cd09c8e42edffefc56c7fe33c547701fccb5c9",
  "0x34fc4e1b8456ea8340902f3d7168c536db5b977d",
  //Staking iron mountain
  "0x96add70053eac0534899c4c51e818add70d96f7a",
  "0x3844a75a2d81f7da0af24ef996b17ce0a18de361",
  "0x2a300082aafe41509e3465447c6a3ac08556e5d7",
];

const FRM = "0xE5CAeF4Af8780E59Df925470b050Fb23C43CA68C";

const stakingPoolContract = "0x11E075725d061DeB6981b19C4ea30983B4E2e070";
const FRM_DFYN_LP = "0x0C77b6682b6fFfFe9599B41E39eBa1c1bCf923D8";

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking: stakings(stakingContracts, FRM),
  },
  polygon: {
    pool2: pool2(stakingPoolContract, FRM_DFYN_LP, "polygon"),
  },
  tvl: (async) => ({}),
  methodology: "Counts liquidty on the staking and pool2 only",
};

'''
'''--- projects/fiatdao/abi.json ---
{
    "underlierToken": {
        "inputs": [],
        "name": "underlierToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "tokenScale": {
        "inputs": [],
        "name": "tokenScale",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "fairPrice": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "net",
                "type": "bool"
            },
            {
                "internalType": "bool",
                "name": "face",
                "type": "bool"
            }
        ],
        "name": "fairPrice",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/fiatdao/index.js ---
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");
const { fetchURL } = require("../helper/utils");
const sdk = require("@defillama/sdk")
const abi = require('./abi.json');
const { default: BigNumber } = require("bignumber.js");

const fdt = "0xed1480d12be41d92f36f5f7bdd88212e381a3677";
const comitium = "0x4645d1cF3f4cE59b06008642E74E60e8F80c8b58";

const stakingNft = "0xE9F9936a639809e766685a436511eac3Fb1C85bC";
const fdtGohm = "0x75b02b9889536B617d57D08c1Ccb929c523945C1";

const stakingContract = "0xe98ae8cD25CDC06562c29231Db339d17D02Fd486";
const wSOhm = "0xca76543cf381ebbb277be79574059e32108e3e65";
const rgt = "0xD291E7a03283640FDc51b121aC401383A46cC623";
const yfi = "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e";
const mkr = "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2";
const bond = "0x0391D2021f89DC339F60Fff84546EA23E337750f";
const uma = "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828";
const wsohmFdtSLP = "0x2e30e758b3950dd9afed2e21f5ab82156fbdbbba";

const gOhm = "0x0ab87046fbb341d058f17cbc4c1133f25a20a52f";

async function tvl(timestamp, block) {
  const balances = {};
  // liquidity mining
  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [wSOhm, false],
      [rgt, false],
      [yfi, false],
      [mkr, false],
      [bond, false],
      [uma, false],
      [wsohmFdtSLP, true],
      [fdtGohm, true],
    ],
    [stakingContract, stakingNft],
    block,
    "ethereum",
    (addr) => {
      if (addr.toLowerCase() === "0xca76543cf381ebbb277be79574059e32108e3e65") {
        return gOhm;
      }
      return addr;
    }
  );

  // v1
  const vaults = Object.entries((await fetchURL("https://raw.githubusercontent.com/fiatdao/changelog/main/deployment/deployment-mainnet.json")).data)
    .filter((e)=>e[0].startsWith("vaultEPT") && !e[0].endsWith("Actions")).map(e=>e[1].address)
  await Promise.all(vaults.map(async vault=>{
    // would be better to use multicall but im lazy
    const token = await sdk.api.abi.call({target:vault, block, abi: abi.token})
    if(token.output==="0x0000000000000000000000000000000000000000"){
      return
    }
    const tokenBalance = await sdk.api.erc20.balanceOf({target: token.output, owner: vault, block})
    const underlier = await sdk.api.abi.call({target:vault, block, abi: abi.underlierToken})
    const price = await sdk.api.abi.call({target:vault, block, abi: abi.fairPrice, params: [0, false, false]})

    sdk.util.sumSingleBalance(balances, underlier.output ==="0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA" ?"0x5f98805a4e8be255a32880fdec7f6728c6568ba0":underlier.output, 
      BigNumber(tokenBalance.output).times(price.output).div(1e18)
    .toFixed(0));
  }))

  return balances;
}

module.exports = {
  methodology:
    "TVL includes value of Rewards Pools and staking includes FDT staked in Senatus",
  ethereum: {
    tvl,
    staking: staking(comitium, fdt),
  },
};

'''
'''--- projects/filda/abi.json ---
{
  "markets": {
    "constant":true,
    "inputs":[
      {
        "name":"",
        "type":"address"
      }
    ],
    "name":"markets",
    "outputs":[
      {
        "name":"isSupported",
        "type":"bool"
      },
      {
        "name":"blockNumber",
        "type":"uint256"
      },
      {
        "name":"interestRateModel",
        "type":"address"
      },
      {
        "name":"totalSupply",
        "type":"uint256"
      },
      {
        "name":"supplyRateMantissa",
        "type":"uint256"
      },
      {
        "name":"supplyIndex",
        "type":"uint256"
      },
      {
        "name":"totalBorrows",
        "type":"uint256"
      },
      {
        "name":"borrowRateMantissa",
        "type":"uint256"
      },
      {
        "name":"borrowIndex",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "totalBorrows": {
    "constant":true,
    "inputs":[

    ],
    "name":"totalBorrows",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "borrowRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"borrowRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "supplyRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"supplyRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6f307dc3"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "signature": "0x3b1d21a2",
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xb0772d0b"
  }
}

'''
'''--- projects/filda/index.js ---

const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const { getBlock } = require('../helper/getBlock')
const { unwrapUniswapLPs } = require('../helper/unwrapLPs')
const { compoundExportsWithDifferentBase, compoundExports } = require('../helper/compound');

const comptroller = "0xb74633f2022452f377403B638167b0A135DB096d"

// ask comptroller for all markets array
async function getAllCTokens(block) {
  return (await sdk.api.abi.call({
    block,
    chain: 'heco',
    target: comptroller,
    params: [],
    abi: abi['getAllMarkets'],
  })).output;
}

async function getUnderlying(block, cToken) {
  if (cToken === '0x824151251B38056d54A15E56B73c54ba44811aF8') {
    return '0x6f259637dcd74c767781e37bc6133cd6a68aa161';//cHT => HT
  } else {
    const token = (await sdk.api.abi.call({
      block,
      chain: 'heco',
      target: cToken,
      abi: abi['underlying'],
    })).output;
    return token
  }
}

function transformAddress(token){
  if(token === '0x6f259637dcd74c767781e37bc6133cd6a68aa161'){
    return token
  } else if (token === '0x3D760a45D0887DFD89A2F5385a236B29Cb46ED2a') {
    return '0x6b175474e89094c44da98b954eedeac495271d0f';//DAI => DAI
  } else if (token === '0x9362Bbef4B8313A8Aa9f0c9808B80577Aa26B73B') {
    return '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';//USDC => USDC
  } else if (token === "0x5eE41aB6edd38cDfB9f6B4e6Cf7F75c87E170d98"){
    return "0x0000000000085d4780b73119b644ae5ecd22b376" //TUSD
  } else {
    return 'heco:' + token
  }
}

// returns {[underlying]: {cToken, decimals, symbol}}
async function getMarkets(block) {
  let allCTokens = await getAllCTokens(block);
  const markets = []
  await (
    Promise.all(allCTokens.map(async (cToken) => {
      let underlying = await getUnderlying(block, cToken);
      markets.push({ underlying, cToken })
    }))
  );

  return markets;
}

const replacements = {
  "0xc2CB6B5357CcCE1B99Cd22232942D9A225Ea4eb1": {
    coingecko: "bitcoin-cash-sv",
    decimals: 1e18
  },
  //"heco:0x581EdD7eAb23896513360D7EE8DfE07A5Cad2aBd": "tether",
  "0x6514a5Ebff7944099591Ae3e8A5c0979C83B2571": {
    coingecko: "neo",
    decimals: 1e8
  },
  "0x45e97daD828AD735af1dF0473fc2735F0Fd5330c": {
    coingecko: "tezos",
    decimals: 1e18,
  }
}
function lending(borrowed) {
  return async (timestamp, ethBlock, chainBlocks) => {
    let balances = {};
    const block = await getBlock(timestamp, 'heco', chainBlocks, true)
    let markets = await getMarkets(block);

    let v2Locked = await sdk.api.abi.multiCall({
      block,
      calls: markets.map((market) => ({
        target: market.cToken,
      })),
      chain: 'heco',
      abi: borrowed ? abi.totalBorrows : abi['getCash'],
    });

    const symbols = await sdk.api.abi.multiCall({
      block,
      calls: markets.map((market) => ({
        target: market.cToken,
      })),
      chain: 'heco',
      abi: "erc20:symbol",
    });

    const lps = []
    markets.forEach((market, idx) => {
      let getCash = v2Locked.output.find((result) => result.input.target === market.cToken);
      const symbol = symbols.output.find((result) => result.input.target === market.cToken);
      if (getCash.output === null) {
        throw new Error("getCash failed")
      }
      if (symbol.output.endsWith("LP")) {
        lps.push({
          token: market.underlying,
          balance: getCash.output
        })
      } else {
        const replacement = replacements[market.underlying]
        if (replacement === undefined) {
          sdk.util.sumSingleBalance(balances, transformAddress(market.underlying), getCash.output)
        } else {
          sdk.util.sumSingleBalance(balances, replacement.coingecko, Number(getCash.output) / replacement.decimals)
        }
      }
    });
    
    await unwrapUniswapLPs(balances, lps, block, "heco", transformAddress)
    return balances;
  }
}

// DANGER!! Oracles are not priced against USD but against other base tokens, such as IOTX
module.exports = {
  timetravel: true, // Impossible because getBlock will rug tho
  heco: {
    tvl: lending(false),
    borrowed: lending(true)
  },
  iotex: compoundExportsWithDifferentBase("0x55E5F6E48FD4715e1c05b9dAfa5CfD0B387425Ee", "iotex", "iotex"),
  bsc: compoundExports("0xF0700A310Cb14615a67EEc1A8dAd5791859f65f1", "bsc"),
  polygon: compoundExports("0xfBE0f3A3d1405257Bd69691406Eafa73f5095723", "polygon"),
  arbitrum: compoundExports("0xF67EF5E77B350A81DcbA5430Bc8bE876eDa8D591", "arbitrum"),
  elastos: compoundExportsWithDifferentBase("0xE52792E024697A6be770e5d6F1C455550265B2CD", "elastos", "elastos"),
};

'''
'''--- projects/filet/index.js ---
const retry = require('async-retry');
const axios = require('axios');

async function fetch() {
  const resp = await retry(
    async () =>
      await axios.get('https://www.filet.finance/pledge/ext/tx/pledgeTxAll')
  );
  return resp.data.data.tvl;
}

module.exports = {
  fetch,
};

'''
'''--- projects/finnexus/abi.json ---
{
    "getPrice": {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "asset",
                "type": "address"
            }
        ],
        "name": "getPrice",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getTotalCollateral": {
        "constant": true,
        "inputs": [],
        "name": "getTotalCollateral",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getCollateralPoolAddress": {
        "constant": true,
        "inputs": [],
        "name": "getCollateralPoolAddress",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/finnexus/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const BN = require("bignumber.js");

async function getTotalCollateral(pools, chain, block) {
    const balances = {};
    // Need to be called separately because BUSDT rejects when multicalled on BSC
    await Promise.all(pools.map(pool =>
        sdk.api.erc20.balanceOf({
            target: pool[1],
            owner: pool[0],
            chain,
            block
        }).then(result => sdk.util.sumSingleBalance(balances, pool[2], result.output))
    ))
    return balances
}

const ethPools = [
    // pool, currency
    ['0x919a35A4F40c479B3319E3c3A2484893c06fd7de', '0xef9cd7882c067686691b6ff49e650b43afbbcc6b', '0xef9cd7882c067686691b6ff49e650b43afbbcc6b'], // FNX
    ['0xff60d81287BF425f7B2838a61274E926440ddAa6', '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'], // USDC
    ['0xff60d81287BF425f7B2838a61274E926440ddAa6', '0xdac17f958d2ee523a2206206994597c13d831ec7', '0xdac17f958d2ee523a2206206994597c13d831ec7'], // USDT
    ['0x6f88e8fbF5311ab47527f4Fb5eC10078ec30ab10', '0x853d955acef822db058eb8505911ed77f175b99e', '0x853d955acef822db058eb8505911ed77f175b99e'] // FRAX
]

async function eth(_timestamp, block, chainBlocks) {
    return getTotalCollateral(ethPools, 'ethereum', block)
}

const wanPools = [
    // pool, currency, ethereum counterpart
    ['0xe96E4d6075d1C7848bA67A6850591a095ADB83Eb', '0xC6F4465A6a521124C8e3096B62575c157999D361', '0xef9cd7882c067686691b6ff49e650b43afbbcc6b'], // FNX
    ['0x297FF55afEF50C9820d50eA757B5bEBa784757AD', '0x11e77E27Af5539872efEd10abaA0b408cfd9fBBD', '0xdac17f958d2ee523a2206206994597c13d831ec7'], // USDT
]
async function wan(timestamp, ethBlock, chainBlocks) {
    const { block } = await sdk.api.util.lookupBlock(timestamp, {
        chain: 'wan'
    })
    return getTotalCollateral(wanPools, 'wan', block)
}

const bscPools = [
    // pool, token, representation
    ['0xf2E1641b299e60a23838564aAb190C52da9c9323', '0xdfd9e2a17596cad6295ecffda42d9b6f63f7b5d5', 'bsc:0xdfd9e2a17596cad6295ecffda42d9b6f63f7b5d5'], //FNX
    ['0xA3f70ADd496D2C1c2C1Be5514A5fcf0328337530', '0xe9e7cea3dedca5984780bafc599bd69add087d56', 'bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56'], //BUSD
    ['0xA3f70ADd496D2C1c2C1Be5514A5fcf0328337530', '0x55d398326f99059fF775485246999027B3197955', 'bsc:0x55d398326f99059fF775485246999027B3197955'], //USDT
]

async function bsc(_timestamp, block, chainBlocks) {
    return getTotalCollateral(bscPools, 'bsc', chainBlocks['bsc'])
}

function mergeBalances(balances, balancesToMerge) {
    Object.entries(balancesToMerge).forEach(balance => {
        sdk.util.sumSingleBalance(balances, balance[0], balance[1])
    })
}
async function tvl(timestamp, block, chainBlocks) {
    const balances = {}
    await Promise.all([
        eth(timestamp, block, chainBlocks),
        bsc(timestamp, block, chainBlocks),
        wan(timestamp, block, chainBlocks),
    ]).then(poolBalances => poolBalances.forEach(pool=>mergeBalances(balances, pool)))
    return balances
}

module.exports = {
    ethereum: {
        tvl: eth,
    },
    bsc: {
        tvl: bsc,
    },
    wan: {
        tvl: wan,
    },
}

'''
'''--- projects/firebird/index.js ---
const sdk = require('@defillama/sdk')
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')
const {transformPolygonAddress} = require('../helper/portedTokens')

const FACTORY = '0x5De74546d3B86C8Df7FEEc30253865e1149818C8';
const stablePool = "0x01C9475dBD36e46d1961572C8DE24b74616Bae9e"
const stablePoolTokens = ['0xc2132d05d31c914a87c6611c10748aeb04b58e8f', '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063']

async function tvl(_, ethBlock, chainBlocks) {
  const transformPolygon = await transformPolygonAddress()// addr=>`polygon:${addr}`
  const block = chainBlocks['polygon']
  const chain = 'polygon'

  const balances = await calculateUniTvl(transformPolygon, block, chain, FACTORY, 0, true)
  const stablePoolBalances = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: stablePoolTokens.map(t=>({
          target: t,
          params: stablePool
      })),
      chain,
      block
  })
  sdk.util.sumMultiBalanceOf(balances, stablePoolBalances, true, transformPolygon)
  return balances
};

module.exports = {
  methodology: "Includes liquidity on all the pools on the uniswap fork plus the liquidity in the 3FBird stableswap pool",
  polygon: { tvl },
};

'''
'''--- projects/firedao/abi.json ---
{
    "want": {
        "constant": true,
        "inputs": [],
        "name": "want",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "balanceOf": {
        "constant": true,
        "inputs": [],
        "name": "balanceOf",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "vaults": {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "vaults",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "balance": {
        "constant": true,
        "inputs": [],
        "name": "balance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/firedao/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const controllerV1 = "0x71908d6faA4c4Ae8717bCe5839b805cC807Ba302";
const controllerV2 = "0xF3CbD482Dd5Ac5aB9A0FF9baa68DdaD2f08B1c2f";

const strategiesContractsV1 = [
  // strategy DAI V1
  "0x1534A23d885C5a78607CFE1C1AC40669C8b79DB7",
  // strategy USDC V1
  "0xCEb3b75e0e3B4EAD10a959753e3Def4F7D93D383",
  // strategy USDT V1
  "0x5B8fCD142617E790038491E30eE8CE68c3B1EDE2",
];

const strategiesContractsV2 = [
  // strategy DAI V2
  "0x87E2Bb2f2695c7EAFb02Fd7dB1a4EF7d7B179C4E",
  // strategy USDC V2
  "0xe68a4365D3Bdeed31F0dF6dAD633bCb1CEF322d8",
  // strategy USDT V2
  "0x898fEbAba28b945dc432fcAa897FD9231a1FeD9d",
];

async function calcTvl(balances, strategiesContracts, controller) {
  const wants = (
    await sdk.api.abi.multiCall({
      abi: abi.want,
      calls: strategiesContracts.map((strat) => ({
        target: strat,
      })),
    })
  ).output.map((token) => token.output);

  const balanceStrategy = (
    await sdk.api.abi.multiCall({
      abi: abi.balanceOf,
      calls: strategiesContracts.map((strat) => ({
        target: strat,
      })),
    })
  ).output.map((bal) => bal.output);

  const vaults = (
    await sdk.api.abi.multiCall({
      abi: abi.vaults,
      calls: wants.map((want) => ({
        target: controller,
        params: want,
      })),
    })
  ).output.map((vault) => vault.output);

  const vaultBalance = (
    await sdk.api.abi.multiCall({
      abi: abi.balance,
      calls: vaults.map((vault) => ({
        target: vault,
      })),
    })
  ).output.map((bal) => bal.output);

  wants.forEach((token, idx) => {
    sdk.util.sumSingleBalance(balances, token, balanceStrategy[idx]);
    sdk.util.sumSingleBalance(balances, token, vaultBalance[idx]);
  });
}

async function ethTvl() {
  const balances = {};

  /*** Version 1 ***/
  await calcTvl(balances, strategiesContractsV1, controllerV1);
  /*** Version 2 ***/
  await calcTvl(balances, strategiesContractsV2, controllerV2);

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology:
    "Counts liquidty on the Vaults trouggh Controller Contracts",
};

'''
'''--- projects/flamedefi/index.js ---
const BigNumber = require('bignumber.js')
const { request, gql } = require("graphql-request");
const axios = require("axios");

const graphUrl = 'https://api2.spacefarm.xyz/api';
const tvlQuery = gql`
  {
    spaceFarm {
      totalStackTez
    }
  }
`;

async function tvl() {
    const data = (await request(graphUrl, tvlQuery));
    const totalLiquidity = new BigNumber(data.spaceFarm.totalStackTez);
    return {
      tezos: totalLiquidity
    }
}

module.exports = {
    methodology: 'TVL counts the liquidity of FlameDefi farms. Data is pulled from:"https://api2.spacefarm.xyz/api".',
    misrepresentedTokens: true,
    tvl
}
'''
'''--- projects/flamincome.js ---
const abis = require('./config/flamincome/abis.js');
const sdk = require("@defillama/sdk")

async function tvl(ts, block) {

  const contracts = [
    '0x54bE9254ADf8D5c8867a91E44f44c27f0c88e88A',
    '0x1a389c381a8242B7acFf0eB989173Cd5d0EFc3e3',
    '0x1E9DC5d843731D333544e63B2B2082D21EF78ed3',
  ]
  const calls = contracts.map(t => ({ target: t }))
  const { output: token } = await sdk.api.abi.multiCall({
    block,
    calls,
    abi: abis['VaultBaseline'].find(i => i.name === 'token')
  })
  const { output: balance } = await sdk.api.abi.multiCall({
    block,
    calls,
    abi: abis['VaultBaseline'].find(i => i.name === 'balance')
  })

  const balances = {}
  token.forEach((t, i) => sdk.util.sumSingleBalance(balances, t.output, balance[i].output))
  return balances
}

module.exports = {
  doublecounted: true,
  ethereum: {
    tvl,
  }
}

'''
'''--- projects/flamingo.js ---
const { get } = require('./helper/http')

async function tvl(timestamp) {
  const ONE_DAY_AGO = timestamp - 24 * 60 * 60
  const data = await get('https://api.flamingo.finance/analytics/pool-stats?mainnet=true');
  return {
    tether: data.totals
      .filter(i => i.t > ONE_DAY_AGO)
      .sort((a, b) => b.t - a.t)[0].lq
  }
}

module.exports = {
  methodology: `TVL is obtained by making calls to the Flamingo Finance API "https://api.flamingo.finance/token-info/tvl".`,
  misrepresentedTokens: true,
  timetravel: false,
  neo: {
    tvl
  }
}

'''
'''--- projects/flare-loans/index.js ---
const sdk = require('@defillama/sdk')
const { getBlock } = require('../helper/getBlock')

async function tvl(time, ethB, cB){
    const block = await getBlock(time, "songbird", cB)
    return {
        "songbird": Number(
            (await sdk.api.erc20.balanceOf({target: "0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED", owner: "0xFa21A4ABD1a58CefAB79CFd597aCcc314403eE9f", block, chain:'songbird'})).output
        )/1e18
    }
}

module.exports={
    methodology: "We count all WSGB on 0xFa21A4ABD1a58CefAB79CFd597aCcc314403eE9f, which is backing the stablecoin",
    songbird: {
        tvl
    }
}
'''
'''--- projects/flarefarm/index.js ---
const { sumUnknownTokens } = require("../helper/unknownTokens");
const WSGB = '0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED'
const CANARY_DOLLAR = '0x70Ad7172EF0b131A1428D0c1F66457EB041f2176'

const chain = 'songbird'

async function farmTvl(timestamp, ethblock, { [chain]: block }) {
  const tokens = [
    [WSGB, "0x6BA0F675EB2f169D15764D5cf10C4EF0e9e059f2"],
    ["0xC348F894d0E939FE72c467156E6d7DcbD6f16e21", "0xc9231AB30b2B39c1f7f79132D7a44bBF0F8144B0"],
    [CANARY_DOLLAR, "0x32b36B0A8B74Ac9212946a99e0af727848D5A3A1"],
    ["0xC6D2f9e21bcD963B42D85379581003be1146b3Aa", "0x02785B7CE6Eb9A5858561DDAB64cCBE5c478b730"],
    ["0x07852D5C7fd1d630Dd79148A195aaAF72241680D", "0x50756c69CAC800a3fA03d130721CDa02Aa0fEF69"],
    ["0xb5bf334b8cc30b8b13fc035d171d77a217aab091", "0x864201b2227Ee23f0875c5D3Fc49F4F0ec59aC19"],
    ["0x47c830e141234d029d953df39b13d7728eb9f2d4", "0x921E8f58cF517d289c01BCBE800c2d31838c1a28"],
  ];
  
  return sumUnknownTokens({ tokensAndOwners: tokens, chain, block, coreAssets: [WSGB, CANARY_DOLLAR,], })
}

async function pool2(timestamp, ethblock, { [chain]: block }) {
  const tokens = [
    ["0xcd15c231b8a0bae40bd7938ae5ea8e43f1e9a15f", "0x0732f6B4aBE5dB2127E671E4B218d340b6af169c"],
    ["0xcd15c231b8a0bae40bd7938ae5ea8e43f1e9a15f", "0x3b343A6FC05B699F48CBe6FF127C0af8e2aA9EEE"],
    ["0x48195ca4d228ce487ae2ae1335b017a95493ade6", "0xc5478a1d5914cF9D0Ee20Da21459502eCb7E1646"],
  ]
  return sumUnknownTokens({ tokensAndOwners: tokens, chain, block, coreAssets: [WSGB, CANARY_DOLLAR] })
};
async function staking(timestamp, ethblock, { [chain]: block }) {
  const tokens = [
    ['0x0D94e59332732D18CF3a3D457A8886A2AE29eA1B', '0x554742076743b366504972F86609d64fd18BDC34']
  ]
  return sumUnknownTokens({ tokensAndOwners: tokens, chain, block, coreAssets: [WSGB, CANARY_DOLLAR], lps: ['0x48195Ca4D228ce487AE2AE1335B017a95493Ade6'] })
};

module.exports = {
  methodology: `Gets token balance from the smart contract address holding the user deposits. These addresses are are labele "tokensAndOwners". SFIN staked to earn more SFIN is labeles as "staking" category`,
  songbird: {
    tvl: farmTvl,
    pool2,
    staking,
  }
};
'''
'''--- projects/flarex/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')
const sdk = require('@defillama/sdk')

const v1 =calculateUsdUniTvl("0x0eAC91966b12b81db18f59D8e893b9ccef7e2c30", "songbird", "0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED", [], "songbird")
const v2 = calculateUsdUniTvl("0x7a39408809441814469A8Fb3F5CFea1aA2774fB6", "songbird", "0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED", ["0xC348F894d0E939FE72c467156E6d7DcbD6f16e21"], "songbird")

module.exports={
    misrepresentedTokens: true,
    methodology: "Factory address (0x0eAC91966b12b81db18f59D8e893b9ccef7e2c30) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    songbird: {
        tvl:sdk.util.sumChainTvls([v1,v2])
    }
}
'''
'''--- projects/flashstake/index.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require("../helper/balances");

const graphUrl =
  "https://api.thegraph.com/subgraphs/name/blockzerohello/flash-stake-stats-v2-subgraph";
const graphQuery = gql`
  query get_tvl($block: Int) {
    flashFactories(block: { number: $block }) {
      totalVolumeUSD
      totalLiquidityUSD
    }
  }
`;

async function tvl(timestamp, block) {
  const { flashFactories } = await request(graphUrl, graphQuery, {
    block,
  });
  const usdTvl = Number(flashFactories[0].totalLiquidityUSD);
  return toUSDTBalances(usdTvl);
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl,
  },
};

'''
'''--- projects/flexa.js ---
const { sumTokens } = require('./helper/unwrapLPs')

async function tvl(_, block) {
  return sumTokens({}, [
    ['0xff20817765cb7f73d4bde2e66e067e58d11095c2', '0x706D7F8B3445D8Dfc790C524E3990ef014e7C578'],
  ], block)
}

module.exports = {
  ethereum: { tvl }
}

'''
'''--- projects/flexdao/index.js ---
const { staking } = require('../helper/staking')

// DAO from Coinflex utility token FLEX
// https://coinflex.com/support/2-2-9-flexdao

const FLEX = '0x98Dd7eC28FB43b3C4c770AE532417015fa939Dd3'
const veFLEX = '0xA9bB3b5334347F9a56bebb3f590E8dF97fC091f9'
const coingeckoId = 'flex-coin'
const chain = 'smartbch'
const decimals = 18

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology: 'Counting all FLEX tokens staked in the DAO',
  start: 2153800,
  [chain]: {
    tvl: ()=>({}),
    staking: staking(veFLEX, FLEX, chain, coingeckoId, decimals)
  },
};

'''
'''--- projects/float-capital/abi.json ---
{
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/float-capital/index.js ---
const { sumTokens, unwrapCreamTokens } = require("../helper/unwrapLPs");
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const vaults = [
  "0xce5da4bebBA980BeC39da5b118750A47a23D4B85",
  "0x595b1408C9c2BF121c7674E270Ca7aCc0bBf100C",
  "0x694c240e63CF60a2cD2d38d84D902744640AcCDA",
  "0x92f29DfceA469ab498ade826FB41d065482B6abA",
  "0xB26289Bee42Aa1ad51466dc28e68ab89f0541A7f",
  "0x1372276638bFc1FCe909B05783D91e526B801669",
  "0x38c23db64e4a22A9f277216a34A88f5a1fB3Cf5e",
];
const amDAI = "0x27f8d03b3a2196956ed754badc28d73be8830a6e";
const avaults = [
  "0xefE423827b87751f9EB91A90a78edc624601565b",
  "0x621cda10820555adAe8506eeC296cB9621E491Ff",
  "0x47a21F14794b6229cc2a1ddfe4498C9e48f1C16c",
];
const avDAI = "0x47afa96cdc9fab46904a55a6ad4bf6660b53c38a";
const DAI = "0xd586e7f844cea2f87f50152665bcbc2c279d8d70";
const transforms = {
  "0x47afa96cdc9fab46904a55a6ad4bf6660b53c38a":
    "0x6b175474e89094c44da98b954eedeac495271d0f", // avDAI
  "0xd586e7f844cea2f87f50152665bcbc2c279d8d70":
    "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
};

async function polyTvl(time, ethBlock, chainBlocks) {
  const balances = {};
  await sumTokens(
    balances,
    vaults.map((v) => [amDAI, v]),
    chainBlocks.polygon,
    "polygon",
    (addr) => `polygon:${addr}`
  );
  return balances;
}

const qiDAI = "avax:0x835866d37afb8cb8f8334dccdaf66cf01832ff5d"

async function avaxTvl(time, ethBlock, chainBlocks) {
  const balances = {};
  await sumTokens(
    balances,
    avaults.map((v) => [avDAI, v]),
    chainBlocks.avax,
    "avax",
    (addr) => {
      return transforms[addr.toLowerCase()] ?? `avax:${addr}`;
    }
  );
  const [{ output: jDAIRate }, { output: jDAIBalance }] = await Promise.all([
    sdk.api.abi.call({
      chain: 'avax',
      target: '0xc988c170d0E38197DC634A45bF00169C7Aa7CA19',
      block: chainBlocks.avax,
      abi: abi.exchangeRateStored
    }),
    sdk.api.erc20.balanceOf({
      target: "0xc988c170d0E38197DC634A45bF00169C7Aa7CA19",
      owner: "0xcD62196CC117EA7fd9525ADe37e44d01209e8EBB",
      block: chainBlocks.avax,
      chain: 'avax'
    })
  ])
  sdk.util.sumSingleBalance(balances, `avax:${DAI}`, jDAIRate * jDAIBalance / 10 ** 18)

  await unwrapCreamTokens(
    balances,
    [[
      "0x835866d37afb8cb8f8334dccdaf66cf01832ff5d", 
      "0xEb2A90ED68017Ac1B068077C5D1537f4C544036C"
    ]],
    chainBlocks.avax,
    "avax",
    (addr) => {
      return transforms[addr.toLowerCase()] ?? `avax:${addr}`;
    }
  );
  return balances;
}

module.exports = {
  polygon: {
    tvl: polyTvl,
  },
  avax: {
    tvl: avaxTvl,
  },
  methodology: `Gets the tokens on markets`,
};

'''
'''--- projects/float/abi.json ---
{
  "stakeToken": {
    "inputs": [],
    "name": "stakeToken",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/float/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const multiplier_pool_single = [
  "0x52eadaFf8E3d816CE205691D1D703e08d369F576",
  "0x432573cf5b10eb9A160624ca2725199DC1b56e3e",
];

// adding some old phases, which still hold certain % of tvl
const multiplier_pool_slp = [
  // BANK/ETH sLP
  "0x726FF99C3f2aa0B0debadE809D2Ac75C5DfA3736",
  // FLOAT/ETH sLP
  "0xE73cf1bBC792c796826f9E57263483fd3DD38d50",
  // BANK-ETH sLPPhase2Pool
  "0xd04F4759A2cc28A5AE33287534CAA4dfcE90B9C3",
  // BANK-ETH sLPPhase4Pool
  "0x08D7e47Beb0470fc683bbdE7d836c5dcd48754F2",
  // FLOAT-ETH sLPPhase4Pool
  "0xCD817491872bdB33e0D21589bd92DbfF43387CA4",
];

const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  for (let i = 0; i < multiplier_pool_single.length; i++) {
    const stake_token = (
      await sdk.api.abi.call({
        abi: abi.stakeToken,
        target: multiplier_pool_single[i],
        ethBlock,
      })
    ).output;

    const balance = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: stake_token,
        params: multiplier_pool_single[i],
        ethBlock,
      })
    ).output;

    sdk.util.sumSingleBalance(balances, stake_token, balance);
  }

  const lpPositions = [];

  for (let i = 0; i < multiplier_pool_slp.length; i++) {
    const token = (
      await sdk.api.abi.call({
        abi: abi.stakeToken,
        target: multiplier_pool_slp[i],
        ethBlock,
      })
    ).output;

    const balance = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: token,
        params: multiplier_pool_slp[i],
        ethBlock,
      })
    ).output;

    lpPositions.push({
      balance,
      token,
    });
  }

  await unwrapUniswapLPs(balances, lpPositions, ethBlock);

  return balances;
};

module.exports = {
  ethereum: {
    tvl: ethTvl
  }
};

'''
'''--- projects/floor-dao/index.js ---
const { ohmTvl } = require('../helper/ohm')
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const BigNumber = require('bignumber.js');
// https://docs.floor.xyz/fundamentals/treasury

// Tokens in treasury
const WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
const PUNK = '0x269616d549d7e8eaa82dfb17028d0b212d11232a'
const xPUNK = '0x08765c76c758da951dc73d3a8863b34752dd76fb'
const PUNKWETH = '0x0463a06fbc8bf28b3f120cd1bfc59483f099d332'
const xPUNKWETH = '0xfb2f1c0e0086bcef24757c3b9bfe91585b1a280f'

const treasury = '0x91E453f442d25523F42063E1695390e325076ca2'
const stakingAddress = '0x759c6de5bca9ade8a1a2719a31553c4b7de02539' 
const FLOOR = '0xf59257E961883636290411c11ec5Ae622d19455e' 
const treasuryTokens = [
    [WETH, false], [PUNK, false], [xPUNK, false], // WETH, PUNK and xPUNK
    [PUNKWETH, true],  // PUNK-ETH SLP
]
module.exports = ohmTvl(treasury, treasuryTokens, 'ethereum', stakingAddress, FLOOR)
module.exports.methodology = 'Using ohmTvl for staking and treasury core TVL, and adding xPUNK and xPUNKWETH balances using 1:1 mapping with PUNK and PUNK-WETH sushi LP'

const tvl = module.exports.ethereum.tvl 
const transform = a => `ethereum:${a}`
module.exports.ethereum.tvl = async (time, ethBlock, chainBlocks) => {
    // Get OHM default TVL balances
    const balances = await tvl(time, ethBlock, chainBlocks)
    
    // Replace xPUNK by PUNK which is 1:1
    balances[transform(PUNK)] = BigNumber(balances[transform(PUNK)]).plus(BigNumber(balances[transform(xPUNK)])).toFixed(0)
    balances[transform(xPUNK)] = 0

    // Unwrap xPUNKWETH which is 1:1 with PUNK-WETH Sushi LP
    const {output: xPUNKWETH_bal} = await sdk.api.abi.call({
        target: xPUNKWETH,
        params: [treasury],
        abi: 'erc20:balanceOf',
        ethBlock,
        chain: 'ethereum'
      })
    const lpPositions = [{
        token: PUNKWETH,
        balance: xPUNKWETH_bal,
    }]
    await unwrapUniswapLPs( balances, lpPositions, ethBlock, "ethereum", transform );
    return balances
}

/*
const dao_treasury = '0xA9d93A5cCa9c98512C8C56547866b1db09090326'
module.exports.ethereum.treasury = async (time, ethBlock, chainBlocks) => {
    const balances = {}
    await sumTokens(balances, [[FLOOR, dao_treasury]], ethBlock, "ethereum", transform)
    // const univ3_Positions = []
    // await unwrapUniswapV3LPs(balances, univ3_Positions, ethBlock, 'ethereum', transform)
    return balances
}
*/
'''
'''--- projects/fluidtokens/index.js ---
const { getAddressesUTXOs, getTxsMetadata, getTxsRedeemers } = require("../helper/cardano/blockfrost");
const { PromisePool } = require('@supercharge/promise-pool')

const smartContractAddress =
  "addr1wxzqzlncct5g0686c07lyuq3q3j2a0t8l88uwdznw99k9asz6z0hq";

const tvl = async () => {
  let utxos = await getAddressesUTXOs(smartContractAddress);

  let utxosWithRedeemer = []; // Only the UTXO with redeemer have actually been taken and are and active loan

  const { errors } = await PromisePool.withConcurrency(10)
    .for(utxos)
    .process(async (utxo) => {
      const redeemer = await getTxsRedeemers(utxo.tx_hash)
      if (redeemer.length > 0) utxosWithRedeemer.push(utxo)
    })

  if (errors && errors.length)
    throw errors[0]

  let loanDetails = [];

  const { errors: errors1 } = await PromisePool.withConcurrency(10)
    .for(utxosWithRedeemer)
    .process(async (utxo) => {
      const details = await getTxsMetadata(utxo.tx_hash)
      loanDetails.push(details[0].json_metadata)
    })

  if (errors1 && errors1.length)
    throw errors1[0]

  const TVL = loanDetails.reduce((x, y) => {
    return x + parseInt(y.AMOUNT);
  }, 0);
  return {
    cardano: TVL / 1e6,
  };
};

module.exports = {
  timetravel: false,
  cardano: {
    tvl,
  },
};

'''
'''--- projects/fluity/getEntireSystemColl.abi.json ---
{
  "inputs": [],
  "name": "getEntireSystemColl",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "entireSystemColl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/fluity/index.js ---
const sdk = require("@defillama/sdk");
const getEntireSystemCollAbi = require("./getEntireSystemColl.abi.json")
const { getLiquityTvl } = require("../helper/liquity");

const BNB_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
// TroveManager has a record of total system collateral
const TROVE_MANAGER_ADDRESS = "0xe041c4099C0d6dcfC52C56A556EE4289D2E4b7C5";
/*
async function tvl(_, block, chainBlocks) {
  const balance = (
    await sdk.api.abi.call({
      target: TROVE_MANAGER_ADDRESS,
      abi: getEntireSystemCollAbi,
      block: chainBlocks['bsc'],
      chain: 'bsc'
    })
  ).output;

  return { [BNB_ADDRESS]: balance };
}
*/
module.exports = {
  tvl: getLiquityTvl(BNB_ADDRESS,TROVE_MANAGER_ADDRESS,"bsc")
};

'''
'''--- projects/flux/index.js ---
const axios = require("axios");
const { toUSDTBalances } = require("../helper/balances");

const url = "https://gateway.api.01defi.com/base/fluxTvl/get";

// tvl and staking amount
function getChainData(chain, type) {
  return async () => {
    const data = await axios.get(url);
    const info = (data?.data?.data?.detail || []).find(
      (item) => item.chain === chain
    );
    if (!info)  return toUSDTBalances(0)

    switch (type) {
      case "tvl":
        return toUSDTBalances(info.lendingTVL);
      case "staking":
        return toUSDTBalances(info.stakedTVL);
    }
  };
}

module.exports = {
  timetravel: true,
  bsc: {
    tvl: getChainData("bsc", "tvl"),
    staking: getChainData("bsc", "staking"),
  },
  okexchain: {
    tvl: getChainData("okexchain", "tvl"),
    staking: getChainData("okexchain", "staking"),
  },
  heco: {
    tvl: getChainData("heco", "tvl"),
    staking: getChainData("heco", "staking"),
  },
  arbitrum: {
    tvl: getChainData("arbitrum", "tvl"),
    staking: getChainData("arbitrum", "staking"),
  },
  polygon: {
    tvl: getChainData("polygon", "tvl"),
    staking: getChainData("polygon", "staking"),
  },
  conflux: {
    tvl: getChainData("conflux", "tvl"),
    staking: getChainData("conflux", "staking"),
  },
  ethereum: {
    tvl: getChainData("ethereum", "tvl"),
    staking: getChainData("ethereum", "staking"),
  },
};

'''
'''--- projects/fodl/abi.json ---
{
    "getAllMyPositionsFromNFT":{
       "inputs":[
          {
             "internalType":"address",
             "name":"foldingNFT",
             "type":"address"
          }
       ],
       "name":"getAllMyPositionsFromNFT",
       "outputs":[
          {
             "components":[
                {
                   "internalType":"uint256",
                   "name":"supplyAmount",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"borrowAmount",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"collateralUsageFactor",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"principalValue",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"positionValue",
                   "type":"uint256"
                },
                {
                   "internalType":"address",
                   "name":"positionAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"platformAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"supplyTokenAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"borrowTokenAddress",
                   "type":"address"
                }
             ],
             "internalType":"struct SimplePositionMetadata[]",
             "name":"assetsData",
             "type":"tuple[]"
          }
       ],
       "stateMutability":"nonpayable",
       "type":"function"
    },
    "getPositionsMetadata":{
       "inputs":[
          {
             "internalType":"address[]",
             "name":"positions",
             "type":"address[]"
          }
       ],
       "name":"getPositionsMetadata",
       "outputs":[
          {
             "components":[
                {
                   "internalType":"uint256",
                   "name":"supplyAmount",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"borrowAmount",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"collateralUsageFactor",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"principalValue",
                   "type":"uint256"
                },
                {
                   "internalType":"uint256",
                   "name":"positionValue",
                   "type":"uint256"
                },
                {
                   "internalType":"address",
                   "name":"positionAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"platformAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"supplyTokenAddress",
                   "type":"address"
                },
                {
                   "internalType":"address",
                   "name":"borrowTokenAddress",
                   "type":"address"
                }
             ],
             "internalType":"struct SimplePositionMetadata[]",
             "name":"assetsData",
             "type":"tuple[]"
          }
       ],
       "stateMutability":"nonpayable",
       "type":"function"
    },
    "tokenByIndex":{
       "inputs":[
          {
             "internalType":"uint256",
             "name":"",
             "type":"uint256"
          }
       ],
       "name":"tokenByIndex",
       "outputs":[
          {
             "internalType":"address",
             "name":"",
             "type":"address"
          }
       ],
       "stateMutability":"view",
       "type":"function"
    }
 }
'''
'''--- projects/fodl/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs.js");  
const BigNumber = require("bignumber.js")
const abi = require('./abi.json')

const position_nft = '0xB410075E1E13c182475b2D0Ece9445f2710AB197'
const lens_contract = '0x080155C42b0854C3A718B610cC5183e963851Afb'

async function tvl(timestamp, ethBlock, chainBlocks) {
  // Get number of positions opened by users by querying the supply of ERC721 tokens
  const erc721_supply = (await sdk.api.abi.call({ target: position_nft, abi: 'erc20:totalSupply', block: ethBlock, chain: 'ethereum' })).output;
  console.log(`${erc721_supply} position ownership ERC 721 existing`)

  // Get all positions contracts addresses
  const positionsCalls = [...Array(parseInt(erc721_supply)).keys()].map(t => ({target: position_nft, params: t}))
  const positionsAddresses = (
    await sdk.api.abi.multiCall({
      calls: positionsCalls,
      abi: abi['tokenByIndex'],
      block: ethBlock,
      chain: 'ethereum'
    })
  ).output

  
  // FODL uses flashloans to leverage the user provided collateral. TVL should count only what the user brought in, which is supplyAmount of supplyTokenAddress 
  // const usersSuppliedBalances = usersPositions.map(t => ({[t.supplyTokenAddress]: t.supplyAmount}))
  const balances = {}

  // console.log(positionsAddresses.map(t => t.output).slice(0,5))
  // The call to getPositionsMetadata only accounts for max 192 positions
  const nParamsMax = 100
  for (let iSlice = 0; iSlice < positionsAddresses.length / nParamsMax; iSlice++) {
    // Get all positions paramters using the lens contract
    const positionsSlice = positionsAddresses.slice(iSlice * nParamsMax, (iSlice+1) * nParamsMax)
    let params = [positionsSlice.map(t => t.output)]
    const usersPositions = (
      await sdk.api.abi.call({
        target: lens_contract, 
        params: params,
        abi: abi['getPositionsMetadata'],
        block: ethBlock,
        chain: 'ethereum'
      })
    ).output
    // console.log('first position example', usersPositions[0])
    
    usersPositions.forEach(t => {
      const token = t.supplyTokenAddress
      //principalValue is capital provided by users, while supplyAmount also accounts for that flashloan'd for the borrow-lend leverage loops 
      balances[token] = (new BigNumber(balances[token] || "0").plus(new BigNumber(t.principalValue)) ).toString(10)
    })
    // console.log(iSlice, balances)
  }
  return balances
}

/* position lens contract getPositionsMetadata returns a struct like this:
  uint256 supplyAmount;
  uint256 borrowAmount;
  uint256 collateralUsageFactor;
  uint256 principalValue;
  uint256 positionValue;
  address positionAddress;
  address platformAddress;
  address supplyTokenAddress;
  address borrowTokenAddress;
*/

const sushiLps = [
  "0xa5c475167f03b1556c054e0da78192cd2779087f", // FODL-USDC
  "0xce7e98d4da6ebda6af474ea618c6b175729cd366", // FODL-WETH
];

async function ethPool2(timestamp, block) {
  let balances = {};

  let { output: totalSupply } = await sdk.api.abi.multiCall({
    calls: sushiLps.map(address => ({
      target: address
    })),
    abi: "erc20:totalSupply",
    block
  });

  let lpPos = totalSupply.map(result => ({
    balance: result.output,
    token: result.input.target
  }));

  await unwrapUniswapLPs(balances, lpPos, block);

  return balances;  
}

module.exports = {
  methodology: "FODL leverages users positions on Aave and Compound. The fodl lens contract is used to get the positions metadata, especially supplyAmount and supplyTokenAddress, which counts as the TVL of the position of the user. Pool2 TVL are the tokens locked in the SUSHI pools",
  ethereum: {
    tvl: tvl,
    pool2: ethPool2,
  },
};

'''
'''--- projects/folks-finance/constants.js ---
const pools = [
  {
    // Algo
    appId: 686498781,
    assetId: 0,
    assetDecimals: 6,
  },
  {
    // gALGO
    appId: 794055220,
    assetId: 793124631,
    assetDecimals: 6,
  },
  {
    // USDC
    appId: 686500029,
    assetId: 31566704,
    assetDecimals: 6,
  },
  {
    // USDt
    appId: 686500844,
    assetId: 312769,
    assetDecimals: 6,
  },
  {
    // goBTC
    appId: 686501760,
    assetId: 386192725,
    assetDecimals: 8,
  },
  {
    // goETH
    appId: 694405065,
    assetId: 386195940,
    assetDecimals: 8,
  },
  {
    // gAlgo3
    appId: 694464549,
    assetId: 694432641,
    assetDecimals: 6,
  },
  // USDC-gALGO TMP1.1
  {
    appId: 805843312,
    assetId: 794948880,
    assetDecimals: 6,
    poolAppAddress:
      "3WT6YVLQY2WSQ6VLX73MJB7BI3CGBDTB2KKAAFZ2CZQJUFUCIOMUN2K24U",
  },
  // ALGO-gALGO PLP
  {
    appId: 805846536,
    assetId: 794882756,
    assetDecimals: 6,
    poolAppId: 794882684,
  },
  {
    // Algo-gAlgo3 TMP1.1
    appId: 743679535,
    assetId: 694683000,
    assetDecimals: 6,
    poolAppAddress:
      "WNA4H7Y3UGEVNEVVFU2TUDLMOMLWSV72UF6SYYRBOQ7IGDW4ZIOKYWNIWU",
  },
  {
    // Algo-gAlgo3 PLP
    appId: 743685742,
    assetId: 701364134,
    assetDecimals: 6,
    poolAppId: 701363946,
  },
  {
    // Algo-USDC TMP1.1
    appId: 747237154,
    assetId: 552647097,
    assetDecimals: 6,
    poolAppAddress:
      "FPOU46NBKTWUZCNMNQNXRWNW3SMPOOK4ZJIN5WSILCWP662ANJLTXVRUKA",
  },
  {
    // Algo-USDC PLP
    appId: 747239433,
    assetId: 620996279,
    assetDecimals: 6,
    poolAppId: 620995314,
  },
  {
    // USDC-USDt TMP1.1
    appId: 776179559,
    assetId: 552888874,
    assetDecimals: 6,
    poolAppAddress:
      "I37JDCOJCK2JSPRMV5HHFHQ54YU6J6VWCBCDNULIT5ZJWO357R2DJLGIBM",
  },
  {
    // USDC-USDt PLP
    appId: 776176449,
    assetId: 701273234,
    assetDecimals: 6,
    poolAppId: 701273050,
  },
  {
    // Planets
    appId: 751285119,
    assetId: 27165954,
    assetDecimals: 6,
  },
];

// app id of the governance app used only on 3rd governance period
const liquidGovernance3AppId = 694427622;
// app id of the governance app used from 4th governance period on
const liquidGovernanceAppId = 793119194;

const oracleAppId = 793269965;
const oracleAdapterAppId = 751277258;
const oracleDecimals = 14;
const tinymanValidatorAppId = 552635992;

module.exports = {
  pools,
  liquidGovernance3AppId,
  liquidGovernanceAppId,
  oracleAppId,
  oracleAdapterAppId,
  oracleDecimals,
  tinymanValidatorAppId,
};

'''
'''--- projects/folks-finance/index.js ---
const { toUSDTBalances } = require("../helper/balances");

const {
  pools,
  liquidGovernance3AppId,
  liquidGovernanceAppId,
} = require("./constants");
const {
  lookupApplications,
  lookupAccountByID,
  getApplicationAddress,
} = require("../helper/algorand");
const { getAppState, getParsedValueFromState } = require("./utils");
const { getPrices } = require("./prices");

async function getAlgoLiquidGovernanceDepositUsd(
  prices,
  liquidGovernanceAppId
) {
  const [app, acc] = await Promise.all([
    lookupApplications(liquidGovernanceAppId),
    lookupAccountByID(getApplicationAddress(liquidGovernanceAppId)),
  ]);
  const state = app.application.params["global-state"];

  const gAlgoId = Number(getParsedValueFromState(state, "g_algo_id") || 0);
  const gAlgoBalance =
    acc.account.assets?.find((asset) => asset["asset-id"] === gAlgoId)
      ?.amount || 10e15;

  // 10e15 is the amount of gAlgo preminted by the governance contract (not in circulation)
  // gAlgoBalance is the amount still locked in the governance contract
  // totalMinted is the amount of gAlgo in circulation, and since gAlgo is 1:1 with Algo,
  // it represents the amount of Algo deposited and locked in the governance contract
  const totalMinted = 10e15 - gAlgoBalance;
  return totalMinted * prices[0];
}

async function getTotalPoolDepositsUsd(prices) {
  const promises = pools.map(async (pool) => {
    try {
      const state = await getAppState(pool.appId);
      const totalDeposits = getParsedValueFromState(state, "total_deposits");
      const numericDeposits = isNaN(Number(totalDeposits))
        ? 0
        : Number(totalDeposits);
      const depositAmountUsd = numericDeposits * prices[pool.assetId];

      return depositAmountUsd;
    } catch (e) {
      return 0;
    }
  });

  const depositsAmountUsd = await Promise.all(promises);
  const totalDepositsUsd = depositsAmountUsd.reduce((a, b) => a + b, 0);

  return totalDepositsUsd;
}

/* Get total deposits */
async function tvl() {
  const prices = await getPrices();

  const [
    depositsAmountUsd,
    algoLiquidGovernance3DepositUsd,
    algoLiquidGovernanceDepositUsd,
    borrowsAmountUsd,
  ] = await Promise.all([
    getTotalPoolDepositsUsd(prices),
    getAlgoLiquidGovernanceDepositUsd(prices, liquidGovernance3AppId),
    getAlgoLiquidGovernanceDepositUsd(prices, liquidGovernanceAppId),
    borrowed(),
  ]);

  return toUSDTBalances(
    depositsAmountUsd +
      algoLiquidGovernance3DepositUsd +
      algoLiquidGovernanceDepositUsd -
      borrowsAmountUsd
  );
}

/* Get total borrows */
async function borrowed() {
  const prices = await getPrices();

  const promises = pools.map(async (pool) => {
    try {
      const state = await getAppState(pool.appId);
      const borrowAmount = getParsedValueFromState(state, "total_borrows");
      const numericBorrowAmount = isNaN(Number(borrowAmount))
        ? 0
        : Number(borrowAmount);
      const borrowAmountUsd = numericBorrowAmount * prices[pool.assetId];

      return borrowAmountUsd;
    } catch (e) {
      return 0;
    }
  });

  const borrowsAmountUsd = await Promise.all(promises);
  const totalBorrowsUsd = borrowsAmountUsd.reduce((a, b) => a + b, 0);

  return totalBorrowsUsd;
}

async function borrowedBalances() {
  return toUSDTBalances(await borrowed());
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  algorand: {
    tvl,
    borrowed: borrowedBalances,
  },
};

'''
'''--- projects/folks-finance/prices.js ---
const { lookupAccountByID, lookupApplications } = require("../helper/algorand");
const {
  oracleAppId,
  oracleAdapterAppId,
  pools,
  tinymanValidatorAppId,
  oracleDecimals,
} = require("./constants");
const {
  getAppState,
  getParsedValueFromState,
  fromIntToBytes8Hex,
  parseOracleValue,
  parseOracleAdapterValue,
  calcLPPrice,
} = require("./utils");

async function getTinymanLPPrice(validatorAppId, poolAddress, p0, p1) {
  const res = await lookupAccountByID(poolAddress);
  const { account } = res;

  const state = account["apps-local-state"]?.find(
    (app) => app.id === validatorAppId
  )?.["key-value"];
  if (state === undefined)
    throw new Error(
      `Unable to find Tinyman Pool: ${poolAddress} for validator app ${validatorAppId}.`
    );
  const r0 = BigInt(getParsedValueFromState(state, "s1") || 0);
  const r1 = BigInt(getParsedValueFromState(state, "s2") || 0);
  const lts = BigInt(getParsedValueFromState(state, "ilt") || 0);

  return calcLPPrice(r0, r1, p0, p1, lts);
}

async function getPactLPPrice(poolAppId, p0, p1) {
  const res = await lookupApplications(poolAppId);
  const state = res.application.params["global-state"];

  const r0 = BigInt(getParsedValueFromState(state, "A") || 0);
  const r1 = BigInt(getParsedValueFromState(state, "B") || 0);
  const lts = BigInt(getParsedValueFromState(state, "L") || 0);

  return calcLPPrice(r0, r1, p0, p1, lts);
}

/* Get prices from oracle */
async function getPrices() {
  const oracleState = await getAppState(oracleAppId);
  const oracleAdapterState = await getAppState(oracleAdapterAppId);
  const prices = {};

  let price;
  for (const pool of pools) {
    const base64Value = getParsedValueFromState(
      oracleAdapterState,
      fromIntToBytes8Hex(pool.assetId),
      "hex"
    );

    // check if liquidity token
    if (base64Value !== undefined) {
      const oracleAdapterValue = parseOracleAdapterValue(base64Value);

      const price0 = parseOracleValue(
        String(
          getParsedValueFromState(
            oracleState,
            fromIntToBytes8Hex(oracleAdapterValue.asset0Id),
            "hex"
          )
        )
      );
      const price1 = parseOracleValue(
        String(
          getParsedValueFromState(
            oracleState,
            fromIntToBytes8Hex(oracleAdapterValue.asset1Id),
            "hex"
          )
        )
      );

      price =
        oracleAdapterValue.provider === "Tinyman"
          ? await getTinymanLPPrice(
              tinymanValidatorAppId,
              oracleAdapterValue.poolAddress,
              price0,
              price1
            )
          : await getPactLPPrice(oracleAdapterValue.poolAppId, price0, price1);
    } else {
      price = parseOracleValue(
        String(
          getParsedValueFromState(
            oracleState,
            fromIntToBytes8Hex(pool.assetId),
            "hex"
          )
        )
      );
    }

    prices[pool.assetId] = Number(price) / 10 ** oracleDecimals;
  }

  return prices;
}

module.exports = { getPrices };

'''
'''--- projects/folks-finance/utils.js ---
const { lookupApplications } = require("../helper/algorand");
const { encodeAddress } = require("../helper/algorandUtils/address");

function fromIntToBytes8Hex(num) {
  return num.toString(16).padStart(16, "0");
}

function encodeToBase64(str, encoding = "utf8") {
  return Buffer.from(str, encoding).toString("base64");
}

function parseOracleValue(base64Value) {
  const value = Buffer.from(base64Value, "base64").toString("hex");
  // first 8 bytes are the price
  const price = BigInt("0x" + value.slice(0, 16));

  return price;
}

function parseOracleAdapterValue(base64Value) {
  const value = Buffer.from(base64Value, "base64").toString("hex");
  // first 8 bytes are if Tinyman
  const isTinyman = Number(`0x${value.slice(0, 16)}`);
  // next 16 bytes are asset ids
  const asset0Id = Number(`0x${value.slice(16, 32)}`);
  const asset1Id = Number(`0x${value.slice(32, 48)}`);

  // check if LP token is Tinyman or Pact
  if (isTinyman) {
    // next 32 bytes are tinyman pool address
    const poolAddress = encodeAddress(Buffer.from(value.slice(48, 112), "hex"));
    return { provider: "Tinyman", asset0Id, asset1Id, poolAddress };
  } else {
    // next 8 bytes are pact pool app id
    const poolAppId = Number(`0x${value.slice(48, 64)}`);
    return { provider: "Pact", asset0Id, asset1Id, poolAppId };
  }
}

function getParsedValueFromState(state, key, encoding = "utf8") {
  const encodedKey = encoding ? encodeToBase64(key, encoding) : key;
  const keyValue = state.find((entry) => entry.key === encodedKey);
  if (keyValue === undefined) return;
  const { value } = keyValue;
  if (value.type === 1) return value.bytes;
  if (value.type === 2) return BigInt(value.uint);
  return;
}

async function getAppState(appId) {
  const res = await lookupApplications(appId);
  return res.application.params["global-state"];
}

/**
 * Calculate the sqrt of a bigint (rounded down to nearest integer)
 * @param value value to be square-rooted
 * @return bigint sqrt
 */
function sqrt(value) {
  if (value < BigInt(0))
    throw Error("square root of negative numbers is not supported");

  if (value < BigInt(2)) return value;

  function newtonIteration(n, x0) {
    const x1 = (n / x0 + x0) >> BigInt(1);
    if (x0 === x1 || x0 === x1 - BigInt(1)) return x0;
    return newtonIteration(n, x1);
  }

  return newtonIteration(value, BigInt(1));
}

/**
 * Calculates the LP price
 * @param r0 pool supply of asset 0
 * @param r1 pool supply of asset 1
 * @param p0 price of asset 0
 * @param p1 price of asset 1
 * @param lts circulating supply of liquidity token
 * @return bigint LP price
 */
function calcLPPrice(r0, r1, p0, p1, lts) {
  return BigInt(2) * (sqrt(r0 * p0 * r1 * p1) / lts);
}

function isTinymanLPTokenPool(pool) {
  return "poolAppAddress" in pool;
}

function isPactLPTokenPool(pool) {
  return "poolAppId" in pool;
}

module.exports = {
  fromIntToBytes8Hex,
  encodeToBase64,
  parseOracleValue,
  parseOracleAdapterValue,
  getParsedValueFromState,
  getAppState,
  isTinymanLPTokenPool,
  isPactLPTokenPool,
  calcLPPrice,
};

'''
'''--- projects/foodcourt/index.js ---

const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: getUniTVL({
      chain: 'bsc',
      factory: '0xc801C7980c8C7900Bc898B1F38392b235fF64097',
      coreAssets: [
        '0xe9e7cea3dedca5984780bafc599bd69add087d56',
      ],
    }),
  },
  reichain: {
    tvl: getUniTVL({
      chain: 'reichain',
      factory: '0xC437190E5c4F85EbBdE74c86472900b323447603',
      coreAssets: [
        '0xf8ab4aaf70cef3f3659d3f466e35dc7ea10d4a5d', // killswitch BNB
        '0xDD2bb4e845Bd97580020d8F9F58Ec95Bf549c3D9', // killswitch BUSD
      ],
    }),
  }
}

'''
'''--- projects/forcedao/abi.json ---
{
    "underlyingBalanceWithInvestment": {
        "constant": true,
        "inputs": [],
        "name": "underlyingBalanceWithInvestment",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/forcedao/index.js ---
const sdk = require("@defillama/sdk");
const { request, gql } = require("graphql-request");
const abi = require('./abi.json')
const {unwrapCrv, unwrapUniswapLPs} = require('../helper/unwrapLPs')

const graphUrl = 'https://api.thegraph.com/subgraphs/name/axejintao/delta-dao'
const graphQuery = gql`
query GET_VAULTS($block: Int) {
  vaults(
    block: { number: $block }
  ) {
    id
    name
    token {
      id
    }
  }
}
`;

async function tvl(timestamp, block) {
  let balances = {};

  const {vaults} = (await request(
    graphUrl,
    graphQuery,
    {
      block,
    }
  )) //.filter(vault=>!vault.name.startsWith('DELTA'))

  const lockedTokens = (await sdk.api.abi.multiCall({
    abi: abi['underlyingBalanceWithInvestment'],
    calls: vaults.map(vault=>({
      target: vault.id
    })),
    block
  })).output
  const lpPositions = []
  await Promise.all(lockedTokens.map(async call=>{
    const vault = vaults.find(vault=>vault.id===call.input.target.toLowerCase());
    const underlyingTokenBalance = call.output
    if(vault.name.endsWith('3Crv')){
      await unwrapCrv(balances, vault.token.id, underlyingTokenBalance, block)
    } else if(vault.name.endsWith('SLP')){
      lpPositions.push({
        token: vault.token.id,
        balance: underlyingTokenBalance
      })
    } else {
      sdk.util.sumSingleBalance(balances, vault.token.id, underlyingTokenBalance)
    }
  }))
  await unwrapUniswapLPs(balances, lpPositions, block)
  return balances
}
  

module.exports = {
  start: 0, // WRONG!
  ethereum: {
    tvl,
  },
  broken: 'Api is down and the project is winding down: https://forcedao.medium.com/winding-down-and-redistribution-8ed28220101b, '
}
'''
'''--- projects/fortress/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasuryAddress = "0xb8e8d2E97C5F4594F65CCe0f5888C641C7A3a056";
module.exports = ohmTvl(treasuryAddress, [
  ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false],
  ["0x130966628846bfd36ff31a822705796e8cb8c18d", false],
  ["0x3e5f198b46f3de52761b02d4ac8ef4ceceac22d6", true],
  ["0x2a91134162e2da1394df9e5e64608109d73ed3a0", true],
], "avax", "0x4D8ba74820e2d6EaD2Ea154586CB7dfbA8A691aa", "0xf6d46849db378ae01d93732585bec2c4480d1fd5", undefined, undefined, true)

'''
'''--- projects/fortube-v3/index.js ---
const utils = require('../helper/utils');

/* * * * * * * *
* ==> Correct adapter needs to be created.
*
*****************/
async function fetch() {
  let data = await utils.fetchURL('https://api.for.tube/api/v1/bank/public/markets/TVL')
  return data.data
}

module.exports = {
  fetch
}

'''
'''--- projects/fortube/abi.json ---
{
    "getCollateralMarketsLength": {
        "constant": true,
        "inputs": [],
        "name": "getCollateralMarketsLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "collateralTokens": {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "collateralTokens",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "mkts": {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "mkts",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "accrualBlockNumber",
                "type": "uint256"
            },
            {
                "internalType": "int256",
                "name": "supplyRate",
                "type": "int256"
            },
            {
                "internalType": "int256",
                "name": "demondRate",
                "type": "int256"
            },
            {
                "internalType": "contract IInterestRateModel",
                "name": "irm",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "totalSupply",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "supplyIndex",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalBorrows",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "borrowIndex",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalReserves",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "minPledgeRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "liquidationDiscount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "decimals",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getAllMarkets": {
        "constant": true,
        "payable": false,
        "inputs": [],
        "name": "getAllMarkets",
        "outputs": [
            {
                "internalType": "contract IFToken[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "APR": {
        "constant": true,
        "payable": false,
        "inputs": [],
        "name": "APR",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "APY": {
        "constant": true,
        "payable": false,
        "inputs": [],
        "name": "APY",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrows": {
        "constant": true,
        "payable": false,
        "inputs": [],
        "name": "totalBorrows",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}

'''
'''--- projects/fortube/index.js ---
  const sdk = require("@defillama/sdk");

  const abi = require("./abi.json");
  const BigNumber = require("bignumber.js");
  const axios = require("axios")
  const {unwrapUniswapLPs} = require('../helper/unwrapLPs')
  const {getBlock} = require('../helper/getBlock')
  const {toUSDTBalances} = require('../helper/balances')
  
  const ForTube = "0xE48BC2Ba0F2d2E140382d8B5C8f261a3d35Ed09C";
  const ForTubeV2 = "0x936E6490eD786FD0e0f0C1b1e4E1540b9D41F9eF";
  const EthAddress = "0x0000000000000000000000000000000000000000";
  const EthAddressV2 = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const V2BLOCK = 10808868;
  
  async function getCollateralMarketsLength(block) {
    return (
      await sdk.api.abi.call({
        block,
        target: ForTube,
        params: [],
        abi: abi["getCollateralMarketsLength"],
      })
    ).output;
  }
  
  // returns [addresses]
  async function getErc20Assets(block) {
    let erc20Assets = [];
    let calls = [];
    let length = await getCollateralMarketsLength(block);
    for (var i = 0; i < length; i++) {
      calls.push({
        target: ForTube,
        params: i,
      });
    }
    let erc20AssetResults = await sdk.api.abi.multiCall({
      block,
      calls: calls,
      abi: abi["collateralTokens"],
    });
    erc20AssetResults.output.forEach((result) => {
      if (result.output != EthAddress) {
        erc20Assets.push(result.output);
      }
    });
  
    return erc20Assets;
  }
  
  async function allUnderlyingMarkets(block) {
    let fTokens = await getAllMarkets(block);
    let erc20AssetsV2 = [];
    let underlyings = await sdk.api.abi.multiCall({
      block,
      calls: fTokens.map((fToken) => ({
        target: fToken,
        params: [],
      })),
      abi: abi['underlying']
    });

    underlyings.output.forEach((result) => {
      if (result.output != EthAddressV2) {
        erc20AssetsV2.push(result.output);
      }
    });
    return erc20AssetsV2;
  }

  async function getAllMarkets(block) {
    return (await sdk.api.abi.call({
      block,
      target: ForTubeV2,
      abi: abi['getAllMarkets'],
    })).output;
  }

  async function eth(timestamp, block) {
    let balances = {};
    let erc20Assets = await getErc20Assets(block);
  
    // Get erc20 assets locked
    let balanceOfResults = await sdk.api.abi.multiCall({
      block,
      calls: erc20Assets.map((asset) => ({
        target: asset,
        params: ForTube,
      })),
      abi: "erc20:balanceOf",
    });
  
    //add ETH tvl
    balances[EthAddress] = (
      await sdk.api.eth.getBalance({ target: ForTube, block })
    ).output;

    //10808868 is First Deposit Tx blockNumber in ForTube V2
    if (block > V2BLOCK) {
      const ethBalance2 = (await sdk.api.eth.getBalance({ target: ForTubeV2, block })).output;
      balances[EthAddress] = BigNumber(balances[EthAddress]).plus(ethBalance2).toFixed();

      let erc20AssetsV2 = await allUnderlyingMarkets(block);
      let balanceOfResultsV2 = await sdk.api.abi.multiCall({
        block,
        calls: erc20AssetsV2.map((assetV2) => ({
          target: assetV2,
          params: ForTubeV2,
        })),
        abi: "erc20:balanceOf",
      });

      sdk.util.sumMultiBalanceOf(balances, balanceOfResultsV2);
    }

    sdk.util.sumMultiBalanceOf(balances, balanceOfResults);
  
    return balances;
  }

  async function unwrapVaultLP(balances, vaultAddress, amount, block){
    const underlyingToken = await sdk.api.abi.call({
      target: vaultAddress,
      block,
      chain: 'bsc',
      abi: {"inputs":[],"name":"token","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"}
    })
    await unwrapUniswapLPs(balances, [{
      token: underlyingToken.output,
      balance: amount // Not really, but pricePerShare ~= 1
    }], block, 'bsc', addr=>`bsc:${addr}`)
  }

  const fortubeCollateralBsc = "0xc78248D676DeBB4597e88071D3d889eCA70E5469"
  const wbnb = "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
  async function bsc(_timestamp, _ethBlock, chainBlocks){
    const balances = {}
    const markets = await axios.get("https://api.for.tube/api/v1/bank/public/chain/BSC-Inno/markets")

    const tokens = markets.data.data.map((val)=>val.token_address)
    const tokenBalances = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      chain: 'bsc',
      block: chainBlocks['bsc'],
      calls: tokens.map(token=>({
        target: token,
        params: [fortubeCollateralBsc]
      }))
    })
    const unwrapCalls = []
    tokenBalances.output.map((call, idx)=>{
      const token = call.input.target
      if(token === "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"){
        return
      }
      const symbol = markets.data.data[idx].token_symbol
      if(symbol.startsWith('v')){
        if(symbol === "v4Belt" || symbol === "v3EPS"){
          sdk.util.sumSingleBalance(balances, '0x4fabb145d64652a948d72533023f6e7a623c7c53', call.output) // BUSD
        } else {
          unwrapCalls.push(unwrapVaultLP(balances, token, call.output, chainBlocks['bsc']))
        }
      }else {
        sdk.util.sumSingleBalance(balances, 'bsc:'+token, call.output)
      }
    })
    await Promise.all(unwrapCalls)
    console.log('call')
    const bnbCollateral = await sdk.api.eth.getBalance({
      target: fortubeCollateralBsc,
      chain: 'bsc',
      block: chainBlocks['bsc']
    })
    sdk.util.sumSingleBalance(balances, wbnb, bnbCollateral.output)
    return balances
  }

  /*
  const okexPool = "0x33d6d5f813bf78163901b1e72fb1feb90e72fd72"
  async function okexchain(timestamp, _ethBlock, chainBlocks){
    const markets = await axios.get("https://api.for.tube/api/v1/bank/public/chain/OEC-Inno/markets")
    const tokenBalances = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      chain: 'okexchain',
      block: await getBlock(timestamp, 'okexchain', chainBlocks),
      calls: markets.data.data.map(token=>({
        target: token.token_address,
        params: [okexPool]
      }))
    })
    const balances = {}
    sdk.util.sumMultiBalanceOf(balances, tokenBalances, d=>`okexchain:${d}`)
    return balances
  }
  */
  async function okexchain(_timestamp, _ethBlock, chainBlocks){
    const markets = await axios.get("https://api.for.tube/api/v1/bank/public/chain/OEC-Inno/markets")
    const usdCollateral = markets.data.data.reduce((acc, val)=> acc + val.token_price * val.global_token_reserved, 0)
    return toUSDTBalances(usdCollateral)
  }
  async function iotexchain(_timestamp, _ethBlock, chainBlocks){
    const markets = await axios.get("https://api.for.tube/api/v1/bank/public/chain/IoTeX-Inno/markets")
    const usdCollateral = markets.data.data.reduce((acc, val)=> acc + val.token_price * val.global_token_reserved, 0)
    return toUSDTBalances(usdCollateral)
  }
  async function polygonchain(_timestamp, _ethBlock, chainBlocks){
    const markets = await axios.get("https://api.for.tube/api/v1/bank/public/chain/Polygon-Inno/markets")
    const usdCollateral = markets.data.data.reduce((acc, val)=> acc + val.token_price * val.global_token_reserved, 0)
    return toUSDTBalances(usdCollateral)
  }
  
  module.exports = {
    methodology: "4belt and 3EPS are replaced by BUSD",
    start: 1596384000, // 2020/8/3 00:00:00 +UTC
    bsc: {
      tvl: bsc
    },
    ethereum: {
      tvl: eth
    },
    okexchain: {
      tvl: okexchain
    },
    iotex: {
      tvl: iotexchain
    },
    polygon: {
      tvl: polygonchain
    },
    
  };
  

'''
'''--- projects/fortunedao.js ---
const { ohmTvl } = require('./helper/ohm')

module.exports=ohmTvl("0xC8F249cDCDCBBa52d0908Dd201F20Af926710a9c", [
    ["0xF2001B145b43032AAF5Ee2884e456CCd805F677D", false],
    ["0x88ef5a29eEc8BAAAb8c1111A57Ad2FCeC8aD6109", true],
], "cronos", "0xAFfB721B859db8300F7a13d8E80E7b74845Fe47a", "0xcA558149225Fb386B9c26716e8C35a650C74d35e",
()=>"0x6b175474e89094c44da98b954eedeac495271d0f", undefined, false)

'''
'''--- projects/fountain.js ---
const { compoundExports } = require("./helper/compound");
const { transformOasisAddressBase } = require('./helper/portedTokens')

module.exports = {
    timetravel: true,
    aurora: {
        ...compoundExports(
            '0xA7684aE7e07Dac91113900342b3ef25B9Fd1D841',
            'oasis',
            '0xD7d588bAbFb99E82Cd6dd0cA7677A5599AA678B5',
            '0x21C718C22D52d0F3a789b752D4c2fD5908a8A733',
            transformOasisAddressBase,
            )
    },
}; // node test.js projects/fountain.js
'''
'''--- projects/fractal-protocol/index.js ---
const sdk = require('@defillama/sdk')
const getTokenPrice = {"inputs":[],"name":"getTokenPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
const USDF_TOKEN_CONTRACT = '0x51acB1ea45c1EC2512ae4202B9076C13016dc8aA';
const FRACTAL_VAULT_CONTRACT = '0x3eB82f2eD4d992dc0Bed328214A0907250f4Ec82';

async function tvl(timestamp, block) {
  const { output: totalSupply } = await sdk.api.erc20.totalSupply({ target: USDF_TOKEN_CONTRACT, block }) 
  const { output: price } = await sdk.api.abi.call({ target: FRACTAL_VAULT_CONTRACT, block, abi: getTokenPrice }) 

  return {
    'usd-coin': totalSupply * price / 1e12
  }
}

module.exports = {
  ethereum: {
    methodology: "USDF is minted when USDC is deposited into the Fractal Vault. TVL = totalSupply * usdfPrice.",
    tvl,
  }
}

'''
'''--- projects/fractional-art.js ---
const sdk = require("@defillama/sdk");
const { BigNumber } = require("bignumber.js");
const utils = require('./helper/utils');

// Retrieve needed vaults attributes from REST API
const fractional_api_url = 'https://mainnet-api.fractional.art/vaults?perPage=12' // &page=1' 
async function retrieveVaultsAPI() {
  // Get page count
  const page1 = await utils.fetchURL(fractional_api_url + '&page=1')
  let pageCount = page1.data.metadata.pagination.total_pages;
  //pageCount = 1 // uncomment for for debug

  const vaults = []
  let openedVaultsCount = 0
  for (let i = 0; i < pageCount; i++) {
    let vaults_i = await utils.fetchURL(fractional_api_url + `&page=${i+1}`)
    // Filter out unwanted attributes: keep analytics.tvlUsd, pools, contractAddress, symbol, slug, collectables
    vaults_i = vaults_i.data.data.map(({ analytics, pools, contractAddress, symbol, slug, collectables, isClosed, tokenAddress }) => ({analytics, pools, contractAddress, symbol, slug, collectables, isClosed, tokenAddress}))

    // Note : Could filter out closed vaults, but their tokens can still be provided to pools, so not filtering
    openedVaultsCount += vaults_i.filter(vault => !vault.isClosed).length

    // Append to complete vaults array
    vaults.push(...vaults_i)
  }
  return {vaults, openedVaultsCount}
}

// This API returns a list of vaults similar to the following exampleVaultDebug
function exampleVaultDebug() {
  return {
    "symbol":	"DOG",
    "contractAddress":	"0xbaac2b4491727d78d2b78815144570b9f2fe8899",
    "pools":	[ {
      "pool":	"0x7731CA4d00800b6a681D031F565DeB355c5b77dA",
      "token0":	"0xBAac2B4491727D78D2b78815144570b9f2Fe8899",
      "token1":	"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      "provider":	"UNISWAP_V3"
    }],
    "tokenAddress":	"0xabEFBc9fD2F806065b4f3C237d4b59D9A97Bcac7",
    "analytics": {
      "tvlUsd": 21790624
    },
    "slug":	"the-doge-nft",
    "isClosed":	false,
  }
}

// Get Fractional.art TVL
async function tvl(timestamp, block, chainBlocks, chain) {
  // Get vaults and Compute vaults TVL (trusting fractional rest api)
  const {vaults, openedVaultsCount} = await retrieveVaultsAPI()
  const vaulstTVL_api = getVaultsTvlApi(vaults)
  // note: vault with slug fractional-dream-930 has null analytics and symbol, because it is an ERC1155 not listed on any DEXes
  
  // Or try to find all pools associated to vault and account for tokens locked against vault token
  // In pool: provider, pool, token0, token1
  const univ2_sushiv1_pools = []
  const univ3_pools = []
  vaults.forEach(vault => {
    vault.pools.forEach(pool => {
      // Swap token0 and token1 if needed so token0 is always vault token
      if (vault.contractAddress.toLowerCase() === pool.token1.toLowerCase()) {
        const tmp = pool.token1
        pool.token1 = pool.token0
        pool.token0 = tmp
      }
      // Pool provider can be any of ['UNISWAP_V3', 'SUSHISWAP_V1', 'UNISWAP_V2']
      const provider = pool.provider
      if ((provider === 'UNISWAP_V2') || (provider === 'SUSHISWAP_V1')) {
        univ2_sushiv1_pools.push(pool)
      } else if (provider === 'UNISWAP_V3') {
        univ3_pools.push(pool)
      }
    })
  })
  // Concat v2 and v3 pools
  const v2_v3_pools = univ3_pools.concat(univ2_sushiv1_pools)

  // Retrieve balances from onchain calls
  let balances = {}

  // Get UNISWAP_V3 LPs
  // Simply get amount of token0 and token1 allocated to pool contract. And since we only need the token1 it is even more efficient
  const calls_v3_v2_t0_t1 = v2_v3_pools.map((pool) => ({ 
      target: pool.token1,
      params: pool.pool
    }))
  /*
  const calls_v3_t1 = univ3_pools.map((pool) => ({ // 33.67 // 20.69
      target: pool.token1,
      params: pool.pool
    }))
  const calls_v3_t0_t1 = univ3_pools.map((pool) => ({ // 69.12 // 20.69 univ2_sushiv1_pools
    target: pool.token1,
    params: pool.pool
  })).concat(univ3_pools.map((pool) => ({
      target: pool.token0,
      params: pool.pool
    })))
  */
  
  const poolBalance = await sdk.api.abi.multiCall({ 
    block,
    calls: calls_v3_v2_t0_t1, // calls_v3_t0_t1
    abi: 'erc20:balanceOf'
  })
  balances = {}
  sdk.util.sumMultiBalanceOf(balances, poolBalance)

  // Remove vaults tokens balances as they should not account for TVL. 
  // TODO: Choose if we remove the vaults tokens from pooled balances or not

  return balances
}

// Using fractional REST API, a TVL is returned in USD, stored as USDC
function getVaultsTvlApi(vaults) {
  return vaults.reduce((acc, vault) => acc.plus(BigNumber(vault.analytics ? vault.analytics.tvlUsd : 0)), BigNumber(0))
}

const usdc = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
async function tvl_api(timestamp, block, chainBlocks, chain) {
  const {vaults, openedVaultsCount} = await retrieveVaultsAPI()
  return {[usdc]: getVaultsTvlApi(vaults).times(1e6)} 
}

module.exports = {
  ethereum: { tvl },
  methodology: `TVL is the total quantity of tokens held in LPs against any vault token. Each vault has a token, which is provided as LP in several pools returned by fractional REST API. Do not account for vault token locked in pools as contributing to TVL.`
}

// ------------
// Alternatives
// ------------

// 1. COULD USE unwrapUniswapLPs with lpPositions set to erc20:totalSupply of pool but does not work for uni_v3
/*
  // Get UNISWAP_V2 and SUSHISWAP_V1 LPs
  // Call unwrapUniswapLPs with lpPositions set to totalSupply of LP token. So you unwrap the whole pool without needing to pull reserves of token1 - only pull totalSupply of LP token
  const univ2_sushiv1_pairAddresses = univ2_sushiv1_pools.map(p => p.pool)
  const univ3_pairAddresses = univ3_pools.map(p => p.pool)
  const lpSupply = (await sdk.api.abi.multiCall({
    block,
    abi: 'erc20:totalSupply',
    calls: univ2_sushiv1_pairAddresses.map(address=>({ // cannot retrieve uni_v3 balances
        target: address
    })),
    chain
  })).output
  // Format the way unwrapUniswapLPs function requires the token/balance pairs
  const lpPositions = lpSupply.map(call => ({
    token: call.input.target,
    balance: call.output
  }))
  // Accumulate to balances
  await unwrapUniswapLPs(balances, lpPositions, block, chain=chain)
  */

// 2. COULD USE staking contract, but too slow to retrieve call by call the amount of tokens
/*
const { staking } = require("./helper/staking.js");
balances = {}
for (const pool of v2_v3_pools) { // univ3_pools
  const token1_locked = staking(pool.pool, pool.token1, chain="ethereum")
  token1_pool_balance = await token1_locked(timestamp, block, chainBlocks)

  sdk.util.sumSingleBalance(balances, pool.token1, token1_pool_balance[pool.token1]);
  // sdk.util.sumMultiBalanceOf(balances, [token1_pool_balance], true);
}
*/

// 3. COULD USE core/index.js functions to get TL locked in given Uniswap pools, but too much to copy-paste from ./CORE/INDEX.JS
/*
const {getUniswapPairInfo, getPairUnderlyingReserves, flattenUnderlyingReserves} = require('./core/index.js');
Would need to copy-paste these functions are export them by module
const pairInfo = await getUniswapPairInfo(univ2_sushiv1_pairAddresses, timestamp, block);
const underlyingReserves = await Promise.all(pairInfo.map(info => getPairUnderlyingReserves(info, timestamp, block)));
let balances = flattenUnderlyingReserves(underlyingReserves);
*/
'''
'''--- projects/francium.js ---
const retry = require("./helper/retry");
const axios = require("axios");

async function fetch() {
  const response = (
    await retry(async (bail) => await axios.get("https://francium.io/api/pools/liquidity"))
  ).data.data;

  const poolLiqArray = response.farm.map(pool => pool.liquidityLocked);
  const lendArray = response.lend.map(pool => pool.available);
  const tvl = [...poolLiqArray, ...lendArray, response.old].reduce((a, b) => a + b, 0);

  return tvl;
}

module.exports = {
  timetravel: false,
  methodology: 'Value of total LP tokens locked + deposits that are not borrowed.',
  fetch,
};

'''
'''--- projects/fraxfinance/abi.json ---
{
    "usdValueInVault": {
        "inputs": [],
        "name": "usdValueInVault",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "collatDollarBalance": {
        "inputs": [],
        "name": "collatDollarBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "borrowed_frax": {
        "inputs": [],
        "name": "borrowed_frax",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/fraxfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const { staking, stakings } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");
const { sumTokens } = require("../helper/unwrapLPs");

const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const FXS = "0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0";

const FEI3CRVs = [
  "0x70F55767B11c047C8397285E852919F5f6c8DC60",
  "0xE4BD0461AE7fdc76c61CE286a80c9B55d83B204a",
];

const contractAddresses = [
  //FRAX3CRV
  "0x49ee75278820f409ecd67063D8D717B38d66bd71",
  //CURVE_AMO
  "0x72170Cdc48C33a6AE6B3E83CD387ca3Fb9105da2",
  //FRAX_AMO_MINTER
  "0xcf37B62109b537fa0Cb9A90Af4CA72f6fb85E241",
  //LENDING_AMO
  "0x9507189f5B6D820cd93d970d67893006968825ef",
  //MANUAL_AMO
  "0x1Be588641Fb28Eb8C2A51f1129707FB1E2683f5a",
  //USDC_POOL_V1
  "0x3C2982CA260e870eee70c423818010DfeF212659",
  //USDC_POOL_V2
  "0x1864Ca3d47AaB98Ee78D11fc9DCC5E7bADdA1c0d",
  //USDC_POOL_V3
  "0x2fE065e6FFEf9ac95ab39E5042744d695F560729",
  //INVESTOR_COLLATERAL_POOL
  "0xEE5825d5185a1D512706f9068E69146A54B6e076",
  //INVESTOR_AMO_V2
  "0xB8315Af919729c823B2d996B1A6DDE381E7444f1",
];

const veFXS_StakingContract = "0xc8418aF6358FFddA74e09Ca9CC3Fe03Ca6aDC5b0";

const POOL_STAKING_CONTRACTS = [
  "0xD875628B942f8970De3CcEaf6417005F68540d4f",
  "0xa29367a3f057F3191b62bd4055845a33411892b6",
  "0xda2c338350a0E59Ce71CDCED9679A3A590Dd9BEC",
  "0xDc65f3514725206Dd83A8843AAE2aC3D99771C88",
];
const LP_ADDRESSES = [
  //Uniswap FRAX/WETH LP
  "0xFD0A40Bc83C5faE4203DEc7e5929B446b07d1C76",
  //Uniswap FRAX/USDC LP
  "0x97C4adc5d28A86f9470C70DD91Dc6CC2f20d2d4D",
  //Uniswap FRAX/FXS LP
  "0xE1573B9D29e2183B1AF0e743Dc2754979A40D237",
  //Uniswap FXS/WETH LP
  "0xecBa967D84fCF0405F6b32Bc45F4d36BfDBB2E81",
];

const treasuryContracts = [
  "0x63278bF9AcdFC9fA65CFa2940b89A34ADfbCb4A1",
  "0x8D4392F55bC76A046E443eb3bab99887F4366BB0",
  "0xa95f86fE0409030136D6b82491822B3D70F890b3",
  "0x9AA7Db8E488eE3ffCC9CdFD4f2EaECC8ABeDCB48",
  "0x874a873e4891fB760EdFDae0D26cA2c00922C404",
];

const ethereumTvl = async (timestamp, block) => {
  let balances = {};

  // --- CurveMetapoolLockerAMOs USDC TVL ---
  const usdValueInVault = (
    await sdk.api.abi.multiCall({
      calls: FEI3CRVs.map((addr) => ({ target: addr })),
      abi: abi.usdValueInVault,
      block,
    })
  ).output.map((value) => value.output);

  usdValueInVault.forEach((value) => {
    sdk.util.sumSingleBalance(
      balances,
      USDC,
      BigNumber(value)
        .dividedBy(10 ** 12)
        .toFixed(0)
    );
  });

  // --- USDC POOLs + AMOs + FRAX3CRV and FEI3CRVs ---
  const usdcTvls = (
    await sdk.api.abi.multiCall({
      calls: contractAddresses.map((addr) => ({ target: addr })),
      abi: abi.collatDollarBalance,
      block,
    })
  ).output.map((response) => response.output);

  usdcTvls.forEach((usdcTvl) => {
    sdk.util.sumSingleBalance(
      balances,
      USDC,
      BigNumber(usdcTvl)
        .dividedBy(10 ** 12)
        .toFixed(0)
    );
  });

  return balances;
};

// Fantom
const contractAddressesFantom = [
  //Spirit/Ola Lending AMO Fantom
  "0x8dbc48743a05A6e615D9C39aEBf8C2b157aa31eA",
  //Scream Lending AMO Fantom
  "0x51E6D09d5A1EcF8BE035BBCa82F77BfeC3c7672A",
  //SpiritSwap Liquidity AMO Fantom
  "0x48F0856e0E2D06fBCed5FDA10DD69092a500646B",
];

const fantomTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const chain = "fantom"
  const block = chainBlocks[chain]
  // --- AMO's ---
  const usdcTvls = (
    await sdk.api.abi.multiCall({
      calls: contractAddressesFantom.map((addr) => ({ target: addr })),
      abi: abi.borrowed_frax,
      block,
      chain,
    })
  ).output.map((response) => response.output);

  usdcTvls.forEach((usdcTvl) => {
    sdk.util.sumSingleBalance(
      balances,
      USDC,
      BigNumber(usdcTvl)
        .dividedBy(10 ** 12) // // Convert to 6 decimal USDC values
        .toFixed(0)
    );
  });

  // --- Liquidity staking ---

  // Curve FRAX2Pool
  await sumTokens(balances, [
    ["0x8866414733f22295b7563f9c5299715d2d76caf4", "0x7a656b342e14f745e2b164890e88017e27ae7320"],
    ["0x04068da6c83afcfa0e13ba15a6696662335d5b75", "0xbea9f78090bdb9e662d8cb301a00ad09a5b756e9"]
  ], block, chain, addr => addr === "0x8866414733f22295b7563f9c5299715d2d76caf4" ? "0x6b175474e89094c44da98b954eedeac495271d0f" : `${chain}:${addr}`)

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    treasury: stakings(treasuryContracts, FXS),
    staking: staking(veFXS_StakingContract, FXS),
    pool2: pool2s(POOL_STAKING_CONTRACTS, LP_ADDRESSES),
    tvl: ethereumTvl,
  },
  fantom: {
    tvl: fantomTvl
  },
  methodology:
    "Counts liquidty as the Collateral USDC on all AMOs, USDC POOLs, FRAX3CRV and FEI3CRVs through their Contracts",
};
'''
'''--- projects/freeliquid/index.js ---
const { staking } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");

const stakingContracts = [
    "0x5E4935fe0f1f622bfc9521c0e098898e7b8b573c",
    "0x975Aa6606f1e5179814BAEf22811441C5060e815"
];
const FL = "0xffed56a180f23fd32bc6a1d8d3c09c283ab594a8";

const lpStakingContract_USDFL = "0x001F7C987996DBD4f1Dba243b0d8891D0Bf693A2";
const lpStakingContract_FL = "0x34e2B546D1819fE428c072080829028aF36540DD";

const pool2Lps_USDFL = [
    //USDFL-DAI
    "0xA8216F6eb1f36E1dE04D39C3BC7376D2385f3455",
    //USDFL-USDN
    "0x85790C03400b7F6d35895dBB7198c41ecDe4a7F7",
    //USDFL-USDT
    "0xeDf7a6fB0d750dd807375530096Ebf2e756eaEE0",
    //USDFL-USDC
    "0x481c830edC1710E06e65c32bd7c05ADd5516985b",
];

const pool2Lps_FL = [
    //DAI-FL
    "0xc869935EFE9264874BaF7940449925318f193322",
    //USDFL-FL
    "0xF03756E7a2B088A8c5D042C764184E8748dFA10d",
    //USDT-FL
    "0x6E35996aE06c45E9De2736C44Df9c3f1aAb781af",
    //USDC-FL
    "0xeC314D972FC771EAe56EC5063A5282A554FD54a2"
];

const Staking = async (...params) => {
    for (const stakingContract of stakingContracts) {
        return staking(stakingContract, FL)(...params);
    }
};

const Pool2 = async (...params) => {
    for (const stakingContract of [lpStakingContract_USDFL, lpStakingContract_FL]) {
        if (stakingContract == lpStakingContract_FL) {
            return pool2s([lpStakingContract_FL], pool2Lps_FL)(...params);
        } else {
            return pool2s([lpStakingContract_USDFL], pool2Lps_USDFL)(...params);
        }
    }
};

module.exports = {
    ethereum: {
        staking: Staking,
        pool2: Pool2,
        tvl: async => ({})
    },
    methodology:
        "Counts liquidity on the Save through StakingReward Contracts",
};

'''
'''--- projects/freeriver/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

const wMOVR = "0x98878B06940aE243284CA214f92Bb71a2b032B8A" // their own barely used version

module.exports={
    misrepresentedTokens: true,
    tvl: calculateUsdUniTvl("0x52abD262B13bef4E65Ff624880E8A0595a17af48", "moonriver", wMOVR, 
    [
        '0x63F2ADf5f76F00d48fe2CBef19000AF13Bb8de82', // FREE
        '0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d', // USDC
        '0xb44a9b6905af7c801311e8f4e76932ee959c663c', // USDT
        '0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c', // WETH
        '0x5d9ab5522c64e1f6ef5e3627eccc093f56167818', // BUSD
    ], "moonriver")
}
'''
'''--- projects/friktion/index.js ---
const axios = require("axios");
async function tvl() {
  const friktionSnapshotResponse = await axios.get(
    "https://raw.githubusercontent.com/Friktion-Labs/mainnet-tvl-snapshots/main/friktionSnapshot.json"
  );

  const friktionSnapshot = friktionSnapshotResponse.data;

  if (
    !(
      friktionSnapshot &&
      typeof friktionSnapshot === "object" &&
      typeof friktionSnapshot.totalTvlUSD === "number" &&
      friktionSnapshot.coinsByCoingeckoId !== null &&
      typeof friktionSnapshot.coinsByCoingeckoId === "object" &&
      Object.keys(friktionSnapshot.coinsByCoingeckoId).length > 5
    )
  ) {
    console.log(friktionSnapshot);
    throw new Error("Unexpected shape of friktionShapshot");
  }

  if (!friktionSnapshot.totalTvlUSD || friktionSnapshot.totalTvlUSD < 1000000) {
    console.log(friktionSnapshot);
    throw new Error("Unexpected totalTvlUSD");
  }

  return friktionSnapshot.coinsByCoingeckoId;
}

module.exports = {
  timetravel: false,
  methodology:
    "TVL is scraped from the window.friktionSnapshot variable in app.friktion.fi and saved to the GitHub repo at Friktion-Labs/mainnet-tvl-snapshots. The data is the same as what is displayed on the app",
  tvl,
};

'''
'''--- projects/fringe/index.js ---
const sdk = require('@defillama/sdk');
const PIT = require('./pit-abi.json');

const PRIMARY_LENDING_PLATFORM = "0x46558DA82Be1ae1955DE6d6146F8D2c1FE2f9C5E";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};

  const lendingTokensLength = Number((await sdk.api.abi.call({
    abi: PIT["getLendingTokensLength"],
    chain: 'ethereum',
    target: PRIMARY_LENDING_PLATFORM,
    params: [],
    block: chainBlocks['ethereum'],
  })).output);
  for (let i = 0; i < lendingTokensLength; i++) {
    const lendingToken = (await sdk.api.abi.call({
      abi: PIT["getLendingTokenByIndex"],
      chain: 'ethereum',
      target: PRIMARY_LENDING_PLATFORM,
      params: [i.toString()],
      block: chainBlocks['ethereum'],
    })).output;

    const bLendingToken = (await sdk.api.abi.call({
      abi: PIT["getLendingTokenInfo"],
      chain: 'ethereum',
      target: PRIMARY_LENDING_PLATFORM,
      params: [lendingToken],
      block: chainBlocks['ethereum'],
    })).output['bLendingToken'];

    const balance = (await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      chain: 'ethereum',
      target: lendingToken,
      params: [bLendingToken],
      block: chainBlocks['ethereum'],
    })).output;

    await sdk.util.sumSingleBalance(balances, lendingToken, balance);
  }

  const projectTokensLength = Number((await sdk.api.abi.call({
    abi: PIT["getProjectTokensLength"],
    chain: 'ethereum',
    target: PRIMARY_LENDING_PLATFORM,
    params: [],
    block: chainBlocks['ethereum'],
  })).output);
  for (let i = 0; i < projectTokensLength; i++) {
    const projectToken = (await sdk.api.abi.call({
      abi: PIT["getProjectTokenByIndex"],
      chain: 'ethereum',
      target: PRIMARY_LENDING_PLATFORM,
      params: [i.toString()],
      block: chainBlocks['ethereum'],
    })).output;

    const balance = (await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      chain: 'ethereum',
      target: projectToken,
      params: [PRIMARY_LENDING_PLATFORM],
      block: chainBlocks['ethereum'],
    })).output;

    await sdk.util.sumSingleBalance(balances, projectToken, balance);
  }

  return balances;
}

module.exports = {
  timetravel: true,
  methodology: 'Gets the value of all tokens locked in Fringe Finance\'s Primary Lending Platform',
  start: 14847363,
  misrepresentedTokens: false,
  ethereum: {
    tvl
  },
}

'''
'''--- projects/fringe/pit-abi.json ---
{
  "getProjectTokensLength": {
    "inputs": [],
    "name": "projectTokensLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getLendingTokensLength": {
    "inputs": [],
    "name": "lendingTokensLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getProjectTokenByIndex": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "projectTokens",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getLendingTokenByIndex": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "lendingTokens",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getLendingTokenInfo": {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "lendingTokenInfo",
    "outputs": [
      {
        "internalType": "bool",
        "name": "isListed",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "isPaused",
        "type": "bool"
      },
      {
        "internalType": "contract BLendingToken",
        "name": "bLendingToken",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/frog-nation-farm/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const frog = "0xFA5c941BC491Ee6Dc1E933f38d01d8B5D5637205";
const masterchef = "0x254D43bD428DA1420Ee043cD30bDA455f353c241";

module.exports = {
    ...masterChefExports(masterchef, "fantom", frog)
}
'''
'''--- projects/frostfinance/abi.json ---
{
    "poolInfo": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "address",
                "name": "lpToken",
                "internalType": "contract IERC20"
            },
            {
                "type": "uint256",
                "name": "allocPoint",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "lastRewardBlock",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "accTUNDRAPerShare",
                "internalType": "uint256"
            },
            {
                "type": "uint16",
                "name": "withdrawFeeBP",
                "internalType": "uint16"
            }
        ],
        "name": "poolInfo",
        "inputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ]
    },
    "poolLength": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "poolLength",
        "inputs": []
    }
}
'''
'''--- projects/frostfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2BalanceFromMasterChefExports } = require("../helper/pool2");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformAvaxAddress } = require("../helper/portedTokens");

const masterChefTUNDRA = "0x87f1b38D0C158abe2F390E5E3482FDb97bC8D0C5";
const TUNDRA = "0x21c5402C3B7d40C89Cc472C9dF5dD7E51BbAb1b1";

const masterChefEXP = "0x02941a0Ffa0Bb0E41D9d96314488d2E7652EDEa6";
const EXP = "0xf57b80a574297892b64e9a6c997662889b04a73a";

const masterChefDUNE = "0xCEA209Fafc46E5C889A8ad809e7C8e444B2420C0";
const DUNE = "0x314f3bee25e49ea4bcea9a3d1321c74c95f10eab";

async function avaxTvl(timestamp, block, chainBlocks) {
  const balances = {};

  const transformAddress = await transformAvaxAddress();

  await addFundsInMasterChef(
    balances,
    masterChefTUNDRA,
    chainBlocks.avax,
    "avax",
    transformAddress,
    abi.poolInfo,
    [TUNDRA],
    true,
    true,
    TUNDRA
  );

  await addFundsInMasterChef(
    balances,
    masterChefEXP,
    chainBlocks.avax,
    "avax",
    transformAddress,
    abi.poolInfo,
    [EXP],
    true,
    true,
    EXP
  );

  await addFundsInMasterChef(
    balances,
    masterChefDUNE,
    chainBlocks.avax,
    "avax",
    transformAddress,
    abi.poolInfo,
    [DUNE],
    true,
    true,
    DUNE
  );
  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  avax: {
    staking: sdk.util.sumChainTvls([
      staking(masterChefTUNDRA, TUNDRA, "avax"),
      staking(masterChefEXP, EXP, "avax"),
      staking(masterChefDUNE, DUNE, "avax"),
    ]),
    pool2: sdk.util.sumChainTvls([
      pool2BalanceFromMasterChefExports(
        masterChefTUNDRA,
        TUNDRA,
        "avax",
        (addr) => `avax:${addr}`
      ),
      pool2BalanceFromMasterChefExports(
        masterChefEXP,
        EXP,
        "avax",
        (addr) => `avax:${addr}`
      ),
      pool2BalanceFromMasterChefExports(
        masterChefDUNE,
        DUNE,
        "avax",
        (addr) => `avax:${addr}`
      ),
    ]),
    tvl: avaxTvl,
  },
  methodology:
    "Counts TVL on all the farms and pools through MasterChef Contracts",
};

'''
'''--- projects/frozen-walrus/index.js ---
const wlrTokenAddress = "0x395908aeb53d33A9B8ac35e148E9805D34A555D3";
const wshareTokenAddress = "0xe6d1aFea0B76C8f51024683DD27FA446dDAF34B6";
const masonryAddress = "0x38B0b6Ef43c4262659523986D731f9465F871439";
const treasuryAddress = "0xDb8618e899FD9fa4B8E6DBd1E00BCA89E4DaF9cd";
const rewardPool = '0x752FEacFdA5c3B440Fd6D40ECf338a86b568c2d2'
const chain = 'avax'
const { tombTvl } = require('../helper/tomb');

const ftmLPs = [
    "0x82845B52b53c80595bbF78129126bD3E6Fc2C1DF", // tombFtmLpAddress
    "0x03d15E0451e54Eec95ac5AcB5B0a7ce69638c62A", //tshareFtmLpAddress
];

module.exports = {
  ...tombTvl(wlrTokenAddress, wshareTokenAddress, rewardPool, masonryAddress, ftmLPs, chain, undefined, true, ftmLPs[1])
};
'''
'''--- projects/ftm-frens/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const frens = "0x4cC23f962d872938d478803c4499079517dB2666";
const maserchef = "0x48C2913b014B34979585281df22c6ffbcc53862b";

module.exports = {
    ...masterChefExports(maserchef, "fantom", frens, false)
}
'''
'''--- projects/ftmguru/index.js ---
const sdk = require("@defillama/sdk")
const ITVL = [
 {
   "inputs": [],
   "name": "pool2",   //POOL2 TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "staking",   //STAKING TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "tvl",   //GLOABL TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
 "inputs": [],
 "name": "usd",   //On-chain USD Reference Token
 "outputs": [
   {
     "internalType": "address",
     "name": "",
     "type": "address"
   }
 ],
 "stateMutability": "view",
 "type": "function"
 }
]
const tvlGuru = "0x0786c3a78f5133F08C1c70953B8B10376bC6dCad";   //On-Chain Universal TVL Finder
const USD = "fantom:0x04068DA6C83AFCFA0e13ba15A6696662335D5B75";   //same as abi.call({target:tvlGuru,abi:ITVL[3]})
//NOTE: USD===fantom:USDC is used explicitly to reduce EVM calls by this adapter. It makes this process faster.
async function pool2(timestamp,block) {
   let _pool2 = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[0],
    block: block,
    chain: 'fantom'
   });
   let balances={}
   balances[USD]=(Number(_pool2.output)/1e12).toFixed(0)
   return balances;
}
async function staking(timestamp,block) {
   let _staking = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[1],
    block: block,
    chain: 'fantom'
   });
   let balances={}
   balances[USD]=(Number(_staking.output)/1e12).toFixed(0)
   return balances;
}
async function tvl(timestamp,block) {
   let _tvl = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[2],
    block: block,
    chain: 'fantom'
   });
   let balances={}
   balances[USD]=(Number(_tvl.output)/1e12).toFixed(0)
   return balances;
}
module.exports = {
 methodology: "USD-denominated value aggregation of most Locked assets held across ftm.guru's contracts, powered by direct on-chain storage of quantity, pools and prices using ftm.guru's Universal TVL Finder Tool (tvlGuru.sol). More detailed documentation of TVL is available at https://ftm.guru/rawdata/tvl",
 fantom: {
   pool2: pool2,
   staking: staking,
   tvl: tvl
 },
}

'''
'''--- projects/fujidao/abi.json ---
{
    "totalSupply":{"inputs":[{"internalType":"uint256","name":"_assetID","type":"uint256"}],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/fujidao/index.js ---
const {sumTokens} = require('../helper/unwrapLPs')
const abi = require('./abi.json')
const sdk = require('@defillama/sdk')
const { default: BigNumber } = require('bignumber.js')

const ethContracts = [
    {
        name: "F1155 Core",
        address: "0x1Cf24e4eC41DA581bEe223E1affEBB62a5A95484",
        ids: [0, 2, 4]
    },
    {
        name: "F1155 Fuse",
        address: "0xa2d62f8b02225fbFA1cf8bF206C8106bDF4c692b",
        ids: [0, 2]
    },
];

const weth = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const wbtc = "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599";
const ftm = "0x4E15361FD6b4BB609Fa63C81A2be19d873717870";

const marketsupply = async (contract, block, chain) => {
    return await sdk.api.abi.multiCall(
        {
            abi: abi.totalSupply,
            calls: (contract.ids).map( id => ({
                target:(contract.address),
                params: [id]
            })),
            block,
            chain
        }
    );
}

const allMarketSupplies = async (contracts, block, chain) => {
    let allMarkets;
    for (let index = 0; index < contracts.length; index++) {
        if (!allMarkets) {
            allMarkets = await marketsupply(contracts[index], block, chain);
        } else {
            let temp = allMarkets.output;
            let response = await marketsupply(contracts[index], block, chain);
            response = response.output;
            allMarkets.output = temp.concat(response);
        } 
    }
    return allMarkets.output.reduce((t,v) => t.plus(v.output), BigNumber(0)).toFixed(0);
}

async function eth(_timestamp, block){
    const supplies = await allMarketSupplies(ethContracts, block, "ethereum");

    return {
        [weth]: supplies
    }
}

const fantomContracts = [
    {
        name: "F1155 Core",
        address: "0xB4E2eC87f8E6E166929A900Ed433c4589d721D70",
        ids: [0, 2]
    },
];

async function fantom(_timestamp, ethBlock, chainBlocks){
    const ftmSupplies = await allMarketSupplies(fantomContracts, chainBlocks.fantom, "fantom");
    const wbtcSupplies = await allMarketSupplies([{
        name: "F1155 Core",
        address: "0xB4E2eC87f8E6E166929A900Ed433c4589d721D70",
        ids: [4]
    }], chainBlocks.fantom, "fantom");

    return {
        [ftm]: ftmSupplies,
        [wbtc]: wbtcSupplies,
    }
}

module.exports = {
    ethereum:{
        tvl:eth
    },
    fantom:{
        tvl: fantom
    },
    methodology: "Counts balance of receipt tokens in F1155 Contract on all vaults."
}
'''
'''--- projects/funbeast/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl');

module.exports = {
    misrepresentedTokens: true,
    methodology: "Astar Exchange Tvl Calculation",
    astar: {
        tvl: calculateUsdUniTvl(
            "0xb99978440F310658C5E69D5042724327EF6D3CE7", 
            "astar", 
            "0xAeaaf0e2c81Af264101B9129C00F4440cCF0F720",
            [
                '0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98', // USDC
            ], 
            "astar"),
    }
};

'''
'''--- projects/furucombo/index.js ---
const sdk = require("@defillama/sdk");
const axios = require("axios");
const retry = require("async-retry");

const API_ENDPOINT = "https://api.furucombo.app/v1/investables/farm_tvl";
const API_KEY = "VDNl6XunwQaTYWtvMZ6Qqa2GeVtSqzqo8Mrquo4O";

async function polygon(timestamp, blockETH, chainBlocks) {
  const balances = {};

  const { data } = await retry(
    async (bail) =>
      await axios.get(API_ENDPOINT, {
        params: { block: chainBlocks["polygon"] },
        headers: { ["X-Api-Key"]: API_KEY },
      }),
    { retries: 3 }
  );

  for (const { token, balance } of data.balances) {
    sdk.util.sumSingleBalance(balances, "polygon:" + token.address, balance);
  }

  return balances;
}

module.exports = {
  polygon: {
    tvl: polygon,
  },
};

'''
'''--- projects/furylabsfinance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const furyToken = "0xB1822A7ee73DD7de6Eda328A0681f8E1779CC4B6";
const masterchef = "0x23e2DA1657C2b552185d7AF485d6f4825f68200a";

module.exports = {
    methodology: `Counts tokens held in the masterchef contract(0x23e2DA1657C2b552185d7AF485d6f4825f68200a)`,
    ...masterChefExports(masterchef, "fantom", furyToken, false)
} // node test.js projects/furylabsfinance/index.js
'''
'''--- projects/fuse.js ---
/*==================================================
  Modules
  ==================================================*/

  const { GraphQLClient } = require('graphql-request')
  
  const BigNumber = require("bignumber.js")
  const utils = require('./helper/utils')
  
  /*==================================================
  Constants
  ==================================================*/
  const ambBridgeContract = "0xf301d525da003e874DF574BCdd309a6BF0535bb6"

  /*==================================================
  Methods
  ==================================================*/
  const bridgeClient = new GraphQLClient('https://graph.fuse.io/subgraphs/name/fuseio/fuse-ethereum-bridge')

  const fetchBridgedTokenPairs = async () => {
    const query = `{bridgedTokens {address, foreignAddress, symbol}}`
    const { bridgedTokens } = await bridgeClient.request(query)
    return bridgedTokens
  }

  async function fetch() {

    // Calculate the TVL locked in the amb bridge
    const tokenList = (await fetchBridgedTokenPairs()).map(({ foreignAddress }) => foreignAddress)
    var prices = await utils.getPricesFromContract(tokenList)

    var bridgeTVL = 0
    for (var key in tokenList) {
      if (tokenList[key] in prices.data)
      {
        var balances = await utils.returnBalance(tokenList[key], ambBridgeContract)
        bridgeTVL += (parseFloat(balances) * prices.data[tokenList[key]].usd)
      }
    }

    // Calculate the TVL of fuse on the fusenetwork
    var circulatingFuse = await utils.fetchURL('https://bot.fuse.io/api/v1/stats/circulating')
    var lockedOnFuse = circulatingFuse.data.onFuseNetwork + circulatingFuse.data.staked
    var fusePriceString = await utils.getPricesfromString("fuse-network-token")
    var fusePrice = fusePriceString.data["fuse-network-token"].usd
    var fuseTVL = fusePrice * lockedOnFuse

    var TVL = fuseTVL + bridgeTVL

    return TVL;
  }

  module.exports = {
    fetch
  }
'''
'''--- projects/fusefi/index.js ---
const sdk = require("@defillama/sdk");
const swap = require("./swap");
const olalending = require("./olalending");
const { stakingPricedLP } = require("../helper/staking");

const VOLT_TOKEN = "0x34Ef2Cc892a88415e9f02b91BfA9c91fC0bE6bD4".toLowerCase();
const VOLT_BAR = "0x97a6e78c9208c21afaDa67e7E61d7ad27688eFd1".toLowerCase();
const WFUSE_VOLT_LP =
  "0xa670b12f8485aa379e99cf097017785b6aca5968".toLowerCase();

module.exports = {
  timetravel: true,
  fuse: {
    tvl: sdk.util.sumChainTvls([swap.tvl, olalending.tvl]),
    borrowed: olalending.borrowed,
    staking: stakingPricedLP(
      VOLT_BAR,
      VOLT_TOKEN,
      "fuse",
      WFUSE_VOLT_LP,
      "fuse-network-token"
    ),
  },
  hallmarks: [
    [1648684800, "Reentrancy attack"]
]
};

'''
'''--- projects/fusefi/olalending.js ---
const {usdCompoundExports} = require('../helper/compound');

const unitroller_fuse = "0x26a562B713648d7F3D1E1031DCc0860A4F3Fa340"

const abis = {
    oracle: {"constant":true,"inputs":[],"name":"getRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},
    underlyingPrice: {"constant":true,"inputs":[{"internalType":"address","name":"cToken","type":"address"}],"name":"getPriceForUnderling","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
}

module.exports=usdCompoundExports(unitroller_fuse, "fuse", "0x025B0ff0920298e087308F3b2de0CF6399685909", abis)
'''
'''--- projects/fusefi/swap.js ---
const { getChainTvl } = require('../helper/getUniSubgraphTvl');
const { getUniTVL } = require('../helper/unknownTokens');
const endpoint = 'https://api.thegraph.com/subgraphs/name/voltfinance/voltage-exchange';

module.exports = {
    tvl: getUniTVL({
        factory: '0x1998E4b0F1F922367d8Ec20600ea2b86df55f34E',
        chain: 'fuse',
        coreAssets: [
            '0x0be9e53fd7edac9f859882afdda116645287c629',
            '0x620fd5fa44BE6af63715Ef4E65DDFA0387aD13F5',
            '0x94Ba7A27c7A95863d1bdC7645AC2951E0cca06bA',
            '0xFaDbBF8Ce7D5b7041bE672561bbA99f79c532e10',
            '0xa722c13135930332Eb3d749B2F0906559D2C5b99',
            '0x43b17749b246fd2a96de25d9e4184e27e09765b0',
        ]
    })
}

'''
'''--- projects/fusion/index.js ---
// const { masterChefExports } = require('../helper/masterchef');
const { stakings } = require('../helper/staking');
const { sumTokens2 } = require('../helper/unwrapLPs');
const { getUniTVL } = require('../helper/unknownTokens');
const { mergeExports } = require('../helper/utils');

// const masterchef = '0x00501Ed66d67B1127809E54395F064e256b75B23'
const sntFantom = '0x69D17C151EF62421ec338a0c92ca1c1202A427EC'
const sntNova = '0x657a66332a65b535da6c5d67b8cd1d410c161a08'
const callStake = "0xe9749a786c77A89fd45dAd3A6Ad1022eEa897F97";
const bondStake = "0xaaBaB0FB0840DFfFc93dbeed364FB46b1ffD92EE";
const nullAddress = '0x0000000000000000000000000000000000000000'
const dexFactory = '0x9550b0c83AD5a58898cD4267987Af67e7E52bF55'
const ethers = require("ethers")
const { config } = require('@defillama/sdk/build/api');

config.setProvider("nova", new ethers.providers.StaticJsonRpcProvider(
  "http://dataseed-0.rpc.novanetwork.io:8545/",
  {
    name: "nova",
    chainId: 87,
  }
))

// const masterchefExport = {
//   timetravel: true,
//   misrepresentedTokens: false,
//   ...masterChefExports(masterchef, 'fantom', sntFantom, true),
//   // ...masterChefExports(masterchef, 'nova', sntNova, true),
// }

const dexTVL = {
  nova: {
    tvl: getUniTVL({
      factory: dexFactory,
      chain: "nova",
      coreAssets: [
        sntNova
      ],
    })
  },
  fantom: {
    tvl: getUniTVL({
      factory: dexFactory,
      chain: "fantom",
      coreAssets: [],
    })
  }
}

const stakingExports = {
  fantom: {
    staking: stakings([callStake, bondStake], sntFantom, 'fantom'),
  },
  nova: {
    staking: async (_, _b, { nova: block }) => sumTokens2({ owners: [callStake, bondStake,], tokens: [nullAddress, sntNova], chain: 'nova', block, })
  },
}

module.exports = mergeExports([dexTVL, stakingExports,])
'''
'''--- projects/futureswap/index.js ---
/*==================================================
  Modules
  ==================================================*/

const sdk = require("@defillama/sdk");

const BigNumber = require("bignumber.js");

/*==================================================
    Settings
 ==================================================*/

const contracts = [
  "0x91a154F9AD33da7e889C4b6fE4A9F9C3Fc6B6081",
  "0x8fA7490cedB7207281a5ceabee12773046dE664E",
  "0xd1Ed35A3Ee043683A1833509dE8f2C1A0d8777B7",
];

const tokens = [
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
];

/*==================================================
  TVL
  ==================================================*/

async function tvl(timestamp, block) {
  const balances = {};

  let balanceOfCalls = [];
  contracts.forEach((contract) => {
    balanceOfCalls = [
      ...balanceOfCalls,
      ...tokens.map((token) => ({
        target: token,
        params: contract,
      })),
    ];
  });

  const balanceOfResult = (
    await sdk.api.abi.multiCall({
      block,
      calls: balanceOfCalls,
      abi: "erc20:balanceOf",
    })
  ).output;

  /* combine token volumes on multiple contracts */
  balanceOfResult.forEach((result) => {
    let balance = new BigNumber(result.output || 0);
    if (balance <= 0) return;

    let asset = result.input.target;
    let total = balances[asset];

    if (total) {
      balances[asset] = balance.plus(total).toFixed();
    } else {
      balances[asset] = balance.toFixed();
    }
  });

  return balances;
}

/*==================================================
  Exports
  ==================================================*/

module.exports = {
  start: 1609459200, // unix timestamp (utc 0) specifying when the project began, or where live data begins
  ethereum: { tvl }
};

'''
'''--- projects/fuzzfinance/index.js ---
// const { request, gql } = require("graphql-request");
const sdk = require("@defillama/sdk");
// const { toUSDTBalances } = require('../helper/balances');
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { fixHarmonyBalances } = require("../helper/portedTokens");

const fuzz = "0x984b969a8e82f5ce1121ceb03f96ff5bb3f71fee";
const factory = "0x5245d2136dc79Df222f00695C0c29d0c4d0E98A6";
const masterchef = "0x847b46ed6c3df75e34a0496ef148b89bf5eb41b1";

// const graphUrl = 'https://graph.fuzz.fi/subgraphs/name/fuzzfinance/fuzzswap'
// const graphQuery = gql`
// query get_tvl($block: Int) {
//   uniswapFactory(
//     id: "0x5245d2136dc79Df222f00695C0c29d0c4d0E98A6",
//     block: { number: $block }
//   ) {
//     totalLiquidityUSD
//   },
// }
// `;

async function tvl(timestamp, block, chainBlocks) {
  // const {block} = await sdk.api.util.lookupBlock(timestamp,{
  //   chain: 'harmony'
  // })
  // const response = await request(
  //   graphUrl,
  //   graphQuery,
  //   {
  //     block,
  //   }
  // );

  // const usdTvl = Number(response.uniswapFactory.totalLiquidityUSD)

  // return toUSDTBalances(usdTvl)
  let balances = await calculateUniTvl(
    (addr) => {
      if (addr === "0x224e64ec1bdce3870a6a6c777edd450454068fec") {
        return "0xa47c8bf37f92abed4a126bda807a7b7498661acd";
      }
      return `harmony:${addr}`;
    },
    chainBlocks.harmony,
    "harmony",
    factory,
    0,
    true
  );
  fixHarmonyBalances(balances);
  return balances;
}

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (
    await sdk.api.erc20.balanceOf({
      target: fuzz,
      owner: masterchef,
      block: chainBlocks.harmony,
      chain: "harmony",
    })
  ).output;
  sdk.util.sumSingleBalance(balances, `harmony:${fuzz}`, balance);
  return balances;
}

module.exports = {
  methodology: `Counts the tokens locked on AMM pools from the factory contract.`,
  harmony: {
    tvl,
    staking,
  },
};

'''
'''--- projects/gaia-dao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const gaia = "0x9f6aEDcA032b1092E08b848FC9D6F29139370837";
const stakingAdd = "0x89884B045Ed93067b28C2554a9CB877a41a8fA73";
const treasury = "0x15E5A559e67Cb6CAB391821635B351D43E2371b2";
const treasuryTokens = [
    ["0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664", false], // USDC
    ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false], // WAVAX
    ["0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab", false], // WETH
    ["0x6Ca7AAc252FeD4894132Ae6E6d96bFc739d9FC3a", true] // GAIA USDC JLP
];

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "avax", stakingAdd, gaia)
}
'''
'''--- projects/gainsNetwork.js ---
const { transformPolygonAddress } = require('./helper/portedTokens');
const sdk = require('@defillama/sdk');
const { getBlock } = require('./helper/getBlock');
const { pool2 } = require('./helper/pool2');

const contracts = [
    '0x151757c2E830C467B28Fe6C09c3174b6c76aA0c5',
    '0x203F5c9567d533038d2da70Cbc20e6E8B3f309F9',
    '0x176586Dec2b70df5B72a6Efe158a87f210551798',
    '0xaee4d11a16B2bc65EDD6416Fb626EB404a6D65BD',
    '0xd7052EC0Fe1fe25b20B7D65F6f3d490fCE58804f'
];

const tokens = {
    DAI: '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063',
    dQUICK: '0xf28164a485b0b2c90639e47b0f377b4a438a16b1'
};

async function tvl(timestamp, block, chainBlocks) {
    const transform = await transformPolygonAddress();
    const balances = {};
    block = await getBlock(timestamp, 'polygon', chainBlocks);

    const DAIbalance = (await sdk.api.abi.multiCall({
        calls: contracts.map((c) => ({
            target: tokens.DAI,
            params: c
        })),
        abi: "erc20:balanceOf",
        block,
        chain: 'polygon'
    })).output.reduce((a, b) => Number(a) + Number(b.output), 0);

    const dQUICKbalance = (await sdk.api.abi.multiCall({
        calls: contracts.map((c) => ({
            target: tokens.dQUICK,
            params: c
        })),
        abi: "erc20:balanceOf",
        block,
        chain: 'polygon'
    })).output.reduce((a, b) => Number(a) + Number(b.output), 0);

    return {
        [transform(tokens.DAI)]: DAIbalance,
        [transform(tokens.dQUICK)]: dQUICKbalance
    };
};

// node test.js projects/gainsNetwork.js
module.exports={
    polygon: {
        tvl,
        pool2: pool2(
            '0x33025b177A35F6275b78f9c25684273fc24B4e43', 
            '0x6e53cb6942e518376e9e763554db1a45ddcd25c4', 
            'polygon')
    }
};
'''
'''--- projects/galatea/index.js ---
/*** This Protocol seems hacked/rugged. It's a case for study and analyze ***/

const utils = require("../helper/utils");

const api_galatea = "https://api.galatea.cash/api";

async function fetch() {
  // var tvl = (await utils.fetchURL(api_galatea)).data.tvl;
  return 0;
}

async function pool2() {
  var pool2 = (await utils.fetchURL(api_galatea)).data.networks.map(
    (p) => p.stats.pools
  );
  return pool2;
}

async function staking() {
    var staking = (await utils.fetchURL(api_galatea)).data.networks.map(
      (p) => p.stats.boardroom.tvl
    );
    return staking;
  }

module.exports = {
  deadFrom: 1648765747,
  // pool2: {
  //   fetch: pool2,
  // },
  // staking: {
  //   fetch: staking,
  // },
  fetch,
};

'''
'''--- projects/galaxygoggle/index.js ---
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");

const GgStaking = "0xBD79c01140CeE7040f8F5E935B72e13540a801b6"
const gg = "0xF2F7CE610a091B94d41D69f4fF1129434a82E2f0"

// https://app.galaxygoggle.money/#/bonds
const treasury = "0xD5F922e23693e552793fE0431F9a95ba67A60A23"
const dao = "0xDEEdd1646984F9372Cc9D3d7E13AC1606cC2B548"
const mim = "0x130966628846BFd36ff31a822705796e8cb8C18D"
const wavax = "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
const joe = "0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [mim, false],
      [wavax, false],
      [joe, false],
      ["0xe9E8d6b6ce6D94Fc9d724711e80784Ec096949Fc", true], // mim-gg
    ],
    [treasury, dao],
    chainBlocks.avax,
    'avax',
    addr=>`avax:${addr}`
  );

  return balances;
}

const bscGG = "0xcAf23964Ca8db16D816eB314a56789F58fE0e10e";
const bscTreasury = "0xF76C9753507B3Df0867EB02D86d07C6fFcEecaf1";
const bscStaking = "0x97209Cf7a6FccC388eEfF85b35D858756f31690d";
const treasuryTokensBSC = [
  ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], // BUSD
  ["0x13Cf29b3F58f777dDeD38278F7d938401f6b260c", true] // GG-BUSD
]

async function bscTvl(timestamp, block, chainBlocks) {
  let balances = {};
  await sumTokensAndLPsSharedOwners(balances, treasuryTokensBSC, [bscTreasury], chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`);
  balances[`avax:${gg}`] = balances["bsc:0xcaf23964ca8db16d816eb314a56789f58fe0e10e"];
  delete balances["bsc:0xcaf23964ca8db16d816eb314a56789f58fe0e10e"];
  return balances;
}

module.exports = {
  avalanche: {
    tvl,
    staking: staking(GgStaking, gg, "avax")
  },
  bsc: {
    tvl: bscTvl,
    staking: staking(bscStaking, bscGG, "bsc", `avax:${gg}`)
  },
  methodology:
    "Counts tokens on the treasury for tvl and staked GG for staking",
};

'''
'''--- projects/gale/index.js ---
const { staking } = require("../helper/staking");

const config = {
  bsc: {
    windmillContract: "0x0b374F3C618FF06583E7C4a1207bcaF22343737E",
    tokenContract: "0x627E86E9eC832b59018Bf91456599e752288Aa97",
    liquidityContract: "0x1fC3152de89b0c6c36F0d330b7Be369d6dDB219F",
    vaultContract: "0x973Abe726E3e37bbD8501B2D8909Fa59535Babdd",
    busd: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
  }
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  bsc: {
    tvl: () => ({}),
    treasury:  staking(config.bsc.vaultContract, config.bsc.busd, "bsc"),
    staking:  staking(config.bsc.windmillContract, config.bsc.tokenContract, "bsc"),
  },
  methodology:
    "Counts tokens on the windmill for tvl",
};

'''
'''--- projects/gale/windmillABI.json ---
{
  "totalBurned": {
    "inputs": [],
    "name": "totalBurned",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/gamblefi/index.js ---
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { staking } = require("../helper/staking");
const sdk = require("@defillama/sdk");

const betifystaking = "0x335CAC92af7015BE7802170B62Ebc4C74900484d";
const betify = "0xD465b6B4937D768075414D413e981Af0b49349Cc";
const treasury = "0x596a6DFf0CF36fABf75EDeB6aA2992C950Ff14bA";
const dao = "0xEe376093ccDB3D81f226C2290868219687226845";
const wBETSLIP = "0x3e7dfdd82965515e9b6398d91b991f5d4c830ef6";
const revenueShare = "0x40822C8E1389dE62980691bF0AFBd5B8D1D56cB7";

async function tvl(timestamp, ethBlock, chainBlocks) {
  const balances = {};
  const transform = (addr) =>
    addr.toLowerCase() === "0xF2001B145b43032AAF5Ee2884e456CCd805F677D"
      ? "0xF2001B145b43032AAF5Ee2884e456CCd805F677D"
      : `cronos:${addr}`;

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      //   [usdc, false]
      ["0xf2001b145b43032aaf5ee2884e456ccd805f677d", false], // DAI
      ["0x76f0adfff61fd9a542a36a98b96909ec7d3a8c53", true], // BETIFY-DAI
      ["0xe2c5275d86D2fB860F19a2CbBED9967d39AA73e8", true], // BETIFY-MMF
      ["0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23", false], // WCRO
      ["0x3e7dfdd82965515e9b6398d91b991f5d4c830ef6", false], // wBETSLIP
    ],
    [treasury, dao, revenueShare],
    chainBlocks.metis,
    "cronos",
    transform
  );

  const wbetslipAddress = transform(wBETSLIP);

  const betslip = await sdk.api.abi.call({
    target: wBETSLIP,
    abi: {
      inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
      name: "wBTSToBTS",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    chain: "cronos",
    block: chainBlocks.cronos,
    params: [balances[wbetslipAddress]],
  });
  balances[transform(betify)] = betslip.output;
  delete balances[wbetslipAddress];

  return balances;
}
module.exports = {
  cronos: {
    tvl,
    staking: staking(betifystaking, betify, "cronos"),
  },
  methodology:
    "Counts tokens on the treasury for tvl and staked BETIFY for staking",
};

'''
'''--- projects/gametheory/index.js ---
const { unknownTombs } = require("../helper/unknownTokens")

const token = "0x60787C689ddc6edfc84FCC9E7d6BD21990793f06"
const rewardPool = "0x820c3b6d408Cff08C8a31C9F1461869097ba047c"
const lps = [
    "0x168e509FE5aae456cDcAC39bEb6Fd56B6cb8912e",
    "0xF69FCB51A13D4Ca8A58d5a8D964e7ae5d9Ca8594"
]

module.exports = unknownTombs({
  lps,
  token,
  shares: [
    '0x56EbFC2F3873853d799C155AF9bE9Cb8506b7817',
    '0xFfF54fcdFc0E4357be9577D8BC2B4579ce9D5C88',
  ],
  rewardPool,
  masonry: [
    '0x83641aa58e362a4554e10ad1d120bf410e15ca90',
    '0x670433FB874d4B7b94CF1D16E95fa241474E6787'
  ],
  chain: 'fantom',
  coreAssets: [
    '0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E', // DAI
  ]
})

'''
'''--- projects/gardensdao/index.js ---
const { request, gql } = require("graphql-request");
const sdk = require('@defillama/sdk')

const SUBGRAPH_HONEYSWAP_V2 =
  "https://api.thegraph.com/subgraphs/name/1hive/honeyswap-v2";
const SUBGRAPH_GARDENS_XDAI =
  "https://api.thegraph.com/subgraphs/name/1hive/gardens-xdai";

const balanceAbi = {
  "constant": true,
  "inputs": [
    { "internalType": "address", "name": "_token", "type": "address" }
  ],
  "name": "balance",
  "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

const ALL_ORGS_GQL = gql`
  query allOrgs($lastID: ID) {
    organizations(first: 1000, where: { id_gt: $lastID, active: true }) {
      id
      token {
        name
        id
      }
      config {
        conviction {
          requestToken {
            id
            name
          }
          fundsManager
        }
      }
      proposalCount
      active
    }
  }
`;

const ALL_TOKEN_PRICE_QUERY = gql`
  query pricesTokens($tokenAddress: [ID]) {
    tokens(where: { id_in: $tokenAddress }) {
      id
      derivedETH
      tradeVolume
      tradeVolumeUSD
      untrackedVolumeUSD
      totalLiquidity
    }
  }
`;

async function getAllOrgs() {
  let allFound = false;
  let lastID = "";
  let data = [];

  while (!allFound) {
    const orgs = await request(
      SUBGRAPH_GARDENS_XDAI,
      ALL_ORGS_GQL,
      { lastID }
    );

    const numOrgs = orgs.organizations.length;

    if (numOrgs < 1000) {
      allFound = true;
    }
    lastID = orgs.organizations[numOrgs - 1].id;
    data = data.concat(orgs.organizations);
  }
  return data;
}

const chain = 'xdai'

async function tvl(timestamp, _block, { xdai: block }) {
  const balances = {};

  const orgs = await getAllOrgs()
  const calls = orgs.map(org => {
    return { params: org.config.conviction?.requestToken.id, target: org.config.conviction?.fundsManager, }
  }).filter(i => i.params && i.target)

  const { output } = await sdk.api.abi.multiCall({
    abi: balanceAbi,
    calls, chain, block,
  })

  output.forEach(({ input, output }) => {
    sdk.util.sumSingleBalance(balances, input.params[0].toLowerCase(), output)
  })

  const tokens = Object.keys(balances)
  const calls2 = tokens.map(i => ({ target: i }))

  const { output: decimals } = await sdk.api.abi.multiCall({
    abi: 'erc20:decimals',
    calls: calls2,
    chain, block,
  })

  decimals.forEach(({ input: { target: token }, output: decimal }) => {
    balances[token] /= 10 ** +decimal
  })

  const tokenPrices = await request(
    SUBGRAPH_HONEYSWAP_V2,
    ALL_TOKEN_PRICE_QUERY,
    { tokenAddress: tokens }
  )

  let tvl = 0

  tokenPrices.tokens.forEach(({ id, totalLiquidity, derivedETH }) => {
    if (+totalLiquidity < 1e4 || !balances[id] || !derivedETH) // if liquidity is below 10k or token not found or price is missing, ignore and move on
      return;
    tvl += +balances[id] * +derivedETH
  })

  return {
    tether: tvl
  }
}

module.exports = {
  methodology:
    '"Uses Gardens and Honeyswap Subgraph to finds USD value of Common Pool treasuries for tokens with greater than $10k of liquidity on Honeyswap"',
  misrepresentedTokens: true,
  xdai: {
    tvl,
  },
};
'''
'''--- projects/gaur/index.js ---
const { tombTvl } = require('../helper/tomb');

const bond = "0x046cb616d7a52173e4Da9efF1BFd590550aa3228";
const share = "0x66ec6e9f61ac288f5ba661cd9a2dbe3abf9871c9";
const boardroom = "0x73c34f572a428c0fc298e9a2ae45d01e87713e8f";
const rewardPool = "0x4d24484a5944b6a8e2bc9af74c6d44c47767b150";
const pool2lps = [
  '0xe34973e9c89a9a1d2886379ce52d32dde296ca22',
  '0x9f4daa971e76e3d0c68c9983125e35c0f89b077a',
  '0xe61Db569E231B3f5530168Aa2C9D50246525b6d6',
  '0x062b7d86c51aa3b2ec998272b5bd0609e95b3661',
  '0xfd0cd0c651569d1e2e3c768ac0ffdab3c8f4844f',
  '0xa111c17f8b8303280d3eb01bbcd61000aa7f39f9',
];

module.exports = {
    ...tombTvl(bond, share, rewardPool, boardroom, pool2lps, "cronos", undefined, true, pool2lps[1])
};
'''
'''--- projects/gdao.js ---
const { sumTokens } = require('./helper/unwrapLPs');
const { pool2 } = require('./helper/pool2');
const { staking } = require('./helper/staking');

const liquidityMinesAddress = '0x4DaC3e07316D2A31baABb252D89663deE8F76f09';
const loyaltyMineAddress = '0xda58927f4065f1d02a6ea850c2aac49d7362a643';

const stakedTokens = [
	'0x514910771af9ca656af840dff83e8264ecf986ca', //link
	'0x1f9840a85d5af5bf1d1762f925bdaddc4201f984', //uni
	'0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9', //aave
	'0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', //wbtc
	'0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', //weth
	'0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f', //snx
	'0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', //usdc
	'0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e', //yfi
];

const GDAOLP = '0x4d184bf6f805ee839517164d301f0c4e5d25c374';
const gdaoToken = '0x515d7E9D75E2b76DB60F8a051Cd890eBa23286Bc';

async function tvl(ts, block) {
	const balances = {}
	const tao = stakedTokens.map(t => [t, liquidityMinesAddress])
	return sumTokens(balances, tao, block)
}

module.exports = {
	methodology: 'TVL counts tokens deposited in the Liquidity Mining program.',
  ethereum: {
    tvl,
		staking: staking(loyaltyMineAddress, gdaoToken),
		pool2: pool2(loyaltyMineAddress, GDAOLP),
  }
}

'''
'''--- projects/gdl/index.js ---
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js')

// avax addresses below.
const GDL_USD_POOL = '0x3CE2B891071054ee10d4b5eD5a9446f9016F90d8';
const USDT = '0xde3a24028580884448a5397872046a019649b084';
const zUSDT = '0x650cecafe61f3f65edd21efacca18cc905eef0b7';

const GDL_DAI_POOL = '0x9D43f28C5Fce24D0c8B653E5c5859E0421Af7783';
const DAI = '0xba7deebbfc5fa1100fb055a87773e1e99cd3507a';
const zDAI = '0x12f108e6138d4a9c58511e042399cf8f90d5673f';

const GDL_ETH_POOL = '0xed986f982269e0319F710EC270875dE2b2A443d2';
const ETH = '0xf20d962a6c8f70c731bd838a3a388d7d48fa6e15';
const zETH = '0xf6f3eea905ac1da6f6dd37d06810c6fcb0ef5183';

const GDL_POOL = '0x34C8712Cc527a8E6834787Bd9e3AD4F2537B0f50';
const GDL = '0xd606199557c8ab6f4cc70bd03facc96ca576f142';

async function balanceOf(owner, target, block) {
  const chain = 'avax';
  let decimals = (await sdk.api.erc20.decimals(target, chain)).output;
  let balance = (await sdk.api.erc20.balanceOf({
    owner,
    target,
    block,
    chain,
  })).output;
  return Number(balance)/(10**decimals);
}

async function poolBalance(owner, targets, block) {
  let calls = await Promise.all(targets.map(async (target) => {
    return balanceOf(owner, target, block);
  }));
  let sum = calls.reduce((s, a) => s+a, 0);
  return sum;
}

async function tvl(timestamp, ethereumBlock, chainBlocks) {
  const block = chainBlocks['avax'];
  let balances = {};
  balances['tether'] = await poolBalance(GDL_USD_POOL, [USDT, zUSDT], block);
  balances['dai'] = await poolBalance(GDL_DAI_POOL, [DAI, zDAI], block);
  balances['ethereum'] = await poolBalance(GDL_ETH_POOL, [ETH, zETH], block);
  balances['gondola-finance'] = await poolBalance(GDL_POOL, [GDL], block);
  return balances;
}

module.exports = {
  avalanche:{
    tvl,
  },
};

'''
'''--- projects/gearbox/abi.json ---
{
  "getContractsRegister":{"inputs":[],"name":"getContractsRegister","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
  "getPoolsCount":{"inputs":[],"name":"getPoolsCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  "getPools":{"inputs":[],"name":"getPools","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
  "totalBorrowed":{"inputs":[],"name":"totalBorrowed","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  "underlyingToken":{"inputs":[],"name":"underlyingToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/gearbox/index.js ---
const sdk = require("@defillama/sdk");
const {sumTokens} = require("../helper/unwrapLPs.js");
const abi = require("./abi.json");

const addressProvider = '0xcf64698aff7e5f27a11dff868af228653ba53be0'
// const contractsRegister = '0xa50d4e7d8946a7c90652339cdbd262c375d54d99'
// GEAR token: 0xba3335588d9403515223f109edc4eb7269a9ab5d

const getPoolAddrs = async (ethBlock) => {
    // Get contractsRegister from Gearbox addressProvider
    const { output: contractsRegister } = await sdk.api.abi.call({
        abi: abi['getContractsRegister'],
        target: addressProvider,
        ethBlock,
    })
    // Get gearbox pools from the contractsRegister, and underlyingToken for each pool
    const { output: pools } = await sdk.api.abi.call({
        abi: abi['getPools'],
        target: contractsRegister,
        ethBlock,
    })
    return pools
}

const tvl = async (timestamp, ethBlock, chainBlocks) => {
    const pools = await getPoolAddrs(ethBlock)
    const {output: poolsUnderlying} = await sdk.api.abi.multiCall({
        abi: abi['underlyingToken'],
        calls: pools.map((pool) => ({ target: pool })),
        ethBlock,
      })
    const gearboxPoolsTokensAndOwners = poolsUnderlying.map(t => [t.output, t.input.target])

    // Sum pools balances
    const balances = {}
    await sumTokens(balances, gearboxPoolsTokensAndOwners, ethBlock, "ethereum")
    return balances
}

const borrowed = async (timestamp, ethBlock, chainBlocks) => {
    const pools = await getPoolAddrs(ethBlock)
    //
    const { output: poolsUnderlying } = await sdk.api.abi.multiCall({
        abi: abi['underlyingToken'],
        calls: pools.map((pool) => ({ target: pool })),
        ethBlock,
    })
    const { output: totalBorrowed } = await sdk.api.abi.multiCall({
        abi: abi['totalBorrowed'],
        calls: pools.map((pool) => ({ target: pool })),
        ethBlock,
    })
    return Object.fromEntries(pools.map((_, ind) => [poolsUnderlying[ind].output, totalBorrowed[ind].output]))
}

module.exports = {
    ethereum: {
        tvl,
        borrowed,
    },
    methodology: `Retrieve tokens locked by users on each Gearbox pool (WETH/DAI/WBTC/USDC atm) - the pools being returned by the gearbox contractsRegister`
};
'''
'''--- projects/geist/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { aaveChainTvl } = require("../helper/aave");
const { transformFantomAddress } = require("../helper/portedTokens");

const stakingContract = "0x49c93a95dbcc9A6A4D8f77E59c038ce5020e82f8";
const GEIST = "0xd8321aa83fb0a4ecd6348d4577431310a6e0814d";

const stakingContractPool2 = "0xE40b7FA6F5F7FB0Dc7d56f433814227AAaE020B5";
const GEIST_WFTM_spLP = "0x668AE94D0870230AC007a01B471D02b2c94DDcB9";

function lending(borrowed) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const transform = await transformFantomAddress();
    return aaveChainTvl(
      "fantom",
      "0x4CF8E50A5ac16731FA2D8D9591E195A285eCaA82",
      transform,
      undefined,
      borrowed
    )(timestamp, ethBlock, chainBlocks);
  };
}

module.exports = {
  timetravel: true,
  methodology:
    "Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending",
  fantom: {
    tvl: lending(false),
    borrowed: lending(true),
    staking: staking(stakingContract, GEIST, "fantom"),
    pool2: pool2(stakingContractPool2, GEIST_WFTM_spLP, "fantom"),
  },
};

'''
'''--- projects/gemkeeper.js ---
const { calculateUsdUniTvl } = require('./helper/getUsdUniTvl');
const { staking, stakingPricedLP } = require("./helper/staking.js");
const xBlingContract = "0x25070fA2244b41EA39B964DBFA9E0ab70A886e72"
const BlingAddr = "0x72Ad551af3c884d02e864B182aD9A34EE414C36C"
const wRoseBlingLP = "0xb29553faf847ba5b79b6ae13fa82d0b216faf626"
module.exports = {
    oasis: {
        tvl: calculateUsdUniTvl(
            '0xa7200334f652425A12BF2f7e4F0F5409CCA4d963',
            'oasis',
            '0x21C718C22D52d0F3a789b752D4c2fD5908a8A733',
            [
                '0xdC19A122e268128B5eE20366299fc7b5b199C8e3',
            ],
            'oasis-network'
        ),
        staking: stakingPricedLP(xBlingContract,BlingAddr,"oasis",wRoseBlingLP,"oasis-network")
    }
};
'''
'''--- projects/gemmine/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0xf3C01F6D7ec85682FCAAfE438B8C6A3a54C7164C"
const gemmine = "0x1e2a499fAefb88B2d085d7036f3f7895542b09De"
const gemmineFtmLP = "0xBc2c0E34BF4955eB8967504d0f873b40D1d75Ef9";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [gemmine, gemmineFtmLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, gemmine, "fantom"),
      pool2: pool2Exports(chef, [gemmineFtmLP], "fantom"),
  },
  
} 
'''
'''--- projects/genesis/abi.json ---
{
    "poolInfo": {
        "type":"function",
        "stateMutability":"view",
        "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accGenesisPerShare",
        "type": "uint256"
      },
      {
        "internalType": "uint16",
        "name": "depositFeeBP",
        "type": "uint16"
      }
    ],
        "name":"poolInfo",
        "inputs":[
            {
                "type":"uint256",
                "name":"",
                "internalType":"uint256"
            }
        ]
    }
}

'''
'''--- projects/genesis/index.js ---
const {masterChefExports} = require('../helper/masterchef')

const GENESIS = "0x2638bE7B0d033A59cbcA9139B470503F0a711379"
module.exports={
    deadFrom: 1648765747,
    misrepresentedTokens: true,
    methodology: "Tokens in masterchef",
    ...masterChefExports("0xbf0929439Ea073d55DE8bd0F6e0293Ec30e42Df8", "cronos", GENESIS)
}

'''
'''--- projects/genesys/index.js ---
const {addFundsInMasterChef} = require("../helper/masterchef");
const {pool2Exports} = require("../helper/pool2");
const {staking} = require("../helper/staking")

const token = "0xf8b234a1ce59991006930de8b0525f9013982746";
const masterchef = "0x18cD511b4ad613308Bd0C795e85Fbd8BE1a0aF94";

const ignore = [
    token,
    "0x692784Af9fe59B55A3D0E2a81a318bab88cf5B71",
    "0x325b358a1fC2024E2bdC63f656d9254b2Befc8F5"
]

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, masterchef, chainBlocks.fantom, "fantom", addr=>{
        addr = addr.toLowerCase();
        if (addr === "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e") {
            return "0x6b175474e89094c44da98b954eedeac495271d0f"
        }
        return `fantom:${addr}`
    }, undefined, ignore);
    return balances;
}

module.exports = {
    fantom: {
        tvl,
        staking: staking(masterchef, token, "fantom"),
        pool2: pool2Exports(masterchef, [ignore[1], ignore[2]], "fantom", addr=>`fantom:${addr}`)
    }
}
'''
'''--- projects/genshiro/api.js ---
const { ApiPromise, WsProvider } = require("@polkadot/api");
const BN = require("bn.js");

const types = {
	AccountInfo: {
		nonce: "Index",
		consumers: "RefCount",
		providers: "RefCount",
	},
	Address: "AccountId",
	Asset: {
		0: "AssetIdInnerType",
	},
	AssetData: {
		id: "Asset",
		lot: "FixedU128",
		price_step: "FixedU128",
		maker_fee: "FixedU128",
		taker_fee: "FixedU128",
		multi_asset: "Option<MultiAsset>",
		multi_location: "Option<MultiLocation>",
		debt_weight: "DebtWeightType",
		buyout_priority: "u64",
		asset_type: "AssetType",
		is_dex_enabled: "bool",
	},
	AssetId: "Asset",
	AssetIdInnerType: "u64",
	AssetMetrics: {
		period_start: "Duration",
		period_end: "Duration",
		returns: "Vec<FixedNumber>",
		volatility: "FixedNumber",
		correlations: "Vec<(Asset, FixedNumber)>",
	},
	AssetName: "Vec<u8>",
	AssetType: {
		_enum: {
			Native: null,
			Physical: null,
			Synthetic: null,
			Lp: "PoolId",
		},
	},
	Balance: "u64",
	BalanceOf: "Balance",
	BalancesAggregate: {
		total_issuance: "Balance",
		total_debt: "Balance",
	},
	BestPrice: {
		ask: "Option<FixedI64>",
		bid: "Option<FixedI64>",
	},
	BlockNumber: "u64",
	CapVec: {
		head_index: "u32",
		len_cap: "u32",
		items: "Vec<FixedNumber>",
	},
	ChainId: "u8",
	ChunkKey: "u64",
	Currency: {
		_enum: ["UNKNOWN", "Usd", "Eq", "Eth", "Btc", "Eos", "Dot", "Crv"],
	},
	DataPoint: {
		price: "u64",
		account_id: "AccountId",
		block_number: "BlockNumber",
		timestamp: "u64",
	},
	DebtWeightType: "i128",
	DebtWeightTypeInner: "i128",
	DepositNonce: "u64",
	Duration: {
		secs: "u64",
		nanos: "u32",
	},
	FinancialMetrics: {
		period_start: "Duration",
		period_end: "Duration",
		assets: "Vec<Asset>",
		mean_returns: "Vec<FixedNumber>",
		volatilities: "Vec<FixedNumber>",
		correlations: "Vec<FixedNumber>",
		covariances: "Vec<FixedNumber>",
	},
	FixedI64: "i64",
	FixedNumber: "u128",
	FixedU128: "u128",
	Keys: "SessionKeys3",
	LookupSource: "AccountId",
	MarginState: {
		_enum: {
			Good: null,
			SubGood: null,
			MaintenanceStart: "u64",
			MaintenanceIsGoing: "u64",
			MaintenanceTimeOver: "u64",
			MaintenanceEnd: null,
			SubCritical: null,
		},
	},
	Number: "FixedU128",
	OperationRequest: {
		account: "AccountId",
		authority_index: "AuthIndex",
		validators_len: "u32",
		block_num: "BlockNumber",
	},
	OperationRequestDexCorridor: {
		asset: "Asset",
		order_id: "OrderId",
		price: "FixedI64",
		authority_index: "AuthIndex",
		validators_len: "u32",
		block_num: "BlockNumber",
	},
	OperationRequestDexDeleteOrder: {
		asset: "Asset",
		order_id: "OrderId",
		price: "FixedI64",
		who: "AccountId",
		buyout: "Option<Balance>",
		authority_index: "AuthIndex",
		validators_len: "u32",
		block_num: "BlockNumber",
	},
	OperationRequestLiqFm: {
		authority_index: "AuthIndex",
		validators_len: "u32",
		block_num: "BlockNumber",
	},
	Order: {
		order_id: "OrderId",
		account_id: "AccountId",
		side: "OrderSide",
		price: "FixedI64",
		amount: "FixedU128",
		created_at: "u64",
		expiration_time: "u64",
	},
	OrderType: {
		_enum: {
			Limit: "FixedI64",
			Market: null,
		},
	},
	OrderId: "u64",
	OrderSide: {
		_enum: ["Buy", "Sell"],
	},
	PoolId: "u32",
	PoolInfo: {
		owner: "AccountId",
		pool_asset: "AssetId",
		assets: "Vec<AssetId>",
		amplification: "Number",
		fee: "Permill",
		admin_fee: "Permill",
		balances: "Vec<Balance>",
		total_balances: "Vec<Balance>",
	},
	PoolTokenIndex: "u32",
	PortfolioMetrics: {
		period_start: "Duration",
		period_end: "Duration",
		z_score: "u32",
		volatility: "FixedNumber",
		value_at_risk: "FixedNumber",
	},
	Price: "u128",
	PriceLog: {
		latest_timestamp: "Duration",
		prices: "CapVec<Price>",
	},
	PricePayload: {
		public: "[u8; 33]",
		asset: "Asset",
		price: "FixedI64",
		block_number: "BlockNumber",
	},
	PricePeriod: {
		_enum: ["Min", "TenMin", "Hour", "FourHour", "Day"],
	},
	PricePoint: {
		block_number: "BlockNumber",
		timestamp: "u64",
		last_fin_recalc_timestamp: "Timestamp",
		price: "u64",
		data_points: "Vec<DataPoint>",
	},
	PriceUpdate: {
		period_start: "Duration",
		time: "Duration",
		price: "FixedNumber",
	},
	ProposalStatus: {
		_enum: ["Initiated", "Approved", "Rejected"],
	},
	ProposalVotes: {
		votes_for: "Vec<AccountId>",
		votes_against: "Vec<AccountId>",
		status: "ProposalStatus",
		expiry: "BlockNumber",
	},
	ResourceId: "[u8; 32]",
	SignedBalance: {
		_enum: {
			Positive: "Balance",
			Negative: "Balance",
		},
	},
	SubAccType: {
		_enum: ["Bailsman", "Borrower", "Lender"],
	},
	Timestamp: "u64",
	TotalAggregates: {
		collateral: "Balance",
		debt: "Balance",
	},
	TransferReason: {
		_enum: [
			"Common",
			"InterestFee",
			"MarginCall",
			"LiquidityFarming",
			"BailsmenRedistribution",
			"TreasuryEqBuyout",
			"TreasuryBuyEq",
			"Subaccount",
			"Lock",
			"Unlock",
			"Claim",
			"CurveFeeWithdraw",
		],
	},
	UserGroup: {
		_enum: ["Unknown", "Balances", "Bailsmen", "Borrowers", "Lenders"],
	},
	UnsignedPriorityPair: "(u64, u64)",
	VestingInfo: {
		locked: "Balance",
		perBlock: "Balance",
		startingBlock: "BlockNumber",
	},
};

const ASSETS = [
	{ token: "ethereum", code: "6648936" },
	{ token: "polkadot", code: "6582132" },
	{ token: "curve-dao-token", code: "6517366" },
	{ token: "eos", code: "6647667" },
	//{ token: "genshiro", code: "1734700659" },
	{ token: "dai", code: "6578537" },
	{ token: "tether", code: "1970496628" },
	{ token: "binance-usd", code: "1651864420" },
	{ token: "usd-coin", code: "1970496611" },
	{ token: "binancecoin", code: "6450786" },
	{ token: "wrapped-bitcoin", code: "2002941027" },
];

const PRECISION = new BN(1_000_000_000);

async function tvl() {
	const provider = new WsProvider("wss://node.genshiro.io");
	const api = await ApiPromise.create({ provider, types });

	const queries = ASSETS.map(({ code }) => {
		return [api.query.eqAggregates.totalUserGroups, ["Balances", { 0: code }]];
	});

	const balances = await api.queryMulti(queries);

	const result = ASSETS.reduce((acc, { token }, i) => {
		return {
			...acc,
			[token]: new BN(balances[i].collateral).div(PRECISION).toNumber(),
		};
	}, {});

	return result;
}

module.exports = {
  genshiro: { tvl },
};

'''
'''--- projects/genshiro/index.js ---
const { getExports } = require('../helper/heroku-api')

module.exports = {
	timetravel: false,
	...getExports("genshiro", ['genshiro'])
}
'''
'''--- projects/gensokishi/index.js ---
const { staking } = require("../helper/staking")

module.exports={
    polygon:{
        staking: staking("0x1b2430aeedececafb52a3ff8cc8321e9426fc82c", "0xa3c322ad15218fbfaed26ba7f616249f7705d945", "polygon", "polygon:0xa3c322ad15218fbfaed26ba7f616249f7705d945"),
        tvl:()=>({})
    }
}
'''
'''--- projects/gfs/contracts.json ---
{
  "iotex": {
    "gfs": {
      "address": "0x1ba725d2ba56482f11fee3642f1c739d25018e4d",
      "token": "0x19f3cb6a4452532793d1605c8736d4a94f48752c"
    }
  }
}

'''
'''--- projects/gfs/index.js ---
const sdk = require("@defillama/sdk");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const { getBlock } = require("../helper/getBlock");
const { sumSingleBalance } = require("@defillama/sdk/build/generalUtil");
const { sumLPWithOnlyOneToken } = require("./../helper/unwrapLPs");

const iotx = "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69";
const wiotx = "0xA00744882684C3e4747faEFD68D283eA44099D03";

function pool2(chain, gasToken) {
  return async (timestamp, block, chainBlocks) => {
    block = await getBlock(timestamp, chain, chainBlocks);
    let balances = { iotex: 0 };
    for (let contract of Object.entries(contracts[chain])) {
      await sumLPWithOnlyOneToken(
        balances,
        contract[1].token,
        contract[1].address,
        wiotx,
        block,
        "iotex"
      );
    }

    if (iotx in balances) {
      balances["iotex"] += balances[iotx] / 10 ** 18;
      delete balances[iotx];
    }
    if (wiotx in balances) {
      balances["iotex"] += balances[wiotx] / 10 ** 18;
      delete balances[wiotx];
    }

    return balances;
  };
}

module.exports = {
  iotex: {
    tvl: () => ({}),
    pool2: pool2("iotex", "iotex"),
  },
};

'''
'''--- projects/gft/contracts.json ---
{
  "iotex": {
    "gft": {
      "address": "0xde5914a97cc5066751624f053d719f67a4d69383",
      "token": "0x53bdd401a871bd0f84e94619edcc0c24489d4aab"
    },
    "gfs": {
      "address": "0x1ba725d2ba56482f11fee3642f1c739d25018e4d",
      "token": "0x19f3cb6a4452532793d1605c8736d4a94f48752c"
    }
  }
}

'''
'''--- projects/gft/index.js ---
const sdk = require("@defillama/sdk");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const { getBlock } = require("../helper/getBlock");
const { sumSingleBalance } = require("@defillama/sdk/build/generalUtil");
const { sumLPWithOnlyOneToken } = require("./../helper/unwrapLPs");
const BigNumber = require("bignumber.js");

const iotx = "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69";
const wiotx = "0xA00744882684C3e4747faEFD68D283eA44099D03";

const gfsBonusStackPool = "0x4346a618c2e3fd4cfa821e91216eaf927bd46ddd";
const gfs = "0x5d0f4ca481fd725c9bc6b415c0ce5b3c3bd726cf";
const gfsLiquidityPool = "0x19f3cb6a4452532793d1605c8736d4a94f48752c";

function pool2(chain, gasToken) {
  return async (timestamp, block, chainBlocks) => {
    block = await getBlock(timestamp, chain, chainBlocks);
    let balances = { iotex: 0 };
    for (let contract of Object.entries(contracts[chain])) {
      await sumLPWithOnlyOneToken(
        balances,
        contract[1].token,
        contract[1].address,
        wiotx,
        block,
        "iotex"
      );
    }

    // bonus stack pool
    const [balanceOfTokenListedInLP, balanceOfLP, balanceOfStackPool] = await Promise.all([
      sdk.api.erc20.balanceOf({
        target: wiotx,
        owner: gfsLiquidityPool,
        block,
        chain
      }),
      sdk.api.erc20.balanceOf({
        target: gfs,
        owner: gfsLiquidityPool,
        block,
        chain
      }),
      sdk.api.erc20.balanceOf({
        target: gfs,
        owner: gfsBonusStackPool,
        block,
        chain
      }),
    ])
    sdk.util.sumSingleBalance(balances, wiotx, BigNumber(balanceOfTokenListedInLP.output).times(balanceOfStackPool.output).div(balanceOfLP.output).toFixed(0))

    if (iotx in balances) {
      balances["iotex"] += balances[iotx] / 10 ** 18;
      delete balances[iotx];
    }
    if (wiotx in balances) {
      balances["iotex"] += balances[wiotx] / 10 ** 18;
      delete balances[wiotx];
    }

    return balances;
  };
}

module.exports = {
  iotex: {
    tvl: () => ({}),
    pool2: pool2("iotex", "iotex"),
  },
};

'''
'''--- projects/gibxswap/index.js ---
const { staking } = require("../helper/staking");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

const swapMiningStakingContract = "0xC31A355277228C1bf9A88599647faEaaE664Ea1f";
const X = "0xAe28714390e95B8dF1Ef847C58AEaC23ED457702";

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    staking: staking(swapMiningStakingContract, X, "bsc"),
    tvl: calculateUsdUniTvl(
      "0x97bCD9BB482144291D77ee53bFa99317A82066E8",
      "bsc",
      "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      ["0x55d398326f99059fF775485246999027B3197955"],
      "WBNB"
    ),
  },
  methodology:
    "Factory address on BSC (0x97bCD9BB482144291D77ee53bFa99317A82066E8) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
};

'''
'''--- projects/ginfinance.js ---
const { calculateUsdUniTvl } = require('./helper/getUsdUniTvl');
module.exports = {
    boba: {
        tvl: calculateUsdUniTvl(
            '0x06350499760aa3ea20FEd2837321a84a92417f39',
            'boba',
            '0x5de1677344d3cb0d7d465c10b72a8f60699c062d',
            [
                '0xa18bf3994c0cc6e3b63ac420308e5383f53120d7', // BOBA
                '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000', // ETH
                '0x66a2a913e447d6b4bf33efbec43aaef87890fbbc', // GIN
            ],
            'tether',
            6
        )
    }
};
'''
'''--- projects/gizadao/index.js ---
const { ohmTvl } = require('../helper/ohm')

const transforms = {
    "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e": "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
}

const treasury = "0x6e273a49Ba8F77d03C0CF5a190f226DcA7D46E9F"
module.exports = ohmTvl(treasury, [
    //DAI
    ["0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e", false],
    //spirit LP
    ["0x9026711a2097252a198e6602a052117eaa5f3cab", true],
    //spirit LP 
    ["0x9733f6ac1fb1d750cc28261bbbbf902d239c1e36", true],
   ], 
   "fantom", 
   "0xF5aB479d02336917bA84981fb8C3999147FcC12B", 
   "0x3389492f36642f27F7bF4a7749fb3FC2c8fbB7EE", 
   addr => (transforms[addr.toLowerCase()] ? transforms[addr.toLowerCase()] : `fantom:${addr}`) ,)
'''
'''--- projects/glide-finance/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')

module.exports={
    timetravel: true,
    misrepresentedTokens: true,
    methodology: "Factory address (0xaAbe38153b25f0d4b2bDa620f67059B3a45334e5) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    elastos: {
        tvl:calculateUsdUniTvl("0xaAbe38153b25f0d4b2bDa620f67059B3a45334e5", "elastos", "0x517E9e5d46C1EA8aB6f78677d6114Ef47F71f6c4", ["0x802c3e839E4fDb10aF583E3E759239ec7703501e", "0xA06be0F5950781cE28D965E5EFc6996e88a8C141"], "elastos"),
        staking: stakingPricedLP("0x7F5489f77Bb8515DE4e0582B60Eb63A7D9959821", "0xd39eC832FF1CaaFAb2729c76dDeac967ABcA8F27", "elastos", "0xbeeAAb15628329C2C89Bc9F403d34b31fbCb3085", "elastos")
    }
}

'''
'''--- projects/globiancedex/index.js ---
const retry = require("../helper/retry");
const axios = require("axios");

async function fetch() {
  const response = (
    await retry(
      async (bail) => await axios.post("https://dexapi.globiance.com/get-stats")
    )
  ).data;

  const tvl = response.data.tvl;

  return tvl;
}

module.exports = {
  misrepresentedTokens: true,
  methodology: `GlobianceDEX TVL is a sum of all the crypto assets locked in various liquidity pools & staking pools available on the DEX.`,
  fetch,
};

'''
'''--- projects/gmx/index.js ---
const sdk = require('@defillama/sdk');
const axios = require('axios')
const {staking} = require('../helper/staking')
const { transformAvaxAddress, transformArbitrumAddress } = require("../helper/portedTokens");

//Arbitrum
const arbitrumApiEndpoint = 'https://gmx-server-mainnet.uw.r.appspot.com/tokens'
const arbitrumVault = '0x489ee077994B6658eAfA855C308275EAd8097C4A';
const arbitrumStaking = '0x908C4D94D34924765f1eDc22A1DD098397c59dD4';
const arbitrumGMX = '0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a';
//Avalanche
const avalancheApiEndpoint = 'https://gmx-avax-server.uc.r.appspot.com/tokens'
const avalancheVault = '0x9ab2De34A33fB459b538c43f251eB825645e8595'
const avalancheStaking = '0x2bD10f8E93B3669b6d42E74eEedC65dd1B0a1342'
const avalancheGMX = '0x62edc0692BD897D2295872a9FFCac5425011c661'

const arbitrumTVL = async (timestamp, block, chainBlocks) =>{
  const transform = await transformArbitrumAddress();
  const balances = {};
  const allTokens = (await axios.get(arbitrumApiEndpoint)).data;
  const tokenBalances = await sdk.api.abi.multiCall({
      block: chainBlocks.arbitrum,
      calls: allTokens.map(token=>({
          target: token.id,
          params: [arbitrumVault]
      })),
      abi: 'erc20:balanceOf',
      chain: 'arbitrum',
  });
  sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transform);
  return balances;
};

const avalancheTVL = async (timestamp, block, chainBlocks) =>{
  const transform = await transformAvaxAddress();
  const balances = {};
  const allTokens = (await axios.get(avalancheApiEndpoint)).data;
  const tokenBalances = await sdk.api.abi.multiCall({
      calls: allTokens.map(token=>({
          target: token.id,
          params: [avalancheVault],
      })),
      abi: 'erc20:balanceOf',
      chain: 'avax',
      block: chainBlocks.avax
  });
  sdk.util.sumMultiBalanceOf(balances, tokenBalances, true, transform);
  return balances;
};

module.exports = {
  arbitrum: {
    staking: staking(arbitrumStaking, arbitrumGMX, "arbitrum", "gmx", 18),
    tvl: arbitrumTVL
  },
  avalanche: {
    staking: staking(avalancheStaking, avalancheGMX, "avax", "gmx", 18),
    tvl: avalancheTVL
  }
};

'''
'''--- projects/gnosis/conditional-token.js ---
/*==================================================
  Modules
==================================================*/

const { api: { abi, util } } = require('@defillama/sdk');

/*==================================================
  Settings
==================================================*/

const START_BLOCK = 8623608;
const PROTOCOL_ADDRESS = '0xc59b0e4de5f1248c1140964e0ff287b192407e0c';
const TOKENS_TO_IGNORE = new Set();

/*==================================================
  Helper Functions
==================================================*/

const getTokenAddressFromLogData = data => '0x' + data.substring(26, 66);

const getCallDataOfErc20Token = (tokenAddress, atThisBlock) =>
  ({
    target: tokenAddress,
    params: PROTOCOL_ADDRESS,
    abi: 'erc20:balanceOf',
    block: atThisBlock,
  });

/*==================================================
  Main
==================================================*/

async function tvl(_, block) {
  // Snag all token addresses that have been listed on Gnosis Conditional Token
  const { output: events } = await util.getLogs({
    keys: [],
    toBlock: block,
    target: PROTOCOL_ADDRESS,
    fromBlock: START_BLOCK,
    topic: "PositionSplit(address,address,bytes32,bytes32,uint256[],uint256)",
  });

  // 1. Reduce all TokenListing logs into an array of token addresses from the log data
  // 2. Remove any tokens we want to ignore as denoted top of file
  // 3. Format to pipe into erc20:balanceOf multiCall
  const tokenList = events.reduce((acc, { data }) => {
    const tokenAddress = getTokenAddressFromLogData(data);
    if (TOKENS_TO_IGNORE.has(tokenAddress)) return acc;
    // add it to de-dupe
    TOKENS_TO_IGNORE.add(tokenAddress);
    const tokenWithCallData = getCallDataOfErc20Token(tokenAddress, block);
    return acc.concat(tokenWithCallData)
  }, []);
  
  // [0] Batch call all ERC20 balances from the Gnosis Conditional Token contract
  // [1] Resolve initial ethBalance promise
  const balances = await abi.multiCall({
    block,
    abi: 'erc20:balanceOf',
    calls: tokenList
  });

  return balances;
}

/*==================================================
  Exports
==================================================*/

module.exports = {
  tvl,
}

'''
'''--- projects/gnosis/index.js ---
/*==================================================
  Modules
==================================================*/

const { api: { abi, util }, util: utilBase } = require('@defillama/sdk');
const { tvl: conditionalTokenTvl } = require('./conditional-token')

/*==================================================
  Settings
==================================================*/

const START_BLOCK = 9340147;
const PROTOCOL_ADDRESS = '0x6F400810b62df8E13fded51bE75fF5393eaa841F';
/* 
* Tokens on GP to ignore
[ 
    0x7cac16770dd5f2a59859a395a492224f05a846b6: "oETH Put $200 29/05/2020",
    0x57ab1e02fee23774580c119740129eac7081e9d3: "broken sUSD proxy"
]
*/
const TOKENS_TO_IGNORE = new Set(['0x7cac16770dd5f2a59859a395a492224f05a846b6', '0x57ab1e02fee23774580c119740129eac7081e9d3', '0xc011a72400e58ecd99ee497cf89e3775d4bd732f']);

/*==================================================
  Helper Functions
==================================================*/

const getTokenAddressFromLogData = data => '0x' + data.substring(26, 66);

const getCallDataOfErc20Token = (tokenAddress, atThisBlock) => 
  ({ 
    target: tokenAddress, 
    params: PROTOCOL_ADDRESS, 
    abi: 'erc20:balanceOf', 
    block: atThisBlock, 
  });

/*==================================================
  Main
==================================================*/

async function tvl(_, block) {
  // Start promised TVL of Conditional Token
  const promisedConditionalTokenTvl = conditionalTokenTvl(_, block)
  
  // Snag all token addresses that have been listed on GP
  const { output: events } = await util.getLogs({
    keys: [],
    toBlock: block,
    target: PROTOCOL_ADDRESS,
    fromBlock: START_BLOCK,
    topic: 'TokenListing(address,uint16)',
  });

  // 1. Reduce all TokenListing logs into an array of token addresses from the log data
  // 2. Remove any tokens we want to ignore as denoted top of file
  // 3. Format to pipe into erc20:balanceOf multiCall
  const tokenList =
    events
      .reduce((acc, { data }) => {
        const tokenAddress = getTokenAddressFromLogData(data)
        if (TOKENS_TO_IGNORE.has(tokenAddress)) return acc

        const tokenWithCallData = getCallDataOfErc20Token(tokenAddress, block)
        return acc.concat(tokenWithCallData)
      }, []);

  // Batch call all ERC20 balances from the G-Protocol & resolve conditionalToken balance promise
  const [protocolErc20Balances, conditionalTokenErc20Balances] = await Promise.all([
    abi.multiCall({
      block,
      abi: 'erc20:balanceOf',
      calls: tokenList
    }), 
    promisedConditionalTokenTvl,
  ])

  const combinedErc20Balances = {
    output: protocolErc20Balances.output.concat(conditionalTokenErc20Balances.output)
  }

  const balances = {
    // GP only accepts WETH
    '0x0000000000000000000000000000000000000000': '0',
  };

  utilBase.sumMultiBalanceOf(balances, combinedErc20Balances);

  return balances;
}

/*==================================================
  Exports
==================================================*/

module.exports = {
  start: 1579811423, // Thu, 23 Jan 2020 20:30:23 GMT
  tvl,
};

'''
'''--- projects/goblin/abi.json ---
{
	"poolInfo": {
		"type": "function",
		"stateMutability": "view",
		"outputs": [
			{
				"internalType": "contract IERC20",
				"name": "lpToken",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "allocPoint",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "lastRewardTime",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "accgoblinPerShare",
				"type": "uint256"
			},
			{
				"internalType": "uint16",
				"name": "depositFeeBP",
				"type": "uint16"
			},
			{
				"internalType": "uint256",
				"name": "lpSupply",
				"type": "uint256"
			}
		],
		"name": "poolInfo",
		"inputs": [
			{
				"type": "uint256",
				"name": "",
				"internalType": "uint256"
			}
		]
	}
}

'''
'''--- projects/goblin/index.js ---
const {masterChefExports} = require('../helper/masterchef')

const GOBLIN = "0x81570aB82533cbd5DB529d29596180eF688c52ba"
module.exports={
    misrepresentedTokens: true,
    methodology: "Tokens in masterchef",
    ...masterChefExports("0x0a05f6022D6e051539b190Bff7E484068A7dd0a4", "fantom", GOBLIN)
}
'''
'''--- projects/goblingold.js ---
const retry = require('./helper/retry');
const axios = require('axios');

async function fetch() {
  const response = (
    await retry(
      async (bail) => await axios.get('https://data.goblin.gold:7766/metrics/tvl')
    )
  ).data;

  return response.totalTVL;
}

module.exports = {
  timetravel: false,
  methodology: "The GoblinGold API endpoint fetches on-chain data from the GoblinGold contracts and uses Coingecko prices to aggregate total TVL.",
  fetch,
};

'''
'''--- projects/goblinscash/index.js ---
const sdk = require('@defillama/sdk');
const { staking, stakingPricedLP } = require("../helper/staking");
const { calculateUsdUniTvlPairs } = require('../helper/getUsdUniTvl')

const goblinStaking = "0x48B8aCe692ad8BD2E3139C65bFf7d28c048F8f00";
const GOB = "0x56381cB87C8990971f3e9d948939e1a95eA113a3";
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04"

const treasuryAddress = "0x259D4CBA522A15AA5Db641D0E06d6f7Aa040D89f";
const flexUSD = "0x7b2B3C5308ab5b2a1d9a94d20D35CCDf61e05b72";
const GOB_flexUSD_MLP = "0xC20A4f3012bA2Df47544d4926B19604Fa777FB01";
const GOB_BCH_MLP = "0x86b0fd64234a747681f0235b6cc5fe04a4d95b31";
const CHAIN = "smartbch"

const flexUsdTVL = calculateUsdUniTvlPairs([GOB_flexUSD_MLP], CHAIN, flexUSD, [GOB], "flex-usd", 18)
const bchTVL = calculateUsdUniTvlPairs([GOB_BCH_MLP], CHAIN, WBCH, [GOB], "bitcoin-cash", 18)
const flexUsdTreasuryTVL = staking(treasuryAddress, flexUSD, CHAIN, "flex-usd", 18)

module.exports = {
  misrepresentedTokens: true,
  smartbch: {
    staking: stakingPricedLP(goblinStaking, GOB, CHAIN, GOB_flexUSD_MLP, "flex-usd", false, 18),
    tvl: sdk.util.sumChainTvls([flexUsdTVL, bchTVL, flexUsdTreasuryTVL])
  },
  methodology:
    "Counts flexUSD and MistSwap's LP tokens (GOB-flexUSD, GOB-WBCH) on the treasury contract towards TVL and staked GOB tokens towards staking",
};

'''
'''--- projects/gogocoin/index.js ---
const sdk = require('@defillama/sdk');
const {
    transformPolygonAddress
} = require('../helper/portedTokens');
const {
    pool2
} = require('../helper/pool2');
const {
    sumChainTvls
} = require('@defillama/sdk/build/generalUtil');

const USDC_POOL_STAKING_CONTRACT = '0x7FCf0f2dcEc385FCCEd98240A8A4bEC8e91da7D1'
const GOVERNANCE_STAKING_CONTRACT = '0xd46206003FfB72Fe5FEB04373328C62e2bF864f9'
const LP_TOKEN_USDC = '0xe33Dd0C0534189b66B9872425189399e2B9c169D'
const LP_STAKING_CONTRACT = '0x5dc4ffc0f9c2261dcaae7f69e1a8837afbd577bc'
const GOGOCOIN = '0xdD2AF2E723547088D3846841fbDcC6A8093313d6'
const USDC = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
const chain = 'polygon'

async function chainTVL(timestamp, block, chainBlocks) {
    const balances = {}
    const transform = await transformPolygonAddress();

    const USDCPool = await sdk.api.abi.call({
        target: USDC_POOL_STAKING_CONTRACT,
        abi: {
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }],
            "stateMutability": "view",
            "type": "function"
        },
        chain: chain,
        block: chainBlocks[chain]
    })

    sdk.util.sumSingleBalance(balances, transform(USDC), USDCPool.output)
    return balances
};

async function stakingX(timestamp, block, chainBlocks) {
    const balances = {}
    const transform = await transformPolygonAddress();

    const totalGOGOLocked = await sdk.api.abi.call({
        target: GOVERNANCE_STAKING_CONTRACT,
        abi: {
            "inputs": [],
            "name": "getTotalLockedGogo",
            "outputs": [{
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }],
            "stateMutability": "view",
            "type": "function"
        },
        chain: chain,
        block: chainBlocks[chain]
    })

    sdk.util.sumSingleBalance(balances, transform(GOGOCOIN), totalGOGOLocked.output)

    return balances
};

async function pool2X(...args) {
    const transform = await transformPolygonAddress();
    return pool2(LP_STAKING_CONTRACT, LP_TOKEN_USDC, chain, transform)(...args)
}

module.exports = {
    timetravel: true,
    start: 1638388550,
    polygon: {
        staking: stakingX,
        pool2: pool2X,
        tvl: chainTVL,
    },
    methodology: "We count liquidity that it is in our USDC-GOGO Liquidity Pool, we also count the total locked USDC in our USDC Staking contract and we count the numbers of GOGOs staked in our GOGO Staking contract.",
}
'''
'''--- projects/goldfinch/abi.json ---
{
    "totalLoansOutstanding": {
      "inputs": [],
      "name": "totalLoansOutstanding",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "pools": {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "pools",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalMinted",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalPrincipalRedeemed",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "created",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "assets": {
      "inputs": [],
      "name": "assets",
      "outputs": [
          {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
          }
      ],
      "stateMutability": "view",
      "type": "function"
    }
}

'''
'''--- projects/goldfinch/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens } = require("../helper/unwrapLPs");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");

const seniorPoolAddress = "0x8481a6EbAf5c7DABc3F7e09e44A89531fd31F822";
const gfFactoryAddress = "0xd20508E1E971b80EE172c73517905bfFfcBD87f9";
const poolTokensAddress = "0x57686612C601Cb5213b01AA8e80AfEb24BBd01df";
const V2_START = 13097274;
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";

const getTranchedPoolAddresses = async (ethBlock) => {
  const logs = await sdk.api.util.getLogs({
    target: gfFactoryAddress,
    keys: [],
    fromBlock: V2_START,
    toBlock: ethBlock,
    topic: "PoolCreated(address,address)",
  });
  return logs.output.map((l) => "0x" + l.topics[1].substr(26));
};

/**
 * This metric represents DeFiLlama's "base" definition of Total Value Locked. It includes
 * only USDC balances in the protocol (that is, in the `SeniorPool` and in all `TranchedPool`s).
 */
const tvl = async (timestamp, ethBlock) => {
  const balances = {};

  const tranchedPoolAddresses = await getTranchedPoolAddresses(ethBlock);

  await sumTokens(
    balances,
    [seniorPoolAddress, ...tranchedPoolAddresses].map((pool) => [USDC, pool]),
    ethBlock
  );

  return balances;
};

/**
 * This metric supplements the "base" `tvl()` metric, by additionally counting value that has
 * been borrowed through the protocol.
 *
 * Goldfinch considers the protocol's Total Value Locked to be the sum of `tvl()` and `borrowed()`.
 *
 * This metric does not include the interest gains of Backers of `TranchedPool`s (though those
 * interest gains are reflected in the USDC balance of `TranchedPool`s in `tvl()`, before
 * that balance is withdrawn). This metric also does not reflect "writedowns" in the value of 
 * the principal of Backers of `TranchedPool`s, as there is no such writedown mechanic for Backers. 
 * Only the `SeniorPool` has a writedown mechanic -- which is reflected in this metric (via 
 * `SeniorPool.assets()`).
 */
const borrowed = async (_, ethBlock) => {
  const _seniorPoolUsdcBalances = {};
  await sumTokens(
    _seniorPoolUsdcBalances,
    [seniorPoolAddress].map((pool) => [USDC, pool]),
    ethBlock
  );
  const seniorPoolUsdcBalance = new BigNumber(_seniorPoolUsdcBalances[USDC]);

  const balances = {};

  const tranchedPoolAddresses = await getTranchedPoolAddresses(ethBlock);

  const poolStats = (
    await sdk.api.abi.multiCall({
      calls: tranchedPoolAddresses.map((tranchedPoolAddress) => ({
        target: poolTokensAddress,
        params: tranchedPoolAddress,
      })),
      abi: abi.pools,
      ethBlock,
    })
  ).output;

  const totalInvested = await poolStats.reduce((sum, thisPoolStats) => {
    return sum
      .plus(new BigNumber(thisPoolStats.output.totalMinted))
      .minus(new BigNumber(thisPoolStats.output.totalPrincipalRedeemed));
  }, new BigNumber(0));

  const seniorAssets = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: abi.assets,
        target: seniorPoolAddress,
        ethBlock,
      })
    ).output
  );

  const seniorLoansOutstanding = new BigNumber(
    (
      await sdk.api.abi.call({
        abi: abi.totalLoansOutstanding,
        target: seniorPoolAddress,
        ethBlock,
      })
    ).output
  );

  // `totalInvested` reflects the senior pool's investments. So we subtract out
  // `seniorLoansOutstanding`, to avoid double-counting given the inclusion of
  // `SeniorPool.totalLoansOutstanding()` in the definition of `SeniorPool.assets()`.
  //
  // We also subtract out `seniorPoolUsdcBalance`, which is included in `SeniorPool.assets()`,
  // and which we do not want to count in this metric so that this metric is properly
  // supplementary to, and not double-counting vis-a-vis, `tvl()`.
  //
  // Note that for (a) a tranched pool that is open and whose principal hasn't been drawndown
  // yet, and for (b) a tranched pool that has had principal repaid but not yet withdrawn, there 
  // is a double-counting phenomenon for such a pool: the pool's USDC balance counted by 
  // `tvl()`, and its principal counted by `totalInvested`. We do not worry about preventing 
  // that double-counting, because it is transient; it disappears once the pool is drawndown 
  // (in the case of (a)) or withdrawn from (in the case of (b)). 
  const borrowed = totalInvested
    .plus(seniorAssets)
    .minus(seniorLoansOutstanding)
    .minus(seniorPoolUsdcBalance);

  sdk.util.sumSingleBalance(balances, USDC, String(borrowed));

  return balances;
};

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  ethereum: {
    tvl,
    borrowed,
  },
  methodology:
    "The base TVL metric counts only excess USDC liquidity in the Senior Pool, and USDC in all the Borrower Pools. " +
    "The Borrowed TVL component additionally counts loans made by the Senior Pool and the Backers of all Borrower Pools.",
};

'''
'''--- projects/golff-finance/abi.json ---
{
    "token": {
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalDeposit":{
        "inputs": [],
        "name": "totalDeposit",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/golff-finance/index.js ---
const sdk = require('@defillama/sdk')
const { default: axios } = require('axios')
const { getBlock } = require('../helper/getBlock')
const abi = require('./abi.json')
const { toUSDTBalances } = require("../helper/balances");

const chainIds = {
    ethereum: 1,
    bsc: 56,
    heco: 128
}

// https://golff.finance/api/v2/product/list?chain_id=56&biz_type=2
function chainTvl(chain, filterFunction) {
    return async (timestamp, ethBlock, chainBlocks) => {
        const api = `https://golff.finance/api/v2/product/list?chain_id=${chainIds[chain]}&biz_type=1`
        const pools = (await axios.get(api)).data.data.filter(filterFunction)
        return toUSDTBalances(pools.reduce((t,p)=>t+p.tvl, 0)/1e18)
    }
}

function chainExports(chain){
    return {
        tvl: chainTvl(chain, p=>!p.name.includes("GOF")),
        staking: chainTvl(chain, p=>p.token_name==="GOF" || p.token_name=== "G-GOF"),
        pool2: chainTvl(chain, p=>p.name.includes("GOF-")),
    }
}

module.exports={
    misrepresentedTokens: false,
    ethereum:chainExports("ethereum"),
    bsc:chainExports("bsc"),
    heco:chainExports("heco"),
}

'''
'''--- projects/good-ghosting/index.js ---
const sdk = require("@defillama/sdk");
const { getChainTransform } = require("../helper/portedTokens");
const axios = require("axios");
const apiUrl = "https://goodghosting-api.com/v1/games";

const chainIdMap = {
  ethereum: 1,
  polygon: 137,
  celo: 42220,
};

function tvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const gameData = await axios.get(apiUrl).then((resp) => resp.data);

    const balances = {};
    const transform = await getChainTransform(chain);

    const calls = Object.values(gameData)
      .filter((game) => game.networkId == chainIdMap[chain])
      .map((game) => [
        {
          target: game.depositTokenAddress,
          params: [game.id],
        },
        {
          target: game.liquidityTokenAddress,
          params: [game.id],
        },
      ])
      .flat();

    const gameContractBalances = await sdk.api.abi.multiCall({
      calls,
      abi: "erc20:balanceOf",
      chain,
    });

    sdk.util.sumMultiBalanceOf(balances, gameContractBalances, true, transform);

    //fix decimal issue with celo tokens
    for (const representation of ["celo-dollar", "celo", "celo-euro"]) {
      if (balances[representation] !== undefined) {
        balances[representation] = Number(balances[representation]) / 1e18;
      }
    }

    return balances;
  };
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology:
    "counts the amount of interest bearing tokens owned by the smart game contract",
  polygon: {
    tvl: tvl("polygon"),
  },
  celo: {
    tvl: tvl("celo"),
  },
}

'''
'''--- projects/gooddollar/abi.json ---
{
	"currentPriceDAI": {
		"inputs": [],
		"name": "currentPriceDAI",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"totalDelegated": {
		"type": "function",
		"stateMutability": "view",
		"outputs": [
			{
				"type": "uint256",
				"name": "",
				"internalType": "uint256"
			}
		],
		"name": "totalDelegated",
		"inputs": []
	}
} 
'''
'''--- projects/gooddollar/index.js ---
const sdk = require("@defillama/sdk");
const abi = require('./abi.json');
const BigNumber = require("bignumber.js");
const { sumTokens } = require("../helper/unwrapLPs");

const tokens = {
    aUSDC: "0xbcca60bb61934080951369a648fb03df4f96263c",
    DAI: "0x6b175474e89094c44da98b954eedeac495271d0f",
    cDAI: "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
    Gfuse: "0x495d133B938596C9984d462F007B676bDc57eCEC", // GoodDollar on Fuse
    FUSE: "0x970b9bb2c0444f5e81e9d0efb84c8ccdcdcaf84d", // Fuse on Mainnet
};

const FUSE_STAKING = '0xA199F0C353E25AdF022378B0c208D600f39a6505';
const GOV_STAKING = '0xFAF457Fb4A978Be059506F6CD41f9B30fCa753b0';
const GOV_STAKING_V2 = '0xB7C3e738224625289C573c54d402E9Be46205546';
const RESERVE_ADDRESS = '0xa150a825d425B36329D8294eeF8bD0fE68f8F6E0';
const AAVE_STAKING_V2 = '0x3ff2d8eb2573819a9ef7167d2ba6fd6d31b17f4f';
const COMPOUND_STAKING = '0xD33bA17C8A644C585089145e86E282fada6F3bfd';
const COMPOUND_STAKING_V2 = '0x7b7246c78e2f900d17646ff0cb2ec47d6ba10754';
const COMMUNITY_SAFE = '0x5Eb5f5fE13d1D5e6440DbD5913412299Bc5B5564';
const GOODDOLLAR_DECIMALS = 2;

async function eth(timestamp, ethBlock) {
    const balances = {};
    await sumTokens(balances, [
        [tokens.aUSDC, AAVE_STAKING_V2],
        [tokens.cDAI, COMPOUND_STAKING],
        [tokens.cDAI, COMPOUND_STAKING_V2],
        [tokens.cDAI, RESERVE_ADDRESS]
    ], ethBlock)

    return balances;
};

async function fuseStaking(timestamp, ethBlock, chainBlocks) {    
    const gdStaked = (await sdk.api.erc20.balanceOf({
        target: tokens.Gfuse,
        chain: 'fuse',
        owner: GOV_STAKING,
        block: chainBlocks['fuse'],
    })).output;

    const gdStakedV2 = (await sdk.api.erc20.balanceOf({
        target: tokens.Gfuse,
        chain: 'fuse',
        owner: GOV_STAKING_V2,
        block: chainBlocks['fuse'],
    })).output;

    const sumGdStaked = BigNumber(gdStaked).plus(gdStakedV2);
    const gdInDAI = await convertGoodDollarsToDai(sumGdStaked, ethBlock);

    const balances = {};
    sdk.util.sumSingleBalance(balances, tokens.DAI, Number(gdInDAI));

    return balances;
}

async function fuseTreasury(timestamp, ethBlock, chainBlocks) {
    const gdInCommunitySafe = (await sdk.api.erc20.balanceOf({
        target: tokens.Gfuse,
        chain: 'fuse',
        owner: COMMUNITY_SAFE,
        block: chainBlocks['fuse']
    })).output;

    const gdInFuseStaking = (await sdk.api.erc20.balanceOf({
        target: tokens.Gfuse,
        chain: 'fuse',
        owner: FUSE_STAKING,
        block: chainBlocks['fuse']
    })).output;

    const gdTotal = BigNumber(gdInCommunitySafe).plus(gdInFuseStaking);
    let gdInDAI = await convertGoodDollarsToDai(gdTotal, ethBlock);

    const balances = {};
    sdk.util.sumSingleBalance(balances, tokens.DAI, Number(gdInDAI));

    return balances;
}

// Required until GoodDollar lists on CoinGecko
async function convertGoodDollarsToDai(gdAmount, ethBlock) {
    const gdPriceInDAI = (await sdk.api.abi.call({
        target: RESERVE_ADDRESS,
        abi: abi.currentPriceDAI,
        block: ethBlock
    })).output;

    return await new BigNumber(gdPriceInDAI).times(gdAmount).div(10 ** GOODDOLLAR_DECIMALS);
}

async function fuse(timestamp, ethBlock, chainBlocks) {
    const fuseAmount = (await sdk.api.abi.call({
        abi: abi.totalDelegated,
        chain: 'fuse',
        target: FUSE_STAKING,
        block: chainBlocks['fuse']
    })).output;

    const balances = {};
    sdk.util.sumSingleBalance(balances, tokens.FUSE, Number(fuseAmount));

    return balances;
}

module.exports = {
    methodology: `Aggregation of funds staked in our contracts on Ethereum and Fuse, funds locked in reserve backing G$ token and community treasury. G$ value was converted to USD based on current price at the reserve.`,
    misrepresentedTokens: true,
    timetravel: true,
    ethereum: {
        tvl: eth
    },
    fuse: {
        staking: fuseStaking,
        tvl: () => ({}),
        treasury: fuseTreasury
    },
}
'''
'''--- projects/goose.js ---
const utils = require('./helper/utils');

/* * * * * * * *
* ==> Correct adapter needs to be created.
*
*****************/

async function fetch() {
  let response = await utils.fetchURL('https://api.goosedefi.com/getTVL')
  return parseFloat(response.data);

}

module.exports = {
  fetch
}

'''
'''--- projects/grape-finance/index.js ---
const { pool2Exports } = require("../helper/pool2");
const { staking } = require("../helper/staking");

const grape = "0x5541D83EFaD1f281571B343977648B75d95cdAC2";
const wine = "0xC55036B5348CfB45a932481744645985010d3A44";
const rewardpool = "0x28c65dcB3a5f0d456624AFF91ca03E4e315beE49";
const boardroom = "0x3ce7bC78a7392197C569504970017B6Eb0d7A972";

const LPTokens = [
    "0x00cB5b42684DA62909665d8151fF80D1567722c3", // WINE-MIM
    "0xb382247667fe8CA5327cA1Fa4835AE77A9907Bc8", // GRAPE-MIM
    "0xd3d477Df7f63A2623464Ff5Be6746981FdeD026F" // GRAPE-WINE
]

module.exports = {
    avalanche: {
        tvl: async () => ({}),
        pool2: pool2Exports(rewardpool, LPTokens, "avax"),
        staking: staking(boardroom, wine, "avax")
    }
}
'''
'''--- projects/grassland-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const wild = "0x54c6960fbb3e6572377980277057cf08ccad646b";
const masterchef = "0x68B279Cfaf1b0CDE999B5590C3Cb5F74AEc1eF6a";

module.exports = {
    ...masterChefExports(masterchef, "polygon", wild, false)
}
'''
'''--- projects/grave/index.js ---
const sdk = require("@defillama/sdk");
const { stakingPricedLP } = require("../helper/staking");
const { transformAvaxAddress  } = require("../helper/portedTokens");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const { pool2Exports } = require("../helper/pool2");

const GRAVE = "0x3700a92dd231F0CaC37D31dBcF4c0f5cCb1db6Ca"
const GSHARE = "0xffe04bf98c7111360bf7a6c56b343915543cd941"
const GenMasterchef = "0x6ee714a7c17309b57b85a61a161621acb66dbbd9"
const ASYLUM = "0xDa1fe319C8C295A26102f40b680bF4beB7afF6c4"
const GShareRewardPool = "0xF051dB01326355303A24bEa002409dcD71d396a0"

const graveAvaxLp = "0x10e882acfae3cf63e96741fabc41c19025e7be2a"
const gShareAvaxLp = "0xae427ad7a54f5490ef76b3bde3663b0e45c7a102"

async function atvl(timestamp, block, chainBlocks) {
    const balances = {};
    const transform = await transformAvaxAddress();
    await sumTokensAndLPsSharedOwners(
		balances,
		[
			["0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", false],
			["0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664", false],
			["0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd", false],
			["0x070092b3A985f9E5424351D68730c9A318ad96eb", false],
			
		],
		[GenMasterchef],
		chainBlocks.avax,
		"avax",
		transform,
	);
    

    return balances;
};

const pool2LPs = [
    graveAvaxLp,
    gShareAvaxLp,
  ];
  
module.exports = {
    avalanche: {
        tvl: atvl,
        pool2: pool2Exports(GShareRewardPool,pool2LPs,"avax"),
        staking: stakingPricedLP(ASYLUM, GSHARE, "avax", gShareAvaxLp, "wrapped-avax")
    }   
};
'''
'''--- projects/gravity-finance/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js');
const {transformPolygonAddress} = require('../helper/portedTokens');

async function tvl(_, block, chainBlocks) {
  const transformPolygon = await transformPolygonAddress();
  block = chainBlocks['polygon'];

  const balances = await calculateUniTvl(
    transformPolygon, 
    block, 
    'polygon', 
    '0x3ed75AfF4094d2Aaa38FaFCa64EF1C152ec1Cf20', 
    18134755, 
    true
  );
    
  return balances;
};

module.exports = {
  methodology: `Counts the liquidity on all AMM pools.
  We get the TVL by first fetching all the PairCreated() events emitted by the factory contract in order to get all the pairs and then we get the amount of tokens on each pair by calling getReserves() on that pair's contract. Once we have the total amount locked of each token we just price them using coingecko, and, if coingecko doesn't have the price of one of the tokens we just exclude that token from the TVL.`,
  polygon: {
    tvl
  }
};
// node test.js projects/gravity-finance/index.js

'''
'''--- projects/greenhouse/index.js ---
const { getChainTransform } = require("../helper/portedTokens")
const { addFundsInMasterChef } = require('../helper/masterchef')
const MASTERCHEF = "0xbD40a260Ddd78287ddA4C4ede5880505a9fEdF9a"

async function tvl (timestamp, ethBlock, chainBlocks) {
  const balances = {};
  const chain = 'polygon'
  const transformAddress = await getChainTransform(chain);
  await addFundsInMasterChef(balances, MASTERCHEF, chainBlocks[chain], chain, transformAddress);
  return balances;
};

module.exports = {
  polygon: {  tvl,  },
}

'''
'''--- projects/grim/index.js ---
const utils = require('../helper/utils');

async function fetch() {
  const response = await utils.fetchURL('https://api.grim.finance/tvl');

  let tvl = 0;
  for (const chainId in response.data) {
    const chain = response.data[chainId];

    for (const vault in chain) {
      tvl += chain[vault];
    }
  }
  if(tvl === 0){
    throw new Error("TVL for grim finance cannot be 0")
  }

  return tvl;
}

module.exports = {
  hallmarks: [
    [1639785600, "Reentrancy attack"]
],
  timetravel: false,
  methodology: 'TVL data is pulled from the Grim Finance API "https://api.grim.finance/tvl".',
  fetch,
}

'''
'''--- projects/groprotocol/abi.json ---
{
   "totalAssets": {
       "inputs": [],
       "name": "totalAssets",
       "outputs": [
           {
               "internalType": "uint256",
               "name": "",
               "type": "uint256"
           }
       ],
       "stateMutability": "view",
       "type": "function"
   },
   "totalSupply": {
       "inputs": [],
       "name": "totalSupply",
       "outputs": [
           {
               "internalType": "uint256",
               "name": "",
               "type": "uint256"
           }
       ],
       "stateMutability": "view",
       "type": "function"
   }
}

'''
'''--- projects/groprotocol/helpers.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");

const lpReservesAbi = {
  constant: true,
  inputs: [],
  name: "getReserves",
  outputs: [
    { internalType: "uint112", name: "_reserve0", type: "uint112" },
    { internalType: "uint112", name: "_reserve1", type: "uint112" },
    { internalType: "uint32", name: "_blockTimestampLast", type: "uint32" },
  ],
  payable: false,
  stateMutability: "view",
  type: "function",
};
const lpSuppliesAbi = {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
  payable: false,
  stateMutability: "view",
  type: "function",
};
const token0Abi = {
  constant: true,
  inputs: [],
  name: "token0",
  outputs: [{ internalType: "address", name: "", type: "address" }],
  payable: false,
  stateMutability: "view",
  type: "function",
};
const token1Abi = {
  constant: true,
  inputs: [],
  name: "token1",
  outputs: [{ internalType: "address", name: "", type: "address" }],
  payable: false,
  stateMutability: "view",
  type: "function",
};

/* lpPositions:{
    balance,
    token
}[]
*/
async function unwrapUniswapLPs(
  balances,
  lpPositions,
  block,
  chain = "ethereum",
  transformAddress = (addr) => addr,
  excludeTokensRaw = [],
  retry = false
) {
  const excludeTokens = excludeTokensRaw.map((addr) => addr.toLowerCase());
  const lpTokenCalls = lpPositions.map((lpPosition) => ({
    target: lpPosition.token,
  }));
  const lpReserves = sdk.api.abi.multiCall({
    block,
    abi: lpReservesAbi,
    calls: lpTokenCalls,
    chain,
  });
  const lpSupplies = sdk.api.abi.multiCall({
    block,
    abi: lpSuppliesAbi,
    calls: lpTokenCalls,
    chain,
  });
  const tokens0 = sdk.api.abi.multiCall({
    block,
    abi: token0Abi,
    calls: lpTokenCalls,
    chain,
  });
  const tokens1 = sdk.api.abi.multiCall({
    block,
    abi: token1Abi,
    calls: lpTokenCalls,
    chain,
  });
  if (retry) {
    await Promise.all(
      [
        [lpReserves, lpReservesAbi],
        [lpSupplies, lpSuppliesAbi],
        [tokens0, token0Abi],
        [tokens1, token1Abi],
      ].map(async (call) => {
        await requery(await call[0], chain, block, call[1]);
      })
    );
  }
  await Promise.all(
    lpPositions.map(async (lpPosition) => {
      try {
        const lpToken = lpPosition.token;
        const token0 = (await tokens0).output
          .find((call) => call.input.target === lpToken)
          .output.toLowerCase();
        const token1 = (await tokens1).output
          .find((call) => call.input.target === lpToken)
          .output.toLowerCase();
        const supply = (await lpSupplies).output.find(
          (call) => call.input.target === lpToken
        ).output;
        const { _reserve0, _reserve1 } = (await lpReserves).output.find(
          (call) => call.input.target === lpToken
        ).output;
        if (!excludeTokens.includes(token0)) {
          const token0Balance = BigNumber(lpPosition.balance)
            .times(BigNumber(_reserve0))
            .div(BigNumber(supply));
          sdk.util.sumSingleBalance(
            balances,
            await transformAddress(token0),
            token0Balance.toFixed(0)
          );
        }
        if (!excludeTokens.includes(token1)) {
          const token1Balance = BigNumber(lpPosition.balance)
            .times(BigNumber(_reserve1))
            .div(BigNumber(supply));
          sdk.util.sumSingleBalance(
            balances,
            await transformAddress(token1),
            token1Balance.toFixed(0)
          );
        }
      } catch (e) {
        console.log(
          `Failed to get data for LP token at ${lpPosition.token} on chain ${chain}`
        );
        throw e;
      }
    })
  );
}

const crvPools = {
  // PWRD-3CRV
  "0xbcb91e689114b9cc865ad7871845c95241df4105": {
    swapContract: "0x001C249c09090D79Dc350A286247479F08c7aaD7",
    underlyingTokens: [
      "0xf0a93d4994b3d98fb5e3a2f90dbc2d69073cb86b",
      "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490",
    ],
  },
};

async function unwrapCrvLPs(
  balances,
  lpPositions,
  block,
  chain = "ethereum",
  transformAddress = (addr) => addr,
  excludeTokens = []
) {
  await Promise.all(
    lpPositions.map(async (lp) => {
      try {
        await unwrapCrv(
          balances,
          lp.token,
          lp.balance,
          block,
          chain,
          transformAddress,
          excludeTokens
        );
      } catch (e) {
        console.log(
          `Failed to get data for LP token at ${lp.token} on chain ${chain}`
        );
        throw e;
      }
    })
  );
}

async function unwrapCrv(
  balances,
  crvToken,
  balance3Crv,
  block,
  chain = "ethereum",
  transformAddress = (addr) => addr,
  excludeTokensRaw = []
) {
  const excludeTokens = excludeTokensRaw.map((t) => t.toLowerCase());
  if (crvPools[crvToken.toLowerCase()] === undefined) {
    return;
  }
  const underlyingTokens = crvPools[crvToken.toLowerCase()].underlyingTokens;
  const crvTotalSupply = sdk.api.erc20.totalSupply({
    target: crvToken,
    block,
    chain,
  });
  const underlyingSwapTokens = (
    await sdk.api.abi.multiCall({
      calls: underlyingTokens.map((token) => ({
        target: token,
        params: [crvToken],
      })),
      block,
      chain,
      abi: "erc20:balanceOf",
    })
  ).output;
  const resolvedCrvTotalSupply = (await crvTotalSupply).output;
  underlyingSwapTokens.forEach((call) => {
    if (excludeTokens.includes(call.input.target.toLowerCase())) {
      return;
    }
    const underlyingBalance = BigNumber(call.output || 0)
      .times(balance3Crv)
      .div(resolvedCrvTotalSupply);
    sdk.util.sumSingleBalance(
      balances,
      transformAddress(call.input.target),
      underlyingBalance.toFixed(0)
    );
  });
}

module.exports = {
  unwrapCrv,
  unwrapCrvLPs,
  unwrapUniswapLPs,
};

'''
'''--- projects/groprotocol/index.js ---
// Adapter for Gro Protocol : https://gro.xyz

const sdk = require("@defillama/sdk");
const { sumBalancerLps } = require("../helper/unwrapLPs");
const { unwrapUniswapLPs, unwrapCrvLPs } = require("./helpers");
const { getBlock } = require("../helper/getBlock");
const { transformAvaxAddress } = require("../helper/portedTokens");

const groTokenAbi = require("./abi.json");
const { stakings } = require("../helper/staking");

// Gro Protocol Token Addresses
const GRO = "0x3Ec8798B81485A254928B70CDA1cf0A2BB0B74D7"; // Governance Token, not counted for TVL unless staked in pools
const GVT = "0x3ADb04E127b9C0a5D36094125669d4603AC52a0c"; // Protocol token representing share of assets, fully count
const PWRD = "0xf0a93d4994b3d98fb5e3a2f90dbc2d69073cb86b"; // Protocol token representing share of assets, fully count

// Gro Protocol LP Pool Addresses
const PO_SS_GRO = "0x3Ec8798B81485A254928B70CDA1cf0A2BB0B74D7"; // Count only if staked
const P1_UNI_GRO_GVT = "0x2ac5bC9ddA37601EDb1A5E29699dEB0A5b67E9bB"; // Count non-GVT assets and only if staked
const P2_UNI_GRO_USDC = "0x21C5918CcB42d20A2368bdCA8feDA0399EbfD2f6"; // Count only if staked
const P3_SS_GVT = "0x3ADb04E127b9C0a5D36094125669d4603AC52a0c"; // Ignore as GVT already counted
const P4_CRV_PWRD_TCRV = "0xbcb91E689114B9Cc865AD7871845C95241Df4105"; // Count non-PWRD assets and only if staked
const P5_BAL_GRO_WETH = "0x702605f43471183158938c1a3e5f5a359d7b31ba"; // Count only if staked

// Other Token Addresses
const TCRV = "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490"; // Count if staked
const DAI = "0x6B175474E89094C44Da98b954EedeAC495271d0F"; // Count if staked
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"; // Count if staked
const USDT = "0xdAC17F958D2ee523a2206206994597C13D831ec7"; // Count if staked
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"; // Count if staked

// Contract Addresses
const GROTokenStaker1 = "0x001C249c09090D79Dc350A286247479F08c7aaD7";
const GROTokenStaker2 = "0x2E32bAd45a1C29c1EA27cf4dD588DF9e68ED376C";

async function tvl(timestamp, ethBlock) {
  let balances = {};
  const crvLpPositions = [];

  if (timestamp < 1633046400) {
    // Before 01-10-2021
    // Prior to this point no pools and no pricing on Coingecko so use 18 decimal DAI as a $1.00 proxy

    for (const token of [PWRD, GVT]) {
      const current = await sdk.api.abi.call({
        target: token,
        abi: groTokenAbi["totalAssets"],
        block: ethBlock,
      });
      // Treat amounts as if in DAI. Calls to totalAssets() return USD amount
      sdk.util.sumSingleBalance(balances, DAI, current.output);
    }
  } else {
    // On or after 01-10-2021
    // Can output PWRD and GVT balances directly as Coingecko can price the tokens

    // Assets held within PWRD and GVT directly
    for (const token of [PWRD, GVT]) {
      const current = await sdk.api.abi.call({
        target: token,
        abi: groTokenAbi["totalSupply"],
        block: ethBlock,
      });
      sdk.util.sumSingleBalance(balances, token, current.output);
    }

    // Assets held in staking pools (not counting any PWRD or GVT assets as these are already counted)

    // P3_SS_GVT - GVT already accounted for

    // P4_CRV_PWRD_TCRV
    const p4a = await sdk.api.erc20.balanceOf({
      target: P4_CRV_PWRD_TCRV,
      owner: GROTokenStaker1,
      block: ethBlock,
    });
    crvLpPositions.push({ token: P4_CRV_PWRD_TCRV, balance: p4a.output });

    // P4_CRV_PWRD_TCRV
    const p4b = await sdk.api.erc20.balanceOf({
      target: P4_CRV_PWRD_TCRV,
      owner: GROTokenStaker2,
      block: ethBlock,
    });
    crvLpPositions.push({ token: P4_CRV_PWRD_TCRV, balance: p4b.output });

    await unwrapCrvLPs(
      balances,
      crvLpPositions,
      ethBlock,
      "ethereum",
      undefined,
      [PWRD]
    ); // Excludes already counted PWRD amount
  }

  return balances;
}
async function pool2(timestamp, ethBlock) {
  let balances = {};
  balances = await tokenStaker(timestamp, ethBlock, balances, GROTokenStaker1);
  return await tokenStaker(timestamp, ethBlock, balances, GROTokenStaker2);
}
async function tokenStaker(timestamp, ethBlock, balances, GROTokenStaker) {
  const uniLpPositions = [];
  const balLpPositions = [];
  // P1_UNI_GRO_GVT
  // P2_UNI_GRO_USDC
  const p1 = (
    await sdk.api.erc20.balanceOf({
      target: P1_UNI_GRO_GVT,
      owner: GROTokenStaker,
      block: ethBlock,
    })
  ).output;
  uniLpPositions.push({ token: P1_UNI_GRO_GVT, balance: p1 });

  const p2 = (
    await sdk.api.erc20.balanceOf({
      target: P2_UNI_GRO_USDC,
      owner: GROTokenStaker,
      block: ethBlock,
    })
  ).output;
  uniLpPositions.push({ token: P2_UNI_GRO_USDC, balance: p2 });

  await unwrapUniswapLPs(
    balances,
    uniLpPositions,
    ethBlock,
    "ethereum",
    undefined,
    [GVT]
  ); // Excludes already counted GVT amount
  // P5_BAL_GRO_WETH
  if (timestamp > 1633392000) {
    // On or after 05-10-2021, P5 pool available
    const p5 = await sdk.api.erc20.balanceOf({
      target: P5_BAL_GRO_WETH,
      owner: GROTokenStaker,
      block: ethBlock,
    });
    balLpPositions.push({ P5_BAL_GRO_WETH, p5 });

    await sumBalancerLps(
      balances,
      [[P5_BAL_GRO_WETH, GROTokenStaker, true]],
      ethBlock,
      "ethereum",
      (addr) => addr.toLowerCase(addr)
    );
  }
  return balances;
}

const labs = [
  {
    // USDC
    vault: "0x57DaED1ee021BE9991F5d30CF494b6B09B5B449E",
    baseToken: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
  },
  {
    // DAI
    vault: "0x5E57E11483A3F60A76af3045303604522059dA2a",
    baseToken: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
  },
  {
    // USDT
    vault: "0x471F4B4b9A97F82C3a25b034B33A8E306eE9Beb5",
    baseToken: "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
  },
  {
    // USDC
    vault: "0x2Eb05cfFA24309b9aaf300392A4D8Db745d4E592",
    baseToken: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
  },
  {
    // DAI
    vault: "0x6063597B9356B246E706Fd6A48C780F897e3ef55",
    baseToken: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
  },
  {
    // USDT
    vault: "0x6EF44077a1F5e10cDfcCc30EFb7dCdb1d5475581",
    baseToken: "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
  },
];

async function avaxTvl(timestamp, block, chainBlocks) {
  let balances = {};
  block = await getBlock(timestamp, "avax", chainBlocks);
  const transform = await transformAvaxAddress();
  const totalAssets = (
    await sdk.api.abi.multiCall({
      calls: labs.map((l) => ({ target: l.vault })),
      abi: groTokenAbi.totalAssets,
      block,
      chain: "avax",
    })
  ).output;

  for (let i = 0; i < labs.length; i++) {
    sdk.util.sumSingleBalance(
      balances,
      transform(labs[i].baseToken),
      totalAssets[i].output
    );
  }
  return balances;
}

module.exports = {
  ethereum: {
    pool2,
    staking: stakings([ GROTokenStaker1, GROTokenStaker2 ], GRO),
    tvl,
  },
  avalanche: {
    tvl: avaxTvl,
  },
  start: 1622204347, // 28-05-2021 12:19:07 (UTC)
  methodology:
    "Assets held within the GRO Protocol - either within the PWRD or Vault (GVT) products, or staked in the Gro Protocol pools. Avax TVL is the sum of tokens locked in Gro Labs.",
};

'''
'''--- projects/growth-defi.js ---
const axios = require("axios");

async function fetch() {
    const query = `
    {
      totalValueLocked(id: 1) {
        totalValueLockedUSD
      }
    }
  `;

    const options = {
      method: "post",
      url: "https://api.thegraph.com/subgraphs/name/growthdefi/growth-defi",
      data: {
        query,
      },
    };

    const response = await axios(options);

    const tvl = response.data.data.totalValueLocked.totalValueLockedUSD;

    return parseFloat(tvl);
}

module.exports = {
  fetch
}

'''
'''--- projects/growthdefi/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accCakePerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "symbol": {
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "reserveToken": {
        "inputs": [],
        "name": "reserveToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "_reserveToken",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalReserve": {
        "inputs": [],
        "name": "totalReserve",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "_totalReserve",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "state": {
        "inputs": [],
        "name": "state",
        "outputs": [
            {
                "internalType": "address",
                "name": "_masterChef",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "_pid",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "_rewardToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_routingToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_reserveToken",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_treasury",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_collector",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "_exchange",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "_minimalGulpFactor",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_forceGulpRatio",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_performanceFee",
                "type": "uint256"
            },
            {
                "internalType": "bool",
                "name": "_emergencyMode",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/growthdefi/abis/belt.json ---
{
    "totalSupply": {
        "name": "totalSupply",
        "outputs": [
            {
                "type": "uint256",
                "name": "out"
            }
        ],
        "inputs": [],
        "constant": true,
        "payable": false,
        "type": "function"
    },
    "balances": {
        "name": "balances",
        "outputs": [
            {
                "type": "uint256",
                "name": "out"
            }
        ],
        "inputs": [
            {
                "type": "int128",
                "name": "arg0"
            }
        ],
        "constant": true,
        "payable": false,
        "type": "function"
    },
    "coins": {
        "name": "coins",
        "outputs": [
            {
                "type": "address",
                "name": "out"
            }
        ],
        "inputs": [
            {
                "type": "int128",
                "name": "arg0"
            }
        ],
        "constant": true,
        "payable": false,
        "type": "function"
    },
    "sharesToAmount": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_shares",
                "type": "uint256"
            }
        ],
        "name": "sharesToAmount",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/growthdefi/abis/clqdr.json ---
{
    "totalReserve": {
        "inputs": [],
        "name": "totalReserve",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/growthdefi/abis/psm.json ---
{
    "peggedToken": {
        "inputs": [],
        "name": "peggedToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/growthdefi/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const clqdr = require("./abis/clqdr.json");
const psm = require("./abis/psm.json");
const { staking } = require("../helper/staking");

const {
  transformBscAddress,
  transformAvaxAddress,
  transformFantomAddress,
} = require("../helper/portedTokens");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const GRO_BSC = "0x336ed56d8615271b38ecee6f4786b55d0ee91b96";
const LINSPIRIT = "0xc5713B6a0F26bf0fdC1c52B90cd184D950be515C";

const morChains = {
  bsc: {
    pools: [
      "0x13e7a6691fe00de975cf27868386f4ae9aed3cdc",
      "0xc2e8c3c427e0a5baaf512a013516aecb65bd75cb",
    ],

    ignoreAddresses: [],
  },
  avax: {
    pools: [],

    ignoreAddresses: [],
  },
  fantom: {
    pools: [
      "0x30463d33735677b4e70f956e3dd61c6e94d70dfe",
      "0xaebd31E9FFcB222feE947f22369257cEcf1F96CA",
    ],
    ignoreAddresses: [],
  },
};

const morChainsNonStk = {
  bsc: {
    pools: [],
    mcds: [],
    ignoreAddresses: [],
  },
  avax: {
    pools: [],
    mcds: [],
    ignoreAddresses: [],
  },
  fantom: {
    pools: [
      "0x814c66594a22404e101fecfecac1012d8d75c156",
      "0x3f569724cce63f7f24c5f921d5ddcfe125add96b",
    ],
    mcds: [
      "0xe5fb3D583660e57b1f616f89Ae98dfb6e3c37f99",
      "0x726d946BBF3d0E6f9e5078D4F5e1f0014c37288F",
    ],
    ignoreAddresses: [],
  },
};

const transformFrom = async (chain) => {
  if (chain === "bsc") {
    return transformBscAddress();
  } else if (chain === "avax") {
    return transformAvaxAddress();
  } else {
    return transformFantomAddress();
  }
};

//*** MOR tvl portion as product of GrowthDefi Protocol ***//
const fetchMorChainTvl = async (
  timestamp,
  ethBlock,
  chainBlocks,
  chain,
  chainCustomProcessor
) => {
  const chainConfig = morChains[chain];

  const balances = {};

  const stakeLpTokens = (
    await sdk.api.abi.multiCall({
      abi: abi.state,
      calls: chainConfig.pools.map((pool) => ({
        target: pool,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp) => stkLp.output._reserveToken);

  const stakeLpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: abi.totalReserve,
      calls: chainConfig.pools.map((pool) => ({
        target: pool,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp_bal) => stkLp_bal.output);

  const stkSymbol = (
    await sdk.api.abi.multiCall({
      abi: abi.symbol,
      calls: stakeLpTokens.map((lp) => ({
        target: lp,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output;

  const lpPositions = [];

  await Promise.all(
    stkSymbol.map(async (symbol, idx) => {
      if (symbol.output.includes("LP")) {
        lpPositions.push({
          token: stakeLpTokens[idx],
          balance: stakeLpTokens_bal[idx],
        });
      } else {
        const processedTokens = await chainCustomProcessor(
          stakeLpTokens[idx],
          stakeLpTokens_bal[idx],
          symbol.output,
          chainBlocks
        );

        processedTokens.map(({ tokenAddress, tokenBalance }) => {
          sdk.util.sumSingleBalance(
            balances,
            `${chain}:${tokenAddress}`,
            tokenBalance
          );
        });
      }
    })
  );

  const transformAddress = await transformFrom(chain);

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks[chain],
    chain,
    transformAddress
  );

  return balances;
};

//*** MOR tvl portion as product of GrowthDefi Protocol - for the non strategy contracts ***//
const fetchMorNonStkChainTvl = async (
  timestamp,
  ethBlock,
  chainBlocks,
  chain,
  chainCustomProcessor
) => {
  const chainConfig = morChainsNonStk[chain];

  const balances = {};

  const stakeLpTokens = chainConfig.pools;

  const stakeLpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: "erc20:balanceOf",
      calls: chainConfig.pools.map((pool, idx) => ({
        target: pool,
        params: chainConfig.mcds[idx],
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp_bal) => stkLp_bal.output);

  const stkSymbol = (
    await sdk.api.abi.multiCall({
      abi: abi.symbol,
      calls: stakeLpTokens.map((lp) => ({
        target: lp,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output;

  const lpPositions = [];

  await Promise.all(
    stkSymbol.map(async (symbol, idx) => {
      if (symbol.output.includes("LP")) {
        lpPositions.push({
          token: stakeLpTokens[idx],
          balance: stakeLpTokens_bal[idx],
        });
      } else {
        const processedTokens = await chainCustomProcessor(
          stakeLpTokens[idx],
          stakeLpTokens_bal[idx],
          symbol.output,
          chainBlocks
        );

        processedTokens.map(({ tokenAddress, tokenBalance }) => {
          sdk.util.sumSingleBalance(
            balances,
            `${chain}:${tokenAddress}`,
            tokenBalance
          );
        });
      }
    })
  );

  const transformAddress = await transformFrom(chain);

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks[chain],
    chain,
    transformAddress
  );

  return balances;
};

//*** LQDR staked portion as product of GrowthDefi Protocol ***//
const fetchCLQDRStaking = async (
  timestamp,
  ethBlock,
  chainBlocks,
  chain,
  chainCustomProcessor
) => {
  const balances = {};

  const stakeLpTokens = ["0x814c66594a22404e101fecfecac1012d8d75c156"];

  const stakeLpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: clqdr.totalReserve,
      calls: stakeLpTokens.map((pool, idx) => ({
        target: pool,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp_bal) => stkLp_bal.output);

  const stkSymbol = (
    await sdk.api.abi.multiCall({
      abi: abi.symbol,
      calls: stakeLpTokens.map((lp) => ({
        target: lp,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output;

  await Promise.all(
    stkSymbol.map(async (symbol, idx) => {
      const processedTokens = await chainCustomProcessor(
        "0x10b620b2dbAC4Faa7D7FFD71Da486f5D44cd86f9",
        stakeLpTokens_bal[idx],
        "LQDR",
        chainBlocks
      );

      processedTokens.map(({ tokenAddress, tokenBalance }) => {
        sdk.util.sumSingleBalance(
          balances,
          `${chain}:${tokenAddress}`,
          tokenBalance
        );
      });
    })
  );

  return balances;
};

const psmConfig = {
  avax: ["0x88cc23286f1356eb0163ad5bdbfa639416e4168d"],
  bsc: [],
  fantom: ["0xa561fa603bf0b43cb0d0911eeccc8b6777d3401b"],
};

const stableConfig = {
  avax: ["0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664"],
  bsc: ["0xe9e7cea3dedca5984780bafc599bd69add087d56"],
  fantom: [],
};

const autoGem = {
  avax: "0x65764167EC4B38D611F961515B51a40628614018",
  bsc: "0xE02CE329281664A5d2BC0006342DC84f6c384663",
  fantom: "",
};

const DAI = {
  avax: "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
  bsc: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
  fantom: "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e",
};

//*** PSM staked portion as product of GrowthDefi Protocol ***//
const fetchPSMMultiple = async (
  timestamp,
  ethBlock,
  chainBlocks,
  chain,
  chainCustomProcessor
) => {
  const balances = {};

  const stakeLpTokens = psmConfig[chain];

  const stakeLpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: "erc20:totalSupply",
      calls: stakeLpTokens.map((pool, idx) => ({
        target: pool,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp_bal) => stkLp_bal.output);

  const stkSymbol = (
    await sdk.api.abi.multiCall({
      abi: abi.symbol,
      calls: stakeLpTokens.map((lp) => ({
        target: lp,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output;

  await Promise.all(
    stkSymbol.map(async (symbol, idx) => {
      const processedTokens = await chainCustomProcessor(
        DAI[chain],
        stakeLpTokens_bal[idx],
        "DAI",
        chainBlocks
      );

      processedTokens.map(({ tokenAddress, tokenBalance }) => {
        sdk.util.sumSingleBalance(
          balances,
          `${chain}:${tokenAddress}`,
          tokenBalance
        );
      });
    })
  );

  return balances;
};

//*** PSM staked portion as product of GrowthDefi Protocol ***//
const fetchPSMSingle = async (
  timestamp,
  ethBlock,
  chainBlocks,
  chain,
  chainCustomProcessor
) => {
  const balances = {};

  const stakeLpTokens = stableConfig[chain];

  const stakeLpTokens_bal = (
    await sdk.api.abi.multiCall({
      abi: "erc20:balanceOf",
      calls: stakeLpTokens.map((pool, idx) => ({
        target: pool,
        params: autoGem[chain],
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output.map((stkLp_bal) => stkLp_bal.output);

  const stkSymbol = (
    await sdk.api.abi.multiCall({
      abi: abi.symbol,
      calls: stakeLpTokens.map((lp) => ({
        target: lp,
      })),
      chain: chain,
      block: chainBlocks[chain],
    })
  ).output;

  await Promise.all(
    stkSymbol.map(async (symbol, idx) => {
      const processedTokens = await chainCustomProcessor(
        DAI[chain],
        stakeLpTokens_bal[idx],
        "DAI",
        chainBlocks
      );

      processedTokens.map(({ tokenAddress, tokenBalance }) => {
        sdk.util.sumSingleBalance(
          balances,
          `${chain}:${tokenAddress}`,
          tokenBalance
        );
      });
    })
  );

  return balances;
};

/**
 * BSC-specific tokens processing logic
 *
 * @param {*} address
 * @param {*} balance
 * @param {*} symbol
 * @param {*} chainBlocks
 * @returns
 */
const bscTokensProcessor = async (address, balance, symbol, chainBlocks) => {
  let tokenAddress = address;
  let tokenBalance = balance;

  // Replace govGRO token with GRO (as it's pegged 1:1)
  if (symbol === "govGRO") {
    tokenAddress = GRO_BSC;
  }

  return [{ tokenAddress, tokenBalance }];
};

/**
 * Avax-specific tokens processing logic
 *
 * @param {*} address
 * @param {*} balance
 * @param {*} symbol
 * @param {*} chainBlocks
 * @returns
 */
const avaxTokensProcessor = async (address, balance, symbol, chainBlocks) => {
  let tokenAddress = address;
  let tokenBalance = balance;

  return [{ tokenAddress, tokenBalance }];
};

const ftmTokensProcessor = async (address, balance, symbol, chainBlocks) => {
  let tokenAddress = address;
  let tokenBalance = balance;

  // Replace govGRO token with GRO (as it's pegged 1:1)
  if (symbol === "slinSpirit") {
    tokenAddress = LINSPIRIT;
  }

  return [{ tokenAddress, tokenBalance }];
};

const morBscTvl = (timestamp, ethBlock, chainBlocks) => {
  return fetchMorChainTvl(
    timestamp,
    ethBlock,
    chainBlocks,
    "bsc",
    bscTokensProcessor
  );
};

const morAvaxTvl = (timestamp, ethBlock, chainBlocks) => {
  return fetchMorChainTvl(
    timestamp,
    ethBlock,
    chainBlocks,
    "avax",
    avaxTokensProcessor
  );
};

const morFTMTvl = (timestamp, ethBlock, chainBlocks) => {
  return fetchMorChainTvl(
    timestamp,
    ethBlock,
    chainBlocks,
    "fantom",
    ftmTokensProcessor
  );
};

const morFTMNonStkTvl = (timestamp, ethBlock, chainBlocks) => {
  return fetchMorNonStkChainTvl(
    timestamp,
    ethBlock,
    chainBlocks,
    "fantom",
    ftmTokensProcessor
  );
};

const clqdrStakeTvl = (timestamp, ethBlock, chainBlocks) => {
  return fetchCLQDRStaking(
    timestamp,
    ethBlock,
    chainBlocks,
    "fantom",
    ftmTokensProcessor
  );
};

const psmTVLMultipleFTM = (timestamp, ethBlock, chainBlocks) => {
  return fetchPSMMultiple(
    timestamp,
    ethBlock,
    chainBlocks,
    "fantom",
    ftmTokensProcessor
  );
};

const psmTVLMultipleAVAX = (timestamp, ethBlock, chainBlocks) => {
  return fetchPSMMultiple(
    timestamp,
    ethBlock,
    chainBlocks,
    "avax",
    ftmTokensProcessor
  );
};

const psmTVLSingleAVAX = (timestamp, ethBlock, chainBlocks) => {
  return fetchPSMSingle(
    timestamp,
    ethBlock,
    chainBlocks,
    "avax",
    ftmTokensProcessor
  );
};

const psmTVLSingleBSC = (timestamp, ethBlock, chainBlocks) => {
  return fetchPSMSingle(
    timestamp,
    ethBlock,
    chainBlocks,
    "bsc",
    ftmTokensProcessor
  );
};
module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: sdk.util.sumChainTvls([morBscTvl, psmTVLSingleBSC]),
  },
  avax: {
    tvl: sdk.util.sumChainTvls([
      morAvaxTvl,
      psmTVLMultipleAVAX,
      psmTVLSingleAVAX,
    ]),
  },
  fantom: {
    tvl: sdk.util.sumChainTvls([
      morFTMTvl,
      morFTMNonStkTvl,
      clqdrStakeTvl,
      psmTVLMultipleFTM,
    ]),
  },
  methodology:
    "We count liquidity on MOR through MasterChef and Staking Contracts",
};

'''
'''--- projects/gton.js ---
const sdk = require("@defillama/sdk");
const axios = require("axios");
const retry = require("./helper/retry");
const { transformFantomAddress } = require("./helper/portedTokens");
const { sumTokens } = require("./helper/unwrapLPs");

const gton = "0xC1Be9a4D5D45BeeACAE296a7BD5fADBfc14602C4".toLowerCase();
const stakingContract = "0xB0dAAb4eb0C23aFFaA5c9943d6f361b51479ac48";
const treasury = "0xB3D22267E7260ec6c3931d50D215ABa5Fd54506a";
const fantomToken = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'
const chain = 'fantom'

async function tvl(timestamp, _block, { fantom: block}) {
    const balances = {};

    let treasuryTokens = (
        await retry(
          async (bail) =>
            await axios.get(
              `https://api.covalenthq.com/v1/${250}/address/${treasury}/balances_v2/?&key=ckey_72cd3b74b4a048c9bc671f7c5a6`
            )
        )
      ).data.data.items.map((t) => t.contract_address);
    
    treasuryTokens = treasuryTokens.map(a => a.toLowerCase()).filter(a => a !== fantomToken).map(a => [a, treasury])

    const fantomBalance = (await sdk.api.eth.getBalance({ target: treasury, block, chain})).output
    sdk.util.sumSingleBalance(balances, 'fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83', fantomBalance)
    await sumTokens(balances, treasuryTokens, block, chain, undefined, { resolveLP: true })
    delete balances['fantom:'+gton];
    return balances;
};

async function staking(timestamp, block, chainBlocks) {
    const balances = {};
    const transform = await transformFantomAddress();

    const underlyingBalances = await sdk.api.abi.multiCall({
        target: gton,
        calls: [ stakingContract, treasury ].map(c => ({
            params: c
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks.fantom,
        chain: "fantom",
    });

    sdk.util.sumMultiBalanceOf(balances, underlyingBalances, true, transform);

    return balances;
};

module.exports = {
    fantom: {
        tvl,
        staking,
    }
};
'''
'''--- projects/gyro.js ---
const { ohmTvl } = require('./helper/ohm')

module.exports=ohmTvl("0x8B1522402FECe066d83E0F6C97024248Be3C8c01", [
    ["0x55d398326f99059ff775485246999027b3197955", false],
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false],
    ["0x5ca063a7e2bebefeb2bdea42158f5b825f0f9ffb", true],
    ["0xa5399084a5f06d308c4527517bbb781c4dce887c", true]
], "bsc", "0xe9c178cfdfeb917a46429714e5d51f6d4f296b75", "0x1b239abe619e74232c827fbe5e49a4c072bd869d")
'''
'''--- projects/gysr/index.js ---
const { request, gql } = require("graphql-request");
const sdk = require('@defillama/sdk');

const { toUSDTBalances } = require('../helper/balances');

const graphUrlMainnet = "https://api.thegraph.com/subgraphs/name/gysr-io/gysr";
const graphUrlPolygon = "https://api.thegraph.com/subgraphs/name/gysr-io/gysr-polygon";
const graphQuery = gql`
query GET_TVL($block: Int) {
  platform(id: "0x0000000000000000000000000000000000000000", block: { number: $block }) {
    tvl
  }
}
`;

async function ethereum(timestamp, block) {
  const { platform } = await request(
    graphUrlMainnet,
    graphQuery,
    {
      block
    }
  );

  // if block is before protocol launched platform will be null
  const tvl = platform ? platform.tvl : '0'

  return toUSDTBalances(tvl);
}

async function polygon(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks.polygon;
  const { platform } = await request(
    graphUrlPolygon,
    graphQuery,
    {
      block
    }
  );

  // if block is before protocol launched platform will be null
  const tvl = platform ? platform.tvl : '0'

  return toUSDTBalances(tvl);
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethereum
  },
  polygon: {
    tvl: polygon
  },
}

'''
'''--- projects/hades-money/index.js ---
const { staking } = require("../helper/staking");
const { pool2Exports } = require("../helper/pool2");

const hades = "0x88C37E0bc6a237e96bc4A82774A38BBc30efF3Cf";
const hellshare = "0xEfB15eF34f85632fd1D4C17FC130CcEe3D3D48aE";
const masonry = "0x686A9472B839e8601c81335D0B088b33082BC2f7";
const hellsharerewardpool = "0xcd66208ac05f75069C0f3a345ADf438FB3B53C1A";

const pool2LPs = [
    "0xCD1cc85DC7b4Deef34247CCB5d7C42A58039b1bA", //HELLSHARE-METIS
    "0x586f616Bb811F1b0dFa953FBF6DE3569e7919752" // HADES-METIS
]

module.exports = {
    metis: {
        tvl: async () => ({}),
        staking: staking(masonry, hellshare, "metis"),
        pool2: pool2Exports(hellsharerewardpool, pool2LPs, "metis")
    }
}
'''
'''--- projects/hadesswap/index.js ---
const sdk = require('@defillama/sdk');
const { getChainTvl } = require('../helper/getUniSubgraphTvl');

const chainTvl = getChainTvl({
    polis: 'https://graph.polis.tech/subgraphs/name/hadeswap/exchange',
}, "factories", "liquidityUSD")

module.exports = {
    timetravel: true,
    misrepresentedTokens: true,
    polis: {
        tvl: chainTvl('polis')
    },
}

'''
'''--- projects/hakka.js ---
const sdk = require("@defillama/sdk")
const utils = require('./helper/utils')
const abi = require("./config/hakka/abi.json")
const { default: BigNumber } = require("bignumber.js")
const WeiPerEther = 1e18

const HAKKA_ADDRESSES = {
  1: '0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd',
  56: '0x1d1eb8e8293222e1a29d2c0e4ce6c0acfd89aaac',
}
const thirdFloorAddress = '0x66be1bc6C6aF47900BBD4F3711801bE6C2c6CB32'

async function thirdFloor(price_feed) {
  const ethBalance = await utils.returnEthBalance(thirdFloorAddress);
  const ethPrice = price_feed.data.ethereum.usd
  const ethValue = BigNumber(ethBalance).times(ethPrice)
  
  return ethValue
}

async function getRewardPool2(price_feed) {
  const BHS_USDC_DAI_HAKKA_BPT = '0x1B8874BaceAAfba9eA194a625d12E8b270D77016'
  const BHS_USDC_DAI_HAKKA_POOL = '0x6EE6683Cb9b44810369C873679f8073bCBE52F27'
  const tokens = [
    {
      name: 'hakka-finance',
      address: '0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd',
    },
    {
      name: 'dai',
      address: '0x6B175474E89094C44Da98b954EedeAC495271d0F'
    },
    {
      name: 'usd-coin',
      address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
    },
    {
      name: 'blackholeswap-compound-dai-usdc',
      address: '0x35101c731b1548B5e48bb23F99eDBc2f5c341935'
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [BHS_USDC_DAI_HAKKA_BPT],
    })),
    abi: abi['balanceOf'],
  })
  const { output: bptSupply } = await sdk.api.abi.call({
    target: BHS_USDC_DAI_HAKKA_BPT,
    abi: abi['totalSupply'],
  })
  const { output: poolBpt } = await sdk.api.abi.call({
    target: BHS_USDC_DAI_HAKKA_BPT,
    params: [BHS_USDC_DAI_HAKKA_POOL],
    abi: abi['balanceOf'],
  })
  
  const tokenValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const pricePerBpt = tokenValue.reduce((a, c) => BigNumber(a).plus(c)).div(BigNumber(bptSupply))

  return pricePerBpt.times(poolBpt).div(WeiPerEther)
}

async function getRewardPool3(price_feed) {
  const BHS_HAKKA_BPT = '0xaE95D3198d602acFB18F9188d733d710e14A27Dd'
  const BHS_HAKKA_POOL = '0x3792ee68E736b8214D4eDC91b1B3340B525e00BF'
  const tokens = [
    {
      name: 'hakka-finance',
      address: '0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd',
    },
    {
      name: 'blackholeswap-compound-dai-usdc',
      address: '0x35101c731b1548B5e48bb23F99eDBc2f5c341935'
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [BHS_HAKKA_BPT],
    })),
    abi: abi['balanceOf'],
  })
  const { output: bptSupply } = await sdk.api.abi.call({
    target: BHS_HAKKA_BPT,
    abi: abi['totalSupply'],
  })
  const { output: poolBpt } = await sdk.api.abi.call({
    target: BHS_HAKKA_BPT,
    params: [BHS_HAKKA_POOL],
    abi: abi['balanceOf'],
  })
  
  const tokenValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const pricePerBpt = tokenValue.reduce((a, c) => BigNumber(a).plus(c)).div(BigNumber(bptSupply))

  return pricePerBpt.times(poolBpt).div(WeiPerEther)
}

async function rewards(price_feed) {
  const four = await getRewardPool2(price_feed)
  const half = await getRewardPool3(price_feed)
  const tvl = four.plus(half)
  
  return tvl
}

async function stakedHakka(price_feed) {
  const sHakka = '0xd9958826Bce875A75cc1789D5929459E6ff15040'

  const { output: hakkaBalance } = await sdk.api.abi.call({
    target: HAKKA_ADDRESSES[1],
    params: [sHakka],
    abi: abi['balanceOf'],
  })

  const hakkaPrice = price_feed.data['hakka-finance'].usd
  const hakkaBalanceBignum = BigNumber(hakkaBalance)
  const hakkaValue = hakkaBalanceBignum.times(hakkaPrice).div(WeiPerEther)
  
  return hakkaValue
}

async function intelligence(price_feed) {
  const ethAddress = ['0x0F2fd95c221770d108aCD5363D25b06Bdc43140B']
  const bscAddress = ['0xD8B3fF98025Cf203Ba6D7Bb2d25DBeEF9539E6FB', '0x517Ef6281a9b3dc4Ef6B0318Bc5EDFDCf677d29D', '0x0A3e364eE37bac9E6aFF9E864E65B4603D5BC5D4']
  const { output: ethTvl } = await sdk.api.abi.multiCall({
    calls: ethAddress.map((round) => ({
      target: HAKKA_ADDRESSES[1],
      params: [round],
    })),
    abi: abi['balanceOf'],
  })

  const { output: bscTvl } = await sdk.api.abi.multiCall({
    calls: bscAddress.map((round) => ({
      target: HAKKA_ADDRESSES[56],
      params: [round],
    })),
    abi: abi["balanceOf"],
    chain: 'bsc',
  })
  
  const ethTvlBignum = ethTvl.map((res) => BigNumber(res.output))
  const bscTvlBignum = bscTvl.map((res) => BigNumber(res.output))
  
  const hakkaPrice = price_feed.data['hakka-finance'].usd
  const totalHakka = [...ethTvlBignum, ...bscTvlBignum].reduce((accumulator, currentValue) => accumulator.plus(currentValue))
  const hakkaValue = totalHakka.times(hakkaPrice).div(WeiPerEther)
  
  return hakkaValue
}

async function guildBank(price_feed) {
  const hakkaGuildBank = '0x83D0D842e6DB3B020f384a2af11bD14787BEC8E7'
  const tokens = [
    {
      name: 'maker',
      address: '0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2',
    },
    {
      name: 'blackholeswap-compound-dai-usdc',
      address: '0x35101c731b1548B5e48bb23F99eDBc2f5c341935'
    },
    {
      name: 'usd-coin',
      address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [hakkaGuildBank],
    })),
    abi: abi['balanceOf'],
  })

  const ethBalance = await utils.returnEthBalance(hakkaGuildBank)
  const ethValue = BigNumber(ethBalance).times(price_feed.data.ethereum.usd)
  const tokenValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))

  const tvl = ethValue.plus(tokenValue.reduce((a, c) => BigNumber(a).plus(c)).div(WeiPerEther))
  
  return tvl
}

async function bscBlackHoleSwap(price_feed) {
  const BSC_BHS_ADDRESS = '0x75192D6f3d51554CC2eE7B40C3aAc5f97934ce7E'
  const tokens = [
    {
      name: 'binance-usd',
      address: '0xe9e7cea3dedca5984780bafc599bd69add087d56',
    },
    {
      name: 'tether',
      address: '0x55d398326f99059ff775485246999027b3197955'
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [BSC_BHS_ADDRESS],
    })),
    abi: abi['balanceOf'],
    chain: 'bsc',
  })

  const tokenValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const tvl = tokenValue.reduce((a, c) => BigNumber(a).plus(c)).div(WeiPerEther)

  return tvl
}

// Harvesters
const PANCAKE_STAKING_ADDRESS = '0x73feaa1eE314F8c655E354234017bE2193C9E24E'
const ALPACA_STAKING_ADDRESS = '0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F'
const BELT_STAKING_ADDRESS = '0xD4BbC80b9B102b77B21A06cb77E954049605E6c1'
const ALPACA_ADDRESS = '0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F'
const CAKE_ADDRESS = '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82'
const BUSD_ADDRESS = '0xe9e7cea3dedca5984780bafc599bd69add087d56'
const WBNB_ADDRESS = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'

const BSC_HARVEST_POOLS = [
  {
    // Pool 1
    name: 'BUSD-BNB Harvester',
    tokenAddress: '0x1b96b92314c44b159149f7e0303511fb2fc4774f',
    rewardsAddress: '0x6a3093dc9097fe54c02ffaeb64b6e3a52f4642c8',
    getTVL: pancake_BUSD_BNB_TVL,
  },
  {
    // Pool 2
    name: 'CAKE-BNB Harvester',
    tokenAddress: '0xA527a61703D82139F8a06Bc30097cC9CAA2df5A6',
    rewardsAddress: '0x3792ee68E736b8214D4eDC91b1B3340B525e00BF',
    getTVL: pancake_CAKE_BNB_TVL,
  },
  {
    // Pool 3
    name: 'Alpaca LP Harvester',
    tokenAddress: '0xf3ce6aac24980e6b657926dfc79502ae414d3083',
    rewardsAddress: '0xCb2131C9D1381c38282C006EAa56DE26BD99888E',
    getTVL: alpacaLP_TVL,
  },
  {
    // Pool 4
    name: 'Alpaca BNB Harvester',
    tokenAddress: '0xd7d069493685a581d27824fc46eda46b7efc0063',
    rewardsAddress: '0x992c0170e5f0352a8af39d95dc15fb5edced852c',
    getTVL: alpacaBNB_TVL,
  },
  {
    // Pool 5
    name: 'Alpaca BUSD Harvester',
    tokenAddress: '0x7c9e73d4c71dae564d41f78d56439bb4ba87592f',
    rewardsAddress: '0x4D5054708982e96F284D02c7a46F31d6f7291C56',
    getTVL: alpacaBUSD_TVL,
  },
  {
    // Pool 6
    name: 'Belt4 Harvester',
    tokenAddress: '0x86afa7ff694ab8c985b79733745662760e454169',
    rewardsAddress: '0x8ba1c31cb3c51889c5699fb8121e3c01dbc53b96',
    getTVL: belt4_TVL,
  },
]

async function pancake_BUSD_BNB_TVL( // 2
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const tokens = [
    {
      name: 'binance-usd',
      address: BUSD_ADDRESS,
    },
    {
      name: 'wbnb',
      address: WBNB_ADDRESS
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [tokenAddress],
    })),
    abi: abi['balanceOf'],
    chain: 'bsc',
  })
  const { output: lpTotalSupply } = await sdk.api.abi.call({
    target: tokenAddress,
    abi: abi['totalSupply'],
    chain: 'bsc',
  })
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: PANCAKE_STAKING_ADDRESS,
    params: [2, rewardsAddress],
    abi: abi['pancakeUserInfo'],
    chain: 'bsc',
  })
  
  const lpValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const pricePerLp = lpValue.reduce((a, c) => BigNumber(a).plus(c)).div(BigNumber(lpTotalSupply))
  const tvl = pricePerLp.times(rewardsBalance.amount).div(WeiPerEther)

  return tvl
}

async function pancake_CAKE_BNB_TVL( // 1
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const tokens = [
    {
      name: 'pancakeswap-token',
      address: CAKE_ADDRESS,
    },
    {
      name: 'wbnb',
      address: WBNB_ADDRESS
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [tokenAddress],
    })),
    abi: abi['balanceOf'],
    chain: 'bsc',
  })
  const { output: lpTotalSupply } = await sdk.api.abi.call({
    target: tokenAddress,
    abi: abi['totalSupply'],
    chain: 'bsc',
  })
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: PANCAKE_STAKING_ADDRESS,
    params: [1, rewardsAddress],
    abi: abi['pancakeUserInfo'],
    chain: 'bsc',
  })
  
  const lpValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const pricePerLp = lpValue.reduce((a, c) => BigNumber(a).plus(c)).div(BigNumber(lpTotalSupply))
  const tvl = pricePerLp.times(rewardsBalance.amount).div(WeiPerEther)

  return tvl
}

async function alpacaLP_TVL( // 4
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const tokens = [
    {
      name: 'alpaca-finance',
      address: ALPACA_ADDRESS,
    },
    {
      name: 'wbnb',
      address: WBNB_ADDRESS
    }
  ]

  const { output: tokenTvl } = await sdk.api.abi.multiCall({
    calls: tokens.map((token) => ({
      target: token.address,
      params: [tokenAddress],
    })),
    abi: abi['balanceOf'],
    chain: 'bsc',
  })
  const { output: lpTotalSupply } = await sdk.api.abi.call({
    target: tokenAddress,
    abi: abi['totalSupply'],
    chain: 'bsc',
  })
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: ALPACA_STAKING_ADDRESS,
    params: [4, rewardsAddress],
    abi: abi['alpacaUserInfo'],
    chain: 'bsc',
  })
  
  const lpValue = tokenTvl.map((res, index) => BigNumber(res.output).times(price_feed.data[tokens[index].name].usd))
  const pricePerLp = lpValue.reduce((a, c) => BigNumber(a).plus(c)).div(BigNumber(lpTotalSupply))
  const tvl = pricePerLp.times(rewardsBalance.amount).div(WeiPerEther)

  return tvl
}

async function alpacaBNB_TVL( // 1
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: ALPACA_STAKING_ADDRESS,
    params: [1, rewardsAddress],
    abi: abi['alpacaUserInfo'],
    chain: 'bsc',
  })
  
  const price = price_feed.data['wbnb'].usd
  const rewardsBalanceBignum = BigNumber(rewardsBalance.amount)
  const tvl = rewardsBalanceBignum.times(price).div(WeiPerEther)

  return tvl
}

async function alpacaBUSD_TVL( // 3
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: ALPACA_STAKING_ADDRESS,
    params: [3, rewardsAddress],
    abi: abi['alpacaUserInfo'],
    chain: 'bsc',
  })
  
  const price = price_feed.data['binance-usd'].usd
  const rewardsBalanceBignum = BigNumber(rewardsBalance.amount)
  const tvl = rewardsBalanceBignum.times(price).div(WeiPerEther)

  return tvl
}

async function belt4_TVL(
  tokenAddress,
  rewardsAddress,
  price_feed,
) {
  const { output: rewardsBalance } = await sdk.api.abi.call({
    target: BELT_STAKING_ADDRESS,
    params: [0, rewardsAddress],
    abi: abi['beltUserInfo'],
    chain: 'bsc',
  })

  const tvl = BigNumber(rewardsBalance.shares).div(WeiPerEther)

  return tvl
}

async function harvesters(price_feed) {
  const harvesterTvl = await Promise.all(
    BSC_HARVEST_POOLS.map((pool) =>
      pool.getTVL(
        pool.tokenAddress,
        pool.rewardsAddress,
        price_feed,
      ),
    ),
  )

  const harvesterTvlSum = harvesterTvl.reduce((accumulator, currentValue) => accumulator.plus(currentValue))
  return harvesterTvlSum
}

async function fetch() {
    const tokens = [
      'ethereum',
      'hakka-finance',
      'binancecoin',
      'binance-usd',
      'pancakeswap-token',
      'wbnb',
      'alpaca-finance',
      'maker',
      'blackholeswap-compound-dai-usdc',
      'dai',
      'usd-coin',
      'tether',
    ]
    const price_feed = await utils.getPricesfromString(tokens.toString());

    // Harvesters
    const harvesterTvl = await harvesters(price_feed)

    // Guild Bank
    const guildBankTvl = await guildBank(price_feed)

    // 3F
    const thirdFloorTvl = await thirdFloor(price_feed)

    // sHakka
    const sHakkaTvl = await stakedHakka(price_feed)

    // BHS on BSC
    const bscBhsTvl = await bscBlackHoleSwap(price_feed)

    // Hakka Intelligence
    const intelligenceTvl = await intelligence(price_feed)

    // Rewards without sHakka
    const rewardsTvl = await rewards(price_feed)

    const allData = {
      harvesterTvl: harvesterTvl,
      guildBankTvl: guildBankTvl,
      thirdFloorTvl: thirdFloorTvl,
      sHakkaTvl: sHakkaTvl,
      bscBhsTvl: bscBhsTvl,
      intelligenceTvl: intelligenceTvl,
      //rewardsTvl: rewardsTvl,
    }
    // console.log(allData)
    const tvl = Object.values(allData).reduce((a, c) => a.plus(c)).toFixed(0)
    return tvl
}

module.exports = {
  fetch
}

'''
'''--- projects/hakuswap/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { stakingUnknownPricedLP } = require("../helper/staking");

const FACTORY_ADDRESS = "0x2Db46fEB38C57a6621BCa4d97820e1fc1de40f41";
const HAKU_TOKEN_ADDRESS = "0x695Fa794d59106cEbd40ab5f5cA19F458c723829";
const XHAKU_ADDRESS = "0xa95C238B5a72f481f6Abd50f951F01891130b441";

async function avalancheTvl(timestamp, block, chainBlocks) {
  let balances = await calculateUniTvl(
    (addr) => `avax:${addr}`,
    chainBlocks.avax,
    "avax",
    FACTORY_ADDRESS,
    0,
    true
  );
  return balances;
}

module.exports = {
  avalanche: {
    tvl: avalancheTvl,
    staking: stakingUnknownPricedLP(XHAKU_ADDRESS, HAKU_TOKEN_ADDRESS, "avax", "0x7943Acd42c41a345841cB22Bd846794a22d8682d")
  },
  misrepresentedTokens: true,
  methodology: "TVL comes from the DEX liquidity pools, staking TVL is accounted as the haku on xHAKU pool(0xa95C238B5a72f481f6Abd50f951F01891130b441)",
};
'''
'''--- projects/halodao/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking.js");

const rnbwEthToken = "0xe94b97b6b43639e238c851a7e693f50033efd75c";
const rnbwEthPool = "0x47BE779De87de6580d0548cde80710a93c502405";

// Nothing in RNBW staking pool on polygon yet
const wrnbwPolyToken = "0x18e7bDB379928A651f093ef1bC328889b33A560c";
const wrnbwPolyPool = "0xc104e54803abA12f7a171a49DDC333Da39f47193";

// ETH Pool 2 pool RNBW-ETH
const rnbwUniPool = {
  lpToken: "0x3E8E036Ddfd310B0838d3CC881A9fa827778845D",
  token0: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  token1: "0xe94b97b6b43639e238c851a7e693f50033efd75c",
};

const ethPools = [
  {
    // USDC:XSGD
    lpToken: "0x64DCbDeb83e39f152B7Faf83E5E5673faCA0D42A",
    token0: "0x70e8de73ce538da2beed35d14187f6959a8eca96",
    token1: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  },
  {
    // USDC:TCAD
    lpToken: "0xE15E50fF9d52beC41D53d3173F2ed40834D455f4",
    token0: "0x00000100F2A2bd000715001920eB70D229700085",
    token1: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  },
  {
    // USDC:TAUD
    lpToken: "0x11816335DEe6763e2A7B6080b2b2980Eac7F85E4",
    token0: "0x00006100F7090010005F1bd7aE6122c3C2CF0090",
    token1: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  },
  {
    // USDC:TGBP
    lpToken: "0x2ED09E2961D72659E4002ba8C2BaDfedC7db19B7",
    token0: "0x00000000441378008ea67f4284a57932b1c000a5",
    token1: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  },
];

const polyPools = [
  {
    //xSGD:USDC
    lpToken: "0x8123C64D6607412C7Ac9E880f12245ef22558b14",
    token0: "0x769434dca303597c8fc4997bf3dab233e961eda2",
    token1: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
  },
  {
    //wTCAD:USDC
    lpToken: "0xaEad273bc7E17DD6951ceD3264B1dBa8A19114C2",
    token0: "0x6d3cC56DFC016151eE2613BdDe0e03Af9ba885CC",
    token1: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
  },
  {
    //wTAUD:USDC
    lpToken: "0x95AB308bE1e209eB6FfdD3279B5ea71D365AD30B",
    token0: "0xe4F7761b541668f88d04fe9F2E9DF10CA613aEf7",
    token1: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
  },
  {
    //wTGBP:USDC
    lpToken: "0xbF772a745533f6bAd97C58D2cb6B241eF7487242",
    token0: "0x81A123f10C78216d32F8655eb1A88B5E9A3e9f2F",
    token1: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
  },
];

//Converts Polygon tokens to ETH tokens cause CoinGecko
const tokenConvert = {
  "0x2791bca1f2de4661ed88a30c99a7a9449aa84174":
    "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
  "0x769434dca303597c8fc4997bf3dab233e961eda2":
    "0x70e8de73ce538da2beed35d14187f6959a8eca96", // xSGD
  "0x6d3cC56DFC016151eE2613BdDe0e03Af9ba885CC":
    "0x00000100F2A2bd000715001920eB70D229700085", // wTCAD
  "0xe4F7761b541668f88d04fe9F2E9DF10CA613aEf7":
    "0x00006100F7090010005F1bd7aE6122c3C2CF0090", // wTAUD
  "0x81A123f10C78216d32F8655eb1A88B5E9A3e9f2F":
    "0x00000000441378008ea67f4284a57932b1c000a5", // wTGBP
};

async function calcTvl(balances, pools, block, chain) {
  for (let i = 0; i < pools.length; i++) {
    let { output: balance } = await sdk.api.abi.multiCall({
      calls: [
        {
          target: pools[i].token0,
          params: pools[i].lpToken,
        },
        {
          target: pools[i].token1,
          params: pools[i].lpToken,
        },
      ],
      abi: "erc20:balanceOf",
      block: block,
      chain: chain,
    });
    let tokens = [pools[i].token0, pools[i].token1];
    for (let j = 0; j < tokens.length; j++) {
      if (tokens[j] in tokenConvert) {
        tokens[j] = tokenConvert[tokens[j]];
      }
    }

    sdk.util.sumSingleBalance(balances, tokens[0], balance[0].output);
    sdk.util.sumSingleBalance(balances, tokens[1], balance[1].output);
  }
}

async function ethTvl(timestamp, block) {
  let balances = {};
  await calcTvl(balances, ethPools, block, "ethereum");
  return balances;
}

async function ethPool2(timestamp, block) {
  let balances = {};
  await calcTvl(balances, [rnbwUniPool], block, "ethereum");
  return balances;
}

async function polygonTvl(timestamp, block, chainBlocks) {
  let balances = {};
  await calcTvl(balances, polyPools, chainBlocks.polygon, "polygon");
  return balances;
}

module.exports = {
  ethereum: {
    tvl: ethTvl,
    staking: staking(rnbwEthPool, rnbwEthToken),
    pool2: ethPool2,
  },
  polygon: {
    tvl: polygonTvl,
    staking: staking(wrnbwPolyPool, wrnbwPolyToken, "polygon"),
  },
};

'''
'''--- projects/handlefi/abi.json ---
{
  "rari_dir.pools":{
     "inputs":[
        {
           "internalType":"uint256",
           "name":"",
           "type":"uint256"
        }
     ],
     "name":"pools",
     "outputs":[
        {
           "internalType":"string",
           "name":"name",
           "type":"string"
        },
        {
           "internalType":"address",
           "name":"creator",
           "type":"address"
        },
        {
           "internalType":"address",
           "name":"comptroller",
           "type":"address"
        },
        {
           "internalType":"uint256",
           "name":"blockPosted",
           "type":"uint256"
        },
        {
           "internalType":"uint256",
           "name":"timestampPosted",
           "type":"uint256"
        }
     ],
     "stateMutability":"view",
     "type":"function"
  },
  "comptroller.getAllMarkets":{
     "constant":true,
     "inputs":[
        
     ],
     "name":"getAllMarkets",
     "outputs":[
        {
           "internalType":"contract CToken[]",
           "name":"",
           "type":"address[]"
        }
     ],
     "payable":false,
     "stateMutability":"view",
     "type":"function"
  },
  "comptroller.underlying":{
     "constant":true,
     "inputs":[
        
     ],
     "name":"underlying",
     "outputs":[
        {
           "internalType":"address",
           "name":"",
           "type":"address"
        }
     ],
     "payable":false,
     "stateMutability":"view",
     "type":"function",
     "signature":"0x6f307dc3"
  },
  "comptroller.getCash":{
     "constant":true,
     "inputs":[
        
     ],
     "name":"getCash",
     "outputs":[
        {
           "internalType":"uint256",
           "name":"",
           "type":"uint256"
        }
     ],
     "payable":false,
     "stateMutability":"view",
     "type":"function",
     "signature":"0x3b1d21a2"
  }
}
'''
'''--- projects/handlefi/index.js ---
const sdk = require("@defillama/sdk")
const BigNumber = require("bignumber.js")
const { sumTokens, unwrapUniswapLPs } = require("../helper/unwrapLPs")
const {pool2 } = require("../helper/pool2")
const { getBlock } = require("../helper/getBlock")
const abi = require("./abi.json");

// Arbitrum TVL
const transformArbitrumAddress = addr => `arbitrum:${addr}`
const treasuryContract = "0x5710B75A0aA37f4Da939A61bb53c519296627994"
const WETH_arbitrum = "0x82af49447d8a07e3bd95bd0d56f35241523fbab1"
const FOREX_arbitrum = "0xDb298285FE4C5410B05390cA80e8Fbe9DE1F259B"
const treasuryTokens = [WETH_arbitrum,FOREX_arbitrum]
const perpsVault = "0x1785e8491e7e9d771b2A6E9E389c25265F06326A"
// Arbitrum Staking 
const WETH_FOREX_sushi_LP = '0x9745e5cc0522827958ee3fc2c03247276d359186'
const LP_staking_contract = '0x5cdeb8ff5fd3a3361e27e491696515f1d119537a'
// Eth-mainnet TVL 
const fuse_pool_directory = '0x835482FE0532f169024d5E9410199369aAD5C77E'
const fuse_pool_ids = [72, 116]
const fxTokens = {
  aud: "0x7E141940932E3D13bfa54B224cb4a16510519308",
  eur: "0x116172B2482c5dC3E6f445C16Ac13367aC3FCd35",
  php: "0x3d147cD9aC957B2a5F968dE9d1c6B9d0872286a0",
}

// Arbitrum TVL: Retrieve tokens stored in treasury contract - only weth at the moment
// https://arbiscan.io/address/0x5710B75A0aA37f4Da939A61bb53c519296627994
async function arbitrum_tvl(timestamp, ethBlock, chainBlocks, chain) {
  const block = await getBlock(timestamp, "arbitrum", chainBlocks)
  const balances = {}
  await sumTokens(
    balances,
    treasuryTokens.map(t => [t, treasuryContract]),
    block,
    "arbitrum",
    transformArbitrumAddress
  )
  return balances
}

// Eth-mainnet TVL is locked in RariCapital Fuse pool #72 and #116
async function ethereum_tvl(timestamp, ethBlock, chainBlocks) {
  const balances = {}  

  for (const fuse_pool_id of fuse_pool_ids) {
    // Get pool 72 or 116 metadata from onchain call
    const {output: pool} = await sdk.api.abi.call({
      target: fuse_pool_directory, 
      params: fuse_pool_id,
      abi: abi['rari_dir.pools'],
      block: ethBlock,
      chain: 'ethereum'
    })
    const fuse_comptroller = pool.comptroller 
    
    // Get markets from comptroller
    const {output: markets} = await sdk.api.abi.call({
      target: fuse_comptroller, 
      abi: abi['comptroller.getAllMarkets'],
      block: ethBlock,
      chain: 'ethereum'
    })

    // Get markets balances of underlying
    const [ {output: underlying},  {output: balance}] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: markets.map(m => ({ target: m })),
        abi: abi['comptroller.underlying'],
        block: ethBlock,
        chain: "ethereum",
      }),
      sdk.api.abi.multiCall({
        calls: markets.map(m => ({ target: m })),
        abi: abi['comptroller.getCash'],
        block: ethBlock,
        chain: "ethereum",
      }),
    ])
    //console.log(`Rari Fuse pool #${fuse_pool_id}: balances of underlying of comptroller markets`, underlying.map((t, i) => t.output + ': ' + balance[i].output))

    underlying.forEach((t, i) => {
      balances[t.output] = (new BigNumber(balances[t.output] || "0").plus(new BigNumber(balance[i].output)) ).toString(10)
    })
  }

  // Set to zero balance of fxTokens, which are not collateral but are backed by the other assets of rari pools
  for (const [key, value] of Object.entries(fxTokens)) {
    delete balances[value];
  }
  return balances
}

module.exports = {
  arbitrum: {
    tvl: arbitrum_tvl,
    pool2: pool2(LP_staking_contract, WETH_FOREX_sushi_LP, "arbitrum")
  },
  ethereum: {
    tvl: ethereum_tvl,
  },
  methodology: `TVL on arbitrum is sum of all collateralTokens (weth only atm) provided in vaults to mint any fxTokens on arbitrum. TVL on mainnet is given by collateral provided to Rari Fuse pools #72 and #116 against WETH, FEI, DAI, USDC, USDT, FRAX for now.`,
}

'''
'''--- projects/hard.js ---
const retry = require('./helper/retry')
const axios = require("axios");

const KAVA_DENOM = "ukava";
const HARD_DENOM = "hard";
const USDX_DENOM = "usdx";
const BNB_DENOM = "bnb";
const BTC_DENOM = "btcb";
const BUSD_DENOM = "busd";
const XRPB_DENOM = "xrpb";
const ATOM_DENOM = "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2"
const AKT_DENOM = "ibc/799FDD409719A1122586A629AE8FCA17380351A51C1F47A80A1B8E7F2A491098"
const coingeckoIds = {
    [KAVA_DENOM]: 'kava',
    [HARD_DENOM]:'kava-lend',
    [USDX_DENOM]:'usdx',
    [BNB_DENOM]:'binancecoin',
    [BTC_DENOM]:'bitcoin',
    [BUSD_DENOM]:'binance-usd',
    [XRPB_DENOM]:'ripple',
    [ATOM_DENOM]:'cosmos',
    [AKT_DENOM]:'akash-network'
}
const decimals = {
    [KAVA_DENOM]: 6,
    [HARD_DENOM]:6,
    [USDX_DENOM]:6,
    [BNB_DENOM]:8,
    [BTC_DENOM]:8,
    [BUSD_DENOM]:8,
    [XRPB_DENOM]:8,
    [ATOM_DENOM]:6,
    [AKT_DENOM]:6
}

var tvl = async () => {
    const balances = {}
    const totalDeposited = await retry(async bail => await axios.get('https://api2.kava.io/hard/total-deposited'))
    const totalBorrowed = await retry(async bail => await axios.get('https://api2.kava.io/hard/total-borrowed'))
    for(const coin of totalDeposited.data.result){
        const borrowed = Number(totalBorrowed.data.result.find(item=>item.denom === coin.denom)?.amount || 0);
        balances[coingeckoIds[coin.denom]]=(Number(coin.amount)-borrowed)/(10**decimals[coin.denom]);
    }
    return balances;
}

var borrowed = async () => {
    const balances = {}
    const totalBorrowed = await retry(async bail => await axios.get('https://api2.kava.io/hard/total-borrowed'))
    for(const coin of totalBorrowed.data.result){
        balances[coingeckoIds[coin.denom]]=Number(coin.amount)/(10**decimals[coin.denom]);
    }
    return balances;
}

module.exports = {
    timetravel: false,
    kava:{
        tvl,
        borrowed
    }
}

'''
'''--- projects/harvest.js ---
const utils = require('./helper/utils');
const {fetchChainExports} = require('./helper/exports');

// historical tvl on https://ethparser-api.herokuapp.com/api/transactions/history/alltvl?network=eth
const endpoint = "https://api-ui.harvest.finance/vaults?key=41e90ced-d559-4433-b390-af424fdc76d6"
const chains = {
  ethereum: 'eth',
  bsc: 'bsc',
  polygon: 'matic'
}

function fetchChain(chainRaw) {
  const chain = chains[chainRaw]
  return async () => {
    var tvl = 0;
    var staked = await utils.fetchURL(endpoint)
    Object.values(staked.data[chain]).map(async item => {
      const poolTvl = parseFloat(item.totalValueLocked ?? 0)
      tvl += poolTvl
    })
    return tvl;
  }
}

module.exports = fetchChainExports(fetchChain, Object.keys(chains))

'''
'''--- projects/hashflow/dataCache.json ---
{
  "ethereum": [
    {
      "pool": "0xb6260b8b0bcdcbb7a57f86b074a7e03a095106f0",
      "tokens": [
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "0x6b175474e89094c44da98b954eedeac495271d0f",
        "0x0000000000000000000000000000000000000000",
        "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
      ]
    },
    {
      "pool": "0xd0cd2141774c2b0f86858a63e8b83b41bdc77a57",
      "tokens": [
        "0x6b175474e89094c44da98b954eedeac495271d0f",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "0xdac17f958d2ee523a2206206994597c13d831ec7"
      ]
    },
    {
      "pool": "0x3c5ca94857639970ef9cee60e4456719a78960ee",
      "tokens": [
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "0xa47c8bf37f92abed4a126bda807a7b7498661acd",
        "0x853d955acef822db058eb8505911ed77f175b99e",
        "0xdac17f958d2ee523a2206206994597c13d831ec7"
      ]
    },
    {
      "pool": "0xe8a8700fafd46cbe81aa983d180fe2ee89d3e401",
      "tokens": [
        "0x6b175474e89094c44da98b954eedeac495271d0f",
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "0x2a8e1e676ec238d8a992307b495b45b3feaa5e86"
      ]
    },
    {
      "pool": "0xcc5ab3f04704620d6f20a0cf2e772d6a81f42c4b",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "0x6b175474e89094c44da98b954eedeac495271d0f",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
      ]
    },
    {
      "pool": "0xfe895436dbbdf64930c4480136f851e41d7db948",
      "tokens": [
        "0x5faa989af96af85384b8a938c2ede4a7378d9875",
        "0xdac17f958d2ee523a2206206994597c13d831ec7"
      ]
    },
    {
      "pool": "0x7d9af957bb728595a9d2405b33b03f7282e91899",
      "tokens": []
    },
    {
      "pool": "0xe794ffecc16a8e5f5c7d7818322ba7fe41a63f72",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
      ]
    }
  ],
  "polygon": [
    {
      "pool": "0x2ad89af11955ac2627f0a112f017d50536d75cfe",
      "tokens": []
    },
    {
      "pool": "0x5b0e634823ac8490a4bc22040d6e42ce38808672",
      "tokens": []
    },
    {
      "pool": "0x012566234e737f3c8aaa892be36100240e952345",
      "tokens": [
        "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
        "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        "0x0000000000000000000000000000000000000000",
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174"
      ]
    },
    {
      "pool": "0xdb654136fd25246736872c3a4c751075e7a3f79a",
      "tokens": [
        "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174"
      ]
    },
    {
      "pool": "0xb959416953dd179c7a4b1a464673625ae5a87845",
      "tokens": []
    },
    {
      "pool": "0xdfe0295618c385375dd14ede49328bf4c9653a65",
      "tokens": [
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
        "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063"
      ]
    },
    {
      "pool": "0x84ea0b90566eec9bc4509ae1a67cd6cc94242c6f",
      "tokens": [
        "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
        "0x0000000000000000000000000000000000000000",
        "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f"
      ]
    },
    {
      "pool": "0x42e5f7a008bc628bb947b74eb5c0724dc6dc5134",
      "tokens": []
    }
  ],
  "bsc": [
    {
      "pool": "0xd120e9d5c839e4ed6e8a0caa2ad4bf406594bccb",
      "tokens": [
        "0x55d398326f99059ff775485246999027b3197955",
        "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
        "0xe9e7cea3dedca5984780bafc599bd69add087d56"
      ]
    },
    {
      "pool": "0x80c31eb5024ab5730a1d18a0ac5766181fefe39e",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0x55d398326f99059ff775485246999027b3197955",
        "0xe9e7cea3dedca5984780bafc599bd69add087d56"
      ]
    },
    {
      "pool": "0xab57578b5e86234999897eb0be2ac22c9b4d01dc",
      "tokens": []
    },
    {
      "pool": "0x64b4fa6761e8bf60e68fe8c5c97f96ad28f1956d",
      "tokens": [
        "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "0x55d398326f99059ff775485246999027b3197955",
        "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d"
      ]
    },
    {
      "pool": "0xef763609e773a911a897a93e29c4aefb2bf40221",
      "tokens": []
    },
    {
      "pool": "0x22d17be4d4fad3034ad23a9dece4ea5fdf8ba66b",
      "tokens": [
        "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        "0x55d398326f99059ff775485246999027b3197955",
        "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
        "0x0000000000000000000000000000000000000000"
      ]
    }
  ],
  "arbitrum": [
    {
      "pool": "0xbfaabce766c86d9c5d70d2cb9d10bab6729197e5",
      "tokens": [
        "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"
      ]
    },
    {
      "pool": "0x46c0fe865545353311d61e247201a1de3ca0e62e",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"
      ]
    },
    {
      "pool": "0x1e91011bf7caf4942f199236227ba4858ae389f6",
      "tokens": [
        "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"
      ]
    }
  ],
  "avax": [
    {
      "pool": "0xe75abd1e50ee369b3bef03dfd5e6e4e8ef2f4731",
      "tokens": []
    },
    {
      "pool": "0xae3a27de3646be3860776c7e38a2b724a945c86f",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0xc7198437980c041c805a1edcba50c1ce5db95118"
      ]
    },
    {
      "pool": "0x27a1c0e072a6b5f972a392ec061858e5bc9c8ec0",
      "tokens": []
    },
    {
      "pool": "0x76856360104c3171e25cffa6d8cc2b3a6c467fd9",
      "tokens": [
        "0x0000000000000000000000000000000000000000",
        "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
        "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
        "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e",
        "0xc7198437980c041c805a1edcba50c1ce5db95118"
      ]
    },
    {
      "pool": "0x8ce05b3d9024cb901ea1d0ff95c1a678391ee93e",
      "tokens": []
    },
    {
      "pool": "0x52c3cac381faf7ac75a37fa9be6112a38402f984",
      "tokens": [
        "0xc7198437980c041c805a1edcba50c1ce5db95118",
        "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
        "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
        "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e"
      ]
    },
    {
      "pool": "0xc0d76d179e6a50bc2b91f64eae6e5c7f2d931107",
      "tokens": [
        "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
        "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
        "0xc7198437980c041c805a1edcba50c1ce5db95118",
        "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e"
      ]
    }
  ]
}
'''
'''--- projects/hashflow/index.js ---
const axios = require("axios");
const retry = require('../helper/retry');
const { chainExports } = require('../helper/exports');
const { sumTokens } = require("../helper/unwrapLPs");
let dataCache = require('./dataCache.json')

const chainIds = {
  ethereum: 1,
  polygon: 137,
  bsc: 56,
  arbitrum: 42161,
  avax: 43114
}

let dataCacheUpdating

async function updateDataCache() {

  const http_api_url = 'https://api.hashflow.com/internal/pool/getPools';
  const null_addr = '0x0000000000000000000000000000000000000000';
  const allChainData = {}

  for (const chain of Object.keys(chainIds)) {
    const chainId = chainIds[chain]
    const url = `${http_api_url}?networkId=${chainId}&lp=${null_addr}`
    const pools_response = (await retry(async () => await axios.get(url))).data
    allChainData[chain] = pools_response.pools.map(pool =>
    ({
      pool: pool.pool,
      tokens: pool.tokens.map(t => t.token.address)
    })
    )
  }

  require('fs').writeFileSync(__dirname + '/dataCache.json', JSON.stringify(allChainData, null, 2))
  dataCache = allChainData
}

function chainTvl(chain) {
  return async (timestamp, ethBlock, { [chain]: block }) => {
    // if (!dataCacheUpdating) dataCacheUpdating = updateDataCache()
    // await dataCacheUpdating

    const pools = dataCache[chain]
    const tokensAndOwners = pools.map(p => p.tokens.map(t => [t, p.pool])).flat()
    return sumTokens({}, tokensAndOwners, block, chain);
  }
}

module.exports = chainExports(chainTvl, Object.keys(chainIds)),
  module.exports.methodology = 'Hashflow TVL is made of all pools token balances. Pools and their tokens are retrieved by Hashflow HTTP REST API.'
module.exports.broken = 'Server IP is blocked, so api call fails'
'''
'''--- projects/hbtc.js ---
const sdk = require('@defillama/sdk')

async function tvl(ts, block) {
  return {
    '0x0316EB71485b0Ab14103307bf65a021042c6d380': (await sdk.api.erc20.totalSupply({ target: '0x0316EB71485b0Ab14103307bf65a021042c6d380', block })).output
  }
}

module.exports = {
  ethereum: { tvl }
}

'''
'''--- projects/hebeswap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

module.exports={
    timetravel: true,
    misrepresentedTokens: true,
    methodology: "Factory address (0x09fafa5eecbc11C3e5d30369e51B7D9aab2f3F53) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    ethereumclassic: {
        tvl:calculateUsdUniTvl("0x09fafa5eecbc11C3e5d30369e51B7D9aab2f3F53", "ethereumclassic", "0x82A618305706B14e7bcf2592D4B9324A366b6dAd", ["0x88d8C3Dc6B5324f34E8Cf229a93E197048671abD"
        ], "ethereum-classic")
    }
}
'''
'''--- projects/hector/abi.json ---
{
  "userInfo": {
    "inputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "userInfo",
    "outputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" },
      {
        "internalType": "uint256",
        "name": "boostMultiplier",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "want": {
    "inputs": [],
    "name": "want",
    "outputs": [
      { "internalType": "contract IERC20", "name": "", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "lpToken",
    "outputs": [
      { "internalType": "contract IBEP20", "name": "", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "poolInfo",
    "outputs": [
      { "internalType": "address", "name": "lptoken", "type": "address" },
      { "internalType": "address", "name": "token", "type": "address" },
      { "internalType": "address", "name": "gauge", "type": "address" },
      { "internalType": "address", "name": "crvRewards", "type": "address" },
      { "internalType": "address", "name": "stash", "type": "address" },
      { "internalType": "bool", "name": "shutdown", "type": "bool" }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/hector/contracts.json ---
{
  "tokenHolders": {
    "ethereum": [
      {
        "address": "0x4bfb33d65f4167ebe190145939479227e7bf2cb0",
        "chain": "ethereum"
      },
      {
        "address": "0x8a43e670619973944cb573bb23688c24cc0b5131",
        "chain": "ethereum"
      }
    ],
    "fantom": [
      {
        "address": "0xcb54ea94191b280c296e6ff0e37c7e76ad42dc6a",
        "chain": "fantom"
      },
      {
        "address": "0x677d6ec74fa352d4ef9b1886f6155384acd70d90",
        "chain": "fantom"
      },
      {
        "address": "0x8a43e670619973944cb573bb23688c24cc0b5131",
        "chain": "fantom"
      },
      {
        "address": "0xbe4b73f5caff476ed0cdb4c043236fce81f4dc6c",
        "chain": "fantom"
      },
      {
        "address": "0x35796ce4ed757075d346c1bc374d67628fadcbb1",
        "chain": "fantom"
      }
    ],
    "bsc": [
      {
        "address": "0x3cdf52cc28d21c5b7b91d7065fd6dfe6d426fcc5",
        "chain": "bsc"
      },
      {
        "address": "0x8a43e670619973944cb573bb23688c24cc0b5131",
        "chain": "bsc"
      }
    ]
  },
  "chainMap": {
    "ethereum": {
      "chainId": 1,
      "gasToken": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      "wrappedGasToken": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
    },
    "fantom": {
      "chainId": 250,
      "gasToken": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      "wrappedGasToken": "fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83"
    },
    "bsc": {
      "chainId": 56,
      "gasToken": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      "wrappedGasToken": "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
    }
  },
  "uniLPs": {
    "fantom": [
      "0xbc0eecda2d8141e3a26d2535c57cadcb1095bca9",
      "0x41d88635029c4402bf9914782ae55c412f8f2142"
    ]
  },
  "curveLPs": {
    "fantom": ["0x24699312cb27c26cfc669459d670559e5e44ee60"],
    "ethereum": [
      "0x3a283d9c08e8b55966afb64c515f5143cf907611",
      "0xed4064f376cb8d68f770fb1ff088a3d0f3ff5c4d"
    ]
  }
}

'''
'''--- projects/hector/index.js ---
const axios = require("axios");
const sdk = require("@defillama/sdk");
const { GraphQLClient, gql } = require("graphql-request");
const {
  sumMultiBalanceOf,
  sumSingleBalance
} = require("@defillama/sdk/build/generalUtil");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const { default: BigNumber } = require("bignumber.js");
const { toUSDTBalances } = require("../helper/balances");
const retry = require("async-retry");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { unwrapCrv } = require("../helper/resolveCrvTokens");
const abi = require("./abi.json");
const { genericUnwrapCvx } = require("../helper/unwrapLPs");

async function walletBalances(chain, block, balances, transform) {
  const response = (await Promise.all(
    contracts.tokenHolders[chain].map(c =>
      axios.get(
        `https://api.covalenthq.com/v1/${contracts.chainMap[c.chain]
          .chainId}/address/${c.address}/balances_v2/?&key=ckey_72cd3b74b4a048c9bc671f7c5a6`
      )
    )
  )).map(a => a.data.data.items);

  const calls = [];
  response.map((c, i) => {
    calls.push(
      ...c.map(t => ({
        target: t.contract_address,
        params: [contracts.tokenHolders[chain][i].address]
      }))
    );
  });

  const [gasBalances, erc20Balances] = await Promise.all([
    sdk.api.eth.getBalances({
      targets: calls
        .filter(c => c.target == contracts.chainMap[chain].gasToken)
        .map(c => c.params[0]),
      block,
      chain
    }),
    sdk.api.abi.multiCall({
      abi: "erc20:balanceOf",
      calls: calls.filter(c => c.target != contracts.chainMap[chain].gasToken),
      block,
      chain
    })
  ]);

  sumMultiBalanceOf(balances, erc20Balances, true, transform);
  sumSingleBalance(
    balances,
    contracts.chainMap[chain].wrappedGasToken,
    gasBalances.output
      .reduce((a, b) => a.plus(new BigNumber(b.balance)), new BigNumber("0"))
      .toFixed(0)
  );
}
async function deployedBalances(chain, block, balances, transform) {
  switch (chain) {
    case "bsc":
      await getPancakeDeposits(
        chain,
        block,
        "0xa5f8c5dbd5f286960b9d90548680ae5ebff07652",
        [2, 4, 14],
        "0x3cdf52cc28d21c5b7b91d7065fd6dfe6d426fcc5",
        balances,
        transform
      );
      return;
    case "fantom":
      await getBeefyDeposits(
        chain,
        block,
        [
          "0x8b92de822b121761a3caf894627a09a9f87864c0",
          "0xf723ae5478b1f03ca88c204f1ae5498d3576b78f"
        ],
        balances
      );
      return;
    case "ethereum":
      await getConvexDeposits(
        chain,
        block,
        "0xf403c135812408bfbe8713b5a23a04b3d48aae31",
        [61, 64],
        "0x4bfb33d65f4167ebe190145939479227e7bf2cb0",
        balances
      );
      return;
  }
}
async function getBeefyDeposits(chain, block, targets, balances) {
  const wants = (await sdk.api.abi.multiCall({
    calls: targets.map(t => ({
      target: t
    })),
    block,
    abi: abi.want,
    chain
  })).output;

  wants.map(t => {
    balances[`${chain}:${t.output.toLowerCase()}`] =
      balances[`${chain}:${t.input.target}`];
    delete balances[`${chain}:${t.input.target}`];
  });
}
async function getConvexDeposits(
  chain,
  block,
  target,
  poolIds,
  owner,
  balances
) {
  let poolInfos = (await sdk.api.abi.multiCall({
    abi: abi.poolInfo,
    target,
    calls: poolIds.map(i => ({
      params: [i]
    })),
    chain,
    block
  })).output;

  for (let i = 0; i < poolInfos.length; i++) {
    await genericUnwrapCvx(
      balances,
      owner,
      poolInfos[i].output.crvRewards,
      block,
      chain
    );
  }
}
async function getPancakeDeposits(
  chain,
  block,
  target,
  poolIds,
  owner,
  balances,
  transform
) {
  const [{ output: balance }, { output: lpToken }] = await Promise.all([
    sdk.api.abi.multiCall({
      abi: abi.userInfo,
      target,
      calls: poolIds.map(i => ({
        params: [i, owner]
      })),
      chain,
      block
    }),
    sdk.api.abi.multiCall({
      abi: abi.lpToken,
      target,
      calls: poolIds.map(i => ({
        params: [i]
      })),
      chain,
      block
    })
  ]);

  lpToken.map((t, i) => {
    sumSingleBalance(balances, transform(t.output), balance[i].output.amount);
  });
}
async function hectorBank() {
  var endpoint =
    "https://api.thegraph.com/subgraphs/name/hectordao-hec/hector-dao";
  var graphQLClient = new GraphQLClient(endpoint);

  var query = gql`
    query {
      protocolMetrics(first: 1, orderBy: timestamp, orderDirection: desc) {
        bankSupplied
      }
    }
  `;
  const results = await retry(async bail => await graphQLClient.request(query));
  const balance = +results.protocolMetrics[0].bankSupplied - (await borrowed());
  return toUSDTBalances(balance);
}
async function borrowed() {
  var endpoint =
    "https://api.thegraph.com/subgraphs/name/hectordao-hec/hector-dao";
  var graphQLClient = new GraphQLClient(endpoint);

  var query = gql`
    query {
      protocolMetrics(first: 1, orderBy: timestamp, orderDirection: desc) {
        bankBorrowed
      }
    }
  `;
  const results = await retry(async bail => await graphQLClient.request(query));

  return results.protocolMetrics[0].bankBorrowed;
}
async function unwrap(balances, chain, block, transform) {
  if (chain in contracts.uniLPs) {
    await unwrapUniswapLPs(
      balances,
      contracts.uniLPs[chain].map(l => ({
        balance: balances[`${chain}:${l}`],
        token: l
      })),
      block,
      chain,
      transform
    );
  }

  if (chain in contracts.curveLPs) {
    for (let token of contracts.curveLPs[chain]) {
      await unwrapCrv(
        balances,
        token,
        balances[`${chain}:${token}`],
        block,
        chain,
        transform
      );
    }
  }
}
function tvl(chain) {
  return async (t, b, chainBlocks) => {
    let balances = {};
    const block = chainBlocks[chain];
    const transform = await getChainTransform(chain);

    await walletBalances(chain, block, balances, transform);
    await deployedBalances(chain, block, balances, transform);
    await unwrap(balances, chain, block, transform);

    delete balances["fantom:0x74e23df9110aa9ea0b6ff2faee01e740ca1c642e"];
    delete balances["bsc:0x1d6cbdc6b29c6afbae65444a1f65ba9252b8ca83"];
    delete balances["fantom:0x5c4fdfc5233f935f20d2adba572f770c2e377ab0"];
    delete balances["bsc:0x638eebe886b0e9e7c6929e69490064a6c94d204d"];

    return balances;
  };
}
const staking = async () => {
  var endpoint =
    "https://api.thegraph.com/subgraphs/name/hectordao-hec/hector-dao";
  var graphQLClient = new GraphQLClient(endpoint);

  var query = gql`
    query {
      protocolMetrics(first: 1, orderBy: timestamp, orderDirection: desc) {
        totalValueLocked
      }
    }
  `;
  const results = await retry(async bail => await graphQLClient.request(query));
  return toUSDTBalances(+results.protocolMetrics[0].totalValueLocked);
};
module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  ethereum: {
    tvl: tvl("ethereum")
  },
  fantom: {
    tvl: sdk.util.sumChainTvls([tvl("fantom"), hectorBank]),
    staking
  },
  bsc: {
    tvl: tvl("bsc")
  }
};

'''
'''--- projects/hegic/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokens } = require('../helper/unwrapLPs')

const poolsV8888 = {
    ETH_CALL: "0xb9ed94c6d594b2517c4296e24A8c517FF133fb6d",
    ETH_PUT: "0x790e96E7452c3c2200bbCAA58a468256d482DD8b",
    WBTC_CALL: "0xfA77f713901a840B3DF8F2Eb093d95fAC61B215A",
    WBTC_PUT: "0x7A42A60F8bA4843fEeA1bD4f08450D2053cC1ab6"
};

const tokens = {
    ETH: "0x0000000000000000000000000000000000000000",
    WBTC: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
    WETH: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    USDC: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
};

async function ethTvl(_timestamp, ethBlock) {
    const ethV1 = (await sdk.api.eth.getBalance({
        target: '0x878f15ffc8b894a1ba7647c7176e4c01f74e140b',
        block: ethBlock,
    })).output;
    const btcV1 = (await sdk.api.erc20.balanceOf({
        target: tokens.WBTC,
        owner: '0x20DD9e22d22dd0a6ef74a520cb08303B5faD5dE7',
        block: ethBlock,
    })).output;

    const balances = {
        '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': btcV1,
        '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': ethV1,
    }

    // V2
    await sumTokens(balances, [
        [tokens.WBTC, poolsV8888.WBTC_CALL],
        [tokens.USDC, poolsV8888.WBTC_PUT],
        [tokens.USDC, poolsV8888.ETH_PUT],
        [tokens.WETH, poolsV8888.ETH_CALL]
    ], ethBlock)

    return balances
};

async function arbiTvl(timestamp, block, chainBlocks) {
    const balances = {};
    const tokenHolders = [
        '0xB0F9F032158510cd4a926F9263Abc86bAF7b4Ab3',
        '0x60898dfA3C6e8Ba4998B5f3be25Fb0b0b69d5D5d'
    ];
    const USDC = '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8';

    const usdcBalances = await sdk.api.abi.multiCall({
          calls: tokenHolders.map(t => ({
              target: USDC,
              params: t
          })),
          abi: 'erc20:balanceOf',
          block: chainBlocks.arbitrum,
          chain: 'arbitrum'
        })

    sdk.util.sumMultiBalanceOf(
        balances, 
        usdcBalances, 
        true, 
        a => '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
        );

    return balances;
};
// node test.js projects/hegic/index.js
module.exports = {
    ethereum: {
        tvl: ethTvl
    },
    arbitrum: {
        tvl: arbiTvl
    },
    methodology: `TVL for Hegic is calculated using the Eth and WBTC deposited for liquidity`
};
'''
'''--- projects/heliosprime/abi.json ---
{
    "getComponents":{"inputs":[],"name":"getComponents","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/heliosprime/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const {getComponents} = require('./abi.json');
const { sumTokens } = require("../helper/unwrapLPs");

const CoverageContract = "0x69c316563414d091c57C7Ec098523e43Baa5E175";
const USDT = "0xdac17f958d2ee523a2206206994597c13d831ec7";
const EDP = "0x7633da43dfd4ee5a5da99740f077ca9d97aa0d0e"

const StakingContract_BMI = "0xDfB820b95EEE42A858f50BEfbF834D2d24621153";
const BMI = "0x725c263e32c72ddc3a19bea12c5a0479a81ee688";

const StakingContract_BMI_ETH = "0x49791b39B8cb01ad5f207c296123fD772D5C0d62";
const BMI_ETH_UNIV2 = "0xa9Bd7EEF0c7AfFbdBDAE92105712E9Ff8b06Ed49";

const ethTvl = async (time, block) => {
  const components = await sdk.api.abi.call({
    target: EDP,
    block,
    abi: getComponents
  })
  const balances={}
  await sumTokens(balances, components.output.map(t=>[t, EDP]), block)
  return balances
};

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology:
    "We count liquidity on the pool2, and it counts the staking of native token separtly",
};

'''
'''--- projects/helmetinsure/index.js ---
const { blockQuery } = require('../helper/graph')
const { gql } = require('graphql-request')
const BigNumber = require("bignumber.js");
const CHAIN_POLYGON = 'polygon'
const CHAIN_BSC = 'bsc'

BigNumber.config({ EXPONENTIAL_AT: 50 })

const THEGARPH_API = {
  [CHAIN_POLYGON]: "https://api.thegraph.com/subgraphs/name/app-helmet-insure/guard",
  [CHAIN_BSC]: "https://api.thegraph.com/subgraphs/name/app-helmet-insure/helmet-insure"
}

function transform(str) {
  switch (str) {
    case "bsc:0xaf90e457f4359adcc8b37e8df8a27a1ff4c3f561": // SHIB
      return "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE"
    case "bsc:0xf218184af829cf2b0019f8e6f0b2423498a36983": // MATH
      return "0x08d967bb0134f2d07f7cfb6e246680c53927dd30"
    case "bsc:0xbd2949f67dcdc549c6ebe98696449fa79d988a9f":
      return "0xBd2949F67DcdC549c6Ebe98696449Fa79D988A9F"
    default:
      return str
  }
}

function fetch(chain) {
  return async (_timestamp, _ethBlock, chainBlocks) => {
    var endpoint = THEGARPH_API[chain]
    var query = gql`
    query tvl($block: Int){
      options(
        first: 1000,
        block: { number: $block }
      ) {
        collateral
        asks {
          volume
          settleToken
        }
      }
    }
    `;
    const results = await blockQuery(endpoint, query, chainBlocks[chain], 1000)
    const { options } = results

    const data = options.flatMap(o => {
      return o.asks.map(ask => {
        return Object.assign(ask, {
          collateral: o.collateral
        })
      })
    }).reduce((_data, ask) => {
      const key = transform(`${chain}:${ask.collateral}`)
      if (typeof _data[key] === 'undefined') {
        _data[key] = ask.volume
      } else {
        _data[key] = new BigNumber(_data[key]).plus(new BigNumber(ask.volume)).toFixed()
      }
      return _data
    }, {})
    return data
  }
}

module.exports = {
  [CHAIN_POLYGON]:{
    tvl: fetch(CHAIN_POLYGON)
  },
  [CHAIN_BSC]:{
    tvl: fetch(CHAIN_BSC)
  },
}
'''
'''--- projects/helper/CosmWasm.js ---
const { get } = require('./http')
const EnigmaUtils = require('./utils/enigma')
const { toBase64, fromBase64, toUtf8, fromUtf8, toHex,  }  = EnigmaUtils

class CosmWasmClient {
  constructor(nodeURL) {
    this.nodeURL = nodeURL
    this.codeHashCache = {}
    this.enigmautils = new EnigmaUtils(nodeURL)
  }

  async getHeight() {
    const latest = await this.get('/blocks/latest')
    return parseInt(latest.block.header.height, 10)
  }

  async queryContractSmart(contractAddress, query, addedParams) {
    const contractCodeHash = await this.getCodeHashByContractAddr(contractAddress);
    const encrypted = await this.enigmautils.encrypt(contractCodeHash, query);
    const nonce = encrypted.slice(0, 32);
    const encoded = toHex(toUtf8(toBase64(encrypted)));
    // @ts-ignore
    const paramString = new URLSearchParams(addedParams).toString();
    const path = `/wasm/contract/${contractAddress}/query/${encoded}?encoding=hex&${paramString}`;
    let responseData = (await this.get(path))
    // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)
    return JSON.parse(fromUtf8(fromBase64(fromUtf8(await this.enigmautils.decrypt(fromBase64(responseData.result.smart), nonce)))));

  }

  async get(api) {
    return get(this.nodeURL + api)
  }

  async getContracts(codeId) {
    const path = `/wasm/code/${codeId}/contracts`;
    const responseData = (await this.get(path));
    const result = responseData.result || [];
    return result.map((entry) => ({
      address: entry.address,
      codeId: entry.code_id,
      creator: entry.creator,
      label: entry.label,
    }));
  }

  async getCodeHashByContractAddr(addr) {
    const codeHashFromCache = this.codeHashCache[addr];
    if (typeof codeHashFromCache === "string")
      return codeHashFromCache;

    const path = `/wasm/contract/${addr}/code-hash`;
    const responseData = await this.get(path);
    this.codeHashCache[addr] = responseData.result
    return responseData.result;
  }

}

module.exports = CosmWasmClient
'''
'''--- projects/helper/aave.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');
const abi = require('./abis/aave.json');
const { getBlock } = require('./getBlock');

async function getV2Reserves(block, addressesProviderRegistry, chain, dataHelperAddress) {
  let validProtocolDataHelpers
  if (dataHelperAddress === undefined) {
    const addressesProviders = (
      await sdk.api.abi.call({
        target: addressesProviderRegistry,
        abi: abi["getAddressesProvidersList"],
        block,
        chain
      })
    ).output;

    const protocolDataHelpers = (
      await sdk.api.abi.multiCall({
        calls: addressesProviders.map((provider) => ({
          target: provider,
          params: "0x0100000000000000000000000000000000000000000000000000000000000000",
        })),
        abi: abi["getAddress"],
        block,
        chain
      })
    ).output;

    validProtocolDataHelpers = protocolDataHelpers.filter(
      (helper) =>
        helper.output !== "0x0000000000000000000000000000000000000000"
    ).map(p => p.output);
  } else {
    validProtocolDataHelpers = dataHelperAddress
  }

  const aTokenMarketData = (
    await sdk.api.abi.multiCall({
      calls: validProtocolDataHelpers.map((dataHelper) => ({
        target: dataHelper,
      })),
      abi: abi["getAllATokens"],
      block,
      chain
    })
  ).output;

  let aTokenAddresses = [];
  aTokenMarketData.map((aTokensData) => {
    aTokenAddresses = [
      ...aTokenAddresses,
      ...aTokensData.output.map((aToken) => aToken[1]),
    ];
  });

  const underlyingAddressesData = (
    await sdk.api.abi.multiCall({
      calls: aTokenAddresses.map((aToken) => ({
        target: aToken,
      })),
      abi: abi["getUnderlying"],
      block,
      chain
    })
  ).output;

  const reserveAddresses = underlyingAddressesData.map((reserveData) => reserveData.output);

  return [aTokenAddresses, reserveAddresses, validProtocolDataHelpers[0]]
}

async function getTvl(balances, block, chain, v2Atokens, v2ReserveTokens, transformAddress) {
  const balanceOfUnderlying = await sdk.api.abi.multiCall({
      calls: v2Atokens.map((aToken, index) => ({
        target: v2ReserveTokens[index],
        params: aToken,
      })),
      abi: "erc20:balanceOf",
      block,
      chain
    });
  sdk.util.sumMultiBalanceOf(balances, balanceOfUnderlying, true, transformAddress)
}

async function getBorrowed(balances, block, chain, v2ReserveTokens, dataHelper, transformAddress, v3 = false) {
  const reserveData = await sdk.api.abi.multiCall({
      calls: v2ReserveTokens.map((token) => ({
        target: dataHelper,
        params: [token],
      })),
      abi: v3 ? abi.getTotalDebt : abi.getHelperReserveData,
      block,
      chain
    });

    reserveData.output.forEach((data, idx)=>{
      const quantity = v3 ? data.output : BigNumber(data.output.totalVariableDebt).plus(data.output.totalStableDebt).toFixed(0)
      sdk.util.sumSingleBalance(balances, transformAddress(data.input.params[0]), quantity)
    })
}

function aaveChainTvl(chain, addressesProviderRegistry, transformAddressRaw, dataHelperAddresses, borrowed, v3 = false) {
  const transformAddress = transformAddressRaw ? transformAddressRaw : addr=>`${chain}:${addr}`
  return async (timestamp, ethBlock, chainBlocks) => {
    const balances = {}
    const block = await getBlock(timestamp, chain, chainBlocks, true);
    const [v2Atokens, v2ReserveTokens, dataHelper] = await getV2Reserves(block, addressesProviderRegistry, chain, dataHelperAddresses)
    if(borrowed){
      await getBorrowed(balances, block, chain, v2ReserveTokens, dataHelper, transformAddress, v3);
    } else {
      await getTvl(balances, block, chain, v2Atokens, v2ReserveTokens, transformAddress);
    }
    return balances
  }
}
function aaveExports(chain, addressesProviderRegistry, transform = undefined, dataHelpers = undefined){
  return {
    tvl: aaveChainTvl(chain, addressesProviderRegistry, transform, dataHelpers, false),
    borrowed: aaveChainTvl(chain, addressesProviderRegistry, transform, dataHelpers, true)
  }
}
module.exports = {
  aaveChainTvl,
  getV2Reserves,
  getTvl,
  aaveExports,
  getBorrowed,
}
'''
'''--- projects/helper/abis/aave.json ---
{
  "getTotalDebt": {
    "inputs": [
      {
        "internalType": "address",
        "name": "asset",
        "type": "address"
      }
    ],
    "name": "getTotalDebt",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getReservesList": {
    "inputs": [],
    "name": "getReservesList",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAMMReserveData": {
    "inputs": [
      {
        "internalType": "address",
        "name": "asset",
        "type": "address"
      }
    ],
    "name": "getReserveData",
    "outputs": [
      {
        "components": [
          {
            "components": [
              {
                "internalType": "uint256",
                "name": "data",
                "type": "uint256"
              }
            ],
            "internalType": "struct DataTypes.ReserveConfigurationMap",
            "name": "configuration",
            "type": "tuple"
          },
          {
            "internalType": "uint128",
            "name": "liquidityIndex",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "variableBorrowIndex",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "currentLiquidityRate",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "currentVariableBorrowRate",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "currentStableBorrowRate",
            "type": "uint128"
          },
          {
            "internalType": "uint40",
            "name": "lastUpdateTimestamp",
            "type": "uint40"
          },
          {
            "internalType": "address",
            "name": "aTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "stableDebtTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "variableDebtTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "interestRateStrategyAddress",
            "type": "address"
          },
          {
            "internalType": "uint8",
            "name": "id",
            "type": "uint8"
          }
        ],
        "internalType": "struct DataTypes.ReserveData",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getCurrentTokens": {
    "constant": true,
    "inputs": [],
    "name": "getCurrentTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "tokens",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveData": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_reserve",
        "type": "address"
      }
    ],
    "name": "getReserveData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "totalLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "availableLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalBorrowsStable",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalBorrowsVariable",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "averageStableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "utilizationRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowIndex",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "aTokenAddress",
        "type": "address"
      },
      {
        "internalType": "uint40",
        "name": "lastUpdateTimestamp",
        "type": "uint40"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveConfigurationData": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_reserve",
        "type": "address"
      }
    ],
    "name": "getReserveConfigurationData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "ltv",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidationThreshold",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidationBonus",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "interestRateStrategyAddress",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "usageAsCollateralEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "borrowingEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "stableBorrowRateEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "isActive",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getReserves": {
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getAddressesProvidersList": {
    "inputs": [],
    "name": "getAddressesProvidersList",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAddress": {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "id",
        "type": "bytes32"
      }
    ],
    "name": "getAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAllATokens": {
    "inputs": [],
    "name": "getAllATokens",
    "outputs": [
      {
        "components": [
          {
            "internalType": "string",
            "name": "symbol",
            "type": "string"
          },
          {
            "internalType": "address",
            "name": "tokenAddress",
            "type": "address"
          }
        ],
        "internalType": "struct AaveProtocolDataProvider.TokenData[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getUnderlying": {
    "inputs": [],
    "name": "UNDERLYING_ASSET_ADDRESS",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveDataV2": {
    "inputs": [
      {
        "internalType": "address",
        "name": "asset",
        "type": "address"
      }
    ],
    "name": "getReserveData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "availableLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalStableDebt",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalVariableDebt",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "averageStableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint40",
        "name": "lastUpdateTimestamp",
        "type": "uint40"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBPool": {
    "inputs": [],
    "name": "bPool",
    "outputs": [
      {
        "internalType": "contract IBPool",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getHelperReserveData": {
    "inputs": [
      {
        "internalType": "address",
        "name": "asset",
        "type": "address"
      }
    ],
    "name": "getReserveData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "availableLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalStableDebt",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalVariableDebt",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "averageStableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint40",
        "name": "lastUpdateTimestamp",
        "type": "uint40"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveTotalBorrows": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_reserve",
        "type": "address"
      }
    ],
    "name": "getReserveTotalBorrows",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/helper/abis/balancer.json ---
{
    "getPoolTokens": {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "poolId",
                "type": "bytes32"
            }
        ],
        "name": "getPoolTokens",
        "outputs": [
            {
                "internalType": "contract IERC20[]",
                "name": "tokens",
                "type": "address[]"
            },
            {
                "internalType": "uint256[]",
                "name": "balances",
                "type": "uint256[]"
            },
            {
                "internalType": "uint256",
                "name": "lastChangeBlock",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getPoolId": {
        "inputs": [],
        "name": "getPoolId",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "bPool": {
        "inputs": [],
        "name": "bPool",
        "outputs": [
            {
                "internalType": "contract IBPool",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getCurrentTokens": {
        "constant": true,
        "inputs": [],
        "name": "getCurrentTokens",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "tokens",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/helper/abis/blindex.json ---
{
  "bdstable_pools_array": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "bdstable_pools_array",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBdStablesPoolsLength": {
    "inputs": [],
    "name": "getBdStablesPoolsLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBDStablePoolCollateral": {
    "inputs": [],
    "name": "collateral_token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBDStable": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "bdstables",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBdStablesLength": {
    "inputs": [],
    "name": "getBdStablesLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getBDXPriceUsdD12": {
    "inputs": [],
    "name": "BDX_price_d12",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/helper/abis/blockng.json ---
{
  "getPoolInfo": {
    "inputs": [
      {
        "internalType": "contract IVoter",
        "type": "address"
      },
      {
        "internalType": "address",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "type": "uint256"
      }
    ],
    "name": "getPoolInfo",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "lpTokenAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "subTokenAddress",
            "type": "address"
          },
          {
            "internalType": "string",
            "name": "subTokenSymbol",
            "type": "string"
          },
          {
            "internalType": "address",
            "name": "dexFactory",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "gaugeAddress",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "gaugeTotalSupply",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "lpPrice",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "gaugeAPR",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "bribeAddress",
            "type": "address"
          },
          {
            "internalType": "int256",
            "name": "weights",
            "type": "int256"
          },
          {
            "internalType": "uint256",
            "name": "punkId",
            "type": "uint256"
          }
        ],
        "internalType": "struct LawDaoLen.BEAM[]",
        "name": "beams",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "numberOfPool": {
    "inputs": [
      {
        "internalType": "contract IVoter",
        "name": "voter",
        "type": "address"
      }
    ],
    "name": "numberOfPool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "len",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/helper/abis/compound.json ---
{
  "markets": {
    "constant":true,
    "inputs":[
      {
        "name":"",
        "type":"address"
      }
    ],
    "name":"markets",
    "outputs":[
      {
        "name":"isSupported",
        "type":"bool"
      },
      {
        "name":"blockNumber",
        "type":"uint256"
      },
      {
        "name":"interestRateModel",
        "type":"address"
      },
      {
        "name":"totalSupply",
        "type":"uint256"
      },
      {
        "name":"supplyRateMantissa",
        "type":"uint256"
      },
      {
        "name":"supplyIndex",
        "type":"uint256"
      },
      {
        "name":"totalBorrows",
        "type":"uint256"
      },
      {
        "name":"borrowRateMantissa",
        "type":"uint256"
      },
      {
        "name":"borrowIndex",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "totalBorrows": {
    "constant":true,
    "inputs":[

    ],
    "name":"totalBorrows",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "borrowRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"borrowRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "supplyRatePerBlock": {
    "constant":true,
    "inputs":[

    ],
    "name":"supplyRatePerBlock",
    "outputs":[
      {
        "name":"",
        "type":"uint256"
      }
    ],
    "payable":false,
    "stateMutability":"view",
    "type":"function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6f307dc3"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "signature": "0x3b1d21a2",
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xb0772d0b"
  },
  "getUnderlyingPrice":
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_pToken",
        "type": "address"
      }
    ],
    "name": "getUnderlyingPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "oracle":
  {
    "inputs": [],
    "name": "oracle",
    "outputs": [
      {
        "internalType": "contract IPriceOracle",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/helper/abis/cream.json ---
{
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/helper/abis/dodo.json ---
{
    "_BASE_TOKEN_": {
        "inputs": [],
        "name": "_BASE_TOKEN_",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "_QUOTE_TOKEN_": {
        "inputs": [],
        "name": "_QUOTE_TOKEN_",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/helper/abis/erc20.json ---
{
  "balanceOf": {
    "inputs": [
      { "internalType": "address", "name": "account", "type": "address" }
    ],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "symbol": {
    "type": "function",
    "stateMutability": "view",
    "payable": false,
    "outputs": [{ "type": "string", "name": "" }],
    "name": "symbol",
    "inputs": [],
    "constant": true
  },
  "name":  {
    "type": "function",
    "stateMutability": "view",
    "payable": false,
    "outputs": [
      {
        "type": "string",
        "name": ""
      }
    ],
    "name": "name",
    "inputs": [],
    "constant": true
  }
}

'''
'''--- projects/helper/abis/factory.json ---
{
  "allPairs": {
    "constant": true,
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "allPairs",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "allPairsLength": {
    "constant": true,
    "inputs": [],
    "name": "allPairsLength",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/helper/abis/getEntireSystemColl.abi.json ---
{
  "inputs": [],
  "name": "getEntireSystemColl",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "entireSystemColl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/helper/abis/getPair.json ---
{
  "constant": true,
  "inputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    },
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "name": "getPair",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/helper/abis/getPricePerShare.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "getPricePerFullShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x77c7b8fc"
  },
  {
    "name": "pricePerShare",
    "outputs": [
      {
        "type": "uint256",
        "name": ""
      }
    ],
    "inputs": [],
    "stateMutability": "view",
    "type": "function",
    "gas": 12412
  }
]
'''
'''--- projects/helper/abis/getReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
    {
      "internalType": "uint112",
      "name": "_reserve0",
      "type": "uint112"
    },
    {
      "internalType": "uint112",
      "name": "_reserve1",
      "type": "uint112"
    },
    {
      "internalType": "uint32",
      "name": "_blockTimestampLast",
      "type": "uint32"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/helper/abis/kashipair.json ---
[
  {
    "inputs": [],
    "name": "totalBorrow",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "elastic",
        "type": "uint128"
      },
      {
        "internalType": "uint128",
        "name": "base",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/helper/abis/masterchef.json ---
{
    "poolInfo": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [
        {
          "type": "address",
          "name": "lpToken",
          "internalType": "contract IERC20"
        },
        { "type": "uint256", "name": "allocPoint", "internalType": "uint256" },
        {
          "type": "uint256",
          "name": "lastRewardBlock",
          "internalType": "uint256"
        },
        {
          "type": "uint256",
          "name": "accFishPerShare",
          "internalType": "uint256"
        },
        { "type": "uint16", "name": "depositFeeBP", "internalType": "uint16" }
      ],
      "name": "poolInfo",
      "inputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }]
    },
    "poolLength": {
      "type": "function",
      "stateMutability": "view",
      "outputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }],
      "name": "poolLength",
      "inputs": []
    }
  }
  
'''
'''--- projects/helper/abis/symbol.json ---
{
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
        {
            "internalType": "string",
            "name": "",
            "type": "string"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
}
'''
'''--- projects/helper/abis/token.json ---
{
  "inputs": [],
  "name": "token",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/helper/abis/token0.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token0",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/helper/abis/token1.json ---
{
  "constant": true,
  "inputs": [],
  "name": "token1",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}

'''
'''--- projects/helper/abis/underlying.json ---

  {
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
'''
'''--- projects/helper/abis/userInfo.json ---
{
    "inputs": [{
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        },
        {
            "internalType": "address",
            "name": "",
            "type": "address"
        }
    ],
    "name": "userInfo",
    "outputs": [{
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
        },
        {
            "internalType": "uint256",
            "name": "rewardDebt",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}

'''
'''--- projects/helper/acala/api.js ---

const { ApiPromise, WsProvider } = require("@polkadot/api")
const { Wallet } = require("@acala-network/sdk/wallet")
const { options } = require("@acala-network/api")

const api = {}

const providers = {
  karura: [
    // Taken from https://wiki.acala.network/integrate/integration-1/networks
    "wss://karura.api.onfinality.io/public-ws",
    "wss://pub.elara.patract.io/karura",
    "wss://karura-rpc-0.aca-api.network",
    "wss://karura-rpc-1.aca-api.network",
    "wss://karura-rpc-2.aca-api.network/ws",
    "wss://karura-rpc-3.aca-api.network/ws",
  ],
  polkadot: [
    "wss://polkadot-rpc.dwellir.com",
    "wss://polkadot.api.onfinality.io/public-ws",
    "wss://rpc.polkadot.io",
  ],
  kusama: [
    "wss://kusama-rpc.polkadot.io",
    "wss://kusama.api.onfinality.io/public-ws",
    "wss://kusama-rpc.dwellir.com",
  ],
  acala: [
    "wss://acala.polkawallet.io",
  ],
}

async function getAPI(chain) {
  if (!api[chain]) {
    const provider = new WsProvider(providers[chain]);
    api[chain] = ApiPromise.create(options({ provider }))
  }

  await api[chain].isReady
  return api[chain]
}

async function getWallet(chain) {
  const api = await getAPI(chain)
  const wallet = new Wallet(api, {
    supportAUSD: true,
  })

  await wallet.isReady
  return wallet
}

module.exports = {
  getAPI,
  getWallet,
}

'''
'''--- projects/helper/acala/dex-staking.js ---
const { FixedPointNumber, forceToCurrencyName } = require("@acala-network/sdk-core");

async function dexStaking(chain){
  const api = await getAPI(chain)
  const wallet = await getWallet(chain)
  const data = await api.query.rewards.poolInfos.entries();
  let total = FixedPointNumber.ZERO;
  const filterData = data.filter(([token]) => {
    return token.toHuman()[0].hasOwnProperty('Dex');
  });

  for (let i = 0; i < filterData.length; i++) {
    const [token, amount] = filterData[i];

    const lpToken = await wallet.getToken(forceToCurrencyName(token.args[0].asDex));
    const totalShares = FixedPointNumber.fromInner(amount.totalShares.toString(), lpToken.decimals);
    const price = await wallet.getPrice(lpToken.name);

    total = total.add(totalShares.times(price));
  }

  return {
    tether: total.toNumber()
  }
}

module.exports = {
  dexStaking
}

'''
'''--- projects/helper/acala/dex.js ---
const { FixedPointNumber, forceToCurrencyName } = require("@acala-network/sdk-core");
const { getAPI, getWallet } = require('./api')

async function dex(chain) {
  const api = await getAPI(chain)
  const wallet = await getWallet(chain)
  const data = await api.query.dex.liquidityPool.entries();
  let total = FixedPointNumber.ZERO;
  const prices = {}

  async function getPrice(token) {
    if (!prices[token]) prices[token] = wallet.getPrice(token)
    return prices[token]
  }

  for (let i = 0; i < data.length; i++) {
    const [token, amount] = data[i];
    const tokenA = await wallet.getToken(forceToCurrencyName(token.args[0][0]));
    const tokenB = await wallet.getToken(forceToCurrencyName(token.args[0][1]));
    const amountA = FixedPointNumber.fromInner(amount[0].toString(), tokenA.decimals);
    const amountB = FixedPointNumber.fromInner(amount[1].toString(), tokenB.decimals);
    const priceA = await getPrice(tokenA)
    const priceB = await getPrice(tokenB)

    if (!priceA || !priceB) continue;

    total = total.add(amountA.times(priceA)).add(amountB.times(priceB));
  }

  return {
    tether: total.toNumber()
  }
}

module.exports = {
  dex
}
'''
'''--- projects/helper/acala/lcdot.js ---
const { getWallet } = require('./api')

async function staking(chain) {
  const wallet = await getWallet(chain)
  const supply = await wallet.getIssuance('lc://13')
  const price = await wallet.getPrice('DOT')

  return  {
    tether: supply.times(price).toNumber()
  }
}

module.exports = {
  staking,
}
'''
'''--- projects/helper/acala/lending.js ---
const { FixedPointNumber, forceToCurrencyName } = require("@acala-network/sdk-core")
const { getAPI, getWallet } = require('./api')

async function lending(chain){
  const api = await getAPI(chain)
  const wallet = await getWallet(chain)
  let locked = FixedPointNumber.ZERO;

  const data = await api.query.loans.totalPositions.entries();

  for (let i = 0; i < data.length; i++) {
    const [_token, amount] = data[i];
    const token = await wallet.getToken(forceToCurrencyName(_token.args[0]));
    const collateral = FixedPointNumber.fromInner(amount.collateral.toString(), token.decimals);
    const price = await wallet.getPrice(token.name);

    locked = locked.add(collateral.times(price));
  }

  return {
    tether: +locked.toString(),
  }
}

module.exports = {
  lending
}

'''
'''--- projects/helper/acala/liquidStaking.js ---
const { FixedPointNumber } = require("@acala-network/sdk-core")
const { getAPI, getWallet } = require('./api')

const getTotalStaking = async (api, token) => {
  const toBond = await api.query.homa.toBondPool();
  const stakingLedgers = await api.query.homa.stakingLedgers.entries();
  let totalInSubAccount = FixedPointNumber.ZERO;

  stakingLedgers.map(item => {
    const ledge = item[1].unwrapOrDefault();
    totalInSubAccount = totalInSubAccount.add(FixedPointNumber.fromInner(ledge.bonded.unwrap().toString(), token.decimals));
  })

  const total = FixedPointNumber.fromInner(toBond.toString(), token.decimals).add(totalInSubAccount);

  return total;
}

async function staking(chain) {
  const api = await getAPI(chain)
  const wallet = await getWallet(chain)
  const getStakingCurrencyId = api.consts.prices.getStakingCurrencyId;
  const stakingToken = await wallet.getToken(getStakingCurrencyId);
  const price = await wallet.getPrice(stakingToken);

  const total = await getTotalStaking(api, stakingToken)

  return {
    tether: total.times(price).toNumber(),
  }
}

module.exports = {
  staking,
  getTotalStaking,
}
'''
'''--- projects/helper/algorand.js ---
// documentation: https://developer.algorand.org/docs/get-details/indexer/?from_query=curl#sdk-client-instantiations

const axios = require('axios')
const { getApplicationAddress } = require('./algorandUtils/address')
const { RateLimiter } = require("limiter");

const axiosObj = axios.create({
  baseURL: 'https://algoindexer.algoexplorerapi.io',
  timeout: 300000,
})

const indexerLimiter = new RateLimiter({ tokensPerInterval: 10, interval: "second" });

async function lookupApplications(appId) {
  return (await axiosObj.get(`/v2/applications/${appId}`)).data
}

async function lookupAccountByID(appId) {
  return (await axiosObj.get(`/v2/accounts/${appId}`)).data
}

async function searchAccounts({ appId, limit = 1000, nexttoken, }) {
  const response = (await axiosObj.get('/v2/accounts', {
    params: {
      'application-id': appId,
      limit,
      next: nexttoken
    }
  }))
  return response.data
}

const withLimiter = (fn, tokensToRemove = 1) => async (...args) => {
  await indexerLimiter.removeTokens(tokensToRemove);
  return fn(...args);
}

module.exports = {
  getApplicationAddress,
  lookupApplications: withLimiter(lookupApplications),
  lookupAccountByID: withLimiter(lookupAccountByID),
  searchAccounts: withLimiter(searchAccounts),
}

'''
'''--- projects/helper/algorandUtils/address.js ---
const base32 = require('hi-base32');
const sha512 = require('js-sha512');

const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;
const PUBLIC_KEY_LENGTH = 32

const APP_ID_PREFIX = Buffer.from('appID');

/**
 * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.
 * @param address - a raw Algorand address
 * @returns the address and checksum encoded as a string.
 */
function encodeAddress(address) {
  // compute checksum
  const checksum = genericHash(address)
    .slice(
      PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,
      PUBLIC_KEY_LENGTH
    );
  const addr = base32.encode(concatArrays(address, checksum));

  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='
}

/**
 * Get the escrow address of an application.
 * @param appID - The ID of the application.
 * @returns The address corresponding to that application's escrow account.
 */
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return encodeAddress(new Uint8Array(hash));
}

function concatArrays(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size);

  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c.set(arrs[i], offset);
    offset += arrs[i].length;
  }

  return c;
}

function encodeUint64(num) {
  const isInteger = typeof num === 'bigint' || Number.isInteger(num);

  if (!isInteger || num < 0 || num > BigInt('0xffffffffffffffff')) {
    throw new Error('Input is not a 64-bit unsigned integer');
  }

  const buf = Buffer.allocUnsafe(8);

  buf.writeBigUInt64BE(BigInt(num));

  return new Uint8Array(buf);
}

function genericHash(arr) {
  return sha512.sha512_256.array(arr);
}

module.exports = {
  encodeAddress,
  getApplicationAddress,
}
'''
'''--- projects/helper/ankr/abis/AethToken.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "guy",
        "type": "address"
      },
      {
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "src",
        "type": "address"
      },
      {
        "name": "dst",
        "type": "address"
      },
      {
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "withdraw",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "dst",
        "type": "address"
      },
      {
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "deposit",
    "outputs": [],
    "payable": true,
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "",
        "type": "address"
      },
      {
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "payable": true,
    "stateMutability": "payable",
    "type": "fallback"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "src",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "guy",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "src",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "dst",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "dst",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "src",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "wad",
        "type": "uint256"
      }
    ],
    "name": "Withdrawal",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "ratio",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/ERC20.json ---
[
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "subtractedValue",
        "type": "uint256"
      }
    ],
    "name": "decreaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "addedValue",
        "type": "uint256"
      }
    ],
    "name": "increaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
      }
    ],
    "name": "mintTo",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
'''
'''--- projects/helper/ankr/abis/OnsToken.json ---
[
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousGovernor",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newGovernor",
        "type": "address"
      }
    ],
    "name": "GovernorshipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "governor_",
        "type": "address"
      }
    ],
    "name": "__Governable_init_unchained",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "governor_",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "vault_",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "onsFarm",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "offering",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "timelock",
        "type": "address"
      }
    ],
    "name": "__ONS_init",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "onsFarm",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "offering",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "timelock",
        "type": "address"
      }
    ],
    "name": "__ONS_init_unchained",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "vault_",
        "type": "address"
      }
    ],
    "name": "__VaultERC20_init_unchained",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "acct",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amt",
        "type": "uint256"
      }
    ],
    "name": "burn_",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "subtractedValue",
        "type": "uint256"
      }
    ],
    "name": "decreaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "addr",
        "type": "address"
      }
    ],
    "name": "getConfig",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getConfig",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "name": "getConfig",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "governor",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "addedValue",
        "type": "uint256"
      }
    ],
    "name": "increaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "acct",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amt",
        "type": "uint256"
      }
    ],
    "name": "mint_",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceGovernorship",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "setConfig",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "addr",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "setConfig",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "setConfig",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom_",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newGovernor",
        "type": "address"
      }
    ],
    "name": "transferGovernorship",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
'''
'''--- projects/helper/ankr/abis/OnxPool.json ---
[
  {
    "inputs": [],
    "name": "totalBorrow",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalStake",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalPledge",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/helper/ankr/abis/OnxToken.json ---
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_exchange",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_treasury",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "subtractedValue",
        "type": "uint256"
      }
    ],
    "name": "decreaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "exchangeAirdropCampaign",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "addedValue",
        "type": "uint256"
      }
    ],
    "name": "increaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
      }
    ],
    "name": "mintTo",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasuryAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- projects/helper/ankr/abis/QuickswapPool.json ---
[
  { "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": false, "internalType": "uint112", "name": "reserve0", "type": "uint112" },
      { "indexed": false, "internalType": "uint112", "name": "reserve1", "type": "uint112" }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "MINIMUM_LIQUIDITY",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      { "internalType": "address", "name": "", "type": "address" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "burn",
    "outputs": [
      { "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "factory",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint112", "name": "_reserve0", "type": "uint112" },
      { "internalType": "uint112", "name": "_reserve1", "type": "uint112" },
      { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "_token0", "type": "address" },
      { "internalType": "address", "name": "_token1", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "kLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "mint",
    "outputs": [{ "internalType": "uint256", "name": "liquidity", "type": "uint256" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "nonces",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" },
      { "internalType": "uint256", "name": "deadline", "type": "uint256" },
      { "internalType": "uint8", "name": "v", "type": "uint8" },
      { "internalType": "bytes32", "name": "r", "type": "bytes32" },
      { "internalType": "bytes32", "name": "s", "type": "bytes32" }
    ],
    "name": "permit",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "skim",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "bytes", "name": "data", "type": "bytes" }
    ],
    "name": "swap",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "sync",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      { "internalType": "address", "name": "from", "type": "address" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/QuickswapVault.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "Invest",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Withdraw",
    "type": "event"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "controller",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }
    ],
    "name": "decreaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "address", "name": "holder", "type": "address" }
    ],
    "name": "depositFor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "doHardWork", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "governance",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "addedValue", "type": "uint256" }
    ],
    "name": "increaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_storage", "type": "address" },
      { "internalType": "address", "name": "_underlying", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_storage", "type": "address" }],
    "name": "initializeControllableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "initializeGovernableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_underlying", "type": "address" },
      { "internalType": "uint256", "name": "_underlyingUnit", "type": "uint256" }
    ],
    "name": "initializeVaultStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "rebalance", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_fee", "type": "uint256" },
      { "internalType": "uint256", "name": "_feeMax", "type": "uint256" }
    ],
    "name": "setKeepFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "setStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_strategy", "type": "address" }],
    "name": "setStrategy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "stakeQuickFarm", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "strategy",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "sender", "type": "address" },
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasury",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlying",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceInVault",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceWithInvestment",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "holder", "type": "address" }],
    "name": "underlyingBalanceWithInvestmentForHolder",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingUnit",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "numberOfShares", "type": "uint256" }],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "withdrawAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
]

'''
'''--- projects/helper/ankr/abis/SOnxToken.json ---
[
  {
    "inputs": [
      {
        "internalType": "contract IERC20",
        "name": "_onx",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "subtractedValue",
        "type": "uint256"
      }
    ],
    "name": "decreaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
      }
    ],
    "name": "enter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "addedValue",
        "type": "uint256"
      }
    ],
    "name": "increaseAllowance",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_share",
        "type": "uint256"
      }
    ],
    "name": "leave",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "onx",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
'''
'''--- projects/helper/ankr/abis/SpookyswapPool.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": false, "internalType": "uint112", "name": "reserve0", "type": "uint112" },
      { "indexed": false, "internalType": "uint112", "name": "reserve1", "type": "uint112" }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MINIMUM_LIQUIDITY",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "", "type": "address" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "burn",
    "outputs": [
      { "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "factory",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint112", "name": "_reserve0", "type": "uint112" },
      { "internalType": "uint112", "name": "_reserve1", "type": "uint112" },
      { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_token0", "type": "address" },
      { "internalType": "address", "name": "_token1", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "kLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "mint",
    "outputs": [{ "internalType": "uint256", "name": "liquidity", "type": "uint256" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "nonces",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" },
      { "internalType": "uint256", "name": "deadline", "type": "uint256" },
      { "internalType": "uint8", "name": "v", "type": "uint8" },
      { "internalType": "bytes32", "name": "r", "type": "bytes32" },
      { "internalType": "bytes32", "name": "s", "type": "bytes32" }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "skim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "bytes", "name": "data", "type": "bytes" }
    ],
    "name": "swap",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "sync", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "from", "type": "address" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/SpookyswapVault.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "Invest",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Withdraw",
    "type": "event"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "controller",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }
    ],
    "name": "decreaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "address", "name": "holder", "type": "address" }
    ],
    "name": "depositFor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "doHardWork", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "governance",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "addedValue", "type": "uint256" }
    ],
    "name": "increaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_storage", "type": "address" },
      { "internalType": "address", "name": "_underlying", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_storage", "type": "address" }],
    "name": "initializeControllableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "initializeGovernableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_underlying", "type": "address" },
      { "internalType": "uint256", "name": "_underlyingUnit", "type": "uint256" }
    ],
    "name": "initializeVaultStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "rebalance", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "setStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_strategy", "type": "address" }],
    "name": "setStrategy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "stakeBooFarm", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "stakeExternalRewards", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "stakeXBoo", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "strategy",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "sender", "type": "address" },
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlying",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceInVault",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceWithInvestment",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "holder", "type": "address" }],
    "name": "underlyingBalanceWithInvestmentForHolder",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingUnit",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "numberOfShares", "type": "uint256" }],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "withdrawAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
]

'''
'''--- projects/helper/ankr/abis/SushiswapPool.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": false, "internalType": "uint112", "name": "reserve0", "type": "uint112" },
      { "indexed": false, "internalType": "uint112", "name": "reserve1", "type": "uint112" }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MINIMUM_LIQUIDITY",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "", "type": "address" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "burn",
    "outputs": [
      { "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "factory",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint112", "name": "_reserve0", "type": "uint112" },
      { "internalType": "uint112", "name": "_reserve1", "type": "uint112" },
      { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_token0", "type": "address" },
      { "internalType": "address", "name": "_token1", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "kLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "mint",
    "outputs": [{ "internalType": "uint256", "name": "liquidity", "type": "uint256" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "nonces",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" },
      { "internalType": "uint256", "name": "deadline", "type": "uint256" },
      { "internalType": "uint8", "name": "v", "type": "uint8" },
      { "internalType": "bytes32", "name": "r", "type": "bytes32" },
      { "internalType": "bytes32", "name": "s", "type": "bytes32" }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "skim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "bytes", "name": "data", "type": "bytes" }
    ],
    "name": "swap",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "sync", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "from", "type": "address" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/SushiswapVault.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "Invest",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Withdraw",
    "type": "event"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "controller",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }
    ],
    "name": "decreaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "address", "name": "holder", "type": "address" }
    ],
    "name": "depositFor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "doHardWork", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "doHardWorkSOnx", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "doHardWorkXSushi", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "governance",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "addedValue", "type": "uint256" }
    ],
    "name": "increaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_storage", "type": "address" },
      { "internalType": "address", "name": "_underlying", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_storage", "type": "address" }],
    "name": "initializeControllableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "initializeGovernableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_underlying", "type": "address" },
      { "internalType": "uint256", "name": "_underlyingUnit", "type": "uint256" }
    ],
    "name": "initializeVaultStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "rebalance", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "setStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_strategy", "type": "address" }],
    "name": "setStrategy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "stakeOnsenFarm", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "stakeOnx", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "stakeOnxFarm", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  { "inputs": [], "name": "stakeSushiBar", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "strategy",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "sender", "type": "address" },
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlying",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceInVault",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceWithInvestment",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "holder", "type": "address" }],
    "name": "underlyingBalanceWithInvestmentForHolder",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingUnit",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "numberOfShares", "type": "uint256" }],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "withdrawAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
]

'''
'''--- projects/helper/ankr/abis/TraderJoePool.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "sender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount0In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1In", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "indexed": false, "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": false, "internalType": "uint112", "name": "reserve0", "type": "uint112" },
      { "indexed": false, "internalType": "uint112", "name": "reserve1", "type": "uint112" }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MINIMUM_LIQUIDITY",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "", "type": "address" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "burn",
    "outputs": [
      { "internalType": "uint256", "name": "amount0", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1", "type": "uint256" }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "factory",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint112", "name": "_reserve0", "type": "uint112" },
      { "internalType": "uint112", "name": "_reserve1", "type": "uint112" },
      { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_token0", "type": "address" },
      { "internalType": "address", "name": "_token1", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "kLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "mint",
    "outputs": [{ "internalType": "uint256", "name": "liquidity", "type": "uint256" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "name": "nonces",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" },
      { "internalType": "uint256", "name": "deadline", "type": "uint256" },
      { "internalType": "uint8", "name": "v", "type": "uint8" },
      { "internalType": "bytes32", "name": "r", "type": "bytes32" },
      { "internalType": "bytes32", "name": "s", "type": "bytes32" }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "to", "type": "address" }],
    "name": "skim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount0Out", "type": "uint256" },
      { "internalType": "uint256", "name": "amount1Out", "type": "uint256" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "bytes", "name": "data", "type": "bytes" }
    ],
    "name": "swap",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "sync", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "from", "type": "address" },
      { "internalType": "address", "name": "to", "type": "address" },
      { "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/TraderJoeVault.json ---
[
  { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "owner", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "spender", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [{ "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "Invest",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
      { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" },
      { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "Withdraw",
    "type": "event"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "controller",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }
    ],
    "name": "decreaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "address", "name": "holder", "type": "address" }
    ],
    "name": "depositFor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "doHardWork", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [],
    "name": "governance",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "addedValue", "type": "uint256" }
    ],
    "name": "increaseAllowance",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_storage", "type": "address" },
      { "internalType": "address", "name": "_underlying", "type": "address" }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_storage", "type": "address" }],
    "name": "initializeControllableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "initializeGovernableInit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "_underlying", "type": "address" },
      { "internalType": "uint256", "name": "_underlyingUnit", "type": "uint256" }
    ],
    "name": "initializeVaultStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  { "inputs": [], "name": "rebalance", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
  {
    "inputs": [
      { "internalType": "uint256", "name": "_fee", "type": "uint256" },
      { "internalType": "uint256", "name": "_feeMax", "type": "uint256" }
    ],
    "name": "setKeepFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_store", "type": "address" }],
    "name": "setStorage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "_strategy", "type": "address" }],
    "name": "setStrategy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "strategy",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transfer",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "sender", "type": "address" },
      { "internalType": "address", "name": "recipient", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "transferFrom",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlying",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceInVault",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingBalanceWithInvestment",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "holder", "type": "address" }],
    "name": "underlyingBalanceWithInvestmentForHolder",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "underlyingUnit",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "uint256", "name": "numberOfShares", "type": "uint256" }],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  { "inputs": [], "name": "withdrawAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
]

'''
'''--- projects/helper/ankr/abis/UniswapV2Pair.json ---
[
  {
    "inputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0In",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1In",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0Out",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1Out",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint112",
        "name": "reserve0",
        "type": "uint112"
      },
      {
        "indexed": false,
        "internalType": "uint112",
        "name": "reserve1",
        "type": "uint112"
      }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "MINIMUM_LIQUIDITY",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "burn",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "factory",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "uint112",
        "name": "_reserve0",
        "type": "uint112"
      },
      {
        "internalType": "uint112",
        "name": "_reserve1",
        "type": "uint112"
      },
      {
        "internalType": "uint32",
        "name": "_blockTimestampLast",
        "type": "uint32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_token1",
        "type": "address"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "kLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "mint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "liquidity",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "skim",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount0Out",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount1Out",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "swap",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "sync",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

'''
'''--- projects/helper/ankr/abis/activePool.json ---
{
  "inputs": [],
  "name": "activePool",
  "outputs": [
    {
      "internalType": "contract IActivePool",
      "name": "",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/helper/ankr/abis/wethAddress.json ---
{
  "inputs": [],
  "name": "wethAddress",
  "outputs": [
    {
      "internalType": "address",
      "name": "",
      "type": "address"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/helper/ankr/chainAddresses.js ---
const coinAddresses = {
  weth: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", //Ethereum
  ftm: "0x4e15361fd6b4bb609fa63c81a2be19d873717870",  //Fantom
  matic: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", //Matic
  dot: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", //DOT
  avax: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", //Avalanche
};

module.exports = coinAddresses;
'''
'''--- projects/helper/ankr/networks.js ---
const SupportedChainId = {
  MAINNET: 1,
  ROPSTEN: 3,
  MATIC: 137,
  MATIC_TESTNET: 80001,
  LOCAL_TESTNET: 31337,
  BSC: 56,
  FANTOM: 250,
  AVALANCHE: 0xa86a,
}

const SUPPORTED_NETWORKS = {
  [SupportedChainId.MAINNET]: {
    chainId: '0x1', //1
    chainName: 'Ethereum',
    nativeCurrency: {
      name: 'Ethereum',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: ['https://mainnet.infura.io/v3'],
    blockExplorerUrls: ['https://etherscan.com'],
  },
  [SupportedChainId.BSC]: {
    chainId: '0x38', //56
    chainName: 'Binance Smart Chain',
    nativeCurrency: {
      name: 'Binance Coin',
      symbol: 'BNB',
      decimals: 18,
    },
    rpcUrls: ['https://bsc-dataseed.binance.org'],
    blockExplorerUrls: ['https://bscscan.com'],
  },
  [SupportedChainId.MATIC]: {
    chainId: '0x89', //137
    chainName: 'Matic',
    nativeCurrency: {
      name: 'Matic',
      symbol: 'MATIC',
      decimals: 18,
    },
    rpcUrls: ['https://polygon-rpc.com'],
    blockExplorerUrls: ['https://explorer-mainnet.maticvigil.com'],
  },
  [SupportedChainId.FANTOM]: {
    chainId: '0xFA', //250
    chainName: 'Fantom',
    nativeCurrency: {
      name: 'FTM',
      symbol: 'FTM',
      decimals: 18,
    },
    rpcUrls: ['https://rpc.ftm.tools/'],
    blockExplorerUrls: ['https://ftmscan.com/'],
  },
  [SupportedChainId.AVALANCHE]: {
    chainId: '0xa86a', //43114
    chainName: 'Avalanche',
    nativeCurrency: {
      name: 'AVAX',
      symbol: 'AVAX',
      decimals: 18,
    },
    rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
    blockExplorerUrls: ['https://avascan.info/blockchain/c/'],
  },
};

const ethereumRpcUrl = SUPPORTED_NETWORKS[SupportedChainId.MAINNET].rpcUrls[0];
const fantomRpcUrl = SUPPORTED_NETWORKS[SupportedChainId.FANTOM].rpcUrls[0];
const polygonRpcUrl = SUPPORTED_NETWORKS[SupportedChainId.MATIC].rpcUrls[0];
const avalancheRpcUrl = SUPPORTED_NETWORKS[SupportedChainId.AVALANCHE].rpcUrls[0];
const binanceRpcUrl = SUPPORTED_NETWORKS[SupportedChainId.BSC].rpcUrls[0];

module.exports = {
  SupportedChainId,
  SUPPORTED_NETWORKS,
  ethereumRpcUrl,
  fantomRpcUrl,
  polygonRpcUrl,
  avalancheRpcUrl,
  binanceRpcUrl,
}
'''
'''--- projects/helper/ankr/prices/binance.js ---
const { fetchURL } = require("../../utils");

const getBinancePrice = async (symbol) => {
  const response = await fetchURL(
    `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`
  );
  return response?.data?.price;
};

module.exports = {
  getBinancePrice,
};

'''
'''--- projects/helper/ankr/utils.js ---
const BigNumber = require('bignumber.js');
const { toUSDTBalances } = require('../balances');
const vaultABI = require('./abis/TraderJoeVault.json');
const sdk = require("@defillama/sdk")
const UniswapV2PairContractAbi = require('./abis/UniswapV2Pair.json');

const ZERO = new BigNumber(0);

const ONE_COIN = 1e18;

const fromWei = (v) => {
  if (v) {
    return new BigNumber(v).div(1e18);
  }
  return new BigNumber(0);
};

const getVautsTvl = async (vaults, getPrice) => {
  const vaultsMap = await Promise.all(vaults.map((item) => {
    return new Promise(async (resolve) => {
      const { vault, chain } = item
      let { output: underlyingBalanceWithInvestment } = await sdk.api.abi.call({
        chain,
        target: vault,
        abi: vaultABI.find(i => i.name === 'underlyingBalanceWithInvestment')
      })

      underlyingBalanceWithInvestment = new BigNumber(underlyingBalanceWithInvestment);

      const usd = await getPrice(item);

      resolve(usd.multipliedBy(underlyingBalanceWithInvestment));
    })
  }));
  return toUSDTBalances(vaultsMap.reduce((acc, item) => acc.plus(item), new BigNumber(ZERO)));
}

function numberWithCommas(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

const formatDecimal = (value, decimal = 18, numPoint = 4, precision = 2) => {
  const data = new BigNumber(value).dividedBy(new BigNumber(10).pow(decimal));
  if (data.isGreaterThan(1)) {
    return numberWithCommas(data.dp(precision, 1).toNumber());
  }
  return data.dp(numPoint, 1).toNumber();
};

const getReserves = async (pairAddress) => {
  const { output: { _reserve0, _reserve1, _blockTimestampLast } } = await sdk.api.abi.call({
    target: pairAddress,
    abi: UniswapV2PairContractAbi.find(i => i.name === 'getReserves')
  })
  return { reserve0: _reserve0, reserve1: _reserve1, blockTimestampLast: _blockTimestampLast };
};

const getTotalSupplyOf = async (contract, chain) => {
  const { output: totalSupply } = await sdk.api.erc20.totalSupply({ target: contract })
  return new BigNumber(totalSupply);
};

const getBalanceOf = async (account, contract) => {
  const { output } = await sdk.api.erc20.balanceOf({ target: contract, owner: account, })
    return new BigNumber(output);
};

module.exports = {
  ZERO,
  ONE_COIN,
  fromWei,
  getVautsTvl,
  formatDecimal,
  numberWithCommas,
  getReserves,
  getTotalSupplyOf,
  getBalanceOf,
}
'''
'''--- projects/helper/balancer.js ---
const { request, gql } = require("graphql-request");
const { getBlock } = require("../helper/getBlock");
const { toUSDTBalances } = require("../helper/balances");

const graphQuery = gql`
query get_tvl($block: Int) {
    balancers(
        first: 5,
        block: { number: $block }
    ) {
        totalLiquidity,
    }
}
`;

function getBalancerSubgraphTvl(graphUrl, chain) {
    return async (timestamp, ethereumBlock, chainBlocks) => {
        const block = await getBlock(timestamp, chain, chainBlocks)
        const { balancers } = await request(
            graphUrl,
            graphQuery,
            {
                block
            }
        );
        return toUSDTBalances(balancers[0].totalLiquidity)
    }
}

module.exports = {
    getBalancerSubgraphTvl
};
'''
'''--- projects/helper/balances.js ---
const BigNumber = require("bignumber.js");

const usdtAddress = "0xdac17f958d2ee523a2206206994597c13d831ec7";

const toUSDT = (value, times = 1e6) => BigNumber(value).times(times).toFixed(0);

const toUSDTBalances = (value, times = 1e6) => ({
  [usdtAddress]: toUSDT(value, times),
});

module.exports = {
  toUSDT,
  toUSDTBalances,
  usdtAddress,
};

'''
'''--- projects/helper/calculateUniTvl.js ---
const BigNumber = require('bignumber.js');
const sdk = require('@defillama/sdk');
const token0 = require('./abis/token0.json');
const token1 = require('./abis/token1.json');
const getReserves = require('./abis/getReserves.json');
const factoryAbi = require('./abis/factory.json');
const { getBlock } = require('./getBlock')
const { getChainTransform, getFixBalances } = require('./portedTokens')

async function calculateUniTvl(getAddress, block, chain, FACTORY, START_BLOCK, useMulticall = false, abis = {
  getReserves
}) {
  let pairAddresses;
  if (useMulticall) {
    const pairLength = (await sdk.api.abi.call({
      target: FACTORY,
      abi: factoryAbi.allPairsLength,
      chain,
      block
    })).output
    if (pairLength === null) {
      throw new Error("allPairsLength() failed")
    }
    const pairNums = Array.from(Array(Number(pairLength)).keys())
    const pairs = (await sdk.api.abi.multiCall({
      abi: factoryAbi.allPairs,
      chain,
      calls: pairNums.map(num => ({
        target: FACTORY,
        params: [num]
      })),
      block,
      requery: true
    })).output
    pairAddresses = pairs.map(result => result.output.toLowerCase())
  } else {
    const logs = (
      await sdk.api.util
        .getLogs({
          keys: [],
          toBlock: block,
          chain,
          target: FACTORY,
          fromBlock: START_BLOCK,
          topic: 'PairCreated(address,address,address,uint256)',
        })
    ).output;

    pairAddresses = logs
      // sometimes the full log is emitted
      .map((log) =>
        typeof log === 'string' ? log : `0x${log.data.slice(64 - 40 + 2, 64 + 2)}`
      )
      // lowercase
      .map((pairAddress) => pairAddress.toLowerCase());
  }

  const [token0Addresses, token1Addresses, reserves] = await Promise.all([
    sdk.api.abi
      .multiCall({
        abi: token0,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
        requery: true
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: token1,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
        requery: true
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: abis.getReserves,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
        requery: true
      }).then(({ output }) => output),
  ]);

  const pairs = {};
  // add token0Addresses
  token0Addresses.forEach((token0Address) => {
    const tokenAddress = token0Address.output.toLowerCase();

    const pairAddress = token0Address.input.target.toLowerCase();
    pairs[pairAddress] = {
      token0Address: getAddress(tokenAddress),
    }
  });

  // add token1Addresses
  token1Addresses.forEach((token1Address) => {
    const tokenAddress = token1Address.output.toLowerCase();
    const pairAddress = token1Address.input.target.toLowerCase();
    pairs[pairAddress] = {
      ...(pairs[pairAddress] || {}),
      token1Address: getAddress(tokenAddress),
    }
  });

  const balances = reserves.reduce((accumulator, reserve, i) => {
    const pairAddress = reserve.input.target.toLowerCase();
    const pair = pairs[pairAddress] || {};

    // handle reserve0
    if (pair.token0Address) {
      const reserve0 = new BigNumber(reserve.output['0']);
      if (!reserve0.isZero()) {
        const existingBalance = new BigNumber(
          accumulator[pair.token0Address] || '0'
        );

        accumulator[pair.token0Address] = existingBalance
          .plus(reserve0)
          .toFixed()
      }
    }

    // handle reserve1
    if (pair.token1Address) {
      const reserve1 = new BigNumber(reserve.output['1']);

      if (!reserve1.isZero()) {
        const existingBalance = new BigNumber(
          accumulator[pair.token1Address] || '0'
        );

        accumulator[pair.token1Address] = existingBalance
          .plus(reserve1)
          .toFixed()
      }
    }

    return accumulator
  }, {});

  if (['cronos'].includes(chain))
    (await getFixBalances(chain))(balances);

  return balances
};

function uniTvlExport(factory, chain, transformAddressOriginal = undefined, abis) {
  return async (timestamp, _ethBlock, chainBlocks) => {
    let transformAddress;
    if (transformAddressOriginal === undefined) {
      transformAddress = await getChainTransform(chain);
    } else {
      transformAddress = await transformAddressOriginal()
    }
    const block = await getBlock(timestamp, chain, chainBlocks, true)
    return calculateUniTvl(transformAddress, block, chain, factory, 0, true, abis)
  }
}

async function simpleAddUniTvl(balances, factory, chain, timestamp, chainBlocks) {
  const transformAddress = addr => `${chain}:${addr}`;
  const block = await getBlock(timestamp, chain, chainBlocks);
  return calculateUniTvl(transformAddress, block, chain, factory, 0, true)
}

module.exports = {
  calculateUniTvl,
  uniTvlExport,
  simpleAddUniTvl
};

'''
'''--- projects/helper/cardano/blockfrost.js ---
const axios = require('axios')

const axiosObj = axios.create({
  baseURL: 'https://cardano-mainnet.blockfrost.io/api/v0',
  headers: {
    'project_id': 'mainnet9mqP0lhGpRfqcUnVjOFaTSK67Z9UdZMM',
    'Content-Type': 'application/json'
  },
  timeout: 300000,
})

async function getAddressesUTXOs(address) {
  const utxos = []
  let page = 1
  let response
  do {
    response = await axiosObj.get(`addresses/${address}/utxos?page=${page}`)
    response = response.data
    utxos.push(...response)
    page++
  } while (response.length)
  return utxos
}

async function getTxsRedeemers(utxo) {
  const { data } = await axiosObj.get(`txs/${utxo}/redeemers`)
  return data
}

async function getTxsMetadata(utxo) {
  const { data } = await axiosObj.get(`txs/${utxo}/metadata`)
  return data
}

module.exports = {
  getAddressesUTXOs,
  getTxsRedeemers,
  getTxsMetadata,
}

'''
'''--- projects/helper/chains.json ---
[
  "ethereum",
  "bsc",
  "polygon",
  "fantom",
  "avalanche",
  "arbitrum",
  "cronos",
  "harmony",
  "avax",
  "heco",
  "moonriver",
  "solana",
  "xdai",
  "optimism",
  "aurora",
  "okexchain",
  "terra",
  "eos",
  "moonbeam",
  "metis",
  "iotex",
  "celo",
  "boba",
  "kcc",
  "klaytn",
  "oasis",
  "staking",
  "smartbch",
  "fuse",
  "tron",
  "shiden",
  "stacks",
  "telos",
  "cardano",
  "pool2",
  "algorand",
  "near",
  "kadena",
  "kardia",
  "songbird",
  "csc",
  "wax",
  "syscoin",
  "velas",
  "rsk",
  "astar",
  "elastos",
  "tomochain",
  "theta",
  "gochain",
  "binance",
  "polkadot",
  "kusama",
  "energyweb",
  "borrowed",
  "wan",
  "hpb",
  "tezos",
  "ontology",
  "bitcoin",
  "curio",
  "hoo",
  "ergo",
  "conflux",
  "polis",
  "kava",
  "ronin",
  "liquidchain",
  "elrond",
  "neo",
  "nahmii",
  "ultra",
  "proton",
  "thundercore",
  "ubiq",
  "callisto",
  "cosmos",
  "palm",
  "ethereumclassic",
  "thorchain",
  "everscale",
  "icon",
  "bittorrent",
  "vechain",
  "waves",
  "vite",
  "vive",
  "meter",
  "zilliqa",
  "godwoken",
  "zksync",
  "zyx",
  "karura",
  "milkomeda",
  "evmos",
  "dfk",
  "crab",
  "clover",
  "hedera",
  "rei",
  "hydra",
  "findora",
  "osmosis",
  "bitgert",
  "reef",
  "bitcoincash",
  "doge",
  "litecoin",
  "secret",
  "sora",
  "candle",
  "bifrost",
  "stafi",
  "lachain",
  "coti",
  "obyte",
  "carbon",
  "neo3",
  "energi",
  "palette",
  "bytomsidechain",
  "starcoin",
  "fusion",
  "reichain",
  "ontology_evm",
  "terra2",
  "clv",
  "echelon",
  "multivac",
  "sx",
  "lbry",
  "rvn",
  "ore",
  "acala",
  "genshiro",
  "flow",
  "icp",
  "nova",
  "kintsugi",
  "kujira"
]
'''
'''--- projects/helper/compound.js ---

const sdk = require('@defillama/sdk');
const abi = require('./abis/compound.json');
const { getBlock } = require('./getBlock');
const { unwrapUniswapLPs } = require('./unwrapLPs');
const { requery } = require("./requery");
const { getUniqueAddresses } = require("./utils");
const { transformMetisAddress, getChainTransform, getFixBalances, } = require('./portedTokens');
const { usdtAddress } = require('./balances');
const agoraAbi = require("./../agora/abi.json");
// ask comptroller for all markets array
async function getAllCTokens(comptroller, block, chain, allMarketsAbi = abi['getAllMarkets']) {
  return (await sdk.api.abi.call({
    block,
    target: comptroller,
    params: [],
    abi: allMarketsAbi,
    chain
  })).output;
}

// returns [{cToken, underlying}]
async function getMarkets(comptroller, block, chain, cether, cetheEquivalent, blacklist = [], abis={}) {
  const marketKey = `${chain}:${comptroller}:${block}`

  if (!marketsCache[marketKey]) marketsCache[marketKey] = _getMarkets()
  return marketsCache[marketKey]

  async function _getMarkets() {
    let allCTokens = await getAllCTokens(comptroller, block, chain, abis.getAllMarkets);
    const markets = []
    const calls = []
    allCTokens.forEach(cToken => {
      cToken = cToken.toLowerCase()
      if (blacklist.includes(cToken)) return;
      if (cether && cToken === cether.toLowerCase()) {
        markets.push({ underlying: cetheEquivalent, cToken })
        return;
      }
      if (cToken === '0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5'.toLowerCase()) {
        markets.push({ underlying: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', cToken })  //cETH => WETH
        return;
      }
      if (cToken === '0x5C0401e81Bc07Ca70fAD469b451682c0d747Ef1c'.toLowerCase() && chain === 'avax') {
        markets.push({ underlying: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', cToken })
        return;
      }
      if (['0xd2ec53e8dd00d204d3d9313af5474eb9f5188ef6', '0x0aeadb9d4c6a80462a47e87e76e487fa8b9a37d7'].includes(cToken) && chain === 'rsk') {
        markets.push({ underlying: '0x542fda317318ebf1d3deaf76e0b632741a7e677d', cToken })
        return;
      }

      calls.push({ target: cToken })
    })

    const underlyings = await sdk.api.abi.multiCall({
      abi: abi['underlying'],
      calls,
      chain, block,
    })

    await requery(underlyings, chain, block, abi)

    const isCeth = underlyings.output.find(i => !i.output)
    if (isCeth)
      throw new Error(`${isCeth.input.target} market rugged, is that market CETH?`)

    underlyings.output.forEach(({ output, input: { target } }) => markets.push({ cToken: target, underlying: output }))

    return markets;
  }
}
async function unwrapPuffTokens(balances, lpPositions, block) {
  const pricePerShare = (await sdk.api.abi.multiCall({
    block,
    abi: agoraAbi.getPricePerFullShare,
    calls: lpPositions.map(p => ({
      target: p.token
    })),
    chain: 'metis'
  })).output;
  const underlying = (await sdk.api.abi.multiCall({
    block,
    abi: agoraAbi.want,
    calls: lpPositions.map(p => ({
      target: p.token
    })),
    chain: 'metis'
  })).output;

  const newLpPositions = [];
  for (let i = 0; i < lpPositions.length; i++) {
    newLpPositions.push({ balance: lpPositions[i].balance * pricePerShare[i].output / 10 ** 18, token: underlying[i].output })
  };

  await unwrapUniswapLPs(
    balances,
    newLpPositions,
    block,
    'metis',
    transformMetisAddress()
  );
};

let marketsCache = {}

function getCompoundV2Tvl(comptroller, chain = "ethereum", transformAdress,
  cether = "0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5", cetheEquivalent = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  borrowed = false, checkForLPTokens = undefined,
  {
    blacklistedTokens = [],
    abis = {
      getAllMarkets: abi['getAllMarkets']
    }
  } = {}) {
  blacklistedTokens = blacklistedTokens.map(i => i.toLowerCase())
  return async (timestamp, ethBlock, chainBlocks) => {
    if (!transformAdress) transformAdress = await getChainTransform(chain)
    const block = await getBlock(timestamp, chain, chainBlocks, true);
    let balances = {};
    let markets = await getMarkets(comptroller, block, chain, cether, cetheEquivalent, [], abis);
    const cTokenCalls = markets.map(market => ({
      target: market.cToken,
    }))
    // Get V2 tokens locked
    let v2Locked = await sdk.api.abi.multiCall({
      block,
      chain,
      calls: cTokenCalls,
      abi: borrowed ? abi.totalBorrows : abi['getCash'],
    });

    let symbols;
    if (checkForLPTokens !== undefined) {
      symbols = await sdk.api.abi.multiCall({
        block,
        chain,
        calls: cTokenCalls,
        abi: "erc20:symbol",
      });
    }

    const lpPositions = []
    markets.forEach((market, idx) => {
      const underlying = market.underlying.toLowerCase()
      if (blacklistedTokens.includes(underlying)) return;
      let getCash = v2Locked.output.find((result) => result.input.target === market.cToken);
      if (checkForLPTokens !== undefined && checkForLPTokens(symbols.output[idx].output)) {
        lpPositions.push({
          token: underlying,
          balance: getCash.output
        })
      } else {
        sdk.util.sumSingleBalance(balances, transformAdress(underlying), getCash.output)
      }
    });
    if (["harmony", 'oasis', 'bsc'].includes(chain)) {
      const fixBalances = await getFixBalances(chain)
      fixBalances(balances);
    }

    if (comptroller == "0x92DcecEaF4c0fDA373899FEea00032E8E8Da58Da") {
      await unwrapPuffTokens(balances, lpPositions, block)
    } else if (lpPositions.length > 0) {
      await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAdress)
    }
    return balances;
  }
}

const BigNumber = require('bignumber.js').default;
const { toUSDTBalances } = require('./balances');

// ask comptroller for oracle
async function getOracle(block, chain, comptroller, oracleAbi) {
  const { output: oracle } = await sdk.api.abi.call({
    target: comptroller,
    abi: oracleAbi,
    block,
    chain: chain,
  });
  return oracle;
}

async function getUnderlyingDecimalsMultiple(block, chain, marketData, cether) {
  const response = {}
  const calls = marketData.map(i => ({ target: i.underlying }))
  const { output: decimals } = await sdk.api.abi.multiCall({
    calls,
    abi: "erc20:decimals",
    block,
    chain,
  })

  decimals.forEach(({ output}, i) => {
    response[marketData[i].cToken] = output
  })

  return response
}

async function getCashMultiple(block, chain, tokens, borrowed) {
  const calls = tokens.map(t => ({ target: t }))
  const { output: cash } = await sdk.api.abi.multiCall({
    calls,
    abi: borrowed ? abi.totalBorrows : abi['getCash'],
    block,
    chain,
  });
  const response = {}
  cash.forEach(({ input, output }) => response[input.target] = output)
  return response;
}

async function getUnderlyingPriceMultiple(block, chain, oracle, tokens, methodAbi) {
  const calls = tokens.map(t => ({ params: [t] }))
  const { output: underlyingPrice } = await sdk.api.abi.multiCall({
    target: oracle,
    abi: methodAbi,
    block,
    chain,
    calls,
  });
  const response = {}
  underlyingPrice.forEach(({ input, output }) => response[input.params[0]] = output)
  return response;
}

function getCompoundUsdTvl(comptroller, chain, cether, borrowed, abis = {
  oracle: abi['oracle'],
  underlyingPrice: abi['getUnderlyingPrice'],
  getAllMarkets: abi['getAllMarkets']
}, {
  blacklist = []
} = {}) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const block = await getBlock(timestamp, chain, chainBlocks, true);
    let tvl = new BigNumber('0');
    blacklist = blacklist.map(i => i.toLowerCase())
    const marketData = await getMarkets(comptroller, block, chain, cether, undefined, blacklist, abis)
    let allMarkets = marketData.map(i => i.cToken);
    // allMarkets = allMarkets.filter(token => !blacklist.includes(token.toLowerCase())) // taken care of by getMarkets
    let oracle = await getOracle(block, chain, comptroller, abis.oracle);
    const amounts = await getCashMultiple(block, chain, allMarkets, borrowed)
    const decimalsAll = await getUnderlyingDecimalsMultiple(block, chain, marketData, cether)
    const underlyingPrices = await getUnderlyingPriceMultiple(block, chain, oracle, allMarkets, abis.underlyingPrice)

    allMarkets.forEach(token => {
      let amount = new BigNumber(amounts[token]);
      let decimals = decimalsAll[token];
      let locked = amount.div(10 ** decimals);
      let underlyingPrice = new BigNumber(underlyingPrices[token]).div(10 ** (18 + 18 - decimals))
      tvl = tvl.plus(locked.times(underlyingPrice));
    })
    return toUSDTBalances(tvl.toNumber());
  }
}

function compoundExports(comptroller, chain, cether, cetheEquivalent, transformAdressRaw, checkForLPTokens, { blacklistedTokens = [] } = {}) {
  if (cether !== undefined && cetheEquivalent === undefined) {
    throw new Error("You need to define the underlying for native cAsset")
  }
  return {
    tvl: getCompoundV2Tvl(comptroller, chain, transformAdressRaw, cether, cetheEquivalent, false, checkForLPTokens, { blacklistedTokens }),
    borrowed: getCompoundV2Tvl(comptroller, chain, transformAdressRaw, cether, cetheEquivalent, true, checkForLPTokens, { blacklistedTokens })
  }
}

function compoundExportsWithAsyncTransform(comptroller, chain, cether, cetheEquivalent, transformAdressConstructor) {
  return {
    tvl: async (...args) => {
      const transformAddress = await transformAdressConstructor()
      return getCompoundV2Tvl(comptroller, chain, transformAddress, cether, cetheEquivalent)(...args)
    },
    borrowed: async (...args) => {
      const transformAddress = await transformAdressConstructor()
      return getCompoundV2Tvl(comptroller, chain, transformAddress, cether, cetheEquivalent, true)(...args)
    },
  }
}

function fullCoumpoundExports(comptroller, chain, cether, cetheEquivalent, transformAdress) {
  return {
    timetravel: true,
    doublecounted: false,
    [chain]: compoundExports(comptroller, chain, cether, cetheEquivalent, transformAdress)
  }
}

function usdCompoundExports(comptroller, chain, cether, abis, options = {}) {
  return {
    tvl: getCompoundUsdTvl(comptroller, chain, cether, false, abis, options,),
    borrowed: getCompoundUsdTvl(comptroller, chain, cether, true, abis, options,)
  }
}

function compoundExportsWithDifferentBase(comptroller, chain, token) {
  const raw = usdCompoundExports(comptroller, chain)
  async function tvl(...params) {
    const tvl = await raw.tvl(...params)
    return {
      [token]: Number(tvl[usdtAddress]) / 1e6
    }
  }

  async function borrowed(...params) {
    const tvl = await raw.borrowed(...params)
    return {
      [token]: Number(tvl[usdtAddress]) / 1e6
    }
  }
  return {
    tvl,
    borrowed
  }
}

module.exports = {
  getCompoundV2Tvl,
  compoundExports,
  getCompoundUsdTvl,
  compoundExportsWithAsyncTransform,
  fullCoumpoundExports,
  usdCompoundExports,
  compoundExportsWithDifferentBase
};

'''
'''--- projects/helper/curvePools.js ---
module.exports = {
  // Curve.fi Factory USD Metapool: moUSD 
  '0x162b21ba1a90dd9384c615192fa4053217d2a8db': {
    swapContract: '0x162B21ba1a90Dd9384C615192FA4053217D2A8Db',
    underlyingTokens: ['0x9fFFb2F49adFC231B44dDCFf3FfCF0E81b06430A', '0x19793b454d3afc7b454f206ffe95ade26ca6912c'],
  },
  // USDS3CRV
  '0xde495223f7cd7ee0cde1addbd6836046bbdf3ad3': {
    swapContract: '0xde495223f7cd7ee0cde1addbd6836046bbdf3ad3',
    underlyingTokens: ['0x6c3f90f043a72fa612cbac8115ee7e52bde6e490', '0x45fdb1b92a649fb6a64ef1511d3ba5bf60044838']
  },
  // USDSam3CRV
  '0xcf5186491739aac19db943d71a9b9b759f3afabf': {
    swapContract: '0xcf5186491739aac19db943d71a9b9b759f3afabf',
    underlyingTokens: ['0x2f1b1662A895C6Ba01a99DcAf56778E7d77e5609', '0x19793B454D3AfC7b454F206Ffe95aDE26cA6912c']
  },
  // USDSav3CRV
  '0x90d5233b53436767fecacd1a783d3da8cc7395ed': {
    swapContract: '0x90D5233b53436767fecACD1a783D3dA8Cc7395ED',
    underlyingTokens: ['0xab05b04743e0aeaf9d2ca81e5d3b8385e4bf961e', '0x5b5cfe992adac0c9d48e05854b2d91c73a003858']
  },
  // ARTHuval3PS
  '0x4cfaabd5920021359bb22bb6924cce708773b6ac': {
    swapContract: '0x1d4b4796853aeda5ab457644a18b703b6ba8b4ab',
    underlyingTokens: ['0x88fd584dF3f97c64843CD474bDC6F78e398394f4', '0x5b5bd8913d766d005859ce002533d4838b0ebbb5'],
  },
  // val3PS
  '0x5b5bd8913d766d005859ce002533d4838b0ebbb5': {
    swapContract: '0x19ec9e3f7b21dd27598e7ad5aae7dc0db00a806d',
    underlyingTokens: ['0xaed19dab3cd68e4267aec7b2479b1ed2144ad77f', '0xa6fdea1655910c504e974f7f1b520b74be21857b', '0x5f7f6cb266737b89f7af86b30f03ae94334b83e9'],
  },
  // ARTHu3PS
  '0xb38b49bae104bbb6a82640094fd61b341a858f78': {
    swapContract: '0x98245bfbef4e3059535232d68821a58abb265c45',
    underlyingTokens: ['0x88fd584dF3f97c64843CD474bDC6F78e398394f4', '0xaf4de8e872131ae328ce21d909c74705d3aaf452'],
  },
  // 3EPS
  '0xaf4de8e872131ae328ce21d909c74705d3aaf452': {
    swapContract: '0x160caed03795365f3a589f10c379ffa7d75d4e76',
    underlyingTokens: ['0xe9e7cea3dedca5984780bafc599bd69add087d56', '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', '0x55d398326f99059ff775485246999027b3197955'],
  },
  '0x6c3f90f043a72fa612cbac8115ee7e52bde6e490': {
    swapContract: '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7',
    underlyingTokens: ['0xdac17f958d2ee523a2206206994597c13d831ec7', '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0x6b175474e89094c44da98b954eedeac495271d0f'],
  },
  '0x075b1bb99792c9e1041ba13afef80c91a1e70fb3': {
    swapContract: '0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714',
    underlyingTokens: ['0xeb4c2781e4eba804ce9a9803c67d0893436bb27d', '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6'],
  },
  // Nerve
  '0xf2511b5e4fb0e5e2d123004b672ba14850478c14': {
    swapContract: '0x1B3771a66ee31180906972580adE9b81AFc5fCDc',
    underlyingTokens: ['0xe9e7cea3dedca5984780bafc599bd69add087d56', '0x55d398326f99059ff775485246999027b3197955', '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d'],
  },
  // DOP-LP BSC
  '0x9116f04092828390799514bac9986529d70c3791': {
    swapContract: '0x5162f992EDF7101637446ecCcD5943A9dcC63A8A',
    underlyingTokens: [
      '0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3',
      '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
      '0x55d398326f99059fF775485246999027B3197955',
      '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d'
    ],
  },
  // DOP-2P-LP BSC
  '0x124166103814e5a033869c88e0f40c61700fca17': {
    swapContract: '0x449256e20ac3ed7F9AE81c2583068f7508d15c02',
    underlyingTokens: [
      '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
      '0x55d398326f99059fF775485246999027B3197955'
    ],
  },
  // DOP-UST-LP BSC
  '0x7edcdc8cd062948ce9a9bc38c477e6aa244dd545': {
    swapContract: '0x830e287ac5947B1C0DA865dfB3Afd7CdF7900464',
    underlyingTokens: [
      '0x23396cF899Ca06c4472205fC903bDB4de249D6fC',
      '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
      '0x55d398326f99059fF775485246999027B3197955'
    ],
  },
  // DOP-3P-LP BSC
  '0xaa5509ce0ecea324bff504a46fc61eb75cb68b0c': {
    swapContract: '0x61f864a7dFE66Cc818a4Fd0baabe845323D70454',
    underlyingTokens: [
      '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
      '0x55d398326f99059fF775485246999027B3197955',
      '0xfF54da7CAF3BC3D34664891fC8f3c9B6DeA6c7A5'
    ],
  },
  // 3P-QLP BSC
  '0xb0f0983b32352a1cfaec143731ddd8a5f6e78b1f': {
    swapContract: '0x3ED4b2070E3DB5eF5092F504145FB8150CfFE5Ea',
    underlyingTokens: [
      '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56',
      '0x55d398326f99059fF775485246999027B3197955',
      '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d'
    ],
  },
  // IS3USD Polygon
  '0xb4d09ff3dA7f9e9A2BA029cb0A81A989fd7B8f17': {
    swapContract: '0x837503e8A8753ae17fB8C8151B8e6f586defCb57',
    underlyingTokens: [
      '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063',
      '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
      '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
    ]
  },
  // am3CRV Polygon
  '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171': {
    swapContract: '0x445FE580eF8d70FF569aB36e80c647af338db351',
    underlyingTokens: [
      '0x27F8D03b3a2196956ED754baDc28D73be8830A6e',
      '0x1a13F4Ca1d028320A707D99520AbFefca3998b7F',
      '0x60D55F02A771d515e077c9C2403a1ef324885CeC'
    ]
  },
  // sCRV Eth
  '0xc25a3a3b969415c80451098fa907ec722572917f': {
    swapContract: '0xA5407eAE9Ba41422680e2e00537571bcC53efBfD',
    underlyingTokens: [
      '0xdac17f958d2ee523a2206206994597c13d831ec7',
      '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
      '0x6b175474e89094c44da98b954eedeac495271d0f',
      '0x57ab1ec28d129707052df4df418d58a2d46d5f51'
    ]
  },
  // renBTC Eth
  '0x49849c98ae39fff122806c06791fa73784fb3675': {
    swapContract: '0x93054188d876f558f4a66B2EF1d97d16eDf0895B',
    underlyingTokens: [
      '0xeb4c2781e4eba804ce9a9803c67d0893436bb27d',
      '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599'
    ]
  },
  // lusd Eth
  '0xed279fdd11ca84beef15af5d39bb4d4bee23f0ca': {
    swapContract: '0xed279fdd11ca84beef15af5d39bb4d4bee23f0ca',
    underlyingTokens: [
      '0x5f98805A4E8be255a32880FDeC7F6728C6568bA0',
      '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490'
    ]
  },
  // steCRV Eth
  '0x06325440d014e39736583c165c2963ba99faf14e': {
    swapContract: '0xdc24316b9ae028f1497c275eb9192a3ea0f67022',
    underlyingTokens: ['0xae7ab96520de3a18e5e111b5eaab095312d7fe84']
  },
  // fraxCRV Eth
  '0xd632f22692fac7611d2aa1c0d552930d43caed3b': {
    swapContract: '0xd632f22692fac7611d2aa1c0d552930d43caed3b',
    underlyingTokens: [
      '0x853d955acef822db058eb8505911ed77f175b99e',
      '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490'
    ]
  },
  // seCRV Eth
  '0xa3d87fffce63b53e0d54faa1cc983b7eb0b74a9c': {
    swapContract: '0xc5424B857f758E906013F3555Dad202e4bdB4567',
    underlyingTokens: ['0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb']
  },
  // btcCRV Polygon
  '0xf8a57c1d3b9629b77b6726a042ca48990a84fb49': {
    swapContract: '0xC2d95EEF97Ec6C17551d45e77B590dc1F9117C67',
    underlyingTokens: [
      '0x5c2ed810328349100A66B82b78a1791B101C9D61',
      '0xDBf31dF14B66535aF65AaC99C32e9eA844e14501'
    ]
  },
  // tricryptoCRV v1 Polygon
  '0x8096ac61db23291252574D49f036f0f9ed8ab390': {
    swapContract: '0x751B1e21756bDbc307CBcC5085c042a0e9AaEf36',
    underlyingTokens: [
      '0x28424507fefb6f7f8e9d3860f56504e4e5f5f390',
      '0x5c2ed810328349100a66b82b78a1791b101c9d61',
      '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171'
    ]
  },
  // tricryptoCRV v2 Polygon
  '0xbece5d20a8a104c54183cc316c8286e3f00ffc71': {
    swapContract: '0x92577943c7aC4accb35288aB2CC84D75feC330aF',
    underlyingTokens: [
      '0x28424507fefb6f7f8e9d3860f56504e4e5f5f390',
      '0x5c2ed810328349100a66b82b78a1791b101c9d61',
      '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171'
    ]
  },
  // tricryptoCRV v3 Polygon
  '0xdad97f7713ae9437fa9249920ec8507e5fbb23d3': {
    swapContract: '0x92215849c439e1f8612b6646060b4e3e5ef822cc',
    underlyingTokens: [
      '0x28424507fefb6f7f8e9d3860f56504e4e5f5f390',
      '0x5c2ed810328349100a66b82b78a1791b101c9d61',
      '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171'
    ]
  },
  // 4eur-f Polygon
  '0xad326c253a84e9805559b73a08724e11e49ca651': {
    swapContract: '0xad326c253a84e9805559b73a08724e11e49ca651',
    underlyingTokens: [
      '0xe111178a87a3bff0c8d18decba5798827539ae99',
      '0x4e3decbb3645551b8a19f0ea1678079fcb33fb4c',
      '0x7BDF330f423Ea880FF95fC41A280fD5eCFD3D09f',
      '0xe2aa7db6da1dae97c5f5c6914d285fbfcc32a128'
    ]
  },
  // gondolaDAIeUSDTe Avax
  '0xd7d4a4c67e9c1f5a913bc38e87e228f4b8820e8a': {
    swapContract: '0xCF97190fAAfea63523055eBd139c008cdb4468eB',
    underlyingTokens: [
      '0xd586E7F844cEa2F87f50152665BCbc2C279D8d70',
      '0xc7198437980c041c805a1edcba50c1ce5db95118'
    ]
  },
  // gondolaYAKPool Avax
  '0x7f1e6a8730fec77f27daeecd82e1941518383a62': {
    swapContract: '0xd72Dc856868f964D37D01CeA7A7a3c1F4da4F98f',
    underlyingTokens: [
      '0xddaaad7366b455aff8e7c82940c43ceb5829b604',
      '0x59414b3089ce2af0010e7523dea7e2b35d776ec7'
    ]
  },
  // gondolaUSDCe Avax
  '0x4dc5a6308338e540aa97faab7fd2e03876075413': {
    swapContract: '0x4b941276eb39d114c89514791d073a085acba3c0',
    underlyingTokens: [
      '0xc7198437980c041c805a1edcba50c1ce5db95118',
      '0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664'
    ]
  },
  // av3CRV Avax
  '0x1337bedc9d22ecbe766df105c9623922a27963ec': {
    swapContract: '0x7f90122BF0700F9E7e1F688fe926940E8839F353',
    underlyingTokens: [
      '0x47AFa96Cdc9fAb46904A55a6ad4bf6660B53c38a',
      '0x46A51127C3ce23fb7AB1DE06226147F446e4a857',
      '0x532E6537FEA298397212F09A61e03311686f548e'
    ]
  },
  // MIM-fUSDT-USDC Fantom
  '0x2dd7c9371965472e5a5fd28fbe165007c61439e1': {
    swapContract: '0x2dd7C9371965472E5A5fD28fbE165007c61439E1',
    underlyingTokens: [
      '0x82f0B8B456c1A451378467398982d4834b6829c1',
      '0x049d68029688eAbF473097a2fC38ef61633A3C7A',
      '0x04068DA6C83AFCFA0e13ba15A6696662335D5B75'
    ]
  },
  // Dai-Usdc Fantom
  '0x27e611fd27b276acbd5ffd632e5eaebec9761e40': {
    swapContract: '0x27E611FD27b276ACbd5Ffd632E5eAEBEC9761E40',
    underlyingTokens: [
      '0x04068DA6C83AFCFA0e13ba15A6696662335D5B75',
      '0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E'
    ]
  },
  // gDai-gUSDC-gUSDT Fantom
  '0xd02a30d33153877bc20e5721ee53dedee0422b2f': {
    swapContract: '0x0fa949783947Bf6c1b171DB13AEACBB488845B3f',
    underlyingTokens: [
      '0x940F41F0ec9ba1A34CF001cc03347ac092F5F6B5',
      '0x07E6332dD090D287d3489245038daF987955DCFB',
      '0xe578C856933D8e1082740bf7661e379Aa2A30b26'
    ]
  },
  // tricrypto Fantom
  '0x58e57ca18b7a47112b877e31929798cd3d703b0f': {
    swapContract: '0x3a1659Ddcf2339Be3aeA159cA010979FB49155FF',
    underlyingTokens: [
      '0x74b23882a30290451A17c44f4F05243b6b58C76d',
      '0x321162Cd933E2Be498Cd2267a90534A804051b11',
      '0x049d68029688eAbF473097a2fC38ef61633A3C7A'
    ]
  },
  // btc-renbtc Fantom
  '0x5b5cfe992adac0c9d48e05854b2d91c73a003858': {
    swapContract: '0x3eF6A01A0f81D6046290f3e2A8c5b843e738E604',
    underlyingTokens: [
      '0xDBf31dF14B66535aF65AaC99C32e9eA844e14501',
      '0x321162Cd933E2Be498Cd2267a90534A804051b11'
    ]
  },
  // mim pool avax
  '0xaea2e71b631fa93683bcf256a8689dfa0e094fcd': {
    swapContract: '0xaea2e71b631fa93683bcf256a8689dfa0e094fcd',
    underlyingTokens: [
      '0xc7198437980c041c805a1edcba50c1ce5db95118',
      '0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664',
      '0x130966628846bfd36ff31a822705796e8cb8c18d',
    ]
  },
  // EURS/sEUR Eth
  '0x194ebd173f6cdace046c53eacce9b953f28411d1': {
    swapContract: '0x0ce6a5ff5217e38315f87032cf90686c96627caa',
    underlyingTokens: [
      '0xd71ecff9342a5ced620049e616c5035f1db98620',
      '0xdb25f211ab05b1c97d595516f45794528a807ad8'
    ]
  },
  // aDAI/aUSDC/aUSDT (a3CRV) Eth
  '0xfd2a8fa60abd58efe3eee34dd494cd491dc14900': {
    swapContract: '0xdebf20617708857ebe4f679508e7b7863a8a8eee',
    underlyingTokens: [
      '0x028171bca77440897b824ca71d1c56cac55b68a3',
      '0xbcca60bb61934080951369a648fb03df4f96263c',
      '0x3ed3b47dd13ec9a98b44e6204a523e766b225811'
    ]
  },
  // MIM / USDT/USDC/DAI Eth
  '0x5a6a4d54456819380173272a5e8e9b9904bdf41b': {
    swapContract: '0x5a6A4D54456819380173272A5E8E9B9904BdF41B',
    underlyingTokens: [
      '0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3',
      '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490',
    ],
  },
  // ETH / alETH Eth
  '0xc4c319e2d4d66cca4464c0c2b32c9bd23ebe784e': {
    swapContract: '0xC4C319E2D4d66CcA4464C0c2B32c9Bd23ebe784e',
    underlyingTokens: ['0x0100546F2cD4C9D97f798fFC9755E47865FF7Ee6'],
  },
  // LINK / sLINK Eth
  '0xcee60cfa923170e4f8204ae08b4fa6a3f5656f3a': {
    swapContract: '0xF178C0b5Bb7e7aBF4e12A4838C7b7c5bA2C623c0',
    underlyingTokens: [
      '0x514910771AF9Ca656af840dff83E8264EcF986CA',
      '0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6',
    ],
  },
  // 3CRV Harmony
  '0xc5cfada84e902ad92dd40194f0883ad49639b023': {
    swapContract: '0xc5cfada84e902ad92dd40194f0883ad49639b023',
    underlyingTokens: [
      '0xef977d2f931c1978db5f6747666fa1eacb0d0339',
      '0x985458e523db3d53125813ed68c274899e9dfab4',
      '0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f'
    ]
  },
  // VST-FRAX Arbitrum
  '0x59bf0545fca0e5ad48e13da269facd2e8c886ba4': {
    swapContract: '0x59bf0545fca0e5ad48e13da269facd2e8c886ba4',
    underlyingTokens: [
      '0x64343594ab9b56e99087bfa6f2335db24c2d1f17',
      '0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F',
    ]
  },
  // pBTC-sBTC Ethereum
  '0xde5331ac4b3630f94853ff322b66407e0d6331e8': {
    swapContract: '0x7F55DDe206dbAD629C080068923b36fe9D6bDBeF',
    underlyingTokens: [
      '0x5228a22e72ccC52d415EcFd199F99D0665E7733b',
      '0x075b1bb99792c9e1041ba13afef80c91a1e70fb3',
    ]
  },
  // TOKEMAKS START
  '0x9462f2b3c9beea8afc334cdb1d1382b072e494ea': {
    swapContract: '0x9462f2b3c9beea8afc334cdb1d1382b072e494ea',
    underlyingTokens: ['0x6BeA7CFEF803D1e3d5f7C0103f7ded065644e197']
  },
  '0x50b0d9171160d6eb8aa39e090da51e7e078e81c4': {
    swapContract: '0x50b0d9171160d6eb8aa39e090da51e7e078e81c4',
    underlyingTokens: ['0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F']
  },
  '0xcaf8703f8664731ced11f63bb0570e53ab4600a9': {
    swapContract: '0xcaf8703f8664731ced11f63bb0570e53ab4600a9',
    underlyingTokens: ['0x4104b135DBC9609Fc1A9490E61369036497660c8']
  },
  '0x01fe650ef2f8e2982295489ae6adc1413bf6011f': {
    swapContract: '0x01fe650ef2f8e2982295489ae6adc1413bf6011f',
    underlyingTokens: ['0x9C4A4204B79dd291D6b6571C5BE8BbcD0622F050']
  },
  '0xc250b22d15e43d95fbe27b12d98b6098f8493eac': {
    swapContract: '0xc250b22d15e43d95fbe27b12d98b6098f8493eac',
    underlyingTokens: ['0xc770EEfAd204B5180dF6a14Ee197D99d808ee52d']
  },
  '0x0437ac6109e8a366a1f4816edf312a36952db856': {
    swapContract: '0x0437ac6109e8a366a1f4816edf312a36952db856',
    underlyingTokens: ['0x6B3595068778DD592e39A122f4f5a5cF09C90fE2']
  },
  '0x9001a452d39a8710d27ed5c2e10431c13f5fba74': {
    swapContract: '0x9001a452d39a8710d27ed5c2e10431c13f5fba74',
    underlyingTokens: ['0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF']
  },
  '0x961226b64ad373275130234145b96d100dc0b655': {
    swapContract: '0x961226b64ad373275130234145b96d100dc0b655',
    underlyingTokens: ['0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0']
  },
  // TOKEMAKS END

}
'''
'''--- projects/helper/dexpad.js ---
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");

const { unwrapUniswapLPs } = require("./unwrapLPs");
const symbol = require("./abis/symbol.json");
const getPairFactory = require("./abis/getPair.json");

const { isLP } = require("./utils");
const { getChainTransform, getFixBalances } = require("./portedTokens");

async function getDexPadLpsCoreValue(
  block,
  chain,
  contract, // locker contract address.
  getNumLockedTokensABI, // ABI to retrieve the total amount of tokens locked.
  getLockedTokenAtIndexABI, // ABI to retrieve tokens at a specific lock index.
  trackedTokens = [], // liquid assets for tokens to be paired against (ETH, USD etc.).
  pool2 = [], // pool2 pair to be excluded from the balances.
  isMixedTokenContract = false,
  factory = null
) {
  let balances = {};

  const getLocks = Number(
    (await sdk.api.abi.call({
      abi: getNumLockedTokensABI,
      target: contract,
      chain: chain,
      block: block
    })).output
  );

  let lockedLPs = [];
  const lockIds = Array.from(Array(getLocks).keys());
  {
    const lps = (await sdk.api.abi.multiCall({
      abi: getLockedTokenAtIndexABI,
      calls: lockIds.map(lockid => ({
        target: contract,
        params: lockid
      })),
      chain: chain,
      block: block
    })).output;

    lps.forEach(lp => {
      if (lp.success && !pool2.includes(lp)) {
        const lpToken = lp.output.toLowerCase();
        lockedLPs.push(lpToken);
      }
    });
  }

  return isMixedTokenContract // check if purely an lp locker or contains lps and tokens
    ? getTokensAndLPsTrackedValue(
        balances,
        lockedLPs,
        contract,
        factory,
        trackedTokens,
        block,
        chain
      )
    : getLPsTrackedValue(
        balances,
        lockedLPs,
        contract,
        factory,
        trackedTokens,
        block,
        chain
      );
}

// get pairs made of 2 core assets to avoid double counting their balances
async function generateWhitelistedPairs(trackedTokens, factory, block, chain) {
  
  if (!Array.isArray(trackedTokens))
    throw new Error("must pass an array of base tokens to trackedTokens");

  let matchedBaseTokens = [];
  if (trackedTokens.length > 1) {
    trackedTokens.forEach(token0 =>
      trackedTokens.forEach(token1 => {
        if (!(token0 == token1)) matchedBaseTokens.push([token0, token1]);
      })
    );
  }

  let whitelistedBasePairs = new Set();

  {
    const basePairs = (await sdk.api.abi.multiCall({
      abi: getPairFactory,
      calls: Object.values(matchedBaseTokens).map(value => ({
        target: factory,
        params: value
      })),
      chain: chain,
      block: block
    })).output;

    basePairs.forEach(pair => {
      if (pair.success) {
        const basePair = pair.output.toLowerCase();
        if (basePair != "0x0000000000000000000000000000000000000000")
          whitelistedBasePairs.add(basePair);
      }
    });
  }
  return whitelistedBasePairs;
}
// mixed token contracts
async function getTokensAndLPsTrackedValue(
  balances,
  tokens,
  contract,
  factory,
  trackedTokens,
  block,
  chain
) {
  const whitelistedBasePairs = await generateWhitelistedPairs(
    trackedTokens,
    factory,
    block,
    chain
  );

  const [tokenSymbols, tokenBalances] = await Promise.all([
    sdk.api.abi
      .multiCall({
        abi: symbol,
        chain,
        calls: tokens.map(token => ({
          target: token
        })),
        block
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: "erc20:balanceOf",
        chain,
        calls: tokens.map(token => ({
          target: token,
          params: contract
        })),
        block
      })
      .then(({ output }) => output)
  ]);
  let lps = {};
  let filteredLps = {};

  tokenBalances.forEach(balance => {
    const lpAddress = balance.input.target.toLowerCase();
    lps[lpAddress] = {
      balance: balance.output
    };
  });

  tokenSymbols.forEach(tokenSymbol => {
    const pairAddress = tokenSymbol.input.target.toLowerCase();
    lps[pairAddress].symbol = tokenSymbol.output;
  });

  Object.entries(lps).forEach(([key, value]) => {
    if (value.symbol && value.balance) {
      if (value.balance > 0 && isLP(value.symbol, key, chain)) {
        let lpBalance = whitelistedBasePairs.has(key)
          ? value.balance
          : BigNumber(value.balance).times(BigNumber(2)).toFixed(0);
        filteredLps[key] = lpBalance;
      }
    }
  });

  let lpBalances = [];
  Object.entries(filteredLps).forEach(([key, value]) => {
    lpBalances.push({
      balance: value,
      token: key
    });
  });
  const chainTransform = await getChainTransform(chain)

  await unwrapUniswapLPs(
    balances,
    lpBalances,
    block,
    chain,
    addr => chainTransform(addr)
  );

  let formattedWhitelist = trackedTokens.map(address => `${chain}:${address}`);

  balances = Object.keys(balances)
    .filter(balance => formattedWhitelist.includes(balance))
    .reduce((obj, balance) => {
      obj[balance] = balances[balance];
      return obj;
    }, {});

  return balances;
}

// pure lp contracts
async function getLPsTrackedValue(
  balances,
  lpTokens,
  contract,
  factory,
  trackedTokens,
  block,
  chain
) {
  if (!Array.isArray(trackedTokens))
    throw new Error("must pass an array of base tokens to trackedTokens");
  const whitelistedBasePairs = await generateWhitelistedPairs(
    trackedTokens,
    factory,
    block,
    chain
  );

  let lps = [];
  {
    const tokenBalances = (await sdk.api.abi.multiCall({
      abi: "erc20:balanceOf",
      calls: lpTokens.map(lpToken => ({
        target: lpToken,
        params: contract
      })),
      chain: chain,
      block: block
    })).output;
    tokenBalances.forEach(balance => {
      if (balance.success) {
        const lpAddress = balance.input.target.toLowerCase();
        let lpBalance = whitelistedBasePairs.has(lpAddress)
          ? balance.output
          : BigNumber(balance.output).times(BigNumber(2)).toFixed(0);
        if (lpBalance > 0) {
          lps[lpAddress] = lpBalance;
        }
      }
    });
  }

  let lpBalances = [];
  Object.entries(lps).forEach(([key, value]) => {
    lpBalances.push({
      balance: value,
      token: key
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpBalances,
    block,
    chain,
    addr => `${chain}:${addr}`
  );
  let formattedWhitelist = trackedTokens.map(addr => `${chain}:${addr}`);

  console.log("before", balances)
  balances = Object.keys(balances)
    .filter(balance => formattedWhitelist.includes(balance))
    .reduce((obj, balance) => {
      obj[balance] = balances[balance];
      return obj;
    }, {});
    console.log("after",balances)
    if(chain === 'kava'){
      return (await getFixBalances(chain))(balances)
    }
  return balances;
}

module.exports = {
  getDexPadLpsCoreValue,
  getTokensAndLPsTrackedValue,
  getLPsTrackedValue
};

'''
'''--- projects/helper/eos.js ---
const axios = require('axios')
const retry = require('../helper/retry')

const RPC_ENDPOINTS = {
    'eos': 'https://eos.greymass.com',
    'wax': 'https://wax.greymass.com',
    'telos': 'https://telos.greymass.com',
}

async function get_currency_balance(code, account, symbol, chain = "eos") {
    const response = await retry(async () => await axios.default.post(`${RPC_ENDPOINTS[chain]}/v1/chain/get_currency_balance`, {code, account, symbol}));
    try {
        return Number(response.data[0].split(" ")[0]);
    } catch (e) {
        return 0;
    }
}

/**
 * Get symbol precision
 *
 * @example
 *
 * get_precision("EOS");
 * // => 4
 * get_precision("4,EOS");
 * // => 4
 * get_precision("8,WAX");
 * // => 8
 */
function get_precision( symbol )
{
    if ( symbol.includes(",") ) return symbol.split(",")[0];
    if ( symbol == "EOS") return 4;
    if ( symbol == "TLOS") return 4;
    if ( symbol == "WAX") return 8;
    return 4;
}

// native staked CPU/Net & REX should be counted as liquid balance
async function get_staked(account_name, symbol, chain = "eos") {
    const response = await retry(async () => await axios.default.post(`${RPC_ENDPOINTS[chain]}/v1/chain/get_account`, { account_name }));
    try {
        return response.data.voter_info.staked / (10 ** get_precision( symbol ))
    } catch (e) {
        return 0;
    }
}

async function get_account_tvl(accounts, tokens, chain = "eos") {
    const balances = {}

    // support single or multiple accounts
    for ( const account of Array.isArray(accounts) ? accounts : [ accounts ] ) {
        for ( const [ code, symbol, id ] of tokens ) {
            const balance = await get_currency_balance(code, account, symbol, chain);

            // support native staking as balance
            const staked = code == "eosio.token" ? await get_staked(account, symbol, chain) : 0;

            // support adding same balance from multiple accounts
            if ( balances[id] ) balances[id] += balance + staked;
            else balances[id] = balance + staked;
        }
    }
    return balances;
}

module.exports = {
    get_staked,
    get_currency_balance,
    get_account_tvl,
}
'''
'''--- projects/helper/exports.js ---
function chainExports(chainTvl, chains){
  const chainTvls = chains.reduce((obj, chain) => ({
    ...obj,
    [chain === 'avax' ? 'avalanche' : chain]: {
      tvl:chainTvl(chain)
    }
  }), {})

  return chainTvls
}

function generalizedChainExports(chainTvl, chains){
  const chainTvls = chains.reduce((obj, chain) => ({
    ...obj,
    [chain === 'avax' ? 'avalanche' : chain]: chainTvl(chain)
  }), {})

  return chainTvls
}

function fetchChainExports(chainTvl, chains){
  const chainTvls = chains.reduce((obj, chain) => ({
    ...obj,
    [chain === 'avax' ? 'avalanche' : chain]: {
      fetch:chainTvl(chain)
    }
  }), {})

  return {
    ...chainTvls,
    fetch: ()=>{
      return Promise.all(chains.map(c=>chainTvl(c)())).then(cs=>cs.reduce((total, c)=>total+c, 0))
    }
  }
}

module.exports={
    chainExports,
    fetchChainExports,
    generalizedChainExports
}
'''
'''--- projects/helper/formatAddressChecksum.js ---
/**
 * @dev This function will format an address string according to the avilability of EIP-1191 on the network.
 *      This EIP determines the way the address checksum is being calculated.
 *      For example, on RSK (which implemented EIP-1191) any js/ts call to the blockchain for getting/connecting to a contract
 *      will have to be done with a low case address, while on a non EIP-1191 netwrok it has to remain mix-case.
 *      For more information please read: https://developers.rsk.co/rsk/architecture/account-based/
 */
function formatAddressChecksum(address, netwrokName) {
  // Add here more EIP-1191 networks as needed
  return ["rsk"].includes(netwrokName?.toLowerCase())
    ? address.toLowerCase()
    : address;
}

module.exports = {
  formatAddressChecksum,
};

'''
'''--- projects/helper/getBlock.js ---
const sdk = require('@defillama/sdk')
const retry = require('async-retry')
const axios = require("axios");

async function getBlock(timestamp, chain, chainBlocks, undefinedOk = false) {
    if (chainBlocks[chain] !== undefined || (process.env.HISTORICAL === undefined && undefinedOk)) {
        return chainBlocks[chain]
    } else {
        if(chain === "celo"){
            return Number((await retry(async bail => await axios.get("https://explorer.celo.org/api?module=block&action=getblocknobytime&timestamp=" + timestamp + "&closest=before"))).data.result.blockNumber);
        } else if(chain === "moonriver") {
            return Number((await retry(async bail => await axios.get(`https://blockscout.moonriver.moonbeam.network/api?module=block&action=getblocknobytime&timestamp=${timestamp}&closest=before`))).data.result.blockNumber);
        }
        return sdk.api.util.lookupBlock(timestamp, { chain }).then(blockData => blockData.block)
    }
}

module.exports = {
    getBlock,
};
'''
'''--- projects/helper/getChainList.js ---
const fs = require('fs')
const path = require('path')

const projectsFolder = path.join(__dirname, '..')

const files = fs.readdirSync(projectsFolder, { withFileTypes: true })
const whitelistedKeys = require('./whitelistedExportKeys.json')

const projectNames = []
const rModules = []
const projectMissingChainNames = []
const keysCount = {}
const chainCount = {}

files.forEach(i => {
  if (['config', 'helper'].includes(i.name)) return;
  let fPath
  try {
    if (i.isFile()) {
      fPath = path.join(projectsFolder, i.name)
      rModules.push(getModule(fPath, i.name))
      projectNames.push(i.name)
      return;
    }
    fPath = path.join(projectsFolder, i.name, 'index.js')
    if (checkFileExistsSync(fPath)) {
      rModules.push(getModule(fPath, i.name))
      projectNames.push(i.name)
      return;
    }
    console.log('Adapter wrong? ', i.name)
  } catch (e) {
    // console.error(e)
    console.log('error in', i.name)
  }
})

function getModule(fPath, projectName) {
  let module = require(fPath)
  delete module.hallmarks
  if (typeof module.tvl === 'function') {
    const chainsWithTVL = Object.keys(module).filter(chain => typeof module[chain] === 'object' && typeof module[chain].tvl === 'function')
    if (chainsWithTVL.length) console.log('I am confused:', projectName, chainsWithTVL)
    else module.ethereum = { tvl: module.tvl }
    delete module.tvl
  }

  Object.keys(module).filter(k => typeof module[k] !== 'object')
    .forEach(i => {
      addKey(i, projectName)
      delete module[i]
    })

  Object.keys(module).forEach(chain => {
    Object.keys(module[chain]).forEach(key => addKey(key, `${projectName}-${chain}`))
  })
  return module
}

function addKey(key, label) {
  if (whitelistedKeys.includes(key)) return;
  if (!keysCount[key]) keysCount[key] = []
  keysCount[key].push(label)
}

rModules.forEach((module, i) => {
  if (!Object.keys(module).length) return projectMissingChainNames.push(projectNames[i])
  Object.keys(module).forEach(chain => {
    if (!chainCount[chain]) chainCount[chain] = []
    chainCount[chain].push(projectNames[i])
  })
})

// console.log(`projectMissingChainNames count: `, projectMissingChainNames.length, projectMissingChainNames.join(', '))
// console.log(`Chain count: `, Object.keys(chainCount).length)
const chainCountTable = Object.keys(chainCount).map((chain) => [chain, chainCount[chain].length, chainCount[chain]]).sort((a, b) => b[1] - a[1])
const keyCountTable = Object.keys(keysCount).map((key) => [key, keysCount[key].length, keysCount[key]]).sort((a, b) => b[1] - a[1])
console.table(chainCountTable)
console.table(keyCountTable)
const chainNames = chainCountTable.map(([chain]) => chain)

fs.writeFileSync(path.join(__dirname, 'chains.json'), JSON.stringify(chainNames, null, 2))

function checkFileExistsSync(filepath) {
  let flag = true;
  try {
    fs.accessSync(filepath, fs.constants.F_OK);
  } catch (e) {
    flag = false;
  }
  return flag;
}
'''
'''--- projects/helper/getEfficientUsdUniTvl.js ---
const sdk = require('@defillama/sdk');
const token0 = require('./abis/token0.json');
const token1 = require('./abis/token1.json');
const getReserves = require('./abis/getReserves.json');
const factoryAbi = require('./abis/factory.json');
const { getBlock } = require('./getBlock');

async function requery(results, chain, block, abi) {
    if (results.some(r => !r.success)) {
        const failed = results.map((r, i) => [r, i]).filter(r => !r[0].success)
        const newResults = await sdk.api.abi
            .multiCall({
                abi,
                chain,
                calls: failed.map((f) => f[0].input),
                block,
            }).then(({ output }) => output);
        failed.forEach((f, i) => {
            results[f[1]] = newResults[i]
        })
    }
}

function sum(balances, token, amount) {
    if (balances[token] === undefined) {
        balances[token] = 0
    }
    balances[token] += Number(amount)
}

function setPrice(prices, address, coreAmount, tokenAmount) {
    if (prices[address] !== undefined) {
        const currentCoreAmount = prices[address][0]
        if (coreAmount < currentCoreAmount) {
            return
        }
    }
    prices[address] = [Number(coreAmount), Number(coreAmount) / Number(tokenAmount)]
}

const step = 10e3;

function calculateUsdUniTvl(FACTORY, chain, coreAssetRaw, whitelistRaw, coreAssetName, decimals = 18) {
    const whitelist = whitelistRaw.map(t => t.toLowerCase())
    const coreAsset = coreAssetRaw.toLowerCase()
    return async (timestamp, ethBlock, chainBlocks) => {
        const block = await getBlock(timestamp, chain, chainBlocks)

        let pairAddresses;
        const pairLengthRaw = (await sdk.api.abi.call({
            target: FACTORY,
            abi: factoryAbi.allPairsLength,
            chain,
            block
        })).output
        if (pairLengthRaw === null) {
            throw new Error("allPairsLength() failed")
        }
        const prices = {}
        let coreBalance = 0
        const pairLength = Number(pairLengthRaw)
        for (let floor = 0; floor < pairLength; floor += step) {
            const pairNums = Array.from(Array(Number(step)).keys()).map(k=>k+floor)
            {
                const pairs = (await sdk.api.abi.multiCall({
                    abi: factoryAbi.allPairs,
                    chain,
                    calls: pairNums.map(num => ({
                        target: FACTORY,
                        params: [num]
                    })),
                    block
                })).output
                await requery(pairs, chain, block, factoryAbi.allPairs);
                pairAddresses = pairs.map(result => result.output.toLowerCase())
            }

            const [token0Addresses, token1Addresses, reserves] = await Promise.all([
                sdk.api.abi
                    .multiCall({
                        abi: token0,
                        chain,
                        calls: pairAddresses.map((pairAddress) => ({
                            target: pairAddress,
                        })),
                        block,
                    })
                    .then(({ output }) => output),
                sdk.api.abi
                    .multiCall({
                        abi: token1,
                        chain,
                        calls: pairAddresses.map((pairAddress) => ({
                            target: pairAddress,
                        })),
                        block,
                    })
                    .then(({ output }) => output),
                sdk.api.abi
                    .multiCall({
                        abi: getReserves,
                        chain,
                        calls: pairAddresses.map((pairAddress) => ({
                            target: pairAddress,
                        })),
                        block,
                    }).then(({ output }) => output),
            ]);
            await requery(token0Addresses, chain, block, token0);
            await requery(token1Addresses, chain, block, token1);
            await requery(reserves, chain, block, getReserves);

            const pairs = {};
            // add token0Addresses
            token0Addresses.forEach((token0Address) => {
                const tokenAddress = token0Address.output.toLowerCase();

                const pairAddress = token0Address.input.target.toLowerCase();
                pairs[pairAddress] = {
                    token0Address: tokenAddress,
                }
            });

            // add token1Addresses
            token1Addresses.forEach((token1Address) => {
                const tokenAddress = token1Address.output.toLowerCase();
                const pairAddress = token1Address.input.target.toLowerCase();
                pairs[pairAddress] = {
                    ...(pairs[pairAddress] || {}),
                    token1Address: tokenAddress,
                }
            });

            const balances = {}
            for (let i = 0; i < reserves.length; i++) {
                const pairAddress = reserves[i].input.target.toLowerCase();
                const pair = pairs[pairAddress];
                const token0Address = pair.token0Address.toLowerCase()
                const token1Address = pair.token1Address.toLowerCase()
                const reserveAmounts = reserves[i].output
                if (token0Address === coreAsset) {
                    coreBalance += Number(reserveAmounts[0]) * 2
                    if (whitelist.includes(token1Address)) {
                        setPrice(prices, token1Address, reserveAmounts[0], reserveAmounts[1])
                    }
                } else if (token1Address === coreAsset) {
                    coreBalance += Number(reserveAmounts[1]) * 2
                    if (whitelist.includes(token0Address)) {
                        setPrice(prices, token0Address, reserveAmounts[1], reserveAmounts[0])
                    }
                } else {
                    const whitelistedToken0 = whitelist.find(t => t === token0Address)
                    const whitelistedToken1 = whitelist.find(t => t === token1Address)
                    if (whitelistedToken0 !== undefined) {
                        sum(balances, whitelistedToken0, Number(reserveAmounts[0]) * 2)
                    } else if (whitelistedToken1 !== undefined) {
                        sum(balances, whitelistedToken1, Number(reserveAmounts[1]) * 2)
                    }
                }
            }
            Object.entries(balances).forEach(([address, amount]) => {
                const price = prices[address];
                if (price !== undefined) {
                    coreBalance += price[1] * (amount ?? 0)
                }
            })
        }
        return {
            [coreAssetName]: (coreBalance) / (10 ** decimals)
        }
    }
};

module.exports = {
    calculateUsdUniTvl,
};

'''
'''--- projects/helper/getTokens.js ---
const axios = require('axios')

const chainIds = {
    'ethereum': 1,
    'bsc': 56,
    'polygon': 137
}

async function getTokens(address, chain = "ethereum"){
    const allTokens = (await axios.get(`https://api.covalenthq.com/v1/${chainIds[chain]}/address/${address}/balances_v2/?&key=ckey_72cd3b74b4a048c9bc671f7c5a6`)).data.data.items.filter(t=>t.contract_address !== "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee");
    return allTokens.map(token=>token.contract_address);
}

module.exports = {
    getTokens
}

'''
'''--- projects/helper/getUniFactory.js ---
const sdk = require('@defillama/sdk')

const router = "0x3881e447F439891dC106Da7bca0007B319eeB74D";
const chain = 'gochain';

async function getFactory(){
    const factory = await sdk.api.abi.call({
        target: router,
        chain,
        abi: {"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
    })
    const wrappedToken = await sdk.api.abi.call({
        target: router,
        chain,
        abi: {"inputs":[],"name":"WETH","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
    })
    console.log("factory", factory.output)
    console.log("wrapped token", wrappedToken.output)
}
getFactory()
'''
'''--- projects/helper/getUniSubgraphTvl.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require('../helper/balances');
const { getBlock } = require('../helper/getBlock');
const { blockQuery } = require('./graph')

function getChainTvl(graphUrls, factoriesName = "uniswapFactories", tvlName = "totalLiquidityUSD", blockCatchupLimit) {
  const graphQuery = gql`
query get_tvl($block: Int) {
  ${factoriesName}(
    block: { number: $block }
  ) {
    ${tvlName}
  }
}
`;
  return (chain) => {
    return async (timestamp, ethBlock, chainBlocks) => {
      const block = await getBlock(timestamp, chain, chainBlocks)
      let uniswapFactories

      if (!blockCatchupLimit) {
        uniswapFactories = (await request(graphUrls[chain], graphQuery, { block, }))[factoriesName];
      } else {
        uniswapFactories = (await blockQuery(graphUrls[chain], graphQuery, block, blockCatchupLimit))[factoriesName];
      }

      const usdTvl = Number(uniswapFactories[0][tvlName])
      return toUSDTBalances(usdTvl)
    }
  }
}

function getChainTvlBuffered(graphUrls, bufferSeconds, factoriesName = "uniswapFactories", tvlName = "totalLiquidityUSD") {
  const chainFn = getChainTvl(graphUrls, factoriesName, tvlName)
  return (chain) => {
    const tvl = chainFn(chain)
    return async (timestamp, ethBlock, chainBlocks) => {
      timestamp -= bufferSeconds
      for (const chainName in chainBlocks) {
        chainBlocks[chainName] = await getBlock(timestamp, chainName, {}, false)
      }
      ethBlock = chainBlocks['ethereum']
      return await tvl(timestamp, ethBlock, chainBlocks)
    }
  }
}

function getAvaxUniswapTvl(graphUrl, factoriesName = "uniswapFactories", tvlName = "totalLiquidityETH") {
  const graphQuery = gql`
query get_tvl($block: Int) {
  ${factoriesName}(
    block: { number: $block }
  ) {
    ${tvlName}
  }
}
`;
  return async (timestamp, ethBlock, chainBlocks) => {
    const response = await request(
      graphUrl,
      graphQuery,
      {
        block: chainBlocks.avax,
      }
    );

    return {
      'avalanche-2': Number(response[factoriesName][0].totalLiquidityETH)
    }
  }
}

module.exports = {
  getChainTvl,
  getChainTvlBuffered,
  getAvaxUniswapTvl
}
'''
'''--- projects/helper/getUsdUniTvl.js ---
const BigNumber = require('bignumber.js');
const sdk = require('@defillama/sdk');
const token0 = require('./abis/token0.json');
const token1 = require('./abis/token1.json');
const getReserves = require('./abis/getReserves.json');
const factoryAbi = require('./abis/factory.json');
const { getBlock } = require('./getBlock');
const { getChainTransform, getFixBalances } = require('./portedTokens')

async function requery(results, chain, block, abi) {
    if (results.some(r => !r.success)) {
        const failed = results.map((r, i) => [r, i]).filter(r => !r[0].success)
        const newResults = await sdk.api.abi
            .multiCall({
                abi,
                chain,
                calls: failed.map((f) => f[0].input),
                block,
            }).then(({ output }) => output);
        failed.forEach((f, i) => {
            results[f[1]] = newResults[i]
        })
    }
}

function sum(balances, token, amount) {
    if (balances[token] === undefined) {
        balances[token] = 0
    }
    balances[token] += Number(amount)
}

function setPrice(prices, address, coreAmount, tokenAmount) {
    if (prices[address] !== undefined) {
        const currentCoreAmount = prices[address][0]
        if (coreAmount < currentCoreAmount) {
            return
        }
    }
    prices[address] = [Number(coreAmount), Number(coreAmount) / Number(tokenAmount)]
}

function calculateUsdUniTvl(FACTORY, chain, coreAssetRaw, whitelistRaw, coreAssetName = undefined, decimals = 18, allowUndefinedBlock = true) {
    const whitelist = whitelistRaw.map(t => t.toLowerCase())
    const coreAsset = coreAssetRaw.toLowerCase()
    return async (timestamp, ethBlock, chainBlocks) => {
        const block = await getBlock(timestamp, chain, chainBlocks, allowUndefinedBlock)
        const transformAddress = await getChainTransform(chain)

        let pairAddresses;
        const pairLength = (await sdk.api.abi.call({
            target: FACTORY,
            abi: factoryAbi.allPairsLength,
            chain,
            block
        })).output
        if (pairLength === null) {
            throw new Error("allPairsLength() failed")
        }
        const pairNums = Array.from(Array(Number(pairLength)).keys())
        {
            const pairs = (await sdk.api.abi.multiCall({
                abi: factoryAbi.allPairs,
                chain,
                calls: pairNums.map(num => ({
                    target: FACTORY,
                    params: [num]
                })),
                block
            })).output
            await requery(pairs, chain, block, factoryAbi.allPairs);
            pairAddresses = pairs.map(result => result.output.toLowerCase())
        }

        const [token0Addresses, token1Addresses, reserves] = await Promise.all([
            sdk.api.abi
                .multiCall({
                    abi: token0,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                })
                .then(({ output }) => output),
            sdk.api.abi
                .multiCall({
                    abi: token1,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                })
                .then(({ output }) => output),
            sdk.api.abi
                .multiCall({
                    abi: getReserves,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                }).then(({ output }) => output),
        ]);
        await requery(token0Addresses, chain, block, token0);
        await requery(token1Addresses, chain, block, token1);
        await requery(reserves, chain, block, getReserves);

        const pairs = {};
        // add token0Addresses
        token0Addresses.forEach((token0Address) => {
            const tokenAddress = token0Address.output.toLowerCase();

            const pairAddress = token0Address.input.target.toLowerCase();
            pairs[pairAddress] = {
                token0Address: tokenAddress,
            }
        });

        // add token1Addresses
        token1Addresses.forEach((token1Address) => {
            const tokenAddress = token1Address.output.toLowerCase();
            const pairAddress = token1Address.input.target.toLowerCase();
            pairs[pairAddress] = {
                ...(pairs[pairAddress] || {}),
                token1Address: tokenAddress,
            }
        });

        const balances = {}
        let coreBalance = 0
        const prices = {}
        for (let i = 0; i < reserves.length; i++) {
            const pairAddress = reserves[i].input.target.toLowerCase();
            const pair = pairs[pairAddress];
            const token0Address = pair.token0Address.toLowerCase()
            const token1Address = pair.token1Address.toLowerCase()
            const reserveAmounts = reserves[i].output
            if (token0Address === coreAsset) {
                coreBalance += Number(reserveAmounts[0]) * 2
                if (whitelist.includes(token1Address)) {
                    setPrice(prices, token1Address, reserveAmounts[0], reserveAmounts[1])
                }
            } else if (token1Address === coreAsset) {
                coreBalance += Number(reserveAmounts[1]) * 2
                if (whitelist.includes(token0Address)) {
                    setPrice(prices, token0Address, reserveAmounts[1], reserveAmounts[0])
                }
            } else {
                const whitelistedToken0 = whitelist.find(t => t === token0Address)
                const whitelistedToken1 = whitelist.find(t => t === token1Address)
                if (whitelistedToken0 !== undefined) {
                    sum(balances, whitelistedToken0, Number(reserveAmounts[0]) * 2)
                } else if (whitelistedToken1 !== undefined) {
                    sum(balances, whitelistedToken1, Number(reserveAmounts[1]) * 2)
                }
            }
        }
        const finalBalances = {}
        Object.entries(balances).forEach(([address, amount]) => {
            const price = prices[address];
            if (price !== undefined) {
                coreBalance += price[1] * (amount ?? 0)
            } else {
                finalBalances[transformAddress(address)] = amount
            }
        })
        
        const fixBalances = await getFixBalances(chain)
        fixBalances(finalBalances)

        if (coreAssetName)
            sdk.util.sumSingleBalance(finalBalances, coreAssetName, (coreBalance) / (10 ** decimals))
        else
            sdk.util.sumSingleBalance(finalBalances, transformAddress(coreAsset), coreBalance)

        return finalBalances
    }
};

// same as calculateUsdUniTvl, but takes pair addresses as params instead of iterating over all pairs from factory
function calculateUsdUniTvlPairs(pairAddresses, chain, coreAssetRaw, whitelistRaw, coreAssetName = undefined, decimals = 18, allowUndefinedBlock = true) {
    const whitelist = whitelistRaw.map(t => t.toLowerCase())
    const coreAsset = coreAssetRaw.toLowerCase()
    return async (timestamp, ethBlock, chainBlocks) => {
        const block = await getBlock(timestamp, chain, chainBlocks, allowUndefinedBlock)
        const transformAddress = await getChainTransform(chain)

        const [token0Addresses, token1Addresses, reserves] = await Promise.all([
            sdk.api.abi
                .multiCall({
                    abi: token0,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                })
                .then(({ output }) => output),
            sdk.api.abi
                .multiCall({
                    abi: token1,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                })
                .then(({ output }) => output),
            sdk.api.abi
                .multiCall({
                    abi: getReserves,
                    chain,
                    calls: pairAddresses.map((pairAddress) => ({
                        target: pairAddress,
                    })),
                    block,
                }).then(({ output }) => output),
        ]);
        await requery(token0Addresses, chain, block, token0);
        await requery(token1Addresses, chain, block, token1);
        await requery(reserves, chain, block, getReserves);

        const pairs = {};
        // add token0Addresses
        token0Addresses.forEach((token0Address) => {
            const tokenAddress = token0Address.output.toLowerCase();

            const pairAddress = token0Address.input.target.toLowerCase();
            pairs[pairAddress] = {
                token0Address: tokenAddress,
            }
        });

        // add token1Addresses
        token1Addresses.forEach((token1Address) => {
            const tokenAddress = token1Address.output.toLowerCase();
            const pairAddress = token1Address.input.target.toLowerCase();
            pairs[pairAddress] = {
                ...(pairs[pairAddress] || {}),
                token1Address: tokenAddress,
            }
        });

        const balances = {}
        let coreBalance = 0
        const prices = {}
        for (let i = 0; i < reserves.length; i++) {
            const pairAddress = reserves[i].input.target.toLowerCase();
            const pair = pairs[pairAddress];
            const token0Address = pair.token0Address.toLowerCase()
            const token1Address = pair.token1Address.toLowerCase()
            const reserveAmounts = reserves[i].output
            if (token0Address === coreAsset) {
                coreBalance += Number(reserveAmounts[0]) * 2
                if (whitelist.includes(token1Address)) {
                    setPrice(prices, token1Address, reserveAmounts[0], reserveAmounts[1])
                }
            } else if (token1Address === coreAsset) {
                coreBalance += Number(reserveAmounts[1]) * 2
                if (whitelist.includes(token0Address)) {
                    setPrice(prices, token0Address, reserveAmounts[1], reserveAmounts[0])
                }
            } else {
                const whitelistedToken0 = whitelist.find(t => t === token0Address)
                const whitelistedToken1 = whitelist.find(t => t === token1Address)
                if (whitelistedToken0 !== undefined) {
                    sum(balances, whitelistedToken0, Number(reserveAmounts[0]) * 2)
                } else if (whitelistedToken1 !== undefined) {
                    sum(balances, whitelistedToken1, Number(reserveAmounts[1]) * 2)
                }
            }
        }
        const finalBalances = {}
        Object.entries(balances).forEach(([address, amount]) => {
            const price = prices[address];
            if (price !== undefined) {
                coreBalance += price[1] * (amount ?? 0)
            } else {
                finalBalances[transformAddress(address)] = amount
            }
        })

        const fixBalances = await getFixBalances(chain)
        fixBalances(finalBalances)

        if (coreAssetName)
            sdk.util.sumSingleBalance(finalBalances, coreAssetName, (coreBalance) / (10 ** decimals))
        else
            sdk.util.sumSingleBalance(finalBalances, transformAddress(coreAsset), coreBalance)

        return finalBalances
    }
};

module.exports = {
    calculateUsdUniTvl,
    calculateUsdUniTvlPairs,
    requery,
    setPrice,
    sum
};

'''
'''--- projects/helper/graph.js ---
const { GraphQLClient, } = require('graphql-request')

async function blockQuery(endpoint, query, block, blockCatchupLimit = 200) {
  const graphQLClient = new GraphQLClient(endpoint)
  try {
    const results = await graphQLClient.request(query, { block })
    return results
  } catch (e) {
    if (!block) throw e
    const errorString = e.toString()
    const isBlockCatchupIssue = /Failed to decode.*block.number.*has only indexed up to block number \d+/.test(errorString)
    if (!isBlockCatchupIssue) throw e
    const indexedBlockNumber = +errorString.match(/indexed up to block number (\d+) /)[1]
    console.log('We have indexed only upto ', indexedBlockNumber, 'requested block: ', block)
    if (block - blockCatchupLimit > indexedBlockNumber)
      throw e
    return graphQLClient.request(query, { block: indexedBlockNumber })
  }
}

module.exports = {
  blockQuery
}

'''
'''--- projects/helper/hbar.js ---
const http = require('./http')
const BigNumber = require('bignumber.js')
const sdk = require('@defillama/sdk')

const HBAR_API_V1 = 'https://mainnet-public.mirrornode.hedera.com/api/v1'

async function getHBARBalance(address, timestamp) {
  const tsString = timestamp ? `&timestamp=${timestamp}` : ''
  const response = await http.get(`${HBAR_API_V1}/balances?account.id=${address}${tsString}`)
  return response.balances[0].balance
}

async function addHBarBalance({ balances = {}, address, timestamp }) {
  let balance = await getHBARBalance(address, timestamp)
  balance = BigNumber(balance).shiftedBy(-1 * 8).toFixed(0)
  sdk.util.sumSingleBalance(balances, 'hedera-hashgraph', balance)
  return balances
}

module.exports = {
  addHBarBalance
}
'''
'''--- projects/helper/heroku-api.js ---
const { get } = require('./http')
const endpoint = "https://sushi-analytics.onrender.com"

function getExports(protocol, chains) {
    const chainTvls = chains.reduce((obj, chain) => {
        obj[chain === 'avax' ? 'avalanche' : chain] = {
            tvl: async (timestamp) => {
                if(Math.abs(Date.now()/1000-timestamp) > 3600){
                    throw new Error("Can't refill adapters moved to heroku")
                }
                const data = await get(`${endpoint}?project=${protocol}&chain=${chain}`)
                if(data[protocol]?.[chain] === undefined){
                    throw new Error(`Data for protocol ${protocol} on chain ${chain} is undefined on heroku`)
                }
                return data[protocol][chain]
            }
        }
        return obj
    }, {})

    return chainTvls
}

module.exports={
    getExports
}
'''
'''--- projects/helper/historicalApi.js ---
const { toUSDTBalances } = require('./balances')

// getCurrent: ()=>number
// getHistorical: ()=>[{date, totalLiquidityUSD}]
async function getApiTvl(timestamp, getCurrent, getHistorical) {
    if (Math.abs(timestamp - Date.now() / 1000) < 3600) {
        const tvl = await getCurrent()
        return toUSDTBalances(tvl)
    } else {
        const historical = await getHistorical()
        let closest = historical[0]
        historical.forEach(dayTvl => {
            if (Math.abs(dayTvl.date - timestamp) < Math.abs(closest.date - timestamp)) {
                closest = dayTvl
            }
        })
        if (Math.abs(closest.date - timestamp) > 3600 * 24) { // Oldest data is too recent
            throw new Error("Too old")
        }
        return toUSDTBalances(closest.totalLiquidityUSD)
    }
}

module.exports = {
    getApiTvl
}
'''
'''--- projects/helper/hodltree/calculateBalances.js ---
const sdk = require('@defillama/sdk');

const {
    ethContracts,
    polygonContracts,
    dexTypes
} = require('../../config/hodltree');
const { transformPolygonAddress, transformEthereumAddress } = require('../portedTokens');
const { calculateEM } = require('./calculateEM');
const { calculateFlashloan } = require('./calculateFlashloan');
const { calculateLendBorrow } = require('./calculateLendBorrow');

async function calculateHodltreeBalances(dexes, chain, chainBlocks, transform) {
    let tokenBalances = [];
    for (let dex of dexes) {
        let res;
        switch (dex.dexType) {
            case dexTypes.dexType.flashloan: 
                res = await calculateFlashloan(dex, chain, chainBlocks)
                break

            case dexTypes.dexType.lendBorrow:
                res = await calculateLendBorrow(dex, chain, chainBlocks)
                break

            case dexTypes.dexType.em:
                res = await calculateEM(dex, chain, chainBlocks)
                break
        }
        tokenBalances = tokenBalances.concat(res);
    }
    const balances = {};
    tokenBalances.map((tokenBalancePair) => {
        sdk.util.sumSingleBalance(balances, transform(tokenBalancePair[0]), tokenBalancePair[1]);
    })

    return balances;
}

async function calculateHodltreeBalancesEth(timestamp, block, chainBlocks) {
    const transform = await transformEthereumAddress();
    return calculateHodltreeBalances(ethContracts, 'ethereum', chainBlocks, transform);
}

async function calculateHodltreeBalancesPolygon(timestamp, block, chainBlocks) {
    const transform = await transformPolygonAddress()
    return calculateHodltreeBalances(polygonContracts, 'polygon', chainBlocks, transform);

}

module.exports = {
    calculateHodltreeBalancesEth,
    calculateHodltreeBalancesPolygon
}
'''
'''--- projects/helper/hodltree/calculateEM.js ---
const sdk = require('@defillama/sdk');

/**
 * @param {import("../../config/hodltree/addresses").Dex} dex 
 * @param {} chain
 * @param {} chainBlocks
 */
async function calculateEM(dex, chain, chainBlocks) {
    let tokens = [];
    let calls = [];
    dex.contracts.map((contract) => {
        let token = contract.miscInfo.token;
        tokens.push(token);
        calls.push({
            target: token,
            params: contract.address
        })
    })

    const flashloanBalances = (
        await sdk.api.abi.multiCall({
            abi: 'erc20:balanceOf',
            calls,
            chain: chain,
            block: chainBlocks[chain],
        })
    ).output.map((val) => val.output);

    let res = [];

    for (let tokenId = 0; tokenId < tokens.length; tokenId++) {
        res.push([tokens[tokenId], flashloanBalances[tokenId]]);
    }

    return res;
}

module.exports = {
    calculateEM
}
'''
'''--- projects/helper/hodltree/calculateFlashloan.js ---
const sdk = require('@defillama/sdk');

/**
 * @param {import("../../config/hodltree/addresses").Dex} dex 
 * @param {} chain
 * @param {} chainBlocks
 */
async function calculateFlashloan(dex, chain, chainBlocks) {
    let tokens = [];
    let calls = [];
    dex.contracts.map((contract) => {
        for (let token of contract.miscInfo.tokensIn) {
            tokens.push(token);
            calls.push({
                target: token,
                params: contract.address
            })
        }
    })

    const flashloanBalances = (
        await sdk.api.abi.multiCall({
            abi: 'erc20:balanceOf',
            calls,
            chain: chain,
            block: chainBlocks[chain],
        })
    ).output.map((val) => val.output);

    let res = [];

    for (let tokenId = 0; tokenId < tokens.length; tokenId++) {
        res.push([tokens[tokenId], flashloanBalances[tokenId]]);
    }

    return res;
}

module.exports = {
    calculateFlashloan
}
'''
'''--- projects/helper/hodltree/calculateLendBorrow.js ---
const sdk = require('@defillama/sdk');

/**
 * @param {import("../../config/hodltree/addresses").Dex} dex 
 * @param {} chain
 * @param {} chainBlocks
 */
async function calculateLendBorrow(dex, chain, chainBlocks) {
    let calls = [];
    let tokens = [];

    dex.contracts.map((contract) => {
        let token = contract.miscInfo.tokenIn;
        tokens.push(token);
        calls.push({
            target: token,
            params: contract.address
        });
    });

    const lendBorrowBalances = (
        await sdk.api.abi.multiCall({
            abi: 'erc20:balanceOf',
            calls,
            chain: chain,
            block: chainBlocks[chain],
        })
    ).output.map((val) => val.output);

    let res = [];

    for (let tokenId = 0; tokenId < tokens.length; tokenId++) {
        res.push([tokens[tokenId], lendBorrowBalances[tokenId]]);
    }

    return res;
}

module.exports = {
    calculateLendBorrow
}
'''
'''--- projects/helper/http.js ---
const retry = require('./retry')
const axios = require("axios")
const { request } = require("graphql-request")
const COVALENT_KEY = 'ckey_72cd3b74b4a048c9bc671f7c5a6'

async function get(endpoint) {
  return (await retry(async _ => await axios.get(endpoint))).data
}

async function post(endpoint, body) {
  return (await axios.post(endpoint, body)).data
}

async function graphQuery(endpoint, graphQuery, params = {}) {
  return request(endpoint, graphQuery, params)
}

async function covalentGetTokens(address, chain = 'ethereum') {
  let chainId
  switch(chain) {
    case 'ethereum': chainId = 1; break;
    case 'bsc': chainId = 56; break;
    default: throw new Error('Missing chain to chain id mapping!!!')
  }
  const {
    data: { items }
  } = await get(`https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/?&key=${COVALENT_KEY}`)
  return items
}

module.exports = {
  get,
  post,
  graphQuery,
  covalentGetTokens,
}
'''
'''--- projects/helper/koyo.js ---
const sdk = require("@defillama/sdk");
const { requery } = require("./requery");
const { fetchURL } = require("./utils");
const BigNumber = require("bignumber.js");
const { usdtAddress, toUSDT } = require("./balances");

const koyoStableSwapVirtualPriceABI = {
  stateMutability: "view",
  type: "function",
  name: "get_virtual_price",
  inputs: [],
  outputs: [
    {
      name: "",
      type: "uint256",
    },
  ],
};

/**
 * @description This function presumes that passed LP Tokens are from USD based stable pools.
 * @param {Object.<string, number>} balances
 * @param {string[]} lpTokens
 * @param {string[]} owners
 * @param {number[]} block
 * @param {string} [chain="boba"]
 * @param {*} transformAddress
 */
async function sumKoyoLPTokens(
  balances,
  lpTokens,
  owners,
  block,
  chain = "boba",
  transformAddress = (addr) => addr
) {
  const {
    data: { data: pools },
  } = await fetchURL(`https://api.exchange.koyo.finance/pools/raw/${chain}`);
  const lpToSwap = Object.fromEntries(
    Object.entries(pools)
      .filter(([k]) => !["generatedTime"].includes(k))
      .map(([, pool]) =>
        [pool.addresses.lpToken, pool.addresses.swap].map((addr) =>
          addr.toLowerCase()
        )
      )
  );

  const swapCalls = Object.values(lpToSwap).map((swap) => ({
    target: swap,
  }));
  const virtualPrices = await sdk.api.abi.multiCall({
    block,
    abi: koyoStableSwapVirtualPriceABI,
    calls: swapCalls,
    chain,
  });

  const balanceOfTokens = await sdk.api.abi.multiCall({
    calls: lpTokens
      .map((target) =>
        owners.map((o) => ({
          target,
          params: o,
        }))
      )
      .flat(),
    abi: "erc20:balanceOf",
    block,
    chain,
  });

  await requery(balanceOfTokens, chain, block, "erc20:balanceOf");

  balanceOfTokens.output.forEach((result) => {
    const token = result.input.target.toLowerCase();
    const balance = result.output;

    const virtualPrice = virtualPrices.output.find(
      (call) => call.input.target === lpToSwap[token]
    ).output;

    const virtualizedBalance = BigNumber(balance).times(
      BigNumber(virtualPrice).div(10 ** 18)
    );

    sdk.util.sumSingleBalance(
      balances,
      usdtAddress,
      toUSDT(virtualizedBalance.div(10 ** 18))
    );
  });
}

module.exports = {
  sumKoyoLPTokens,
};

'''
'''--- projects/helper/liquity.js ---
const sdk = require("@defillama/sdk");
const getEntireSystemCollAbi = require("./abis/getEntireSystemColl.abi.json");

const TUSD = "0x0000000000085d4780b73119b644ae5ecd22b376"

function getLiquityTvl(ETH_ADDRESS, TROVE_MANAGER_ADDRESS, chain) {
  return async (_, ethBlock, chainBlocks) => {
    const block = chainBlocks[chain]
    /*const stabilityPoolLusdTvl = (
      await sdk.api.erc20.balanceOf({
        target: LUSD_TOKEN_ADDRESS,
        owner: STABILITY_POOL_ADDRESS,
        block,
        chain,
      })
    ).output;*/

    const troveEthTvl = (
      await sdk.api.abi.call({
        target: TROVE_MANAGER_ADDRESS,
        abi: getEntireSystemCollAbi,
        block,
        chain,
      })
    ).output;

    return {
      [chain+':'+ETH_ADDRESS]: troveEthTvl,
      //[useTusd? TUSD : chain+':'+LUSD_TOKEN_ADDRESS]: stabilityPoolLusdTvl,
    };
  }
}

module.exports = {
  getLiquityTvl
};

'''
'''--- projects/helper/masterchef.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abis/masterchef.json')
const { unwrapUniswapLPs, unwrapLPsAuto, isLP } = require('./unwrapLPs')
const tokenAbi = require("./abis/token.json");
const token0Abi = require("./abis/token0.json");
const token1Abi = require("./abis/token1.json");
const getReservesAbi = require("./abis/getReserves.json");
const userInfoAbi = require("./abis/userInfo.json");
const { getBlock } = require('./getBlock');
const { default: BigNumber } = require('bignumber.js');
const { getChainTransform, getFixBalances } = require('../helper/portedTokens');

async function getPoolInfo(masterChef, block, chain, poolInfoAbi = abi.poolInfo) {
    const poolLength = (
        await sdk.api.abi.call({
            abi: abi.poolLength,
            target: masterChef,
            block,
            chain,
        })
    ).output;

    const poolInfo = (
        await sdk.api.abi.multiCall({
            block,
            calls: Array.from(Array(Number(poolLength)).keys()).map(i => ({
                target: masterChef,
                params: i,
            })),
            abi: poolInfoAbi,
            chain,
        })
    ).output;

    return poolInfo
}

async function getSymbolsAndBalances(masterChef, block, chain, poolInfo) {
    const [symbols, tokenBalances] = await Promise.all([
        sdk.api.abi.multiCall({
            block,
            calls: poolInfo.map(p => ({
                target: p.output[0]
            })),
            abi: 'erc20:symbol',
            chain,
        }),
        sdk.api.abi.multiCall({
            block,
            calls: poolInfo.map(p => ({
                target: p.output[0],
                params: masterChef
            })),
            abi: 'erc20:balanceOf',
            chain,
        })
    ])
    return [symbols, tokenBalances]
}

function isYV(symbol) {
    return symbol.includes('yv')
}

async function addFundsInMasterChef(balances, masterChef, block, chain = 'ethereum', transformAddress = undefined, poolInfoAbi = abi.poolInfo, ignoreAddresses = [], includeLPs = true, excludePool2 = false, stakingToken = undefined) {
    const poolInfo = await getPoolInfo(masterChef, block, chain, poolInfoAbi)
    if (!transformAddress) transformAddress = await getChainTransform(chain)
    const [symbols, tokenBalances] = await getSymbolsAndBalances(masterChef, block, chain, poolInfo);

    const lpPositions = [];
    const lpTokens = [];

    symbols.output.forEach((symbol, idx) => {
        const balance = tokenBalances.output[idx].output;
        const token = symbol.input.target;
        if (ignoreAddresses.some(addr => addr.toLowerCase() === token.toLowerCase()) || symbol.output === null) {
            return
        }
        if (isLP(symbol.output, symbol.input.target, chain)) {
            if (includeLPs && balance && !excludePool2) {
                lpPositions.push({
                    balance,
                    token
                });
            }
            else if (includeLPs && balance && excludePool2) {
                lpTokens.push(token);
            }
        } else {
            sdk.util.sumSingleBalance(balances, transformAddress(token), balance)
        }
    })

    if (excludePool2) {
        const [token0, token1, balance] = await Promise.all([
            sdk.api.abi.multiCall({
                calls: lpTokens.map(p => ({
                    target: p
                })),
                abi: token0Abi,
                block,
                chain
            }),
            sdk.api.abi.multiCall({
                calls: lpTokens.map(p => ({
                    target: p
                })),
                abi: token1Abi,
                block,
                chain
            }),
            sdk.api.abi.multiCall({
                calls: lpTokens.map(p => ({
                    target: p,
                    params: masterChef
                })),
                abi: "erc20:balanceOf",
                block,
                chain
            })
        ]);

        [token0, token1, balance].forEach((_, idx) => {
            if (lpTokens[idx] === undefined || token0.output[idx].output.toLowerCase() === stakingToken.toLowerCase() || token1.output[idx].output.toLowerCase() === stakingToken.toLowerCase()) {
                return
            }
            lpPositions.push({
                balance: balance.output[idx].output,
                token: balance.output[idx].input.target
            });
        });
    }

    await unwrapUniswapLPs(
        balances,
        lpPositions,
        block,
        chain,
        transformAddress
    );
}

function masterChefExports(masterChef, chain, stakingTokenRaw, tokenIsOnCoingecko = true, poolInfoAbi = abi.poolInfo, includeYVTokens = false) {
    const stakingToken = stakingTokenRaw.toLowerCase();
    let balanceResolve;

    async function getTvl(timestamp, ethBlock, chainBlocks) {
        const block = await getBlock(timestamp, chain, chainBlocks, true)
        const transformAddress = await getChainTransform(chain);

        const poolInfo = await getPoolInfo(masterChef, block, chain, poolInfoAbi)
        const [symbols, tokenBalances] = await getSymbolsAndBalances(masterChef, block, chain, poolInfo);

        const balances = {
            staking: {},
            pool2: {},
            tvl: {}
        }

        const lpPositions = [];

        await Promise.all(symbols.output.map(async (symbol, idx) => {
            const balance = tokenBalances.output[idx].output;
            const token = symbol.input.target.toLowerCase();
            if (token === stakingToken) {
                sdk.util.sumSingleBalance(balances.staking, transformAddress(token), balance)
            } else if (isLP(symbol.output, symbol.input.target, chain)) {
                lpPositions.push({
                    balance,
                    token
                });
            } else if (includeYVTokens && isYV(symbol.output)) {
                let underlyingToken = (await sdk.api.abi.call({
                    target: token,
                    abi: tokenAbi,
                    block,
                    chain,
                })).output;
                sdk.util.sumSingleBalance(balances.tvl, transformAddress(underlyingToken), balance)
            } else {
                sdk.util.sumSingleBalance(balances.tvl, transformAddress(token), balance)
            }
        }));

        const [token0, token1] = await Promise.all([
            sdk.api.abi.multiCall({
                calls: lpPositions.map(p => ({
                    target: p.token
                })),
                abi: token0Abi,
                block,
                chain
            }),
            sdk.api.abi.multiCall({
                calls: lpPositions.map(p => ({
                    target: p.token
                })),
                abi: token1Abi,
                block,
                chain
            }),
        ]);

        const pool2LpPositions = []
        const outsideLpPositions = []
        lpPositions.forEach((position, idx) => {
            if (token0.output[idx].output.toLowerCase() === stakingToken || token1.output[idx].output.toLowerCase() === stakingToken) {
                pool2LpPositions.push(position);
            } else {
                outsideLpPositions.push(position);
            }
        })
        await Promise.all([unwrapUniswapLPs(
            balances.tvl,
            outsideLpPositions,
            block,
            chain,
            transformAddress
        ), unwrapUniswapLPs(
            balances.pool2,
            pool2LpPositions,
            block,
            chain,
            transformAddress
        )]);

        if (!tokenIsOnCoingecko && pool2LpPositions.length) {
            const response = (await sdk.api.abi.multiCall({
                calls: pool2LpPositions.map(p => ({
                    target: stakingToken,
                    params: [p.token]
                })),
                abi: "erc20:balanceOf",
                block,
                chain
            })).output
            const maxPool2ByToken = response.reduce((max, curr) => {
                if (BigNumber(curr.output).gt(max.output)) {
                    return curr
                }
                return max
            });
            const poolAddress = maxPool2ByToken.input.params[0].toLowerCase()
            const poolReserves = await sdk.api.abi.call({
                block,
                chain,
                abi: getReservesAbi,
                target: poolAddress
            })
            const posToken0 = token0.output.find(t => t.input.target.toLowerCase() === poolAddress).output;
            const posToken1 = token1.output.find(t => t.input.target.toLowerCase() === poolAddress).output;
            let price, otherToken;
            if (posToken0.toLowerCase() === stakingToken) {
                price = poolReserves.output[1] / poolReserves.output[0]
                otherToken = transformAddress(posToken1)
            } else {
                price = poolReserves.output[0] / poolReserves.output[1]
                otherToken = transformAddress(posToken0)
            }
            const transformedStakingToken = transformAddress(stakingToken)
            Object.values(balances).forEach(balance => {
                Object.entries(balance).forEach(([addr, bal]) => {
                    if (addr.toLowerCase() === transformedStakingToken) {
                        balance[otherToken] = BigNumber(bal).times(price).toFixed(0)
                        delete balance[addr]
                    }
                })
            })
        }

        if (['smartbch', 'cronos'].includes(chain)) {
            const fixBalances = await getFixBalances(chain)
            Object.values(balances).map(fixBalances)
        }
        return balances
    };

    function getTvlPromise(key) {
        return async (ts, _block, chainBlocks) => {
            if (!balanceResolve)
                balanceResolve = getTvl(ts, _block, chainBlocks)
            return (await balanceResolve)[key]
        }
    }

    return {
        methodology: "TVL includes all farms in MasterChef contract",
        [chain]: {
            staking: getTvlPromise("staking"),
            pool2: getTvlPromise("pool2"),
            masterchef: getTvlPromise("tvl"),
            tvl: getTvlPromise("tvl"),
        }
    };
}

const standardPoolInfoAbi = { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "poolInfo", "outputs": [{ "internalType": "contract IERC20", "name": "lpToken", "type": "address" }, { "internalType": "uint256", "name": "allocPoint", "type": "uint256" }, { "internalType": "uint256", "name": "lastRewardBlock", "type": "uint256" }, { "internalType": "uint256", "name": "accWeVEPerShare", "type": "uint256" }], "stateMutability": "view", "type": "function" }

async function getUserMasterChefBalances({ balances = {}, masterChefAddress, userAddres, block, chain = 'ethereum', transformAddress, excludePool2 = false, onlyPool2 = false, pool2Tokens= [], poolInfoABI = abi.poolInfo, getLPAddress = null }) {
    if (!transformAddress)
        transformAddress = await getChainTransform(chain)

    const tempBalances = {}
    const poolLength = (await sdk.api.abi.call({ abi: abi.poolLength, target: masterChefAddress, block, chain, })).output
    const dummyArray = Array.from(Array(Number(poolLength)).keys())
    const poolInfoCalls = dummyArray.map(i => ({ target: masterChefAddress, params: i, }))
    const userInfoCalls = dummyArray.map(i => ({ target: masterChefAddress, params: [i, userAddres], }))
    const lpTokens = (await sdk.api.abi.multiCall({ block, calls: poolInfoCalls, abi: poolInfoABI, chain, })).output
        .map(a => getLPAddress ? getLPAddress(a.output) : (a.output && a.output[0]))
    const userBalances = (await sdk.api.abi.multiCall({ block, calls: userInfoCalls, abi: userInfoAbi, chain, })).output
        .map(a => a.output[0])

    userBalances.forEach((balance, idx) => {
        if (isNaN(+balance) || +balance <= 0) return;
        tempBalances[transformAddress(lpTokens[idx])] = balance
    })

    await unwrapLPsAuto({ balances: tempBalances, chain, block, transformAddress, excludePool2, onlyPool2, pool2Tokens })

    Object.keys(tempBalances).forEach(key => sdk.util.sumSingleBalance(balances, key, tempBalances[key]))

    return balances
}

module.exports = {
    addFundsInMasterChef,
    masterChefExports,
    getPoolInfo,
    isLP,
    standardPoolInfoAbi,
    getSymbolsAndBalances,
    isYV,
    getUserMasterChefBalances,
}

'''
'''--- projects/helper/methodologies.js ---
module.exports = {
    lendingMarket : "Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending.",
}
'''
'''--- projects/helper/near.js ---
const axios = require("axios")
const { default: BigNumber } = require("bignumber.js")
const { transformNearAddress } = require('../helper/portedTokens')
const sdk = require('@defillama/sdk')

const transformAddress = transformNearAddress()

const endpoint = "https://rpc.mainnet.near.org"

const tokenMapping = {
  'wrap.near': { name: 'near', decimals: 24, },
  'meta-pool.near': { name: 'staked-near', decimals: 24, },
  'usn': { name: 'usn', decimals: 18, },
  'aurora': { name: 'ethereum', decimals: 18, },
  'token.skyward.near': { name: 'skyward-finance', decimals: 18, },
  'dbio.near': { name: 'debio-network', decimals: 18, },
  // 'hak.tkn.near': { name: '', }, // Hakuna matata
  // 'meta-token.near': { name: '', }, // $Meta
  'v3.oin_finance.near': { name: 'oin-finance', decimals: 8, },
  // 'gems.l2e.near': { name: '', }, // https://www.landtoempire.com/
  // 'nd.tkn.near': { name: '', },   // nearDog
  // 'gold.l2e.near': { name: '', }, // https://www.landtoempire.com/
  'token.v2.ref-finance.near': { name: 'ref-finance', decimals: 18, },
  // 'myriadcore.near': { name: '', },  // Myria
  'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near': { name: 'usd-coin', decimals: 18 },
  'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': { name: 'tether', decimals: 18 },
  '2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near': { name: 'wrapped-bitcoin', decimals: 18 }
}

async function view_account(account_id) {
  const result = await axios.post(endpoint, {
    "jsonrpc": "2.0",
    "id": "1",
    "method": "query",
    "params": {
      "request_type": "view_account",
      "finality": "final",
      "account_id": account_id
    }
  });
  if (result.data.error) {
    throw new Error(`${result.data.error.message}: ${result.data.error.data}`)
  }
  return result.data.result;
}

async function call(contract, method, args = {}) {
  const result = await axios.post(endpoint, {
    "jsonrpc": "2.0",
    "id": "1",
    "method": "query",
    "params": {
      "request_type": "call_function",
      "finality": "final",
      "account_id": contract,
      "method_name": method,
      "args_base64": Buffer.from(JSON.stringify(args)).toString("base64")
    }
  });
  if (result.data.error) {
    throw new Error(`${result.data.error.message}: ${result.data.error.data}`)
  }
  return JSON.parse(Buffer.from(result.data.result.result).toString())
}

async function getTokenBalance(token, account) {
  return call(token, "ft_balance_of", { account_id: account })
}

async function addTokenBalances(tokens, account, balances = {}) {
  if (!Array.isArray(tokens)) tokens = [tokens]
  const fetchBalances = tokens.map(token => addAsset(token, account, balances))
  await Promise.all(fetchBalances)
  return balances
}

async function addAsset(token, account, balances = {}) {
  let balance = await getTokenBalance(token, account)
  return sumSingleBalance(balances, token, balance)
}

function sumSingleBalance(balances, token, balance) {
  const { name, decimals, } = tokenMapping[token] || {}

  if (name) {
    if (decimals)
      balance = BigNumber(balance).shiftedBy(-1 * decimals)

    if (!balances[name])
      balances[name] = BigNumber(0)

    balances[name] = balances[name].plus(balance)
    return
  }

  sdk.util.sumSingleBalance(balances, transformAddress(token), balance)
  return balances
}

module.exports = {
  view_account,
  call,
  addTokenBalances,
  getTokenBalance,
  sumSingleBalance,
};

'''
'''--- projects/helper/obyte.js ---
const utils = require('./utils')

/**
 * @param {number} timestamp - unix timestamp in seconds from epoch of the moment in time for which the balances are requested
 * @param {string} address - the Obyte address of the base AA for which the balances are fetched
 *
 * @return {Promise<object>} the balances of all assets of all AAs that are based on the base AA identified by address
 */
async function fetchBaseAABalances(timestamp, address) {
  /*
   * {
   *   "subject": "GS23D3GQNNMNJ5TL4Z5PINZ5626WASMA",
   *   "addresses": {
   *     "67XYBBBME57DZMJPLOYNXSIMAIDHGUDW": {
   *       "assets": {
   *         "3XF+1slNoFxIVPvRupR5uf9AXluOm92nobzKyCCSE3c=": {
   *           "balance": 829,
   *           "burned": false,
   *           "selfIssued": false,
   *           "selfIssuedUncapped": false
   *         },
   *         "base": {
   *           "balance": 36262,
   *           "burned": false,
   *           "selfIssued": false,
   *           "selfIssuedUncapped": false
   *         }
   *       }
   *     },
   *     "TBLLH5DGDX6KU5UGHG4WDH4N7IC5FPKP": {
   *        ...
   *     },
   *   }
   * }
   */
  const fetched = await utils.fetchURL(` https://api.charts.obyte.app/baseagents/${address}/balances?ts=${timestamp}`)
  return fetched.data
}

/**
 * A reducer applied on a list of response objects returned by fetchBaseAABalances() to calculate the total.
 * This reducer excludes locked in assets that were issued by the same autonomous agent.
 *
 * @example
 *   const balancesV1 = wait fetchBaseAABalances(timestamp, 'GS23D3GQNNMNJ5TL4Z5PINZ5626WASMA')
 *   const balancesV2 = wait fetchBaseAABalances(timestamp, '2JYYNOSRFGLI3TBI4FVSE6GFBUAZTTI3')
 *   const tvl = [balancesV1, balancesV2].reduce(summingBaseAABalancesToTvl(assetMetadata, exchangeRates), 0)
 *
 * @param {object} assetMetadata asset metadata (eg. decimals) mapped to the asset id (asset unit hash)
 * @param {object} exchangeRates asset/USD exchange rates mapped to assetId_USD keys
 * @return {function(number, object)} reducer function to be used with Array.reduce() where each element in the array is
 *    a result of a fetchBaseAABalances() call
 */
function summingBaseAABalancesToTvl(assetMetadata, exchangeRates) {

  const summingAssetTvl = (total, [asset, assetDetails]) => {
    if (!assetMetadata?.hasOwnProperty(asset)) return total

    const decimals = assetMetadata[asset].decimals ?? 0
    const baseCurrency = (asset === "base") ? "GBYTE" : asset
    const usdRate = exchangeRates[`${baseCurrency}_USD`] ?? 0
    const usdValue = assetDetails.balance / Math.pow(10, decimals) * usdRate
    // console.log(`  ${assetMetadata[asset]?.symbol ?? asset} = ${usdValue.toFixed(2)}`)
    return total + usdValue
  }

  const summingAddressTvl = (total, [address, addressDetails]) => {
    // console.log(`${address}:`)
    return total + Object.entries(addressDetails.assets)
        .filter(([asset, assetDetails]) => !assetDetails.selfIssued)
        .reduce(summingAssetTvl, 0)
  }

  const summingBaseAATvl = (total, balances) => {
    return total + Object.entries(balances.addresses).reduce(summingAddressTvl, 0)
  }

  return summingBaseAATvl
}

/**
 * @return {Promise<object>} fetches all exchange rates traded on Oswap v1 and v2 plus a few externally defined tokens such as GBYTE-USD or BTC-USD
 */
async function fetchOswapExchangeRates() {
  /*
   * {
   *   "BTC_USD": 29832,
   *   "GBYTE_BTC": 0.0004509,
   *   "GBYTE_USD": 13.4512488,
   *   "+X9n1ni9OpH/0PFXdmeB4f16wSxSivW4/qcyOt1UEDI=_USD": 88.2777158012621,
   *   "/1ReF/OW7wud1rqomgWMSeaetx8WjyD6eSTnGurTftU=_USD": 0.22874160911121644
   * }
   */
  const fetched = await utils.fetchURL("https://v2-data.oswap.io/api/v1/exchangeRates")
  return fetched.data
}

/**
 * @return {Promise<object>} fetches assets traded on Oswap v1
 */
async function fetchOswapV1Assets() {
  /*
   * {
   *  "O2-GBYTE-USDC": {
   *    "asset_id": "cQZVAFFh0Aaj5kMMydWoTqcMDxpfzGzEZhhEaQSVbHA=",
   *    "decimals": 0,
   *    "description": "Oswap v2 LP shares GBYTE-USDC",
   *    "symbol": "O2-GBYTE-USDC",
   *    "supply": 5026551
   *  }
   * }
   */
  const fetched = await utils.fetchURL("https://v1-data.oswap.io/api/v1/assets")
  const assets = fetched.data
  return Object.values(assets).reduce((map, asset) => {
    map[asset.asset_id] = asset
    return map
  }, {})
}

/**
 * @return {Promise<object>} fetches assets traded on Oswap v2
 */
async function fetchOswapV2Assets() {
  /*
   * {
   *  "O2-GBYTE-USDC": {
   *    "asset_id": "cQZVAFFh0Aaj5kMMydWoTqcMDxpfzGzEZhhEaQSVbHA=",
   *    "decimals": 0,
   *    "description": "Oswap v2 LP shares GBYTE-USDC",
   *    "symbol": "O2-GBYTE-USDC",
   *    "supply": 5026551
   *  }
   * }
   */
  const fetched = await utils.fetchURL("https://v2-data.oswap.io/api/v1/assets")
  const assets = fetched.data
  return Object.values(assets).reduce((map, asset) => {
    map[asset.asset_id] = asset
    return map
  }, {})
}

async function fetchOswapAssets() {
  const [assets1, assets2] = await Promise.all([
      fetchOswapV1Assets(),
      fetchOswapV2Assets()
  ])
  return {
    ...assets1,
    ...assets2
  }
}

/**
 * @return {Promise<object>} fetches assets traded on Oswap v2
 */
async function fetchOstableAssets() {
  /*
   * {
   *  "IUSD": {
   *    "asset_id": "eCpmov+r6LOVNj8KD0EWTyfKPrqsG3i2GgxV4P+zE6A=",
   *    "decimals": 4,
   *    "description": "Stable+ token for bonded stablecoin (VLKI3XMMX5YULOBA6ZXBXDPI6TXF6V3D)",
   *    "symbol": "IUSD",
   *    "supply": 61172.4893,
   *    "last_gbyte_value": 0.08233341192937123
   *  },
   * }
   */
  const fetched = await utils.fetchURL("https://data.ostable.org/api/v1/assets")
  const assets = fetched.data
  return Object.values(assets).reduce((map, asset) => {
    map[asset.asset_id] = asset
    return map
  }, {})
}

/**
 * Exchange rates of assets traded on Ostable.
 * @example
 *   {
 *     { "ymCWKx3kZg06i9oG5c1n3K+BdsCz4uE32hZ94sT3CsU=_base": 2.91381565819933e-06 }
 *   }
 *
 * @return {Promise<object>} map of asset pairs issued on Ostable to their exchange rate.
 */
async function fetchOstableExchangeRates() {
 /*
  *  {
  *   {
  *    "market_name": "GB2S-GBYTE",
  *      "quote_symbol": "GBYTE",
  *      "base_symbol": "GB2S",
  *      "quote_id": "base",
  *      "base_id": "ymCWKx3kZg06i9oG5c1n3K+BdsCz4uE32hZ94sT3CsU=",
  *      "lowest_price_24h": 0,
  *      "highest_price_24h": 0,
  *      "last_price": 2.91381565819933e-06,
  *      "quote_volume": 0,
  *      "base_volume": 0,
  *      "first_trade_date": "2020-10-09T10:26:11.000Z"
  *    }
  *  }
  */

  const fetched = await utils.fetchURL("https://data.ostable.org/api/v1/tickers")
  const tickers = fetched.data
  return Object.values(tickers).reduce((map, ticker) => {
    const currencyPair = `${ticker.base_id}_${ticker.quote_id}`
    map[currencyPair] = ticker.last_price
    return map
  }, {})
}

/**
 * Exchange rates of assets in USD traded on Ostable.
 * @example
 *   {
 *     { "ymCWKx3kZg06i9oG5c1n3K+BdsCz4uE32hZ94sT3CsU=_USD": 42.12 }
 *   }
 *
 * @return {Promise<object>} map of asset pairs issued on Ostable to their exchange rate in USD.
 */
async function fetchOstableExchangeRatesInUSD() {
  const [oswapRates, ostableRates] = await Promise.all([
    fetchOswapExchangeRates(),
    fetchOstableExchangeRates()
  ])

  const gbyteUsd = oswapRates["GBYTE_USD"]

  const ostableRatesInUSD = Object.entries(ostableRates)
      .filter(([currencyPair, price]) => currencyPair.endsWith("_base"))
      .reduce((map, [currencyPair, price]) => ({...map, [currencyPair.replace("_base", "_USD")]: price * gbyteUsd}))

  return {
    "GBYTE_USD": gbyteUsd,
    ...ostableRatesInUSD
  }
}

module.exports = {
  fetchBaseAABalances,
  fetchOswapExchangeRates,
  fetchOswapAssets,
  fetchOstableAssets,
  fetchOstableExchangeRatesInUSD,
  summingBaseAABalancesToTvl
}

'''
'''--- projects/helper/ohm.js ---
const { staking, stakingUnknownPricedLP } = require('./staking')
const { sumTokensAndLPsSharedOwners, sumLPWithOnlyOneTokenOtherThanKnown } = require('./unwrapLPs')
const { getFixBalances } = require('./portedTokens')

function ohmTvl(treasury, treasuryTokens, chain = 'ethereum', stakingAddress, stakingToken, transformOriginal = undefined, fix, tokenOnCoingecko = true) {
    let transform = transformOriginal
    const tvl = async (time, ethBlock, chainBlocks) => {
        const block = chainBlocks[chain]
        const balances = {}
        await sumTokensAndLPsSharedOwners(balances, tokenOnCoingecko?treasuryTokens:treasuryTokens.filter(t=>t[1]===false), [treasury], block, chain, transform || (addr => `${chain}:${addr}`))
        if(!tokenOnCoingecko){
            await Promise.all(treasuryTokens.filter(t=>t[1]===true).map(t=>
                sumLPWithOnlyOneTokenOtherThanKnown(balances, t[0], treasury, stakingToken, block, chain, transform)
            ))
        }
        if (!fix) fix = await getFixBalances(chain)
        fix(balances)
        return balances
    }
    return {
        [chain === "avax"?"avalanche":chain]: {
            tvl,
            staking: tokenOnCoingecko?
                staking(stakingAddress, stakingToken, chain, transform ? transform(stakingToken) : undefined)
                : stakingUnknownPricedLP(stakingAddress, stakingToken, chain, treasuryTokens.find(t=>t[1]===true)[0], transform)
        }
    }
}

module.exports = {
    ohmTvl
}

'''
'''--- projects/helper/pact.js ---
const { post } = require('./http')
const { prepareExecCmd } = require('./utils/pact')

async function fetchLocal(localCmd, apiHost) {
  if (!apiHost) throw new Error(`Pact.fetch.local(): No apiHost provided`);

  const { pactCode, meta, networkId } = localCmd
  const cmd = prepareExecCmd(pactCode, meta, networkId);
  const res = await post(`${apiHost}/api/v1/local`, cmd)
  return res;
}

function mkMeta(sender, chainId, gasPrice, gasLimit, creationTime, ttl) {
  return {
    creationTime: creationTime,
    ttl: ttl,
    gasLimit: gasLimit,
    chainId: chainId,
    gasPrice: gasPrice,
    sender: sender
  };
}

module.exports = {
  fetchLocal,
  mkMeta,
}
'''
'''--- projects/helper/pool2.js ---
const {_BASE_TOKEN_, _QUOTE_TOKEN_} = require('./abis/dodo.json')
const sdk = require('@defillama/sdk')
const { default: BigNumber } = require('bignumber.js')
const { unwrapUniswapLPs, sumTokensAndLPsSharedOwners, sumTokensAndLPs } = require('./unwrapLPs');
const masterchefAbi = require("./abis/masterchef.json")
const token0Abi = require("./abis/token0.json")
const token1Abi = require("./abis/token1.json")
const {isLP, getPoolInfo} = require('./masterchef')

function pool2(stakingContract, lpToken, chain = "ethereum", transformAddress) {
    return async (_timestamp, _ethBlock, chainBlocks) => {
        const balances = {}
        if(transformAddress === undefined){
            transformAddress = addr=>`${chain}:${addr}`
        }
        await sumTokensAndLPs(balances, [[lpToken, stakingContract, true]], chainBlocks[chain], chain, transformAddress)
        return balances
    }
}

function pool2s(stakingContracts, lpTokens, chain = "ethereum", transformAddress = undefined){
    return async (_timestamp, _ethBlock, chainBlocks) => {
        const balances = {}
        let transform = transformAddress
        if(transform === undefined){
            transform = addr=>`${chain}:${addr}`
        }
        await sumTokensAndLPsSharedOwners(balances, lpTokens.map(token=>[token, true]), stakingContracts, chainBlocks[chain], chain, transform)
        return balances
    }
}

function pool2Exports(stakingContract, lpTokens, chain, transformAddress) {
    return pool2s([stakingContract], lpTokens, chain, transformAddress)
}

function dodoPool2(stakingContract, lpToken, chain = "ethereum", transformAddress=addr=>addr) {
    return async (_timestamp, _ethBlock, chainBlocks) => {
        const balances = {}
        const block = chainBlocks[chain]
        const [baseToken, quoteToken, totalSupply] = await Promise.all([_BASE_TOKEN_, _QUOTE_TOKEN_, "erc20:totalSupply"].map(abi => sdk.api.abi.call({
            target: lpToken,
            chain,
            block,
            abi
        }).then(r=>r.output)))
        const [baseTokenBalance, quoteTokenBalance, stakedLPBalance] = await Promise.all([
            [baseToken, lpToken], [quoteToken, lpToken], [lpToken, stakingContract]
        ].map(token => sdk.api.abi.call({
            target: token[0],
            params: [token[1]],
            chain,
            block,
            abi: 'erc20:balanceOf'
        }).then(r=>r.output)))
        sdk.util.sumSingleBalance(balances, baseToken, BigNumber(baseTokenBalance).times(stakedLPBalance).div(totalSupply).toFixed(0))
        sdk.util.sumSingleBalance(balances, quoteToken, BigNumber(quoteTokenBalance).times(stakedLPBalance).div(totalSupply).toFixed(0))
        return balances
    }
}

async function pool2BalanceFromMasterChef(balances, masterchef, token, block, chain = "ethereum", transformAddress=(addr)=>addr, poolInfoAbi = masterchefAbi.poolInfo) {
    const poolInfo = await getPoolInfo(masterchef, block, chain, poolInfoAbi)

    let symbols = (
        await sdk.api.abi.multiCall({
        calls: poolInfo.map((p) => ({
            target: p.output.lpToken,
        })),
        abi: "erc20:symbol",
        block,
        chain,
        })
    ).output;

    let lpTokens = [];

    for (let i = 0; i < symbols.length; i++) {
        let symbol = symbols[i];
        if (symbol.output === null) {
            continue;
        }
        if (isLP(symbol.output, symbol.input.target, chain)){
            lpTokens.push(symbol.input.target);
        }
    }

    let [tokens0, tokens1] = await Promise.all([
        sdk.api.abi.multiCall({
        calls: lpTokens.map((p) => ({
            target: p,
        })),
        abi: token0Abi,
        block,
        chain,
        }),
        sdk.api.abi.multiCall({
        calls: lpTokens.map((p) => ({
            target: p,
        })),
        abi: token1Abi,
        block,
        chain,
        }),
    ]);

    let pool2LPs = [];

    for (let i = 0; i < lpTokens.length; i++) {
        if (
        tokens0.output[i].output.toLowerCase() === token.toLowerCase() ||
        tokens1.output[i].output.toLowerCase() === token.toLowerCase()
        ){
            pool2LPs.push(lpTokens[i]);
        }
    }

    let lpBalances = (await sdk.api.abi.multiCall({
        calls: pool2LPs.map((p) => ({
            target: p,
            params: masterchef
        })),
        abi: "erc20:balanceOf",
        block,
        chain,
    })).output;

    let lpPositions = lpBalances.map((p) => ({
        balance: p.output,
        token: p.input.target
    }));

    await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAddress);

}

function pool2BalanceFromMasterChefExports(masterchef, token, chain = "ethereum", transformAddress=(addr)=>addr, poolInfoAbi = masterchefAbi.poolInfo) {
    
    return async (_timestamp, _ethBlock, chainBlocks) => {
        let balances = {};

        await pool2BalanceFromMasterChef(balances, masterchef, token, chainBlocks[chain], chain, transformAddress, poolInfoAbi);

        return balances;
    } 
}

module.exports = {
    pool2,
    pool2Exports,
    dodoPool2,
    pool2s,
    pool2BalanceFromMasterChef,
    pool2BalanceFromMasterChefExports
}
'''
'''--- projects/helper/portedTokens.js ---
const utils = require("../helper/utils");
const sdk = require("@defillama/sdk");
const IOTEX_CG_MAPPING = require("./../xdollar-finance/iotex_cg_mapping.json");
const BigNumber = require("bignumber.js");

const nullAddress = '0x0000000000000000000000000000000000000000'

async function transformFantomAddress() {
  const multichainTokens = (await utils.fetchURL(
    "https://netapi.anyswap.net/bridge/v2/info"
  )).data.bridgeList;

  const mapping = {
    "0xbf07093ccd6adfc3deb259c557b61e94c1f66945":
      "fantom:0xd6070ae98b8069de6b494332d1a1a81b6179d960",
    "0x1b156c5c75e9df4caab2a5cc5999ac58ff4f9090":
      "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
    "0xa48d959ae2e88f1daa7d5f611e01908106de7598":
      "fantom:0x841fad6eae12c286d1fd18d1d525dffa75c7effe",
    "0xd795d70ec3c7b990ffed7a725a18be5a9579c3b9":
      "avax:0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e",
    "0xb6767518b205ea8b312d2ef4d992a2a08c2f2416":
      "avax:0xc7198437980c041c805a1edcba50c1ce5db95118",
    "0xaf9f33df60ca764307b17e62dde86e9f7090426c":
      "avax:0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
    "0x808d5f0a62336917da14fa9a10e9575b1040f71c":
      "avax:0x60781c2586d68229fde47564546784ab3faca982",
    "0x0dec85e74a92c52b7f708c4b10207d9560cefaf0":
      "fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
    "0x637ec617c86d24e421328e6caea1d92114892439":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8":
      "0x514910771af9ca656af840dff83e8264ecf986ca",
    "0x0a03d2c1cfca48075992d810cc69bd9fe026384a":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0x97927abfe1abbe5429cbe79260b290222fc9fbba":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
    "0x6dfe2aaea9daadadf0865b661b53040e842640f8":
      "0x514910771af9ca656af840dff83e8264ecf986ca",
    "0x920786cff2a6f601975874bb24c63f0115df7dc8":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0x49c68edb7aebd968f197121453e41b8704acde0c":
      "fantom:0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
    "0x0665ef3556520b21368754fb644ed3ebf1993ad4":
      "0x6c3f90f043a72fa612cbac8115ee7e52bde6e490",
    // update below to binspirit when it lists on coingecko
    "0x7345a537a975d9ca588ee631befddfef34fd5e8f":
      "fantom:0x5Cc61A78F164885776AA610fb0FE1257df78E59B",
    "0xdbf31df14b66535af65aac99c32e9ea844e14501":
      "0xeb4c2781e4eba804ce9a9803c67d0893436bb27d", // RenBTC
    "0x4a89338a2079a01edbf5027330eac10b615024e5":
      "fantom:0xad84341756bf337f5a0164515b1f6f993d194e1f", // USDL
    "0xc0d9784fdba39746919bbf236eb73bc015fd351d":
      "fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83", // FTML
    "0xe3a486c1903ea794eed5d5fa0c9473c7d7708f40":
      "fantom:0xad84341756bf337f5a0164515b1f6f993d194e1f", // cUSD (revenent finance)
    "0x02a2b736f9150d36c0919f3acee8ba2a92fbbb40":
      "0x1a7e4e63778b4f12a199c062f3efdd288afcbce8", // agEUR
    "0x1b6382dbdea11d97f24495c9a90b7c88469134a4":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // axUSDC
    "0xB67FA6deFCe4042070Eb1ae1511Dcd6dcc6a532E":
      "0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9", // alUSD
    "0x8cc97b50fe87f31770bcdcd6bc8603bc1558380b":
      "cronos:0x0804702a4e749d39a35fde73d1df0b1f1d6b8347", // single
    "0x95bf7e307bc1ab0ba38ae10fc27084bc36fcd605":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
  };

  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    // WFTM && FTM
    if (
      compareAddresses(addr, "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83") ||
      compareAddresses(addr, "0x0000000000000000000000000000000000000000") ||
      compareAddresses(addr, "0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
    ) {
      return "0x4e15361fd6b4bb609fa63c81a2be19d873717870";
    }
    if (compareAddresses(addr, "0x658b0c7613e890ee50b8c4bc6a3f41ef411208ad")) {
      // fETH
      return "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
    }
    if (compareAddresses(addr, "0x82f0b8b456c1a451378467398982d4834b6829c1")) {
      // MIM
      return "0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3";
    }
    if (compareAddresses(addr, "0x260b3e40c714ce8196465ec824cd8bb915081812")) {
      return "polygon:0x4a81f8796e0c6ad4877a51c86693b0de8093f2ef"; // IRON ICE
    }
    const srcToken = multichainTokens.find(
      token => token.chainId === "250" && token.token === addr.toLowerCase()
    );
    if (srcToken !== undefined) {
      if (srcToken.srcChainId === "1") {
        return srcToken.srcToken;
      } else if (srcToken.srcChainId === "56") {
        if (srcToken.srcToken === "") {
          return "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c";
        }
        return `bsc:${srcToken.srcToken}`;
      }
    }
    return mapping[addr] || `fantom:${addr}`;
  };
}

function compareAddresses(a, b) {
  return a.toLowerCase() === b.toLowerCase();
}

async function transformAvaxAddress() {
  const [
    bridgeTokensOld,
    bridgeTokensNew,
    bridgeTokenDetails
  ] = await Promise.all([
    utils.fetchURL(
      "https://raw.githubusercontent.com/0xngmi/bridge-tokens/main/data/penultimate.json"
    ),
    utils
      .fetchURL(
        "https://raw.githubusercontent.com/ava-labs/avalanche-bridge-resources/main/avalanche_contract_address.json"
      )
      .then(r => Object.entries(r.data)),
    utils.fetchURL(
      "https://raw.githubusercontent.com/ava-labs/avalanche-bridge-resources/main/token_list.json"
    )
  ]);
  return addr => {
    if (compareAddresses(addr, "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7")) {
      return "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7";
    }
    const srcToken = bridgeTokensOld.data.find(token =>
      compareAddresses(token["Avalanche Token Address"], addr)
    );
    if (
      srcToken !== undefined &&
      srcToken["Ethereum Token Decimals"] ===
      srcToken["Avalanche Token Decimals"]
    ) {
      return srcToken["Ethereum Token Address"];
    }
    const newBridgeToken = bridgeTokensNew.find(token =>
      compareAddresses(addr, token[1])
    );
    if (newBridgeToken !== undefined) {
      const tokenName = newBridgeToken[0].split(".")[0];
      const tokenData = bridgeTokenDetails.data[tokenName];
      if (tokenData !== undefined) {
        return tokenData.nativeContractAddress;
      }
    }
    const map = {
      "0xaf2c034c764d53005cc6cbc092518112cbd652bb":
        "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      "0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33":
        "avax:0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd",
      "0x0000000000000000000000000000000000000000":
        "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      "0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx":
        "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      "0xd45b7c061016102f9fa220502908f2c0f1add1d7":
        "0xffc97d72e13e01096502cb8eb52dee56f74dad7b",
      "0x46a51127c3ce23fb7ab1de06226147f446e4a857":
        "0xbcca60bb61934080951369a648fb03df4f96263c",
      "0x532e6537fea298397212f09a61e03311686f548e":
        "0x3ed3b47dd13ec9a98b44e6204a523e766b225811",
      "0xdfe521292ece2a4f44242efbcd66bc594ca9714b":
        "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      "0x686bef2417b6dc32c50a3cbfbcc3bb60e1e9a15d":
        "0x9ff58f4ffb29fa2266ab25e75e2a8b3503311656",
      "0x53f7c5869a859f0aec3d334ee8b4cf01e3492f21":
        "0x030ba81f1c18d280636f32af80b9aad02cf0854e",
      "0x47afa96cdc9fab46904a55a6ad4bf6660b53c38a":
        "0x028171bca77440897b824ca71d1c56cac55b68a3",
      "0x574679ec54972cf6d705e0a71467bb5bb362919d":
        "avax:0x5817d4f0b62a59b17f75207da1848c2ce75e7af4",
      "0x2f28add68e59733d23d5f57d94c31fb965f835d0":
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // sUSDC(Avalanche) -> USDC(Ethereum)
      "0xf04d3a8eb17b832fbebf43610e94bdc4fd5cf2dd":
        "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // sBUSD(Avalanche) -> BUSD(BSC)
      "0xb0a8e082e5f8d2a04e74372c1be47737d85a0e73":
        "polygon:0xac63686230f64bdeaf086fe6764085453ab3023f", // USV
      "0x02bfd11499847003de5f0f5aa081c43854d48815":
        "0x7a5d3A9Dcd33cb8D527f7b5F96EB4Fef43d55636", // Radioshack
      "0xbf07093ccd6adfc3deb259c557b61e94c1f66945":
        "fantom:0xd6070ae98b8069de6b494332d1a1a81b6179d960",
      "0x1b156c5c75e9df4caab2a5cc5999ac58ff4f9090":
        "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      "0xa48d959ae2e88f1daa7d5f611e01908106de7598":
        "fantom:0x841fad6eae12c286d1fd18d1d525dffa75c7effe",
      "0xd795d70ec3c7b990ffed7a725a18be5a9579c3b9":
        "avax:0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e",
      "0xb6767518b205ea8b312d2ef4d992a2a08c2f2416":
        "avax:0xc7198437980c041c805a1edcba50c1ce5db95118",
      "0xaf9f33df60ca764307b17e62dde86e9f7090426c":
        "avax:0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
      "0x808d5f0a62336917da14fa9a10e9575b1040f71c":
        "avax:0x60781c2586d68229fde47564546784ab3faca982",
      "0x0dec85e74a92c52b7f708c4b10207d9560cefaf0":
        "fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
      "0x637ec617c86d24e421328e6caea1d92114892439":
        "0x6b175474e89094c44da98b954eedeac495271d0f",
      "0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8":
        "0x514910771af9ca656af840dff83e8264ecf986ca",
      "0x0a03d2c1cfca48075992d810cc69bd9fe026384a":
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
      "0x97927abfe1abbe5429cbe79260b290222fc9fbba":
        "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
      "0x6dfe2aaea9daadadf0865b661b53040e842640f8":
        "0x514910771af9ca656af840dff83e8264ecf986ca",
      "0x920786cff2a6f601975874bb24c63f0115df7dc8":
        "0x6b175474e89094c44da98b954eedeac495271d0f",
      "0x49c68edb7aebd968f197121453e41b8704acde0c":
        "fantom:0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      "0x0665ef3556520b21368754fb644ed3ebf1993ad4":
        "0x6c3f90f043a72fa612cbac8115ee7e52bde6e490",
      // update below to binspirit when it lists on coingecko
      "0x7345a537a975d9ca588ee631befddfef34fd5e8f":
        "fantom:0x5Cc61A78F164885776AA610fb0FE1257df78E59B",
      "0x90a424754ad0d72cebd440faba18cdc362bfe70a":
        "heco:0xcbd6cb9243d8e3381fea611ef023e17d1b7aedf0", // BXH
      "0x8965349fb649a33a30cbfda057d8ec2c48abe2a2":
        "0x6e9730ecffbed43fd876a264c982e254ef05a0de", // Nord
      "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7":
        "0xdac17f958d2ee523a2206206994597c13d831ec7"
    };
    return map[addr.toLowerCase()] || `avax:${addr}`;
  };
}

async function transformBscAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB -> WBNB
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB -> WBNB
    "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c":
      "avax:0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c", // ELK
    "0xb7f8cd00c5a06c0537e2abff0b58033d02e5e094":
      "0x8e870d67f660d95d5be530380d0ec0bd388289e1", // PAX
    "0x2170ed0880ac9a755fd29b2688956bd959f933f8":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0xa35d95872d8eb056eb2cbd67d25124a6add7455e": "0x123", // 2030FLOKI returns nonsense TVL
    "0x0cf8e180350253271f4b917ccfb0accc4862f262": "0x123", // BTCBR returns nonsense TVL
    "0x6ded0f2c886568fb4bb6f04f179093d3d167c9d7":
      "0x09ce2b746c32528b7d864a1e3979bd97d2f095ab", // DFL
    "0x2f28add68e59733d23d5f57d94c31fb965f835d0":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // sUSDC(BSC) -> USDC(Ethereum)
    "0xaf6162dc717cfc8818efc8d6f46a41cf7042fcba":
      "polygon:0xac63686230f64bdeaf086fe6764085453ab3023f", // USV Token
    "0x30807d3b851a31d62415b8bb7af7dca59390434a":
      "0x7a5d3A9Dcd33cb8D527f7b5F96EB4Fef43d55636", // Radio Token
    "0xce86f7fcd3b40791f63b86c3ea3b8b355ce2685b":
      "0xb4d930279552397bba2ee473229f89ec245bc365", // MahaDao
    "0xbb9858603b1fb9375f6df972650343e985186ac5":
      "bsc:0xc087c78abac4a0e900a327444193dbf9ba69058e", // Treat staked  BUSD-USDC Staked APE-LP as LP Token
    "0xc5fb6476a6518dd35687e0ad2670cb8ab5a0d4c5":
      "bsc:0x2e707261d086687470b515b320478eb1c88d49bb", // Treat staked  BUSD-USDT Staked APE-LP as LP Token
    "0xaed19dab3cd68e4267aec7b2479b1ed2144ad77f":
      "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // valas BUSD -> BUSD
    "0xa6fdea1655910c504e974f7f1b520b74be21857b":
      "bsc:0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", // valas USDC -> BUSD
    "0x5f7f6cb266737b89f7af86b30f03ae94334b83e9":
      "bsc:0x55d398326f99059ff775485246999027b3197955", // valas USDT -> BUSD
    "0x532197ec38756b9956190b845d99b4b0a88e4ca9":
      "0x1614f18fc94f47967a3fbe5ffcd46d4e7da3d787", // PAID
    "0x6d1b7b59e3fab85b7d3a3d86e505dd8e349ea7f3":
      "heco:0xcbd6cb9243d8e3381fea611ef023e17d1b7aedf0", // BXH
    "0x42586ef4495bb512a86cf7496f6ef85ae7d69a64":
      "polygon:0x66e8617d1df7ab523a316a6c01d16aa5bed93681", // SPICE
    "0x60d01ec2d5e98ac51c8b4cf84dfcce98d527c747": "0x9ad37205d608b8b219e6a2573f922094cec5c200", // iZi
    "0x0a3bb08b3a15a19b4de82f8acfc862606fb69a2d": "0x0a3bb08b3a15a19b4de82f8acfc862606fb69a2d", // iUSD
    // "0x250632378E573c6Be1AC2f97Fcdf00515d0Aa91B": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // BETH->WETH
  };

  return addr => {
    addr = addr.toLowerCase();

    return mapping[addr] || `bsc:${addr}`;
  };
}

const PoSMappedTokenList =
  "https://api.bridge.matic.network/api/tokens/pos/erc20";
const PlasmaMappedTokenList =
  "https://api.bridge.matic.network/api/tokens/plasma/erc20";

async function transformPolygonAddress() {
  const posTokens = await utils.fetchURL(PoSMappedTokenList);
  const plasmaTokens = await utils.fetchURL(PlasmaMappedTokenList);
  const tokens = posTokens.data.tokens
    .concat(plasmaTokens.data.tokens)
    .reduce((tokenMap, token) => {
      tokenMap[token.childToken.toLowerCase()] = token.rootToken.toLowerCase();
      return tokenMap;
    }, {});
  const mapping = {
    "0x60d01ec2d5e98ac51c8b4cf84dfcce98d527c747":
      "0x9ad37205d608b8b219e6a2573f922094cec5c200", // IZI
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee":
      "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", //
    // '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270': '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0',  // WMATIC
    "0x0000000000000000000000000000000000000000":
      "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", //
    "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619":
      "0x0000000000000000000000000000000000000000", //
    "0xAa9654BECca45B5BDFA5ac646c939C62b527D394":
      "polygon:0xAa9654BECca45B5BDFA5ac646c939C62b527D394", // Dino
    "0x2f28add68e59733d23d5f57d94c31fb965f835d0":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // sUSDC(Polygon) -> USDC(Ethereum)
    "0x9fffb2f49adfc231b44ddcff3ffcf0e81b06430a":
      "0x6B175474E89094C44Da98b954EedeAC495271d0F", // moUSD(Polygon) -> DAI
    "0xf04d3a8eb17b832fbebf43610e94bdc4fd5cf2dd":
      "bsc:0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", // sBUSD(Polygon) -> BUSD(BSC)
    "0x8eb3771a43a8c45aabe6d61ed709ece652281dc9":
      "avax:0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664", // sUSDC.e(Polygon) -> USDC.e(Avalanche)
    "0x613a489785c95afeb3b404cc41565ccff107b6e0":
      "0x7a5d3A9Dcd33cb8D527f7b5F96EB4Fef43d55636", // radioshack
    "0x1ddcaa4ed761428ae348befc6718bcb12e63bfaa": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // deUSDC
    "0x794baab6b878467f93ef17e2f2851ce04e3e34c8": "0x794baab6b878467f93ef17e2f2851ce04e3e34c8", // Yin
    "0x282d8efce846a88b159800bd4130ad77443fa1a1": "0x967da4048cd07ab37855c090aaf366e4ce1b9f48" //ocean
  };
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    return mapping[addr] || tokens[addr] || `polygon:${addr}`;
  };
}

async function transformXdaiAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0x44fa8e6f47987339850636f88629646662444217":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0xddafbb505ad214d7b80b1f830fccc89b60fb7a83":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "0x4537e328bf7e4efa29d05caea260d7fe26af9d74":
      "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    "0x4ecaba5870353805a9f068101a40e0f32ed605c6":
      "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "0x7122d7661c4564b7c6cd4878b06766489a6028a2":
      "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    "0x8e5bbbb09ed1ebde8674cda39a0c169401db4252":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
    // '0x29414ec76d79ff238e5e773322799d1c7ca2443f': '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', // Boring oBTC
  };

  return transformChainAddress(mapping, "xdai", { skipUnmapped: false });
}

async function transformOkexAddress() {
  // const okexBridge = (
  //   await utils.fetchURL(
  //     "https://www.okex.com/v2/asset/cross-chain/currencyAddress"
  //   )
  // ).data.data.tokens; TODO
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0x75231f58b43240c9718dd58b4967c5114342a86c", // okex
    "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c":
      "avax:0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c"
  };

  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    if (mapping[addr]) return mapping[addr];
    return `okexchain:${addr}`;
  };
}

async function transformHecoAddress() {
  const mapping = {
    "0xb6f4c418514dd4680f76d5caa3bb42db4a893acb":
      "bsc:0x250632378e573c6be1ac2f97fcdf00515d0aa91b",
    "0x0000000000000000000000000000000000000000":
      "0x6f259637dcd74c767781e37bc6133cd6a68aa161",
    "0xhecozzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz":
      "0x6f259637dcd74c767781e37bc6133cd6a68aa161",
    "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f":
      "0x6f259637dcd74c767781e37bc6133cd6a68aa161",
    "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c":
      "avax:0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c",
    "0x3D760a45D0887DFD89A2F5385a236B29Cb46ED2a":
      "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0x9362Bbef4B8313A8Aa9f0c9808B80577Aa26B73B":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "0xCe0A5CA134fb59402B723412994B30E02f083842":
      "0xc00e94cb662c3520282e6f5717214004a7f26888",
    "0x1Ee8382bE3007Bd9249a89f636506284DdEf6Cc0":
      "0x35a532d376ffd9a705d0bb319532837337a398e7",
    "0x40280e26a572745b1152a54d1d44f365daa51618":
      "bsc:0xba2ae424d960c26247dd6c32edc70b295c744c43",
    "0x5ee41ab6edd38cdfb9f6b4e6cf7f75c87e170d98":
      "0x0000000000085d4780b73119b644ae5ecd22b376",
    "0xA2F3C2446a3E20049708838a779Ff8782cE6645a":
      "bsc:0x1d2f0da169ceb9fc7b3144628db156f3f6c60dbe", // XRP
    "0x843Af718EF25708765a8E0942F89edEae1D88DF0":
      "bsc:0x3ee2200efb3400fabb9aacf31297cbdd1d435d47" // ADA
  };

  return transformChainAddress(mapping, "heco", { skipUnmapped: false });
}

async function transformHooAddress() {
  const mapping = {
    "0xd16babe52980554520f6da505df4d1b124c815a7":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0x3eff9d389d13d6352bfb498bcf616ef9b1beac87":
      "0x6f259637dcd74c767781e37bc6133cd6a68aa161" // wHOO
  };
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    return mapping[addr] || `hoo:${addr}`;
  };
}

async function transformCeloAddress() {
  return addr => {
    return `celo:${addr}`;
  };
}

async function transformHarmonyAddress() {
  const bridge = (await utils.fetchURL(
    "https://be4.bridge.hmny.io/tokens/?page=0&size=1000"
  )).data.content;

  const mapping = {
    "0x6983D1E6DEf3690C4d616b13597A09e6193EA013":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0xb1f6E61E1e113625593a22fa6aa94F8052bc39E0":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    "0xFbdd194376de19a88118e84E279b977f165d01b8":
      "polygon:0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a":
      "harmony:0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a",
    "0x72cb10c6bfa5624dd07ef608027e366bd690048f":
      "harmony:0x72cb10c6bfa5624dd07ef608027e366bd690048f",
    "0xa9ce83507d872c5e1273e745abcfda849daa654f":
      "harmony:0xa9ce83507d872c5e1273e745abcfda849daa654f",
    "0xb12c13e66ade1f72f71834f2fc5082db8c091358":
      "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", //avax
    "0x224e64ec1bdce3870a6a6c777edd450454068fec":
      "0xa47c8bf37f92abed4a126bda807a7b7498661acd",
    "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c":
      "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c",
    "0xd754ae7bb55feb0c4ba6bc037b4a140f14ebe018":
      "0x19e6bfc1a6e4b042fb20531244d47e252445df01",
    "0x0000000000000000000000000000000000000000":
      "0x799a4202c12ca952cB311598a024C80eD371a41e", // Harmony ONE
    "0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f":
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0x985458e523db3d53125813ed68c274899e9dfab4":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1":
      "0x6B175474E89094C44Da98b954EedeAC495271d0F" // DAI
  };

  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    if (mapping[addr]) return mapping[addr];
    const srcToken = bridge.find(token =>
      compareAddresses(addr, token.hrc20Address)
    );
    if (srcToken !== undefined) {
      const prefix = srcToken.network === "BINANCE" ? "bsc:" : "";
      return prefix + srcToken.erc20Address;
    }
    return `harmony:${addr}`;
  };
}

const optimismSynths = {
  "0x8c6f28f2f1a3c87f0f938b96d27520d9751ec8d9":
    "0x57ab1ec28d129707052df4df418d58a2d46d5f51",
  "0xc5db22719a06418028a40a9b5e9a7c02959d0d08":
    "0xbbc455cb4f1b9e4bfc4b73970d360c8f032efee6",
  "0xe405de8f52ba7559f9df3c368500b6e6ae6cee49":
    "0x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb",
  "0x298b9b95708152ff6968aafd889c6586e9169f1d":
    "0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6"
};

async function transformOptimismAddress() {
  const bridge = (await utils.fetchURL(
    "https://static.optimism.io/optimism.tokenlist.json"
  )).data.tokens;

  const mapping = {
    "0x4200000000000000000000000000000000000006":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0x5029c236320b8f15ef0a657054b84d90bfbeded3":
      "0x15ee120fd69bec86c1d38502299af7366a41d1a6",
    "0x0000000000000000000000000000000000000000":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // OETH -> WETH
    "0x121ab82b49B2BC4c7901CA46B8277962b4350204":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // synapse WETH -> WETH
    "0x35D48A789904E9b15705977192e5d95e2aF7f1D3":
      "0x956f47f50a910163d8bf957cf5846d573e7f87ca", // FEI
    "0xcb8fa9a76b8e203d8c3797bf438d8fb81ea3326a":
      "0xbc6da0fe9ad5f3b0d58160288917aa56653660e9", // alUSD
    "0x67CCEA5bb16181E7b4109c9c2143c24a1c2205Be":
      "0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0", // FRAX Share
    "0x2E3D870790dC77A83DD1d18184Acc7439A53f475":
      "0x853d955acef822db058eb8505911ed77f175b99e", // FRAX
    "0x0b5740c6b4a97f90eF2F0220651Cca420B868FfB":
      "0x0ab87046fbb341d058f17cbc4c1133f25a20a52f" // gOHM
  };
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();

    if (mapping[addr]) return mapping[addr];

    const possibleSynth = optimismSynths[addr.toLowerCase()];
    if (possibleSynth !== undefined) {
      return possibleSynth;
    }
    const dstToken = bridge.find(
      token => compareAddresses(addr, token.address) && token.chainId === 10
    );
    if (dstToken !== undefined) {
      const srcToken = bridge.find(
        token => dstToken.logoURI === token.logoURI && token.chainId === 1
      );
      if (srcToken !== undefined) {
        return srcToken.address;
      }
    }
    return `optimism:${addr}`;
  };
}

async function transformMoonriverAddress() {
  const mapping = {
    "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c":
      "avax:0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c",
    "0x0000000000000000000000000000000000000000":
      "moonriver:0x98878B06940aE243284CA214f92Bb71a2b032B8A"
  };

  return transformChainAddress(mapping, "moonriver", { skipUnmapped: false });
}

async function transformMoonbeamAddress() {
  const mapping = {
    '0x322E86852e492a7Ee17f28a78c663da38FB33bfb': '0x853d955aCEf822Db058eb8505911ED77F175b99e', // frax
    '0x8f552a71EFE5eeFc207Bf75485b356A0b3f01eC9': '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // usdc
    '0xdfa46478f9e5ea86d57387849598dbfb2e964b02': 'polygon:0xa3fa99a148fa48d14ed51d610c367c61876997f1', // mai
    '0x8e70cD5B4Ff3f62659049e74b6649c6603A0E594': '0xdac17f958d2ee523a2206206994597c13d831ec7', // usdt
    '0x30D2a9F5FDf90ACe8c17952cbb4eE48a55D916A7': '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // eth
    '0x1DC78Acda13a8BC4408B207c9E48CDBc096D95e0': '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', // wtbc
    '0xc234A67a4F840E61adE794be47de455361b52413': '0x6b175474e89094c44da98b954eedeac495271d0f', // dai
    '0x1d4C2a246311bB9f827F4C768e277FF5787B7D7E': 'moonriver:0x98878b06940ae243284ca214f92bb71a2b032b8a', // movr
    '0x0000000000000000000000000000000000000000': 'moonbeam:0xacc15dc74880c9944775448304b263d191c6077f', // GLMR -> WGLMR
  }

  return transformChainAddress(mapping, "moonbeam", { skipUnmapped: false });
}

async function transformArbitrumAddress() {
  const bridge = (await utils.fetchURL(
    "https://bridge.arbitrum.io/token-list-42161.json"
  )).data.tokens;
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0x09ad12552ec45f82be90b38dfe7b06332a680864":
      "polygon:0xc3fdbadc7c795ef1d6ba111e06ff8f16a20ea539", // ADDy
    "0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A":
      "0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3", // MIM
    "0xDBf31dF14B66535aF65AaC99C32e9eA844e14501":
      "0xeb4c2781e4eba804ce9a9803c67d0893436bb27d", // renBTC
    "0x9ef758ac000a354479e538b8b2f01b917b8e89e7":
      "polygon:0x3dc7b06dd0b1f08ef9acbbd2564f8605b4868eea", // XDO
    "0x31635A2a3892dAeC7C399102676E344F55d20Da7":
      "0x09ce2b746c32528b7d864a1e3979bd97d2f095ab", //  DeFIL
    "0x4a717522566c7a09fd2774ccedc5a8c43c5f9fd2":
      "0x956f47f50a910163d8bf957cf5846d573e7f87ca", //  FEI
    "0x2913e812cf0dcca30fb28e6cac3d2dcff4497688":
      "0x6b175474e89094c44da98b954eedeac495271d0f", //  nUSD
    "0x289ba1701c2f088cf0faf8b3705246331cb8a839":
      "0x58b6a8a3302369daec383334672404ee733ab239", // LPT
    "0x61a1ff55c5216b636a294a07d77c6f4df10d3b56": "0x52a8845df664d76c69d2eea607cd793565af42b8", // APEX
  };

  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    if (mapping[addr]) return mapping[addr];
    const dstToken = bridge.find(token =>
      compareAddresses(addr, token.address)
    );
    if (dstToken !== undefined) {
      return dstToken.extensions.bridgeInfo[1].tokenAddress;
    }
    return `arbitrum:${addr}`;
  };
}

async function transformFuseAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0x970b9bb2c0444f5e81e9d0efb84c8ccdcdcaf84d", // FUSE
    "0x0be9e53fd7edac9f859882afdda116645287c629":
      "0x970b9bb2c0444f5e81e9d0efb84c8ccdcdcaf84d", // FUSE
    "0x620fd5fa44BE6af63715Ef4E65DDFA0387aD13F5":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0x94Ba7A27c7A95863d1bdC7645AC2951E0cca06bA":
      "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
    "0xFaDbBF8Ce7D5b7041bE672561bbA99f79c532e10":
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0xa722c13135930332Eb3d749B2F0906559D2C5b99":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0x43b17749b246fd2a96de25d9e4184e27e09765b0":
      "0xdefa4e8a7bcba345f687a2f1456f5edd9ce97202" // KYC
  };

  return transformChainAddress(mapping, "fuse", {
    skipUnmapped: true,
    chainName: "fuse"
  });
}

async function transformEvmosAddress() {
  const mapping = {
    // '0x0000000000000000000000000000000000000000': '',  // EVMOS
    // '0xD4949664cD82660AaE99bEdc034a0deA8A0bd517': '',  // WEVMOS
    "0x51e44FfaD5C2B122C8b635671FCC8139dc636E82":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // madUSDC
    "0x8d395AfFC1767141387ffF45aF88a074614E7Ccf":
      "0x18084fba666a33d37592fa2633fd49a74dd93a88", // tBTCv2
    "0xb1a8C961385B01C3aA782fba73E151465445D319":
      "0xeb4c2781e4eba804ce9a9803c67d0893436bb27d", // renBTC
    "0xe46910336479F254723710D57e7b683F3315b22B":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // ceUSDC
    "0x63743ACF2c7cfee65A5E356A4C4A005b586fC7AA":
      "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
    "0x7FF4a56B32ee13D7D4D405887E0eA37d61Ed919e":
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // madUSDT
    "0xb72A7567847abA28A2819B855D7fE679D4f59846":
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // ceUSDT
    "0x5842C5532b61aCF3227679a8b1BD0242a41752f2":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0xF80699Dc594e00aE7bA200c7533a07C1604A106D":
      "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", // WBTC
    "0x28eC4B29657959F4A5052B41079fe32919Ec3Bd3":
      "0x853d955aCEf822Db058eb8505911ED77F175b99e", // madFRAX
    "0xE03494D0033687543a80c9B1ca7D6237F2EA8BD8":
      "0x853d955aCEf822Db058eb8505911ED77F175b99e" // FRAX
  };

  return transformChainAddress(mapping, "evmos", {
    skipUnmapped: false,
    chainName: "evmos"
  });
}

function fixAvaxBalances(balances) {
  for (const representation of [
    "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
    "0x9dEbca6eA3af87Bf422Cea9ac955618ceb56EfB4"
  ]) {
    if (balances[representation] !== undefined) {
      balances["avalanche-2"] = Number(balances[representation]) / 1e18;
      delete balances[representation];
    }
  }
}

function fixHarmonyBalances(balances) {
  for (const representation of [
    "harmony:0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
    "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
    "harmony:0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a",
    "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a",
    "bsc:0xdE976f3344cd9F06E451aF3A94a324afC3E154F4",
    "bsc:0xde976f3344cd9f06e451af3a94a324afc3e154f4",
    "0x799a4202c12ca952cB311598a024C80eD371a41e"
  ]) {
    if (balances[representation] !== undefined) {
      sdk.util.sumSingleBalance(
        balances,
        "harmony",
        Number(balances[representation]) / 1e18
      );
      delete balances[representation];
    }
  }
  const xJewel = "harmony:0xa9ce83507d872c5e1273e745abcfda849daa654f";
  if (balances[xJewel]) {
    sdk.util.sumSingleBalance(
      balances,
      "xjewel",
      Number(balances[xJewel]) / 1e18
    );
    delete balances[xJewel];
  }
}

function transformOasisAddressBase(addr) {
  const map = {
    "0x21c718c22d52d0f3a789b752d4c2fd5908a8a733": "oasis-network",
    "0x3223f17957ba502cbe71401d55a0db26e5f7c68f":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", //WETH
    "0xe8a638b3b7565ee7c5eb9755e58552afc87b94dd":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x4bf769b05e832fcdc9053fffbc78ca889acb5e1e":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0x6cb9750a92643382e020ea9a170abb83df05f30b":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0xdc19a122e268128b5ee20366299fc7b5b199c8e3":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT wormhole
    "0x81ecac0d6be0550a00ff064a4f9dd2400585fe9c":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC celer
    "0x94fbffe5698db6f54d6ca524dbe673a7729014be":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x80a16016cc4a2e6a2caca8a4a498b1699ff0f844":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // USDC
    //'0x21c718c22d52d0f3a789b752d4c2fd5908a8a733': 'wrapped-rose',
  };
  return map[addr.toLowerCase()] || `${addr}`;
}

async function transformOasisAddress() {
  return transformOasisAddressBase;
}
function fixBscBalances(balances) {
  if (balances["bsc:0x8b04E56A8cd5f4D465b784ccf564899F30Aaf88C"]) {
    sdk.util.sumSingleBalance(
      balances,
      "anchorust",
      Number(balances["bsc:0x8b04E56A8cd5f4D465b784ccf564899F30Aaf88C"]) /
      10 ** 6
    );
  }
}
function fixOasisBalances(balances) {
  ["oasis-network", "wrapped-rose"].forEach(key => {
    if (balances[key]) balances[key] = balances[key] / 10 ** 18;
  });
}
async function transformIotexAddress() {
  return addr => {
    const dstToken = Object.keys(IOTEX_CG_MAPPING).find(token =>
      compareAddresses(addr, token)
    );
    if (dstToken !== undefined) {
      return (
        IOTEX_CG_MAPPING[dstToken].contract ||
        IOTEX_CG_MAPPING[dstToken].coingeckoId
      );
    }
    return `iotex:${addr}`;
  };
}

async function transformKccAddress() {
  return addr => {
    if (compareAddresses(addr, "0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c")) {
      return "avax:0xe1c110e1b1b4a1ded0caf3e42bfbdbb7b5d7ce1c";
    }
    if (compareAddresses(addr, "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48")) {
      return "okexchain:0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85";
    }
    if (compareAddresses(addr, "0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c")) {
      return "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
    }
    if (compareAddresses(addr, "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d")) {
      return "0x4fabb145d64652a948d72533023f6e7a623c7c53";
    }
    if (compareAddresses(addr, "0xc9baa8cfdde8e328787e29b4b078abf2dadc2055")) {
      return "0x6b175474e89094c44da98b954eedeac495271d0f";
    }
    if (compareAddresses(addr, "0xfa93c12cd345c658bc4644d1d4e1b9615952258c")) {
      return "bsc:0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c";
    }
    if (compareAddresses(addr, "0x218c3c3d49d0e7b37aff0d8bb079de36ae61a4c0")) {
      return "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599";
    }
    if (compareAddresses(addr, "0xf55af137a98607f7ed2efefa4cd2dfe70e4253b1")) {
      return "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
    }
    if (compareAddresses(addr, "0x980a5afef3d17ad98635f6c5aebcbaeded3c3430")) {
      return "okexchain:0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85";
    }
    return `kcc:${addr}`;
  };
}

function transformMetisAddress() {
  const map = {
    "0x0000000000000000000000000000000000000000": "0x9e32b13ce7f2e80a01932b42553652e053d6ed8e", // METIS
    "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000": "0x9e32b13ce7f2e80a01932b42553652e053d6ed8e",
    "0xbb06dca3ae6887fabf931640f67cab3e3a16f4dc": "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "0x420000000000000000000000000000000000000a": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0x5801d0e1c7d977d78e4890880b8e579eb4943276": "bsc:0x5801d0e1c7d977d78e4890880b8e579eb4943276",
    "0xea32a96608495e54156ae48931a7c20f0dcc1a21": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    "0x2692be44a6e38b698731fddf417d060f0d20a0cb": "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
    "0xa5B55ab1dAF0F8e1EFc0eB1931a957fd89B918f4": "avax:0x50b7545627a5162F82A992c33b87aDc75187B218",
    "0x12d84f1cfe870ca9c9df9785f8954341d7fbb249": "bsc:0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", // bUSD
    "0xE253E0CeA0CDD43d9628567d097052B33F98D611": "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", // wAVAX
    "0xa9109271abcf0c4106ab7366b4edb34405947eed": "fantom:0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83", // wFTM
    "0x4651B38e7ec14BB3db731369BFE5B08F2466Bd0A": "bsc:0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3",
    "0xfe282Af5f9eB59C30A3f78789EEfFA704188bdD4": "metis:0xfe282Af5f9eB59C30A3f78789EEfFA704188bdD4",
    "0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8": "bsc:0xad29abb318791d579433d831ed122afeaf29dcfe",
    "0x4b9D2923D875edF43980BF5dddDEde3Fb20fC742": "bsc:0xcc42724c6683b7e57334c4e856f4c9965ed682bd",
    "0x67c10c397dd0ba417329543c1a40eb48aaa7cd00": "0x0f2d719407fdbeff09d87557abb7232601fd9f29", //SYN
    "0x226d8bfb4da78ddc5bd8fd6c1532c58e88f9fd34": "0xbc19712feb3a26080ebf6f2f7849b417fdd792ca", // BoringDAO
  }
  normalizeMapping(map)

  return addr => {
    addr = addr.toLowerCase()

    return map[addr] || `metis:${addr}`;
  };
}

function transformBobaAddress() {
  const map = {
    "0x0000000000000000000000000000000000000000":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0xd203De32170130082896b4111eDF825a4774c18E":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // synapse wETH
    "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0x66a2a913e447d6b4bf33efbec43aaef87890fbbc":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x5de1677344d3cb0d7d465c10b72a8f60699c062d":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0xf74195bb8a5cf652411867c5c2c5b8c2a402be35":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
    "0x461d52769884ca6235B685EF2040F47d30C94EB5":
      "bsc:0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", // BUSD
    "0xdc0486f8bf31df57a952bcd3c1d3e166e3d9ec8b":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599", // WBTC
    "0xa18bf3994c0cc6e3b63ac420308e5383f53120d7":
      "0x42bbfa2e77757c645eeaad1655e0911a7553efbc", // BOBA
    "0xe1e2ec9a85c607092668789581251115bcbd20de":
      "0xd26114cd6EE289AccF82350c8d8487fedB8A0C07", // OMG
    "0x7562f525106f5d54e891e005867bf489b5988cd9":
      "0x853d955acef822db058eb8505911ed77f175b99e", // FRAX
    "0x2f28add68e59733d23d5f57d94c31fb965f835d0":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // sUSDC(Boba) -> USDC(Ethereum)
    "0xf04d3a8eb17b832fbebf43610e94bdc4fd5cf2dd":
      "bsc:0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56" // sBUSD(Boba) -> BUSD(BSC)
  };

  normalizeMapping(map);

  return addr => {
    return map[addr.toLowerCase()] || `boba:${addr}`;
  };
}

function transformNearAddress() {
  return addr => {
    const bridgedAssetIdentifier = ".factory.bridge.near";
    if (addr.endsWith(bridgedAssetIdentifier))
      return `0x${addr.slice(0, addr.length - bridgedAssetIdentifier.length)}`;

    return addr
  };
}

const nearFixMapping = {
  "token.jumbo_exchange.near": {
    coingeckoId: "jumbo-exchange",
    decimals: 18
  },
  "token.paras.near": {
    coingeckoId: "paras",
    decimals: 18
  },
  "marmaj.tkn.near": {
    coingeckoId: "marmaj",
    decimals: 18
  },
  "linear-protocol.near": {
    coingeckoId: "linear-protocol",
    decimals: 24
  },
  "token.pembrock.near": {
    coingeckoId: "pembrock",
    decimals: 18
  },
  "token.burrow.near": {
    coingeckoId: "burrow",
    decimals: 18
  },
}

async function transformKlaytnAddress() {
  const mapping = {
    "0x5388ce775de8f7a69d17fd5caa9f7dbfee65dfce":
      "0x4576E6825B462b6916D2a41E187626E9090A92c6", // Donkey
    "0x02cbe46fb8a1f579254a9b485788f2d86cad51aa":
      "0x26fb86579e371c7aedc461b2ddef0a8628c93d3b", // bora
    "0x5c74070fdea071359b86082bd9f9b3deaafbe32b":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // dai
    "0x754288077d0ff82af7a5317c7cb8c444d421d103":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x0268dbed3832b87582b1fa508acf5958cbb1cd74":
      "bsc:0xf258f061ae2d68d023ea6e7cceef97962785c6c1", // IJM
    "0xcee8faf64bb97a73bb51e115aa89c17ffa8dd167":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0x168439b5eebe8c83db9eef44a0d76c6f54767ae4":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // pUSD
    "0x4fa62f1f404188ce860c8f0041d6ac3765a72e67":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // KSD
    "0xce40569d65106c32550626822b91565643c07823":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // KASH
    "0x210bc03f49052169d5588a52c317f71cf2078b85":
      "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // kBUSD
    "0x16d0e1fbd024c600ca0380a4c5d57ee7a2ecbf9c":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599", // WBTC
    "0x34d21b1e550d73cee41151c77f3c73359527a396":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0x0000000000000000000000000000000000000000": "0xd7a4d10070a4f7bc2a015e78244ea137398c3b74" // Klaytn
  };

  return addr => {
    addr = addr.toLowerCase();
    return mapping[addr] || `klaytn:${addr}`;
  };
}

function fixKlaytnBalances(balances) {
  const mapping = {
    "0xd7a4d10070a4f7bc2a015e78244ea137398c3b74": {
      coingeckoId: "klay-token",
      decimals: 18
    }, // Wrapped KLAY
    "0xe4f05a66ec68b54a58b17c22107b02e0232cc817": {
      coingeckoId: "klay-token",
      decimals: 18
    }, // Wrapped KLAY
    "0x9eaefb09fe4aabfbe6b1ca316a3c36afc83a393f": {
      coingeckoId: "ripple",
      decimals: 6
    },
    "0xd6dab4cff47df175349e6e7ee2bf7c40bb8c05a3": {
      coingeckoId: "tether",
      decimals: 6
    },
    "0xc6a2ad8cc6e4a7e08fc37cc5954be07d499e7654": {
      coingeckoId: "klayswap-protocol",
      decimals: 18
    } // KLAYSWAP
  };
  return fixBalances(balances, mapping);
}

function transformVelasAddress() {
  return addr => {
    const map = {
      "0x85219708c49aa701871ad330a94ea0f41dff24ca":
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
      "0xe41c4324dCbD2926481101f8580D13930AFf8A75":
        "velas:0xc579D1f3CF86749E05CD06f7ADe17856c2CE3126", // WVLX
      "0x6ab0B8C1a35F9F4Ce107cCBd05049CB1Dbd99Ec5":
        "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", // MATIC
      "0x639A647fbe20b6c8ac19E48E2de44ea792c62c5C":
        "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599", // WBTC
      "0x2B8e9cD44C9e09D936149549a8d207c918ecB5C4":
        "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB
      "0xc9b3aA6E91d70f4ca0988D643Ca2bB93851F3de4":
        "fantom:0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83", // FTM
      "0xe2c120f188ebd5389f71cf4d9c16d05b62a58993":
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
      "0x01445c31581c354b7338ac35693ab2001b50b9ae":
        "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
      "0xc111c29a988ae0c0087d97b33c6e6766808a3bd3":
        "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // BUSD
      "0x300a8be53b4b5557f48620d578e7461e3b927dd0":
        "0xf56842af3b56fd72d17cb103f92d027bba912e89" // BAMBOO
    };
    normalizeMapping(map)
    return map[addr.toLowerCase()] || `velas:${addr}`;
  };
}
async function transformCronosAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b",
    "0x09ad12552ec45f82be90b38dfe7b06332a680864":
      "polygon:0xc3fdbadc7c795ef1d6ba111e06ff8f16a20ea539" // ADDY
  };
  return addr => mapping[addr.toLowerCase()] || `cronos:${addr.toLowerCase()}`;
}

function fixShidenBalances(balances) {
  const mapping = {
    "0x0f933dc137d21ca519ae4c7e93f87a4c8ef365ef": {
      coingeckoId: "shiden",
      decimals: 18
    },
    "0xb4BcA5955F26d2fA6B57842655d7aCf2380Ac854": {
      coingeckoId: "emiswap",
      decimals: 18
    },
    "0x765277EebeCA2e31912C9946eAe1021199B39C61": {
      coingeckoId: "ethereum",
      decimals: 18
    },
    "0x332730a4f6e03d9c55829435f10360e13cfa41ff": {
      coingeckoId: "binancecoin",
      decimals: 18
    },
    "0x65e66a61d0a8f1e686c2d6083ad611a10d84d97a": {
      coingeckoId: "binance-usd",
      decimals: 18
    },
    "0x722377a047e89ca735f09eb7cccab780943c4cb4": {
      coingeckoId: "standard-protocol",
      decimals: 18
    }
  };

  return fixBalances(balances, mapping, { removeUnmapped: true });
}

function fixAstarBalances(balances) {
  const mapping = {
    "0xcdb32eed99aa19d39e5d6ec45ba74dc4afec549f": {
      coingeckoId: "orcus-oru",
      decimals: 18,
    },
    "0xc5bcac31cf55806646017395ad119af2441aee37": {
      coingeckoId: "muuu",
      decimals: 18,
    },
    "0x6df98e5fbff3041105cb986b9d44c572a43fcd22": {
      coingeckoId: "alnair-finance-nika",
      decimals: 18,
    },
    "0x29F6e49c6E3397C3A84F715885F9F233A441165C": {
      coingeckoId: "origin-dollar",
      decimals: 18,
    },
    "0xdd90e5e87a2081dcf0391920868ebc2ffb81a1af": {
      coingeckoId: "wmatic",
      decimals: 18,
    },
    "0x257f1a047948f73158dadd03eb84b34498bcdc60": {
      coingeckoId: "kagla-finance",
      decimals: 18,
    },
    "0xc4335b1b76fa6d52877b3046eca68f6e708a27dd": {
      coingeckoId: "starlay-finance",
      decimals: 18,
    },
    "0xde2578edec4669ba7f41c5d5d2386300bcea4678": {
      coingeckoId: "arthswap",
      decimals: 18,
    },
    "0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c": {
      coingeckoId: "ethereum",
      decimals: 18,
    },
    "0x7f27352d5f83db87a5a3e00f4b07cc2138d8ee52": {
      coingeckoId: "binancecoin",
      decimals: 18,
    },
    "0x75364D4F779d0Bd0facD9a218c67f87dD9Aff3b4": {
      coingeckoId: "shiden",
      decimals: 18,
    },
    "0xad543f18cff85c77e140e3e5e3c3392f6ba9d5ca": {
      coingeckoId: "bitcoin",
      decimals: 8,
    },
    "0x3795C36e7D12A8c252A20C5a7B455f7c57b60283": {
      coingeckoId: "tether",
      decimals: 6,
    },
    "0x430D50963d9635bBef5a2fF27BD0bDDc26ed691F": {
      coingeckoId: "tether",
      decimals: 6,
    },
    "0x19574c3c8fafc875051b665ec131b7e60773d2c9": {
      coingeckoId: "astar",
      decimals: 18,
    },
    "0xAeaaf0e2c81Af264101B9129C00F4440cCF0F720": {
      coingeckoId: "astar",
      decimals: 18,
    },
    "0xb361DAD0Cc1a03404b650A69d9a5ADB5aF8A531F": {
      coingeckoId: "emiswap",
      decimals: 18,
    },
    "0xC404E12D3466acCB625c67dbAb2E1a8a457DEf3c": {
      coingeckoId: "usd-coin",
      decimals: 6,
    }, // interest bearing USDC
    "0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98": {
      coingeckoId: "usd-coin",
      decimals: 6,
    },
    "0x6De33698e9e9b787e09d3Bd7771ef63557E148bb": {
      coingeckoId: "dai",
      decimals: 18,
    },
    "0x4dd9c468A44F3FEF662c35c1E9a6108B70415C2c": {
      coingeckoId: "dai",
      decimals: 18,
    },
    "0x4Bf769b05E832FCdc9053fFFBC78Ca889aCb5E1E": {
      coingeckoId: "binance-usd",
      decimals: 18,
    },
    "0xb7aB962c42A8Bb443e0362f58a5A43814c573FFb": {
      coingeckoId: "binance-usd",
      decimals: 18,
    },
    "0x733ebcC6DF85f8266349DEFD0980f8Ced9B45f35": {
      coingeckoId: "bai-stablecoin",
      decimals: 18,
    },
    "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF": {
      coingeckoId: "polkadot",
      decimals: 10,
    },
    "0x431D5dfF03120AFA4bDf332c61A6e1766eF37BDB": {
      coingeckoId: "jpy-coin",
      decimals: 18,
    },
  };

  return fixBalances(balances, mapping);
}

function fixHPBBalances(balances) {
  const mapping = {
    "0xBE05Ac1FB417c9EA435b37a9Cecd39Bc70359d31": {
      coingeckoId: "high-performance-blockchain",
      decimals: 18
    }
  };

  return fixBalances(balances, mapping, { removeUnmapped: true });
}

async function transformAstarAddress() {
  return addr => addr; // we use fix balances instead
}

const cronosFixMapping = {
  "0x45c135c1cdce8d25a3b729a28659561385c52671": {
    coingeckoId: "alethea-artificial-liquid-intelligence-token",
    decimals: 18
  },
  "0x39a65a74dc5a778ff93d1765ea51f57bc49c81b3": {
    coingeckoId: "akash-network",
    decimals: 6
  },
  "0xbed48612bc69fa1cab67052b42a95fb30c1bcfee": {
    coingeckoId: "shiba-inu",
    decimals: 18
  },
  "0x1a8e39ae59e5556b56b76fcba98d22c9ae557396": {
    coingeckoId: "dogecoin",
    decimals: 8
  },
  "0xb888d8dd1733d72681b30c00ee76bde93ae7aa93": {
    coingeckoId: "cosmos",
    decimals: 6
  },
  "0x02dccaf514c98451320a9365c5b46c61d3246ff3": {
    coingeckoId: "dogelon-mars",
    decimals: 18
  },
};

async function transformDfkAddress() {
  const mapping = {
    "0xb57b60debdb0b8172bb6316a9164bd3c695f133a":
      "avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", // AVAX
    "0x3ad9dfe640e1a9cc1d9b0948620820d975c3803a":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" // USDC
  };
  return addr => mapping[addr.toLowerCase()] || `dfk:${addr.toLowerCase()}`;
}
async function transformAuroraAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // Aurora gas -> WETH
    "0xda2585430fef327ad8ee44af8f1f989a2a91a3d2":
      "0x853d955aCEf822Db058eb8505911ED77F175b99e", // FRAX
    "0x07379565cd8b0cae7c60dc78e7f601b34af2a21c":
      "0x6b175474e89094c44da98b954eedeac495271d0f", //  nUSD -> DAI
  };

  normalizeMapping(mapping)
  return addr => mapping[addr.toLowerCase()] || `aurora:${addr.toLowerCase()}`;
}

function transformNovachainAddress() {
  const mapping = {
    "0x0000000000000000000000000000000000000000":
      "fantom:0x69D17C151EF62421ec338a0c92ca1c1202A427EC", // SNT
    "0x657a66332a65b535da6c5d67b8cd1d410c161a08":
      "fantom:0x69D17C151EF62421ec338a0c92ca1c1202A427EC", // SNT
    "0x1f5396f254ee25377a5c1b9c6bff5f44e9294fff":
      "fantom:0x04068da6c83afcfa0e13ba15a6696662335d5b75" // USDC
  };

  return transformChainAddress(mapping, "nova", { skipUnmapped: true });
}

function fixGodwokenBalances(balances) {
  const mapping = {
    "0xC3b946c53E2e62200515d284249f2a91d9DF7954": {
      coingeckoId: "usd-coin",
      decimals: 6
    }, // Wrapped USDC (ForceBridge from Ethereum)
    "0xA21B19d660917C1DE263Ad040Ba552737cfcEf50": {
      coingeckoId: "usd-coin",
      decimals: 18
    }, // Wrapped USDC (ForceBridge from BSC)
    "0x07a388453944bB54BE709AE505F14aEb5d5cbB2C": {
      coingeckoId: "tether",
      decimals: 6
    }, // Wrapped USDT (ForceBridge from Ethereum)
    "0x5C30d9396a97f2279737E63B2bf64CC823046591": {
      coingeckoId: "tether",
      decimals: 18
    }, // Wrapped USDT (ForceBridge from BSC)
    "0x7818FA4C71dC3b60049FB0b6066f18ff8c720f33": {
      coingeckoId: "bitcoin",
      decimals: 8
    }, // Wrapped BTC (ForceBridge from Ethereum)
    "0x3f8d2b24C6fa7b190f368C3701FfCb2bd919Af37": {
      coingeckoId: "bitcoin",
      decimals: 18
    } // Wrapped BTC (ForceBridge from BSC)
  };

  return fixBalances(balances, mapping);
}

const wavesMapping = {
  "5UYBPpq4WoU5n4MwpFkgJnW3Fq4B1u3ukpK33ik4QerR": {
    coingeckoId: "binancecoin",
    decimals: 8
  },
  DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p: {
    coingeckoId: "neutrino",
    decimals: 6
  },
  Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on: {
    coingeckoId: "waves-exchange",
    decimals: 8
  },
  "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu": {
    coingeckoId: "ethereum",
    decimals: 8
  },
  "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ": {
    coingeckoId: "tether",
    decimals: 6
  },
  "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS": {
    coingeckoId: "bitcoin",
    decimals: 8
  },
  WAVES: { coingeckoId: "waves", decimals: 8 },
  "2Fh9m3dNQXycHdnytEaETN3P1gDT7ij5U4HjMqQBeaqN": {
    coingeckoId: "ftx-token",
    decimals: 8
  },
  "4GZH8rk5vDmMXJ81Xqfm3ovFaczqMnQ11r7aELiNxWBV": {
    coingeckoId: "fantom",
    decimals: 8
  },
  "3KhNcHo4We1G5EWps7b1e5DTdLgWDzctc8S6ynu37KAb": {
    coingeckoId: "curve-dao-token",
    decimals: 8
  },
  GVxGPBtgVWMW1wHiFnfaCakbJ6sKgZgowJgW5Dqrd7JH: {
    coingeckoId: "shiba-inu",
    decimals: 2
  },
  HcHacFH51pY91zjJa3ZiUVWBww54LnsL4EP3s7hVGo9L: {
    coingeckoId: "matic-network",
    decimals: 8
  },
  "4YmM7mj3Av4DPvpNpbtK4jHbpzYDcZuY6UUnYpqTbzLj": {
    coingeckoId: "uniswap",
    decimals: 8
  },
  "6QUVF8nVVVvM7do7JT2eJ5o5ehnZgXUg13ysiB9JiQrZ": {
    coingeckoId: "terra-luna",
    decimals: 8
  },
  "7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt": {
    coingeckoId: "aave",
    decimals: 8
  },
  E4rss7qLUcawCvD2uMrbLeTMPGkX15kS3okWCbUhLNKL: {
    coingeckoId: "maker",
    decimals: 8
  },
  HLckRcg7hJ3Syf3PrGftFijKqQMJipf81WY3fwvHCJbe: {
    coingeckoId: "crypto-com-chain",
    decimals: 8
  },
  "8zUYbdB8Q6mDhpcXYv52ji8ycfj4SDX4gJXS7YY3dA4R": {
    coingeckoId: "dai",
    decimals: 6
  },
  "8DLiYZjo3UUaRBTHU7Ayoqg4ihwb6YH1AfXrrhdjQ7K1": {
    coingeckoId: "binance-usd",
    decimals: 6
  },
  "47cyc68FWJszCWEwMWVsD9CadjS2M1XtgANuRGbEW8UH": {
    coingeckoId: "cosmos",
    decimals: 8
  },
  "2bbGhKo5C31iEiB4CwGuqMYwjD7gCA9eXmm51fe2v8vT": {
    coingeckoId: "chainlink",
    decimals: 8
  },
  BLRxWVJWaVuR2CsCoTvTw2bDZ3sQLeTbCofcJv7dP5J4: {
    coingeckoId: "yearn-finance",
    decimals: 8
  },
  A1uMqYTzBdakuSNDv7CruWXP8mRZ4EkHwmip2RCauyZH: {
    coingeckoId: "the-graph",
    decimals: 8
  },
  "2thtesXvnVMcCnih9iZbJL3d2NQZMfzENJo8YFj6r5jU": {
    coingeckoId: "terrausd",
    decimals: 6
  },
  "2GBgdhqMjUPqreqPziXvZFSmDiQVrxNuGxR1z7ZVsm4Z": {
    coingeckoId: "apecoin",
    decimals: 8
  },
  Aug9ccbPApb1hxXSue8fHuvbyMf1FV1BYBtLUuS5LZnU: {
    coingeckoId: "decentraland",
    decimals: 8
  },
  ATQdLbehsMrmHZLNFhUm1r6s14NBT5JCFcSJGpaMrkAr: {
    coingeckoId: "axie-infinity",
    decimals: 8
  },
  "8YyrMfuBdZ5gtMWkynLTveRvGb6LJ4Aff9rpz46UUMW": {
    coingeckoId: "the-sandbox",
    decimals: 8
  },
  EfwRV6MuUCGgAUchdsF4dDFnSpKrDW3UYshdaDy4VBeB: {
    coingeckoId: "enjincoin",
    decimals: 8
  },
  "5zoDNRdwVXwe7DveruJGxuJnqo7SYhveDeKb8ggAuC34": {
    coingeckoId: "wrapped-bitcoin",
    decimals: 8
  },
  DSbbhLsSTeDg5Lsiufk2Aneh3DjVqJuPr2M9uU1gwy5p: {
    coingeckoId: "vires-finance",
    decimals: 8
  },
  // 'C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS': { coingeckoId: 'duck-egg', decimals: 8, },  // fix this with right coin gecko id
  "4LHHvYGNKJUg5hj65aGD5vgScvCBmLpdRFtjokvCjSL8": {
    coingeckoId: "waves-enterprise",
    decimals: 8
  },
  // 'HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS': { coingeckoId: 'puzzle', decimals: 8, },  // fix this with right coin gecko id
  // 'D4TPjtzpsDEJFS1pUAkvh1tJJJMNWGcSrds9sveBoQka': { coingeckoId: 'race', decimals: 8, },
  // '3UHgFQECoynwC3iunYBnbhzmcCzC5gVnVZMv8Yw1bneK': { coingeckoId: 'east', decimals: 8, },
  "6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g": {
    coingeckoId: "neutrino-system-base-token",
    decimals: 8
  },
  // 'DUk2YTxhRoAqMJLus4G2b3fR8hMHVh6eiyFx5r29VR6t': { coingeckoId: 'neutrino eur', decimals: 8, },
  Ehie5xYpeN8op1Cctc6aGUrqx8jq3jtf1DSjXDbfm7aT: {
    coingeckoId: "swop",
    decimals: 6
  },
  "7LMV3s1J4dKpMQZqge5sKYoFkZRLojnnU49aerqos4yg": {
    coingeckoId: "enno-cash",
    decimals: 8
  },
  "9sQutD5HnRvjM1uui5cVC4w9xkMPAfYEV8ymug3Mon2Y": {
    coingeckoId: "signaturechain",
    decimals: 8
  },
  DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J: {
    coingeckoId: "waves-community-token",
    decimals: 2
  },
  // 'AbunLGErT5ctzVN8MVjb4Ad9YgjpubB8Hqb17VxzfAck': { coingeckoId: 'Waves World', decimals: 0, },
  HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk: {
    coingeckoId: "litecoin",
    decimals: 8
  },
  "6XtHjpXbs9RRJP2Sr9GUyVqzACcby9TkThHXnjVC5CDJ": {
    coingeckoId: "usd-coin",
    decimals: 6
  }
};

function fixWavesBalances(balances) {
  return fixBalances(balances, wavesMapping);
}

function fixTezosBalances(balances) {
  const mapping = {
    KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn: { coingeckoId: "tzbtc", decimals: 8 },
    tezos: { coingeckoId: "tezos", decimals: 0 },
    KT1GRSvLoikDsXujKgZPsGLX8k8VvR2Tq95b: {
      coingeckoId: "plenty-dao",
      decimals: 18
    },
    KT1SjXiUX63QvdNMcM2m492f7kuf8JxXRLp4: { coingeckoId: "tezos", decimals: 6 }, // this is ctez, ideally should be valued higher
    KT1Ha4yFVeyzw6KRAdkzq6TxDHB97KG4pZe8: {
      coingeckoId: "dogami",
      decimals: 5
    },
    KT1JkoE42rrMBP9b2oDhbx6EUr26GcySZMUH: {
      coingeckoId: "kolibri-dao",
      decimals: 18
    },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-19": {
      coingeckoId: "wrapped-bitcoin",
      decimals: 8
    },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-17": {
      coingeckoId: "usd-coin",
      decimals: 6
    },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-1": {
      coingeckoId: "binance-usd",
      decimals: 18
    },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-20": {
      coingeckoId: "ethereum",
      decimals: 18
    },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-5": {
      coingeckoId: "dai",
      decimals: 18
    },
    KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ: { coingeckoId: "aave", decimals: 18 },
    "KT18fp5rcTW7mbWDmzFwjLDUhs5MeJmagDSZ-18": {
      coingeckoId: "tether",
      decimals: 6
    },
    KT1K9gCRgaLRFKTErYt1wVxA3Frb9FjasjTV: {
      coingeckoId: "kolibri-usd",
      decimals: 18
    },
    KT1LN4LPSqTMS7Sd2CJw4bbDGRkMv2t68Fy9: {
      coingeckoId: "usdtez",
      decimals: 6
    },
    KT1XRPEPXbZK25r3Htzp2o1x7xdMMmfocKNW: {
      coingeckoId: "youves-uusd",
      decimals: 12
    },
    // 'KT1XRPEPXbZK25r3Htzp2o1x7xdMMmfocKNW-1': { coingeckoId: 'youves-you-defi', decimals: 12, },  //uDEFI token - update gecko id here after adding in coin geckp
    KT1Xobej4mc6XgEjDoJoHtTKgbD1ELMvcQuL: {
      coingeckoId: "youves-you-governance",
      decimals: 12
    },
    "KT1XRPEPXbZK25r3Htzp2o1x7xdMMmfocKNW-2": {
      coingeckoId: "wrapped-bitcoin",
      decimals: 12
    }, // youves BTC
    KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY: {
      coingeckoId: "ethereum",
      decimals: 18
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-0": {
      coingeckoId: "ethereum",
      decimals: 18
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-1": {
      coingeckoId: "wrapped-bitcoin",
      decimals: 8
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-2": {
      coingeckoId: "usd-coin",
      decimals: 6
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-3": {
      coingeckoId: "tether",
      decimals: 6
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-4": {
      coingeckoId: "matic-network",
      decimals: 18
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-5": {
      coingeckoId: "chainlink",
      decimals: 18
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-6": {
      coingeckoId: "dai",
      decimals: 18
    }, // plenty bridge
    "KT1UsSfaXyqcjSVPeiD7U1bWgKy3taYN7NWY-7": {
      coingeckoId: "binance-usd",
      decimals: 18
    } // plenty bridge
  };

  return fixBalances(balances, mapping);
}

const songbirdFixMapping = {
  "0x02f0826ef6aD107Cfc861152B32B52fD11BaB9ED": {
    coingeckoId: "songbird",
    decimals: 18
  },
  "0xC348F894d0E939FE72c467156E6d7DcbD6f16e21": {
    coingeckoId: "flare-finance",
    decimals: 18
  },
  "0x70Ad7172EF0b131A1428D0c1F66457EB041f2176": {
    coingeckoId: "canary-dollar",
    decimals: 18
  }
};

const smartbchFixMapping = {
  [nullAddress]: {
    coingeckoId: "bitcoin-cash",
    decimals: 18
  },
  "0x3743ec0673453e5009310c727ba4eaf7b3a1cc04": {
    coingeckoId: "bitcoin-cash",
    decimals: 18
  },
  "0x0b00366fBF7037E9d75E4A569ab27dAB84759302": {
    coingeckoId: "law",
    decimals: 18
  },
  "0x7b2B3C5308ab5b2a1d9a94d20D35CCDf61e05b72": {
    coingeckoId: "flex-usd",
    decimals: 18
  },
  "0x24d8d5Cbc14FA6A740c3375733f0287188F8dF3b": {
    coingeckoId: "tropical-finance",
    decimals: 18
  },
  "0xBc2F884680c95A02cea099dA2F524b366d9028Ba": {
    coingeckoId: "tether",
    decimals: 18
  },
};

const evmosFixMapping = {
  "0x3F75ceabcdfed1aca03257dc6bdc0408e2b4b026": {
    coingeckoId: "diffusion",
    decimals: 18
  },
  "0xd4949664cd82660aae99bedc034a0dea8a0bd517": {
    coingeckoId: "evmos",
    decimals: 18
  }
};

const energywebFixMapping = {
  "0x6b3bd0478DF0eC4984b168Db0E12A539Cc0c83cd": {
    coingeckoId: "energy-web-token",
    decimals: 18
  }
};

const bittorrentFixMapping = {
  "0xca424b845497f7204d9301bd13ff87c0e2e86fcf": {
    coingeckoId: "usd-coin",
    decimals: 18
  },
  "0x9b5f27f6ea9bbd753ce3793a07cba3c74644330d": {
    coingeckoId: "tether",
    decimals: 18
  },
  "0x23181f21dea5936e24163ffaba4ea3b316b57f3c": {
    coingeckoId: 'bittorrent',
    decimals: 18,
  },
  "TNUC9Qb1rRpS5CbWLmNMxXBjyFoydXjWFR": {
    coingeckoId: 'tron',
    decimals: 6,
  }
};

const syscoinFixMapping = {
  "0xd3e822f3ef011Ca5f17D82C956D952D8d7C3A1BB": {
    coingeckoId: "syscoin",
    decimals: 18
  }
};

const kavaFixMapping = {
  "0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b": {
    coingeckoId: "kava",
    decimals: 18
  },
  "0x332730a4F6E03D9C55829435f10360E13cfA41Ff": {
    coingeckoId: "binance-usd",
    decimals: 18
  },
  "0x65e66a61D0a8F1e686C2D6083ad611a10D84D97A": {
    coingeckoId: "binancecoin",
    decimals: 18
  },
  "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f": {
    coingeckoId: "usd-coin",
    decimals: 6
  },
  "0xB44a9B6905aF7c801311e8F4E76932ee959c663C": {
    coingeckoId: "tether",
    decimals: 6
  },
  "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b": {
    coingeckoId: "bitcoin",
    decimals: 8
  },
  "0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D": {
    coingeckoId: "ethereum",
    decimals: 18
  },
  "0x765277EebeCA2e31912C9946eAe1021199B39C61": {
    coingeckoId: "dai",
    decimals: 18
  }
};

function normalizeMapping(mapping) {
  Object.keys(mapping).forEach(
    key => (mapping[key.toLowerCase()] = mapping[key])
  );
}

function fixBalances(balances, mapping, { removeUnmapped = false } = {}) {
  normalizeMapping(mapping);

  Object.keys(balances).forEach(token => {
    const tokenKey = stripTokenHeader(token).toLowerCase();
    const { coingeckoId, decimals } = mapping[tokenKey] || {};
    if (!coingeckoId) {
      if (removeUnmapped && tokenKey.startsWith('0x')) {
        console.log(
          `Removing token from balances, it is not part of whitelist: ${tokenKey}`
        );
        delete balances[token];
      }
      return;
    }
    const currentBalance = balances[token];
    delete balances[token];
    sdk.util.sumSingleBalance(
      balances,
      coingeckoId,
      +BigNumber(currentBalance).shiftedBy(-1 * decimals)
    );
  });

  return balances;
}

function stripTokenHeader(token) {
  token = token.toLowerCase();
  return token.indexOf(":") > -1 ? token.split(":")[1] : token;
}

async function getFixBalances(chain) {
  const dummyFn = i => i;
  return fixBalancesMapping[chain] || dummyFn;
}

const energiFixMapping = {
  "0x7A86173daa4fDA903c9A4C0517735a7d34B9EC39": {
    coingeckoId: "energi",
    decimals: 18
  },
  "0xa55f26319462355474a9f2c8790860776a329aa4": {
    coingeckoId: "energi",
    decimals: 18
  }
};

const palmFixMapping = {
  "0x4c1f6fcbd233241bf2f4d02811e3bf8429bc27b8": {
    coingeckoId: "dai",
    decimals: 18
  },
  "0x726138359c17f1e56ba8c4f737a7caf724f6010b": {
    coingeckoId: "ethereum",
    decimals: 18
  }
};

const ethereumFixMapping = {
  "0xf6b1c627e95bfc3c1b4c9b825a032ff0fbf3e07d": {
    coingeckoId: "jpyc",
    decimals: 18
  },
  "0x97fe22e7341a0cd8db6f6c021a24dc8f4dad855f": {
    coingeckoId: "jarvis-synthetic-british-pound",
    decimals: 18
  },
  "0x0f83287ff768d1c1e17a42f44d644d7f22e8ee1d": {
    coingeckoId: "upper-swiss-franc",
    decimals: 18
  },
  "0x9fcf418b971134625cdf38448b949c8640971671": {
    coingeckoId: "tether-eurt",
    decimals: 18
  },
  "0x8751d4196027d4e6da63716fa7786b5174f04c15": {
    coingeckoId: "wrapped-bitcoin",
    decimals: 18
  }
};

const sxFixMapping = {
  "0x90d27E008d5Db7f0a3c90a15A8Dcc4Ca18cFc670": {
    coingeckoId: "sx-network",
    decimals: 18
  },
  "0xA173954Cc4b1810C0dBdb007522ADbC182DaB380": {
    coingeckoId: "ethereum",
    decimals: 18
  },
  "0xe2aa35C2039Bd0Ff196A6Ef99523CC0D3972ae3e": {
    coingeckoId: "usd-coin",
    decimals: 6
  },
  "0xfa6F64DFbad14e6883321C2f756f5B22fF658f9C": {
    coingeckoId: "matic-network",
    decimals: 18
  },
  "0x53813CD4aCD7145A716B4686b195511FA93e4Cb7": {
    coingeckoId: "dai",
    decimals: 18
  },
  "0xa0cB58E7F783fce0F4042C790ea3045c48CD51e8": {
    coingeckoId: "shark",
    decimals: 18
  }
};

const meterFixMapping = {
  "0xd86e243fc0007e6226b07c9a50c9d70d78299eb5": {
    coingeckoId: "usd-coin",
    decimals: 6
  },
  "0x5729cb3716a315d0bde3b5e489163bf8b9659436": {
    coingeckoId: "meter",
    decimals: 18
  },
  "0x6abaedab0ba368f1df52d857f24154cc76c8c972": {
    coingeckoId: "meter-stable",
    decimals: 18
  },
  "0x24aa189dfaa76c671c279262f94434770f557c35": {
    coingeckoId: "binance-usd",
    decimals: 18
  },
  "0x5fa41671c48e3c951afc30816947126ccc8c162e": {
    coingeckoId: "tether",
    decimals: 6
  }
};

const callistoFixMapping = {
  "0xF5AD6F6EDeC824C7fD54A66d241a227F6503aD3a": {
    coingeckoId: "callisto",
    decimals: 18
  },
  "0xbf6c50889d3a620eb42c0f188b65ade90de958c4": {
    coingeckoId: "tether",
    decimals: 18
  },
  "0xccc766f97629a4e14b3af8c91ec54f0b5664a69f": {
    coingeckoId: "ethereum-classic",
    decimals: 18
  },
  "0xcc208c32cc6919af5d8026dab7a3ec7a57cd1796": {
    coingeckoId: "ethereum",
    decimals: 18
  },
  "0xccde29903e621ca12df33bb0ad9d1add7261ace9": {
    coingeckoId: "binancecoin",
    decimals: 18
  },
  "0x9FaE2529863bD691B4A7171bDfCf33C7ebB10a65": {
    coingeckoId: "soy-finance",
    decimals: 18
  },
};

const thundercoreFixMapping = {
  "0x4f3c8e20942461e2c3bdd8311ac57b0c222f2b82": {
    coingeckoId: "tether",
    decimals: 6
  },
  "0x22e89898a04eaf43379beb70bf4e38b1faf8a31e": {
    coingeckoId: "usd-coin",
    decimals: 6
  },
};

const ontologyFixMapping = {
  "0xd8bc24cfd45452ef2c8bc7618e32330b61f2691b": {
    coingeckoId: "ong",
    decimals: 18,
  },
};

const fixBalancesMapping = {
  avax: fixAvaxBalances,
  evmos: b => fixBalances(b, evmosFixMapping, { removeUnmapped: false }),
  astar: fixAstarBalances,
  shiden: fixShidenBalances,
  cronos: b => fixBalances(b, cronosFixMapping, { removeUnmapped: false }),
  tezos: fixTezosBalances,
  harmony: fixHarmonyBalances,
  hpb: fixHPBBalances,
  godwoken: fixGodwokenBalances,
  klaytn: fixKlaytnBalances,
  waves: fixWavesBalances,
  songbird: b => fixBalances(b, songbirdFixMapping, { removeUnmapped: true }),
  energi: b => fixBalances(b, energiFixMapping, { removeUnmapped: true }),
  smartbch: b => fixBalances(b, smartbchFixMapping, { removeUnmapped: true }),
  energyweb: b => fixBalances(b, energywebFixMapping, { removeUnmapped: true }),
  palm: b => fixBalances(b, palmFixMapping, { removeUnmapped: true }),
  oasis: fixOasisBalances,
  bittorrent: b =>
    fixBalances(b, bittorrentFixMapping, { removeUnmapped: false }),
  syscoin: b => fixBalances(b, syscoinFixMapping, { removeUnmapped: true }),
  kava: b => fixBalances(b, kavaFixMapping, { removeUnmapped: false }),
  ethereum: b => fixBalances(b, ethereumFixMapping, { removeUnmapped: false }),
  sx: b => fixBalances(b, sxFixMapping, { removeUnmapped: true }),
  meter: b => fixBalances(b, meterFixMapping, { removeUnmapped: true }),
  callisto: b => fixBalances(b, callistoFixMapping, { removeUnmapped: true }),
  near: b => fixBalances(b, nearFixMapping, { removeUnmapped: false }),
  thundercore: b => fixBalances(b, thundercoreFixMapping, { removeUnmapped: true }),
  ontology_evm: b => fixBalances(b, ontologyFixMapping, { removeUnmapped: false }),
};

const chainTransforms = {
  astar: transformAstarAddress,
  fuse: transformFuseAddress,
  celo: transformCeloAddress,
  cronos: transformCronosAddress,
  evmos: transformEvmosAddress,
  fantom: transformFantomAddress,
  bsc: transformBscAddress,
  boba: transformBobaAddress,
  polygon: transformPolygonAddress,
  xdai: transformXdaiAddress,
  avax: transformAvaxAddress,
  heco: transformHecoAddress,
  hoo: transformHooAddress,
  harmony: transformHarmonyAddress,
  optimism: transformOptimismAddress,
  moonriver: transformMoonriverAddress,
  milkomeda: transformMilkomedaAddress,
  okex: transformOkexAddress,
  kcc: transformKccAddress,
  arbitrum: transformArbitrumAddress,
  iotex: transformIotexAddress,
  metis: transformMetisAddress,
  near: transformNearAddress,
  moonbeam: transformMoonbeamAddress,
  klaytn: transformKlaytnAddress,
  velas: transformVelasAddress,
  ethereum: transformEthereumAddress,
  oasis: transformOasisAddress,
  dfk: transformDfkAddress,
  aurora: transformAuroraAddress,
  findora: transformFindoraAddress,
  bittorrent: transformBittorrentAddress,
  reichain: transformReichainAddress,
  nova: transformNovachainAddress,
};

async function transformReichainAddress() {
  const mapping = {
    "0xDD2bb4e845Bd97580020d8F9F58Ec95Bf549c3D9":
      "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // killswitch busd -> busd token
    "0xf8ab4aaf70cef3f3659d3f466e35dc7ea10d4a5d":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c" // killswitch bnb -> bnb token
  };

  return transformChainAddress(mapping, "reichain", { skipUnmapped: true });
}

async function transformEthereumAddress() {
  const mapping = {
    "0x88536c9b2c4701b8db824e6a16829d5b5eb84440":
      "polygon:0xac63686230f64bdeaf086fe6764085453ab3023f", // USV token
    "0xFEEf77d3f69374f66429C91d732A244f074bdf74":
      "0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0", // CVX FXS token
    "0xb8c77482e45f1f44de1745f52c74426c631bdd52":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB
    "0xeb637a9ab6be83c7f8c79fdaa62e1043b65534f0":
      "heco:0xcbd6cb9243d8e3381fea611ef023e17d1b7aedf0", // BXH
    "0x18a1ea69a50a85752b7bc204a2c45a95ce6e429d":
      "avax:0xf30c5083a1479865c9a8916dec6ddadd82e8907b", // SPICE
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // ETH -> WETH
    "0x18084fbA666a33d37592fA2633fD49a74DD93a88":
      "0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa", //tBTC
    "0xef779cf3d260dbe6177b30ff08b10db591a6dd9c":
      "0x0000000000085d4780B73119b644AE5ecd22b376", // kUSD
    "0x42ef9077d8e79689799673ae588e046f8832cb95":
      "0x0000000000085d4780B73119b644AE5ecd22b376", //fUSD
    "0x99534ef705df1fff4e4bd7bbaaf9b0dff038ebfe":
      "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0", // aMATICb
    "0xd3d13a578a53685b4ac36a1bab31912d2b2a2f36":
      "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // tWETH
    "0x94671a3cee8c7a12ea72602978d1bb84e920efb2":
      "0x853d955aCEf822Db058eb8505911ED77F175b99e", // tFRAX
    "0x2fc6e9c1b2c07e18632efe51879415a580ad22e1":
      "0x6bea7cfef803d1e3d5f7c0103f7ded065644e197", // tGAMMA
    "0xeff721eae19885e17f5b80187d6527aad3ffc8de":
      "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f", // tSNX
    "0xdc0b02849bb8e0f126a216a2840275da829709b0":
      "0x4104b135dbc9609fc1a9490e61369036497660c8", // tAPW
    "0x15a629f0665a3eb97d7ae9a7ce7abf73aeb79415":
      "0x9C4A4204B79dd291D6b6571C5BE8BbcD0622F050", // tTCR
    "0x808d3e6b23516967ceae4f17a5f9038383ed5311":
      "0xc770EEfAd204B5180dF6a14Ee197D99d808ee52d", // tFOX
    "0xf49764c9c5d644ece6ae2d18ffd9f1e902629777":
      "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2", // tSUSHI
    "0xd3b5d9a561c293fb42b446fe7e237daa9bf9aa84":
      "0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF", // tALCX
    "0xadf15ec41689fc5b6dca0db7c53c9bfe7981e655":
      "0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0", // tFXS
    "0xc7d9c108d4e1dd1484d3e2568d7f74bfd763d356":
      "0x0000000000085d4780B73119b644AE5ecd22b376", // XSTUSD
    "0x65f7ba4ec257af7c55fd5854e5f6356bbd0fb8ec":
      "0x92d6c1e31e14520e676a687f0a93788b716beff5", // sDYDX
    "0x586aa273f262909eef8fa02d90ab65f5015e0516":
      "0x0000000000085d4780B73119b644AE5ecd22b376", // FIAT
    "0x0a5e677a6a24b2f1a2bf4f3bffc443231d2fdec8":
      "bsc:0xb5102cee1528ce2c760893034a4603663495fd72", // USX
  };
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    return mapping[addr] || addr;
  };
}

function transformBittorrentAddress() {
  const mapping = {
    "0xdb28719f7f938507dbfe4f0eae55668903d34a15":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0x935faa2fcec6ab81265b301a30467bbc804b43d3":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x8d193c6efa90bcff940a98785d1ce9d093d3dc8a":
      "0xc669928185dbce49d2230cc9b0979be6dc797957", // BTT
    "0x17f235fd5974318e4e2a5e37919a209f7c37a6d1":
      "0x0c10bf8fcb7bf5412187a595ab97a3609160b5c6", // USDD
    "0xae17940943ba9440540940db0f1877f101d39e8b":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0xedf53026aea60f8f75fca25f8830b7e2d6200662":
      "tron:TNUC9Qb1rRpS5CbWLmNMxXBjyFoydXjWFR", // TRX
    "0x1249c65afb11d179ffb3ce7d4eedd1d9b98ad006":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0xe887512ab8bc60bcc9224e1c3b5be68e26048b8b":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0xe467f79e9869757dd818dfb8535068120f6bcb97":
      "0xdefa4e8a7bcba345f687a2f1456f5edd9ce97202", // KNC
    "0x9888221fe6b5a2ad4ce7266c7826d2ad74d40ccf":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599" // WBTC
  };
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    return mapping[addr] || addr;
  };
}

async function transformMilkomedaAddress() {
  const mapping = {
    "0x7f27352d5f83db87a5a3e00f4b07cc2138d8ee52":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB token
    // '0x0000000000000000000000000000000000000000': '' // MilkADA
    "0x5950F9B6EF36f3127Ea66799e64D0ea1f5fdb9D1":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0x41eAFC40CD5Cb904157A10158F73fF2824dC1339":
      "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
    "0xab58DA63DFDd6B97EAaB3C94165Ef6f43d951fb2":
      "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0x5a955FDdF055F2dE3281d99718f5f1531744B102":
      "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0x48AEB7584BA26D3791f06fBA360dB435B3d7A174":
      "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599" // WBTC
  };

  return transformChainAddress(mapping, "milkomeda");
}

async function transformFindoraAddress() {
  const mapping = {
    "0xABc979788c7089B516B8F2f1b5cEaBd2E27Fd78b":
      "bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", // BNB token
    "0x008A628826E9470337e0Cd9c0C944143A83F32f3":
      "bsc:0x2170ed0880ac9a755fd29b2688956bd959f933f8", // ETH token
    "0x93EDFa31D7ac69999E964DAC9c25Cd6402c75DB3":
      "bsc:0x55d398326f99059ff775485246999027b3197955", // USDT token
    "0xdA33eF1A7b48beBbF579eE86DFA735a9529C4950":
      "bsc:0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", // USDC token
    "0xE80EB4a234f718eDc5B76Bb442653827D20Ebb2d":
      "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // BUSD token
    "0x07EfA82E00E458ca3D53f2CD5B162e520F46d911":
      "bsc:0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c" //  WBTC token
  };

  return transformChainAddress(mapping, "findora");
}

function transformChainAddress(
  mapping,
  chain,
  { skipUnmapped = false, chainName = "" } = {}
) {
  normalizeMapping(mapping);

  return addr => {
    addr = addr.toLowerCase();
    if (!mapping[addr] && skipUnmapped) {
      console.log(
        "Mapping for addr %s not found in chain %s, returning garbage address",
        addr,
        chain
      );
      return "0x1000000000000000000000000000000000000001";
    }
    return mapping[addr] || `${chain}:${addr}`;
  };
}

async function getChainTransform(chain) {
  if (chainTransforms[chain]) return chainTransforms[chain]();

  return addr => `${chain}:${addr}`;
}

module.exports = {
  getChainTransform,
  getFixBalances,
  transformCeloAddress,
  transformCronosAddress,
  transformFantomAddress,
  transformBscAddress,
  transformPolygonAddress,
  transformXdaiAddress,
  transformAvaxAddress,
  transformHecoAddress,
  transformHarmonyAddress,
  transformOptimismAddress,
  transformMoonriverAddress,
  fixAvaxBalances,
  transformOkexAddress,
  transformKccAddress,
  transformArbitrumAddress,
  fixHarmonyBalances,
  fixBscBalances,
  fixOasisBalances,
  transformIotexAddress,
  transformMetisAddress,
  transformBobaAddress,
  transformNearAddress,
  transformMoonbeamAddress,
  transformKlaytnAddress,
  transformVelasAddress,
  transformEthereumAddress,
  transformOasisAddress,
  transformOasisAddressBase,
  transformMilkomedaAddress,
  transformDfkAddress,
  transformFindoraAddress,
  transformEvmosAddress,
  wavesMapping,
  stripTokenHeader,
  transformBittorrentAddress,
  transformAuroraAddress
};

'''
'''--- projects/helper/processPairs.js ---
const sdk = require("@defillama/sdk");
// --- ABI's required ---
const factoryAbi = require("./abis/factory.json");
const token0 = require("./abis/token0.json");
const token1 = require("./abis/token1.json");
const getReserves = require("./abis/getReserves.json");

async function processPairs(balances, pairNums, chain, block, factory) {
  const pairs = (
    await sdk.api.abi.multiCall({
      abi: factoryAbi.allPairs,
      chain,
      calls: pairNums.map((num) => ({
        target: factory,
        params: [num],
      })),
    })
  ).output;

  // --- In case pairs returns empty array, does not make sense to move down (avoid errs output) ---
  if (pairs.length == 0) return;

  // --- In case that output is null will not make sense to move further (avoid errs output) ---
  if (pairs[0].output == null) return;

  const pairAddresses = pairs.map((result) => result.output.toLowerCase());
  const [token0Addresses, token1Addresses, reserves] = await Promise.all([
    sdk.api.abi
      .multiCall({
        abi: token0,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: token1,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: getReserves,
        chain,
        calls: pairAddresses.map((pairAddress) => ({
          target: pairAddress,
        })),
        block,
      })
      .then(({ output }) => output),
  ]);

  for (let n = 0; n < pairNums.length; n++) {
    // --- Added try/catch block for both outputs from reserve and check null vals before ---
        sdk.util.sumSingleBalance(
          balances,
          `${chain}:${token1Addresses[n].output}`,
          reserves[n].output[1]
        );
        sdk.util.sumSingleBalance(
          balances,
          `${chain}:${token0Addresses[n].output}`,
          reserves[n].output[0]
        );
  }
}

const tvlOnPairs = async (chain, chainBlocks, factoryTarget, balances) => {
  const pairLength = Number(
    (
      await sdk.api.abi.call({
        target: factoryTarget,
        abi: factoryAbi.allPairsLength,
        chain,
        block: chainBlocks[chain],
      })
    ).output
  );

  const allPairNums = Array.from(Array(pairLength).keys());
  const reqs = [];

  for (let i = 0; i < pairLength; i++) {
    const pairNums = allPairNums.slice(i, i + 1);

    const output = processPairs(
      balances,
      pairNums,
      chain,
      chainBlocks[chain],
      factoryTarget
    );

    if (output != undefined) {
      reqs.push(output);
    }
  }

  await Promise.all(reqs);
};

module.exports = tvlOnPairs;

'''
'''--- projects/helper/proton.js ---
const axios = require('axios');
const retry = require('./retry')

const CHAIN_RPC = 'https://proton.greymass.com';
const SWAP_CONTRACT = 'proton.swaps';
const ORACLES_CONTRACT = 'oracles';

async function getTableRows({
  json = true,
  code,
  scope,
  table,
  lower_bound = '',
  upper_bound = '',
  index_position = 1,
  key_type = '',
  limit = -1,
  reverse = false,
  show_payer = false,
}) {
  try {
    const { data } = await axios.default.post(
      CHAIN_RPC + '/v1/chain/get_table_rows',
      JSON.stringify({
        json,
        code,
        scope,
        table,
        lower_bound,
        upper_bound,
        index_position,
        key_type,
        limit,
        reverse,
        show_payer,
      })
    );
    return data;
  } catch (e) {
    console.error(e);
  }
}

async function getFullTable ({
  code,
  scope,
  table,
  lower_bound,
  upper_bound,
}) {
  let { rows, more, next_key } = await getTableRows({
    code,
    scope,
    table,
    lower_bound,
    upper_bound,
    limit: -1
  })

  if (more) {
    rows = rows.concat(await getFullTable({
      code,
      scope,
      table,
      lower_bound: next_key,
      upper_bound
    }))
  }

  return rows
}

async function getCurrencyBalance(code, account, symbol) {
  try {
    const { data } = await axios.default.post(
      CHAIN_RPC + '/v1/chain/get_currency_balance',
      JSON.stringify({
        code,
        account,
        symbol
      })
    );
    return data;
  } catch (e) {
    console.error(e);
  }
}

async function getAllOracleData(lower_bound) {
  try {
    return await getFullTable({
      code: ORACLES_CONTRACT,
      scope: ORACLES_CONTRACT,
      table: 'data',
      limit: -1,
      lower_bound: lower_bound,
    });
  } catch (e) {
    return [];
  }
}

async function getAllSwapPools(lower_bound) {
  try {
    return await getFullTable({
      code: SWAP_CONTRACT,
      scope: SWAP_CONTRACT,
      table: 'pools',
      limit: -1,
      lower_bound: lower_bound,
    });
  } catch (e) {
    return [];
  }
}

async function getTokenPriceUsd(tokenSymbol, tokenContract) {
  const { data: tokens } = await axios.get('https://api.protonchain.com/v1/chain/exchange-rates/info')
  const token = tokens.find(token => token.symbol === tokenSymbol && token.contract === tokenContract)
  const exchangeRate = token.rates.find(rate => rate.counterCurrency === 'USD')
  return exchangeRate.price
}

module.exports = {
  getTableRows,
  getCurrencyBalance,
  getAllOracleData,
  getAllSwapPools,
  getTokenPriceUsd
}
'''
'''--- projects/helper/requery.js ---
const sdk = require('@defillama/sdk');

async function requery(resultsRaw, chain, block, abi) {
    const results = resultsRaw.output;
    if (results.some(r => !r.success)) {
        const failed = results.map((r, i) => [r, i]).filter(r => !r[0].success)
        const newResults = await sdk.api.abi
            .multiCall({
                abi,
                chain,
                calls: failed.map((f) => f[0].input),
                block,
            }).then(({ output }) => output);
        failed.forEach((f, i) => {
            results[f[1]] = newResults[i]
        })
    }
}

module.exports = {
    requery
}
'''
'''--- projects/helper/resolveCrvTokens.js ---

const sdk = require('@defillama/sdk')
const BigNumber = require('bignumber.js')

const curvePoolsPartial = require('../convex/pools-crv')
const abi = require('../concentrator/abis/abi.json')
const AladdinCRVABI = require('../concentrator/abis/AladdinCRV.json')
const crvPools = require('./curvePools')

const replacements = [
  '0x99d1Fa417f94dcD62BfE781a1213c092a47041Bc',
  '0x9777d7E2b60bB01759D0E2f8be2095df444cb07E',
  '0x1bE5d71F2dA660BFdee8012dDc58D024448A0A59',
  '0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01',
  '0xd6aD7a6750A7593E092a9B218d66C0A814a3436e',
  '0x83f798e925BcD4017Eb265844FDDAbb448f1707D',
  '0x73a052500105205d34Daf004eAb301916DA8190f'
]

const curvePools = [
  {
    assets: 'Curve.fi Factory USD Metapool: moUSD',
    isLendingPool: true,
    coins: ['0x60d55f02a771d515e077c9c2403a1ef324885cec', '0x27f8d03b3a2196956ed754badc28d73be8830a6e', '0x1a13f4ca1d028320a707d99520abfefca3998b7f'],
    addresses: {
      swap: '0x445fe580ef8d70ff569ab36e80c647af338db351',
      lpToken: '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171',
      gauge: '0x19793b454d3afc7b454f206ffe95ade26ca6912c',
    },
  }
]

const gaugeLPMapping = {}

Object.keys(crvPools).forEach(key => crvPools[key.toLowerCase()] = crvPools[key])

const curveLPMapping = [...curvePoolsPartial, ...curvePools].reduce((accum, poolData) => {
  accum[poolData.addresses.lpToken.toLowerCase()] = poolData
  if (poolData.addresses.gauge) {
    const gaugeToken = poolData.addresses.gauge.toLowerCase()
    gaugeLPMapping[gaugeToken] = poolData.addresses.lpToken
    accum[gaugeToken] = poolData
  }
  return accum
}, {})

async function unwrapCrvKnown(balances, crvToken, lpBalance, block, chain = 'ethereum', transformAddress = (addr) => addr, excludeTokensRaw = []) {
  crvToken = stripChainHeader(crvToken).toLowerCase()
  const excludeTokens = excludeTokensRaw.map(addr => addr.toLowerCase())
  if (crvPools[crvToken] === undefined)
    return;

  const crvSwapContract = crvPools[crvToken].swapContract
  const underlyingTokens = crvPools[crvToken].underlyingTokens
  const crvTotalSupply = sdk.api.erc20.totalSupply({
    target: crvToken,
    block,
    chain
  })
  const underlyingSwapTokens = (await sdk.api.abi.multiCall({
    calls: underlyingTokens.map(token => ({
      target: token,
      params: [crvSwapContract]
    })),
    block,
    chain,
    abi: 'erc20:balanceOf'
  })).output

  // steth and seth case where balanceOf not applicable on ETH balance
  if (crvToken.toLowerCase() === '0x06325440d014e39736583c165c2963ba99faf14e' || crvToken.toLowerCase() === '0xa3d87fffce63b53e0d54faa1cc983b7eb0b74a9c') {
    underlyingSwapTokens[0].output = underlyingSwapTokens[0].output * 2
  }

  const resolvedCrvTotalSupply = (await crvTotalSupply).output
  underlyingSwapTokens.forEach(call => {
    if (excludeTokens.includes(call.input.target.toLowerCase())) return;
    const underlyingBalance = BigNumber(call.output).times(lpBalance).div(resolvedCrvTotalSupply)
    sdk.util.sumSingleBalance(balances, transformAddress(call.input.target), underlyingBalance.toFixed(0))
  })
}

const cGaugeMapping = {
  avax: {
    '0x5b5cfe992adac0c9d48e05854b2d91c73a003858': '0x1337BedC9D22ecbe766dF105c9623922A27963EC',
  },
  polygon: {
    '0x19793b454d3afc7b454f206ffe95ade26ca6912c': '0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171',
  }
}
Object.values(cGaugeMapping).forEach(mapping => Object.keys(mapping).forEach(key => mapping[key.toLowerCase()] = mapping[key]))

async function unwrapCrv(balances, crvToken, lpBalance, block, chain = 'ethereum', transformAddress = (addr) => addr) {
  crvToken = stripChainHeader(crvToken).toLowerCase()
  const gaugeMap = cGaugeMapping[chain] || {}
  if (gaugeMap[crvToken]) crvToken = gaugeMap[crvToken]

  if (crvPools[crvToken]) return unwrapCrvKnown(...arguments)

  const poolData = curveLPMapping[crvToken]

  if (!poolData) return balances
  const swapAddress = poolData.addresses.swap

  const coinCalls = [...Array(Number(poolData.coins.length)).keys()].map(num => {
    return {
      target: swapAddress,
      params: [num]
    }
  })

  const coinsUint = sdk.api.abi.multiCall({
    abi: abi.coinsUint,
    calls: coinCalls,
    block, chain,
  })

  const coinsInt = sdk.api.abi.multiCall({
    abi: abi.coinsInt,
    calls: coinCalls,
    block, chain,
  })

  let coins = await coinsUint
  if (!coins.output[0].success) {
    coins = await coinsInt
  }
  const coinBalances = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    calls: coins.output.map(coin => ({
      target: coin.output,
      params: [swapAddress]
    })),
    block, chain,
  })
  const totalSupply = (await sdk.api.abi.call({
    target: gaugeLPMapping[crvToken] ? gaugeLPMapping[crvToken] : crvToken,
    block,
    chain,
    abi: AladdinCRVABI.totalSupply,
    params: []
  })).output

  await Promise.all(coinBalances.output.map(async (coinBalance, index) => {
    let coinAddress = coins.output[index].output
    if (replacements.includes(coinAddress)) {
      coinAddress = '0x6b175474e89094c44da98b954eedeac495271d0f' // dai
    }
    if (coinBalance.input.target === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE') {
      coinBalance = await sdk.api.eth.getBalance({
        target: coinBalance.input.params[0],
        block, chain,
      })
      coinAddress = '0x0000000000000000000000000000000000000000'
    }

    const balance = BigNumber(lpBalance).times(coinBalance.output).div(totalSupply)
    if (!balance.isZero()) {
      sdk.util.sumSingleBalance(balances, transformAddress(coinAddress), balance.toFixed(0))
    }
  }))

  return balances
}

function stripChainHeader(token) {
  return token.indexOf(':') > -1 ? token.split(':')[1] : token
}

function getCrvTokens(balances) {
  return Object.keys(balances)
    .filter(isCrvToken)
    .map(token => ({ token, balance: balances[token] }))

  function isCrvToken(token) {
    token = stripChainHeader(token).toLowerCase()
    return crvPools[token] || curveLPMapping[token]
  }
}

async function resolveCrvTokens(balances, block, chain = 'ethereum', transformAddress = (addr) => addr) {
  let crvTokens = getCrvTokens(balances)
  let count = 0
  while (crvTokens.length && count < 6) {
    crvTokens.forEach(({ token }) => delete balances[token])
    await Promise.all(crvTokens.map(({ token, balance }) =>
      unwrapCrv(balances, token, balance, block, chain, transformAddress)))
    crvTokens = getCrvTokens(balances)
    count++
  }

  if (crvTokens.length)
    console.log('unresolved crv tokens:', crvTokens)
  return balances
}

module.exports = {
  unwrapCrv,
  resolveCrvTokens,
}
'''
'''--- projects/helper/retry.js ---
const retryModule = require('async-retry')

async function retry(func){
    return retryModule(func, {
        retries:3
    })
}

module.exports = retry
'''
'''--- projects/helper/solana.js ---
const BigNumber = require("bignumber.js");
const axios = require("axios");
const http = require('./http')
const { Connection, PublicKey, Keypair } = require("@solana/web3.js")
const { Provider } = require("@project-serum/anchor");
const { NodeWallet } = require("@project-serum/anchor/dist/cjs/provider");
const BufferLayout = require("@solana/buffer-layout")
const { MintLayout, TOKEN_PROGRAM_ID } = require("@solana/spl-token")
const { sleep, sliceIntoChunks } = require('./utils')

const solscan_base = "https://public-api.solscan.io/account/"

let connection, provider

const endpoint = process.env.SOLANA_RPC || "https://solana-api.projectserum.com/" // or "https://api.mainnet-beta.solana.com"

function getConnection() { 
  if (!connection)  connection = new Connection(endpoint)
  return connection

}

function getProvider() {
  if (!provider) {
    const dummy_keypair = Keypair.generate();
    const wallet = new NodeWallet(dummy_keypair);
  
    provider = new Provider(
      getConnection(), wallet
    );
  }
  return provider;
}

async function getSolBalance(account) {
  const solBalance = await axios
    .get(solscan_base + account)
    .then((r) => r.data.lamports);
  return new BigNumber(solBalance).div(1e9).toString(10);
}

const TOKEN_LIST_URL = "https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json"

async function getTokenSupply(token) {
  const tokenSupply = await axios.post(endpoint, {
    jsonrpc: "2.0",
    id: 1,
    method: "getTokenSupply",
    params: [token],
  });
  return tokenSupply.data.result.value.uiAmount;
}

async function getTokenBalance(token, account) {
  const tokenBalance = await axios.post(endpoint, {
    jsonrpc: "2.0",
    id: 1,
    method: "getTokenAccountsByOwner",
    params: [
      account,
      {
        mint: token,
      },
      {
        encoding: "jsonParsed",
      },
    ],
  });
  return tokenBalance.data.result.value.reduce(
    (total, account) =>
      total + account.account.data.parsed.info.tokenAmount.uiAmount,
    0
  );
}

async function getTokenAccountBalance(account) {
  const tokenBalance = await axios.post(
    endpoint,
    {
      jsonrpc: "2.0",
      id: 1,
      method: "getTokenAccountBalance",
      params: [account],
    },
    {
      headers: { "Content-Type": "application/json" },
    }
  );
  return tokenBalance.data.result?.value?.uiAmount;
}

let tokenList
let _tokenList

async function getTokenList() {
  if (!_tokenList)
    _tokenList = http.get(TOKEN_LIST_URL)
  tokenList = (await _tokenList).tokens
  return tokenList
}

// tokenList is giant, Map lookups are more performant than object lookups so use a Map
async function getTokenMap() {
  return (await getTokenList()).reduce((map, token) => {
    map.set(token.address, token);
    return map;
  }, new Map())
}

async function getCoingeckoId() {
  const tokenlist = await getTokenList();
  return address => tokenlist.find((t) => t.address === address)?.extensions
    ?.coingeckoId;
}

// Example: [[token1, account1], [token2, account2], ...]
async function sumTokens(tokensAndAccounts) {
  const tokenlist = await axios
    .get(
      "https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json"
    )
    .then((r) => r.data.tokens);
  const tokenBalances = await Promise.all(
    tokensAndAccounts.map((t) => getTokenBalance(...t))
  );
  const balances = {};
  for (let i = 0; i < tokensAndAccounts.length; i++) {
    const token = tokensAndAccounts[i][0];
    let coingeckoId = tokenlist.find((t) => t.address === token)?.extensions
      ?.coingeckoId;
    const replacementCoingeckoId = tokensAndAccounts[i][2];
    if (coingeckoId === undefined) {
      if (replacementCoingeckoId !== undefined) {
        coingeckoId = replacementCoingeckoId;
      } else {
        throw new Error(`Solana token ${token} has no coingecko id`);
      }
    }
    balances[coingeckoId] = (balances[coingeckoId] || 0) + tokenBalances[i];
  }
  return balances;
}

// Example: [[token1, account1], [token2, account2], ...]
async function sumTokensUnknown(tokensAndAccounts) {
  const tokenlist = await axios
    .get(
      "https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json"
    )
    .then((r) => r.data.tokens);
  const tokenBalances = await Promise.all(
    tokensAndAccounts.map((t) => getTokenBalance(...t))
  );
  const balances = {};
  for (let i = 0; i < tokensAndAccounts.length; i++) {
    const token = tokensAndAccounts[i][0];
    let coingeckoId = tokenlist.find((t) => t.address === token)?.extensions?.coingeckoId;
    const replacementCoingeckoId = tokensAndAccounts[i][2];
    if (coingeckoId === undefined) {
      if (replacementCoingeckoId !== undefined) {
        coingeckoId = replacementCoingeckoId;
        balances[coingeckoId] = (balances[coingeckoId] || 0) + tokenBalances[i];
      } else {
        balances[token] = (balances[token] || 0) + tokenBalances[i];
        console.log(`Solana token ${token} has no coingecko id`);
      }
    } else {
      balances[coingeckoId] = (balances[coingeckoId] || 0) + tokenBalances[i];
    }
  }
  return balances;
}

// accountsArray is an array of base58 address strings
async function getMultipleAccountsRaw(accountsArray) {
  if (
    !Array.isArray(accountsArray) ||
    accountsArray.length === 0 ||
    typeof accountsArray[0] !== "string"
  ) {
    throw new Error("Expected accountsArray to be an array of strings");
  }
  const accountsInfo = await axios.post("https://api.mainnet-beta.solana.com", {
    jsonrpc: "2.0",
    id: 1,
    method: "getMultipleAccounts",
    params: [accountsArray],
  });
  return accountsInfo.data.result.value;
}

// Gets data in Buffers of all addresses, while preserving labels
// Example: labeledAddresses = { descriptiveLabel: "9xDUcgo8S6DdRjvrR6ULQ2zpgqota8ym1a4tvxiv2dH8", ... }
async function getMultipleAccountBuffers(labeledAddresses) {
  let labels = [];
  let addresses = [];

  for (const [label, address] of Object.entries(labeledAddresses)) {
    labels.push(label);
    addresses.push(address);
  }
  const accountsData = await getMultipleAccountsRaw(addresses);

  const results = {};
  accountsData.forEach((account, index) => {
    if (account === null) {
      results[labels[index]] = null;
    } else {
      results[labels[index]] = Buffer.from(account.data[0], account.data[1]);
    }

    // Uncomment and paste into a hex editor to do some reverse engineering
    // console.log(`${labels[index]}: ${results[labels[index]].toString("hex")}`);
  });

  return results;
}

// Example: [[token1, account1], [token2, account2], ...]
async function sumOrcaLPs(tokensAndAccounts) {
  const [tokenlist, orcaPools] = await Promise.all([
    axios
      .get(
        "https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json"
      )
      .then((r) => r.data.tokens),
    axios.get("https://api.orca.so/pools").then((r) => r.data),
  ]);
  let totalUsdValue = 0;
  await Promise.all(
    tokensAndAccounts.map(async ([token, owner]) => {
      const balance = await getTokenBalance(token, owner);
      const symbol = tokenlist
        .find((t) => t.address === token)
        ?.symbol?.replace("[stable]", "");
      const supply = await getTokenSupply(token);
      const poolLiquidity =
        orcaPools.find((p) => p.name2 === symbol)?.liquidity ?? 0;
      totalUsdValue += (balance * poolLiquidity) / supply;
    })
  );
  return totalUsdValue;
}

function exportDexTVL(DEX_PROGRAM_ID) {
  return async () => {
    const connection = getConnection()

    const TokenSwapLayout = BufferLayout.struct([
      BufferLayout.u8("version"),
      BufferLayout.u8("isInitialized"),
      BufferLayout.u8("bumpSeed"),
      BufferLayout.blob(32, "tokenProgramId"),
      BufferLayout.blob(32, "tokenAccountA"),
      BufferLayout.blob(32, "tokenAccountB"),
      BufferLayout.blob(32, "tokenPool"),
      BufferLayout.blob(32, "mintA"),
      BufferLayout.blob(32, "mintB"),
      BufferLayout.blob(32, "feeAccount"),
      BufferLayout.blob(8, "tradeFeeNumerator"),
      BufferLayout.blob(8, "tradeFeeDenominator"),
      BufferLayout.blob(8, "ownerTradeFeeNumerator"),
      BufferLayout.blob(8, "ownerTradeFeeDenominator"),
      BufferLayout.blob(8, "ownerWithdrawFeeNumerator"),
      BufferLayout.blob(8, "ownerWithdrawFeeDenominator"),
      BufferLayout.blob(8, "hostFeeNumerator"),
      BufferLayout.blob(8, "hostFeeDenominator"),
      BufferLayout.u8("curveType"),
      BufferLayout.blob(32, "curveParameters"),
    ])

    const tokenMap = await getTokenMap()

    const programPublicKey = new PublicKey(DEX_PROGRAM_ID)

    const programAccounts = await connection.getParsedProgramAccounts(programPublicKey);

    const validTokenAddresses = new Set();

    programAccounts.forEach((account) => {
      const tokenSwap = TokenSwapLayout.decode(account.account.data);
      validTokenAddresses.add(new PublicKey(tokenSwap.mintA).toString());
      validTokenAddresses.add(new PublicKey(tokenSwap.mintB).toString());
    });

    const tokenPoolMints = programAccounts.map(
      (account) =>
        new PublicKey(TokenSwapLayout.decode(account.account.data).tokenPool)
    );

    const poolAuthorityPubKeys = []
    const chunks = sliceIntoChunks(tokenPoolMints, 99)
    for (const chunk of chunks)
      poolAuthorityPubKeys.push(...await connection
        .getMultipleAccountsInfo(chunk)
        .then((poolAccounts) =>
          poolAccounts.map(
            (account) =>
              new PublicKey(MintLayout.decode(account.data).mintAuthority)
          )
        ))

    const poolsTokenAccounts = []

    for (const key of poolAuthorityPubKeys) {
      poolsTokenAccounts.push(await connection.getParsedTokenAccountsByOwner(key, {
        programId: TOKEN_PROGRAM_ID,
      }))
      await sleep(300)
    }
    const balances = {};

    poolsTokenAccounts.forEach((tokenAccounts) => {
      const poolTokens = tokenAccounts.value.filter((account) =>
        validTokenAddresses.has(account.account.data.parsed.info.mint)
      );

      const token1 = tokenMap.get(poolTokens[0].account.data.parsed.info.mint);
      const token2 = tokenMap.get(poolTokens[1].account.data.parsed.info.mint);
      const symbol1 = token1?.extensions?.coingeckoId;
      const symbol2 = token2?.extensions?.coingeckoId;

      let amount1 = poolTokens[0].account.data.parsed.info.tokenAmount.uiAmount;
      let amount2 = poolTokens[1].account.data.parsed.info.tokenAmount.uiAmount;

      // Future proofing - only add this pool's tokens to balances if one of the pool's tokens are listed on Coingecko
      // As of March 23, 2022 all of Penguin Finance pools have at least one token listed on Coingecko
      if (symbol1 || symbol2) {
        // If one of the pool's tokens is not on Coingecko we will double the amount of the other token to get a pool TVL estimation
        if (!symbol1 && symbol2) {
          amount2 *= 2;
          balances[symbol2] = (balances[symbol2] ?? 0) + amount2;
        } else if (symbol1 && !symbol2) {
          amount1 *= 2;
          balances[symbol1] = (balances[symbol1] ?? 0) + amount1;
        } else {
          balances[symbol1] = (balances[symbol1] ?? 0) + amount1;
          balances[symbol2] = (balances[symbol2] ?? 0) + amount2;
        }
      }
    });

    return balances;
  }
}

module.exports = {
  endpoint,
  TOKEN_LIST_URL,
  getTokenList,
  getTokenMap,
  getTokenSupply,
  getTokenBalance,
  getTokenAccountBalance,
  sumTokens,
  getMultipleAccountsRaw,
  getMultipleAccountBuffers,
  sumOrcaLPs,
  getSolBalance,
  getCoingeckoId,
  sumTokensUnknown,
  exportDexTVL,
  getProvider,
  getConnection,
};

'''
'''--- projects/helper/staking.js ---
const sdk = require('@defillama/sdk');
const { getBlock } = require('./getBlock');
const getReserves = require('./abis/getReserves.json');
const token0Abi = require('./abis/token0.json');
const token1Abi = require('./abis/token1.json');
const { default: BigNumber } = require('bignumber.js');
const { getChainTransform, getFixBalances, } = require('./portedTokens')

function staking(stakingContract, stakingToken, chain = "ethereum", transformedTokenAddress = undefined, decimals = undefined) {
    return stakings([stakingContract], stakingToken, chain, transformedTokenAddress, decimals)
}

function stakings(stakingContracts, stakingToken, chain = "ethereum", transformedTokenAddress = undefined, decimals = undefined) {
    return async (timestamp, _ethBlock, chainBlocks) => {
        const block = await getBlock(timestamp, chain, chainBlocks, true)
        const bal = (await sdk.api.abi.multiCall({
            calls: stakingContracts.map(c => ({ target: stakingToken, params: [c] })),
            chain,
            block,
            abi: "erc20:balanceOf"
        })).output.reduce((total, call)=> BigNumber(total).plus(call.output).toFixed(0), "0")
        let address = stakingToken;
        if (transformedTokenAddress) {
            address = transformedTokenAddress
        } else {
            address = (await getChainTransform(chain))(stakingToken)
        }
        if (decimals !== undefined) {
            return {
                [address]: Number(bal) / (10 ** decimals)
            }
        }
        return {
            [address]: bal
        }
    }
}

function stakingPricedLP(stakingContract, stakingToken, chain, lpContract, coingeckoIdOfPairedToken, stakedTokenIsToken0 = false, decimals=18) {
    return stakingUnknownPricedLP(stakingContract, stakingToken, chain, lpContract, ()=>coingeckoIdOfPairedToken, decimals)
}

function stakingUnknownPricedLP(stakingContract, stakingToken, chain, lpContract, transform, decimals) {
    return async (timestamp, _ethBlock, chainBlocks) => {
        if (!transform)   transform = await getChainTransform(chain)

        const block = await getBlock(timestamp, chain, chainBlocks, true)
        const [bal, reserveAmounts, token0, token1] = await Promise.all([
            sdk.api.erc20.balanceOf({
                target: stakingToken,
                owner: stakingContract,
                chain,
                block,
            }),
            ...[getReserves, token0Abi, token1Abi].map(abi=>sdk.api.abi.call({
                target: lpContract,
                abi,
                chain,
                block
            }).then(o=>o.output))
        ])
        let token, stakedBal;
        if(token0.toLowerCase() === stakingToken.toLowerCase()){
            token = token1;
            stakedBal = BigNumber(bal.output).times(reserveAmounts[1]).div(reserveAmounts[0]).toFixed(0);
        }else {
            stakedBal = BigNumber(bal.output).times(reserveAmounts[0]).div(reserveAmounts[1]).toFixed(0);
            token = token0
        }
        if(decimals !== undefined){
            stakedBal = Number(stakedBal)/(10**decimals)
        }

        const balances = {
            [transform(token)]: stakedBal
        }

        if (['klaytn', 'kava'].includes(chain)) {
            const fixBalances = await getFixBalances(chain)
            fixBalances(balances)
        }

        return balances
    }
}

module.exports = {
    staking,
    stakings,
    stakingPricedLP,
    stakingUnknownPricedLP
}

'''
'''--- projects/helper/sunny-pools.json ---
[
  {
    "poolName": "Saber_USDT-USDC",
    "relevantAccounts": {
      "sunnyPool": "DgCMFSzZzZBnyFTmEiX1zfsugckBLyyX79YUgZr9XCf7",
      "tokenAMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "CfWX7o2TswwbxusJ4hCaPobu2jLCb1hfXuXJQjVq3jQF",
      "tokenBReserve": "EnTrdMMpdhugeH6Ban6gYZWXughWxKtVGfCwFn78ZmY3",
      "lpTokenSPL": "2poo1w1DL6yd2WNTCnNTzDqkC6MBXq7axo77P16yrBuf"
    },
    "tokenA": "usd-coin",
    "tokenB": "tether",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_mSOL-SOL",
    "relevantAccounts": {
      "sunnyPool": "F8Tguj5VBWCrYzUPztETok5X78LR7djdrMtaorYhawgw",
      "tokenAMint": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "9DgFSWkPDGijNKcLGbr3p5xoJbHsPgXUTr6QvGBJ5vGN",
      "tokenBReserve": "2hNHZg7XBhuhHVZ3JDEi4buq2fPQwuWBdQ9xkH7t1GQX",
      "lpTokenSPL": "SoLEao8wTzSfqhuou8rcYsVoLjthVmiXuEjzdNPMnCz"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_PAI-USDC",
    "relevantAccounts": {
      "sunnyPool": "GHhWVFF4kPvvz7qxtTi6uTr6nDoC1Ho7ZrKYTNZirVRj",
      "tokenAMint": "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "4DYwgJtxwuJdAjkj5RJSNH4e7U329V5cNp7d3a1nLrZv",
      "tokenBReserve": "EXNW64GEf1ACC6xY9BtKRiunrs6GoJSXBdxWN2eTPmrF",
      "lpTokenSPL": "PaiYwHYxr4SsEWox9YmyBNJmxVG7GdauirbBcYGB7cJ"
    },
    "tokenA": "dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_BTC-renBTC",
    "relevantAccounts": {
      "sunnyPool": "22NmJEkjSUzvtagiau2JEwXdo9pc9UgZJX1BZiRJimaH",
      "tokenAMint": "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
      "tokenBMint": "SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",
      "tokenAReserve": "35yX27bmurdebhfAb8EPmjLETDiUaEUCn9zHaDPbakH2",
      "tokenBReserve": "2CxECn1ZJFoESyUnQysQU8rRgT3iJ5GRs2Mdd6gZjx5g",
      "lpTokenSPL": "SLPbsNrLHv8xG4cTc4R5Ci8kB9wUPs6yn6f7cKosoxs"
    },
    "tokenA": "renbtc",
    "tokenB": "bitcoin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_pBTC-renBTC",
    "relevantAccounts": {
      "sunnyPool": "EGig51WPpRrVknLmZYiTfba93w31sGCFMApRzHcAwmKr",
      "tokenAMint": "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
      "tokenBMint": "DYDWu4hE4MN3aH897xQ3sRTs5EAjJDmQsKLNhbpUiKun",
      "tokenAReserve": "DvHVapj4g2Y1tJVSw2ubSPkPBsJPb8fW387ZWXwaKmZq",
      "tokenBReserve": "DKjqWWgrtDRPKrnMWtZ4UiJk4sGQVCQgFjSo7BvfngvK",
      "lpTokenSPL": "pBTCmyG7FaZx4uk3Q2pT5jHKWmWDn84npdc7gZXpQ1x"
    },
    "tokenA": "renbtc",
    "tokenB": "bitcoin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_UST-USDC",
    "relevantAccounts": {
      "sunnyPool": "CmV2Cppe7EoqhGvsMws3bFs5iStm5gmDmejJvaRT2uco",
      "tokenAMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenBMint": "CXLBjMMcwkc17GfJtBos6rQCo1ypeH6eDbB82Kby4MRm",
      "tokenAReserve": "D9yh4KAysxt9GLacVe4Wwh2XqghhcjTCSTV9HuM7TBJd",
      "tokenBReserve": "HDYfJLpZKaMFb84jM4mRytn7XLR8UFZUnQpSfhJJaNEy",
      "lpTokenSPL": "UST32f2JtPGocLzsL41B3VBBoJzTm1mK1j3rwyM3Wgc"
    },
    "tokenA": "usd-coin",
    "tokenB": "terrausd",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wDAI-USDC",
    "relevantAccounts": {
      "sunnyPool": "BtxevLdCyhHJhhMo1dvcXBvt5RB3FWSv4P6knkeTf6wT",
      "tokenAMint": "FYpdBuyAHSbdaAyD1sKkxyLWbAP8uUW9h6uvdhK74ij1",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "A7VkMFrnCCyeZFUrQ3TzDr4xFep7PZtxvy3jJnBjLB2a",
      "tokenBReserve": "PhfHJ2Yu99BsEjZrefhApqUnLUiExcECcUT1YLoNUUv",
      "lpTokenSPL": "Daimhb91DY4e3aVaa7YCW5GgwaMT9j1ALSi2GriBvDNh"
    },
    "tokenA": "dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wBUSD-USDC",
    "relevantAccounts": {
      "sunnyPool": "HmW1eg5XhWTk7a42Vmd2SmHMeBxxphkcS6abAec6Pg1g",
      "tokenAMint": "AJ1W9A9N9dEMdVyoDiam2rV44gnBm2csrPDP7xqcapgX",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "5uerVwBnZQsuVhZ15igs7ZgmcqhHnYWbwoRtLyRqLvR",
      "tokenBReserve": "9YWiQh5d4jCtgMdzcGLv9bWgnLaFtzvDDh2nnhJdzhBX",
      "lpTokenSPL": "BUSDaZjarCrQJLeHpWi7aLaKptdR1S8DFpwdDuuZu9p3"
    },
    "tokenA": "busd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wLUNA-renLUNA",
    "relevantAccounts": {
      "sunnyPool": "4rDTvyrzLXYPHEweNnVLtEyCnMJ5UfMjAcsMSkfgECvF",
      "tokenAMint": "2Xf2yAXJfg82sWwdLUo2x9mZXy6JCdszdMZkcF1Hf4KV",
      "tokenBMint": "KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",
      "tokenAReserve": "Au5zcSost9sXpH8AQQjULRXJ9QCJ3kdKehUr1zYzTr6G",
      "tokenBReserve": "Gx1L7n1YhDWLNfUyCeZfzKvwHJSxhppnk4DS5cZLqyd",
      "lpTokenSPL": "LUNkiLcb2wxcqULmJvMjuM6YQhpFBadG5KZBe7qBpSE"
    },
    "tokenA": "terra-luna",
    "tokenB": "terra-luna",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wFRAX-USDC",
    "relevantAccounts": {
      "sunnyPool": "oGS5V292ry3XwqDooaqnHgxedKNvEQ5mtrG3cYba2ah",
      "tokenAMint": "8L8pDf3jutdpdr4m3np68CL9ZroLActrqwxi6s9Ah5xU",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "7eEYpq6ShaJ9opZWMxitRFrdCHh6vfyHhGfoSvFht3N2",
      "tokenBReserve": "H8VggnHmuwd1wvwpT8eg9cUJFEfZ7HAaeYjgXrSm7A2u",
      "lpTokenSPL": "FRAXXvt2ucEsxYPK4nufDy5zKhb2xysieqRBE1dQTqnK"
    },
    "tokenA": "frax",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_HBTC-renBTC",
    "relevantAccounts": {
      "sunnyPool": "7mzgsXmiqhwWybEnbDAWJdYff6PWRq4TB8voUWbe1gce",
      "tokenAMint": "8pBc4v9GAwCBNWPB5XKA93APexMGAS4qMr37vNke9Ref",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "GsizhiRtCs4QDKd2LnSQ9BpzvG8CqERMDtHZcQPDkFQB",
      "tokenBReserve": "CRaJHfCry6JShmF4tMr6siR2D2QNNfcUrLawTqPVCTTJ",
      "lpTokenSPL": "HBTCNvkwjMsEtwe2PeXUuMcu8C4Hobw6HDP2m6vpWHGo"
    },
    "tokenA": "bitcoin",
    "tokenB": "bitcoin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_HUSD-USDC",
    "relevantAccounts": {
      "sunnyPool": "MJj6148HLjiahjcv1b83NZ8j4YNCnKN5wJ8urMir5Vh",
      "tokenAMint": "BybpSTBoZHsmKnfxYG47GDhVPKrnEKX31CScShbrzUhX",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "2mUxDu8NrhSKhQJMgKfYLxJqZzeEbmwhQdHeHMyohyuk",
      "tokenBReserve": "AZCBmDBcFsA2jHHhfFJBTsWCHx9XnnKmGfFsue3ZVW1t",
      "lpTokenSPL": "HUSDgP5YieANhAAHD42yivX9aFS1zbodTut2Dvvkj8QS"
    },
    "tokenA": "husd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_USDK-USDC",
    "relevantAccounts": {
      "sunnyPool": "6UaNyeYKzP7zzUwPN3SCQYRjE438akKTVa9VU7cSj5C9",
      "tokenAMint": "2kycGCD8tJbrjJJqWN2Qz5ysN9iB4Bth3Uic4mSB7uak",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "5RfXYWvxR9PUaedokXVxgJHDoD4xnLLauVtdJ27shPWG",
      "tokenBReserve": "DJcFPaQjyW9Xkt7sXCbnEGj1yfykGYuLRUXFyS4LLZ5F",
      "lpTokenSPL": "uSdKg2Cs5bCtFSeNXs7aRVNzZJauX58eCkdsfssxTdW"
    },
    "tokenA": "usdk",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wFTT-FTT",
    "relevantAccounts": {
      "sunnyPool": "9qQVQfDFGqRw6HHvcZfHVTdJgqsgyLS6jY5LU38GkkP5",
      "tokenAMint": "GbBWwtYTMPis4VHb8MrBbdibPhn28TSrLB53KvUmb7Gi",
      "tokenBMint": "FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",
      "tokenAReserve": "46xwHtnXoQR3wCHUbm2eCAbPYWbioDQ59Te1Db8M5DDL",
      "tokenBReserve": "FC38fiikZwFvDt5zTjNtGfKd7LjaPz2uUAzLwKP5pRJY",
      "lpTokenSPL": "FTXdV5wFFhceKjcd1JRrRQTT2uB7ruMerAqbj2rj1Mz7"
    },
    "tokenA": "ftx-token",
    "tokenB": "ftx-token",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_wSRM-SRM",
    "relevantAccounts": {
      "sunnyPool": "4Hn4AvnbQAsCytdPSmFJFtAzsVpGM3XaJsqNZo9TRgMG",
      "tokenAMint": "2jXy799YnEcRXneFo2GEAB6SDRsAa767HpWmktRr1DaP",
      "tokenBMint": "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
      "tokenAReserve": "C5uYkVHiFduEFq8S3fr4pgUS24oYj1sjZ8WW2cb4j8SU",
      "tokenBReserve": "3F5DPU5ScgHiFzePYUHZovvgh3uqmM5keNvbavx2ERqV",
      "lpTokenSPL": "SRMKjSJpBHJ5gSVTrimci49SnXc1LVkBi9TGF9RNYdp"
    },
    "tokenA": "serum",
    "tokenB": "serum",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_ibBTC-renBTC",
    "relevantAccounts": {
      "sunnyPool": "JCskJBoq3itLVHa6RF8mdDJ3htqh8q1APWKhisEYG29b",
      "tokenAMint": "66CgfJQoZkpkrEgC1z4vFJcSFc4V6T5HqbjSSNuqcNJz",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "CZ48nQQ6GK8Z7hGBPdxTtMzRBA8werj5iciVJnc3vz1S",
      "tokenBReserve": "G3nLYyvP46npva5MEobZVJhcDNzJ4rrHgLGJMtvyad5c",
      "lpTokenSPL": "BRENm9SgYJZuCxM4ZJiH6CmZqEBn4MLpD9cnBZDnJgeT"
    },
    "tokenA": "bitcoin",
    "tokenB": "bitcoin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_apUSDT-USDT",
    "relevantAccounts": {
      "sunnyPool": "7pQLXy3befFLSszHBkH9zpkhptEK6H8FEeEZRCXVTikS",
      "tokenAMint": "DNhZkUaxHXYvpxZ7LNnHtss8sQgdAfd1ZYS1fB7LKWUZ",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "D6d156U1bPiJpDYRLextvDRccgFk7QzkQbJg42ceKEu5",
      "tokenBReserve": "GNcM8U5g8RwTZffwwm3kSQqUNPSwv5d2fbN9sLxPJqt2",
      "lpTokenSPL": "PLYJZgSkcV8UXTWhTyf2WLCMeBoZum1Y4rXgXkoYiNj"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_MAI-USDC",
    "relevantAccounts": {
      "sunnyPool": "6UQSBG9p7Z9Tu9CTnQaYTyjP4r7CdV9yHDj8UojguNvA",
      "tokenAMint": "9mWRABuz2x6koTPCWiCPM49WUbcrNqGTHBV9T9k7y1o7",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "DhgiEgiNdqZdRdo195UUHnoEJUtefK8buko8nU97XJUZ",
      "tokenBReserve": "2K2kkXsouBHtWVjtcgkyiXd8eP3oVBvq1bTJzcVdLLr2",
      "lpTokenSPL": "MAiP3Zmjhc6NYiCb2xK2893ifvTTDHciCS57Kga39pC"
    },
    "tokenA": "dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_prtSOL-SOL",
    "relevantAccounts": {
      "sunnyPool": "8U9eJKhA93ULi8U7CdEdAa93PQWxHCa7xYHTzpHoym1W",
      "tokenAMint": "BdZPG9xWrG3uFrx2KrUW1jT4tZ9VKPDWknYihzoPRJS3",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "9ZDpBKPqMABtGfq66FbVribaArMvtk63xxy91onZAtDt",
      "tokenBReserve": "9ZDpBKPqMABtGfq66FbVribaArMvtk63xxy91onZAtDt",
      "lpTokenSPL": "PrsVdKtXDDf6kJQu5Ff6YqmjfE4TZXtBgHM4bjuvRnR"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "Saber_pSOL-prtSOL",
    "relevantAccounts": {
      "sunnyPool": "2z83EUtVrU27aL9hVvRmRaH1tRRW5qe2pE5joY8CyttA",
      "tokenAMint": "9EaLkQrbjmbbuZG9Wdpo8qfNUEjHATJFSycEmw6f1rGX",
      "tokenBMint": "BdZPG9xWrG3uFrx2KrUW1jT4tZ9VKPDWknYihzoPRJS3",
      "tokenAReserve": "3oyc6hpjYSJEquK6dSvG72NXyz3pqLZz5D8AC71pwgQb",
      "tokenBReserve": "Di2vordgFJVZ1aj1aBpvzXtLfZgJsuLLXawGtVFwX6Rz",
      "lpTokenSPL": "PSopTFPXzTRysj2H6W8oTvYBZmJHtRcVaQaDkckifAy"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aadai",
    "relevantAccounts": {
      "sunnyPool": "DKsQsX9YjK8Aj9fQs9819HFS8mJXgkkEaLxDy85S4UUS",
      "tokenAMint": "EgQ3yNtVhdHz7g1ZhjfGbxhFKMPPaFkz8QHXM5RBZBgi",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "GiehZ4X2uQjhEKuxSm3ACmEFrabxh3RTvjbLfLjw1xGX",
      "tokenBReserve": "rxDQYV77NKRKYxCjq4cECX3QQsiSyLv1T1FT2X3zNA2",
      "lpTokenSPL": "AVDuGckLavyLr5YifViaxnoveY6rwqDezHw5kiKiRQEC"
    },
    "tokenA": "multi-collateral-dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aausdc",
    "relevantAccounts": {
      "sunnyPool": "G3oiA7WtZFeyuj6DZzhoXHJtBHL8cB4xm7XVuMCuHc2W",
      "tokenAMint": "8Yv9Jz4z7BUHP68dz8E8m3tMe6NKgpMUKn8KVqrPA6Fr",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "2bPenuBYfqzD8p5dFjCcggwkHDsc2RQDnx9AoyYGUBjA",
      "tokenBReserve": "AE6n6iLuX8oYu61vt5hoDYkjswpnxFxrhSehxrnQTnbx",
      "lpTokenSPL": "AVC7uVb6R9B34T8zWxQMEK8twvYk26U71gworsujxFNv"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aausdt",
    "relevantAccounts": {
      "sunnyPool": "FYAoBTTQyL3pWhKvX8MjNvdhxSm4k5xAxRSPfi2dp5cQ",
      "tokenAMint": "FwEHs3kJEdMa2qZHv7SgzCiFXUQPEycEXksfBkwmS8gj",
      "tokenBMint": "AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",
      "tokenAReserve": "3dFMPj4r9mMmPHF32mz1gNDX7f8ftidWof7S8YiYTs1j",
      "tokenBReserve": "Fc1ED3YPeQfXQosHbd8DTaBd2AV5gHQtwiSAL5C5pUhi",
      "lpTokenSPL": "AVTrxHq5P57fYZTYjMuCRWFqsrLmom2gGThNtgEgK1ip"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aawbtc",
    "relevantAccounts": {
      "sunnyPool": "4eBrJ9FiQwtnuqrjNSL5jNhNsZjHgW86sVeBEqvSUwsQ",
      "tokenAMint": "Fd8xyHHRjTvxfZrBirb6MaxSmrZYw99gRSqFUKdFwFvw",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "bDVSLHopvEo45R3rR7JXoRRAcnUXKD7r14ijj1apALb",
      "tokenBReserve": "33QrhvkyroiTxp21hbXPRowPhsgVHmrgEQbY7eHPp1h4",
      "lpTokenSPL": "AVBDpg1UYpDYQLbzEnRY76R3u82PYHtDuc3NBdFS2k39"
    },
    "tokenA": "wrapped-bitcoin",
    "tokenB": "renbtc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_abbusd",
    "relevantAccounts": {
      "sunnyPool": "AstN8es9yaN3VYop94Hvvyu4KXBrf9RguBnV15Xcmzna",
      "tokenAMint": "6nuaX3ogrr2CaoAPjtaKHAoBNWok32BMcRozuf32s2QF",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "7n9kgNL633yGzCYksgnzHyjG73ZLBAwvEae5sbAekbzW",
      "tokenBReserve": "SscdxE99omdG9AiMVwmaEMQySQnCgeAh1sPj2Leutm2",
      "lpTokenSPL": "BUSDjE9NEQ15aRFTxKFAjUf5vzqBhEgTNbYevWcSB5qp"
    },
    "tokenA": "binance-usd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_acusd",
    "relevantAccounts": {
      "sunnyPool": "D35qQwbQpVthbPxnab7TX29TxsycKtSAtHkL7YnXE6rg",
      "tokenAMint": "EwxNF8g9UfmsJVcZFTpL9Hx5MCkoQFoJi6XNWzKf1j8e",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "44ALBrpqi9PfZkBRTvbtRNtFJGsatfY4QydjtMbFWq8S",
      "tokenBReserve": "2ho8qEEie1UjVwWNBo9y4oAJZMyMLx8zPj9bxyUz6uWs",
      "lpTokenSPL": "cUSDDDBZRhpDW7eyUUPMuw6u1SiMnzu6i7movwf5jxk"
    },
    "tokenA": "celo-dollar",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_acusd_cash",
    "relevantAccounts": {
      "sunnyPool": "8MgufJeVknwE41RRjJB4PFuMACaT9tu7YKeGErXekw5b",
      "tokenAMint": "EwxNF8g9UfmsJVcZFTpL9Hx5MCkoQFoJi6XNWzKf1j8e",
      "tokenBMint": "C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",
      "tokenAReserve": "49EQuSDQNz7L4a22CcnWUxExSpYW4UXSKG985S2drLsR",
      "tokenBReserve": "7DH5gc5Hj1Kq4Y9z8ybEmAX1WPoHcunwiav1Za4A5J3J",
      "lpTokenSPL": "CLPLCvWFycur9CysMT3pmdkUXxPfBjXVkWyxTGntzoZ7"
    },
    "tokenA": "celo-dollar",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_acusdc",
    "relevantAccounts": {
      "sunnyPool": "2vZgBtaVX7Xx77a6ksCLfwKJSsCJt2xcoM5paDYnEcPt",
      "tokenAMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenBMint": "DHpoYejUDqzByb6HAdaLWF7KZvwUv2vWYDY9cTENNZui",
      "tokenAReserve": "AhFPQdu8GKBsxuhiH46UmCu1YpaLgNpoP325HnYtsgas",
      "tokenBReserve": "A8wxWpT3aFEr2XqZp1kDmbxbFfcBE95UUmdsNTDBJYbT",
      "lpTokenSPL": "GEcowHQW46CrEkfAdbcsdt4SV7taCetZF4sFBXN4USDC"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aedai",
    "relevantAccounts": {
      "sunnyPool": "CVENcGmg3Fhm8BFQ9PGvVMm8N1AMpGaGEwtRt7BBC17X",
      "tokenAMint": "9w6LpS7RU1DKftiwH3NgShtXbkMM1ke9iNU4g3MBXSUs",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "B4UtLRZND3D83CitRCBUyeiNr7H8m7YFRqBmiPmXjhW4",
      "tokenBReserve": "AAmpYbuixWiSqDaJBCqYEs1pb5SrbdPr9mgXrB58Q2e",
      "lpTokenSPL": "aeDebgky5BssqgLo426rXoQTmGrAn1JjEXp6aXFNLic"
    },
    "tokenA": "multi-collateral-dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aeeth",
    "relevantAccounts": {
      "sunnyPool": "BD8X5XkHZSeJxctmTMJi2XzivtRqyXhEzXjENXXGhWDK",
      "tokenAMint": "KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",
      "tokenBMint": "AaAEw2VCw1XzgvKB8Rj2DyK2ZVau9fbt2bE8hZFWsMyE",
      "tokenAReserve": "CGoM82Hbz7QVqTgvQatYtjvDWBvoUJp5qm21P8iMs9yb",
      "tokenBReserve": "3dxNNww8TivyN5FMy5dCNdi3Zcxv6e4kUfSPxfFwpdNq",
      "lpTokenSPL": "AET3m1Mp2SLi7QX3tSypcZWyEtk1d8dUGcwhweDiZdaR"
    },
    "tokenA": "ethereum",
    "tokenB": "weth",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aeusdc",
    "relevantAccounts": {
      "sunnyPool": "Guc94iBoSxtDJx1XCz3E9go1FqYZwjnHWaG7K9JazJ7U",
      "tokenAMint": "DdFPRnccQqLD4zCHrBqdY95D6hvw6PLWp9DEXj1fLCL9",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "3S2jpqSYxho6wiz3cafhjXruVY8cg4HYa2v3BqBHYFSj",
      "tokenBReserve": "Dfe67M6TfrG74gKRtdqys4e6E9QirPD53BkF4FujFjuv",
      "lpTokenSPL": "AECpyKJWfXVyWnk2d9md5dUj3RuzHRKfQra8MakjuVRz"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_aeusdt",
    "relevantAccounts": {
      "sunnyPool": "GWhJ9k9huHmDzg8TqGB8HJy3tu5QNuoEVgdXA6crMNG2",
      "tokenAMint": "Bn113WT6rbdgwrm12UJtnmNqGqZjY4it2WoUQuQopFVn",
      "tokenBMint": "AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",
      "tokenAReserve": "Eu1Ze6Z84LWNkq7SNoAHBJbXx5t1P95EwyqYohrfCRFV",
      "tokenBReserve": "ASMbv7WNu3qe4pkhREmvyEdwFNDZQ6B6iSrjkj4u8bdC",
      "lpTokenSPL": "aeTwxcJhujVCq6rwbJri3s6ViYifsJUCFirMjLHgHZ7"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ahusdt",
    "relevantAccounts": {
      "sunnyPool": "DWCjs3Bfk9HpHSiGCFFo4WCVGmKMCdvc8Texb1L1nqpR",
      "tokenAMint": "GfzU1fLASNV3r4NtEyrnwTyTakJkYzoivnaL3Snh45oj",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "DyBGrZkGJHrgbxQXo3sh5KKz7YTzYK9gN8fhRSXN2whK",
      "tokenBReserve": "DRr3h3DF9wupahxh6vHMFCm6WGfmJWMrrBHoBvWAweAQ",
      "lpTokenSPL": "HLPC9r4gbeP6KagT3qJLzFj7iWcYTJs245k9tuHFQGyR"
    },
    "tokenA": "tether",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ahwbtc",
    "relevantAccounts": {
      "sunnyPool": "6feZZFXicPzoGwdtGiTXeY2dH1Gk79jFwXriqfQDoBR",
      "tokenAMint": "Bo4ehCeRcRj2wp5tQpjfCJxYFn4KyRacfDzSa4Aj27tH",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "56TsbS21JcCVgD8x7HDivK371QPWhNWPvH5QPA6oqmTX",
      "tokenBReserve": "LRiFt5Sa2dCx2njaRMTVtkxKbiH2EJV2KN1b7FjMube",
      "lpTokenSPL": "HLPPmd7NzTTNiqKR6rAZYgrH9VhU47kxftecQSk2oD6J"
    },
    "tokenA": "wrapped-bitcoin",
    "tokenB": "renbtc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_apusdc",
    "relevantAccounts": {
      "sunnyPool": "93VzPkdzFEyHKXqVw1mZ6pdtjbdM4eYuYqyc5p8HmfSw",
      "tokenAMint": "eqKJTf1Do4MDPyKisMYqVaUFpkEFAs3riGF3ceDH2Ca",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "4xkyD7AfGQDwsQMy9MosRRNGoVJ1zosNinesxg1TzHG7",
      "tokenBReserve": "Cbm5gsQe3nSiCsFrvepVzMCD9xLK3ri9g3ypS2hdmVJ7",
      "lpTokenSPL": "APUVVYA8Xf7T1PqLyDvNxLtwQ9rRDf3RUxfMttreVzHP"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_apusdt",
    "relevantAccounts": {
      "sunnyPool": "8WoMYJVtnbxenvZSbvbqwjcwdiM21SZVifJPjVyzRjsp",
      "tokenAMint": "DNhZkUaxHXYvpxZ7LNnHtss8sQgdAfd1ZYS1fB7LKWUZ",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "D6d156U1bPiJpDYRLextvDRccgFk7QzkQbJg42ceKEu5",
      "tokenBReserve": "GNcM8U5g8RwTZffwwm3kSQqUNPSwv5d2fbN9sLxPJqt2",
      "lpTokenSPL": "PLYJZgSkcV8UXTWhTyf2WLCMeBoZum1Y4rXgXkoYiNj"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_asol",
    "relevantAccounts": {
      "sunnyPool": "HCiHNn5HxeBssdijUAh2AB8co249FH8WWKVK6k4VF1tq",
      "tokenAMint": "ASoLXbfe7cd6igh5yiEsU8M7FW64QRxPKkxk7sjAfond",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "BKWm4TRnTeKwfWXRyuzjRHU7iZDkPuXBX5b5V5jSVfGJ",
      "tokenBReserve": "A5Ww74HVrkj9nPeC7pHKLfgeDMEhBCpW1efQdz3TGLEg",
      "lpTokenSPL": "ALP89a89ASo1h5VosTSABtQBKLBgeoaWQexYQrRCMNfV"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_btc",
    "relevantAccounts": {
      "sunnyPool": "4P2sGCjQtArNbmVHNxiXsTKCejkTfMKby7PfTs92fuV4",
      "tokenAMint": "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
      "tokenBMint": "SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",
      "tokenAReserve": "35yX27bmurdebhfAb8EPmjLETDiUaEUCn9zHaDPbakH2",
      "tokenBReserve": "2CxECn1ZJFoESyUnQysQU8rRgT3iJ5GRs2Mdd6gZjx5g",
      "lpTokenSPL": "SLPbsNrLHv8xG4cTc4R5Ci8kB9wUPs6yn6f7cKosoxs"
    },
    "tokenA": "renbtc",
    "tokenB": "bitcoin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_busd",
    "relevantAccounts": {
      "sunnyPool": "9wb3VoNdi8e4X1xfHwYDmtoD84yUkc5z7gfaXCm92Nx4",
      "tokenAMint": "AJ1W9A9N9dEMdVyoDiam2rV44gnBm2csrPDP7xqcapgX",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "5uerVwBnZQsuVhZ15igs7ZgmcqhHnYWbwoRtLyRqLvR",
      "tokenBReserve": "9YWiQh5d4jCtgMdzcGLv9bWgnLaFtzvDDh2nnhJdzhBX",
      "lpTokenSPL": "BUSDaZjarCrQJLeHpWi7aLaKptdR1S8DFpwdDuuZu9p3"
    },
    "tokenA": "binance-usd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_cash",
    "relevantAccounts": {
      "sunnyPool": "EBSEehvHWmeujhgXbXoSvgVSJZSe3kaw7qR8RTaEhr1P",
      "tokenAMint": "CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "7EifTDGz2nEU7DiE2UuuBX9Efkbdfad47mgr7Bqrqo8Y",
      "tokenBReserve": "FoL4JKwgaRUnf5c8wZDYdSam98NepnZ6oJDNFqPLuRvr",
      "lpTokenSPL": "CLPKiHjoU5HwpPK5L6MBXHKqFsuzPr47dM1w4An3Lnvv"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_dai",
    "relevantAccounts": {
      "sunnyPool": "ES6mXVjcebPz3QuZNWa7dgj7TVv8Tjtwdj4McWwJUF2M",
      "tokenAMint": "FYpdBuyAHSbdaAyD1sKkxyLWbAP8uUW9h6uvdhK74ij1",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "A7VkMFrnCCyeZFUrQ3TzDr4xFep7PZtxvy3jJnBjLB2a",
      "tokenBReserve": "PhfHJ2Yu99BsEjZrefhApqUnLUiExcECcUT1YLoNUUv",
      "lpTokenSPL": "Daimhb91DY4e3aVaa7YCW5GgwaMT9j1ALSi2GriBvDNh"
    },
    "tokenA": "dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_frax",
    "relevantAccounts": {
      "sunnyPool": "6qqtRvbrYuS2P56AjkBConWsJrS7DvtQAjA4AF6gNShf",
      "tokenAMint": "8L8pDf3jutdpdr4m3np68CL9ZroLActrqwxi6s9Ah5xU",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "7eEYpq6ShaJ9opZWMxitRFrdCHh6vfyHhGfoSvFht3N2",
      "tokenBReserve": "H8VggnHmuwd1wvwpT8eg9cUJFEfZ7HAaeYjgXrSm7A2u",
      "lpTokenSPL": "FRAXXvt2ucEsxYPK4nufDy5zKhb2xysieqRBE1dQTqnK"
    },
    "tokenA": "frax",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ftt",
    "relevantAccounts": {
      "sunnyPool": "GRrf2DDzDqynoXh9rpTeXYbqMaFtHrQJsgBYzqnsDcvx",
      "tokenAMint": "GbBWwtYTMPis4VHb8MrBbdibPhn28TSrLB53KvUmb7Gi",
      "tokenBMint": "FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",
      "tokenAReserve": "46xwHtnXoQR3wCHUbm2eCAbPYWbioDQ59Te1Db8M5DDL",
      "tokenBReserve": "FC38fiikZwFvDt5zTjNtGfKd7LjaPz2uUAzLwKP5pRJY",
      "lpTokenSPL": "FTXdV5wFFhceKjcd1JRrRQTT2uB7ruMerAqbj2rj1Mz7"
    },
    "tokenA": "ftx-token",
    "tokenB": "ftx-token",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_hbtc",
    "relevantAccounts": {
      "sunnyPool": "778pp6bURm31CZXtHWZt4s7zDuTiU9S64X53HizXtV68",
      "tokenAMint": "8pBc4v9GAwCBNWPB5XKA93APexMGAS4qMr37vNke9Ref",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "GsizhiRtCs4QDKd2LnSQ9BpzvG8CqERMDtHZcQPDkFQB",
      "tokenBReserve": "CRaJHfCry6JShmF4tMr6siR2D2QNNfcUrLawTqPVCTTJ",
      "lpTokenSPL": "HBTCNvkwjMsEtwe2PeXUuMcu8C4Hobw6HDP2m6vpWHGo"
    },
    "tokenA": "huobi-btc",
    "tokenB": "renbtc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_husd",
    "relevantAccounts": {
      "sunnyPool": "7PVN9aNkcREn53M7GYC92hxmzxhNYMscFtjr2R9R1q3A",
      "tokenAMint": "BybpSTBoZHsmKnfxYG47GDhVPKrnEKX31CScShbrzUhX",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "2mUxDu8NrhSKhQJMgKfYLxJqZzeEbmwhQdHeHMyohyuk",
      "tokenBReserve": "AZCBmDBcFsA2jHHhfFJBTsWCHx9XnnKmGfFsue3ZVW1t",
      "lpTokenSPL": "HUSDgP5YieANhAAHD42yivX9aFS1zbodTut2Dvvkj8QS"
    },
    "tokenA": "husd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ibbtc",
    "relevantAccounts": {
      "sunnyPool": "8XWAa763NEkwDtkSAs4Se1JhuUDb8qfaKotwoLcKdK8w",
      "tokenAMint": "66CgfJQoZkpkrEgC1z4vFJcSFc4V6T5HqbjSSNuqcNJz",
      "tokenBMint": "9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",
      "tokenAReserve": "Fb2Zdo7hWjMmwMXn7589WbPbjVPxVUQgPgs5cAcStJm8",
      "tokenBReserve": "AjVXZPzFEShWkGASQv5dBp9r4Xf6V1mvyHWfH5UWF9c3",
      "lpTokenSPL": "BADGsQo6rTxKZuqkY1kSoqhriQwZW3ZVgyPjgDk9mvyo"
    },
    "tokenA": "bitcoin",
    "tokenB": "bitcoin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ibbtc_ren",
    "relevantAccounts": {
      "sunnyPool": "FhEGpVfYQUBXWWsSnfXYrmCFBqgghPfrmcRC39eEkvyd",
      "tokenAMint": "66CgfJQoZkpkrEgC1z4vFJcSFc4V6T5HqbjSSNuqcNJz",
      "tokenBMint": "FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",
      "tokenAReserve": "CZ48nQQ6GK8Z7hGBPdxTtMzRBA8werj5iciVJnc3vz1S",
      "tokenBReserve": "G3nLYyvP46npva5MEobZVJhcDNzJ4rrHgLGJMtvyad5c",
      "lpTokenSPL": "BRENm9SgYJZuCxM4ZJiH6CmZqEBn4MLpD9cnBZDnJgeT"
    },
    "tokenA": "bitcoin",
    "tokenB": "renbtc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_luna",
    "relevantAccounts": {
      "sunnyPool": "AoEShMnruaF3CHocY8cF775nzxr1iyYbToXMvymcEy67",
      "tokenAMint": "2Xf2yAXJfg82sWwdLUo2x9mZXy6JCdszdMZkcF1Hf4KV",
      "tokenBMint": "KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",
      "tokenAReserve": "Au5zcSost9sXpH8AQQjULRXJ9QCJ3kdKehUr1zYzTr6G",
      "tokenBReserve": "Gx1L7n1YhDWLNfUyCeZfzKvwHJSxhppnk4DS5cZLqyd",
      "lpTokenSPL": "LUNkiLcb2wxcqULmJvMjuM6YQhpFBadG5KZBe7qBpSE"
    },
    "tokenA": "wrapped-terra",
    "tokenB": "terra-luna",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_mai",
    "relevantAccounts": {
      "sunnyPool": "RrFrHdkHExmUGkd9BJd4j4SgpX1T1LdKTmuPyPHcthz",
      "tokenAMint": "9mWRABuz2x6koTPCWiCPM49WUbcrNqGTHBV9T9k7y1o7",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "DhgiEgiNdqZdRdo195UUHnoEJUtefK8buko8nU97XJUZ",
      "tokenBReserve": "2K2kkXsouBHtWVjtcgkyiXd8eP3oVBvq1bTJzcVdLLr2",
      "lpTokenSPL": "MAiP3Zmjhc6NYiCb2xK2893ifvTTDHciCS57Kga39pC"
    },
    "tokenA": "mimatic",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_msol_sol",
    "relevantAccounts": {
      "sunnyPool": "ABTVKgFr6NcayrKhKuEUNfTcFcm7MhXMBJDfZDE9p3Y4",
      "tokenAMint": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "9DgFSWkPDGijNKcLGbr3p5xoJbHsPgXUTr6QvGBJ5vGN",
      "tokenBReserve": "2hNHZg7XBhuhHVZ3JDEi4buq2fPQwuWBdQ9xkH7t1GQX",
      "lpTokenSPL": "SoLEao8wTzSfqhuou8rcYsVoLjthVmiXuEjzdNPMnCz"
    },
    "tokenA": "msol",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_pai_cash",
    "relevantAccounts": {
      "sunnyPool": "2cg1g8VhnMobXNAVBCXyL5FVLhbEXp8XVAbmT1ZMJJox",
      "tokenAMint": "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
      "tokenBMint": "CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",
      "tokenAReserve": "F36eiDG64zYoAA9vtTvV4EWcTqYNUku7hzhUyTYcQSin",
      "tokenBReserve": "FXJq5PZ8XshMvhcfX2y3khJyWK6S5W7ftLeMgbuFgwDG",
      "lpTokenSPL": "CLP2aB2bCXZEaoQjUNQdn64dCSzCVxKE3Kjgo3PcAYeY"
    },
    "tokenA": "parrot-usd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_pbtc",
    "relevantAccounts": {
      "sunnyPool": "7nr2uHNJMMUNnx7W5PaYjzv8MC44Rqp5Ju51djrUvSyz",
      "tokenAMint": "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
      "tokenBMint": "DYDWu4hE4MN3aH897xQ3sRTs5EAjJDmQsKLNhbpUiKun",
      "tokenAReserve": "DvHVapj4g2Y1tJVSw2ubSPkPBsJPb8fW387ZWXwaKmZq",
      "tokenBReserve": "DKjqWWgrtDRPKrnMWtZ4UiJk4sGQVCQgFjSo7BvfngvK",
      "lpTokenSPL": "pBTCmyG7FaZx4uk3Q2pT5jHKWmWDn84npdc7gZXpQ1x"
    },
    "tokenA": "renbtc",
    "tokenB": "ptokens-btc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_port_2pool",
    "relevantAccounts": {
      "sunnyPool": "3sGzHd66PGuC2Y1uJUtem6AXn4nwfEAy1YSUF9BGkSCW",
      "tokenAMint": "3RudPTAkfcq9Q9Jk8SVeCoecCBmdKMj6q5smsWzxqtqZ",
      "tokenBMint": "FgSsGV8GByPaMERxeQJPvZRZHf7zCBhrdYtztKorJS58",
      "tokenAReserve": "2tBpLvzYBCs7e4DrRocEnssoJANB8rDh2jt5FbeCAeK1",
      "tokenBReserve": "DLkWGoaeXw4oeGPnr2ecJze541HVKFhrhaW4iVSFEwET",
      "lpTokenSPL": "PortuzxBGYMQXeNmM9Kc6AtHLBwqSrb6xWwZ4trQ1en"
    },
    "tokenA": "tether",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_prtsol",
    "relevantAccounts": {
      "sunnyPool": "ADwAz4Re8zDo7P1uhVF7VQHRRLZrotWz8Wyf13atLV6d",
      "tokenAMint": "BdZPG9xWrG3uFrx2KrUW1jT4tZ9VKPDWknYihzoPRJS3",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "9ZDpBKPqMABtGfq66FbVribaArMvtk63xxy91onZAtDt",
      "tokenBReserve": "DaTP4s6N7xxSPinbNZ3FB52EpRDRt87QShTuN3VPCW52",
      "lpTokenSPL": "PrsVdKtXDDf6kJQu5Ff6YqmjfE4TZXtBgHM4bjuvRnR"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_psol",
    "relevantAccounts": {
      "sunnyPool": "D7FXWcnRGRrxypYZvujosegypQ9MsZ6cZMoh8qAJVmqN",
      "tokenAMint": "9EaLkQrbjmbbuZG9Wdpo8qfNUEjHATJFSycEmw6f1rGX",
      "tokenBMint": "BdZPG9xWrG3uFrx2KrUW1jT4tZ9VKPDWknYihzoPRJS3",
      "tokenAReserve": "3oyc6hpjYSJEquK6dSvG72NXyz3pqLZz5D8AC71pwgQb",
      "tokenBReserve": "Di2vordgFJVZ1aj1aBpvzXtLfZgJsuLLXawGtVFwX6Rz",
      "lpTokenSPL": "PSopTFPXzTRysj2H6W8oTvYBZmJHtRcVaQaDkckifAy"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_socean",
    "relevantAccounts": {
      "sunnyPool": "EfpaH6fykCjgpH6wr72uvVbxJGziu5otyyY3gUN76Si2",
      "tokenAMint": "5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "DjvZuMZ46fxKBoBpGMPcRcos4xdTtHFxwMh69DpA2ZFY",
      "tokenBReserve": "9rvDPJLAng4uVVqnnSoEXgNDFhBZQTny9AoQioYDZbQX",
      "lpTokenSPL": "SoCJs5Qw1D3fjGbTqxxovK15FVnYVrwvTbYcBBrZmWj"
    },
    "tokenA": "socean-staked-sol",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_srm",
    "relevantAccounts": {
      "sunnyPool": "9rVWaDfo3htoJVeSwb9Yva8gZif3hY9kwWzAiptW4JNY",
      "tokenAMint": "2jXy799YnEcRXneFo2GEAB6SDRsAa767HpWmktRr1DaP",
      "tokenBMint": "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
      "tokenAReserve": "C5uYkVHiFduEFq8S3fr4pgUS24oYj1sjZ8WW2cb4j8SU",
      "tokenBReserve": "3F5DPU5ScgHiFzePYUHZovvgh3uqmM5keNvbavx2ERqV",
      "lpTokenSPL": "SRMKjSJpBHJ5gSVTrimci49SnXc1LVkBi9TGF9RNYdp"
    },
    "tokenA": "serum",
    "tokenB": "serum",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_stsol",
    "relevantAccounts": {
      "sunnyPool": "5wT6PTeVdsBH9DGiWhCWVdrHDaFCSdDQgttvgxDhzcA4",
      "tokenAMint": "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "4PgzyzLtds9bKZ2to9PMnKqJzKEUpjvNUaeN23phegax",
      "tokenBReserve": "AtymwxoVN9peZo7EXTcDz9jKVc4vRmisJKKrNfe3ewBa",
      "lpTokenSPL": "stSjCmjQ96BiGhTk8gkU22j1739R8YBQVMq7KXWTqUV"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_usdc_pai",
    "relevantAccounts": {
      "sunnyPool": "3fnwDWqNTg9cK861gfwT3fU9HmgigWWCaNq3jhiYhRpG",
      "tokenAMint": "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "4DYwgJtxwuJdAjkj5RJSNH4e7U329V5cNp7d3a1nLrZv",
      "tokenBReserve": "EXNW64GEf1ACC6xY9BtKRiunrs6GoJSXBdxWN2eTPmrF",
      "lpTokenSPL": "PaiYwHYxr4SsEWox9YmyBNJmxVG7GdauirbBcYGB7cJ"
    },
    "tokenA": "parrot-usd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_usdc_usdt",
    "relevantAccounts": {
      "sunnyPool": "3Zk1PhVap6mwrB9jZktucoSaMBa2whYSq8jtLew3tXbp",
      "tokenAMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "CfWX7o2TswwbxusJ4hCaPobu2jLCb1hfXuXJQjVq3jQF",
      "tokenBReserve": "EnTrdMMpdhugeH6Ban6gYZWXughWxKtVGfCwFn78ZmY3",
      "lpTokenSPL": "2poo1w1DL6yd2WNTCnNTzDqkC6MBXq7axo77P16yrBuf"
    },
    "tokenA": "usd-coin",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_usdk",
    "relevantAccounts": {
      "sunnyPool": "FtDqjkFWgxLsUH4sAX8EAwQKmTrsMUdddPEwAZu1j1SY",
      "tokenAMint": "2kycGCD8tJbrjJJqWN2Qz5ysN9iB4Bth3Uic4mSB7uak",
      "tokenBMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenAReserve": "5RfXYWvxR9PUaedokXVxgJHDoD4xnLLauVtdJ27shPWG",
      "tokenBReserve": "DJcFPaQjyW9Xkt7sXCbnEGj1yfykGYuLRUXFyS4LLZ5F",
      "lpTokenSPL": "uSdKg2Cs5bCtFSeNXs7aRVNzZJauX58eCkdsfssxTdW"
    },
    "tokenA": "usdk",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ust",
    "relevantAccounts": {
      "sunnyPool": "J6kYSfcvWUBVE2J7c4T9jvsj8Joimxt9KapAyQkkGwp5",
      "tokenAMint": "JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",
      "tokenBMint": "CXLBjMMcwkc17GfJtBos6rQCo1ypeH6eDbB82Kby4MRm",
      "tokenAReserve": "D9yh4KAysxt9GLacVe4Wwh2XqghhcjTCSTV9HuM7TBJd",
      "tokenBReserve": "HDYfJLpZKaMFb84jM4mRytn7XLR8UFZUnQpSfhJJaNEy",
      "lpTokenSPL": "UST32f2JtPGocLzsL41B3VBBoJzTm1mK1j3rwyM3Wgc"
    },
    "tokenA": "usd-coin",
    "tokenB": "terrausd",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_ust_cash",
    "relevantAccounts": {
      "sunnyPool": "2cjiAfw4ApUjaGm4HtzwdVzNYGeBgS5VvpqnvYcafesU",
      "tokenAMint": "9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",
      "tokenBMint": "CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",
      "tokenAReserve": "JAjt8kZkTsxKA3VKnmszKHQwzuNSAXXhN3Y4NZ2kEoLU",
      "tokenBReserve": "F2NtJ1kcLLvQZ6RMH5sApf12BpGpAeGwio3WWPRZWUDu",
      "lpTokenSPL": "CLPRkuzQFiYnXddGTTKLvqgjgh4Tm7q16sVvivWNRzo8"
    },
    "tokenA": "terrausd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wdai",
    "relevantAccounts": {
      "sunnyPool": "75dRdYpYSYDnLrhnxu1ofSWyM9D6C5bjJNR5Dx6v1d7E",
      "tokenAMint": "EjmyN6qEC1Tf1JxiG1ae7UTJhUxSwk1TCWNWqxWV4J6o",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "725ZA3fhyBAKb5iopNRrcbSuQa3LXA1656Q3mBvYPxeg",
      "tokenBReserve": "GLA6i1dSZpUfk2f9Nj8uiG7xyDdAR2reff8oEiZH3617",
      "lpTokenSPL": "DAihWEjhBc8LEmV1rEekTaiC2zqE5ex7nEFkmoe1Ppp3"
    },
    "tokenA": "dai",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_webusd",
    "relevantAccounts": {
      "sunnyPool": "4YyWv4fh49Pdh2PRftH6cS8w7pWipoS5Joaf4HSDD8wB",
      "tokenAMint": "33fsBLA8djQm82RpHmE3SuVrPGtZBWNYExsEUeKX1HXX",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "4ZjU6MKvtqVQKCiowhvZ5yUsPxXX5SCzd5eFsPeXyey5",
      "tokenBReserve": "BsyWeshjDbCvjDojry3vKDCesmFRM37WtwcR4Kfgzqr",
      "lpTokenSPL": "BSCNZ4GLnpZYv4BLk5edymk4qty8a6ZpiMbfvtv9gAzL"
    },
    "tokenA": "binance-usd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_weusdc",
    "relevantAccounts": {
      "sunnyPool": "GxbxYFigYTQg5thJwroii78kYWqNFseGeE1Cx3rtAs6t",
      "tokenAMint": "A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "3YB7hfpBdbQEuZqLGWVDpRPmeZWCUsrrWyqGXegnQ6Cg",
      "tokenBReserve": "4DPCj6Z1DsG6HUtwSogBGqXEUxdEV5a8YVrrFtcnz7UW",
      "lpTokenSPL": "USDCgfM1psLGhAbx99iPA72mTySvUcVq33qhCJpm65c"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_weusdt",
    "relevantAccounts": {
      "sunnyPool": "9KYAPsNV354dfyhNiuw3qKvCNwAwUTcL5M6b7pT8c1xU",
      "tokenAMint": "Dn4noZ5jgGfkntzcQSUZ8czkreiZ1ForXYoV2H8Dm7S1",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "DtfyjjsZ5yCjWKLKHvwsfXs5QVsmm1QkK6Sh9JZHoq1g",
      "tokenBReserve": "e5wrKCRv4GhHvEf1VD5Pq2KGaZDXP77nTL612Jyrxwy",
      "lpTokenSPL": "USDTJZL2vH92K5QeCvQTTzvMXUYAdvk3v46CwZyfsue"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wfrax",
    "relevantAccounts": {
      "sunnyPool": "7aLF3aQcwZv6QNuFLioyXTje3hYuzed2KvgQjQUBYLi8",
      "tokenAMint": "FR87nWEUxVgerFGhZM8Y4AggKGLnaXswr1Pd8wZ4kZcp",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "DD4ACBWyVqdaKWh7v5btsgqQCCMwbKnuL2xd9pv7Gyuw",
      "tokenBReserve": "GcYqiJ1MAuYbNTNYXm1F1gQYTfTgkErACAhNU5dpVj9T",
      "lpTokenSPL": "FRXsjEv4jF3r72FgbCXu8uLbPoZGLmCmg3EN1S3cfC4x"
    },
    "tokenA": "frax",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wftt",
    "relevantAccounts": {
      "sunnyPool": "6WSukUGc9EvRYHniPEz3KRAvc24wnZ1Q92DogQLSS4b",
      "tokenAMint": "BFsCwfk8VsEbSfLkkgmoKsAPk2N6FMJjeTsuxfGa9VEf",
      "tokenBMint": "FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",
      "tokenAReserve": "CyFL8noR6CKMFBjZPziSmChCKJE1Jtg4hQyMhgWPgH84",
      "tokenBReserve": "5PfKQpBWUayFWSSkwjp1PLr8LiHBrvVB81qfnSP5Dvkb",
      "lpTokenSPL": "FTXjwjwWqituSXEHnL5VF1mjDhZoAyJqvHiRPsRq3KWK"
    },
    "tokenA": "ftx-token",
    "tokenB": "ftx-token",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wheth",
    "relevantAccounts": {
      "sunnyPool": "5BJpF1gtS1WpG1g4PHuAAFngP7Cmk6pzabBZbH4AKaSK",
      "tokenAMint": "SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",
      "tokenBMint": "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
      "tokenAReserve": "8p4mGnARWPBu6P2Gcw4adodLkNDorrXniZMhaY7eJXUn",
      "tokenBReserve": "AyY89zccbsgp9LKFgH4CFZMJmpSgqmPSdTfukhP227rc",
      "lpTokenSPL": "WTHPuMavN9HBvgUafjrL65WqQytQHDwnTAmdFB9whXA"
    },
    "tokenA": "ethereum",
    "tokenB": "ethereum",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_whusd",
    "relevantAccounts": {
      "sunnyPool": "74v27c1cFB49uTvktums6HAb6px4ryv8Yc7DcppneJEL",
      "tokenAMint": "7VQo3HFLNH5QqGtM8eC3XQbPkJUu7nS9LeGWjerRh5Sw",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "E7L8CZxreEeNwM1V8DLxa8AZQKu6oday6RvXxRo27CHi",
      "tokenBReserve": "48UJw19Ra8y5Kv989DsXPrfUHeUWUbHvXZmdPBbGuHdz",
      "lpTokenSPL": "HUSzWddUQbavKn24cjozm65eps8rq9yhNn5edtTLWfdz"
    },
    "tokenA": "husd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wluna",
    "relevantAccounts": {
      "sunnyPool": "FfUiwneyuHdrcSFMEUFXdp7VirpPXveANgZP4NWyk1Kp",
      "tokenAMint": "F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",
      "tokenBMint": "8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",
      "tokenAReserve": "GgRnQyCm22UkHQME96CqJFpsqV93QJQsWMURdsQSSAdk",
      "tokenBReserve": "GrWSq33By3uf7Vqqfrscy7oJMuqGgZojd2KSzsxioxQL",
      "lpTokenSPL": "LUN1p1dZwSBgTv1JSdn2apdUuLanHKtgNcnpDydVFTU"
    },
    "tokenA": "terra-luna",
    "tokenB": "terra-luna",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wpusdc",
    "relevantAccounts": {
      "sunnyPool": "8LsKf2vzMyKPbMbN2SgxTUdzA4ijSEprDUoQoEyELGkW",
      "tokenAMint": "E2VmbootbVCBkMNNxKQgCLMS1X3NoGMaYAsufaAsf7M",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "y8dALFo1bJrSzPYjMX14HJX448pXqYmrfXHD1K8MXih",
      "tokenBReserve": "GN7Yuet3UyiWS5YVkEHv6oQKi4HGBJc3XDPt9zQhAqZz",
      "lpTokenSPL": "WLPyXq7WRfdWLiP4fvRfSisrfDzLiPmCeVTE6okKQWE"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wpusdt",
    "relevantAccounts": {
      "sunnyPool": "2A4Xr9Gezyytrr8Q97HvahTV5bX3m9DJFirL7uJBh7ss",
      "tokenAMint": "5goWRao6a3yNC4d6UjMdQxonkCMvKBwdpubU3qhfcdf1",
      "tokenBMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "tokenAReserve": "631WX9JizSHJm4w6VanZeJAst9T8DeUUnPLesdGkCVtK",
      "tokenBReserve": "211maUSfpnXbPuW1iBu8b4dtJv5EbN1j7JJiEX5TZKEP",
      "lpTokenSPL": "WLP59xUDvQMQdzC2SgPmZeRF1oj2RSvGZiQLksj4bwj"
    },
    "tokenA": "tether",
    "tokenB": "tether",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wusdk",
    "relevantAccounts": {
      "sunnyPool": "B7pvYmmMFk2X4vUi1n2BBkxYj9dY5tq5XJoErwFv6jES",
      "tokenAMint": "43m2ewFV5nDepieFjT9EmAQnc1HRtAF247RBpLGFem5F",
      "tokenBMint": "88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",
      "tokenAReserve": "CMR2J7CwfW98RpvnJmFBgRFTLAd3x8CJ1SWs8Bt3uunG",
      "tokenBReserve": "FmRb5jHfSNj1YWP3b45d9vvYuhwjp4om8bALmtqZpr1v",
      "lpTokenSPL": "USDKKmk1anWU1aEn6GJ6skL3ZvcB9CBAWVkmPGQEHtz"
    },
    "tokenA": "usdk",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_wust",
    "relevantAccounts": {
      "sunnyPool": "AAoP2zqcuQ4hesQsCsAqFKDfKJuH8rwXhFrWhB8i52bU",
      "tokenAMint": "9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "J63v6qEZmQpDqCD8bd4PXu2Pq5ZbyXrFcSa3Xt1HdAPQ",
      "tokenBReserve": "BnKQtTdLw9qPCDgZkWX3sURkBAoKCUYL1yahh6Mw7mRK",
      "lpTokenSPL": "USTCmQpbUGj5iTsXdnTYHZupY1QpftDZhLokSVk6UWi"
    },
    "tokenA": "terrausd",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_xbtc",
    "relevantAccounts": {
      "sunnyPool": "DdmQPMjBanrAZLc4fgYPeRmEZkU8LPH4tB7Qktfegd79",
      "tokenAMint": "HWxpSV3QAGzLQzGAtvhSYAEr7sTQugQygnni1gnUGh1D",
      "tokenBMint": "BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",
      "tokenAReserve": "C82XDu1d1UjtuUwnkSTwVuWyH3AqpJ3ftb9W7en8rEUu",
      "tokenBReserve": "F7cZoYpWQSFuYJzW2UUFw6sVbTtaihyD5upeeHRUPABk",
      "lpTokenSPL": "xBTCPvRuEuRgz5DuuUd3ju3VP5XtR2Dsu1AxyW9JpXK"
    },
    "tokenA": "bitcoin",
    "tokenB": "renbtc",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_xeth",
    "relevantAccounts": {
      "sunnyPool": "BYaEPQ4aWSMkBtuzYycowy4c7C9jCnzALcZtD1fsRsj4",
      "tokenAMint": "8bqjz8DeSuim1sEAsQatjJN4zseyxSPdhHQcuuhL8PCK",
      "tokenBMint": "KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",
      "tokenAReserve": "3gkSjY95an9xNFSjCfsay6JZez7uv7yfW3Ad4ubc4fMK",
      "tokenBReserve": "9wXqANaSuEqkKL9yHzCPEDGHwbkStVAqV5rB3QDs3Jr6",
      "lpTokenSPL": "xETH89889mVRwsw9tSUnULsdLUPryTpijagy2YXxWyY"
    },
    "tokenA": "ethereum",
    "tokenB": "ethereum",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_xftt",
    "relevantAccounts": {
      "sunnyPool": "Ex33MaUfcdDUKfsdxsLWCqy4zEheQcLs8X45gBaiKJgF",
      "tokenAMint": "Fr3W7NPVvdVbwMcHgA7Gx2wUxP43txdsn3iULJGFbKz9",
      "tokenBMint": "EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",
      "tokenAReserve": "HHnpxMvDcXaeHXTSnWw9y8gMeUMnnCzxWfACgx839nCt",
      "tokenBReserve": "Hk8UFqdvVdvJRZjKJV59PkrDrpLnbCCBMgDjVwx53cwi",
      "lpTokenSPL": "xFTTLsMdN28XHtYTTTVWYz5zwXWBm5r1WTuZ7Cc7SyA"
    },
    "tokenA": "ftx-token",
    "tokenB": "ftx-token",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_xsol",
    "relevantAccounts": {
      "sunnyPool": "r5YY5McowCBago6oG1nFF3182Dw1XyKxMUE2CCyo3DT",
      "tokenAMint": "BdUJucPJyjkHxLMv6ipKNUhSeY3DWrVtgxAES1iSBAov",
      "tokenBMint": "So11111111111111111111111111111111111111112",
      "tokenAReserve": "GSt31U8nF6WJBRG7j2EALfNTMd3J8jmotGX9szVTrzvN",
      "tokenBReserve": "7WEqRDS5Dk6kVXFZHrsW5EtdPhy4v6jWK9P5jHhi9oz",
      "lpTokenSPL": "xSoLVBNztDTUW8Kou2GJinHoe54Siu9Sk3e2uoU9aUi"
    },
    "tokenA": "solana",
    "tokenB": "solana",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  },
  {
    "poolName": "quarry_saber_xusd",
    "relevantAccounts": {
      "sunnyPool": "ESkFpDc7n9MzQeMnZC71WX8J4Q7dpehKonanYd6khccZ",
      "tokenAMint": "83LGLCm7QKpYZbX8q4W2kYWbtt8NJBwbVwEepzkVnJ9y",
      "tokenBMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "tokenAReserve": "34M8pFVqgbV7aqHxvRT5tCv3vu2P1JJYT8J3VaxBK2oG",
      "tokenBReserve": "3AZWBSze3ucsY3xSeuLne3b2pauVqiaJ1SZSV5T9WGWw",
      "lpTokenSPL": "XUSDfnsgc2QYXRdbPAbMWoXCbBCCspRSvoGJ8o7RV9n"
    },
    "tokenA": "usd-coin",
    "tokenB": "usd-coin",
    "tvlReader": "sunnyQuarrySaberPoolReader"
  }
]
'''
'''--- projects/helper/terra.js ---
const axios = require('axios')
const { default: BigNumber } = require("bignumber.js")
const sdk = require('@defillama/sdk')

function getEndpoint(isTerra2 = false) {
  if (!isTerra2)
    return process.env["TERRA_RPC"] || 'https://lcd.terra.dev'
  return process.env["TERRA2_RPC"] || 'https://phoenix-lcd.terra.dev'
}

async function query(url, block, isTerra2 = false) {
  block = undefined
  let endpoint = `${getEndpoint(isTerra2)}/wasm/${url}`
  if (block !== undefined) {
    endpoint += `&height=${block - (block % 100)}`
  }
  return (await axios.get(endpoint)).data.result
}

const fetchAssets = async (path) => {
  return (await axios.get(`https://assets.terra.money${path}`))
}

async function queryV1Beta1(url, paginationKey, block, { isTerra2 = false } = {}) {
  let endpoint = `${getEndpoint(isTerra2)}/cosmos/${url}`
  if (block !== undefined) {
    endpoint += `?height=${block - (block % 100)}`
  }
  if (paginationKey) {
    const paginationQueryParam = `pagination.key=${paginationKey}`
    if (block === undefined) {
      endpoint += "?"
    } else {
      endpoint += "&"
    }
    endpoint += paginationQueryParam
  }
  return (await axios.get(endpoint)).data
}

async function getBalance(token, owner, block, { isTerra2 = false } = {}) {
  const data = await query(`contracts/${token}/store?query_msg={"balance":{"address":"${owner}"}}`, block, isTerra2)
  return Number(data.balance)
}

async function getDenomBalance(denom, owner, block, { isTerra2 = false } = {}) {
  let endpoint = `${getEndpoint(isTerra2)}/bank/balances/${owner}`
  if (block !== undefined) {
    endpoint += `?height=${block - (block % 100)}`
  }
  const data = (await axios.get(endpoint)).data.result

  const balance = data.find(balance => balance.denom === denom);
  return balance ? Number(balance.amount) : 0
}

// LP stuff
async function totalSupply(token, block, { isTerra2 = false } = {}) {
  const data = await query(`contracts/${token}/store?query_msg={"token_info":{}}`, block, isTerra2)
  return data.total_supply
}

async function lpMinter(token, block, { isTerra2 = false } = {}) {
  const data = await query(`contracts/${token}/store?query_msg={"minter":{}}`, block, isTerra2)
  return data.minter
}
async function queryContract({ contract, isTerra2 = false, data }) {
  if (typeof data !== 'string') data = JSON.stringify(data)
  data = Buffer.from(data).toString('base64')
  return (await axios.get(`${getEndpoint(isTerra2)}/cosmwasm/wasm/v1/contract/${contract}/smart/${data}`)).data.data
}

function getAssetInfo(asset) {
  return [asset.info.native_token?.denom ?? asset.info.token?.contract_addr, Number(asset.amount)]
}

async function unwrapLp(balances, lpToken, lpBalance, block, { isTerra2 = false } = {}) {
  const pair = await lpMinter(lpToken)
  const { assets, total_share } = await query(`contracts/${pair}/store?query_msg={"pool":{}}`, block);
  const [token0, amount0] = getAssetInfo(assets[0])
  const [token1, amount1] = getAssetInfo(assets[1])
  balances[token0] = (balances[token0] ?? 0) + (amount0 * lpBalance / total_share)
  balances[token1] = (balances[token1] ?? 0) + (amount1 * lpBalance / total_share)
}

const tokenMapping = {
  'terra1xfsdgcemqwxp4hhnyk4rle6wr22sseq7j07dnn': { label: 'KIJU', decimals: 6, },
  'terra188w26t95tf4dz77raftme8p75rggatxjxfeknw': { label: 'sKIJU', decimals: 6, },
  'terra15k5r9r8dl8r7xlr29pry8a9w7sghehcnv5mgp6': { coingeckoId: 'lunaverse', decimals: 6, },
  'terra1cl7whtrqmz5ldr553q69qahck8xvk80fm33qjx': { label: 'ALTO', decimals: 6, },
  'terra1dy9kmlm4anr92e42mrkjwzyvfqwz66un00rwr5': { coingeckoId: 'valkyrie-protocol', decimals: 6, },
  'terra14z56l0fp2lsf86zy3hty2z47ezkhnthtr9yq76': { coingeckoId: 'anchor-protocol', decimals: 6, },
  'terra15gwkyepfc6xgca5t5zefzwy42uts8l2m4g40k6': { coingeckoId: 'mirror-protocol', decimals: 6, },
  'terra17y9qkl8dfkeg4py7n0g5407emqnemc3yqk5rup': { coingeckoId: 'stader-lunax', decimals: 6, },
  'terra1hzh9vpxhsk8253se0vv5jj6etdvxu3nv8z07zu': { coingeckoId: 'anchorust', decimals: 6, },
  'terra1kc87mu460fwkqte29rquh4hc20m54fxwtsx7gp': { coingeckoId: 'bonded-luna', decimals: 6, },
  'uluna': { coingeckoId: 'terra-luna', decimals: 6, },
  'uusd': { coingeckoId: 'terrausd', decimals: 6, },
  'terra1dzhzukyezv0etz22ud940z7adyv7xgcjkahuun': { coingeckoId: 'anchor-beth-token', decimals: 6, },
  'terra1z3e2e4jpk4n0xzzwlkgcfvc95pc5ldq0xcny58': { coingeckoId: 'avalanche-2', decimals: 6, },
  'terra1nef5jf6c7js9x6gkntlehgywvjlpytm7pcgkn4': { label: 'LOOP', decimals: 6, },
  'terra1vwz7t30q76s7xx6qgtxdqnu6vpr3ak3vw62ygk': { coingeckoId: 'luart', decimals: 6, },
  'terra1xj49zyqrwpv5k928jwfpfy2ha668nwdgkwlrg3': { coingeckoId: 'astroport', decimals: 6, },
}

const TOKEN_LIST = Object.keys(tokenMapping).reduce((agg, key) => {
  const { coingeckoId, label } = tokenMapping[key]
  agg[coingeckoId || label] = key
  return agg
}, {})

async function queryContractStore({ contract, queryParam, block, isTerra2= false, }) {
  if (typeof queryParam !== 'string') queryParam = JSON.stringify(queryParam)
  const url = `contracts/${contract}/store?query_msg=${queryParam}`
  return query(url, block, isTerra2)
}

function sumSingleBalance(balances, token, balance, price) {
  const { coingeckoId, label, decimals = 0, } = tokenMapping[token] || {}

  if (coingeckoId || (label && price)) {
    token = coingeckoId || 'terrausd'

    if (decimals)
      balance = BigNumber(balance).shiftedBy(-1 * decimals)

    if (!coingeckoId)
      balance = balance.multipliedBy(BigNumber(price))   // convert the value to UST

    if (!balances[token])
      balances[token] = BigNumber(0)
    else if (typeof balances[token] === 'string')
      balances[token] = BigNumber(balances[token]).shiftedBy(-1 * decimals)

    balances[token] = balances[token].plus(balance)
    return
  }

  sdk.util.sumSingleBalance(balances, token, balance)
  return balances
}

module.exports = {
  totalSupply,
  getBalance,
  getDenomBalance,
  unwrapLp,
  query,
  queryV1Beta1,
  fetchAssets,
  queryContractStore,
  sumSingleBalance,
  queryContract,
  TOKEN_LIST,
}

'''
'''--- projects/helper/tezos.js ---
const http = require('./http')
const sdk = require('@defillama/sdk')
const { getChainTransform } = require('./portedTokens')
const { default: BigNumber } = require('bignumber.js')
const { usdtAddress, } = require('../helper/balances')
const { PromisePool } = require('@supercharge/promise-pool')

const RPC_ENDPOINT = 'https://api.tzkt.io'

const tokenBlacklist = [
  'KT18quSVkqhbJS38d5sbRAEkXd5GoNqmAoro',
  'KT1TtaMcoSx5cZrvaVBWsFoeZ1L15cxo5AEy',
  'KT19oivKN2qzeWgCs886BbttSVYtkcJHRtuQ',
  'KT1AhSVv4Se1j3Hf5Y6a56vBV44zNzjP91D2',
  'KT1Gf5JGXC1M8GMji58pKraXiRLkzW2NRK1s',
  'KT1R52Gk7LzWvyV41oP9dRUbboHs4yVTXAZT',
  'KT1LVnyY5cSCVpFMGXzqVsWNiSkJYA8w1rZk',
  'KT1T9kFJD5fKAT4LAZWjYBCaWNbD7cw1CUju',
  'KT1JXxK3bd39ayLiiBdKm2cdReYnVSG3bkzK',
  'KT1FR9ij18K3dDExgFMBs7ppxfdGYzHiPo7c',
  'KT1GhX6MzTHKcjkMTg1mwCPzam12HRjsp6Sf',
]

async function getTokenBalances(account, includeTezosBalance = true) {
  const response = await http.get(`${RPC_ENDPOINT}/v1/tokens/balances?account=${account}&sort.desc=balance&offset=0&limit=40&select=balance,token.id%20as%20id,token.contract%20as%20contract,token.tokenId%20as%20token_id`)
  const balances = response.reduce((agg, item) => {
    let token = item.contract.address
    if (item.token_id !== '0') token += '-' + item.token_id

    if (!tokenBlacklist.includes(token))
      agg[token] = item.balance
    return agg
  }, {})

  if (includeTezosBalance)
    balances['tezos'] = await getTezosBalance(account)

  if (balances.tezos === 0) delete balances.tezos
  return balances
}

async function getTezosBalance(account) {
  const balance = await http.get(`${RPC_ENDPOINT}/v1/accounts/${account}/balance`)
  return +balance / 10 ** 6
}

async function getStorage(account) {
  return http.get(`${RPC_ENDPOINT}/v1/contracts/${account}/storage`)
}

async function addDexPosition({ balances = {}, account, transformAddress }) {
  if (!transformAddress) transformAddress = await getChainTransform('tezos')
  const tokenBalances = await getTokenBalances(account)
  Object.keys(tokenBalances).forEach(token => sdk.util.sumSingleBalance(balances, transformAddress(token), tokenBalances[token]))
  return balances
}

async function resolveLPPosition({ balances = {}, owner, lpToken, transformAddress, ignoreList = [] }) {
  if (!transformAddress) transformAddress = await getChainTransform('tezos')
  const LPBalances = await getTokenBalances(owner)
  if (!LPBalances[lpToken]) return balances
  const data = await getStorage(lpToken)
  const admin = data.admin || data.exchangeAddress
  const total_supply = data.total_supply || data.totalSupply

  if (ignoreList.includes(admin))
    return balances

  const tokenBalances = await getTokenBalances(admin)
  const ownershipRatio = BigNumber(LPBalances[lpToken]).dividedBy(total_supply)
  Object.keys(tokenBalances).forEach(token => {
    const balance = BigNumber(tokenBalances[token]).multipliedBy(ownershipRatio).toFixed(0)
    sdk.util.sumSingleBalance(balances, transformAddress(token), balance)
  })
  return balances
}

async function sumTokens({ owners = [], balances = {}, includeTezos = false }) {
  const { errors } = await PromisePool.withConcurrency(10)
    .for(owners)
    .process(async item => {
      const balance = await getTokenBalances(item, includeTezos)
      Object.entries(balance).forEach(([token, bal]) => sdk.util.sumSingleBalance(balances, token, bal))
    })

  if (errors && errors.length)
    throw errors[0]

  return balances
}

function fetchPrice() {
  return http.get('https://api.teztools.io/token/prices')
}

let pricePromise

async function getPrices() {
  if (!pricePromise) pricePromise = fetchPrice()
  const { contracts: pricesArray } = await pricePromise
  const priceObj = {}
  pricesArray.forEach(p => {
    let label = p.tokenAddress
    if (p.hasOwnProperty('tokenId') && p.tokenId !== 0) label += '-' + p.tokenId
    priceObj[label] = p
  })
  return priceObj
}

async function convertBalances(balances) {
  let totalUSD = 0
  const prices = await getPrices()
  const response = {}
  Object.entries(balances).forEach(([token, balance]) => {
    if (token === 'tezos') return;
    if (!prices[token]) {
      response[token] = balance
      return;
    }
    const { decimals, usdValue, } = prices[token]
    if (!usdValue || !decimals) return;
    const inMillions = (+balance / 10 ** decimals) * usdValue / 1e6
    if (inMillions > 0.2) console.log(inMillions, decimals, balance, usdValue, token)
    totalUSD += (+balance / 10 ** decimals) * usdValue
  })

  response[usdtAddress] = totalUSD * 1e6
  if (balances.tezos) response.tezos = balances.tezos
  return response
}

async function getLPs(dex) {
  if (!pricePromise) pricePromise = fetchPrice()
  const { contracts } = await pricePromise
  const LPs = {}
  for (const { pairs } of contracts)
    pairs.filter(p => p.dex === dex).forEach(p => LPs[p.address] = p)
  return Object.keys(LPs)
}

module.exports = {
  RPC_ENDPOINT,
  getStorage,
  sumTokens,
  convertBalances,
  getTokenBalances,
  addDexPosition,
  resolveLPPosition,
  getLPs,
}

'''
'''--- projects/helper/tokenholders.js ---
const { sumTokens } = require('./unwrapLPs')
const sdk = require('@defillama/sdk')

const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"

function normalizeArray(arrayOrString){
    if(Array.isArray(arrayOrString)){
        return arrayOrString
    }else {
        return [arrayOrString]
    }
}

function tokenHolderBalances(tokenHolderMap, chain = 'ethereum') {
    return async (timestamp, block, chainBlocks) => {
        if (chain !== 'ethereum') block = chainBlocks[chain]
        const tokensAndHolders = []
        let ethHolders = []
        for (const group of tokenHolderMap) {
            const holders = normalizeArray(group.holders);
            const tokens = normalizeArray(group.tokens)
            if (group.checkETHBalance === true) {
                ethHolders = ethHolders.concat(holders)
            }
            tokens.forEach(token => {
                holders.forEach(holder => {
                    tokensAndHolders.push([token, holder])
                })
            })
        }

        const balances = {};
        await sumTokens(balances, tokensAndHolders, block, chain);
        if (ethHolders.length > 0) {
            const ethBalances = await sdk.api.eth.getBalances({
                targets: ethHolders,
                block,
                chain,
            })
            let nativeToken = WETH
            switch (chain) {
                case 'bsc': nativeToken = 'bsc:0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'; break;  // wbnb
                case 'polygon': nativeToken = '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0'; break;   // matic
                case 'xdai': nativeToken = '0x6b175474e89094c44da98b954eedeac495271d0f'; break;   // xdai
                case 'avax': nativeToken = 'avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7'; break;   // avax
            }
            ethBalances.output.forEach(ethBal => {
                sdk.util.sumSingleBalance(balances, nativeToken, ethBal.balance)
            })
        }
        return balances
    }
}

module.exports = {
    tokenHolderBalances
}
'''
'''--- projects/helper/tomb.js ---
const { staking, stakingUnknownPricedLP } = require("./staking");
const { pool2Exports } = require("./pool2");
const sdk = require("@defillama/sdk");
const token0Abi = require("./abis/token0.json");
const token1Abi = require("./abis/token1.json");
const { default: BigNumber } = require("bignumber.js");

function tombTvl(token, share, rewardPool, masonry, pool2LPs, chain = "ethereum", transform = undefined, tokensOnCoingecko = true, lpWithShare = undefined) {
    if (transform === undefined) transform = addr => `${chain}:${addr}`;
    if (tokensOnCoingecko) {
        return {
            [chain === "avax" ? "avalanche" : chain]: {
                tvl: async () => ({}),
                staking: staking(masonry, share, chain),
                pool2: pool2Exports(rewardPool, pool2LPs, chain, transform)
            }
        }
    }
    else if (!tokensOnCoingecko) {
        const pool2 = async (timestamp, block, chainBlocks) => {
            let balances = {};
            token = token.toLowerCase();
            share = share.toLowerCase();
            block = chainBlocks[chain];
            const pool2Balances = (await sdk.api.abi.multiCall({
                calls: pool2LPs.map(p => ({
                    target: p,
                    params: rewardPool
                })),
                abi: "erc20:balanceOf",
                block,
                chain
            })).output;
            const supplies = (await sdk.api.abi.multiCall({
                calls: pool2LPs.map(p => ({
                    target: p
                })),
                abi: "erc20:totalSupply",
                block,
                chain
            })).output;
            const pool2Token0 = (await sdk.api.abi.multiCall({
                calls: pool2LPs.map(p => ({
                    target: p
                })),
                abi: token0Abi,
                block,
                chain
            })).output;
            const pool2Token1 = (await sdk.api.abi.multiCall({
                calls: pool2LPs.map(p => ({
                    target: p
                })),
                abi: token1Abi,
                block,
                chain
            })).output;

            for (let i = 0; i < pool2LPs.length; i++) {
                let listedToken;
                const token0 = pool2Token0[i].output.toLowerCase();
                const token1 = pool2Token1[i].output.toLowerCase();
                if (token0 === token || token0 === share) {
                    listedToken = token1;
                }
                else if (token1 === token || token1 === share) {
                    listedToken = token0;
                }
                const listedTokenBalance = (await sdk.api.erc20.balanceOf({
                    target: listedToken,
                    owner: pool2LPs[i],
                    block,
                    chain
                })).output;
                const balance = BigNumber(pool2Balances[i].output).times(listedTokenBalance).div(supplies[i].output).times(2).toFixed(0);
                sdk.util.sumSingleBalance(balances, transform(listedToken), balance);
            }
            return balances
        }

        return {
            [chain === "avax" ? "avalanche" : chain]: {
                tvl: async () => ({}),
                staking: stakingUnknownPricedLP(masonry, share, chain, lpWithShare),
                pool2
            }
        }
    }
}

module.exports = {
    tombTvl
}
'''
'''--- projects/helper/tron.js ---
const axios = require('axios')
const BigNumber = require('bignumber.js')
const ethers = require('ethers')
const { toHex } = require('tron-format-address')
const axiosObj = axios.create({
  baseURL: 'https://api.trongrid.io/',
  headers: {
    'TRON-PRO-API-KEY': '66410e19-c0f6-449c-aae3-78f2581a1a0b',
    'Content-Type': 'application/json'
  },
  timeout: 300000,
})

const AbiCoder = ethers.utils.AbiCoder;
const ADDRESS_PREFIX_REGEX = /^(41)/;
const ADDRESS_PREFIX = "41";

function encodeParams(inputs) {
  let typesValues = inputs
  let parameters = ''

  if (typesValues.length == 0)
    return parameters
  const abiCoder = new AbiCoder();
  let types = [];
  const values = [];

  for (let i = 0; i < typesValues.length; i++) {
    let { type, value } = typesValues[i];
    if (type == 'address')
      value = value.replace(ADDRESS_PREFIX_REGEX, '0x');
    else if (type == 'address[]')
      value = value.map(v => toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'));
    types.push(type);
    values.push(value);
  }

  return abiCoder.encode(types, values).replace(/^(0x)/, '');
}

function decodeParams(types, output, ignoreMethodHash) {

  if (!output || typeof output === 'boolean') {
      ignoreMethodHash = output;
      output = types;
  }

  if (ignoreMethodHash && output.replace(/^0x/, '').length % 64 === 8)
      output = '0x' + output.replace(/^0x/, '').substring(8);

  const abiCoder = new AbiCoder();

  if (output.replace(/^0x/, '').length % 64)
      throw new Error('The encoded string is not valid. Its length must be a multiple of 64.');
  return abiCoder.decode(types, output).reduce((obj, arg, index) => {
      if (types[index] == 'address')
          arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
      obj.push(arg);
      return obj;
  }, []);
}

// api reference: https://developers.tron.network/reference
const owner_address = 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t'

async function unverifiedCall(contract, functionSelector, parameter) {
  var body = {
    owner_address: owner_address,
    contract_address: contract,
    function_selector: functionSelector,
    parameter: encodeParams(parameter),
    visible: true,
  };
  const axiosResponse = await axiosObj.post('/wallet/triggerconstantcontract', body)
  return BigNumber("0x" + axiosResponse.data['constant_result'][0])
}

function getUnverifiedTokenBalance(token, account) {
  return unverifiedCall(token, 'balanceOf(address)', [
    {
      type: 'address',
      value: toHex(account)
    }
  ])
}

async function getTokenBalance(token, account) {
  const [balance, decimals] = await Promise.all([
    getUnverifiedTokenBalance(token, account),
    unverifiedCall(token, 'decimals()', [])
  ]);
  return Number(balance.toString()) / (10 ** decimals)
}

async function getTrxBalance(account) {
  const axiosResponse = await axiosObj.get('v1/accounts/' + account)
  return axiosResponse.data.data[0].balance
}

module.exports = {
  getTokenBalance,
  getTrxBalance,
  getUnverifiedTokenBalance,
  unverifiedCall
}

'''
'''--- projects/helper/unifarm.js ---
const axios = require("axios");

const ETH_CHAIN = "ethereum";
const BSC_CHAIN = "bsc";
const POLYGON_CHAIN = "polygon";

const ETH_TOKENLIST =
  "https://raw.githubusercontent.com/InfernalHeir/tokenlist/mainnet-01/unifarm-tokenlist.json";
const BSC_TOKENLIST =
  "https://raw.githubusercontent.com/InfernalHeir/tokenlist/mainnet-01/unifarm.tokenlist.56.json";
const POLYGON_TOKENLIST =
  "https://raw.githubusercontent.com/InfernalHeir/tokenlist/mainnet-01/unifarm.tokenlist.137.json";

const GRAPH_ENDPOINT = "https://graph.unifarm.co/graphql";

const QUERY = `
query GetCohort($where: CohortGroupWhereClause!) {
  allCohortsAndProxies(where: $where) {
    cohortAddress
    proxies
  }
}
`;

const getCohortTokens = async (url) => {
  const results = await axios.get(url);
  return results.data.tokenlist;
};

const getCohortTokensByChainName = async (chain) => {
  switch (chain) {
    case ETH_CHAIN:
      return await getCohortTokens(ETH_TOKENLIST);
    case BSC_CHAIN:
      return await getCohortTokens(BSC_TOKENLIST);
    case POLYGON_CHAIN:
      return await getCohortTokens(POLYGON_TOKENLIST);
    default:
      break;
  }
};

const getCohortAndProxies = async (chainId) => {
  try {
    const results = await axios.post(
      GRAPH_ENDPOINT,
      JSON.stringify({
        query: QUERY,
        variables: {
          where: {
            chainId,
          },
        },
      }),
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
    return results.data.data.allCohortsAndProxies;
  } catch (err) {
    console.log(err.message);
  }
};

const getCohortsAndProxiesByChain = async (chain) => {
  switch (chain) {
    case ETH_CHAIN:
      return getCohortAndProxies(1);
    case BSC_CHAIN:
      return getCohortAndProxies(56);
    case POLYGON_CHAIN:
      return getCohortAndProxies(137);
    default:
      return null;
  }
};

const createCalls = (tokens, cohortId) => {
  return tokens.map((items) => {
    return {
      target: items.address,
      params: [cohortId],
    };
  });
};

const createMulticalls = (cohortAndProxies, tokens) => {
  let calls = [];
  for (var u = 0; u < cohortAndProxies.length; u++) {
    const items = cohortAndProxies[u];
    const cohortId = items.cohortAddress;
    const proxies = items.proxies;
    calls.push(...createCalls(tokens, cohortId));
    if (proxies && proxies[0] !== undefined) {
      for (var k = 0; k < proxies.length; k++) {
        calls.push(...createCalls(tokens, proxies[k]));
      }
    }
  }
  return calls;
};

module.exports = {
  createMulticalls,
  getCohortTokensByChainName,
  getCohortsAndProxiesByChain,
};

'''
'''--- projects/helper/unknownTokens.js ---

const sdk = require('@defillama/sdk');
const symbol = require('./abis/symbol.json')
const token0 = require('./abis/token0.json');
const token1 = require('./abis/token1.json');
const masterchefAbi = require('./abis/masterchef.json')
const getReserves = require('./abis/getReserves.json');
const { getChainTransform, stripTokenHeader, getFixBalances, } = require('./portedTokens')
const { requery, } = require('./getUsdUniTvl')
const { sumTokens, sumTokens2, } = require('./unwrapLPs')
const { isLP, getUniqueAddresses, DEBUG_MODE, sliceIntoChunks, sleep, log } = require('./utils')
const factoryAbi = require('./abis/factory.json');
const { default: BigNumber } = require('bignumber.js')

async function getLPData({
  block,
  chain = 'ethereum',
  lps = [], // list of token addresses (all need not be LPs, code checks and filters out non LPs)
  allLps = false,   // if set true, assumes all tokens provided as lps are lps and skips validation/filtering
}) {
  lps = getUniqueAddresses(lps)
  const pairAddresses = allLps ? lps : await getLPList(lps)
  const pairCalls = pairAddresses.map((pairAddress) => ({ target: pairAddress, }))
  let token0Addresses, token1Addresses, reserves

  [token0Addresses, token1Addresses, reserves] = await Promise.all([
    sdk.api.abi.multiCall({ abi: token0, chain, calls: pairCalls, block, }).then(({ output }) => output),
    sdk.api.abi.multiCall({ abi: token1, chain, calls: pairCalls, block, }).then(({ output }) => output),
  ]);
  await requery(token0Addresses, chain, block, token0);
  await requery(token1Addresses, chain, block, token1);
  const pairs = {};
  // add token0Addresses
  token0Addresses.forEach((token0Address) =>
    pairs[token0Address.input.target] = {
      token0Address: token0Address.output.toLowerCase(),
    }
  )
  token1Addresses.forEach((token1Address) => {
    if (!pairs[token1Address.input.target]) pairs[token1Address.input.target] = {}
    pairs[token1Address.input.target].token1Address = token1Address.output.toLowerCase()
  })
  return pairs

  async function getLPList(lps) {
    const callArgs = lps.map(t => ({ target: t }))
    let symbols = (await sdk.api.abi.multiCall({ calls: callArgs, abi: symbol, block, chain })).output
    symbols = symbols.filter(item => isLP(item.output, item.input.target, chain))
    // log(symbols.filter(item => item.output !== 'Cake-LP').map(i => `token: ${i.input.target} Symbol: ${i.output}`).join('\n'))
    log('LP symbols:', getUniqueAddresses(symbols.map(i => i.output)).join(', '))
    return symbols.map(item => item.input.target.toLowerCase())
  }
}

async function getLPList(lps, chain, block) {
  const callArgs = lps.map(t => ({ target: t }))
  let symbols = (await sdk.api.abi.multiCall({ calls: callArgs, abi: symbol, block, chain })).output
  symbols = symbols.filter(item => isLP(item.output, item.input.target, chain))
  // log(symbols.filter(item => item.output !== 'Cake-LP').map(i => `token: ${i.input.target} Symbol: ${i.output}`).join('\n'))
  log('LP symbols:', getUniqueAddresses(symbols.map(i => i.output)).join(', '))
  return symbols.map(item => item.input.target.toLowerCase())
}

async function getTokenPrices({
  block,
  chain = 'ethereum',
  coreAssets = [],  // list of tokens that can used as base token to price unknown tokens against (Note: order matters, is there are two LPs for a token, the core asset with a lower index is used)
  blacklist = [],   // list of tokens to ignore/blacklist
  whitelist = [],   // if set, tvl/price is computed only for these tokens
  lps = [], // list of token addresses (all need not be LPs, code checks and filters out non LPs)
  transformAddress, // function for transforming token address to coingecko friendly format
  allLps = false,   // if set true, assumes all tokens provided as lps are lps and skips validation/filtering
  minLPRatio = 0.5, // if a token pool has less that this percent of core asset tokens compared to a token pool with max tokens for a given core asset, this token pool is not used for price calculation
  restrictTokenPrice = false, // if enabled, while computed tvl, an unknown token value can max 
  log_coreAssetPrices = [],
  log_minTokenValue = 1e6 // log only if token value is higer than this value, now minimum is set as 1 million
}) {
  let counter = 0
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)

  coreAssets = coreAssets.map(i => i.toLowerCase())
  blacklist = blacklist.map(i => i.toLowerCase())
  whitelist = whitelist.map(i => i.toLowerCase())
  lps = getUniqueAddresses(lps)
  const pairAddresses = allLps ? lps : await getLPList(lps, chain, block)
  const pairCalls = pairAddresses.map((pairAddress) => ({ target: pairAddress, }))

  let token0Addresses, token1Addresses, reserves

  [token0Addresses, token1Addresses, reserves] = await Promise.all([
    sdk.api.abi.multiCall({ abi: token0, chain, calls: pairCalls, block, }).then(({ output }) => output),
    sdk.api.abi.multiCall({ abi: token1, chain, calls: pairCalls, block, }).then(({ output }) => output),
    sdk.api.abi.multiCall({ abi: getReserves, chain, calls: pairCalls, block, }).then(({ output }) => output),
  ]);
  await requery(token0Addresses, chain, block, token0);
  await requery(token1Addresses, chain, block, token1);
  await requery(reserves, chain, block, getReserves);

  const pairs = {};
  // add token0Addresses
  token0Addresses.forEach((token0Address) => {
    const tokenAddress = token0Address.output.toLowerCase();

    const pairAddress = token0Address.input.target.toLowerCase();
    pairs[pairAddress] = {
      token0Address: tokenAddress,
    }
  });

  // add token1Addresses
  token1Addresses.forEach((token1Address) => {
    const tokenAddress = token1Address.output.toLowerCase();
    const pairAddress = token1Address.input.target.toLowerCase();
    pairs[pairAddress] = {
      ...(pairs[pairAddress] || {}),
      token1Address: tokenAddress,
    }
  });

  const prices = {}
  const pairBalances = {}

  for (let i = 0; i < reserves.length; i++) {
    const pairAddress = reserves[i].input.target.toLowerCase();
    const pair = pairs[pairAddress];
    pairBalances[pairAddress] = {}
    const token0Address = pair.token0Address.toLowerCase()
    const token1Address = pair.token1Address.toLowerCase()
    const reserveAmounts = reserves[i].output
    if (coreAssets.includes(token0Address) && coreAssets.includes(token1Address)) {
      sdk.util.sumSingleBalance(pairBalances[pairAddress], token0Address, Number(reserveAmounts[0]))
      sdk.util.sumSingleBalance(pairBalances[pairAddress], token1Address, Number(reserveAmounts[1]))
    } else if (coreAssets.includes(token0Address)) {
      sdk.util.sumSingleBalance(pairBalances[pairAddress], token0Address, Number(reserveAmounts[0]) * 2)
      if (!blacklist.includes(token1Address) && (!whitelist.length || whitelist.includes(token1Address))) {
        setPrice(prices, token1Address, reserveAmounts[0], reserveAmounts[1], token0Address)
      }
    } else if (coreAssets.includes(token1Address)) {
      if (!reserveAmounts) console.log('missing reserves', pairAddress)
      sdk.util.sumSingleBalance(pairBalances[pairAddress], token1Address, Number(reserveAmounts[1]) * 2)
      if (!blacklist.includes(token0Address) && (!whitelist.length || whitelist.includes(token0Address))) {
        setPrice(prices, token0Address, reserveAmounts[1], reserveAmounts[0], token1Address)
      }
    } else {
      const isWhitelistedToken0 = !blacklist.includes(token0Address)
      const isWhitelistedToken1 = !blacklist.includes(token1Address)
      if (isWhitelistedToken0 && isWhitelistedToken1) {
        sdk.util.sumSingleBalance(pairBalances[pairAddress], token0Address, Number(reserveAmounts[0]))
        sdk.util.sumSingleBalance(pairBalances[pairAddress], token1Address, Number(reserveAmounts[1]))
      } else if (isWhitelistedToken0) {
        sdk.util.sumSingleBalance(pairBalances[pairAddress], token0Address, Number(reserveAmounts[0]) * 2)
      } else if (isWhitelistedToken1) {
        sdk.util.sumSingleBalance(pairBalances[pairAddress], token1Address, Number(reserveAmounts[1]) * 2)
      }
    }
  }

  filterPrices(prices)
  const balances = {}
  Object.keys(pairBalances).forEach(key => addBalances(pairBalances[key], balances, { pairAddress: key }))
  const fixBalances = await getFixBalances(chain)
  fixBalances(balances)

  return {
    pairs,
    updateBalances,
    pairBalances,
    prices,
    balances,
  }

  function setPrice(prices, address, coreAmount, tokenAmount, coreAsset) {
    if (prices[address] !== undefined) {
      const currentCoreAmount = prices[address][0]
      const currentCoreAsset = prices[address][2]
      // core asset higher on the list has higher preference
      if (coreAssets.indexOf(currentCoreAmount) < coreAssets.indexOf(coreAsset)) return;
      if ((currentCoreAsset === coreAsset) && coreAmount < currentCoreAmount) return;
    }
    if (Number(tokenAmount) > 0)
      prices[address] = [Number(coreAmount), Number(coreAmount) / Number(tokenAmount), coreAsset, +Number(tokenAmount)]
  }

  function getAssetPrice(asset) {
    const assetIndex = coreAssets.indexOf(asset.toLowerCase())
    if (assetIndex === -1 || !log_coreAssetPrices[assetIndex]) return 1 / 1e18
    return log_coreAssetPrices[assetIndex]
  }

  async function updateBalances(balances, { resolveLP = true, skipConversion = false, onlyLPs = false, } = {}) {
    let lpAddresses = []  // if some of the tokens in balances are LP tokens, we resolve those as well
    log('---updating balances-----')
    const finalBalances = onlyLPs ? {} : balances
    counter = 0
    Object.entries(balances).forEach(([address, amount = 0]) => {
      const token = stripTokenHeader(address)
      const price = prices[token];
      if (pairBalances[token]) {
        lpAddresses.push(token)
        return;
      }
      if (!price || skipConversion) return;
      let tokenAmount = price[1] * +amount
      const coreAsset = price[2]
      const tokensInLP = price[3]
      const coreTokenAmountInLP = price[0]
      if (restrictTokenPrice && +amount > tokensInLP) tokenAmount = coreTokenAmountInLP  // use token amount in pool if balances amount is higher than amount in pool
      if (DEBUG_MODE && tokenAmount * getAssetPrice(coreAsset) > log_minTokenValue)
        console.log(`[converting balances] token vaule (in millions): ${(tokenAmount * getAssetPrice(coreAsset) / 1e6).toFixed(4)}, token value higher than pool: ${+amount > +tokensInLP} token: ${token} counter: ${++counter}`)
      sdk.util.sumSingleBalance(balances, transformAddress(coreAsset), BigNumber(tokenAmount).toFixed(0))
      delete balances[address]
    })

    if (!resolveLP) return balances

    if (lpAddresses.length) {
      const totalBalances = (await sdk.api.abi.multiCall({
        abi: 'erc20:totalSupply', calls: lpAddresses.map(i => ({ target: i })), block, chain
      })).output

      totalBalances.forEach((item) => {
        const token = item.input.target
        const address = transformAddress(token)
        const ratio = +item.output > 0 ? (+(balances[address]) || 0) / +item.output : 0
        addBalances(pairBalances[token], finalBalances, { ratio, pairAddress: token, skipConversion, })
        delete balances[address]
      })
    }

    return finalBalances
  }

  function addBalances(balances, finalBalances, { skipConversion = false, pairAddress, ratio = 1 }) {
    if (ratio > 1) {
      console.log(`There is bug in the code. Pair address: ${pairAddress}, ratio: ${ratio}`)
      ratio = 1
    }
    Object.entries(balances).forEach(([address, amount = 0]) => {
      const price = prices[address];
      // const price =  undefined; // NOTE: this is disabled till, we add a safeguard to limit LP manipulation to inflate token price, like mimimum core asset liquidity to be 10k
      if (price && !skipConversion) {
        const coreTokenAmountInLP = price[0]
        const coreAsset = price[2]
        const tokensInLP = price[3]
        let tokenAmount = price[1] * +amount
        if (restrictTokenPrice && +amount > tokensInLP) tokenAmount = coreTokenAmountInLP
        if (DEBUG_MODE && tokenAmount * getAssetPrice(coreAsset) * ratio > log_minTokenValue)
          console.log(`[resolve LP balance] token vaule (in millions): ${(tokenAmount * getAssetPrice(coreAsset) * ratio / 1e6).toFixed(4)}, token value higher than pool: ${+amount > +tokensInLP} LP Address: ${pairAddress} token: ${address} ratio: ${ratio} counter: ${++counter}`)
        sdk.util.sumSingleBalance(finalBalances, transformAddress(coreAsset), BigNumber(tokenAmount * ratio).toFixed(0))
      } else {
        if ((DEBUG_MODE && coreAssets.includes(address)) && (+amount * getAssetPrice(address) * ratio > log_minTokenValue))
          console.log(`[resolve LP balance] token vaule (in millions): ${(+amount * getAssetPrice(address) * ratio / 1e6).toFixed(4)}, LP Address: ${pairAddress}  core token: ${address} ratio: ${ratio} counter: ${++counter}`)
        sdk.util.sumSingleBalance(finalBalances, transformAddress(address), BigNumber(+amount * ratio).toFixed(0))
      }
    })
  }

  // If we fetch prices from pools with low liquidity, the value of tokens can be absurdly high, so we set a threshold that if we are using a core asset to determine price,
  // the amount of said core asset in a pool from which price is fetched must be at least 0.5% of the amount of core asset tokens in pool with highest core asset tokens
  function filterPrices(prices) {
    const maxCoreTokens = {}
    Object.values(prices).forEach(([amount, _, coreAsset]) => {
      if (!maxCoreTokens[coreAsset] || maxCoreTokens[coreAsset] < +amount)
        maxCoreTokens[coreAsset] = +amount
    })

    Object.keys(prices).forEach(token => {
      const priceArry = prices[token]
      const [amount, _, coreAsset] = priceArry
      if (!maxCoreTokens[coreAsset]) throw new Error('there is bug in the code')
      const lpRatio = +amount * 100 / maxCoreTokens[coreAsset]
      if (lpRatio < minLPRatio) delete prices[token] // current pool has less than 0.5% of tokens compared to pool with highest number of core tokens
    })
  }
}

function getUniTVL({ chain = 'ethereum', coreAssets = [], blacklist = [], whitelist = [], factory, transformAddress, allowUndefinedBlock = true,
  minLPRatio = 1,
  log_coreAssetPrices = [], log_minTokenValue = 1e6,
  withMetaData = false,
  skipPair = [],
}) {
  return async (ts, _block, { [chain]: block }) => {
    let pairAddresses;
    const pairLength = (await sdk.api.abi.call({ target: factory, abi: factoryAbi.allPairsLength, chain, block })).output
    if (pairLength === null)
      throw new Error("allPairsLength() failed")

    log('No. of pairs: ', pairLength)

    let pairNums = Array.from(Array(Number(pairLength)).keys())
    if (skipPair.length) pairNums = pairNums.filter(i => !skipPair.includes(i))
    let pairs = (await sdk.api.abi.multiCall({ abi: factoryAbi.allPairs, chain, calls: pairNums.map(num => ({ target: factory, params: [num] })), block })).output
    await requery(pairs, chain, block, factoryAbi.allPairs);

    pairAddresses = pairs.map(result => result.output.toLowerCase())

    const response = await getTokenPrices({
      block, chain, coreAssets, blacklist, lps: pairAddresses, transformAddress, whitelist, allLps: true,
      minLPRatio, log_coreAssetPrices, log_minTokenValue,
    })
    return withMetaData ? response : response.balances
  }
}

function unknownTombs({ token, shares = [], rewardPool = [], masonry = [], lps, chain = "ethereum", coreAssets = [], }) {
  let getPrices

  if (!Array.isArray(shares) && typeof shares === 'string')
    shares = [shares]
  if (!Array.isArray(masonry) && typeof masonry === 'string')
    masonry = [masonry]
  if (!Array.isArray(rewardPool) && typeof rewardPool === 'string')
    rewardPool = [rewardPool]

  const pool2 = async (timestamp, _block, chainBlocks) => {
    let balances = {};
    const block = chainBlocks[chain]
    if (!getPrices)
      getPrices = getTokenPrices({ block, chain, lps, coreAssets, allLps: true })

    const { updateBalances } = await getPrices

    const tao = []
    lps.forEach(token => rewardPool.forEach(owner => tao.push([token, owner])))

    await sumTokens(balances, tao, block, chain, undefined, { resolveLP: true })
    await updateBalances(balances)
    return balances
  }

  const staking = async (timestamp, _block, chainBlocks) => {
    let balances = {};
    const block = chainBlocks[chain]
    if (!getPrices)
      getPrices = getTokenPrices({ block, chain, lps, coreAssets, allLps: true })

    const { updateBalances } = await getPrices

    const tao = []
    shares.forEach(token => masonry.forEach(owner => tao.push([token, owner])))

    await sumTokens(balances, tao, block, chain)
    await updateBalances(balances)
    return balances
  }

  return {
    [chain === "avax" ? "avalanche" : chain]: {
      tvl: async () => ({}),
      staking,
      pool2
    }
  }

}

function pool2({ stakingContract, lpToken, chain = "ethereum", transformAddress, coreAsset }) {
  return async (_timestamp, _ethBlock, chainBlocks) => {
    const block = chainBlocks[chain]
    if (!transformAddress)
      transformAddress = await getChainTransform(chain)

    const balances = await sumTokens({}, [[lpToken, stakingContract]], block, chain, transformAddress, { resolveLP: true })
    const { updateBalances } = await getTokenPrices({ block, chain, transformAddress, coreAssets: [coreAsset], lps: [lpToken], allLps: true, })

    await updateBalances(balances, { resolveLP: false, })
    const fixBalances = await getFixBalances(chain)
    fixBalances(balances)
    return balances
  }
}

async function vestingHelper({
  coreAssets, owner, tokens, chain = 'ethereum', block, restrictTokenPrice = true, blacklist = [], skipConversion = false, onlyLPs, minLPRatio,
  log_coreAssetPrices = [], log_minTokenValue = 1e6,
}) {
  tokens = getUniqueAddresses(tokens)
  blacklist = getUniqueAddresses(blacklist)
  tokens = tokens.filter(t => !blacklist.includes(t))
  const chunks = sliceIntoChunks(tokens, 2000)
  const finalBalances = {}
  for (let i = 0; i < chunks.length; i++) {
    log('resolving for %s/%s of total tokens: %s (chain: %s)', i + 1, chunks.length, tokens.length, chain)
    let lps = await getLPList(chunks[i], chain, block)  // we count only LP tokens for vesting protocols
    const balances = await sumTokens2({ chain, block, owner, tokens: lps })
    const lpBalances = {}
    Object.entries(balances).forEach(([token, bal]) => {
      if (bal && bal !== 0)
        lpBalances[stripTokenHeader(token)] = bal
      else
        delete balances[token]
    })
    lps = lps.filter(lp => lpBalances[lp])  // we only care about LPs that are still locked in the protocol, we can ignore withdrawn LPs
    const { updateBalances } = await getTokenPrices({ coreAssets, lps, allLps: true, chain, block, restrictTokenPrice, blacklist, log_coreAssetPrices, log_minTokenValue, minLPRatio })
    await updateBalances(balances, { skipConversion, onlyLPs })
    Object.entries(balances).forEach(([token, bal]) => sdk.util.sumSingleBalance(finalBalances, token, bal))
    if (i !== 0 && i % 2 === 0) await sleep(3000)
  }
  const fixBalances = await getFixBalances(chain)
  fixBalances(finalBalances)
  return finalBalances
}

async function sumUnknownTokens({ tokensAndOwners = [],
  coreAssets, owner, tokens, chain = 'ethereum', block, restrictTokenPrice = true, blacklist = [], skipConversion = false, onlyLPs, minLPRatio,
  log_coreAssetPrices = [], log_minTokenValue = 1e6, owners = [], lps = [],
}) {
  blacklist = getUniqueAddresses(blacklist)
  if (!tokensAndOwners.length)
    if (owners.length)
      tokensAndOwners = owners.map(o => tokens.map(t => [t, o])).flat()
    else if (owner)
      tokensAndOwners = tokens.map(t => [t, owner])
  tokensAndOwners = tokensAndOwners.filter(t => !blacklist.includes(t[0]))
  const balances = await sumTokens2({ chain, block, tokensAndOwners })
  const { updateBalances, } = await getTokenPrices({ coreAssets, lps: [...tokensAndOwners.map(t => t[0]), ...lps,], chain, block, restrictTokenPrice, blacklist, log_coreAssetPrices, log_minTokenValue, minLPRatio })
  await updateBalances(balances, { skipConversion, onlyLPs })
  const fixBalances = await getFixBalances(chain)
  fixBalances(balances)
  return balances
}

function staking({ tokensAndOwners = [],
  coreAssets, owner, tokens, chain = 'ethereum', restrictTokenPrice = true, blacklist = [], skipConversion = false, onlyLPs, minLPRatio,
  log_coreAssetPrices = [], log_minTokenValue = 1e6, owners = [], lps = [],
}) {
  blacklist = getUniqueAddresses(blacklist)
  if (!tokensAndOwners.length)
    if (owners.length)
      tokensAndOwners = owners.map(o => tokens.map(t => [t, o])).flat()
    else if (owner)
      tokensAndOwners = tokens.map(t => [t, owner])
  tokensAndOwners = tokensAndOwners.filter(t => !blacklist.includes(t[0]))

  return async (_, _b, { [chain]: block }) => {
    const balances = await sumTokens2({ chain, block, tokensAndOwners })
    const { updateBalances, pairBalances, prices, } = await getTokenPrices({ coreAssets, lps: [...tokensAndOwners.map(t => t[0]), ...lps,], chain, block, restrictTokenPrice, blacklist, log_coreAssetPrices, log_minTokenValue, minLPRatio })
    await updateBalances(balances, { skipConversion, onlyLPs })
    const fixBalances = await getFixBalances(chain)
    fixBalances(balances)
    return balances
  }
}

function masterchefExports({ chain, masterchef, coreAssets, nativeToken, poolInfoABI = masterchefAbi.poolInfo, poolLengthAbi = masterchefAbi.poolLength, getToken = output => output.lpToken }) {
  let allTvl
  nativeToken = nativeToken.toLowerCase()

  async function getAllTVL(block) {
    if (!allTvl) allTvl = getTVL()
    return allTvl

    async function getTVL() {
      const transform = await getChainTransform(chain)
      const balances = {
        tvl: {},
        staking: {},
        pool2: {},
      }
      const { output: length } = await sdk.api.abi.call({
        target: masterchef,
        abi: poolLengthAbi,
        chain, block,
      })

      const calls = []
      for (let i = 0; i < length; i++) calls.push({ params: [i] })
      const { output: data } = await sdk.api.abi.multiCall({
        target: masterchef,
        abi: poolInfoABI,
        calls,
        chain, block,
      })

      const tokens = data.map(({ output }) => getToken(output).toLowerCase())
      const lps = [...tokens].filter(i => i !== nativeToken)
      const tempBalances = await sumTokens2({ chain, block, owner: masterchef, tokens, transformAddress: a => a.toLowerCase() })
      sdk.util.sumSingleBalance(balances.staking, transform(nativeToken), tempBalances[nativeToken])
      delete tempBalances[nativeToken]

      const pairs = await getLPData({ lps, chain, block })

      const { updateBalances, } = await getTokenPrices({ lps: Object.keys(pairs), allLps: true, coreAssets, block, chain, minLPRatio: 0.001 })
      Object.entries(tempBalances).forEach(([token, balance]) => {
        if (pairs[token]) {
          const { token0Address, token1Address } = pairs[token]
          if (nativeToken === token0Address || nativeToken === token1Address) {
            sdk.util.sumSingleBalance(balances.pool2, transform(token), balance)
            return;
          }
        }
        sdk.util.sumSingleBalance(balances.tvl, transform(token), balance)
      })

      await updateBalances(balances.tvl)
      await updateBalances(balances.pool2)
      await updateBalances(balances.staking)

      return balances
    }
  }

  async function tvl(_, _b, { [chain]: block }) {
    return (await getAllTVL(block)).tvl
  }

  async function pool2(_, _b, { [chain]: block }) {
    return (await getAllTVL(block)).pool2
  }

  async function staking(_, _b, { [chain]: block }) {
    return (await getAllTVL(block)).staking
  }

  return {
    [chain]: {
      tvl, pool2, staking
    }
  }
}

module.exports = {
  getTokenPrices,
  getUniTVL,
  unknownTombs,
  pool2,
  getLPData,
  masterchefExports,
  vestingHelper,
  getLPList,
  sumUnknownTokens,
  staking,
};
'''
'''--- projects/helper/unwrapLPs.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const token0 = require('./abis/token0.json')
const symbol = require('./abis/symbol.json')
const { getPoolTokens, getPoolId, bPool, getCurrentTokens, } = require('./abis/balancer.json')
const getPricePerShare = require('./abis/getPricePerShare.json')
const underlyingABI = require('./abis/underlying.json')
const { requery } = require('./requery')
const { getChainTransform, getFixBalances } = require('./portedTokens')
const creamAbi = require('./abis/cream.json')
const { unwrapCrv, resolveCrvTokens } = require('./resolveCrvTokens')
const activePoolAbi = require('./ankr/abis/activePool.json')
const wethAddressAbi = require('./ankr/abis/wethAddress.json');
const { isLP, DEBUG_MODE, getUniqueAddresses, } = require('./utils')
const wildCreditABI = require('../wildcredit/abi.json')

const yearnVaults = {
  // yvToken: underlying, eg yvYFI:YFI
  // ycDAI
  "0x99d1fa417f94dcd62bfe781a1213c092a47041bc": "0x6b175474e89094c44da98b954eedeac495271d0f",
  // ycUSDC
  "0x9777d7e2b60bb01759d0e2f8be2095df444cb07e": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // ycUSDT
  "0x1be5d71f2da660bfdee8012ddc58d024448a0a59": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // yDAI 
  "0xc2cb1040220768554cf699b0d863a3cd4324ce32": "0x6b175474e89094c44da98b954eedeac495271d0f",
  // yUSDT
  "0xe6354ed5bc4b393a5aad09f21c46e101e692d447": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // yUSDC
  "0xd6ad7a6750a7593e092a9b218d66c0a814a3436e": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // yUSDT
  "0x83f798e925bcd4017eb265844fddabb448f1707d": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // yvYFI v2
  "0xe14d13d8b3b85af791b2aadd661cdbd5e6097db1": "0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e",
  // yvWETH v2
  "0xa258c4606ca8206d8aa700ce2143d7db854d168c": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  // yvWETH v1
  "0xa9fe4601811213c340e850ea305481aff02f5b28": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  // yvUSDT v2
  "0x7da96a3891add058ada2e826306d812c638d87a7": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // yvUSDC v2
  "0x5f18c75abdae578b483e5f43f12a39cf75b973a9": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // yvUSDC
  "0xa354f35829ae975e850e23e9615b11da1b3dc4de": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // yvWBTC
  "0xa696a63cc78dffa1a63e9e50587c197387ff6c7e": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
  // yv1INCH
  "0xb8c3b7a2a618c552c23b1e4701109a9e756bab67": "0x111111111117dc0aa78b770fa6a738034120c302",
  // yvDAI
  "0x19d3364a399d251e894ac732651be8b0e4e85001": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  // yvDAI
  "0xacd43e627e64355f1861cec6d3a6688b31a6f952": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  // yvDAI
  "0xda816459f1ab5631232fe5e97a05bbbb94970c95": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  // yvDAI
  "0x16de59092dae5ccf4a1e6439d611fd0653f0bd01": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  // yvSNX
  "0xf29ae508698bdef169b89834f76704c3b205aedf": "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
  // yvUNI
  "0xfbeb78a723b8087fd2ea7ef1afec93d35e8bed42": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
  // yvLINK
  "0x671a912c10bba0cfa74cfc2d6fba9ba1ed9530b2": "0x514910771af9ca656af840dff83e8264ecf986ca",
  // yvCurve Aave 3pool
  "0x39caf13a104ff567f71fd2a4c68c026fdb6e740b": "0xFd2a8fA60Abd58Efe3EeE34dd494cD491dC14900",
  // yvcrvSTETH
  "0xdcd90c7f6324cfa40d7169ef80b12031770b4325": "0x06325440d014e39736583c165c2963ba99faf14e",
  // yvcrvIB
  "0x27b7b1ad7288079a66d12350c828d3c00a6f07d7": "0x5282a4ef67d9c33135340fb3289cc1711c13638c",
  // yvYFI FTM
  "0x2c850cced00ce2b14aa9d658b7cad5df659493db": "0x29b0Da86e484E1C0029B56e817912d778aC0EC69",
  // yvDAI FTM
  "0x637ec617c86d24e421328e6caea1d92114892439": "0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E",
  // yvETH FTM
  "0xce2fc0bdc18bd6a4d9a725791a3dee33f3a23bb7": "0x74b23882a30290451A17c44f4F05243b6b58C76d",
  // yvWBTC FTM
  "0xd817a100ab8a29fe3dbd925c2eb489d67f758da9": "0x321162Cd933E2Be498Cd2267a90534A804051b11",
  // yvMIM FTM
  "0x0a0b23d9786963de69cb2447dc125c49929419d8": "0x82f0b8b456c1a451378467398982d4834b6829c1",
  // yvUSDC FTM
  "0xef0210eb96c7eb36af8ed1c20306462764935607": "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
  // yvWFTM FTM
  "0x0dec85e74a92c52b7f708c4b10207d9560cefaf0": "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
  // yvUSDT FTM
  "0x148c05caf1bb09b5670f00d511718f733c54bc4c": "0x049d68029688eAbF473097a2fC38ef61633A3C7A"
}
async function unwrapYearn(balances, yToken, block, chain = "ethereum", transformAddress = (addr) => addr, fetchUnderlying) {
  let underlying = yearnVaults[yToken.toLowerCase()];
  if (!underlying) {
    if (!fetchUnderlying) return;
    const { output: _underlying } = await sdk.api.abi.call({
      target: yToken,
      abi: underlyingABI,
      chain, block,
    })
    underlying = _underlying
  }

  console.log('underinglin found', underlying)

  const tokenKey = chain == 'ethereum' ? yToken : `${chain}:${yToken}`
  if (!balances[tokenKey]) return;

  let pricePerShare
  let decimals
  try {
    pricePerShare = await sdk.api.abi.call({
      target: yToken,
      abi: getPricePerShare[1],
      block: block,
      chain: chain
    });
    decimals = (await sdk.api.erc20.decimals(underlying, chain)).output
  } catch (e) {
    console.log('Failing to get price per share for %s, trying getPricePerFullShare', yToken)
  }
  if (pricePerShare == undefined) {
    pricePerShare = await sdk.api.abi.call({
      target: yToken,
      abi: getPricePerShare[0],
      block: block,
      chain: chain
    });
    decimals = 18
  };

  const newBalance = BigNumber(balances[tokenKey]).times(pricePerShare.output).div(10 ** decimals)
  const oldBalance = BigNumber(balances[transformAddress(underlying)] || 0)
  balances[transformAddress(underlying)] = oldBalance.plus(newBalance).toFixed(0)
  delete balances[tokenKey];
};

const lpReservesAbi = { "constant": true, "inputs": [], "name": "getReserves", "outputs": [{ "internalType": "uint112", "name": "_reserve0", "type": "uint112" }, { "internalType": "uint112", "name": "_reserve1", "type": "uint112" }, { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }], "payable": false, "stateMutability": "view", "type": "function" }
const lpSuppliesAbi = { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }
const token0Abi = { "constant": true, "inputs": [], "name": "token0", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }
const token1Abi = { "constant": true, "inputs": [], "name": "token1", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }

/* lpPositions:{
    balance,
    token
}[]
*/
async function unwrapUniswapLPs(balances, lpPositions, block, chain = 'ethereum', transformAddress = (addr) => addr, excludeTokensRaw = [], retry = false, uni_type = 'standard',) {
  const excludeTokens = excludeTokensRaw.map(addr => addr.toLowerCase())
  const lpTokenCalls = lpPositions.map(lpPosition => ({
    target: lpPosition.token
  }))
  const lpReserves = sdk.api.abi.multiCall({
    block,
    abi: lpReservesAbi,
    calls: lpTokenCalls,
    chain
  })
  const lpSupplies = sdk.api.abi.multiCall({
    block,
    abi: lpSuppliesAbi,
    calls: lpTokenCalls,
    chain
  })
  const tokens0 = sdk.api.abi.multiCall({
    block,
    abi: token0Abi,
    calls: lpTokenCalls,
    chain
  })
  const tokens1 = sdk.api.abi.multiCall({
    block,
    abi: token1Abi,
    calls: lpTokenCalls,
    chain
  })
  if (retry) {
    await Promise.all([
      [lpReserves, lpReservesAbi],
      [lpSupplies, lpSuppliesAbi],
      [tokens0, token0Abi],
      [tokens1, token1Abi]
    ].map(async call => {
      await requery(await call[0], chain, block, call[1])
    }))
  }
  await Promise.all(lpPositions.map(async lpPosition => {
    try {
      let token0, token1, supply
      const lpToken = lpPosition.token
      const token0_ = (await tokens0).output.find(call => call.input.target === lpToken)
      const token1_ = (await tokens1).output.find(call => call.input.target === lpToken)
      const supply_ = (await lpSupplies).output.find(call => call.input.target === lpToken)

      token0 = token0_.output.toLowerCase()
      token1 = token1_.output.toLowerCase()
      supply = supply_.output
      // console.log(token0_, supply_, token1_, lpToken)

      if (supply === "0") {
        return
      }

      let _reserve0, _reserve1
      if (uni_type === 'standard') {
        ({ _reserve0, _reserve1 } = (await lpReserves).output.find(call => call.input.target === lpToken).output)
      }
      else if (uni_type === 'gelato') {
        const gelatoPools = sdk.api.abi.multiCall({
          block,
          abi: gelatoPoolsAbi,
          calls: lpTokenCalls,
          chain
        });
        const gelatoPool = (await gelatoPools).output.find(call => call.input.target === lpToken).output
        const [{ output: _reserve0_ }, { output: _reserve1_ }] = (await Promise.all([
          sdk.api.erc20.balanceOf({
            target: token0,
            owner: gelatoPool,
            block,
            chain
          })
          , sdk.api.erc20.balanceOf({
            target: token1,
            owner: gelatoPool,
            block,
            chain
          })
        ]))
        _reserve0 = _reserve0_
        _reserve1 = _reserve1_
      }

      if (!excludeTokens.includes(token0)) {
        const token0Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve0)).div(BigNumber(supply))
        sdk.util.sumSingleBalance(balances, await transformAddress(token0), token0Balance.toFixed(0))
      }
      if (!excludeTokens.includes(token1)) {
        const token1Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve1)).div(BigNumber(supply))
        sdk.util.sumSingleBalance(balances, await transformAddress(token1), token1Balance.toFixed(0))
      }
    } catch (e) {
      if (DEBUG_MODE) console.error(e)
      console.log(`Failed to get data for LP token at ${lpPosition.token} on chain ${chain}`)
      throw e
    }
  }))
}

// Mostly similar to unwrapGelatoLPs with only edits being gelatoToken0ABI, same for token1 and balances of tokens which are actually held by the contract which address is given by the read pool method
/* lpPositions:{
    balance,
    token
}[]
*/
const gelatoPoolsAbi = { "inputs": [], "name": "pool", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }

async function unwrapGelatoLPs(balances, lpPositions, block, chain = 'ethereum', transformAddress = (addr) => addr, excludeTokensRaw = [], retry = false) {
  const excludeTokens = excludeTokensRaw.map(addr => addr.toLowerCase())
  const lpTokenCalls = lpPositions.map(lpPosition => ({
    target: lpPosition.token
  }))
  const lpReserves = sdk.api.abi.multiCall({
    block,
    abi: lpReservesAbi,
    calls: lpTokenCalls,
    chain
  })
  const lpSupplies = sdk.api.abi.multiCall({
    block,
    abi: lpSuppliesAbi,
    calls: lpTokenCalls,
    chain
  })
  const tokens0 = sdk.api.abi.multiCall({
    block,
    abi: token0Abi,
    calls: lpTokenCalls,
    chain
  })
  const tokens1 = sdk.api.abi.multiCall({
    block,
    abi: token1Abi,
    calls: lpTokenCalls,
    chain
  })

  // Different bit
  if (retry) {
    await Promise.all([
      [lpReserves, lpReservesAbi],
      [lpSupplies, lpSuppliesAbi],
      [tokens0, token0Abi],
      [tokens1, token1Abi]
    ].map(async call => {
      await requery(await call[0], chain, block, call[1])
    }))
  }
  await Promise.all(lpPositions.map(async lpPosition => {
    try {
      const lpToken = lpPosition.token
      const token0 = (await tokens0).output.find(call => call.input.target === lpToken).output.toLowerCase()
      const token1 = (await tokens1).output.find(call => call.input.target === lpToken).output.toLowerCase()
      const supply = (await lpSupplies).output.find(call => call.input.target === lpToken).output

      // Different bits
      const gelatoPool = (await gelatoPools).output.find(call => call.input.target === lpToken).output
      const [{ output: _reserve0 }, { output: _reserve1 }] = (await Promise.all([
        sdk.api.erc20.balanceOf({
          target: token0,
          owner: gelatoPool,
          block,
          chain
        })
        , sdk.api.erc20.balanceOf({
          target: token1,
          owner: gelatoPool,
          block,
          chain
        })
      ]))

      if (!excludeTokens.includes(token0)) {
        const token0Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve0)).div(BigNumber(supply))
        sdk.util.sumSingleBalance(balances, await transformAddress(token0), token0Balance.toFixed(0))
      }
      if (!excludeTokens.includes(token1)) {
        const token1Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve1)).div(BigNumber(supply))
        sdk.util.sumSingleBalance(balances, await transformAddress(token1), token1Balance.toFixed(0))
      }
    } catch (e) {
      console.log(`Failed to get data for LP token at ${lpPosition.token} on chain ${chain}`)
      throw e
    }
  }))
}

// Unwrap the tokens that are LPs and directly add the others
// To be used when you don't know which tokens are LPs and which are not
async function addTokensAndLPs(balances, tokens, amounts, block, chain = "ethereum", transformAddress = id => id) {
  const tokens0 = await sdk.api.abi.multiCall({
    calls: tokens.output.map(t => ({
      target: t.output
    })),
    abi: token0,
    block,
    chain
  })
  const lpBalances = []
  tokens0.output.forEach((result, idx) => {
    const token = tokens.output[idx].output
    const balance = amounts.output[idx].output
    if (result.success) {
      lpBalances.push({
        token,
        balance
      })
    } else {
      sdk.util.sumSingleBalance(balances, transformAddress(token), balance);
    }
  })
  await unwrapUniswapLPs(balances, lpBalances, block, chain, transformAddress)
}

/*
tokens [
    [token, isLP] - eg ["0xaaa", true]
]
*/
async function sumTokensAndLPsSharedOwners(balances, tokens, owners, block, chain = "ethereum", transformAddress) {
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)
  const balanceOfTokens = await sdk.api.abi.multiCall({
    calls: tokens.map(t => owners.map(o => ({
      target: t[0],
      params: o
    }))).flat(),
    abi: 'erc20:balanceOf',
    block,
    chain
  })
  await requery(balanceOfTokens, chain, block, 'erc20:balanceOf')
  const isLP = {}
  tokens.forEach(token => {
    isLP[token[0].toLowerCase()] = token[1]
  })
  const lpBalances = []
  balanceOfTokens.output.forEach((result, idx) => {
    const token = result.input.target.toLowerCase()
    const balance = result.output
    if (isLP[token] === true) {
      lpBalances.push({
        token,
        balance
      })
    } else {
      sdk.util.sumSingleBalance(balances, transformAddress(token), balance);
    }
  })
  if (lpBalances.length > 0) {
    await unwrapUniswapLPs(balances, lpBalances, block, chain, transformAddress)
  }
}

async function sumTokensSharedOwners(balances, tokens, owners, block, chain = "ethereum", transformAddress) {
  if (transformAddress === undefined) {
    transformAddress = addr => `${chain}:${addr}`
  }
  await sumTokensAndLPsSharedOwners(balances, tokens.map(t => [t, false]), owners, block, chain, transformAddress)
}

async function sumLPWithOnlyOneToken(balances, lpToken, owner, listedToken, block, chain = "ethereum", transformAddress = id => id) {
  const [balanceOfLP, balanceOfTokenListedInLP, lpSupply] = await Promise.all([
    sdk.api.erc20.balanceOf({
      target: lpToken,
      owner,
      block,
      chain
    }),
    sdk.api.erc20.balanceOf({
      target: listedToken,
      owner: lpToken,
      block,
      chain
    }),
    sdk.api.erc20.totalSupply({
      target: lpToken,
      block,
      chain
    }),
  ])
  sdk.util.sumSingleBalance(balances, transformAddress(listedToken),
    BigNumber(balanceOfLP.output).times(balanceOfTokenListedInLP.output).div(lpSupply.output).times(2).toFixed(0)
  )
}

async function sumLPWithOnlyOneTokenOtherThanKnown(balances, lpToken, owner, tokenNotToUse, block, chain = "ethereum", transformAddress = id => id) {
  const [token0, token1] = await Promise.all([token0Abi, token1Abi]
    .map(abi => sdk.api.abi.call({
      target: lpToken,
      abi,
      chain,
      block
    }).then(o => o.output))
  )
  let listedToken = token0
  if (tokenNotToUse.toLowerCase() === listedToken.toLowerCase()) {
    listedToken = token1
  }
  await sumLPWithOnlyOneToken(balances, lpToken, owner, listedToken, block, chain, transformAddress)
}
async function unwrapUniswapV3NFTs({ balances = {}, nftsAndOwners = [], block, chain, transformAddress, owner, nftAddress, owners }) {
  if (!nftsAndOwners.length) {
    if (!nftAddress)
      switch (chain) {
        case 'ethereum':
        case 'polygon':
        case 'arbitrum': nftAddress = '0xC36442b4a4522E871399CD717aBDD847Ab11FE88'; break;
        default: throw new Error('missing default uniswap nft address')
      }

    if (!owners && owner)
      owners = [owner]
    nftsAndOwners = owners.map(o => [nftAddress, o])
  }
  await Promise.all(nftsAndOwners.map(([nftAddress, owner]) => unwrapUniswapV3NFT({ balances, owner, nftAddress, block, chain, transformAddress })))
  return balances
}

async function unwrapUniswapV3NFT({ balances, owner, nftAddress, block, chain = 'ethereum', transformAddress }) {
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)

  const nftPositions = (await sdk.api.erc20.balanceOf({ target: nftAddress, owner, block, chain })).output
  const factory = (await sdk.api.abi.call({ target: nftAddress, abi: wildCreditABI.factory, block, chain })).output

  const positionIds = (await sdk.api.abi.multiCall({
    block, chain, abi: wildCreditABI.tokenOfOwnerByIndex, target: nftAddress,
    calls: Array(Number(nftPositions)).fill(0).map((_, index) => ({ params: [owner, index] })),
  })).output.map(positionIdCall => positionIdCall.output)

  const positions = (await sdk.api.abi.multiCall({
    block, chain, abi: wildCreditABI.positions, target: nftAddress,
    calls: positionIds.map((position) => ({ params: [position] })),
  })).output.map(positionsCall => positionsCall.output)

  const lpInfo = {}
  positions.forEach(position => lpInfo[getKey(position)] = position)
  const lpInfoArray = Object.values(lpInfo)

  const poolInfos = (await sdk.api.abi.multiCall({
    block, chain, abi: wildCreditABI.getPool, target: factory,
    calls: lpInfoArray.map((info) => ({ params: [info.token0, info.token1, info.fee] })),
  })).output.map(positionsCall => positionsCall.output)

  const slot0 = await sdk.api.abi.multiCall({ block, chain, abi: wildCreditABI.slot0, calls: poolInfos.map(i => ({ target: i })) })

  slot0.output.forEach((slot, i) => lpInfoArray[i].tick = slot.output.tick)

  positions.map(addV3PositionBalances)
  return balances

  function getKey(position) {
    let { token0, token1, fee } = position
    token0 = token0.toLowerCase()
    token1 = token1.toLowerCase()
    return `${token0}-${token1}-${fee}`
  }

  function addV3PositionBalances(position) {
    const tickToPrice = (tick) => 1.0001 ** tick

    const token0 = position.token0
    const token1 = position.token1
    const liquidity = position.liquidity
    const bottomTick = +position.tickLower
    const topTick = +position.tickUpper
    const tick = +lpInfo[getKey(position)].tick
    const sa = tickToPrice(bottomTick / 2)
    const sb = tickToPrice(topTick / 2)

    let amount0 = 0
    let amount1 = 0

    if (tick < bottomTick) {
      amount0 = liquidity * (sb - sa) / (sa * sb)
    } else if (tick < topTick) {
      const price = tickToPrice(tick)
      const sp = price ** 0.5

      amount0 = liquidity * (sb - sp) / (sp * sb)
      amount1 = liquidity * (sp - sa)
    } else {
      amount1 = liquidity * (sb - sa)
    }

    sdk.util.sumSingleBalance(balances, transformAddress(token0), new BigNumber(amount0).toFixed(0))
    sdk.util.sumSingleBalance(balances, transformAddress(token1), new BigNumber(amount1).toFixed(0))
  }
}

/*
tokens [
    [token, owner, isLP] - eg ["0xaaa", "0xbbb", true]
]
*/
async function sumTokensAndLPs(balances, tokens, block, chain = "ethereum", transformAddress = id => id) {
  const balanceOfTokens = await sdk.api.abi.multiCall({
    calls: tokens.map(t => ({
      target: t[0],
      params: t[1]
    })),
    abi: 'erc20:balanceOf',
    block,
    chain
  })
  const lpBalances = []
  balanceOfTokens.output.forEach((result, idx) => {
    const token = result.input.target
    const balance = result.output
    if (tokens[idx][2]) {
      lpBalances.push({
        token,
        balance
      })
    } else {
      sdk.util.sumSingleBalance(balances, transformAddress(token), balance);
    }
  })
  await unwrapUniswapLPs(balances, lpBalances, block, chain, transformAddress)
}

const balancerVault = "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
async function sumBalancerLps(balances, tokensAndOwners, block, chain, transformAddress) {
  const poolIds = sdk.api.abi.multiCall({
    calls: tokensAndOwners.map(t => ({
      target: t[0]
    })),
    abi: getPoolId,
    block,
    chain
  })
  const balancerPoolSupplies = sdk.api.abi.multiCall({
    calls: tokensAndOwners.map(t => ({
      target: t[0]
    })),
    abi: 'erc20:totalSupply',
    block,
    chain
  })
  const balanceOfTokens = sdk.api.abi.multiCall({
    calls: tokensAndOwners.map(t => ({
      target: t[0],
      params: t[1]
    })),
    abi: 'erc20:balanceOf',
    block,
    chain
  });
  const balancerPoolsPromise = sdk.api.abi.multiCall({
    calls: (await poolIds).output.map(o => ({
      target: balancerVault,
      params: o.output
    })),
    abi: getPoolTokens,
    block,
    chain
  })
  const [poolSupplies, tokenBalances, balancerPools] = await Promise.all([balancerPoolSupplies, balanceOfTokens, balancerPoolsPromise])
  tokenBalances.output.forEach((result, idx) => {
    const lpBalance = result.output
    const balancerPool = balancerPools.output[idx].output
    const supply = poolSupplies.output[idx].output
    balancerPool.tokens.forEach((token, tokenIndex) => {
      const tokensInPool = balancerPool.balances[tokenIndex]
      const underlyingBalance = BigNumber(tokensInPool).times(lpBalance).div(supply)
      sdk.util.sumSingleBalance(balances, transformAddress(token), underlyingBalance.toFixed(0));
    })
  })
}

const nullAddress = '0x0000000000000000000000000000000000000000'
const gasTokens = [nullAddress, '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee']
/*
tokensAndOwners [
    [token, owner] - eg ["0xaaa", "0xbbb"]
]
*/
async function sumTokens(balances = {}, tokensAndOwners, block, chain = "ethereum", transformAddress, { resolveCrv = false, resolveLP = false, resolveYearn = false, unwrapAll = false, blacklistedLPs = [], } = {}) {
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)

  let ethBalanceInputs = []

  tokensAndOwners = tokensAndOwners.filter(i => {
    const token = i[0].toLowerCase()
    if (token !== nullAddress && !gasTokens.includes(token))
      return true
    ethBalanceInputs.push(i[1])
    return false
  })

  ethBalanceInputs = getUniqueAddresses(ethBalanceInputs)

  if (ethBalanceInputs.length) {
    const { output: ethBalances } = await sdk.api.eth.getBalances({ targets: ethBalanceInputs, chain, block })
    ethBalances.forEach(({ balance }) => sdk.util.sumSingleBalance(balances, transformAddress(nullAddress), balance))
  }

  const balanceOfTokens = await sdk.api.abi.multiCall({
    calls: tokensAndOwners.map(t => ({
      target: t[0],
      params: t[1]
    })),
    abi: 'erc20:balanceOf',
    block,
    chain
  })
  balanceOfTokens.output.forEach((result, idx) => {
    const token = transformAddress(result.input.target)
    const balance = BigNumber(result.output)
    try {
      balances[token] = BigNumber(balances[token] || 0).plus(balance).toFixed(0)
    } catch (e) {
      console.log(token, balance, balances[token])
      throw e
    }
  })

  if (resolveLP || unwrapAll)
    await unwrapLPsAuto({ balances, block, chain, transformAddress, blacklistedLPs })

  if (resolveCrv || unwrapAll)
    await resolveCrvTokens(balances, block, chain, transformAddress)

  if (resolveYearn || unwrapAll) {
    await Promise.all(Object.keys(balances).map(token => unwrapYearn(balances, stripTokenHeader(token), block, chain, transformAddress)))
    await resolveCrvTokens(balances, block, chain, transformAddress)
  }

  if (['astar', 'harmony', 'kava', 'thundercore', 'klaytn', 'evmos'].includes(chain)) {
    const fixBalances = await getFixBalances(chain)
    fixBalances(balances)
  }

  return balances
}

async function unwrapCreamTokens(balances, tokensAndOwners, block, chain = "ethereum", transformAddress = id => id) {
  const [balanceOfTokens, exchangeRates, underlyingTokens] = await Promise.all([
    sdk.api.abi.multiCall({
      calls: tokensAndOwners.map(t => ({
        target: t[0],
        params: t[1]
      })),
      abi: 'erc20:balanceOf',
      block,
      chain
    }),
    sdk.api.abi.multiCall({
      calls: tokensAndOwners.map(t => ({
        target: t[0],
      })),
      abi: creamAbi.exchangeRateStored,
      block,
      chain
    }),
    sdk.api.abi.multiCall({
      calls: tokensAndOwners.map(t => ({
        target: t[0],
      })),
      abi: creamAbi.underlying,
      block,
      chain
    })
  ])
  balanceOfTokens.output.forEach((balanceCall, i) => {
    const underlying = underlyingTokens.output[i].output
    const balance = BigNumber(balanceCall.output).times(exchangeRates.output[i].output).div(1e18).toFixed(0)
    sdk.util.sumSingleBalance(balances, transformAddress(underlying), balance)
  })
}

const crv_abi = {
  "crvLP_coins": { "stateMutability": "view", "type": "function", "name": "coins", "inputs": [{ "name": "arg0", "type": "uint256" }], "outputs": [{ "name": "", "type": "address" }], "gas": 3123 }
}
const tokenToPoolMapping = {
  "0x3a283d9c08e8b55966afb64c515f5143cf907611": "0xb576491f1e6e5e62f1d8f26062ee822b40b0e0d4",
  "0xed4064f376cb8d68f770fb1ff088a3d0f3ff5c4d": "0x8301ae4fc9c624d1d396cbdaa1ed877821d7c511"
}
async function genericUnwrapCrv(balances, crvToken, lpBalance, block, chain) {
  const { output: resolvedCrvTotalSupply } = await sdk.api.erc20.totalSupply({
    target: crvToken,
    chain, block
  })

  // Get Curve LP token balances
  // A while-loop would need a try-catch because sending error when idx > tokens_count
  const { output: crv_symbol } = await sdk.api.abi.call({
    abi: 'erc20:symbol',
    target: crvToken,
    chain,
    block
  })

  const LP_tokens_count = ['3Crv'].includes(crv_symbol) ? 3 : 2
  const coins_indices = Array.from(Array(LP_tokens_count).keys())
  const coins = (await sdk.api.abi.multiCall({
    abi: crv_abi['crvLP_coins'],
    calls: coins_indices.map(i => ({ params: [i] })),
    target: tokenToPoolMapping[crvToken.toLowerCase()] || crvToken,
    chain,
    block
  })).output.map(c => c.output.toLowerCase())
  const crvLP_token_balances = await sdk.api.abi.multiCall({
    abi: 'erc20:balanceOf',
    calls: coins.map(c => ({
      target: c,
      params: tokenToPoolMapping[crvToken.toLowerCase()] || crvToken,
    })),
    chain,
    block
  })

  const transform = await getChainTransform(chain)
  const wrappedGasToken = transform('0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee')
  if (coins.includes(wrappedGasToken)) {
    const gasTokenBalance = (await sdk.api.eth.getBalance({
      target: tokenToPoolMapping[crvToken.toLowerCase()] || crvToken,
      block,
      chain
    })).output
    crvLP_token_balances.output.push({
      output: gasTokenBalance,
      input: {
        target: wrappedGasToken
      },
      success: true
    })
  }

  // Edit the balances to weigh with respect to the wallet holdings of the crv LP token
  crvLP_token_balances.output.forEach(call =>
    call.output = BigNumber(call.output).times(lpBalance).div(resolvedCrvTotalSupply).toFixed(0)
  )
  sdk.util.sumMultiBalanceOf(balances, crvLP_token_balances);
}

const cvx_abi = {
  "cvxBRP_pid": { "inputs": [], "name": "pid", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
  "cvxBRP_balanceOf": { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
  "cvxBRP_earned": { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "earned", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
  "cvxBRP_rewards": { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "rewards", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
  "cvxBRP_userRewardPerTokenPaid": { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "userRewardPerTokenPaid", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
  "cvxBRP_stakingToken": { "inputs": [], "name": "stakingToken", "outputs": [{ "internalType": "address", "name": "stakingToken", "type": "address" }], "stateMutability": "view", "type": "function" },
  "cvxBooster_poolInfo": { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "poolInfo", "outputs": [{ "internalType": "address", "name": "lptoken", "type": "address" }, { "internalType": "address", "name": "token", "type": "address" }, { "internalType": "address", "name": "gauge", "type": "address" }, { "internalType": "address", "name": "crvRewards", "type": "address" }, { "internalType": "address", "name": "stash", "type": "address" }, { "internalType": "bool", "name": "shutdown", "type": "bool" }], "stateMutability": "view", "type": "function" }
}
const cvxBoosterAddress = "0xF403C135812408BFbE8713b5A23a04b3D48AAE31";
async function genericUnwrapCvx(balances, holder, cvx_BaseRewardPool, block, chain) {
  // Compute the balance of the treasury of the CVX position and unwrap
  const [
    { output: cvx_LP_bal },
    { output: pool_id }
  ] = await Promise.all([
    sdk.api.abi.call({
      abi: cvx_abi['cvxBRP_balanceOf'], // cvx_balanceOf cvx_earned cvx_rewards cvx_userRewardPerTokenPaid
      target: cvx_BaseRewardPool,
      params: [holder],
      chain, block
    }),
    // const {output: pool_id} = await 
    sdk.api.abi.call({
      abi: cvx_abi['cvxBRP_pid'],
      target: cvx_BaseRewardPool,
      chain, block
    })
  ])
  const { output: crvPoolInfo } = await sdk.api.abi.call({
    abi: cvx_abi['cvxBooster_poolInfo'],
    target: cvxBoosterAddress,
    params: [pool_id],
    chain,
    block: block,
  })
  await genericUnwrapCrv(balances, crvPoolInfo.lptoken, cvx_LP_bal, block, chain)
}

async function unwrapLPsAuto({ balances, block, chain = "ethereum", transformAddress, excludePool2 = false, onlyPool2 = false, pool2Tokens = [], blacklistedLPs = [] }) {
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)

  pool2Tokens = pool2Tokens.map(token => token.toLowerCase())
  blacklistedLPs = blacklistedLPs.map(token => token.toLowerCase())
  const tokens = []
  const amounts = []

  Object.keys(balances).forEach(key => {
    if (chain === 'ethereum' && key.indexOf(':') > -1) return;  // token is transformed, probably not an LP
    if (chain !== 'ethereum' && !key.startsWith(chain + ':')) return;  // token is transformed, probably not an LP
    const token = stripTokenHeader(key)
    if (!/^0x/.test(token)) return;     // if token is not an eth address, we ignore it
    tokens.push({ output: token })
    amounts.push({ output: balances[key] })
    delete balances[key]
  })

  return _addTokensAndLPs(balances, tokens, amounts)

  async function _addTokensAndLPs(balances, tokens, amounts) {
    const symbols = (await sdk.api.abi.multiCall({
      calls: tokens.map(t => ({ target: t.output })), abi: symbol, block, chain
    })).output
    const lpBalances = []
    symbols.forEach(({ output }, idx) => {
      const token = tokens[idx].output
      const balance = amounts[idx].output
      if (isLP(output, token, chain) && !blacklistedLPs.includes(token.toLowerCase()))
        lpBalances.push({ token, balance })
      else
        sdk.util.sumSingleBalance(balances, transformAddress(token), balance);
    })
    await _unwrapUniswapLPs(balances, lpBalances)
    return balances
  }

  async function _unwrapUniswapLPs(balances, lpPositions) {
    const lpTokenCalls = lpPositions.map(lpPosition => ({ target: lpPosition.token }))
    const { output: lpReserves } = await sdk.api.abi.multiCall({ block, abi: lpReservesAbi, calls: lpTokenCalls, chain, })
    const { output: lpSupplies } = await sdk.api.abi.multiCall({ block, abi: lpSuppliesAbi, calls: lpTokenCalls, chain, })
    const { output: tokens0 } = await sdk.api.abi.multiCall({ block, abi: token0Abi, calls: lpTokenCalls, chain, })
    const { output: tokens1 } = await sdk.api.abi.multiCall({ block, abi: token1Abi, calls: lpTokenCalls, chain, })

    lpPositions.map(lpPosition => {
      try {
        let token0, token1, supply
        const lpToken = lpPosition.token
        const token0_ = tokens0.find(call => call.input.target === lpToken)
        const token1_ = tokens1.find(call => call.input.target === lpToken)
        const supply_ = lpSupplies.find(call => call.input.target === lpToken)
        try {
          token0 = token0_.output.toLowerCase()
          token1 = token1_.output.toLowerCase()
          supply = supply_.output
        } catch (e) {
          console.log('Unable to resolve LP: ', lpToken);
          throw e
        }

        if (excludePool2)
          if (pool2Tokens.includes(token0) || pool2Tokens.includes(token1)) return;

        if (onlyPool2)
          if (!pool2Tokens.includes(token0) && !pool2Tokens.includes(token1)) return;

        if (supply === "0") {
          return
        }

        let _reserve0, _reserve1
        let output = lpReserves.find(call => call.input.target === lpToken);
        _reserve0 = output.output._reserve0 || output.output.reserve0
        _reserve1 = output.output._reserve1 || output.output.reserve1

        const token0Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve0)).div(BigNumber(supply)).toFixed(0)
        const token1Balance = BigNumber(lpPosition.balance).times(BigNumber(_reserve1)).div(BigNumber(supply)).toFixed(0)
        sdk.util.sumSingleBalance(balances, transformAddress(token0), token0Balance)
        sdk.util.sumSingleBalance(balances, transformAddress(token1), token1Balance)
      } catch (e) {
        console.log(`Failed to get data for LP token at ${lpPosition.token} on chain ${chain}`)
        throw e
      }
    })
  }
}

function stripTokenHeader(token) {
  return token.indexOf(':') > -1 ? token.split(':')[1] : token
}

async function unwrapTroves({ balances = {}, chain = 'ethereum', block, troves = [], transformAddress }) {
  const troveCalls = troves.map(target => ({ target }))
  if (!transformAddress)
    transformAddress = await getChainTransform(chain)
  const [{ output: activePools }, { output: tokens }] = await Promise.all([
    sdk.api.abi.multiCall({
      block,
      abi: activePoolAbi,
      calls: troveCalls,
      chain
    }),
    sdk.api.abi.multiCall({
      block,
      abi: wethAddressAbi,
      calls: troveCalls,
      chain
    })
  ])

  const tokensAndOwners = []

  for (let i = 0; i < troves.length; i++) {
    tokensAndOwners.push([tokens[i].output, activePools[i].output])
  }

  await sumTokens(balances, tokensAndOwners, block, chain, transformAddress, { resolveCrv: true, resolveLP: true, resolveYearn: true })
  return balances
}

async function sumTokens2({
  balances = {},
  tokensAndOwners = [],
  tokens = [],
  owners = [],
  owner,
  block,
  chain = 'ethereum',
  transformAddress,
  resolveCrv = false,
  resolveLP = false,
  resolveYearn = false,
  unwrapAll = false,
  blacklistedLPs = [],
  blacklistedTokens = [],
}) {

  if (!tokensAndOwners.length) {
    tokens = getUniqueAddresses(tokens)
    owners = getUniqueAddresses(owners)
    if (owner) tokensAndOwners = tokens.map(t => [t, owner])
    if (owners.length) tokensAndOwners = tokens.map(t => owners.map(o => [t, o])).flat()
  }

  blacklistedTokens = blacklistedTokens.map(t => t.toLowerCase())
  tokensAndOwners = tokensAndOwners.map(([t, o]) => [t.toLowerCase(), o]).filter(([token]) => !blacklistedTokens.includes(token))

  return sumTokens(balances, tokensAndOwners, block, chain, transformAddress, { resolveCrv, resolveLP, resolveYearn, unwrapAll, blacklistedLPs })
}

async function unwrapBalancerToken({ chain, block, balancerToken, owner, balances = {} }) {
  const { output: lpTokens } = await sdk.api.erc20.balanceOf({ target: balancerToken, owner, chain, block, })
  const { output: lpSupply } = await sdk.api.erc20.totalSupply({ target: balancerToken, chain, block, })
  const { output: underlyingPool } = await sdk.api.abi.call({ target: balancerToken, abi: bPool, chain, block, })
  const { output: underlyingTokens } = await sdk.api.abi.call({ target: underlyingPool, abi: getCurrentTokens, chain, block, })

  const ratio = lpTokens / lpSupply
  const tempBalances = await sumTokens2({ owner: underlyingPool, tokens: underlyingTokens, chain, block, })
  for (const [token, value] of Object.entries(tempBalances)) {
    const newValue = BigNumber(value * ratio).toFixed(0)
    sdk.util.sumSingleBalance(balances, token, newValue)
  }

  return balances
}

module.exports = {
  unwrapYearn,
  unwrapCrv,
  unwrapUniswapLPs,
  unwrapUniswapV3NFTs,
  addTokensAndLPs,
  sumTokensAndLPsSharedOwners,
  sumTokensAndLPs,
  sumTokens,
  sumBalancerLps,
  unwrapCreamTokens,
  sumLPWithOnlyOneToken,
  sumTokensSharedOwners,
  sumLPWithOnlyOneTokenOtherThanKnown,
  unwrapGelatoLPs,
  genericUnwrapCrv,
  genericUnwrapCvx,
  unwrapLPsAuto,
  unwrapTroves,
  isLP,
  sumTokens2,
  unwrapBalancerToken,
}

'''
'''--- projects/helper/utils.js ---
const BigNumber = require("bignumber.js");
const retry = require('async-retry')
const axios = require("axios");
const sdk = require('@defillama/sdk')
const http = require('./http')
const erc20 = require('./abis/erc20.json')

async function returnBalance(token, address, block, chain) {
  const { output: decimals } = await sdk.api.erc20.decimals(token, chain)
  let { output: balance } = await sdk.api.erc20.balanceOf({ target: token, owner: address, chain, block })
  balance = await new BigNumber(balance).div(10 ** decimals).toFixed(2);
  return parseFloat(balance);
}

async function returnEthBalance(address) {
  const output = await sdk.api.eth.getBalance({ target: address })
  let ethAmount = await new BigNumber(output.output).div(10 ** 18).toFixed(2);
  return parseFloat(ethAmount);
}

async function getPrices(object) {
  var stringFetch = '';
  for (var key in object[0]) {
    if (object[0][key] != 'stable') {
      if (stringFetch.length > 0) {
        stringFetch = stringFetch + ',' + object[0][key];
      } else {
        stringFetch = object[0][key];
      }
    }
  }
  return fetchURL(`https://api.coingecko.com/api/v3/simple/price?ids=${stringFetch}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true`)
}

async function getPricesFromContract(object) {
  var contractFetch = ''
  for (var key in object) {
    if (object[key]) {
      if (contractFetch.length > 0) {
        contractFetch = contractFetch + ',' + object[key];
      } else {
        contractFetch = object[key];
      }
    }
  }
  return fetchURL(`https://api.coingecko.com/api/v3/simple/token_price/ethereum?contract_addresses=${contractFetch}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true`)
}

async function getPricesfromString(stringFeed) {
  return fetchURL(`https://api.coingecko.com/api/v3/simple/price?ids=${stringFeed}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true`)
}

async function fetchURL(url) {
  return retry(async bail => await axios.get(url), {
    retries: 3
  })
}

async function postURL(url, data) {
  return retry(async bail => await axios.post(url, data), {
    retries: 3
  })
}

function createIncrementArray(length) {
  const arr = []
  for (let i = 0; i < length; i++)
    arr.push(i)

  return arr
}

const LP_SYMBOLS = ['SLP', 'spLP', 'JLP', 'OLP', 'SCLP', 'DLP', 'MLP', 'MSLP', 'ULP', 'TLP', 'HMDX', 'YLP', 'SCNRLP', 'PGL', 'GREEN-V2', 'PNDA-V2', 'vTAROT', 'TETHYSLP', 'BAO-V2', 'DINO-V2', 'DFYNLP', 'LavaSwap', 'RLP', 'ZDEXLP', 'lawSWAPLP']
const blacklisted_LPS = [
  '0xb3dc4accfe37bd8b3c2744e9e687d252c9661bc7',
  '0xf146190e4d3a2b9abe8e16636118805c628b94fe',
  '0xCC8Fa225D80b9c7D42F96e9570156c65D6cAAa25',
  '0xaee4164c1ee46ed0bbc34790f1a3d1fc87796668',
].map(i => i.toLowerCase())

function isLP(symbol, token, chain) {
  // console.log(token, symbol, chain)
  if (!symbol) return false
  if (token && blacklisted_LPS.includes(token.toLowerCase())) return false
  if (chain === 'bsc' && ['OLP', 'DLP', 'MLP', 'LP'].includes(symbol)) return false
  if (chain === 'bsc' && ['WLP', 'FstLP', ].includes(symbol)) return true
  if (chain === 'ethereum' && ['SSLP'].includes(symbol)) return true
  if (chain === 'harmony' && ['HLP'].includes(symbol)) return true
  if (chain === 'songbird' && ['FLRX', 'OLP'].includes(symbol)) return true
  if (chain === 'metis' && ['NLP', 'ALP'].includes(symbol)) return true // Netswap/Agora LP Token
  if (['fantom', 'nova',].includes(chain) && ['NLT'].includes(symbol)) return true
  let label

  if (symbol.startsWith('ZLK-LP') || symbol.includes('DMM-LP') || (chain === 'avax' && 'DLP' === symbol))
    label = 'Blackisting this LP because of unsupported abi'

  if (label) {
    if (DEBUG_MODE) console.log(label, token, symbol)
    return false
  }

  const isLPRes = LP_SYMBOLS.includes(symbol) || /(UNI-V2|vAMM)/.test(symbol) || symbol.split(/\W+/).includes('LP')

  if (DEBUG_MODE && isLPRes && !['UNI-V2', 'Cake-LP'].includes(symbol))
    console.log(chain, symbol, token)

  return isLPRes
}

function mergeExports(...exportsArray) {
  exportsArray = exportsArray.flat()
  const exports = {}

  exportsArray.forEach(exportObj => {
    Object.keys(exportObj).forEach(key => {
      if (typeof exportObj[key] !== 'object') {
        exports[key] = exportObj[key]
        return;
      }
      Object.keys(exportObj[key]).forEach(key1 => addToExports(key, key1, exportObj[key][key1]))
    })
  })

  Object.keys(exports)
    .filter(chain => typeof exports[chain] === 'object')
    .forEach(chain => {
      const obj = exports[chain]
      Object.keys(obj).forEach(key => {
        if (obj[key].length > 1)
          obj[key] = sdk.util.sumChainTvls(obj[key])
        else
          obj[key] = obj[key][0]
      })
    })

  return exports

  function addToExports(chain, key, fn) {
    if (!exports[chain]) exports[chain] = {}
    if (!exports[chain][key]) exports[chain][key] = []
    exports[chain][key].push(fn)
  }
}

async function getBalance(chain, account) {
  switch (chain) {
    case 'bitcoin':
      return (await http.get(`https://chain.api.btc.com/v3/address/${account}`)).data.balance / 1e8
    default: throw new Error('Unsupported chain')
  }
}

function getUniqueAddresses(addresses) {
  const set = new Set()
  addresses.forEach(i => set.add(i.toLowerCase()))
  return [...set]
}

const DEBUG_MODE = !!process.env.LLAMA_DEBUG_MODE

function log(...args) {
  if (DEBUG_MODE) {
    console.log(...args);
  }
}

function sliceIntoChunks(arr, chunkSize = 100) {
  const res = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    const chunk = arr.slice(i, i + chunkSize);
    res.push(chunk);
  }
  return res;
}

async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function stripTokenHeader(token) {
  token = token.toLowerCase();
  return token.indexOf(":") > -1 ? token.split(":")[1] : token;
}

async function diplayUnknownTable({ tvlResults = {}, tvlBalances = {}, storedKey = 'ethereum', log = false, tableLabel = 'Unrecognized tokens' }) {
  if (!DEBUG_MODE && !log) return;
  const balances = {}
  Object.entries(tvlResults.tokenBalances).forEach(([label, balance]) => {
    if (!label.startsWith('UNKNOWN')) return;
    const token = label.split('(')[1].replace(')', '')
    balances[token] = +(+tvlBalances[token] / 1e18).toFixed(0)
    if (balances[token] === 0) delete balances[token]
  })

  return debugBalances({ balances, chain: storedKey, log, tableLabel })
}

async function debugBalances({ balances = {}, chain, log = false, tableLabel = '' }) {
  if (!DEBUG_MODE && !log) return;
  if (!Object.keys(balances).length) return;

  const labelMapping = {}
  const tokens = []
  const ethTokens = []
  Object.keys(balances).forEach(label => {
    const token = stripTokenHeader(label)
    if (!token.startsWith('0x')) return;
    if (!label.startsWith(chain))
      ethTokens.push(token)
    else
      tokens.push(token)
    labelMapping[label] = token
  })

  if (tokens.length > 100) {
    console.log('too many unknowns')
    return;
  }

  const { output: symbols } = await sdk.api.abi.multiCall({
    abi: 'erc20:symbol',
    calls: tokens.map(i => ({ target: i })),
    chain,
  })

  const { output: name } = await sdk.api.abi.multiCall({
    abi: erc20.name,
    calls: tokens.map(i => ({ target: i })),
    chain,
  })

  const { output: symbolsETH } = await sdk.api.abi.multiCall({
    abi: 'erc20:symbol',
    calls: ethTokens.map(i => ({ target: i })),
  })

  const { output: nameETH } = await sdk.api.abi.multiCall({
    abi: erc20.name,
    calls: ethTokens.map(i => ({ target: i })),
  })

  let symbolMapping = symbols.reduce((a, i) => ({ ...a, [i.input.target]: i.output }), {})
  let nameMapping = name.reduce((a, i) => ({ ...a, [i.input.target]: i.output }), {})
  symbolMapping = symbolsETH.reduce((a, i) => ({ ...a, [i.input.target]: i.output }), symbolMapping)
  nameMapping = nameETH.reduce((a, i) => ({ ...a, [i.input.target]: i.output }), nameMapping)
  const logObj = []
  Object.entries(balances).forEach(([label, balance]) => {
    let token = labelMapping[label]
    let name = token && nameMapping[token] || '-'
    let symbol = token && symbolMapping[token] || '-'
    logObj.push({ name, symbol, balance, label })
  })

  console.log('Balance table for [%s] %s', chain, tableLabel)
  console.table(logObj)
}

module.exports = {
  DEBUG_MODE,
  log,
  createIncrementArray,
  fetchURL,
  postURL,
  getPricesfromString,
  getPrices,
  returnBalance,
  returnEthBalance,
  getPricesFromContract,
  isLP,
  mergeExports,
  getBalance,
  getUniqueAddresses,
  sliceIntoChunks,
  sleep,
  debugBalances,
  stripTokenHeader,
  diplayUnknownTable,
}

'''
'''--- projects/helper/utils/enigma.js ---

const miscreant = require("miscreant");
const curve25519 = require("curve25519-js");
const { get } = require('../http')

// const crypto = require('node:crypto')  // -- can be used for node v16 and above
// const hkdf = require("js-crypto-hkdf") // -- needed for node v14 and below
const toBase64 = str => Buffer.from(str).toString('base64')
const fromBase64 = str => Buffer.from(str, 'base64')

const cryptoProvider = new miscreant.PolyfillCryptoProvider();
const hkdfSalt = Uint8Array.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x4b, 0xea, 0xd8, 0xdf, 0x69, 0x99, 0x08, 0x52, 0xc2, 0x02, 0xdb, 0x0e, 0x00, 0x97, 0xc1, 0xa1, 0x2e, 0xa6, 0x37, 0xd7, 0xe9, 0x6d,]);

class EnigmaUtils {
  constructor(apiUrl) {
    this.consensusIoPubKey = null; // cache
    this.apiUrl = apiUrl;
    this.seed = EnigmaUtils.GenerateNewSeed();
    const { privkey, pubkey } = EnigmaUtils.GenerateNewKeyPairFromSeed(this.seed);
    this.privkey = privkey;
    this.pubkey = pubkey;
  }
  static GenerateNewKeyPair() {
    return EnigmaUtils.GenerateNewKeyPairFromSeed(EnigmaUtils.GenerateNewSeed());
  }
  static GenerateNewSeed() {
    return new Uint8Array(Buffer.alloc(32, 0)) // We dont care about true random
  }
  static GenerateNewKeyPairFromSeed(seed) {
    const { private: privkey, public: pubkey } = curve25519.generateKeyPair(seed);
    return { privkey, pubkey };
  }
  async getConsensusIoPubKey() {
    if (this.consensusIoPubKey) return this.consensusIoPubKey
    if (!this.getKey) {
      this.getKey = get(this.apiUrl + "/reg/tx-key")
    }

    const { result: { TxKey }, } = await this.getKey
    this.consensusIoPubKey = fromBase64(TxKey);
    return this.consensusIoPubKey;
  }
  async getTxEncryptionKey(nonce) {
    // const consensusIoPubKey = await this.getConsensusIoPubKey();
    // const txEncryptionIkm = curve25519.sharedKey(this.privkey, consensusIoPubKey);
    // const txEncryptionKey = crypto.hkdfSync("sha256", Uint8Array.from([...txEncryptionIkm, ...nonce]), hkdfSalt, '', 32)
    // const { key: txEncryptionKey } = await hkdf.compute(Uint8Array.from([...txEncryptionIkm, ...nonce]), "SHA-256", 32, "", hkdfSalt)
    const txEncryptionKey = fakeKey
    return new Uint8Array(txEncryptionKey)
  }
  async encrypt(contractCodeHash, msg) {
    const nonce = new Uint8Array(Buffer.alloc(32, 0)) // We dont care about true random
    const txEncryptionKey = await this.getTxEncryptionKey(nonce);
    const siv = await miscreant.SIV.importKey(txEncryptionKey, "AES-SIV", cryptoProvider);
    const plaintext = toUtf8(contractCodeHash + JSON.stringify(msg));
    const ciphertext = await siv.seal(plaintext, [new Uint8Array()]);
    // ciphertext = nonce(32) || wallet_pubkey(32) || ciphertext
    return Uint8Array.from([...nonce, ...this.pubkey, ...ciphertext]);
  }
  async decrypt(ciphertext, nonce) {
    var _a;
    if (!((_a = ciphertext) === null || _a === void 0 ? void 0 : _a.length)) {
      return new Uint8Array();
    }
    const txEncryptionKey = await this.getTxEncryptionKey(nonce);
    //console.log(`decrypt tx encryption key: ${Encoding.toHex(txEncryptionKey)}`);
    const siv = await miscreant.SIV.importKey(txEncryptionKey, "AES-SIV", cryptoProvider);
    const plaintext = await siv.open(ciphertext, [new Uint8Array()]);
    return plaintext;
  }
  getPubkey() {
    return Promise.resolve(this.pubkey);
  }
}

function toUtf8(str) {
  return new TextEncoder().encode(str);
}

function fromUtf8(data) {
  return new TextDecoder("utf-8", { fatal: true }).decode(data);
}

function toHex(data) {
  let out = "";
  for (const byte of data) {
    out += ("0" + byte.toString(16)).slice(-2);
  }
  return out;
}

function fromHex(hexstring) {
  if (hexstring.length % 2 !== 0) {
    throw new Error("hex string length must be a multiple of 2");
  }
  const out = new Uint8Array(hexstring.length / 2);
  for (let i = 0; i < out.length; i++) {
    const j = 2 * i;
    const hexByteAsString = hexstring.slice(j, j + 2);
    if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
      throw new Error("hex string contains invalid characters");
    }
    out[i] = parseInt(hexByteAsString, 16);
  }
  return out;
}

EnigmaUtils.fromHex = fromHex
EnigmaUtils.toHex = toHex
EnigmaUtils.toUtf8 = toUtf8
EnigmaUtils.fromUtf8 = fromUtf8
EnigmaUtils.fromBase64 = fromBase64
EnigmaUtils.toBase64 = toBase64

module.exports = EnigmaUtils

const fakeKey = new Uint8Array([104, 52, 184, 163, 49, 137, 219, 71, 54, 99, 223, 160, 48, 83, 58, 92, 175, 118, 60, 103, 134, 11, 44, 191, 210, 206, 164, 120, 48, 100, 9, 130]).buffer
'''
'''--- projects/helper/utils/pact.js ---
const blake = require("blakejs")

function prepareExecCmd(pactCode, meta = mkMeta("", "", 0, 0, 0, 0), networkId) {
  const cmdJSON = {
    networkId,
    payload: {
      exec: {
        data: {},
        code: pactCode
      }
    },
    signers: [],
    meta,
    nonce: JSON.stringify(new Date().toISOString())
  };
  const cmd = JSON.stringify(cmdJSON);
  const sigs = attachSig(cmd);
  return mkSingleCmd(sigs, cmd);
}

/**
 * Makes a single command given signed data.
 * @param sigs {array} - array of signature objects, see 'sign'
 * @param cmd {string} - stringified JSON blob used to create hash
 * @return valid Pact API command for send or local use.
 */
function mkSingleCmd(sigs, cmd) {
  return {
    hash: sigs[0].hash,
    sigs: [],
    cmd
  };
}

function attachSig(msg) {
  var hshBin = hashBin(msg);
  var hsh = b64urlEncodeArr(hshBin);
  return [{ hash: hsh, sig: undefined }]
}

/**
 * Perform blake2b256 hashing.
 */
function hashBin(s) {
  return blake.blake2b(s, null, 32);
}

function b64urlEncodeArr(input) {
  return b64url.encode(uint8ArrayToStr(input));
}

function uint8ArrayToStr(a) {
  return String.fromCharCode.apply(null, new Uint16Array(a));
}

const b64url = (function () {

  'use strict';

  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error();
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  function base64UrlEncode(input) {
    var str = String(input);
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      // str.charAt (idx | 0) || (map = '=', idx % 1);
      str.charAt(idx | 0);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3 / 4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  }

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  function base64UrlDecode(input) {
    var str = (String(input)).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=
    if (str.length % 4 === 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = str.charAt(idx++); // eslint-disable-line no-cond-assign
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  }

  return { encode: base64UrlEncode, decode: base64UrlDecode };

})()

module.exports = {
  prepareExecCmd
}
'''
'''--- projects/helper/wavesAdapter.js ---
const {getApiTvl} = require('../helper/historicalApi')
const {fetchURL} = require('../helper/utils')

const MINUTE = 60*1000

function wavesAdapter(endpoint, calcTvl){
    return async (time) => {
        return getApiTvl(time, async()=>{
            const data = (await fetchURL(`${endpoint}?limit=1000&since=${time*1e3-10*MINUTE}`)).data
            const last = data[data.length-1]
            return calcTvl(last)
        }, async()=>{
            const data = (await fetchURL(`${endpoint}?limit=1000&since=${time*1e3-6*60*MINUTE}`)).data
            return data.map(item=>({
                date: item.createdAt/1e3,
                totalLiquidityUSD: calcTvl(item)
            }))
        })
    }
}

module.exports={
    wavesAdapter
}
'''
'''--- projects/helper/whitelistedExportKeys.json ---
[
  "tvl",
  "staking",
  "methodology",
  "pool2",
  "misrepresentedTokens",
  "fetch",
  "timetravel",
  "borrowed",
  "start",
  "masterchef",
  "doublecounted",
  "treasury",
  "hallmarks",
  "incentivized",
  "offers",
  "deadFrom",
  "broken",
  "ownTokens"
]
'''
'''--- projects/helper/zilliqa.js ---
const retry = require('../helper/retry')
const axios = require('axios')
const BigNumber = require('bignumber.js')

const ZILLIQA_API = 'https://api.zilliqa.com/' // Mainnet API

async function call(query) {
  return retry(async () => await axios.post(ZILLIQA_API, query))
}

function formQuery(args) {
  if (Array.isArray(args)) return args.map(formQuery)

  let {
    id,
    jsonrpc = '2.0',
    method = 'GetSmartContractSubState',
    params
  } = args

  if (!id) id = `${params[1]}-${params[0]}`

  return { id, jsonrpc, method, params, }
}

async function getContractState(contract, method, args = []) {
  if (contract.startsWith('0x')) contract = contract.slice(2)
  return call({
    params: [contract, method, ...args]
  })
}

async function getBalance(token, address) {
  if (token.startsWith('0x')) token = token.slice(2)
  const {
    data: {
      result: {
        balances
      }
    }
  } = await call(formQuery({
    params: [
      token,
      'balances',
      [address]
    ]
  }))
  return balances[address]
}

async function getZilliqaBalance(address) {
  if (address.startsWith('0x')) address = address.slice(2)
  const {
    data: {
      result: {
        balance
      }
    }
  } = await call(formQuery({ method: 'GetBalance', params: [address] }))
  return BigNumber(balance).shiftedBy(-1 * 12)
}

async function getBalances(tokens, addresses, balances = {}) {
  if (!Array.isArray(tokens)) tokens = [tokens]
  if (!Array.isArray(addresses)) addresses = [addresses]

  const query = tokens
    .map(token =>
      addresses.map(addr => formQuery({
        id: `${token}-${addr}`,
        params: [
          token.startsWith('0x') ? token.slice(2) : token,
          'balances',
          [addr]
        ]
      })
      )).flat()

  const {
    data
  } = await call(query)

  data.forEach((response) => {
    const { id, result } = response
    if (!result) return
    let token = id.split('-')[0]
    const tokenRef = TOKENS[token]
    let decimals = 0

    if (tokenRef && tokenRef.decimals)
      decimals = tokenRef.decimals

    if (tokenRef && tokenRef.coingeckoId)
      token = tokenRef.coingeckoId
    else
      token = `zilliqa:${token}`

    if (!balances[token])
      balances[token] = BigNumber(0)

    const balancesSum = Object.values(result.balances)
      .reduce((sum, i) => sum.plus(BigNumber(i).shiftedBy(decimals * -1)), BigNumber(0))

    balances[token] = balances[token].plus(balancesSum)
  })

  return balances
}

// taken from https://swap.xcadnetwork.com/_next/data/E6YkkwWJMYjzQhGDTm38j/pool-overview.json
const TOKENS = {
  '0x153feaddc48871108e286de3304b9597c817b456': {
    name: 'XCAD Token',
    symbol: 'XCAD',
    decimals: 18,
    contractAddress: '0x153feaddc48871108e286de3304b9597c817b456',
    coingeckoId: 'xcad-network'
  },
  '0x327082dd216ff625748b13e156b9d1a5d3dd41f2': {
    name: 'dXCAD Token',
    symbol: 'dXCAD',
    decimals: 18,
    contractAddress: '0x327082dd216ff625748b13e156b9d1a5d3dd41f2'
  },
  '0x818ca2e217e060ad17b7bd0124a483a1f66930a9': {
    name: 'Zilliqa-bridged USDT token',
    symbol: 'zUSDT',
    decimals: 6,
    contractAddress: '0x818ca2e217e060ad17b7bd0124a483a1f66930a9',
    coingeckoId: 'tether'
  },
  '0x201C44B426D85fB2c382563483140825Fd81b9b5': {
    name: 'Opulous',
    symbol: 'zOPUL',
    decimals: 18,
    contractAddress: '0x201C44B426D85fB2c382563483140825Fd81b9b5',
    coingeckoId: 'opulous'
  },
  '0x31bFa2054B7199F936733f9054DBCE259a3c335a': {
    name: 'Lunr Token',
    symbol: 'Lunr',
    decimals: 4,
    contractAddress: '0x31bFa2054B7199F936733f9054DBCE259a3c335a',
    coingeckoId: 'lunr-token',
  },
  '0x9945a0da3dc74e364da4ea96946c99336013eeb5': {
    name: 'Heroes Of Lowhelm',
    symbol: 'HOL',
    decimals: 5,
    contractAddress: '0x9945a0da3dc74e364da4ea96946c99336013eeb5'
  },
  '0xbf79e16872fad92c16810ddd2a7b9b6858c7b756': {
    name: 'CARBON Token',
    symbol: 'CARB',
    decimals: 8,
    contractAddress: '0xbf79e16872fad92c16810ddd2a7b9b6858c7b756',
    coingeckoId: 'carbon-labs'
  },
  '0x3a683fdc022b26d755c70e9ed7cfcc446658018b': {
    name: 'PackagePortal Token',
    symbol: 'PORT',
    decimals: 4,
    contractAddress: '0x3a683fdc022b26d755c70e9ed7cfcc446658018b',
    coingeckoId: 'packageportal',
  },
  '0x91228A48AEA4E4071B9C6444Eb08B021399CfF7c': {
    name: 'Unifees Token',
    symbol: 'FEES',
    decimals: 4,
    contractAddress: '0x91228A48AEA4E4071B9C6444Eb08B021399CfF7c',
    coingeckoId: 'unifees'
  },
  '0xa3eAFd5021F6B9c36fD02Ed58aa1d015F2238791': {
    name: 'ZILStream Token',
    symbol: 'STREAM',
    decimals: 8,
    contractAddress: '0xa3eAFd5021F6B9c36fD02Ed58aa1d015F2238791',
    coingeckoId: 'zilstream'
  },
  '0xa845C1034CD077bD8D32be0447239c7E4be6cb21': {
    name: 'Governance ZIL',
    symbol: 'gZIL',
    decimals: 15,
    contractAddress: '0xa845C1034CD077bD8D32be0447239c7E4be6cb21',
    coingeckoId: 'governance-zil'
  },
  '0xb393C898b3d261C362a4987CaE5a833232AA666E': {
    name: 'Score',
    symbol: 'SCO',
    decimals: 4,
    contractAddress: '0xb393C898b3d261C362a4987CaE5a833232AA666E',
    coingeckoId: 'score-token',
  },
  '0x173Ca6770Aa56EB00511Dac8e6E13B3D7f16a5a5': {
    name: 'XSGD',
    symbol: 'XSGD',
    decimals: 6,
    contractAddress: '0x173Ca6770Aa56EB00511Dac8e6E13B3D7f16a5a5',
    coingeckoId: 'xsgd',
  },
  '0xaCb721d989c095c64A24d16DfD23b08D738e2552': {
    name: 'REDChillies Token',
    symbol: 'REDC',
    decimals: 9,
    contractAddress: '0xaCb721d989c095c64A24d16DfD23b08D738e2552',
    coingeckoId: 'redchillies',
  },
  '0x75fA7D8BA6BEd4a68774c758A5e43Cfb6633D9d6': {
    name: 'Wrapped Bitcoin',
    symbol: 'zWBTC',
    decimals: 8,
    contractAddress: '0x75fA7D8BA6BEd4a68774c758A5e43Cfb6633D9d6',
    coingeckoId: 'bitcoin',
  },
  '0x2cA315F4329654614d1E8321f9C252921192c5f2': {
    name: 'Ethereum',
    symbol: 'zETH',
    decimals: 18,
    contractAddress: '0x2cA315F4329654614d1E8321f9C252921192c5f2',
    coingeckoId: 'ethereum'
  },
  '0x4268C34dA6Ad41a4cDeAa25cdEF6531Ed0c9a1A2': {
    name: 'BLOX',
    symbol: 'BLOX',
    decimals: 2,
    contractAddress: '0x4268C34dA6Ad41a4cDeAa25cdEF6531Ed0c9a1A2',
    coingeckoId: 'blox-token'
  },
  '0x2fc7167c3Baff89E2805Aef72636ccD98eE6Bbb2': {
    name: 'DeMons',
    symbol: 'DMZ',
    decimals: 18,
    contractAddress: '0x2fc7167c3Baff89E2805Aef72636ccD98eE6Bbb2'
  },
  '0x32339fa037f7ae1DfFF25e13c6451a80289D61F4': {
    name: 'Brokoli',
    symbol: 'zBRKL',
    decimals: 18,
    contractAddress: '0x32339fa037f7ae1DfFF25e13c6451a80289D61F4',
    coingeckoId: 'brokoli',
  },
  '0xC6Bb661eDA683BdC792b3e456A206a92cc3cB92e': {
    name: 'DUCKDUCK',
    symbol: 'DUCK',
    decimals: 2,
    contractAddress: '0xC6Bb661eDA683BdC792b3e456A206a92cc3cB92e',
    coingeckoId: 'duckduck-token',
  },
  '0x9bd504b1445fdb8f4a643453ec1459bb9a2f988a': {
    name: 'XIDR',
    symbol: 'XIDR',
    decimals: 6,
    contractAddress: '0x9bd504b1445fdb8f4a643453ec1459bb9a2f988a'
  },
  '0x54aE64e2092749fb8d25470ffc1d4D6A19c6f2Ab': {
    name: 'Okipad',
    symbol: 'Oki',
    decimals: 5,
    contractAddress: '0x54aE64e2092749fb8d25470ffc1d4D6A19c6f2Ab'
  },
  '0x083196549637fAf95C91EcCD157E60430e69E1A7': {
    name: 'Sparda Wallet',
    symbol: 'SPW',
    decimals: 4,
    contractAddress: '0x083196549637fAf95C91EcCD157E60430e69E1A7',
    coingeckoId: 'sparda-wallet',
  },
  '0x4306f921c982766810cf342775fd79aa2d0d0e24': {
    name: 'Wrapped ZIL',
    symbol: 'wZIL',
    decimals: 12,
    contractAddress: '0x4306f921c982766810cf342775fd79aa2d0d0e24',
    coingeckoId: 'zilliqa',
  },
}

module.exports = {
  call,
  formQuery,
  getContractState,
  getBalance,
  getZilliqaBalance,
  getBalances,
}
'''
'''--- projects/hermes-finance/index.js ---
const { staking } = require('../helper/staking');
const { pool2Exports } = require('../helper/pool2');

const hermes = "0xB15f02F9Da8CD1f99E9dd375F21dc96D25ddd82C";
const hermesShares = "0xfa4b6db72a650601e7bd50a0a9f537c9e98311b2";
const hShareRewardPool = "0xDDd0A62D8e5AFeccFB334e49D27a57713DD0fBcc";
const olympus = "0x02662d2079a3218275bdA1Adf812ab5e324a5b27";

const pool2LPs = [
    "0xc58cc1a0f29f1993d089681e4fa03c7f65df1325", // HERMES-WAVAX PGL
    "0xC132ff3813De33356C859979501fB212673e395e" // HSHARE-WAVAX PGL
]

module.exports = {
    avalanche: {
        tvl: async () => ({}),
        staking: staking(olympus, hermesShares, "avax"),
        pool2: pool2Exports(hShareRewardPool, pool2LPs, "avax")
    }
}
'''
'''--- projects/hermes-protocol/index.js ---
const {uniTvlExport} = require('../helper/calculateUniTvl.js')

module.exports = {
  metis:{
    tvl: uniTvlExport("0x633a093C9e94f64500FC8fCBB48e90dd52F6668F", "metis"),
  },
}

'''
'''--- projects/hermes/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accIrisPerShare",
        "type": "uint256"
      },
      {
        "internalType": "uint16",
        "name": "depositFeeBP",
        "type": "uint16"
      },
      {
        "internalType": "uint256",
        "name": "lpSupply",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balance": {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceof": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "token0": {
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "token1": {
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/hermes/index.js ---
const { getUniTVL, staking, } = require('../helper/unknownTokens')

module.exports = {
  timetravel: true,
  doublecounted: false,
  misrepresentedTokens: true,
  methodology:
    'We calculate liquidity on all pairs with data retreived from the "hermes-defi/hermes-graph" subgraph plus the total amount in dollars of our staking pools xHermes and sHermes.',
  harmony: {
    tvl: getUniTVL({
      factory: '0xfe5e54a8e28534fffe89b9cfddfd18d3a90b42ca',
      chain: 'harmony',
      coreAssets: [
        '0x985458e523db3d53125813ed68c274899e9dfab4',
        '0xcf664087a5bb0237a0bad6742852ec6c8d69a27a',
        '0x6983D1E6DEf3690C4d616b13597A09e6193EA013',
      ],
    }),
    staking: staking({
      owners: ['0x28a4e128f823b1b3168f82f64ea768569a25a37f', '0x8812420fb6e5d971c969ccef2275210ab8d014f0'],
      tokens: ['0xba4476a302f5bc1dc4053cf79106dc43455904a3'],
      chain: 'harmony',
      coreAssets: [
        '0x985458e523db3d53125813ed68c274899e9dfab4',
      ],
      lps: ['0x8604197eb7123888b551fe78a8828b895608d093'],
    }),
  },
};

'''
'''--- projects/hex/abi.json ---
{
    "globalInfo":{"constant":true,"inputs":[],"name":"globalInfo","outputs":[{"internalType":"uint256[13]","name":"","type":"uint256[13]"}],"payable":false,"stateMutability":"view","type":"function"}
}
'''
'''--- projects/hex/index.js ---
const sdk = require("@defillama/sdk")
const abi = require('./abi.json')

const HEX = "0x2b591e99afe9f32eaa6214f7b7629768c40eeb39"
async function staking(timestamp, block){
    const globalInfo = await sdk.api.abi.call({
        target: HEX,
        block,
        abi: abi.globalInfo
    })
    return {
        [HEX]: globalInfo.output[0]
    }
}

module.exports={
    ethereum:{
        staking,
        tvl: ()=>({})
    }
}
'''
'''--- projects/hexal/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasury = "0xC06A7e21289E35eA94cE67C0f7AfAD4e972117D8";
const stakingContract = "0x2f6A0D592f7F24D71c4EcA815c94d43AbE190fc3";
const hexal = "0x57612d60b415ad812da9a7cf5672084796a4ab81";
const treasuryTokens = [
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false],
    ["0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", false],
    ["0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", false],
    ["0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3", false],
    ["0x55d398326f99059ff775485246999027b3197955", false],
    ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false],
    ["0xc94364d0ffd3c015689f55e167ac359eb93c617e", true]
]

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "bsc", stakingContract, hexal, undefined, undefined, false)
}
'''
'''--- projects/hfione/abi.json ---
{
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/hfione/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs, sumTokens } = require("../helper/unwrapLPs");
const { transformHecoAddress } = require("../helper/portedTokens");

const vaults = [
  //HT Pool Vault
  "0x3bb01b3ffe14eb791445db60a5b9d35a1db5c58c",
  //USDT Pool Vault
  "0x787ca650e4d6f8f526e5de9f3a1dcca418c34357",
  //HUSD Pool Vault
  "0xf355df843d1e85b92a5906f5252de85477450bf2",
  //BTC Pool Vault
  "0x33a4aa4a56dc114d6244d5c1d19843da4cca1632",
  //ETH Pool Vault
  "0xb112F95e0DAcd611022d394a1D863574A4Ea1d55",
  //BCH Pool Vault
  "0xbd48D5EEF3d59189f1Ed79503B13d8D35a2412a0",
  //LTC Pool Vault
  "0xb759573EC1a528612FcDd8AE6E3d69683eA93832",
  //DOT Pool Vault
  "0x939D10Fd2B751Ff7604527f9Ec99B92A47AAf7F2",
  //HPT Pool Vault
  "0x1153dC180C03eEc583f1d6aaE54082E1D1b99B99",
  //HBO Pool Vault
  "0x989f969D439cbf923632448075fD536A437db08B",
  //HBO-USDT-LP Vault
  "0x1Fd4b2AaD6297f9699Ed3836B9468C3D5dDD7145",
  //HBO-BTC-LP Vault
  "0x1f472C2565a8Ee5959223E31fd2fcDBE57B922a5",
  //HBO-HT-LP Vault
  "0x4a8D5c4f37a35AFA55f9C20D3416EEC5eCf7888f",
  //HBO-HUSD-LP Vault
  "0x426742111B422668a58C30d4cE6E65fA164f3cd0",
  //HFIL Vault
  "0x526F373BF133D6F6A200d415ae29033bE4C7143a",
  //HPT_Plus Vault
  "0x197f2d0d6851A18033a33FB5579351fe7C809529",
  //UNI VAULT
  "0x2B4069be1fb5B1A0215a4D3f6AfEf749c6511Fa5",
  //AAVE VAULT
  "0x48959A255CCD22d9bb960811975364023444d2CD",
];

const daoObject = {
  dao5: '0xB4A4c8822650Feaa6501987ea3B3b13055919eCc',
  dao30: '0x1eab7995EAD7E1E1A8Cc0df6eE55ceCb42d47008',
  dao100: '0xaB00A0e5377FF7a6fb78a8F81fb500Fe499b8E0E',
  daov2_5: '0x3a74C61bc3CcAf6933DAB5E697D526021ac47d56',
  daov2_30: '0xF86A18720C83E22D2012F6E777e7A5D5D57B7Efb',
  daov2_100: '0x3f4E7EE1f2c1d602284bc9Aca69035d3Bf04f772'
}

const HFI = "0x98fc3b60ed4a504f588342a53746405e355f9347";
const chain = 'heco'

const hecoTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const block = chainBlocks[chain]
  const calls = vaults.map((vault) => ({ target: vault, }))

  // VAULTS Part
  const tokens = (
    await sdk.api.abi.multiCall({ abi: abi.token, calls, chain, block, })
  ).output.map((t) => t.output);

  const totalSupply = (
    await sdk.api.abi.multiCall({ abi: abi.totalSupply, calls, chain, block, })
  ).output.map((bt) => bt.output);

  const lpPositions = [];

  for (let index = 0; index < vaults.length; index++) {
    if (index >= 10 && index <= 13) {
      lpPositions.push({ token: tokens[index], balance: totalSupply[index], });
    } else {
      sdk.util.sumSingleBalance(balances, `heco:${tokens[index]}`, totalSupply[index]);
    }
  }

  const transformAddress = await transformHecoAddress();
  await unwrapUniswapLPs(balances, lpPositions, chainBlocks["heco"], "heco", transformAddress);

  return balances;
};

async function staking(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  const tokensAndOwners = Object.values(daoObject).map(o => [HFI, o])
  return sumTokens(undefined, tokensAndOwners, block, chain)
}

module.exports = {
  heco: {
    tvl: hecoTvl,
    staking,
  },
};

'''
'''--- projects/hodltree/index.js ---
const { calculateHodltreeBalancesEth, calculateHodltreeBalancesPolygon } = require("../helper/hodltree/calculateBalances");

module.exports = {
    methodology:
        `Flashloan pools: sum of all available liquidity
         Lend-borrow contracts: sum of tokens provided as collateral and tokens provided by lenders
         Elastic-Modules: sum of tokens provided by hedgers and amount of tokens to hedge
        `,
    timetravel: true,
    misrepresentedTokens: false,
    ethereum: {
        tvl: calculateHodltreeBalancesEth
    },
    polygon: {
        tvl: calculateHodltreeBalancesPolygon
    }
};
  
'''
'''--- projects/honeyswap/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
  misrepresentedTokens: true,
  xdai: {
    tvl: getUniTVL({
      chain: 'xdai',
      factory: '0xa818b4f111ccac7aa31d0bcc0806d64f2e0737d7',
      coreAssets: [
        '0xe91d153e0b41518a2ce8dd3d7944fa863463a97d', // wxdai
        '0x9c58bacc331c9aa871afd802db6379a98e80cedb', // GNO
        '0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1', // weth
      ],
      blacklist: [
        '0x4f4f9b8d5b4d0dc10506e5551b0513b61fd59e75', 
      ],
      log_minTokenValue: 1e5,
      log_coreAssetPrices: [
        1/1e18,
        197/1e18,
        1824/1e18,
      ]
    })
  },
  polygon: {
    tvl: getUniTVL({
      chain: 'polygon',
      factory: '0x03daa61d8007443a6584e3d8f85105096543c19c',
      coreAssets: [
        '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // wmatic
      ],
      blacklist: ['0x8db0a6d1b06950b4e81c4f67d1289fc7b9359c7f']
    })
  },
}
'''
'''--- projects/honkswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

const HONK = "0xF2d4D9c65C2d1080ac9e1895F6a32045741831Cd";
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04";
const FACTORY = "0x34D7ffF45108De08Ca9744aCdf2e8C50AAC1C73C";

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x34D7ffF45108De08Ca9744aCdf2e8C50AAC1C73C) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  smartbch: {
    tvl: calculateUsdUniTvl(
      FACTORY,
      "smartbch",
      WBCH,
      [HONK],
      "bitcoin-cash"
    )
  }
}

'''
'''--- projects/hop/index.js ---
const sdk = require('@defillama/sdk')
const { transformXdaiAddress, transformOptimismAddress } = require('../helper/portedTokens')
const { getBlock } = require('../helper/getBlock')
const { chainExports } = require('../helper/exports')
const { default: axios } = require('axios')
// node test.js projects/hop/index.js
const WETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
function chainTvl(chain) {
    return async (timestamp, ethBlock, chainBlocks) => {
        const balances = {}
        let transform = token => `${chain}:${token}`
        if (chain === "xdai") {
            transform = await transformXdaiAddress()
        } else if (chain === 'optimism') {
            transform = await transformOptimismAddress()
        }
        const block = await getBlock(timestamp, chain, chainBlocks)
        const tokens = await axios('https://raw.githubusercontent.com/hop-protocol/hop/develop/packages/core/build/addresses/mainnet.json')
        for (const tokenConstants of Object.values(tokens.data.bridges)) {
            const chainConstants = (chain == 'xdai' ? tokenConstants['gnosis'] : tokenConstants[chain])
            if (chainConstants === undefined) {
                continue
            }

            let token = chainConstants.l2CanonicalToken ?? chainConstants.l1CanonicalToken;
            let bridge = chainConstants.l2SaddleSwap ?? chainConstants.l1Bridge;
            let amount;
            if (token === "0x0000000000000000000000000000000000000000" && chain === "ethereum") {
                token = WETH
                amount = await sdk.api.eth.getBalance({
                    target: bridge,
                    block,
                    chain
                })
            } else {
                amount = await sdk.api.erc20.balanceOf({
                    target: token,
                    owner: bridge,
                    block,
                    chain
                })
            }
            sdk.util.sumSingleBalance(balances, transform(token), amount.output)
        }
        if (chain === "ethereum") {
            for (const bonder of Object.entries(tokens.data.bonders)) {
                const tokenName = bonder[0]
                let contractList = []
                for (let i of Object.values(bonder[1])) {
                    for (let j of Object.values(i)) {
                        if (contractList.includes(j.toLowerCase())) {
                            continue;
                        } else {
                            contractList.push(j.toLowerCase())
                        }
                    }
                }
                for (const contract of contractList) {
                    if (tokenName === "ETH") {
                        const amount = await sdk.api.eth.getBalance({
                            target: contract,
                            block,
                        })
                        sdk.util.sumSingleBalance(balances, WETH, amount.output)
                    } else {
                        const token = tokens.data.bridges[tokenName].ethereum.l1CanonicalToken
                        const amount = await sdk.api.erc20.balanceOf({
                            target: token,
                            owner: contract,
                            block,
                        })
                        sdk.util.sumSingleBalance(balances, token, amount.output)
                    }
                }
            }
        }
        return balances
    }
}

module.exports = chainExports(chainTvl, ['ethereum', 'xdai', 'polygon', 'optimism', 'arbitrum'])
'''
'''--- projects/horizon/collateral.js ---
const { request, gql } = require("graphql-request");

const graph_endpoint = 'https://api.thegraph.com/subgraphs/name/rout-horizon/bsc15-issuance'
const graphQuery = gql`
query get_tvl($block: Int) {
  snxholders(orderBy:collateral,orderDirection:desc,block: { number: $block },first:1000,skip:0, where: {initialDebtOwnership_gt: 0, debtEntryAtIndex_gt: 0}) {
    collateral
  }
}`

async function tvl(ts, _block, chainBlocks) {
    const block = chainBlocks.bsc
    const { snxholders } = await request(
        graph_endpoint,
        graphQuery,
        { block: block - 1000 }
    );

    var totalCollateral = 0;
    for (const { collateral } of snxholders) {
        totalCollateral += +collateral        // sum of every user's collateral
    }

    return { 'bsc:0xc0eff7749b125444953ef89682201fb8c6a917cd': totalCollateral * 10 ** 18 };
}

module.exports = {
    collateral: tvl
}
'''
'''--- projects/horizon/index.js ---
const sdk = require("@defillama/sdk");
const { staking, } = require("../helper/staking");
const { sumTokens } = require('../helper/unwrapLPs');
const { collateral } = require('./collateral.js');

const hzn_bnb_LP = '0xdc9a574b9b341d4a98ce29005b614e1e27430e74'

const tokenStaking = [
    {
        stakingToken: '0x0409633A72D846fc5BBe2f98D88564D35987904D',      // phbToken
        rewardToken: '0xc0eff7749b125444953ef89682201fb8c6a917cd',        // hzn
        stakingContract: '0xa1771DCfb7822C8853D7E64B86E58f7f1eB5e33E'      // stakingContract
    },
    {
        stakingToken: '0xc0eff7749b125444953ef89682201fb8c6a917cd',      // hzn
        rewardToken: '0xc0eff7749b125444953ef89682201fb8c6a917cd',        // hzn
        stakingContract: '0x67D5a94F444DF4bBA254645065a4137fc665Bf98'      // stakingContract
    },
]
const lpStaking = [
    {
        stakingLPToken: '0xdc9a574b9b341d4a98ce29005b614e1e27430e74',     // hzn-bnb
        rewardToken: '0xc0eff7749b125444953ef89682201fb8c6a917cd',        // hzn
        stakingContract: '0x84838d0AB37857fAd5979Fcf6BDDf8ddb1cC1dA8'     // stakingContract
    },
    {
        stakingLPToken: '0xc3bf4e0ea6b76c8edd838e14be2116c862c88bdf',     // zusd-busd
        rewardToken: '0xc0eff7749b125444953ef89682201fb8c6a917cd',        // hzn
        stakingContract: '0x5646aA2F9408C7c2eE1dC7db813C8B687A959a85'     // stakingContract
    }
]

async function calculateLPStaking(timestamp, _block, chainBlocks) {
    const block = chainBlocks.bsc
    const tokensAndOwners = lpStaking.map(lp => [lp.stakingLPToken, lp.stakingContract])
    const balances = {}
    await sumTokens(balances, tokensAndOwners, block, 'bsc', undefined, { resolveLP: true })
    return balances;
}

module.exports = {
    timetravel: true,
    misrepresentedTokens: false,
    methodology: 'Counts liquidty on the token staking and lp staking contracts',
    bsc: {
        tvl: collateral,
        staking: sdk.util.sumChainTvls([
            staking(tokenStaking[0].stakingContract, tokenStaking[0].stakingToken, "bsc"), 
            staking(tokenStaking[1].stakingContract, tokenStaking[1].stakingToken, "bsc"), 
        ]),
        pool2: calculateLPStaking
    },
};
'''
'''--- projects/hotfries/index.js ---
const {staking} = require('../helper/staking')

module.exports={
    bsc:{
        tvl: staking("0x849741B79bc1618b46CF9ec600E94E771DEde601", "0xe9e7cea3dedca5984780bafc599bd69add087d56", "bsc")
    }
}
'''
'''--- projects/hotpot-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const masterchef = "0x3BD6827d09a0aF02fe4B6688E16F6fAB8F14938e";
const token = "0x00438AE909739f750c5df58b222Fe0Bde900C210";

module.exports = {
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/hpdex/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
  misrepresentedTokens: true,
  methodology: "Factory address (0xE1d563BcFD4E2a5A9ce355CC8631421186521aAA) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  hpb: {
    tvl: getUniTVL({
      factory: "0xE1d563BcFD4E2a5A9ce355CC8631421186521aAA",
      chain: "hpb",
      coreAssets: ['0xBE05Ac1FB417c9EA435b37a9Cecd39Bc70359d31',]
    })
  }
};

'''
'''--- projects/hswap.js ---
const { uniTvlExport } = require("./helper/calculateUniTvl")

module.exports = {
    heco: {
        tvl: uniTvlExport('0x13D1EA691C8153F5bc9a491d41b927E2baF8A6b1', "heco")
    }
}
'''
'''--- projects/hubble/index.js ---
const axios = require("axios");
const BigNumber = require('bignumber.js');
const {toUSDTBalances} = require('../helper/balances');
const HUBBLE_API = "https://api.hubbleprotocol.io";

const client = axios.create({
  baseURL: HUBBLE_API,
});

async function tvl() {
  const metrics = await client.get("/metrics");
  const tvl = new BigNumber(metrics.data.totalValueLocked);
  const staking = new BigNumber(metrics.data.hbb.staked).multipliedBy( metrics.data.hbb.price);
  return toUSDTBalances(tvl.minus(staking));
}

async function staking() {
  const metrics = await client.get("/metrics");
  const value = new BigNumber(metrics.data.hbb.staked).multipliedBy(metrics.data.hbb.price);
  return toUSDTBalances(value)
}

module.exports = {
  methodology: `To obtain the Hubble Protocol TVL we use the formula 'TVL = Total HBB Staked * Current HBB Price + Total Collateral Value + Total Stablecoin (USDH) in Stability Pool'.`,
  solana: {
    tvl,
    staking,
  },
}
'''
'''--- projects/huckleberry/index.js ---
    const {getChainTvl} = require('../helper/getUniSubgraphTvl')
const { stakingPricedLP } = require('../helper/staking')
const { usdCompoundExports } = require('../helper/compound')
const sdk = require('@defillama/sdk')

const unitroller = '0xcffef313b69d83cb9ba35d9c0f882b027b846ddc'

const lendingMarket = usdCompoundExports(unitroller, "moonriver", "0x455D0c83623215095849AbCF7Cc046f78E3EDAe0")

module.exports={
    methodology: "Liquidity on DEX and supplied and borrowed amounts found using the comptroller address(0xcffef313b69d83cb9ba35d9c0f882b027b846ddc)",
    misrepresentedTokens: true,
    moonriver:{
        staking: stakingPricedLP("0x37619cC85325aFea778830e184CB60a3ABc9210B", "0x9A92B5EBf1F6F6f7d93696FCD44e5Cf75035A756", "moonriver", "0xbBe2f34367972Cb37ae8dea849aE168834440685", "moonriver"),
        tvl: sdk.util.sumChainTvls([
            getChainTvl({moonriver: "https://api.thegraph.com/subgraphs/name/huckleberrydex/huckleberry-subgraph"})('moonriver'),
            lendingMarket.tvl
        ]),
        borrowed: lendingMarket.borrowed
    }
}
'''
'''--- projects/humble/index.js ---
const axios = require('axios');
const retry = require('../helper/retry');
const { toUSDTBalances } = require('../helper/balances');

async function tvl(){
    const response = (
        await retry(
            async () => await axios.get(
                'https://yhnyufyj90.execute-api.us-east-1.amazonaws.com/prod/humble-tvl'
            )
        )
    )

    const data = response.data

    return data.tvl ? toUSDTBalances(data.tvl) : toUSDTBalances(0);
}

module.exports={
    algorand:{
        tvl
    }
}
'''
'''--- projects/hummus/constants.js ---
/**
 * lp token addresses
 */
// USD1
const USD1_mUSDC_LP = "0x9E3F3Be65fEc3731197AFF816489eB1Eb6E6b830";
const USD1_mUSDT_LP = "0x9F51f0D7F500343E969D28010C7Eb0Db1bCaAEf9";
const USD1_DAI_LP = "0xd5A0760D55ad46B6A1C46D28725e4C117312a7aD";

/**
 * token addresses
 */
const mUSDC = "0xEA32A96608495e54156Ae48931A7c20f0dcc1a21";
const mUSDT = "0xbB06DCA3AE6887fAbF931640f67cab3e3a16F4dC";
const DAI = "0x4651B38e7ec14BB3db731369BFE5B08F2466Bd0A";

module.exports = {
  DAI: {
    id: "dai",
    addresses: [
      {
        token: DAI,
        lpTokens: [USD1_DAI_LP],
      },
    ],
  },
  mUSDC: {
    id: "usd-coin",
    addresses: [
      {
        token: mUSDC,
        lpTokens: [
          USD1_mUSDC_LP,
        ],
      },
    ],
  },
  mUSDT: {
    id: "tether",
    addresses: [
      {
        token: mUSDT,
        lpTokens: [USD1_mUSDT_LP],
      },
    ],
  },
};

'''
'''--- projects/hummus/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const constants = require("./constants");

async function balanceOf(owner, target, block) {
  const chain = "metis";
  let decimals = (await sdk.api.erc20.decimals(target, chain)).output;
  let balance = (
    await sdk.api.erc20.balanceOf({
      owner,
      target,
      block,
      chain,
    })
  ).output;
  return Number(balance) / 10 ** decimals;
}

async function tvl(timestamp, ethereumBlock, chainBlocks) {
  const block = chainBlocks["metis"];
  let balances = {};

  for (const key in constants) {
    const { id, addresses } = constants[key];
    let totalBalance = 0;
    for (const { token, lpTokens } of addresses) {
      for (const lpToken of lpTokens) {
        totalBalance += await balanceOf(lpToken, token, block);
      }
    }
    balances[id] = totalBalance;
  }

  return balances;
}

module.exports = {
  metis: {
    tvl,
    staking: staking(
      "0x89351BEAA4AbbA563710864051a8C253E7b3E16d", // veHUM
      "0x4aAC94985cD83be30164DfE7e9AF7C054D7d2121", // HUM
      "metis"
    ),
  },
};

'''
'''--- projects/hundredfinance/index.js ---
const {compoundExports, compoundExportsWithAsyncTransform} = require('../helper/compound')
const {transformArbitrumAddress, transformFantomAddress, transformHarmonyAddress, 
    transformMoonriverAddress, transformXdaiAddress, transformPolygonAddress,
    transformOptimismAddress } = require('../helper/portedTokens')
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const comptroller = "0x0f390559f258eb8591c8e31cf0905e97cf36ace2"

const usdcEth = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
const usdcFantom = "0x04068DA6C83AFCFA0e13ba15A6696662335D5B75"
const usdcArbitrum = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"

const daiEth = "0x6b175474e89094c44da98b954eedeac495271d0f"
const daiFantom = "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e"

const usdtEth = "0xdac17f958d2ee523a2206206994597c13d831ec7"
const usdtArbitrum = "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"

const usdcFantomBAMM = "0xEDC7905a491fF335685e2F2F1552541705138A3D"
const daiFantomBAMM = "0x6d62d6Af9b82CDfA3A7d16601DDbCF8970634d22"
const usdcArbitrumBAMM = "0x04208f296039f482810B550ae0d68c3E1A5EB719"
const usdtArbitrumBAMM = "0x24099000AE45558Ce4D049ad46DDaaf71429b168"

const bamms = {
    "fantom" : [
        {"bamm" : usdcFantomBAMM, "underlying" : usdcFantom, "underlyingEth" : usdcEth },
        { "bamm" : daiFantomBAMM, "underlying" : daiFantom, "underlyingEth" : daiEth }
    ],
    "arbitrum" : [
        {"bamm" : usdcArbitrumBAMM, "underlying" : usdcArbitrum, "underlyingEth" : usdcEth },
        { "bamm" : usdtArbitrumBAMM, "underlying" : usdtArbitrum, "underlyingEth" : usdtEth }
    ]
} 

async function bammTvlFunc(chain, retTvl, unixTimestamp, ethBlock, chainBlocks) {
    const block = chainBlocks[chain]

    const balances = await retTvl(unixTimestamp, ethBlock, chainBlocks)

    for(let bamm of bamms[chain]) {
        const bammBalance = (
            await sdk.api.erc20.balanceOf({
              target: bamm["underlying"],
              owner: bamm["bamm"],
              block: block,
              chain: chain,
            })
          ).output;
        
        const ethToken = bamm["underlyingEth"]
        balances[ethToken] = (new BigNumber(balances[ethToken]).plus(new BigNumber(bammBalance))).toString(10)        
    }

    return balances
}

function tvlWithBamm() {
    const chain = arguments[1]
    const retVal = compoundExportsWithAsyncTransform(...arguments)
    return {tvl: async(...args)=> bammTvlFunc(chain, retVal.tvl, ...args), borrowed: retVal.borrowed}
}

module.exports={
    hallmarks: [
        [1647302400, "Reentrancy attack"]
    ],
    ethereum:compoundExports(comptroller, "ethereum", "0xfCD8570AD81e6c77b8D252bEbEBA62ed980BD64D", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"),
    arbitrum:tvlWithBamm(comptroller, "arbitrum", "0x8e15a22853A0A60a0FBB0d875055A8E66cff0235", "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", transformArbitrumAddress),
    fantom:tvlWithBamm(comptroller, "fantom", "0xfCD8570AD81e6c77b8D252bEbEBA62ed980BD64D", "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83", transformFantomAddress),
    harmony:compoundExportsWithAsyncTransform(comptroller, "harmony", "0xbb93C7F378B9b531216f9aD7b5748be189A55807", "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a", transformHarmonyAddress),
    moonriver:compoundExportsWithAsyncTransform("0x7d166777bd19a916c2edf5f1fc1ec138b37e7391", "moonriver", "0xd6fcBCcfC375c2C61d7eE2952B329DcEbA2D4e10", "0x98878b06940ae243284ca214f92bb71a2b032b8a", transformMoonriverAddress),
    xdai:compoundExportsWithAsyncTransform(comptroller, "xdai", "0x090a00A2De0EA83DEf700B5e216f87a5D4F394FE", "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d", transformXdaiAddress),
    polygon:compoundExportsWithAsyncTransform("0xedba32185baf7fef9a26ca567bc4a6cbe426e499", "polygon", "0xEbd7f3349AbA8bB15b897e03D6c1a4Ba95B55e31", "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270", transformPolygonAddress),
    optimism:compoundExportsWithAsyncTransform(comptroller, "optimism", "0xE8F12f5492Ec28609D2932519456b7436d6c93bD", "0x4200000000000000000000000000000000000006", transformOptimismAddress),
}
'''
'''--- projects/hunnyfinance/abi.json ---
{
    "stakingToken": {
        "inputs": [],
        "name": "stakingToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "balance": {
        "inputs": [],
        "name": "balance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/hunnyfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs, sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

// HUNNY FINANCE
const hunnyToken = "0x565b72163f17849832a692a3c5928cc502f46d69";

// POOL2 TOKEN
const hunnybnblpstaking = "0x434Af79fd4E96B5985719e3F5f766619DC185EAe";
const hunnybnblp = "0x36118142F8C21a1F3fd806D4A34F56f51F33504F";

// STAKING 
const stakingContracts = [
    "0x8B2cf8CF0A30082111FB50D9a8FEBfe53C155B50", // AUTO HUNNY HIVE
    "0x24320c20499535d0D7a8F6adFb08e5E3f5694417", // HUNNY ACE HIVE
    "0x389D2719a9Bcc29583Db89FD9454ADe9e57CD18d" // RETIRED HUNNY HIVE
]
    
const farmContracts = [
    // Auto Compounding FARM Contracts
    "0x848391a2509646cD380fca7f9c740E6F3B6e516F", // CAKE
    "0x76Bd85dA85aA07c6f8565DE0d882356083f37115", // BNB
    "0x7969EF7B7D6f79a798e85367C5824B835C2D644F", // BABY
    "0x9e84a8f7043601a2Ca497c5cF700FF5E099B55DD", // BUSD
    "0xf78b82BFA4596c6862720E3e13E6eaA24B74e4f8", // USDT
    "0x8d58AF27477Aa9B0F79A0F7825689Af015BaC8F2", // BTCB
    "0xeAC4584f446eb608CCd9C173B84a1E277db62C9B", // ETH
    "0xb7D43F1beD47eCba4Ad69CcD56dde4474B599965", // CAKE
    "0xAD4134F59C5241d0B4f6189731AA2f7b279D4104", // BANANA
    "0xc212ba7Dec34308A4cb380612830263387150310", // USDC (Venus)
    "0xBcCfD3e2Af166bB28B6b4Dfd6C1BF1F3f7F47632", // USDT (Venus)
    "0xe763D7E9a14ADB928766C19DF4bcE580fb6393B3", // BUSD (Venus)
    // Booster HIVE Contracts 
    "0x65003459BF2506B096a9a9C8bC691e88430567D1", // BANANA-BNB
    "0xBDb18B0C2fC2dD0DeD494F43c4101E8D23Fb596E", // CAKE-BNB
    // Retired HIVE contracts
    "0x12180BB36DdBce325b3be0c087d61Fce39b8f5A4", // CAKE-BNB
    "0xD87F461a52E2eB9E57463B9A4E0e97c7026A5DCB", // BUSD-BNB
    "0x31972E7bfAaeE72F2EB3a7F68Ff71D0C61162e81", // USDT-BNB
    "0x3B34AA6825fA731c69C63d4925d7a2E3F6c7f13C", // DOGE-BNB
    "0x2ea6676c106e200Eef203331d794c7B4A01CaAB5", // FIL
    "0xef43313e8218f25Fe63D5ae76D98182D7A4797CC", // TUSD
    "0xdFe440fBe839E9D722F3d1c28773850F99692c76", // BUNNY-BNB
    "0xF0D4a0398D6D48B958d0777528D0eE9A24Fb8899", // DOGE-BNB
    "0x6c7eFFa3d0694f8fc2D6aEe501ff484c1FE6fcD2", // LINK-BNB
    "0x4C8714d28Bf187E4B0aC47B880334090500dAFD4", // USDT-BNB
    "0xf36e82E42670DB17f08C9731a45689D9190fB8AC" // BUSD-BNB
];

// HUNNY DAO
const love = "0x9505dbD77DaCD1F6C89F101b98522D4b871d88C5";
const dao = "0x650eC6f59b64AcAC97A33C1F2F34c646659FF8b4"
const loveStaking = "0x31dd9Be51cC7A96359cAaE6Cb4f5583C89D81985"
const treasury = "0x631Fb1f772b8A20e775D1d4F3F87BfCaBA317527";
const treasuryTokens = [
	["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], // BUSD
	["0x9e8Ae3a26536582823Ef82c155B69637a4A753F8", true], // LOVE-BUSD Cake-LP
	["0x55d398326f99059fF775485246999027B3197955", false], // USDT
	["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false], // WBNB
	["0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", false], // CAKE
	["0x565b72163f17849832a692a3c5928cc502f46d69", false], // HUNNY
]

const chain = "bsc";

async function tvl (timestamp, block, chainBlocks) {
    block = chainBlocks.bsc;
    let balances = {};

    // HUNNY FINANCE
    const stakingTokens = (await sdk.api.abi.multiCall({
        calls: farmContracts.map( p => ({
            target: p
        })),
        abi: abi.stakingToken,
        block,
        chain
    })).output;
    const symbols = (await sdk.api.abi.multiCall({
        calls: stakingTokens.map( p => ({
            target: p.output
        })),
        abi: "erc20:symbol",
        block,
        chain
    })).output;
    const stakingBalances = (await sdk.api.abi.multiCall({
        calls: farmContracts.map( p => ({
            target: p
        })),
        abi: abi.balance,
        block,
        chain
    })).output;
    let lpPositions = [];
    for (let i = 0; i < farmContracts.length; i++) {
        if (symbols[i].output.endsWith("LP")) {
            lpPositions.push({
                token: stakingTokens[i].output,
                balance: stakingBalances[i].output
            });
        } else {
            sdk.util.sumSingleBalance(balances, `bsc:${stakingTokens[i].output}`, stakingBalances[i].output);
        }
    }
    await unwrapUniswapLPs(balances, lpPositions, block, chain, addr=>`bsc:${addr}`);

    // HUNNY DAO TVL

    // await sumTokensAndLPsSharedOwners(
	// 	balances,
	// 	treasuryTokens,
	// 	[treasury],
	// 	chainBlocks.bsc,
	// 	'bsc',
	// 	addr=>`bsc:${addr}`
	// );

    return balances;
    
}

async function staking (timestamp, block, chainBlocks) {
    let balances = {};
    block = chainBlocks.bsc;
    // HUNNY FINANCE STAKING
    const stakingBalances = (await sdk.api.abi.multiCall({
        calls: stakingContracts.map( p => ({
            target: p
        })),
        abi: abi.balance,
        block,
        chain
    })).output;
    stakingBalances.forEach(p => {
        sdk.util.sumSingleBalance(balances, `bsc:${hunnyToken}`, p.output);
    });

    // HUNNY DAO STAKING
    // const daoStakeBalance = (await sdk.api.erc20.balanceOf({
    //     target: love,
    //     owner: loveStaking,
    //     block,
    //     chain
    // })).output;
    // sdk.util.sumSingleBalance(balances, `bsc:${love}`, daoStakeBalance);
    return balances;
}

async function pool2 (timestamp, block, chainBlocks) {
    let balances = {};
    block = chainBlocks.bsc;
    const balance = ( await sdk.api.abi.call({
        target: hunnybnblpstaking,
        abi: abi.balance,
        block,
        chain
    })).output;
    await unwrapUniswapLPs(balances, [{balance, token: hunnybnblp}], block, chain, addr=>`bsc:${addr}`);
    return balances;
}

module.exports = {
    methodology: "TVL is from the pools on Hunny Finance and tokens locked in Hunny DAO treasury",
    bsc: {
        tvl,
        staking,
        pool2
    }
}
'''
'''--- projects/hunnyswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x0c6A0061F9D0afB30152b8761a273786e51bec6d) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  avax: {
    tvl: calculateUsdUniTvl(
      "0x0c6A0061F9D0afB30152b8761a273786e51bec6d",
      "avax",
      "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      [
        "0xf9430aD8da4af7fb4091C57FE523af1236FF5b2C",
        "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
        "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
        "0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB",
        "0x264c1383EA520f73dd837F915ef3a732e204a493",
        "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7"
      ],
      "wrapped-avax"
    ),
  },
}; // node test.js projects/hunnyswap/index.js
'''
'''--- projects/hurricaneswap.js ---
const sdk = require("@defillama/sdk");
const { getChainTvl } = require("./helper/getUniSubgraphTvl");
const { getBlock } = require("./helper/getBlock");
const { default: BigNumber } = require("bignumber.js");
const { calculateUsdUniTvl } = require("./helper/getUsdUniTvl");
const { staking, stakings } = require("./helper/staking");

const masterChefV1 = "0x9984d70D5Ab32E8e552974A5A24661BFEfE81DbE";
const masterChefV2 = "0x1c9F36FE608190D1fe99e001b596c31871696b24";
const AVAX = "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7";

const stakingConttract_xhctBar = "0x75B797a0ed87F77bB546F3A3556F18fC35a01140";
const stakingConttract_shctBar = "0xE4aE2E8648B8E84c4A487a559b04e884B822a350";
const HCT = "0x45C13620B55C35A5f539d26E88247011Eb10fDbd";

const chainTvl = calculateUsdUniTvl(
  "0x7009b3619d5ee60d0665BA27Cf85eDF95fd8Ad01",
  "avax",
  "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
  [
    "0x45c13620b55c35a5f539d26e88247011eb10fdbd", //hct
    "0xc7198437980c041c805a1edcba50c1ce5db95118", //usdte
    "0xfbbc6be26e1712685848b7194365600513cf73ca", //ausdt
    "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab", //weth
    "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664", //usdce
    "0x7ed05cf8f77fb75a10947e0715c0876e074ff676", //acake
    "0x50b7545627a5162f82a992c33b87adc75187b218", //wbtc
    "0x60781c2586d68229fde47564546784ab3faca982", //png
    "0x5947bb275c521040051d82396192181b413227a3", //link
  ],
  "wrapped-avax"
);

/*
const graphUrls = {
  avax: 'https://api.thegraph.com/subgraphs/name/hurricaneswap/exchange-v2',
}
const chainTvl = getChainTvl(graphUrls, "pancakeFactories")("avax")
*/

module.exports = {
  timetravel: true,
  doublecounted: false,
  misrepresentedTokens: true,
  avax: {
    tvl: sdk.util.sumChainTvls([chainTvl, staking(masterChefV2, AVAX, "avax")]),
    staking: stakings(
      [
        stakingConttract_xhctBar,
        stakingConttract_shctBar,
        masterChefV2,
        masterChefV1,
      ],
      HCT,
      "avax"
    ),
  },
  methodology:
    'We count TVL from the "0x7009b3619d5ee60d0665BA27Cf85eDF95fd8Ad01" factory address, which includes all pairs data of HurricaneSwap. The staking portion includes the liquidity in the HCTBar (xHCT), StakingReward (sHCT) contract and the WAVAX deposited in pool contract.',
};

'''
'''--- projects/hydradex.js ---
const { GraphQLClient, gql } = require('graphql-request');

async function fetch() {
    var graphQLClient = new GraphQLClient(`https://info.hydradex.org/graphql`);
    const results = await graphQLClient.request(gql
        `query Query {
            hydraswapFactories(
                where: {
                    id: "5a2a927bea6c5f4a48d4e0116049c1e36d52a528"
                }) {
                    totalLiquidityUSD
                }
            }`
        );
    return results.hydraswapFactories[0].totalLiquidityUSD;
};

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  methodology: "We count liquidity on the dex, pulling data from subgraph",
  hydra: {
    fetch
  },
  fetch
};
'''
'''--- projects/hyfi.js ---
const axios = require('axios');

async function fetch() {
  var response = await axios.get('http://api.hyfi.pro/stat')
  return response.data.vault_tvl;
}

module.exports = {
  fetch
}

'''
'''--- projects/hyperswap/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')
const {transformFantomAddress} = require('../helper/portedTokens')

const FACTORY = "0x991152411A7B5A14A8CF0cDDE8439435328070dF";

async function tvl(timestamp, block, chainBlocks) {
  const transform = await transformFantomAddress()
  return calculateUniTvl(transform, chainBlocks['fantom'], 'fantom', FACTORY, 0, true);
}

module.exports={
  methodology: "Liquidity on DEX pools",
  tvl
}
'''
'''--- projects/iTrustfinance/abi.json ---
{
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/iTrustfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const vaults = [
  // sNXM (Nexus Mutual Strategy Vault)
  "0xD82c32Dd3585B5bc528688Efa408adA09963C238",
  // iNXM (Nexus Mutual Index Vault)
  "0xf4104CadE73d699922CC657A97CB1132bC620978",
];

/*
 * WNXM and NXM have different price at coingecko! what do I should use?
 * And in the vaults there are deposited both of them!
 */

const NXM = "0xd7c49CEE7E9188cCa6AD8FF264C1DA2e69D4Cf3B";

const erc20Tokens = [
  //WNXM
  "0x0d438f3b5175bebc262bf23753c1e53d03432bde",
  //IDLE
  "0x875773784Af8135eA0ef43b5a374AaD105c5D39e",
  //WETH
  "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  //VISR
  "0xf938424f7210f31df2aee3011291b658f872e91e",
  //BOND
  "0x0391D2021f89DC339F60Fff84546EA23E337750f",
];

/*** Vaults and staking TVL Portions ***/
const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  for (const vault of vaults) {
    const supply = (
      await sdk.api.abi.call({
        abi: abi.totalSupply,
        target: vault,
        ethBlock,
      })
    ).output;

    sdk.util.sumSingleBalance(balances, NXM, supply);
  }

  await sumTokensAndLPsSharedOwners(
    balances,
    erc20Tokens.map(token => [token, false]),
    vaults,
    chainBlocks["ethereum"]
  );

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology:
    "We count liquidity of NXM/WNXM deposited on the vaults (iNXM and sNXM) threw their contracts and the staking of other tokens within these vaults",
};

'''
'''--- projects/ice-colony/index.js ---
const {masterChefExports} = require("../helper/masterchef");
const masterchef = "0xFa0A21fFCd1BB6210160582Cd9E42C7E90668F83";
const ice = "0x6ad1eEdDf1b1019494E6F78377d264BB2518db6F";

module.exports = {
    ...masterChefExports(masterchef, "polygon", ice, false)
}
'''
'''--- projects/ice-dao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasuryAddress = "0x935AEf514141B0CA32849e9686d22CB8b6f1dCAF";
module.exports = ohmTvl(treasuryAddress, [
//MIM
  ["0x130966628846bfd36ff31a822705796e8cb8c18d", false],
//WAVAX
  ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false],
// ICY MIM JLP
  ["0x453B5415Fe883f15686A5fF2aC6FF35ca6702628", true],
// MEMO
  ["0x136acd46c134e8269052c62a67042d6bdedde3c9", false]

], "avax", "0xBDe1c85C9fAA18bC6e8EDa1e2d813E63f86fd145", "0x78bF833AaE77EBF62C21A9a5A6993A691810F2e1", addr=> {
  if (addr.toLowerCase() === "0x136acd46c134e8269052c62a67042d6bdedde3c9") {
    return "avax:0xb54f16fb19478766a268f172c9480f8da1a7c9c3"
  }
  return `avax:${addr}`
}, undefined, false)
'''
'''--- projects/icecream-finance/index.js ---
const { tombTvl } = require("../helper/tomb");

const cream = "0xAE21d31a6494829a9E4B2B291F4984AAE8121757";
const cshare = "0x155f794b56353533E0AfBF76e1B1FC57DFAd5Bd7";
const masonry = "0x13692700791BD876D8f68b5df910339312Efc14b";
const rewardPool = "0x6CD5a7Acbe8Ddc57C8aC2EE72f3f957e26D81f51";
const pool2LPs = [
    "0x00c87ce7188f7652d0c0940274cec5db62f1e825",
    "0xbd61dfad83fc19960476abca1324ffd798234c66",
    "0xec1e129bbaac3dde156643f5d41fc9b5a59033a7"
]

module.exports = {
    ...tombTvl(cream, cshare, rewardPool, masonry, pool2LPs, "avax", undefined, false, "0xbd61dfad83fc19960476abca1324ffd798234c66")
}
'''
'''--- projects/ichifarm/abi.json ---
{
    "oneTokenCount": {
        "inputs": [],
        "name": "oneTokenCount",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "oneTokenAtIndex": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "oneTokenAtIndex",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "assetCount": {
        "inputs": [],
        "name": "assetCount",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "assetAtIndex": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "assetAtIndex",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getTotalAmounts": {
        "inputs": [],
        "name": "getTotalAmounts",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "total0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "total1",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "allVaults": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "allVaults",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/ichifarm/index.js ---
const sdk = require("@defillama/sdk");
const { default: BigNumber } = require("bignumber.js");
const { stakings } = require("../helper/staking");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const abi = require("./abi.json");
const { requery } = require('./../helper/getUsdUniTvl');

const ichi = "0x903bEF1736CDdf2A537176cf3C64579C3867A881";
const xIchi = "0x70605a6457B0A8fBf1EEE896911895296eAB467E";
const tokenFactory = "0xD0092632B9Ac5A7856664eeC1abb6E3403a6A36a";
const farmContract = "0x275dFE03bc036257Cd0a713EE819Dbd4529739c8";
const ichiLending = "0xaFf95ac1b0A78Bd8E4f1a2933E373c66CC89C0Ce";

const unilps = [
  // SLP
  "0x9cD028B1287803250B1e226F0180EB725428d069",
  // UNI-V2 lP
  "0xd07D430Db20d2D7E0c4C11759256adBCC355B20C"
]

const poolWithTokens = [
  // BANCOR
  ["0x4a2F0Ca5E03B2cF81AebD936328CF2085037b63B", ["0x903bEF1736CDdf2A537176cf3C64579C3867A881", "0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C"]],
  // ONE INCH
  ["0x1dcE26F543E591c27717e25294AEbbF59AD9f3a5", ["0x903bEF1736CDdf2A537176cf3C64579C3867A881", "0x111111111117dC0aa78b770fA6A738034120C302"]],
  // BALANCER
  ["0x58378f5F8Ca85144ebD8e1E5e2ad95B02D29d2BB", ["0x903bEF1736CDdf2A537176cf3C64579C3867A881", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"]]
]

const lendingPools = [
  { 
    target: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    params: ["0x5933f2109652c019ceab70dabf4bc9e0e29873f5"]
  },
  { // oneUNI
    target: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    params: ["0x8290D7a64F25e6b5002d98367E8367c1b532b534"]
  },
  { // oneUNI
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0x8290D7a64F25e6b5002d98367E8367c1b532b534"]
  },
  // { // xICHI
  //   target: "0x70605a6457B0A8fBf1EEE896911895296eAB467E",
  //   params: ["0xb7abc13db4aeaea90a17ae46291317ef8554f076"]
  // },
  { 
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0xece2c0aa6291e3f1222b6f056596dfe0e81039b9"]
  },
  // { // ichiVault == oneUNI
  //   target: "0xfaeCcee632912c42a7c88c3544885A8D455408FA",
  //   params: ["0x78dcc36dc532b0def7b53a56a91610c44dd09444"]
  // }
  { // oneFOX
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0x03352D267951E96c6F7235037C5DFD2AB1466232"]
  },
  { // oneFOX
    target: "0xc770EEfAd204B5180dF6a14Ee197D99d808ee52d",
    params: ["0x03352D267951E96c6F7235037C5DFD2AB1466232"]
  },
  { // oneBTC
    target: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    params: ["0xEc4325F0518584F0774b483c215F65474EAbD27F"]
  },
  {  // oneBTC
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0xEc4325F0518584F0774b483c215F65474EAbD27F"]
  },
  { // oneFUSE
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0xBbcE03B2E7f53caDCA93251CA4c928aF01Db6404"]
  },
  { // oneFUSE
    target: "0x970B9bB2C0444F5E81e9d0eFb84C8ccdcdcAf84d",
    params: ["0xBbcE03B2E7f53caDCA93251CA4c928aF01Db6404"]
  },
  { // onePERL
    target: "0xeca82185adCE47f39c684352B0439f030f860318",
    params: ["0xD9A24485e71B9148e0Fd51F0162072099DF0dB67"]
  },
  {  // onePERL
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0xD9A24485e71B9148e0Fd51F0162072099DF0dB67"]
  },

  { // oneFIL
    target: "0xD5147bc8e386d91Cc5DBE72099DAC6C9b99276F5",
    params: ["0x6d82017e55b1D24C53c7B33BbB770A86f2ca229D"]
  },
  {  // oneFIL
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0x6d82017e55b1D24C53c7B33BbB770A86f2ca229D"]
  },
  { // one1INCH
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0x853Bb55c1f469902F088A629db8C8803A9BE3857"]
  },
  { // one1INCH
    target: "0x111111111117dC0aa78b770fA6A738034120C302",
    params: ["0x853Bb55c1f469902F088A629db8C8803A9BE3857"]
  },
  { // oneMPH
    target: "0x8888801aF4d980682e47f1A9036e589479e835C5",
    params: ["0xBE3F88E18BE3944FdDa830695228ADBB82fA125F"]
  },
  {  // oneMPH
    target: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    params: ["0xBE3F88E18BE3944FdDa830695228ADBB82fA125F"]
  },
]

async function getVaultTvl(balances, vaults, tokenAtIndex, block) {
  let allOneTokens = []
  tokenAtIndex.map(p => {
    allOneTokens.push(p.output.toLowerCase());
  })

  const token0s = (await sdk.api.abi.multiCall({
    calls: vaults.map(p => ({
      target: p
    })),
    abi: abi["token0"],
    block
  })).output;

  const token1s = (await sdk.api.abi.multiCall({
    calls: vaults.map(p => ({
      target: p
    })),
    abi: abi["token1"],
    block
  })).output;

  const totalAmounts = (await sdk.api.abi.multiCall({
    calls: vaults.map(p => ({
      target: p
    })),
    abi: abi["getTotalAmounts"],
    block
  })).output;

  await requery(totalAmounts, 'ethereum', block, abi["getTotalAmounts"]);
  await requery(token0s, 'ethereum', block, abi["token0"]);
  await requery(token1s, 'ethereum', block, abi["token1"]);

  for (let i = 0; i < vaults.length; i++) {
    const tokens = [
      token0s[i].output.toLowerCase(),
      token1s[i].output.toLowerCase()
    ]

    const bals = [
      totalAmounts[i].output[0],
      totalAmounts[i].output[1]
    ]

    for (let j = 0; j < 2; j++) {
      if (allOneTokens.includes(tokens[j])) {
        break;
      }
      sdk.util.sumSingleBalance(balances, tokens[j], bals[j]);
    }
  }
}

async function getOneTokens(block) {
  const tokenCount = (await sdk.api.abi.call({
    target: tokenFactory,
    abi: abi.oneTokenCount,
    block
  })).output;

  const tokenAtIndex = (await sdk.api.abi.multiCall({
    calls: [...Array(tokenCount).keys()].map((i) => ({
      target: tokenFactory,
      params: [i]
    })),
    abi: abi.oneTokenAtIndex,
    block
  })).output;

  return tokenAtIndex
}
async function getTreasuryTvl(balances, tokenAtIndex, block) {

  for (let i = 0; i < tokenAtIndex.length; i++) {
    const asset = tokenAtIndex[i];
    const assetCount = (await sdk.api.abi.call({
      target: asset.output,
      abi: abi["assetCount"],
      block
    })).output;

    const assetAtIndex = (await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(assetCount) }, (_, k) => ({
        target: asset.output,
        params: k
      })),
      abi: abi["assetAtIndex"],
      block
    })).output;

    const assetBalances = (await sdk.api.abi.multiCall({
      calls: assetAtIndex.map(p => ({
        target: p.output,
        params: p.input.target
      })),
      abi: "erc20:balanceOf",
      block
    })).output;

    assetBalances.forEach(p => {
      const token = p.input.target.toLowerCase();
      const balance = p.output;

      if (token === "0xdb0f18081b505a7de20b18ac41856bcb4ba86a1a") {
        sdk.util.sumSingleBalance(balances, ["wing-finance"], BigNumber(balance).div(1e9).toFixed(0));
        return;
      }

      sdk.util.sumSingleBalance(balances, token, balance);
    })
  }
}

async function getDepositTvl(balances, tokenAtIndex, block) {
  const tokenBalances = (await sdk.api.abi.multiCall({
    calls: tokenAtIndex.map(p => ({
      target: p.output,
      params: farmContract
    })),
    abi: "erc20:balanceOf",
    block
  })).output;

  tokenBalances.forEach(p => {
      sdk.util.sumSingleBalance(balances, p.input.target, p.output);
  });
}

async function getLendingTvl(balances, block) {

  const ethBalance = (await sdk.api.eth.getBalance({
    target: "0xd2626105690e480dfeb12a64bc94b878df9d35d8",
    block: block,
  })).output;

  sdk.util.sumSingleBalance(
    balances, 
    "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", 
    ethBalance
  )
  
  const balanceOfResults = await sdk.api.abi.multiCall({
    calls: lendingPools,
    abi: 'erc20:balanceOf',
    block
  })
  sdk.util.sumMultiBalanceOf(balances, balanceOfResults, true)
}

async function getVaults(block) {
  const estVaultCount = 30;
  const vaults = (await sdk.api.abi.multiCall({
    block,
    calls: [...Array(estVaultCount).keys()].map((i) => ({
      target: '0x5a40DFaF8C1115196A1CDF529F97122030F26112',
      params: [i],
    })),
    abi: abi.allVaults,
  })).output.filter(v => v.success == true).map(v => v.output);
  return vaults;
}

async function tvl(timestamp, block) {
  let balances = {};

  const vaults = await getVaults(block)
  const ichiTokens = await getOneTokens(block)

  await getTreasuryTvl(balances, ichiTokens, block);
  await getVaultTvl(balances, vaults, ichiTokens, block);
  await getLendingTvl(balances, block);
  await getDepositTvl(balances, ichiTokens, block);

  for (let t of ichiTokens) {
    delete balances[t]
  }
  return balances;
}

async function getPoolTvl(balances, poolWithTokens, block) {
  for (let i = 0; i < poolWithTokens.length; i++) {
    const pool = poolWithTokens[i][0];
    const tokens = poolWithTokens[i][1];
    const poolBalances = (await sdk.api.abi.multiCall({
      calls: tokens.map(p => ({
        target: p,
        params: pool
      })),
      abi: "erc20:balanceOf",
      block
    })).output;
    poolBalances.forEach(p => {
      sdk.util.sumSingleBalance(balances, p.input.target, p.output);
    })
  }
}

async function pool2(timestamp, block) {
  let balances = {};

  const unilpBalance = (await sdk.api.abi.multiCall({
    calls: unilps.map(p => ({
      target: p,
      params: farmContract
    })),
    abi: "erc20:balanceOf",
    block
  })).output;

  let lpPositions = [];
  unilpBalance.forEach(p => {
    lpPositions.push({ token: p.input.target, balance: p.output });
  })

  await unwrapUniswapLPs(balances, lpPositions, block);
  await getPoolTvl(balances, poolWithTokens, block);

  return balances;
}

module.exports = {
  methodology: "Tokens deposited to mint oneTokens, Angel and HODL vaults excluding oneTokens",
  misrepresentedTokens: true,
  ethereum: {
    tvl,
    pool2,
    staking: stakings([xIchi, ichiLending] , ichi)
  }
} // node test.js projects/ichifarm/index.js
'''
'''--- projects/ideamarket/abi.json ---
{"inputs":[],"name":"getTotalDaiReserves","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
'''
'''--- projects/ideamarket/index.js ---
const sdk = require('@defillama/sdk')
const getTotalDaiReserves = require('./abi.json')

const stateContract = "0x4e908F706f8935f10C101Ea3D7B2DEfc78df284e"
const dai = "0x6b175474e89094c44da98b954eedeac495271d0f"

async function tvl(timestamp, ethBlock, chainBlocks) {
    const daiDeposited = await sdk.api.abi.call({
        target: stateContract,
        abi: getTotalDaiReserves,
        block: chainBlocks.arbitrum,
        chain: "arbitrum"
    })
    return {
        [dai]: daiDeposited.output
    }
}

module.exports = {
    timetravel: true,
    arbitrum: {
        tvl
    }
}
'''
'''--- projects/idex/index.js ---
/*==================================================
  Modules
  ==================================================*/

const { covalentGetTokens, get } = require("../helper/http")
const { sumTokens2 } = require("../helper/unwrapLPs")
const { getUniqueAddresses } = require("../helper/utils")

const IDEX_ETHEREUM_CUSTODY_CONTRACT = "0xE5c405C5578d84c5231D3a9a29Ef4374423fA0c2";
const IDEX_POLYGON_CUSTODY_CONTRACT = "0x3bcc4eca0a40358558ca8d1bcd2d1dbde63eb468";

/*==================================================
  TVL
  ==================================================*/

async function tvl(_timestamp, block, chain) {
  let tokens = ['0x0000000000000000000000000000000000000000']
  let owner

  switch (chain) {
    case 'polygon':
      const assets = await get('https://api-matic.idex.io/v1/assets')
      assets.forEach(t => tokens.push(t.contractAddress))
      owner = IDEX_POLYGON_CUSTODY_CONTRACT
      break;
    case 'ethereum':
      owner = IDEX_ETHEREUM_CUSTODY_CONTRACT
      const ethAssets = await covalentGetTokens(owner)
      ethAssets
        .map(t => t.contract_address.toLowerCase())
        .filter(t => t !== '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' && t !== '0x7b0c06043468469967dba22d1af33d77d44056c8')
        .forEach(t => tokens.push(t))
      break;
    default:
      throw new Error('Unknown chain ' + chain);
  }

  tokens = getUniqueAddresses(tokens)
  const res = await sumTokens2({ chain, block, tokens, owner })
  console.log(chain, res)
  return res
}

/*==================================================
  Exports
  ==================================================*/

const ethereumTvl = (_timestamp, block, chainBlocks) => tvl(_timestamp, block, 'ethereum')
const polygonTvl = (_timestamp, block, chainBlocks) => tvl(_timestamp, chainBlocks.polygon, 'polygon')

module.exports = {
  ethereum: {
    start: 1603166400,
    tvl: ethereumTvl,
  },
  polygon: {
    start: 1638316800,
    tvl: polygonTvl,
  },
};

'''
'''--- projects/idle/abi.json ---
{
    "tokenPrice": {
        "constant": true,
        "inputs": [],
        "name": "tokenPrice",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "token": {
        "constant": true,
        "inputs": [],
        "name": "token",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getContractValue": {
        "inputs": [],
        "name": "getContractValue",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/idle/index.js ---
const sdk = require('@defillama/sdk')
const { default: BigNumber } = require('bignumber.js')
const abi = require('./abi.json')
const {chainExports} = require('../helper/exports')

const contracts = {
    ethereum:[
        '0xC8E6CA6E96a326dC448307A5fDE90a0b21fd7f80',
        '0x5C960a3DCC01BE8a0f49c02A8ceBCAcf5D07fABe',
        '0xb2d5CB72A621493fe83C6885E4A776279be595bC',
        '0x3fe7940616e5bc47b0775a0dccf6237893353bb4',
        '0x78751b12da02728f467a44eac40f5cbc16bd7934',
        '0x5274891bEC421B39D23760c04A6755eCB444797C',
        '0x12B98C621E8754Ae70d0fDbBC73D6208bC3e3cA6',
        '0xF34842d05A1c888Ca02769A633DF37177415C2f8',
        '0x63D27B3DA94A9E871222CB0A32232674B02D2f2D',
        '0xf52cdcd458bf455aed77751743180ec4a595fd3f',
        '0xe79e177d2a5c7085027d7c64c8f271c81430fc9b',
        '0xc278041fDD8249FE4c1Aad1193876857EEa3D68c',
        '0x51C77689A9c2e8cCBEcD4eC9770a1fA5fA83EeF1',
        '0x8C81121B15197fA0eEaEE1DC75533419DcfD3151',
        '0xD6f279B7ccBCD70F8be439d25B9Df93AEb60eC55',
        '0xa14ea0e11121e6e951e87c66afe460a00bcd6a16',
        '0x1846bdfDB6A0f5c473dEc610144513bd071999fB',
        '0x3391bc034f2935ef0e1e41619445f998b2680d35',
        '0xcDdB1Bceb7a1979C6caa0229820707429dd3Ec6C',
        '0x28fAc5334C9f7262b3A3Fe707e250E01053e07b5',
        '0x42740698959761baf1b06baa51efbd88cb1d862b'
      ],
      polygon:[
          "0x8a999F5A3546F8243205b2c0eCb0627cC10003ab",
          "0x1ee6470CD75D5686d0b2b90C0305Fa46fb0C89A1",
          "0xfdA25D931258Df948ffecb66b5518299Df6527C4"
      ]      
}

const trancheContracts = [
    "0xd0DbcD556cA22d3f3c142e9a3220053FD7a247BC", // DAI
    "0x77648a2661687ef3b05214d824503f6717311596", // FEI
    "0x34dcd573c5de4672c8248cd12a99f875ca112ad8", // stETH
    "0x70320A388c6755Fc826bE0EF9f98bcb6bCCc6FeA", // mUSD
    "0x4ccaf1392a17203edab55a1f2af3079a8ac513e7", // FRAX3CRV
    "0x151e89e117728ac6c93aae94c621358b0ebd1866", // MIM3CRV
    "0x7ecfc031758190eb1cb303d8238d553b1d4bc8ef", // steCRV
    "0x008c589c471fd0a13ac2b9338b69f5f7a1a843e1", // ALUSD3CRV
    "0x858F5A3a5C767F8965cF7b77C51FD178C4A92F05", // 3EUR
    "0x16d88C635e1B439D8678e7BAc689ac60376fBfA6", // MUSD3CRV
];

const trancheTokenUnderlying = {
    "0x6B175474E89094C44Da98b954EedeAC495271d0F":"0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
    "0x956F47F50A910163D8BF957Cf5846D573E7f87CA":"0x956f47f50a910163d8bf957cf5846d573e7f87ca", // FEI
    "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84":"0xae7ab96520de3a18e5e111b5eaab095312d7fe84", // stETH
    "0xe2f2a5C287993345a840Db3B0845fbC70f5935a5":"0xe2f2a5c287993345a840db3b0845fbc70f5935a5", // mUSD
    "0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B":"0x853d955acef822db058eb8505911ed77f175b99e", // FRAX3CRV
    "0x5a6A4D54456819380173272A5E8E9B9904BdF41B":"0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3", // MIM3CRV
    "0x06325440D014e39736583c165C2963BA99fAf14E":"0xae7ab96520de3a18e5e111b5eaab095312d7fe84", // steCRV
    "0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c":"0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9", // ALUSD3CRV
    "0xb9446c4Ef5EBE66268dA6700D26f96273DE3d571":"0x1a7e4e63778b4f12a199c062f3efdd288afcbce8", // 3EUR
    "0x1AEf73d49Dedc4b1778d0706583995958Dc862e6":"0xe2f2a5c287993345a840db3b0845fbc70f5935a5", // MUSD3CRV
};

function chainTvl(chain){
    return async (time, ethBlock, chainBlocks)=>{   
        const block = chainBlocks[chain];
        const calls = {
            chain,
            block,
            calls: contracts[chain].map(c=>({target:c}))
        };
        const [tokenPrice, token, supply] = await Promise.all([abi.tokenPrice, abi.token, "erc20:totalSupply"].map(abi=>
            sdk.api.abi.multiCall({
                abi,
                ...calls,
            }))
        );
        const balances = {};
        tokenPrice.output.forEach((price, i)=>{
            sdk.util.sumSingleBalance(balances, chain+":"+ token.output[i].output,
            BigNumber(price.output).times(supply.output[i].output).div(1e18).toFixed(0))
        })
        if (chain==="ethereum"){
            const [contractValue, trancheToken] = await Promise.all([abi.getContractValue, abi.token].map(abi=>
                sdk.api.abi.multiCall({
                    abi,
                    block, chain,
                    calls: trancheContracts.map(c=>({target:c}))
                }))
            );

            contractValue.output.forEach((value, i)=>{
                sdk.util.sumSingleBalance(balances, chain+":"+ trancheTokenUnderlying[trancheToken.output[i].output], value.output)
            })
        }
        return balances;
    }
}

module.exports=chainExports(chainTvl, Object.keys(contracts))
'''
'''--- projects/ifpool/abis.json ---
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "validator",
        "type": "address"
      }
    ],
    "name": "getValidatorInfo",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "enum Validators.Status",
        "name": "",
        "type": "uint8"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }]
'''
'''--- projects/ifpool/index.js ---
const sdk = require("@defillama/sdk");
const abis = require("./abis.json");

const validatorContract = "0x0000000000000000000000000000000000001000";
const validatorAddress = "0xb0dC7A676Ab09868eBef78E16e6AEA9e79F0f9Cf";
const CHAIN = "csc";

async function coinexTVL(timestamp, block, chainBlocks) {
  const validatorInfo = await sdk.api.abi.call({
    chain: CHAIN,
    block: block,
    target: validatorContract,
    abi: abis.find((abi) => abi.name === "getValidatorInfo"),
    params: [validatorAddress],
  });

  return {
    "0x081f67afa0ccf8c7b17540767bbe95df2ba8d97f": validatorInfo.output[2], // CET
  };
}

module.exports = {
  methodology: "Counts staked CET tokens.",
  timetravel: false,
  csc: {
    tvl: coinexTVL,
  },
};

'''
'''--- projects/ifswap/index.js ---
const sdk = require("@defillama/sdk");
const { getBlock } = require("../helper/getBlock");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { stakingPricedLP } = require("../helper/staking");

const USDT = "0x398dcA951cD4fc18264d995DCD171aa5dEbDa129";
const IFS = "0x6925435f9D1CB710abeb680Ec7EF3f8C5E1B2639";
const FACTORY = "0x44b7864D360BFf7879402E3B860aF47e6e371208";
const MASTERCHEF = "0xB9C8c5Bf667310a33D4CB675e2f20c7542d8B3B3";
const IFS_USDT_LP = "0x72083c2de1b53a09ea9ed4a99c63749102ba9aaf";
const COREASSETNAME = "tether";
const CHAIN = "csc";

const ifswapDexTvl = calculateUsdUniTvl(
  FACTORY,
  CHAIN,
  USDT,
  [IFS],
  COREASSETNAME
);

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "We count liquidity of all paris through Factory Contract and Pools (single tokens) seccions through MasterChef Contract.",
  csc: {
    tvl: ifswapDexTvl,
    staking: stakingPricedLP(
      MASTERCHEF,
      IFS,
      "csc",
      IFS_USDT_LP,
      COREASSETNAME
    ),
  },
};

'''
'''--- projects/ignite-finance/abi.json ---
{
    "markdown": {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pair",
          "type": "address"
        }
      ],
      "name": "markdown",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    "valuation": {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pair",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount_",
          "type": "uint256"
        }
      ],
      "name": "valuation",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    "getCurrentPool": {
      "constant": true,
      "inputs": [],
      "name": "getCurrentPool",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        },
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    "circulatingSupply": {
      "inputs": [],
      "name": "circulatingSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    }
  }
'''
'''--- projects/ignite-finance/index.js ---
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const sdk = require('@defillama/sdk')
const { toUSDTBalances } = require("../helper/balances");
const chain = 'klaytn'

const TINDER_ADDRESS = "0x7cd4a64946e91989a21548362c18052704fe5ed6";
const TREASURY = "0xd5EFfEC94D1E0E099277C3723Eb8cc9343738fb5"
const BOND_DATA = {
  NAME: "KDAI_TINDER_LP",
  TOKEN: "0x14E180985BC510628F36a4A129FB57A5Fcb2eE33",
  BOND: "0x68a1C029523D60237d1eAe81777d87E49de4E27F",
  TYPE: "LP",
};

async function getBondMarketPrice(block) {
  const reserves = (await sdk.api.abi.call({ target: BOND_DATA.TOKEN, abi: abi.getCurrentPool, chain, block })).output;
  return new BigNumber(reserves[0])
    .div(reserves[1])
    .div(10 ** 9)
    .toFixed(5);
}

async function staking(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  const sTINDERCirculatingSupply = (await sdk.api.erc20.balanceOf({ target: TINDER_ADDRESS, owner: TREASURY, block, chain })).output
  const  marketPrice = await getBondMarketPrice(block)

  return toUSDTBalances(
    (sTINDERCirculatingSupply * marketPrice) / 10 ** 9
  );
}

module.exports = {
  misrepresentedTokens: true,
  klaytn: {
    tvl: async () => ({}),
    staking,
  },
  methodology: "Counts tokens on the staking for tvl",
};

'''
'''--- projects/illuvium/index.js ---
const {sumTokensAndLPs} = require('../helper/unwrapLPs')

const slp = "0x6a091a3406E0073C3CD6340122143009aDac0EDa"
const ilvstk = "0x25121EDDf746c884ddE4619b573A7B10714E2a36"
const ilv = "0x767fe9edc9e0df98e07454847909b5e959d7ca0e"
const slpstk = "0x8B4d8443a0229349A9892D4F7CbE89eF5f843F72"
const snxstk = "0x9898d72c2901D09E72A426d1c24b6ab90eB100e7"
const snx = "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f"
const axsstk = "0x099A3B242dceC87e729cEfc6157632d7D5F1c4ef"
const axs = "0xbb0e17ef65f82ab018d8edd776e8dd940327b28b"

async function getTvl(tokens, block){
  const balances = {}
  await sumTokensAndLPs(balances, tokens, block)

  return balances
}

async function staking(timestamp, block) {
  return getTvl([
    [ilv, ilvstk],
  ], block)
}

async function pool2(timestamp, block) {
  return getTvl([
    [slp, slpstk, true],
  ], block)
}

async function tvl(timestamp, block) {
  return getTvl([
    [snx, snxstk],
    [axs, axsstk]
  ], block)
}

module.exports = {
  timetravel: true,
  methodology: `Counts the tokens staked on the flash pools, currently SNX on 0x9898d72c2901D09E72A426d1c24b6ab90eB100e7 and AXS on 0x099A3B242dceC87e729cEfc6157632d7D5F1c4ef
  pool2 are the SLP tokens locked on 0x8B4d8443a0229349A9892D4F7CbE89eF5f843F72 and staking are the ILV tokens on 0x25121EDDf746c884ddE4619b573A7B10714E2a36`,
  ethereum:{
    tvl,
    pool2,
    staking
  },
}
'''
'''--- projects/imbtc.js ---

const sdk = require('@defillama/sdk')

async function tvl(ts, block) {
  return {
    'bitcoin': (await sdk.api.erc20.totalSupply({ target: '0x3212b29E33587A00FB1C83346f5dBFA69A458923', block })).output / 1e8
  }
}

module.exports = {
  ethereum: { tvl },
  methodology: `TVL for WBTC consists of the BTC deposits in custody that were used to mint WBTC`
}

'''
'''--- projects/immortal/index.js ---
const { ohmTvl } = require("../helper/ohm");

const immo = "0xE685d21b7B0FC7A248a6A8E03b8Db22d013Aa2eE";
const stakingContract = "0xA02F4e8dE9A226E8f2F2fe27B9b207fC85CFEED2";
const treasury = "0xe2adCd126b4275cD75e72Ff7ddC8cF7e43fc13D4";
const tokens = [
    ["0x918146359264C492BD6934071c6Bd31C854EDBc3", false], // CUSD
    ["0x7d63809EBF83EF54c7CE8dEd3591D4E8Fc2102eE", true] // IMMO-CUSD
]

module.exports = {
    ...ohmTvl(treasury, tokens, "celo", stakingContract, immo)
}

'''
'''--- projects/impact-market/index.js ---
const {getBlock} = require('../helper/getBlock')
const sdk = require('@defillama/sdk')

const PACTTokenAddress = "0x46c9757C5497c5B1f2eb73aE79b6B67D119B0B58"
const CELOTokenAddress = "0x471EcE3750Da237f93B8E339c536989b8978a438"
const ARITokenAddress = "0x20677d4f3d0F08e735aB512393524A3CfCEb250C"

const pactDelegatorContract = "0x8f8BB984e652Cb8D0aa7C9D6712Ec2020EB1BAb4"

async function treasury(timestamp, ethBlock, chainBlocks) {
    const chain = "celo"
    const balances = {}
    const block = await getBlock(timestamp, chain, chainBlocks, true);

    const treasuryCELO = await sdk.api.erc20.balanceOf({
      target: CELOTokenAddress,
      owner: pactDelegatorContract,
      chain: chain,
      block: block
    })

    const treasuryARI = await sdk.api.erc20.balanceOf({
      target: ARITokenAddress,
      owner: pactDelegatorContract,
      chain: chain,
      block: block
    })

    sdk.util.sumSingleBalance(balances, "celo", Number(treasuryCELO.output)/1e18)
    sdk.util.sumSingleBalance(balances, "ari-swap", Number(treasuryARI.output)/1e18)
    return balances;
}

async function staking(timestamp, ethBlock, chainBlocks) {
    const chain = "celo"
    const balances = {}
    const block = await getBlock(timestamp, chain, chainBlocks, true);

    const lockedPACT = await sdk.api.erc20.balanceOf({
      target: PACTTokenAddress,
      owner: pactDelegatorContract,
      chain: chain,
      block: block
    })

    sdk.util.sumSingleBalance(balances, "impactmarket", Number(lockedPACT.output)/1e18)
    return balances;
}

module.exports={
    celo: {
        treasury,
        staking,
        tvl: () => ({})
    }
}

'''
'''--- projects/impermax/index.js ---
const { staking } = require('../helper/staking')
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require('../helper/balances');
const { getBlock } = require('../helper/getBlock');
const xIMX = "0x363b2deac84f0100d63c7427335f8350f596bf59";
const IMX = "0x7b35ce522cb72e4077baeb96cb923a5529764a00";

function offset(chain) {
  switch (chain) {
    case 'ethereum':
      return 100
    case 'polygon':
      return 500
    case 'arbitrum':
      return 2000
    case 'moonriver':
      return 60
    case 'avax':
      return 800
    case 'fantom':
      return 1500
  };
};

function getChainTvl(graphUrls, factoriesName = "uniswapFactories", tvlName = "totalLiquidityUSD") {
  const graphQuery = gql`
      query get_tvl($block: Int) {
        ${factoriesName}(
          block: { number: $block }
        ) {
          ${tvlName}
        }
      }
      `;

  return (chain) => {
    return async (timestamp, ethBlock, chainBlocks) => {
      const block = (await getBlock(timestamp, chain, chainBlocks)) - offset(chain);
      let tvl = 0
      for (const url of graphUrls[chain]) {
        const uniswapFactories = (await request(
          url,
          graphQuery,
          {
            block,
          }
        ))[factoriesName];
        const usdTvl = Number(uniswapFactories[0][tvlName]);
        tvl += usdTvl
      }

      return toUSDTBalances(tvl);
    };
  };
};

const subgraphs = {
  'ethereum': ['impermax-finance/impermax-x-uniswap1'],
  'polygon': [
    'impermax-finance/impermax-x-uniswap-v2-polygon',
    'impermax-finance/impermax-x-uniswap-v2-polygon-v2',
  ],
  'arbitrum': ['impermax-finance/impermax-x-uniswap-v2-arbitrum'],
  'moonriver': ['impermax-finance/impermax-x-uniswap-v2-moonriver'],
  'avax': ['impermax-finance/impermax-x-uniswap-v2-avalanche'],
  'fantom': ['impermax-finance/impermax-x-uniswap-v2-fantom'],
}

const chainTvl = getChainTvl(
  Object.fromEntries(Object.entries(subgraphs).map(
    s => [s[0], s[1].map(i => i.startsWith("http") ? i : "https://api.thegraph.com/subgraphs/name/" + i)])),
  "impermaxFactories",
  "totalBalanceUSD"
);

module.exports = {
  arbitrum: {
    tvl: chainTvl('arbitrum')
  },
  ethereum: {
    tvl: chainTvl('ethereum'),
    staking: staking(xIMX, IMX, 'ethereum')
  },
  avax: {
    tvl: chainTvl('avax')
  },
  polygon: {
    tvl: chainTvl('polygon')
  },
  moonriver: {
    tvl: chainTvl('moonriver')
  },
  fantom: {
    tvl: chainTvl('fantom')
  },
};
'''
'''--- projects/impossiblefi/index.js ---
const { staking } = require("../helper/staking");
const sdk = require('@defillama/sdk')
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')
const {uniTvlExport} = require('../helper/calculateUniTvl')

const stakingAddresses = [
    "0x1d37f1e6f0cce814f367d2765ebad5448e59b91b",
    "0x1aBd0067f60513F152ff14E9cD26a62c820d022C",
    "0xfc652ea2e8a373c16f3d8c5bd25e9898b9699ecb"
]
const idia = "0x0b15ddf19d47e6a86a56148fb4afffc6929bcb89"

module.exports={
    bsc:{
        tvl: sdk.util.sumChainTvls([
            uniTvlExport(
            //factory
            "0x918d7e714243F7d9d463C37e106235dCde294ffC", 
            "bsc"),
            uniTvlExport("0x4233ad9b8b7c1ccf0818907908a7f0796a3df85f", "bsc", ()=>addr=>`bsc:${addr}`, {
                getReserves: {"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint256","name":"_reserve0","type":"uint256"},{"internalType":"uint256","name":"_reserve1","type":"uint256"}],"stateMutability":"view","type":"function"}
            })
        ]),
        staking: sdk.util.sumChainTvls(stakingAddresses.map(a=>staking(a, idia, "bsc")))
    }
}

'''
'''--- projects/increment-lending/index.js ---
const { fetchURL } = require("../helper/utils");

// increment lending info: https://app.increment.fi/markets
async function tvl() {
  const { data: tvls } = await fetchURL("https://app.increment.fi/info/tvl");
  return tvls.LendingTVL - tvls.LendingBorrow;
}
async function fetch() {
  const { data: tvls } = await fetchURL("https://app.increment.fi/info/tvl");
  return tvls.LendingTVL - tvls.LendingBorrow;
}
//denominating in tether as a placeholder for usd
async function borrowed() {
  const { data: tvls } = await fetchURL("https://app.increment.fi/info/tvl");
  return {tether: tvls.LendingBorrow};
}

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "This is the first lending protocol on the flow blockchain , and temporarily uses the project's own endpoint.",
  flow: {
    fetch: tvl,
    borrowed: borrowed
  },
  fetch
};

'''
'''--- projects/increment-swap/index.js ---
const { fetchURL } = require("../helper/utils");

// increment swap link: https://app.increment.fi/swap
// swap info: https://app.increment.fi/infos

async function tvl() {
    const { data: tvls } = await fetchURL(
        "https://app.increment.fi/info/tvl"
    );
    return tvls.DexTVL;
}
async function fetch() {
    const { data: tvls } = await fetchURL(
        "https://app.increment.fi/info/tvl"
    );
    return tvls.DexTVL;
}

module.exports = {
    methodology: "This is the first permissionless dex on the flow blockchain.",
    flow: {
        fetch: tvl,
    },
    fetch,
};

'''
'''--- projects/indexcoop/index.js ---
const sdk = require("@defillama/sdk");

const dpiAddress = "0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b";
const ethFliAddress = "0xaa6e8127831c9de45ae56bb1b0d4d4da6e5665bd";
const mviAddress = "0x72e364f2abdc788b7e918bc238b21f109cd634d7";
const cgiAddress = "0xada0a1202462085999652dc5310a7a9e2bf3ed42";
const btcFliAddress = "0x0b498ff89709d3838a063f1dfa463091f9801c2b";
const bedAddress = "0x2aF1dF3AB0ab157e1E2Ad8F88A7D04fbea0c7dc6";
const dataAddress = "0x33d63Ba1E57E54779F7dDAeaA7109349344cf5F1";
const gmiAddress = "0x47110d43175f7f2c2425e7d15792acc5817eb44f";
const icethAddress = "0x7c07f7abe10ce8e33dc6c5ad68fe033085256a84";
const tokens = [
  dpiAddress,
  ethFliAddress,
  mviAddress,
  cgiAddress,
  btcFliAddress,
  bedAddress,
  dataAddress,
  gmiAddress,
  icethAddress
];

async function tvl(timestamp, block) {
  const calls = tokens.map((token) => ({
    target: token,
  }));
  const totalSupplies = await sdk.api.abi.multiCall({
    block,
    calls,
    abi: "erc20:totalSupply",
  });
  const balances = {};
  sdk.util.sumMultiBalanceOf(balances, totalSupplies);
  return balances;
}

module.exports = {
  ethereum: {
    tvl,
  },
};

'''
'''--- projects/indexed/index.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require('../helper/balances');

const graphUrl = 'https://api.thegraph.com/subgraphs/name/indexed-finance/indexed'
const graphQuery = gql`
query get_indexes($block: Int) {
  indexPools(
    block: { number: $block }
  ) {
    name
    totalValueLockedUSD
  }
}
`;

async function tvl(timestamp, block) {
  const { indexPools } = await request(
    graphUrl,
    graphQuery,
    {
      block,
    }
  );
  const usdTvl = indexPools.reduce((total, p) => total + Number(p.totalValueLockedUSD), 0)

  return toUSDTBalances(usdTvl)
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: { tvl },
  start: 0, // WRONG!
}
'''
'''--- projects/infinitypad/contracts.json ---
{
    "chains": [
        "bsc",
        "celo",
        "fuse"
    ],
    "stakingContractBsc": "0xcf5180580c3c300cd9714d28813d4907123b0490",
    "stakingTokenBsc": "0xf07dfc2ad28ab5b09e8602418d2873fcb95e1744",
    "stakingTokenLp": "0x1998be7f13608e62eac2da735d88a576db3d9eea"
}
'''
'''--- projects/infinitypad/index.js ---
const sdk = require("@defillama/sdk");
const { stakings } = require("../helper/staking");
const { getChainTransform } = require("../helper/portedTokens");
const contracts = require("./contracts.json");
const axios = require("axios");
const { pool2s } = require("../helper/pool2");

async function fetchBalances(exports, contracts, transform, chainBlocks, chain) {
    if (!contracts[chain]) return 0;

    const balances = await sdk.api.abi.multiCall({
        calls: Object.keys(contracts[chain]).map(c => ({
            target: contracts[chain][c].tokenAddress,
            params: [ contracts[chain][c].tokenHolder ]
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks[chain],
        chain
    });

    sdk.util.sumMultiBalanceOf(exports, balances, false, transform);
};

// node test.js projects/infinitypad/index.js
function tvl(chain) {
    return async (timestamp, block, chainBlocks) => {
        const balances = {};
        const transform = await getChainTransform(chain);

        const vestingContracts = (await axios.get("https://api.infinitypad.com/get-all-vesting-contracts")).data;
        const clientVesting = {};
        for (const vestingContract of vestingContracts) {
            if (!clientVesting[vestingContract.chain_name]) {
                clientVesting[vestingContract.chain_name] = {};
            }
            clientVesting[vestingContract.chain_name][vestingContract.vesting_smart_contract_address] = {
                tokenHolder: vestingContract.vesting_smart_contract_address,
                tokenAddress: vestingContract.token_address
            };
        }

        await fetchBalances(
            balances, 
            clientVesting, 
            transform, 
            chainBlocks, 
            chain
        );

        return balances;
    };
};

const chainTVLObject = contracts.chains.reduce(
    (agg, chain) => ({ ...agg, [chain]: {tvl: tvl(chain) }}), {}
);

chainTVLObject.bsc.staking = stakings(
    [ contracts.stakingContractBsc ], 
    contracts.stakingTokenBsc,
    "bsc"
);

chainTVLObject.bsc.pool2 = pool2s(
    [ contracts.stakingContractBsc ], 
    [ contracts.stakingTokenLp ], 
    'bsc'
);

module.exports = {
    ...chainTVLObject
};
'''
'''--- projects/injective/index.js ---
const sdk = require('@defillama/sdk')
const {sumTokensSharedOwners} = require('../helper/unwrapLPs')

const inj = '0xe28b3b32b6c345a34ff64674606124dd5aceca30'
const oldHolder = '0x53f2b8cc450679d04c479a048dc3ff39a4D20D13'
const newHolder = '0xf955c57f9ea9dc8781965feae0b6a2ace2bad6f3'
async function tvl(_timestamp, ethBlock){
    const balances = {}
    await sumTokensSharedOwners(balances, [inj], [
        oldHolder,
        newHolder
    ], ethBlock)
    return balances
}
// Note: There are other ERC20 tokens in the contract address as well, notably USDT and WETH.
module.exports = {
    ethereum:{
        tvl
    }
}

'''
'''--- projects/ink-protocol/index.js ---
const {fetchURL} = require('../helper/utils');

async function tvl() {
  const coreUrl = 'https://lcd.terra.dev/wasm/contracts/terra1nlsfl8djet3z70xu2cj7s9dn7kzyzzfz5z2sd9/store?query_msg=%7B%22strategy%22:%7B%22sid%22:0%7D%7D'
  const interestUrl = 'https://lcd.terra.dev/wasm/contracts/terra1v579mvp2xxw3st7glgaurfla5pxses0jdwedde/store?query_msg=%7B%22total_vault_info%22:%7B%7D%7D'

  const core = await fetchURL(coreUrl)
  const interest = await fetchURL(interestUrl)

  return {
    'terrausd': (core.data.result.total_deposit.amount / 1e6) + (interest.data.result.anchor / 1e6)
  }
}

module.exports = {
  methodology: 'TVL counts the UST that users deposited into Ink Protocol',
  terra: {
    tvl
  },
}

'''
'''--- projects/instadapp.js ---
const retry = require("./helper/retry");
const axios = require("axios");
const {toUSDTBalances} = require('./helper/balances')

async function fetch() {
  const stats = (
    await retry(async (bail) => await axios.get(
      "https://api.internal.instadapp.io/defi/api/stats/instadapp/overall?limit=1&offset=0"
      )
    )
  ).data.stats[0];

  return toUSDTBalances(stats.totalSupplied);
}

module.exports = {
  misrepresentedTokens: true,
  doublecounted: true,
  timetravel: false,
  ethereum: {
    tvl: fetch,
  },
  
}
// node test.js projects/instadapp.js
'''
'''--- projects/instrumental/index.js ---
const sdk = require("@defillama/sdk");
const { pool2s, pool2 } = require("../helper/pool2");
const { staking } = require("../helper/staking");

// Sushi LP Staking + locking on Mainnet
const STRM_ETH_sushi = "0xb301d7efb4d46528f9cf0e5c86b065fbc9f50e9a";
const LP_staking = "0xc5124896459d3c219be821d1a9146cd51e4bc759";
const LP_locking = "0x4f4f6b428af559db1dbe3cb32e1e3500deffa799";
const STRM = "0x0edf9bc41bbc1354c70e2107f80c42cae7fbbca8";
const veSTRM = "0x62ae88697782f474b2537b890733cc15d3e01f1d";

module.exports = {
  ethereum: {
    tvl: () => ({}),
    // pool2: pool2(LP_locking, STRM_ETH_sushi, "ethereum"), // 1M TVL
    // pool2: pool2(LP_staking, STRM_ETH_sushi, "ethereum"), // 1.13M

    pool2: pool2s([LP_staking, LP_locking], [STRM_ETH_sushi], "ethereum"),
    staking: staking(veSTRM, STRM, "ethereum"), // vote escrowed STRM, TVL corresponds
  },
  methodology:
    "Instrumental can be LP'ed and LP can be staked or locked (pool2s). Plus STRM itself can be locked against veSTRM (staking). Vaults coming soon.",
};

'''
'''--- projects/insurace/abi.json ---
{
    "getStakedAmountPT": {
        "inputs": [
            {
                "internalType": "address",
                "name": "_token",
                "type": "address"
            }
        ],
        "name": "getStakedAmountPT",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/insurace/avalanchePools.json ---
{
    "pools": [
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0x544c42fBB96B39B21DF61cf322b5EDC285EE7429",
            "TokenTicker": "INSUR"
        },
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
            "TokenTicker": "AVAX"
        },
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
            "TokenTicker": "USDC"
        },
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0xc7198437980c041c805A1EDcbA50c1Ce5db95118",
            "TokenTicker": "USDT"
        },
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",
            "TokenTicker": "DAI"
        },
        {
            "StakersPool": "0xF851cBB9940F8bAebd1D0EaF259335c108E9E893",
            "PoolToken": "0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB",
            "TokenTicker": "WETH"
        }
    ]
}
'''
'''--- projects/insurace/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');

const BigNumber = require('bignumber.js');
const axios = require("axios");
const polygonPools = require('./polygonPools.json')
const avalanchePools = require('./avalanchePools.json')

async function eth(timestamp, ethBlock) {
    // ETH
    // start timestamp: 1619248141
    // start ethBlock: 12301500
    // Stakers Pool creation time, Saturday, 24 April 2021 07:09:01 AM
    if (ethBlock < 12301500) {
        throw new Error("Not yet deployed")
    }
    const { data } = await axios.get("https://files.insurace.io/public/defipulse/pools.json");
    const pools = data.pools;

    const { output: _tvlList } = await sdk.api.abi.multiCall({
        calls: pools.map((pool) => ({
            target: pool.StakersPool,
            params: pool.PoolToken,
        })),
        abi: abi["getStakedAmountPT"],
        ethBlock,
    }
    );

    const balances = {};
    _tvlList.forEach((element) => {
        let address = element.input.params[0].toLowerCase();
        if (address == "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") {
            address = "0x0000000000000000000000000000000000000000";
        }
        let balance = element.output;
        if (BigNumber(balance).toNumber() <= 0) {
            return;
        }
        balances[address] = BigNumber(balances[address] || 0).plus(balance).toFixed();
    })
    const uniLPINSUR2USDC = "0x169bf778a5eadab0209c0524ea5ce8e7a616e33b";
    /*
    await unwrapUniswapLPs(balances, [{
        token: uniLPINSUR2USDC,
        balance: balances[uniLPINSuniLPINSUR2USDCUR2USDC]
    }], ethBlock);
    */
    delete balances[uniLPINSUR2USDC];
    return balances;
}

async function bsc(timestamp, ethBlock, chainBlocks){
    // BSC
    // start bscBlock: 8312474
    // Stakers Pool creation time, Jun-15-2021 07:33:48 AM +UTC
    const bscBlock = chainBlocks["bsc"]
    if (bscBlock < 8312474) {
        throw new Error("Not yet deployed")
    }
    const { data } = await axios.get("https://files.insurace.io/public/defipulse/bscPools.json");
    const pools = data.pools;

    const { output: _tvlList } = await sdk.api.abi.multiCall({
        calls: pools.map((pool) => ({
            target: pool.StakersPool,
            params: pool.PoolToken,
        })),
        abi: abi["getStakedAmountPT"],
        bscBlock,
        chain: "bsc"
    }
    );

    const balances = {};
    _tvlList.forEach((element) => {
        let address = element.input.params[0].toLowerCase();
        if (address == "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") {
            address = "bsc:0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c";
        }else if (address == "0x3192ccddf1cdce4ff055ebc80f3f0231b86a7e30") {
            address = "0x544c42fbb96b39b21df61cf322b5edc285ee7429";
        }else{
            address = `bsc:${address}`;
        }
        let balance = element.output;
        if (BigNumber(balance).toNumber() <= 0) {
            return;
        }
        balances[address] = BigNumber(balances[address] || 0).plus(balance).toFixed();
    })
    return balances;
}

async function polygon(timestamp, ethBlock, chainBlocks) {
    const pools = polygonPools.pools;

    const { output: _tvlList } = await sdk.api.abi.multiCall({
        calls: pools.map((pool) => ({
            target: pool.StakersPool,
            params: pool.PoolToken,
        })),
        abi: abi["getStakedAmountPT"],
        block: chainBlocks.polygon,
        chain: 'polygon'
    });

    const balances = {};
    _tvlList.forEach((element) => {
        let address = element.input.params[0].toLowerCase();
        if(address === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"){
            address = "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270"
        }
        let balance = element.output;
        sdk.util.sumSingleBalance(balances, 'polygon:'+address, balance)
    })
    return balances;
}

const INSUR = "0x544c42fbb96b39b21df61cf322b5edc285ee7429"
async function avax(timestamp, ethBlock, chainBlocks) {
    const pools = avalanchePools.pools;

    const { output: _tvlList } = await sdk.api.abi.multiCall({
        calls: pools.map((pool) => ({
            target: pool.StakersPool,
            params: pool.PoolToken,
        })),
        abi: abi["getStakedAmountPT"],
        block: chainBlocks.avax,
        chain: 'avax'
    });

    const balances = {};
    _tvlList.forEach((element) => {
        let address = element.input.params[0].toLowerCase();
        if(address === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"){
            address = "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"
        }
        let balance = element.output;
        sdk.util.sumSingleBalance(balances, address===INSUR?INSUR:'avax:'+address, balance)
    })
    return balances;
}

module.exports = {
    ethereum: {
        tvl: eth,
    },
    bsc:{
        tvl: bsc
    },
    polygon:{
        tvl: polygon
    },
    avalanche:{
        tvl: avax
    },
}

'''
'''--- projects/insurace/polygonPools.json ---
{
    "pools": [
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0x8a0e8b4b0903929f47C3ea30973940D4a9702067",
            "TokenTicker": "INSUR"
        },
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
            "TokenTicker": "MATIC"
        },
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
            "TokenTicker": "USDC"
        },
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
            "TokenTicker": "USDT"
        },
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
            "TokenTicker": "DAI"
        },
        {
            "StakersPool": "0xD2171aBb60D2994CF9aCB767F2116Cf47BBF596F",
            "PoolToken": "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
            "TokenTicker": "WETH"
        }
    ]
}
'''
'''--- projects/insuredao/abi.json ---
{
  "balanceOf": {
    "constant": true,
    "inputs": [{ "name": "_owner", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "name": "balance", "type": "uint256" }],
    "type": "function"
  },
  "count": {
    "inputs": [],
    "name": "count",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "list": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "offset",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "limit",
        "type": "uint256"
      }
    ],
    "name": "list",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "_policyBooksArr",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getShieldTokenAddress": {
    "inputs": [
      {
        "internalType": "address",
        "name": "_policyBook",
        "type": "address"
      }
    ],
    "name": "getShieldTokenAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "virtualUsdtAccumulatedBalance": {
    "inputs": [],
    "name": "virtualUsdtAccumulatedBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "valueAll": {
    "inputs": [],
    "name": "valueAll",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "supply": {
    "inputs": [],
    "name": "supply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/insuredao/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { sumTokens, sumTokensAndLPs, unwrapCrv, unwrapUniswapLPs, genericUnwrapCvx, } = require('../helper/unwrapLPs');

const chain = "ethereum";

// addresses pools

const usdc = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const insure = "0xd83AE04c9eD29d6D3E6Bf720C71bc7BeB424393E";

const Vault = "0x131fb74c6fede6d6710ff224e07ce0ed8123f144";
const optimismVault = "0xCa1FeE73b00c221966E5f25226402146BdffE259";
const astarVault = "0x190dA1B9fA124BD872e9166bA3c7Dd656A11E8F8";

const VotingEscrow = "0x3dc07E60ecB3d064d20c386217ceeF8e3905916b";
const vlINSURE = "0xA12ab76a82D118e33682AcB242180B4cc0d19E29";

const uni = "0x1b459aec393d604ae6468ae3f7d7422efa2af1ca";
const uniStaking = "0xf57882cf186db61691873d33e3511a40c3c7e4da";

// =================== GET ETH usdc BALANCES =================== //
async function tvl(timestamp, block) {
  let balances = {};

  const vusdcBalances = (
    await sdk.api.abi.call({
      target: Vault,
      abi: abi["valueAll"],
      chain: chain,
      block: block,
    })
  ).output;
  sdk.util.sumSingleBalance(balances, usdc, vusdcBalances);

  return balances;
}

// =================== GET Optimism usdc BALANCES =================== //
async function optimismtvl(timestamp, block) {
  let balances = {};

  const vusdcBalances = (
    await sdk.api.abi.call({
      target: optimismVault,
      abi: abi["valueAll"],
      chain: "optimism",
      block: block,
    })
  ).output;
  sdk.util.sumSingleBalance(balances, usdc, vusdcBalances);

  return balances;
}

// =================== GET astar usdc BALANCES =================== //
async function astartvl(timestamp, block) {
  let balances = {};

  const vusdcBalances = (
    await sdk.api.abi.call({
      target: astarVault,
      abi: abi["valueAll"],
      chain: "astar",
      block: block,
    })
  ).output;
  sdk.util.sumSingleBalance(balances, usdc, vusdcBalances);

  return balances;
}

// =================== GET INSURE BALANCES =================== //
async function staking(timestamp, block) {
  let balances = {};

  const veinsureBalances = (
    await sdk.api.abi.call({
      target: VotingEscrow,
      abi: abi["supply"],
      chain: chain,
      block: block,
    })
  ).output;

  const vlinsureBalances = (
    await sdk.api.abi.call({
      target: insure,
      params: vlINSURE,
      abi: abi["balanceOf"],
      chain: chain,
      block: block,
    })
  ).output;
  
  sdk.util.sumSingleBalance(balances, insure ,veinsureBalances);
  sdk.util.sumSingleBalance(balances, insure ,vlinsureBalances);
  
  return balances;
}

async function pool2(timestamp, block) {
  const balances = {}
  await sumTokensAndLPs(balances, [
    [uni, uniStaking, true]
  ], block)
  return balances
}

module.exports = {
  ethereum: {
    tvl: tvl,
    staking: staking,
    pool2: pool2,
  },
  optimism: {
    tvl: optimismtvl,
  },
  astar: {
    tvl: astartvl,
  }
};

'''
'''--- projects/insuredefi/abi.json ---
{
  "totalPledge": {
    "inputs": [],
    "name": "totalPledge",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "totalStake": {
    "inputs": [],
    "name": "totalStake",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }

}

'''
'''--- projects/insuredefi/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const BigNumber = require("bignumber.js");

const constant = {
  treasuryPool: {
    address: "0xF4b2aa60Cd469717857a8A4129C3dB9108f54D74",
  }
};

async function underwriting(block) {
  let SURE = '0xcb86c6a22cb56b6cf40cafedb06ba0df188a416e';
  let balanceOf;
  balanceOf = await sdk.api.abi.call({
    block,
    target: SURE,
    abi: abi["balanceOf"],
    params: constant.treasuryPool.address,
  });
  balanceOf = balanceOf.output

  return { [SURE]: balanceOf }
}
//tracking SURE contributed to the community vaults.
async function tvl(timestamp, block) {
  let underwritingPool = await underwriting(block);
  
  let balances = {
    ...underwritingPool
  }

  return balances;
}

module.exports = {
  start: 1513566671, // 2020/10/21 6:34:47 (+UTC)
  ethereum: { tvl }
};

'''
'''--- projects/integral/abis/fiveGetReserves.json ---
{
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
        {
            "internalType": "uint112",
            "name": "reserve0",
            "type": "uint112"
        },
        {
            "internalType": "uint112",
            "name": "reserve1",
            "type": "uint112"
        },
        {
            "internalType": "uint32",
            "name": "lastTimestamp",
            "type": "uint32"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
}
'''
'''--- projects/integral/abis/sizeGetReserves.json ---
{
  "constant": true,
  "inputs": [],
  "name": "getReserves",
  "outputs": [
      {
          "internalType": "uint112",
          "name": "reserve0",
          "type": "uint112"
      },
      {
          "internalType": "uint112",
          "name": "reserve1",
          "type": "uint112"
      }
  ],
  "payable": false,
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/integral/abis/token0.json ---
{
    "constant": true,
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
'''
'''--- projects/integral/abis/token1.json ---
{
    "constant": true,
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
'''
'''--- projects/integral/index.js ---
const BigNumber = require('bignumber.js');
const TVL = require('./utils');

async function tvl(timestamp, block) {
  const [five, size] = await Promise.all([
    TVL(timestamp, block, 'five'),
    TVL(timestamp, block, 'size')
  ]);

  const tokenAddresses = new Set(Object.keys(five).concat(Object.keys(size)));

  const balances = (
    Array
      .from(tokenAddresses)
      .reduce((accumulator, tokenAddress) => {
        const fiveBalance = new BigNumber(five[tokenAddress] || '0');
        const sizeBalance = new BigNumber(size[tokenAddress] || '0');
        accumulator[tokenAddress] = fiveBalance.plus(sizeBalance).toFixed();

        return accumulator;
      }, {})
  );
  return balances;
}

module.exports = {
  ethereum: {
    tvl
  },
};

'''
'''--- projects/integral/utils.js ---
const BigNumber = require('bignumber.js');
const sdk = require('@defillama/sdk');

const TOKEN0_ABI = require('./abis/token0.json');
const TOKEN1_ABI = require('./abis/token1.json');
const FIVE_GET_RESERVES_ABI = require('./abis/fiveGetReserves.json');
const SIZE_GET_RESERVES_ABI = require('./abis/sizeGetReserves.json');

const FIVE_START_BLOCK = 12108732;
const FIVE_FACTORY = '0x673662e97b05e001816c380ba5a628d2e29f55d1';
const SIZE_START_BLOCK = 14422957;
const SIZE_FACTORY = '0xC480b33eE5229DE3FbDFAD1D2DCD3F3BAD0C56c6';

const Product = {
  five: 'five',
  size: 'size',
}

module.exports = async function tvl(_, block, product) {
  const pairs = await getPairs(block, product);
  const reserves = await getReserves(block, pairs, product);
  const balances = getBalances(pairs, reserves);

  return balances;
}

async function getPairAddresses(block, product) {
  const logs = await sdk.api.util.getLogs({
    keys: [],
    toBlock: block,
    target: product == Product.five ? FIVE_FACTORY : SIZE_FACTORY,
    fromBlock: product == Product.five ? FIVE_START_BLOCK : SIZE_START_BLOCK,
    topic: 'PairCreated(address,address,address,uint256)',
  });

  return logs.output
    .map(log => typeof log === 'string' ? log : `0x${log.data.slice(64 - 40 + 2, 64 + 2)}`)
    .map(pairAddress => pairAddress.toLowerCase());
}

async function getPairs(block, product) {
  const pairAddresses = await getPairAddresses(block, product);
  const [token0Addresses, token1Addresses] = await getTokenAddresses(block, pairAddresses);
  const pairs = constructPairs(token0Addresses, token1Addresses);

  return pairs;
}

async function getTokenAddresses(block, pairAddresses) {
  const [token0Addresses, token1Addresses] = await Promise.all([
    sdk.api.abi.multiCall({
      abi: TOKEN0_ABI,
      calls: pairAddresses.map(pairAddress => ({
        target: pairAddress,
      })),
      block,
    }),
    sdk.api.abi.multiCall({
      abi: TOKEN1_ABI,
      calls: pairAddresses.map(pairAddress => ({
        target: pairAddress,
      })),
      block,
    }),
  ]);

  return [token0Addresses.output, token1Addresses.output];
}

async function constructPairs(token0Addresses, token1Addresses) {
  const pairs = {};

  token0Addresses.forEach((token0Address) => {
      const tokenAddress = token0Address.output.toLowerCase();
        const pairAddress = token0Address.input.target.toLowerCase();
        pairs[pairAddress] = {
          token0Address: tokenAddress,
        }
  });

  token1Addresses.forEach((token1Address) => {
      const tokenAddress = token1Address.output.toLowerCase();
        const pairAddress = token1Address.input.target.toLowerCase();
        pairs[pairAddress] = {
          ...(pairs[pairAddress] || {}),
          token1Address: tokenAddress,
        }
  });

  return pairs;
}

async function getReserves(block, pairs, product) {
  const reserves = await sdk.api.abi.multiCall({
    abi: product == Product.five ? FIVE_GET_RESERVES_ABI : SIZE_GET_RESERVES_ABI,
    calls: Object.keys(pairs).map((pairAddress) => ({
      target: pairAddress,
    })),
    block,
  });

  return reserves.output;
}

async function getBalances(pairs, reserves) {
  return reserves.reduce((memo, reserve) => {
      const pairAddress = reserve.input.target.toLowerCase();
      const pair = pairs[pairAddress] || {};

      if (pair.token0Address) {
        const reserve0 = new BigNumber(reserve.output['0']);
        if (!reserve0.isZero()) {
          const existingBalance = new BigNumber(memo[pair.token0Address] || '0');
          memo[pair.token0Address] = existingBalance.plus(reserve0).toFixed()
        }
      }

      if (pair.token1Address) {
        const reserve1 = new BigNumber(reserve.output['1']);
        if (!reserve1.isZero()) {
          const existingBalance = new BigNumber(memo[pair.token1Address] || '0');
          memo[pair.token1Address] = existingBalance.plus(reserve1).toFixed()
        }
      }

    return memo
  }, {});
}

'''
'''--- projects/invariant/index.js ---
const retry = require("async-retry");
const axios = require("axios");

async function fetch() {
  const response = (
    await retry(
      async () => await axios.get("https://stats.invariant.app/short/mainnet")
    )
  ).data;
  return response.tvl;
}

module.exports = {
  timetravel: false,
  fetch,
  methodology: "TVL is a sum of the locked capital in each liquidity pool",
};

'''
'''--- projects/inverse/abi.json ---
{
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0xb0772d0b"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function",
    "signature": "0x6f307dc3"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "signature": "0x3b1d21a2",
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "supply": {
    "constant": true,
    "inputs": [],
    "name": "supply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/inverse/index.js ---

const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

// Anchor
const anchorStart = 11915867;
const comptroller = "0x4dcf7407ae5c07f8681e1659f626e114a7667339";
const ignore = ["0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670"]; // anDOLA will be counted through the stabilizer
const anETH = "0x697b4acAa24430F254224eB794d2a85ba1Fa1FB8";
const wETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// Stabilizer
const stabilizer = "0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd";
const dai = "0x6B175474E89094C44Da98b954EedeAC495271d0F";

// Vaults
const vaults = [
  "0x89eC5dF87a5186A0F0fa8Cb84EdD815de6047357", // inUSDC->ETH
  "0xc8f2E91dC9d198edEd1b2778F6f2a7fd5bBeac34", // inDAI->WBTC
  "0x41D079ce7282d49bf4888C71B5D9E4A02c371F9B", // inDAI->YFI
  "0x2dCdCA085af2E258654e47204e483127E0D8b277", // inDAI->ETH
];

// ask comptroller for all markets array
async function getAllTokens(block) {
  let tokens = (
    await sdk.api.abi.call({
      block,
      target: comptroller,
      params: [],
      abi: abi["getAllMarkets"],
    })
  ).output;
  return tokens.filter(function (token) {
    return ignore.indexOf(token) === -1;
  });
}

async function getAllUnderlying(block, tokens) {
  let allUnderlying = (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens.filter((token) => token !== anETH).map(
        (token) => ({
          target: token,
        })
      ),
      abi: abi["underlying"],
    })
  ).output;

  allUnderlying.push({
    input: {
      target: anETH,
    },
    success: true,
    output: wETH,
  });
  return allUnderlying;
}

async function getCashes(block, tokens) {
  return (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens.map((token) => ({
        target: token,
      })),
      abi: abi["getCash"],
    })
  ).output;
}

async function getTotalSupplies(block, tokens) {
  return (
    await sdk.api.abi.multiCall({
      block,
      calls: tokens.map((token) => ({
        target: token,
      })),
      abi: abi["totalSupply"],
    })
  ).output;
}

async function anchorTVL(block) {
  const balances = {};
  if (block < anchorStart) {
    return balances;
  }

  const tokens = await getAllTokens(block);
  const [allUnderlying, cashes] = await Promise.all([
    getAllUnderlying(block, tokens),
    getCashes(block, tokens),
  ]);

  tokens.forEach((token) => {
    let cash = cashes.find(
      (result) => result.input.target === token
    );
    let underlying = allUnderlying.find(
      (result) => result.input.target === token
    );
    if (cash && underlying) {
      balances[underlying.output] = BigNumber(
        balances[underlying.output] || 0
      ).plus(cash.output);
    }
  });

  return balances;
}

async function vaultsTVL(block) {
  const balances = {};

  const [allUnderlying, totalSupplies] = await Promise.all([
    getAllUnderlying(block, vaults),
    getTotalSupplies(block, vaults),
  ]);

  vaults.forEach((token) => {
    let totalSupply = totalSupplies.find(
      (result) => result.input.target === token
    );
    let underlying = allUnderlying.find(
      (result) => result.input.target === token
    );
    if (totalSupply && underlying) {
      balances[underlying.output] = BigNumber(
        balances[underlying.output] || 0
      ).plus(totalSupply.output);
    }
  });

  return balances;
}

async function stabilizerTVL(block) {
  if (block < anchorStart) {
    return {};
  }

  const supply = (
    await sdk.api.abi.call({
      block,
      target: stabilizer,
      abi: abi["supply"],
    })
  ).output;

  return {
    [dai]: BigNumber(supply),
  };
}

async function tvl(timestamp, block) {
  const balances = {};

  const [
    anchorBalances,
    vaultBalances,
    stabilizerBalances,
  ] = await Promise.all([
    anchorTVL(block),
    vaultsTVL(block),
    stabilizerTVL(block),
  ]);

  const lps = []
  Object.entries(anchorBalances).forEach(([token, value]) => {
    const balance = BigNumber(balances[token] || 0);
    if(token === '0xAA5A67c256e27A5d80712c51971408db3370927D'){
      token = "0x865377367054516e17014ccded1e7d814edc9ce4"
    }
    if(token === "0x5BA61c0a8c4DccCc200cd0ccC40a5725a426d002"){
      lps.push({
        token,
        balance: value.toFixed(0)
      })
    } else {
      balances[token] = balance.plus(BigNumber(value)).toFixed();
    }
  });

  Object.entries(vaultBalances).forEach(([token, value]) => {
    const balance = BigNumber(balances[token] || 0);
    balances[token] = balance.plus(BigNumber(value)).toFixed();
  });

  Object.entries(stabilizerBalances).forEach(([token, value]) => {
    const balance = BigNumber(balances[token] || 0);
    balances[token] = balance.plus(BigNumber(value)).toFixed();
  });
  await unwrapUniswapLPs(balances, lps, block)

  return balances;
}

module.exports = {
  methodology: "DOLA curve metapool replaced by DOLA",
  hallmarks: [
    [1648771200, "INV price hack"]
],
  start: 1607731200, // Dec 12 2020 00:00:00 GMT+0000
  ethereum: { tvl }
};

'''
'''--- projects/investin/index.js ---
const { default: axios } = require("axios");

const api = "https://capitalfund-api-1-8ftn8.ondigitalocean.app/solanaFunds/details";

async function fetch() {
    let aumValue = (await axios.get(api)).data.totalVolume;
    return aumValue;
}

module.exports = {
    fetch
}

'''
'''--- projects/invictus/index.js ---
const { getTokenAccountBalance, getTokenBalance } = require('../helper/solana')

async function staking() {
  const stakedInv = await getTokenAccountBalance("5EZiwr4fE1rbxpzQUWQ6N9ppkEridNwbH3dU3xUf7wPZ")
  return {
    "invictus": stakedInv
  }
}

const treasury = "6qfyGvoUqGB6AQ7xLc4pVwFNdgJSbAMkTtKkBXhLRiV1"
async function tvl() {
  const [usdc,] = await Promise.all([
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", //usdc
  ].map(t => getTokenBalance(t, treasury)))
  return {
    "usd-coin": usdc,
  }

}

module.exports = {
  deadFrom: 1648765747,
  timetravel: false,
  misrepresentedTokens: true,
  doublecounted: true,
  solana: {
    tvl,
    staking
  }
}

'''
'''--- projects/iotube/index.js ---
const retry = require("../helper/retry");
const { request, gql } = require("graphql-request");

const apiURL = "https://smart-graph.iotex.me/iotube/graphql";

const query = gql`
  query (
    $iotexTokens: [String!]!
    $ethTokens: [String!]!
    $bscTokens: [String!]!
    $polygonTokens: [String!]!
  ) {
    iotex: IoTeX {
      chainId
      CIOTX: ERC20(address: ["0x99B2B0eFb56E62E36960c20cD5ca8eC6ABD5557A"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      CYC: ERC20(address: ["0x4d7b88403aa2f502bf289584160db01ca442426c"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      Tokens: ERC20(address: $iotexTokens) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      TokenSafe: ERC20(
        address: ["0xa00744882684c3e4747faefd68d283ea44099d03"]
      ) {
        address
        symbol
        decimals
        balance: balanceUSD(account: "0xc4a29a94f12be03033daa4e6ce9b9678c26275a2")
      }
    }
    ethereum: ETH {
      chainId
      CYC: ERC20(address: ["0x8861cfF2366C1128fd699B68304aD99a0764Ef9a"]) {
        address
        symbol
        decimals
        totalSupply
				balance: market_cap
      }
      TokenSafe: ERC20(address: $ethTokens) {
        address
        symbol
        decimals
        balance: balanceUSD(account: "0xc2e0f31d739cb3153ba5760a203b3bd7c27f0d7a")
      }
    }
    bsc: BSC {
      chainId
      CIOTX: ERC20(address: ["0x2aaF50869739e317AB80A57Bf87cAA35F5b60598"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      CYC: ERC20(address: ["0x810ee35443639348adbbc467b33310d2ab43c168"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      TokenSafe: ERC20(address: $bscTokens) {
        address
        symbol
        decimals
        balance: balanceUSD(account: "0xfbe9a4138afdf1fa639a8c2818a0c4513fc4ce4b")
      }
    }
    polygon: Polygon {
      chainId
      CIOTX: ERC20(address: ["0x300211Def2a644b036A9bdd3e58159bb2074d388"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
      }
      CYC: ERC20(address: ["0xcFb54a6D2dA14ABeCD231174FC5735B4436965D8"]) {
        address
        symbol
        decimals
        totalSupply
        balance: market_cap
        
      }
      TokenSafe: ERC20(address: $polygonTokens) {
        address
        symbol
        decimals
        balance: balanceUSD(account: "0xa239f03cda98a7d2aaaa51e7bf408e5d73399e45")
      }
    }
  }
`;

const variables = {
  iotexTokens: [
    "0x0258866edaf84d6081df17660357ab20a07d0c80",
    "0xc7b93720f73b037394ce00f954f849ed484a3dea",
    "0xacee9b11cd4b3f57e58880277ac72c8c41abe4e4",
    "0xedeefaca6a1581fe2349cdfc3083d4efa8188e55",
    "0x2a6003e4b618ff3457a4a2080d028b0249b51c80",
    "0x6fbCdc1169B5130C59E72E51Ed68A84841C98cd1",
    "0x3B2bf2b523f54C4E454F08Aa286D03115aFF326c",
    "0x1CbAd85Aa66Ff3C12dc84C5881886EEB29C1bb9b",
    "0x97e6c48867fdc391a8dfe9d169ecd005d1d90283",
    "0x84abcb2832be606341a50128aeb1db43aa017449",
    "0x42C9255D5e522e83B16ea11a3BA04c2D3AfCA079",
    "0x037346E5a5722957Ac2cAb6ceb8c74fC18Cea91D",
    "0x0bDF82F276309E2efd4947Ee8E0A248b2726E8Df",
    "0x8e66c0d6b70c0b23d39f4b21a1eac52bba8ed89a",
    "0x653656f84381e8a359a268f3002621bbb14c62f8",
    "0x7f0ad63c902c67b1fa1b1102b0daffb889f5d5cb",
    "0x62a9d987cbf4c45a550deed5b57b200d7a319632",
    "0x3cdb7c48e70b854ed2fa392e21687501d84b3afc",
    "0xc04da3a99d17135857bb937d2fbb321d3b6c6a81",
    "0x295ebb8c782e186bcb70d9a8124053043d1adf5c",
    "0xe46ba98a87dca989725e9a2389975c0bbbb8f985",
    "0xaadc74127109d944e36cbd70f71fc5f0c921fc6c",
    "0x0499a3ec965136bea01e4350113a2105724785dc",
    "0x28873cEA8c26F603b15937f9985A888C5DA5Fd90",
    "0xc1B58620aD839383c662BFe80dB4514344DeC6d7",
  ],
  ethTokens: [
    "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69",
    "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69",
    "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
    "0x8861cfF2366C1128fd699B68304aD99a0764Ef9a",
    "0x4Fabb145d64652a948d72533023f6E7A623C7C53",
    "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    "0x45804880de22913dafe09f4980848ece6ecbaf78",
    "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "0x6b175474e89094c44da98b954eedeac495271d0f",
    "0xD227c3e4f3F8dE94180269eF9DC221a6efc1F4C4",
    "0xf79deaBc1406a3AD07c70877fBaEb90777B77E68",
  ],
  bscTokens: [
    "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    "0xe9e7cea3dedca5984780bafc599bd69add087d56",
    "0x810ee35443639348adbbc467b33310d2ab43c168",
    "0x2aaF50869739e317AB80A57Bf87cAA35F5b60598",
    "0x55d398326f99059ff775485246999027b3197955",
    "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
    "0x7e544f2fEDDc69b1cB12555779c824CFe100ee34",
    "0x049Dd7532148826CdE956c7B45fec8c30b514052",
    "0x049Dd7532148826CdE956c7B45fec8c30b514052",
    "0xab951271F025D93c278516e3d131e017e8a3089D",
  ],
  polygonTokens: [
    "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
    "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
    "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
    "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
    "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
    "0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a",
    "0x831753DD7087CaC61aB5644b308642cc1c33Dc13",
    "0xD6DF932A45C0f255f85145f286eA0b292B21C90B",
    "0xcFb54a6D2dA14ABeCD231174FC5735B4436965D8",
    "0x300211Def2a644b036A9bdd3e58159bb2074d388",
  ],
};
let cache = null;

const loadTvl = async () => {
  const result = cache
    ? cache
    : await retry(async (fail) => await request(apiURL, query, variables)).then(
        (res) => {
          Object.entries(res).forEach(([k, v]) => {
            res[k] = [
              ...(v.CIOTX?.filter((i) => i.balance > 0).map((i) =>
                Number(i.balance)
              ) || []),
              ...(v.Tokens?.filter((i) => i.balance > 0).map((i) =>
                Number(i.balance)
              ) || []),
              ...(v.CYC?.filter((i) => i.balance > 0).map((i) =>
                Number(i.balance)
              ) || []),
              ...(v.TokenSafe?.filter((i) => i.balance > 0).map((i) =>
                Number(i.balance)
              ) || []),
            ].reduce((acc, i) => acc + i, 0)
            if (!cache) cache = {};
            cache[res] = res[k];
          });
          return res;
        }
      );
  return result;
};

const allChains = ["iotex", "ethereum", "bsc", "polygon"].reduce((p, c) => {
  p[c] = {
    fetch: async () => {
      const tvl = await loadTvl();
      return tvl[c];
    },
  };
  return p;
}, {});

module.exports = {
  ...allChains,
  fetch: async () => {
    const tvl = await loadTvl();
    return Object.values(tvl).reduce((acc, i) => acc + i, 0)
  },
};

'''
'''--- projects/ip/index.js ---
const sdk = require('@defillama/sdk');
const {lendingMarket} = require('../helper/methodologies')

const VaultController = "0x4aaE9823Fb4C70490F1d802fC697F3ffF8D5CbE3"

const vaultSummaryAbi = {
  "inputs":
  [
    {
      "internalType": "uint96",
      "name": "start",
      "type": "uint96"
    },
    {
      "internalType": "uint96",
      "name": "stop",
      "type": "uint96"
    }
  ],
  "name": "vaultSummaries",
  "outputs":
  [
    {
      "components":
      [
        {
          "internalType": "uint96",
          "name": "id",
          "type": "uint96"
        },
        {
          "internalType": "uint192",
          "name": "borrowingPower",
          "type": "uint192"
        },
        {
          "internalType": "uint192",
          "name": "vaultLiability",
          "type": "uint192"
        },
        {
          "internalType": "address[]",
          "name": "tokenAddresses",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenBalances",
          "type": "uint256[]"
        }
      ],
      "internalType": "struct IVaultController.VaultSummary[]",
      "name": "",
      "type": "tuple[]"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}

const tokens = {
  "WETH": {
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    symbol: 'WETH',
    decimals: 18,
  },
  "USDC": {
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    symbol: 'USDC',
    decimals: 6,
  },
  "WTC":{
    address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
    symbol: 'WBTC',
    decimals: 8,
  },
  "UNI":{
    address: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
    symbol: 'UNI',
    decimals: 18,
  },
  "USDI":{
    address: "0x2A54bA2964C8Cd459Dc568853F79813a60761B58",
    symbol: 'USDI',
    decimals: 18,
  },
}

const getVaultCount = async (block) => {
  return (await sdk.api.abi.call({
    block,
    target: VaultController,
    params: [],
    abi: {name:"vaultsMinted", type:"function",stateMutability:"view",outputs:[{internalType:"uint96",type:"uint96"}]},
  })).output;
}

const getVaults = async (block) => {
  return getVaultCount()
    .then(async (c)=>{
      return (await sdk.api.abi.call({
        block,
        target: VaultController,
        params: [1,c],
        abi: vaultSummaryAbi,
      })).output;
    })
}

const getReserve = async (block) =>{
  return (await sdk.api.abi.call({
    block,
    target: tokens.USDC.address,
    params: [tokens.USDI.address],
    abi: "erc20:balanceOf",
  })).output;
}

const collateral = async (timestamp, block)=>{
  const balances = {}
  const vaults = await getVaults()
  vaults.forEach(x=>{
    x.tokenAddresses.forEach((token, i)=>{
      sdk.util.sumSingleBalance(balances, token, x.tokenBalances[i])
    })
  })
  return balances
}
const borrowed = async (timestamp, block) => {
  const balances = {}
  const vaults = await getVaults()
  vaults.forEach(x=>{
      sdk.util.sumSingleBalance(balances, tokens.USDI.address, x.vaultLiability)
  })
  return balances
}

const tvl = async (timestamp, block) => {
  const coll = await collateral(timestamp, block)
  const reserve = await getReserve(block)
  const balances  = {
    [tokens.USDC.address]: reserve,
    ...coll
  }
  return balances
}

module.exports = {
  timetravel: true,
  start: 14962974,
  ethereum: {
    tvl,
    borrowed
  },
  methodology: `${lendingMarket}.
  For Interest Protocol, TVL is Reserve + Total Collateral Value
  Reserve is found through calling USDC.getBalances(USDI)
  Balances are found through VaultController.vaultSummaries(1,VaultController.vaultsMinted())
  `
};

'''
'''--- projects/ironbank/cerc20.json ---
{
    "getCash": {
        "constant": true,
        "inputs": [],
        "name": "getCash",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "underlying": {
        "constant": true,
        "inputs": [],
        "name": "underlying",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "totalBorrows": {
        "constant": true,
        "inputs": [],
        "name": "totalBorrows",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "totalReserves": {
        "constant": true,
        "inputs": [],
        "name": "totalReserves",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/ironbank/index.js ---
const { getCompoundV2Tvl, compoundExports, usdCompoundExports } = require("../helper/compound");

const ftmSFIreplace =  addr=> addr==="0x924828a9Fb17d47D0eb64b57271D10706699Ff11" ? "0xb753428af26e81097e7fd17f40c88aaa3e04902c":`fantom:${addr}`
module.exports = {
  start: 1599552000, // 09/08/2020 @ 8:00am (UTC)
  ethereum: usdCompoundExports("0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB", "ethereum"),
  fantom: {
    tvl: getCompoundV2Tvl("0x4250a6d3bd57455d7c6821eecb6206f507576cd2", "fantom", ftmSFIreplace, undefined, undefined, false),
    borrowed: getCompoundV2Tvl("0x4250a6d3bd57455d7c6821eecb6206f507576cd2", "fantom", ftmSFIreplace, undefined, undefined, true)
  },
  avalanche:compoundExports("0x2eE80614Ccbc5e28654324a66A396458Fa5cD7Cc", "avax"),
};

'''
'''--- projects/ironfinance/abi-polygon.json ---
{
  "IronSwap": {
    "getTokenBalances": {
      "inputs": [],
      "name": "getTokenBalances",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    "getTokens": {
      "inputs": [],
      "name": "getTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  },

  "IronController": {
    "getAllMarkets": {
      "constant": true,
      "inputs": [],
      "name": "getAllMarkets",
      "outputs": [
        {
          "internalType": "contract RToken[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  },

  "rToken": {
    "getCash": {
      "constant": true,
      "inputs": [],
      "name": "getCash",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },

    "underlying": {
      "constant": true,
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },

    "symbol": {
      "constant": true,
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  }
}

'''
'''--- projects/ironfinance/index.js ---
const sdk = require('@defillama/sdk');
const abiPolygon = require('./abi-polygon.json');
const { transformAddress } = require('./utils');
const { compoundExports } = require('../helper/compound');

const Contracts = {
  polygon: {
    pools: {
      is3usd: '0x837503e8a8753ae17fb8c8151b8e6f586defcb57',
      ispusd: '0x4a783cd1b4543559ece45db47e07e0cb59e55c09',
      isxusd: '0xe440ccc13e6f273c110cf3cf4087c23a66b8e872',
      isiron: '0xCaEb732167aF742032D13A9e76881026f91Cd087',
    },
    ignoredLps: ['0xb4d09ff3da7f9e9a2ba029cb0a81a989fd7b8f17'],
    lend: {
      ironController: '0xF20fcd005AFDd3AD48C85d0222210fe168DDd10c',
    },
    wrappedNative: '0x0000000000000000000000000000000000001010',
  },
  avax: {
    pools: {
      is3usd: '0x952BDA8A83c3D5F398a686bb4e8C6DD90072d523',
    },
  },
  fantom: {
    pools: {
      is3usd: '0x952BDA8A83c3D5F398a686bb4e8C6DD90072d523',
    },
    lend: {
      ironController: '0xDc4C597E36Fc80876801df0309Cc11A7C12E0764',
    },
    wrappedNative: '0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83',
  },
};

const poolTvl = async (chain, poolAddress, block, addressTransformer) => {
  const [balances, tokens] = await Promise.all([
    sdk.api.abi.call({
      target: poolAddress,
      abi: abiPolygon.IronSwap.getTokenBalances,
      chain: chain,
      block,
    }),
    sdk.api.abi.call({
      target: poolAddress,
      abi: abiPolygon.IronSwap.getTokens,
      chain: chain,
      block,
    }),
  ]);

  const sum = {};

  tokens.output.forEach((token, i) => {
    if (
      Contracts[chain].ignoredLps &&
      Contracts[chain].ignoredLps.includes(token.toLowerCase())
    ) {
      return;
    }

    const tokenAddress = addressTransformer(token);
    sdk.util.sumSingleBalance(sum, tokenAddress, balances.output[i]);
  });

  return sum;
};

const polygonTvl = async (timestamp, ethBlock, chainBlocks) => {
  let block = chainBlocks['polygon'];
  const addressTransformer = await transformAddress('polygon');
  const tvl = {};

  for (let address of Object.values(Contracts.polygon.pools)) {
    const balances = await poolTvl(
      'polygon',
      address,
      block,
      addressTransformer,
    );

    Object.entries(balances).forEach(([token, value]) => {
      sdk.util.sumSingleBalance(tvl, token, value);
    });
  }

  return tvl;
};

const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  let tvl = {};
  const addressTransformer = await transformAddress('avax');
  for (let address of Object.values(Contracts.avax.pools)) {
    const balances = await poolTvl(
      'avax',
      address,
      chainBlocks['avax'],
      addressTransformer,
    );

    Object.entries(balances).forEach(([token, value]) => {
      sdk.util.sumSingleBalance(tvl, token, value);
    });
  }

  return tvl;
};

const fantomTvl = async (timestamp, ethBlock, chainBlocks) => {
  const addressTransformer = await transformAddress('fantom');
  const block = chainBlocks['fantom'];

  let tvl = {};
  for (let address of Object.values(Contracts.fantom.pools)) {
    const balances = await poolTvl(
      'fantom',
      address,
      block,
      addressTransformer,
    );

    Object.entries(balances).forEach(([token, value]) => {
      sdk.util.sumSingleBalance(tvl, token, value);
    });
  }

  return tvl;
};

const {tvl: polygonLending, borrowed: polygonBorrowed} =
  compoundExports(Contracts.polygon.lend.ironController, "polygon", "0xCa0F37f73174a28a64552D426590d3eD601ecCa1", Contracts.polygon.wrappedNative)
const {tvl: fantomLending, borrowed: fantomBorrowed} = 
  compoundExports(Contracts.fantom.lend.ironController, "fantom", "0xdfce3E14a8c77D32fe2455a9E56424F149E2F271", Contracts.fantom.wrappedNative)

module.exports = {
  timetravel: true,
  polygon: {
    tvl: sdk.util.sumChainTvls([polygonTvl, polygonLending]),
    borrowed: polygonBorrowed
  },
  avalanche: {
    tvl: avaxTvl,
  },
  fantom: {
    tvl:  sdk.util.sumChainTvls([fantomTvl, fantomLending]),
    borrowed: fantomBorrowed
  },
};

'''
'''--- projects/ironfinance/utils.js ---
const { transformFantomAddress, transformAvaxAddress, transformPolygonAddress } = require("../helper/portedTokens");

const transformAddress = (chain, address) => {
  switch (chain) {
    case 'polygon': 
      return Promise.resolve(address => `polygon:${address}`)
    case 'fantom': 
      return transformFantomAddress()
    case 'avax': 
      return transformAvaxAddress()
    default:
      throw 'Unsupported chain'
  }
}

module.exports = {
  transformAddress
}
'''
'''--- projects/izumi-iziswap/abi.js ---
module.exports = {
  liquidities: {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "liquidities",
    "outputs": [
      {
        "internalType": "int24",
        "name": "leftPt",
        "type": "int24"
      },
      {
        "internalType": "int24",
        "name": "rightPt",
        "type": "int24"
      },
      {
        "internalType": "uint128",
        "name": "liquidity",
        "type": "uint128"
      },
      {
        "internalType": "uint256",
        "name": "lastFeeScaleX_128",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastFeeScaleY_128",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "remainTokenX",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "remainTokenY",
        "type": "uint256"
      },
      {
        "internalType": "uint128",
        "name": "poolId",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  liquidityNum: {
    "inputs": [],
    "name": "liquidityNum",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  pool: {
    "inputs": [
      {
        "internalType": "address",
        "name": "tokenX",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "tokenY",
        "type": "address"
      },
      {
        "internalType": "uint24",
        "name": "fee",
        "type": "uint24"
      }
    ],
    "name": "pool",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  poolMetas: {
    "inputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "name": "poolMetas",
    "outputs": [
      {
        "internalType": "address",
        "name": "tokenX",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "tokenY",
        "type": "address"
      },
      {
        "internalType": "uint24",
        "name": "fee",
        "type": "uint24"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
'''
'''--- projects/izumi-iziswap/index.js ---

let abi = require('./abi')
const { sumTokens2, } = require('../helper/unwrapLPs')

const sdk = require('@defillama/sdk')
const nullAddress = '0x0000000000000000000000000000000000000000'
const poolHelper = '0x93C22Fbeff4448F2fb6e432579b0638838Ff9581'

module.exports = {
  bsc: {
    tvl: async (ts, _b, { bsc: block }) => {
      const chain = 'bsc'
      const toa = []
      let i = 1
      let foundLastPool = false
      const chunkSize = 10
      const poolMetaData = []

      do {
        const calls = []
        for (let j = i; j < i + chunkSize; j++)
          calls.push({ params: j })
        i += chunkSize
        const { output: poolMetas } = await sdk.api.abi.multiCall({
          target: poolHelper,
          abi: abi.poolMetas,
          calls,
          chain, block,
        })
        for (const { output } of poolMetas) {
          if (output.tokenX === nullAddress && output.fee === '0') {
            foundLastPool = true
            break;
          }
          poolMetaData.push(output)
        }
      } while (!foundLastPool)

      const poolCalls = poolMetaData.map(i => ({ params: [i.tokenX, i.tokenY, i.fee] }))
      const { output: pools } = await sdk.api.abi.multiCall({
        target: poolHelper,
        abi: abi.pool,
        calls: poolCalls,
        chain, block,
      })

      pools.forEach(({ output }, i) => toa.push([poolMetaData[i].tokenX, output], [poolMetaData[i].tokenY, output],))

      return sumTokens2({ tokensAndOwners: toa, chain, block })
    }
  },
  ownTokens: ['IZI', 'IUSD'],
}

'''
'''--- projects/izumi/index.js ---
const {  unwrapUniswapV3NFTs } = require('../helper/unwrapLPs')
const { staking } = require('../helper/staking')

const config = {
  ethereum: {
    pools: [
      '0x461b154b688D5171934D70F991C17d719082710C',
      '0x57AFF370686043B5d21fDd76aE4b513468B9fb3C',
      '0x8981c60ff02CDBbF2A6AC1a9F150814F9cF68f62',
      '0x99CC0A41F8006385f42aed747e2d3642a226d06E',
    ],
    pool2: [
      '0x9f58193b717449d00c7dcaf5d9F6f5AF48a09894',
      '0xbE138aD5D41FDc392AE0B61b09421987C1966CC3',
      '0xdc035e4b6fbc48103e213f9638a81defc9323b98',
    ],
  },
  polygon: {
    pools: [
      '0x01Cc44fc1246D17681B325926865cDB6242277A5',
      '0x150848c11040F6E52D4802bFFAfFBD57E6264737',
      '0x28d7BFf13c5A1227aEe2E892F8d22d8A1a84A0D4',
      '0xaFD5f7a790041761F33bFbf3dF1b54DF272F2576',
    ],
    pool2: [
      '0xC0840394978CbCDe9fCCcDE2934636853A524965',
    ],
  },
  arbitrum: {
    pools: [
      '0x1c0a560EF9f6Ff3f5c2BCCe98dC92f2649a507EF',
      '0xB2DeceA19D58ebe10ab215A04dB2EDBE52E37fA4',
      '0xbE138aD5D41FDc392AE0B61b09421987C1966CC3',
    ],
    pool2: [
      '0x0893eB041c20a34Ce524050711492Fa8377d838b',
    ],
  },
}

module.exports = {
  ownTokens: ['IZI', 'IUSD'],
}

Object.keys(config).forEach(chain => {
  const { pools, pool2 = []} = config[chain]
  module.exports[chain] = {
    tvl: getTvl(),
    pool2: getTvl(true),
  }

  function getTvl(isPool2) {
    const poolList = isPool2 ? pool2 : pools
    return async (_, _b, { [chain]: block }) => {
      return unwrapUniswapV3NFTs({ chain, block, owners: poolList, })
    }
  }
})

module.exports.ethereum.staking = staking('0xb56a454d8dac2ad4cb82337887717a2a427fcd00', '0x9ad37205d608b8b219e6a2573f922094cec5c200')

'''
'''--- projects/jade-protocol/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0x2841c20F1f4C814b1f212d9198d258D5db98eF7d"
module.exports = ohmTvl(treasury, [
    //WBNB
    ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false],
    //BUSD
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false],
    //PancakeLP
    ["0x46503d91d7a41fcbdc250e84cee9d457d082d7b4", true],
   ], "bsc", "0x097d72e1D9bbb8d0263477f9b20bEBF66f243AF4", "0x7ad7242A99F21aa543F9650A56D141C57e4F6081")
'''
'''--- projects/jaguarswap.js ---
const { transformArbitrumAddress } = require("./helper/portedTokens");
const { getBlock } = require('./helper/getBlock');
const { addFundsInMasterChef } = require('./helper/masterchef');
const { staking } = require("./helper/staking");
const STAKING_CONTRACT = "0xAd60A8cb60e052196F5B968B4bd4328A67Df27d3";
const JAGUAR = '0x31535F7A83083E3f34899F356ECC7246FBF2E82D'

const arbitrumTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const transformAddress = await transformArbitrumAddress();
  const block = await getBlock(timestamp, "arbitrum", chainBlocks)
  await addFundsInMasterChef(
    balances, STAKING_CONTRACT, block, 'arbitrum', transformAddress, undefined, [JAGUAR]);
  return balances;
};

module.exports = {
  methodology: 'All tokens and LP tokens staked on the Masterchef (0x1cCf20F4eE3EFD291267c07268BEcbFDFd192311) are counted as the TVL, with the exception of the native token(JAGUAR) which is considered staking TVL.',
  arbitrum: {
    tvl: arbitrumTvl,
    staking: staking(STAKING_CONTRACT, JAGUAR, "arbitrum", `arbitrum:${JAGUAR}`)
  },
}
// node test.js projects/jaguarswap.js

'''
'''--- projects/jarvis/abi.json ---
{
  "SynthereumPoolRegistry_getCollaterals": {"inputs":[],"name":"getCollaterals","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}, 
  "SynthereumPoolRegistry_getSyntheticTokens": {"inputs":[],"name":"getSyntheticTokens","outputs":[{"internalType":"string[]","name":"","type":"string[]"}],"stateMutability":"view","type":"function"}, 
  "SynthereumPoolRegistry_getElements": {"inputs":[{"internalType":"string","name":"syntheticTokenSymbol","type":"string"},{"internalType":"contract IERC20","name":"collateralToken","type":"address"},{"internalType":"uint8","name":"version","type":"uint8"}],"name":"getElements","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}, 
  "LiquidityPool_syntheticToken": {"inputs":[],"name":"syntheticToken","outputs":[{"internalType":"contract IERC20","name":"syntheticCurrency","type":"address"}],"stateMutability":"view","type":"function"}, 
  "LiquidityPool_getAllDerivatives": {"inputs":[],"name":"getAllDerivatives","outputs":[{"internalType":"contract IDerivative[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/jarvis/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const contracts_old = {
  ethereum:{
    usdcToken : '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
    synthCollateralContracts : ['0x48546bdd57d34cb110f011cdd1ccaae75ee17a70', '0x182d5993106573a95a182ab3a77c892713ffda56', '0x496b179d5821d1a8b6c875677e3b89a9229aab77', "0x911f0Dfc9d98Fcf6E4d07410E7aC460F19843599", "0xF47Ff36956105255E64455BfEDe4538768439066", "0x2431b64cDD6D7E9A630046d225BA4F01B3AC9D3b", "0x4e3Decbb3645551B8A19f0eA1678079FCB33fB4c", "0x767058F11800FBA6A682E73A6e79ec5eB74Fac8c", "0xbD1463F02f61676d53fd183C2B19282BFF93D099", "0xCbbA8c0645ffb8aA6ec868f6F5858F2b0eAe34DA", "0xeF4Db4AF6189aae295a680345e07E00d25ECBAAb", "0x10d00f5788c39a2bf248adfa2863fa55d83dce36"],
    liquidityPools : ['0x833407f9c6C55df59E7fe2Ed6fB86bb413536359', '0x2D8b421F3C6F14Df2887dce70b517d87d11af1E0', '0x6FF556740b30dFb092602dd5721F6D42c66A1580'] // Not AMM LP pools, just pools where money is waiting to be used for minting
  },
  polygon:{
    usdcToken : '0x2791bca1f2de4661ed88a30c99a7a9449aa84174',
    synthCollateralContracts: ['0x0fa1a6b68be5dd9132a09286a166d75480be9165', '0xa87b3e78d128dab9db656cf459c9266c4c1d5255', '0x9b0a1c61f234e2d21b6f7c0da6178dfbbaa3756f', '0x2076648e2d9d452d55f4252cba9b162a1850db48', '0x0d1534bcc572288156b97e2a2651383f1029138c', '0xd016daf08017a0647b8fff5d82b629b93c6c91f3', '0xe25d6cd64c08b986e19cab507e67e8eec6b87156', '0xb6C683B89228455B15cF1b2491cC22b529cdf2c4', '0xA4B72abA6793Ef9f5a6773941d9d039af9258d65', '0x606ac601324e894dc20e0ac9698ccaf180960456'], 
    liquidityPools: ['0xcbba8c0645ffb8aa6ec868f6f5858f2b0eae34da', '0x10d00f5788c39a2bf248adfa2863fa55d83dce36', '0xef4db4af6189aae295a680345e07e00d25ecbaab',     '0x6ca82a7e54053b102e7ec452788cc19204e831de', '0xf1a69f6937a7661a6e6f2f521f9497822bfa854c', '0x715995b91c4fa32a35514971f2f88ee2a7f59796', '0x86413032f772596034AEf76438aeF1A62Ec6121e', '0x91436EB8038ecc12c60EE79Dfe011EdBe0e6C777', '0x60E5db98d156B68bC079795096D8599d12F2DcA6', '0x09757f36838aaacd47df9de4d3f0add57513531f']
  }
}

function chainTvl_old(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    let balances = {};
    const block = chainBlocks[chain]
    const {synthCollateralContracts, liquidityPools, usdcToken} = contracts_old[chain]

    const collateralTokens = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: synthCollateralContracts.concat(liquidityPools).map(contract => ({
        target: usdcToken,
        params: [contract]
      })),
      block,
      chain
    })
    sdk.util.sumMultiBalanceOf(balances, collateralTokens, true, t=>`${chain}:${t}`)
    return balances
  }
}

// The synthpoolRegistry addresses can be found in this repo
// https://gitlab.com/jarvis-network/apps/exchange/mono-repo/-/tree/dev/libs/contracts/networks
const contracts = {
  polygon: { // 137
    version: 4, synthpoolRegistry: '0xdCE12741DF9d2CcF2A8bB611684C8151De91a7d2', 
  },
  ethereum: { // 1
    version: 4, synthpoolRegistry: '0xaB77024DdC68A3Fe942De8dDb0014738ED01A5e5', 
  },
  bsc: { // 56
    version: 5, synthpoolRegistry: '0x930A54D8Af945F6D1BED5AAF63b63fAb50a8197f', 
  },
  xdai: { // 100
    version: 5, synthpoolRegistry: '0x43a98e5C4A7F3B7f11080fc9D58b0B8A80cA954e', 
  }
}
function chainTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const { synthpoolRegistry, version } = contracts[chain]
    const block = chainBlocks[chain]
    console.log(chain, block, 'synthpoolRegistry', synthpoolRegistry)

    // Get liquidityPools by calling getElements(synth, collateral, version)
    // For v4, these are not AMM LP pools, just pools where money is waiting to be used for minting
    // For v5, the collateral is stored in the liquidity pools directly
    // Get collaterals, usually single collat, USDC on polygon, BUSD on BSC, but might be multiple collats later on
    const {output: collaterals} = await sdk.api.abi.call({
      abi: abi["SynthereumPoolRegistry_getCollaterals"],
      target: synthpoolRegistry,
      block,
      chain
    })
    // Get synth token symbols - jEUR, jCHF etc
    const {output: syntheticTokens} = await sdk.api.abi.call({
      abi: abi["SynthereumPoolRegistry_getSyntheticTokens"],
      target: synthpoolRegistry,
      block,
      chain
    })
    // Get liquidityPools by calling SynthereumPoolRegistry_getElements
    const params_list = collaterals.map(collateral => syntheticTokens.map(synth => [synth, collateral, version])).flat()
    const {output: elements_obj} = await sdk.api.abi.multiCall({
      abi: abi["SynthereumPoolRegistry_getElements"],
      calls: params_list.map(params => ({
        target: synthpoolRegistry,
        params: params
      })),
      block,
      chain
    })
    const liquidityPools = elements_obj.map(e => e.output).flat(2)

    // Retrieve synthCollateralContracts where most of the collateral is held for v4 
    if (version <= 4) {
      const synthCollateralContracts = (await sdk.api.abi.multiCall({
        abi: abi['LiquidityPool_getAllDerivatives'],
        calls: liquidityPools.map(a => ({target: a})),
        block,
        chain
      })).output.map(e => e.output).flat().filter(c => c) // filter out null contracts
      liquidityPools.push(...synthCollateralContracts)
    } 
    
    // Get balances of every LiquidityPool and SynthToken Contracts
    const tokenBalances_calls = collaterals.map(collat => 
      liquidityPools.map(contract => ({
        target: collat,
        params: [contract]
      }))
    ).flat()
    const collateralTokens = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: tokenBalances_calls,
      block,
      chain
    })
    const balances = {};
    sdk.util.sumMultiBalanceOf(balances, collateralTokens, true, t=>`${chain}:${t}`)
    return balances
  }
}

module.exports = {
  ethereum: {
    tvl: chainTvl('ethereum')
  },
  polygon: {
    tvl: chainTvl('polygon')
  },
  xdai: {
    tvl: chainTvl('xdai')
  },
  bsc: {
    tvl: chainTvl('bsc')
  }, 
  methodology: 'Count collateral used to mint jFIAT - in v4 it is held by liquidityPools and synthCollateralContracts, in v5 only in liquidityPools'
}
'''
'''--- projects/jelly/index.js ---
const { pool2s } = require("../helper/pool2");

const jelly = "0xf5f06fFa53Ad7F5914F493F16E57B56C8dd2eA80"
const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
const jellyUsdcLP = "0x64C2F792038f1FB55da1A9a22749971eAC94463E"
const sweetPool = '0xF897C014a57298DA3453f474312079cC6cB140c0'
const royalPool = '0xcC43331067234a0014d298b5226A1c22cb0ac66a'

module.exports = {
  misrepresentedTokens: true,
  methodology: 'TVL accounts for the liquidity on Sushiswap. Staking accounts for the JELLY locked in our farming contracts',
  ethereum: {
    pool2: pool2s([sweetPool, royalPool], [jellyUsdcLP], 'ethereum'),
    tvl: () => ({}),
  },
}

'''
'''--- projects/jetfuelfinance/abi.json ---
{
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balance": {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getCash": {
    "constant": true,
    "inputs": [],
    "name": "getCash",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/jetfuelfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");
const { compoundExports } = require("../helper/compound");
const {calculateUniTvl} = require("../helper/calculateUniTvl");

// Jetswap section
const factory = "0x0eb58E5c8aA63314ff5547289185cC4583DfCBD5";

/*Vaults found via Jetfuel 1 deployer, some it could not be tracked
* so there is missing a small % of tvl compare to their official site stated amount ~60m
*/
const vaults = [
  "0x4149531aeD145a15ccc361C469B0c79FE26B4F1c",
  "0x1Ae8F478571E7BC7caC067a8FCD298749BE722AE",
  "0x06FD5CaB123990a0dd0Ba2130Bfa76Da26C91b43",
  "0x7F2E9e374E97f171c9eD3E0910111b15B9045644",
  "0xF2F11389cE9cf23c37B03131Df914772BA17e664",
  "0x755aAC39603599D2a10C407C3D06deE96999Ae90",
  "0xD0B1DC1B39A730D634902c01C61316A97afA31B5",
  "0x465A5e8501Bf38898A8AeAd87f0d864AdCc826a4",
  "0xED2097330741aC6AA574C0EDa26A7ad41c976fb0",
  "0xA10983a758DbD8998215dB48b44A0aDa77C5f7DB",
  "0xd1C249dc749E6458813Da36a3dE0Bb4A75cd3104",
  "0x229e084E2C88a09aA04eEdbF93c3D728D06DAE58",
  "0x229eeDacA481A673cd7F318Dffd35489Fdb3c888",
  "0x99cC3060487fA635Cfd9BCFf69417D225b3f0104",
  "0x29C12B9cE7df205C944725520718D10aafA78433",
  "0x804ef864d199E28C1F48d179FAeb53683B671875",
  "0x980edEc0A2a62E3D396A1a60EE8101f5116De316",
  "0x4e52Ae85329474EC9e2469bdD1d0491EA2C41254",
  "0x032bb900363BE7A2fA566694A7F065F13820EcDA",
  "0x6bA6c5aa9b3B24Bb786E31adb4AE36397678a64b",
  "0xA6d55074b038a082748c88D9C3E56821C44474ff",
];

const single_side_vault = [
  //wbnb vault
  "0x15e84D6eD8997590E02b25d3D3CeEe9686753306",
  // eth vault
  "0x647db6Dce3C36Ac1a3BA48f0F6B767A6c73E22D2",
  // btcb vault
  "0xeaa8234D9bf8Dfc6C8c24D3d24BE3cAd256450EF",
];

const single_side_assets = [
  "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "0x250632378e573c6be1ac2f97fcdf00515d0aa91b",
  "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c",
];

const bscTvl = async (timestamp, block, chainBlocks) => {
  // Jetswap section
  const balances = await calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks.bsc, "bsc", factory, 0, true)

  // Vault section in their repo
  const vault_balances = (
    await sdk.api.abi.multiCall({
      abi: abi.balance,
      calls: vaults.map((address) => ({ target: address })),
      chain: "bsc",
      block: chainBlocks["bsc"],
    })
  ).output.map((el) => el.output);

  const vault_tokens = (
    await sdk.api.abi.multiCall({
      abi: abi.token,
      calls: vaults.map((address) => ({ target: address })),
      chain: "bsc",
      block: chainBlocks["bsc"],
    })
  ).output.map((el) => el.output);

  const lpPositions = [];

  vault_balances.forEach((vault, idx) => {
    lpPositions.push({
      token: vault_tokens[idx],
      balance: vault,
    });
  });

  const transformAddress = await transformBscAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["bsc"],
    "bsc",
    transformAddress
  );

  const vault_single_side_balances = (
    await sdk.api.abi.multiCall({
      abi: abi.balance,
      calls: single_side_vault.map((address) => ({ target: address })),
      chain: "bsc",
      block: chainBlocks["bsc"],
    })
  ).output.map((el) => el.output);

  vault_single_side_balances.forEach((bal, idx) => {
    sdk.util.sumSingleBalance(balances, `bsc:${single_side_assets[idx]}`, bal);
  });

  return balances;
};

const {tvl:lendingTvl, borrowed} = compoundExports("0x67340bd16ee5649a37015138b3393eb5ad17c195", "bsc", "0xE24146585E882B6b59ca9bFaaaFfED201E4E5491", "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c")

module.exports = {
  timetravel: true,
  bsc: {
    tvl: sdk.util.sumChainTvls([bscTvl, lendingTvl]),
    borrowed
  },
};

'''
'''--- projects/jetmine/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0xF7711748bF74f2dDC261e745Ff43FdD8abfD1200"
const jetmine = "0x71BE8F5F245c1F5aa5727DFdB36aAD3C71a4c26b"
const jetmineFtmLP = "0x9f0121654bb430192CF2Fc2fc5B6673C97d5DFA3";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [jetmine, jetmineFtmLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, jetmine, "fantom"),
      pool2: pool2Exports(chef, [jetmineFtmLP], "fantom"),
  },
  
} 
'''
'''--- projects/jetprotocol.js ---
const { getTokenBalance } = require("./helper/solana");

async function borrowed() {
  const [usdcAmount, ethAmount, solAmount, btcAmount] = await Promise.all([
    getTokenBalance(
      "G17Yu6f4emBeRLWS1Y4cNJMTmT5LUGJH95zK6253KoAH",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "5v8QVtwqZjSdJxhCF2xWrAopiyhDgJTdgeQZ5aWmStnE",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "A9S9XVCuNXHnJGFhxBhsTmJNHa6aPccF5NCAGgE4BxGF",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "7SXpzVgqMvDEWkv9jtDUZVjkBPUbn8EUitKwV22WCpxt",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
  ]);
  return {
    bitcoin: btcAmount,
    "usd-coin": usdcAmount,
    ethereum: ethAmount,
    solana: solAmount,
  };
}

async function tvl() {
  const [usdcAmount, ethAmount, solAmount, btcAmount] = await Promise.all([
    getTokenBalance(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "So11111111111111111111111111111111111111112",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
    getTokenBalance(
      "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
      "7gpj9cpzBBW9Ci1yMwWz7iGbQYpm5fZmadNQyrYsqch8"
    ),
  ]);
  return {
    bitcoin: btcAmount,
    "usd-coin": usdcAmount,
    ethereum: ethAmount,
    solana: solAmount,
  };
}

module.exports = {
  timetravel: false,
  solana: {
    tvl,
    borrowed,
  },
  methodology:
    "TVL consists of deposits made to the protocol and like other lending protocols, borrowed tokens are not counted. Coingecko is used to price tokens.",
};

'''
'''--- projects/jetswap/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require("../helper/calculateUniTvl");

const bscFactory = "0x0eb58E5c8aA63314ff5547289185cC4583DfCBD5";
const polygonFactory = "0x668ad0ed2622C62E24f0d5ab6B6Ac1b9D2cD4AC7";
const fantomFactory = "0xf6488205957f0b4497053d6422F49e27944eE3Dd";

const WINGS_TOKEN_BSC = "0x0487b824c8261462f88940f97053e65bdb498446";
const WINGS_TOKEN_POLYGON = "0x845E76A8691423fbc4ECb8Dd77556Cb61c09eE25";
const WINGS_TOKEN_FANTOM = "0x3D8f1ACCEe8e263F837138829B6C4517473d0688";

const MASTER_BSC = "0x63d6EC1cDef04464287e2af710FFef9780B6f9F5";
const MASTER_POLYGON = "0x4e22399070aD5aD7f7BEb7d3A7b543e8EcBf1d85";
const MASTER_FANTOM = "0x9180583C1ab03587b545629dd60D2be0bf1DF4f2";

async function bscTvl(timestamp, block, chainBlocks) {
  let balances = await calculateUniTvl(
    (addr) => `bsc:${addr}`,
    chainBlocks.bsc,
    "bsc",
    bscFactory,
    0,
    true
  );
  return balances;
}

async function polygonTvl(timestamp, block, chainBlocks) {
  let balances = calculateUniTvl(
    (addr) => `polygon:${addr}`,
    chainBlocks.polygon,
    "polygon",
    polygonFactory,
    0,
    true
  );
  return balances;
}

async function fantomTvl(timestamp, block, chainBlocks) {
  let balances = calculateUniTvl(
    (addr) => `fantom:${addr}`,
    chainBlocks.fantom,
    "fantom",
    fantomFactory,
    0,
    true
  );
  return balances;
}

function staking(masterchef, token, chain) {
  return async (_timestamp, _block, chainBlocks) => {
    let balances = {};
    let balance = (
      await sdk.api.erc20.balanceOf({
        target: token,
        owner: masterchef,
        block: chainBlocks[chain],
        chain,
      })
    ).output;
    sdk.util.sumSingleBalance(balances, `bsc:${WINGS_TOKEN_BSC}`, balance);
    return balances;
  };
}

module.exports = {
  bsc: {
    tvl: bscTvl,
    staking: staking(MASTER_BSC, WINGS_TOKEN_BSC, "bsc"),
  },
  polygon: {
    tvl: polygonTvl,
    staking: staking(MASTER_POLYGON, WINGS_TOKEN_POLYGON, "polygon"),
  },
  fantom: {
    tvl: fantomTvl,
    staking: staking(MASTER_FANTOM, WINGS_TOKEN_FANTOM, "fantom"),
  },
};

'''
'''--- projects/jones-dao/abi.json ---
{
    "MANAGEMENT_WINDOW_OPEN": {
        "inputs": [],
        "name": "MANAGEMENT_WINDOW_OPEN",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "snapshotVaultBalance": {
        "inputs": [],
        "name": "snapshotVaultBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "snapshotAssetBalance": {
        "inputs": [],
        "name": "snapshotAssetBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/jones-dao/index.js ---
const sdk = require("@defillama/sdk");
const { pool2s } = require("../helper/pool2");
const { stakings } = require("../helper/staking");
const abi = require("./abi.json");

const jones = "0x10393c20975cf177a3513071bc110f7962cd67da";
const jonesStaking = [
    "0xf1a26cf6309a59794da29b5b2e6fabd3070d470f", 
    "0xb94d1959084081c5a11C460012Ab522F5a0FD756",
    "0x808A84063a586E680b7699be20a4Ec958ADfdF86"
];

const ethVault = "0x6be861aA87009331bF62E22D418Ab666e88B1354";

const vaultandCollateral = [
    ["0x9a62E407028961EaC4538453Cb5D97038b69C814", "0x8d9ba570d6cb60c7e3e0f31343efe75ab8e65fb1"],// gOHM
    ["0xBa3386D94FC593a1e9A5b57fF02524396080f7b4", "0x6c2c06790b3e3e3c38e12ee22f8183b37a13ee55"],// DPX

    ["0xF46Ce0C13577232D5F29D9Bd78a9Cab278755346", "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"],// WETH
    ["0x8883E5bb2920bBE766A2c9e86ad9aA45a573f3F5", "0x8d9ba570d6cb60c7e3e0f31343efe75ab8e65fb1"],// gOHM
    ["0x5BA98Ad75AB87eB90fFc2b680bCfC6b9030E1246", "0x32Eb7902D4134bf98A28b963D26de779AF92A212"],// rDPX
    ["0x42448fDDCec02124cf6dB19a9f91Dea7bB0e88e5", "0x32Eb7902D4134bf98A28b963D26de779AF92A212"],// DPX 
]

const jTokenToToken = {
    "0x662d0f9ff837a51cf89a1fe7e0882a906dac08a3": "arbitrum:0x82af49447d8a07e3bd95bd0d56f35241523fbab1", // jETH
    "0x5375616bb6c52a90439ff96882a986d8fcdce421": "arbitrum:0x8d9ba570d6cb60c7e3e0f31343efe75ab8e65fb1", // jgOHM,
    "0xf018865b26ffab9cd1735dcca549d95b0cb9ea19": "arbitrum:0x6c2c06790b3e3e3c38e12ee22f8183b37a13ee55", // jDPX
    "0x1f6fa7a58701b3773b08a1a16d06b656b0eccb23": "arbitrum:0x32eb7902d4134bf98a28b963d26de779af92a212" // jrdpx
}

const lpStaking = [
    "0x360a766F30F0Ba57d2865eFb32502FB800b14dD3", // JONES-ETH LP 
    "0x13f6A63867046107780Bc3fEBdeE90E7AfCdfd99", // JONES-USDC LP 
    "0xBAc58e8b57935A0B60D5Cb4cd9F6C21049595F04", // jETH-ETH LP 
    "0x7eCe38dBE9D61D0d9Bf2D804A87A7d21b5937a56", // jgOHM-gOHM LP
    "0x5723be83199C9Ec68ED0Ac979e98381224870e7f", // jDPX-DPX LP
    "0xb94d1959084081c5a11C460012Ab522F5a0FD756" // Masterchef
]

const lps = [
    "0xe8EE01aE5959D3231506FcDeF2d5F3E85987a39c", // JONES-ETH LP
    "0xa6efc26daa4bb2b9bf5d23a0bc202a2badc2b59e", // JONES-USDC LP
    "0xdf1a6dd4e5b77d7f2143ed73074be26c806754c5", // jETH-ETH LP
    "0x292d1587a6bb37e34574c9ad5993f221d8a5616c", // jgOHM-gOHM LP
    "0xeeb24360c8c7a87933d16b0075e10e1a30ad65b7", // jDPX-DPX LP
    "0x110a0f39b15D04f2F348B61Bd741429C7d188d3F", // RDPX-jRDPX LP
]

async function tvl(timestamp, block, chainBlocks) {
    let balances = {};
    block = chainBlocks.arbitrum;
    const chain = "arbitrum";

    const ethManagementWindow = (await sdk.api.abi.call({
        target: ethVault,
        abi: abi.MANAGEMENT_WINDOW_OPEN,
        block,
        chain
    })).output; // node test.js projects/jones-dao/index.js
    if (ethManagementWindow === true) {
        const ethSnapshot = (await sdk.api.abi.call({
            target: ethVault,
            abi: abi.snapshotVaultBalance,
            block,
            chain
        })).output;
        sdk.util.sumSingleBalance(balances, "arbitrum:0x82af49447d8a07e3bd95bd0d56f35241523fbab1", ethSnapshot);
    } else {
        const ethBalance = (await sdk.api.eth.getBalance({
            target: ethVault,
            block,
            chain
        })).output;
        sdk.util.sumSingleBalance(balances, "arbitrum:0x82af49447d8a07e3bd95bd0d56f35241523fbab1", ethBalance);
    }

    const vaultManagementWindows = (await sdk.api.abi.multiCall({
        calls: vaultandCollateral.map(p => ({
            target: p[0]
        })),
        abi: abi.MANAGEMENT_WINDOW_OPEN,
        block,
        chain
    })).output;

    const vaultSnapshots = (await sdk.api.abi.multiCall({
        calls: vaultandCollateral.map(p => ({
            target: p[0]
        })),
        abi: abi.snapshotVaultBalance,
        block,
        chain
    })).output;

    const vaultBalances = (await sdk.api.abi.multiCall({
        calls: vaultandCollateral.map(p => ({
            target: p[1],
            params: p[0]
        })),
        abi: "erc20:balanceOf",
        block,
        chain
    })).output;

    const vaultAssetBalances = (await sdk.api.abi.multiCall({
        calls: vaultandCollateral.map(p => ({
            target: p[0]
        })),
        abi: abi.snapshotAssetBalance,
        block,
        chain
    })).output;

    for (let i = 0; i < vaultandCollateral.length; i++) {
        if (vaultManagementWindows[i].output === true) {
            sdk.util.sumSingleBalance(balances, `arbitrum:${vaultandCollateral[i][1]}`, vaultSnapshots[i].output);
        } else if (vaultAssetBalances[i].success === true) {
            sdk.util.sumSingleBalance(balances, `arbitrum:${vaultandCollateral[i][1]}`, vaultAssetBalances[i].output);
        } else {
            sdk.util.sumSingleBalance(balances, `arbitrum:${vaultandCollateral[i][1]}`, vaultBalances[i].output);
        }
    }

    return balances;
}

module.exports = {
    misrepresentedTokens: true,
    arbitrum: {
        tvl,
        pool2: pool2s(lpStaking, lps, "arbitrum", addr=>{
            addr = addr.toLowerCase();
            if (jTokenToToken[addr] !== undefined) {
                return jTokenToToken[addr];
            }
            return `arbitrum:${addr}`;
        }),
        staking: stakings(jonesStaking, jones, "arbitrum")
    }
}
'''
'''--- projects/joystickclub/index.js ---
const sdk = require('@defillama/sdk');
const { getBlock } = require('../helper/getBlock');
const { default: BigNumber } = require('bignumber.js');

const CHAIN = "smartbch"

const JOYBOT_STAKING_CONTRACT = "0x498B8524c7C309471b65aEAC4f16551776B80e0F"

const staking = async (timestamp, ethBlock, chainBlocks) => {
    const block = await getBlock(timestamp, CHAIN, chainBlocks, false)
    const total = (await sdk.api.abi.call({
        target: JOYBOT_STAKING_CONTRACT,
        abi: {
            "inputs": [],
            "name": "_totalSupply",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
        chain: CHAIN,
        block
    })).output

    const floorPrice = 500; // 500 JOY to mint an NFT
    return { 'joystick-2': BigNumber(total).multipliedBy(floorPrice) }
}

module.exports = {
    misrepresentedTokens: false,
    methodology: "Total value of NFTs sent to staking contract is counted towards staking metric",
    smartbch: {
        tvl: () => ({}),
        staking: staking,
    },
}

'''
'''--- projects/jpeg-d/index.js ---
const { staking } = require("../helper/staking")
const { pool2 } = require("../helper/pool2")

const JPEG = "0xe80c0cd204d654cebe8dd64a4857cab6be8345a3"
const JPEG_WETH_SLP = "0xdb06a76733528761eda47d356647297bc35a98bd"
const staking_contract = "0x3eed641562ac83526d7941e4326559e7b607556b"

module.exports = {
  methodology: `TVL for JPEG'd consists of the staking of JPEG and pool2 of the sushi JPEG/WETH LP`, 
  ethereum:{
    tvl: () => ({}),
    staking: staking(staking_contract, JPEG, "ethereum"), 
    pool2: pool2(staking_contract, JPEG_WETH_SLP, "ethereum"), 
  }
}
'''
'''--- projects/jpool.js ---
const {getTokenSupply} = require('./helper/solana')

async function tvl(){
    const supply = await getTokenSupply("7Q2afV64in6N6SeZsAAB81TJzwDoD6zpqmHkzi9Dcavn")
    return {
        jpool: supply
    }
}

module.exports={
    timetravel: false,
    methodology: "JSOL total supply as it's equal to the SOL staked",
    solana:{
        tvl
    }
}
'''
'''--- projects/jswap-finance/index.js ---

const factory = "0xd654CbF99F2907F06c88399AE123606121247D5C"

const { getUniTVL } = require('../helper/unknownTokens');

module.exports = {
  okexchain: {
    tvl: getUniTVL({
      factory,
      chain: 'okexchain',
      coreAssets: [
        "0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15", // WOKT
        "0x382bB369d343125BfB2117af9c149795C6C65C50", // USDT
        "0x54e4622DC504176b3BB432dCCAf504569699a7fF", // BTCK
        "0xEF71CA2EE68F45B9Ad6F72fbdb33d707b872315C", // ETHK
        "0xdF54B6c6195EA4d948D03bfD818D365cf175cFC2", // OKB
        "0xab0d1578216A545532882e420A8C61Ea07B00B12", // KST
        "0x8179d97eb6488860d816e3ecafe694a4153f216c", // che
      ],
    })
  },
}

'''
'''--- projects/jumboexchange/index.js ---
const { call, sumSingleBalance, } = require('../helper/near')
const { getFixBalances } = require('../helper/portedTokens')

const PROJECT_CONTRACT = 'v1.jumbo_exchange.near'

async function tvl() {
  const fixBalances = await getFixBalances('near')

  const balances = {}
  let poolIndex = 0
  const numberOfPools = await call(PROJECT_CONTRACT, 'get_number_of_pools', {})

  do {
    const pools = await call(PROJECT_CONTRACT, 'get_pools', { from_index: poolIndex, limit: 100 })

    pools
      .filter(({ shares_total_supply }) => +shares_total_supply > 0) // Token pair must have some liquidity
      .map(({ token_account_ids, pool_kind, amounts }) => {
        if (!['SIMPLE_POOL', 'STABLE_SWAP'].includes(pool_kind)) throw new Error('Unknown pool kind, add handler')
        token_account_ids.forEach((token, index) => {
          sumSingleBalance(balances, token, amounts[index])
        })
      })

    poolIndex += 100
  } while (poolIndex < numberOfPools)

  await fixBalances(balances)
  return balances
}

module.exports = {
  near: {
    tvl,
  },
  methodology: 'Summed up all the tokens deposited in their pool'
};

'''
'''--- projects/jupiterswap/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
    misrepresentedTokens: true,
    methodology: "Factory addresses (0xc08BAEA14C14f25bcafe3e3E05550715505eF3dE for kava) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    kava: {
        tvl: getUniTVL({
            factory: '0xc08BAEA14C14f25bcafe3e3E05550715505eF3dE',
            chain: 'kava',
            coreAssets: [
                '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b'
            ]
        }),
    }
}

'''
'''--- projects/justCryptos/index.js ---
const axios = require('axios')

let nowDate = new Date();
nowDate.setFullYear(nowDate.getFullYear() - 1);
let T = parseInt(nowDate.getTime() / 1000);

const url = "https://apilist.tronscan.org/api/defiTvl?type=tvlline&project=&startTime=" + T;

function getItemByName (projectName, listArr) {
  for (let i = 0; i < listArr.length; i++) {
    if (listArr[i].project === projectName) {
      return listArr[i];
    }
  }
}

async function fetch(){
    const pools = await axios.get(url);
    let item = getItemByName('Just Cryptos', pools.data.projects);
    return parseInt(item.locked);
}

module.exports = {
    fetch
}
'''
'''--- projects/justSwap/index.js ---
const axios = require('axios')
const {getApiTvl} = require('../helper/historicalApi')
const sdk = require('@defillama/sdk')

async function v1(timestamp){
    return getApiTvl(timestamp, async ()=>{
      const r = await axios.get("https://abc.ablesdxd.link/swap/scan/statusinfo")
      return Number(r.data.data.totalLiquidity)
    }, async()=>{
      const r = await axios.get("https://abc.ablesdxd.link/swap/scan/liquidityall")
      // {liquidity: "0.000000000000000000", time: 1597492800000}
      return r.data.data.map(d=>({
        date: d.time/1000,
        totalLiquidityUSD: Number(d.liquidity)
      }))
    })
}

async function v2(timestamp){
  return getApiTvl(timestamp, async ()=>{
    const r = await axios.get("https://pabc.ablesdxd.link/swapv2/scan/getStatusInfo")
    return Number(r.data.data.totalLiquidityUsd)
  }, async()=>{
    const r = await axios.get("https://pabc.ablesdxd.link/swapv2/scan/getAllLiquidityVolume")
    // {liquidity: "0.000000000000000000", time: 1597492800000}
    return r.data.data.map(d=>({
      date: d.time/1000,
      totalLiquidityUSD: Number(d.liquidity)
    }))
  })
}

module.exports = {
    timetravel: true,
    misrepresentedTokens: true,
    methodology: "We get liquidity from the ablesdxd.link API",
    tron:{
      tvl: sdk.util.sumChainTvls([v1,v2])
    }
}

'''
'''--- projects/justlend.js ---
const retry = require('./helper/retry');
const axios = require('axios');
const { toUSDTBalances } = require('./helper/balances');

async function core() {
  const response = (
    await retry(
      async (bail) => await axios.get(
        'https://labc.ablesdxd.link/justlend/markets/dashboard')
    )
  ).data.data;

  const tvl = response.totalDepositedUSD - response.totalBorrowedUSD;

  return toUSDTBalances(tvl);
};

async function historical() {
  const response = (
    await retry(
      async (bail) => await axios.get(
        'https://labc.ablesdxd.link/justlend/markets/dashboard')
    )
  ).data.data;

  const tvl = response.totalDepositedUSD - response.totalBorrowedUSD;

  return toUSDTBalances(tvl);
};

// node test.js projects/justlend.js
async function pool2() {
  const response = (
    await retry(
      async (bail) => await axios.get(
        'https://apilist.tronscan.org/api/defiTvl')
    )
  ).data;

  const justLend = (response.projects.filter(
    p => p.project == "JustLend"))[0];

  const coreTVL = await core();

  if (coreTVL > 0) {
    return justLend.locked - coreTVL;
  } else {
    return 0;
  };
};
module.exports = {
  misrepresentedTokens: true,
  tron: {
    tvl: core,
    pool2,
  },
};

'''
'''--- projects/justmoney/index.js ---
const sdk = require('@defillama/sdk')
const { getFixBalances } = require('../helper/portedTokens')
const { getTokenBalance } = require('../helper/tron')
const { getUniTVL } = require('../helper/unknownTokens')
const { sleep } = require('../helper/utils')

const tokens = {
  ACTIV: { 'address': 'TVoxBVmFuBM7dsRnfi1V8v1iupv4uyPifN', 'id': '_activ' },
  BBT: { 'address': 'TGyZUWrL97mmmYJwrC7ZCLVrhbzvHmmWPL', 'id': '_bbt' },
  BEMT: { 'address': 'TBp6ZMzkxci5o4sJjFa6Fo9Wy36gcubQLW', 'id': 'bem' },
  BTT: { 'address': 'TAFjULxiVgT4qWk6UZwjqwZXTSaGaqnVp4', 'id': 'bittorrent' },
  CREED: { 'address': 'TM2fhs1CFiS696VW13s3oBuDdPazCEGcfJ', 'id': '_creed' },
  CREEDX: { 'address': 'TQSC8P2nLsawUZHF6iMAD6KPH8HdJXFWYi', 'id': '_creedx' },
  CUBE: { 'address': 'TQxzbBVFRFUgHXnhyCRiatrkwX9BAJnHam', 'id': '_cube' },
  CYFM: { 'address': 'TZ5jA9F5zGRgi9qk9ATMu6D7wyEpnxQGJh', 'id': 'cyberfm' },
  ICR: { 'address': 'TKqvrVG7a2zJvQ3VysLoiz9ijuMNDehwy7', 'id': 'intercrone' },
  JM: { 'address': 'TVHH59uHVpHzLDMFFpUgCx2dNAQqCzPhcR', 'id': 'justmoney-2' },
  JST: { 'address': 'TCFLL5dx5ZJdKnWuesXxi1VPwjLVmWZZy9', 'id': 'just' },
  KLV: { 'address': 'TVj7RNVHy6thbM7BWdSe9G6gXwKhjhdNZS', 'id': 'klever' },
  KODX: { 'address': 'TTUwzoZAK6rpDjpSh8B2XFTnxGfbMLHJaq', 'id': 'kodx' },
  KTY: { 'address': 'TTroZqb95vmsw4kppupQ8tVEzkNDDP2bcG', 'id': '_kty' },
  LDA: { 'address': 'TNP1D18nJCqQHhv4i38qiNtUUuL5VyNoC1', 'id': '_lda' },
  LUMI: { 'address': 'TDBNKiYQ8yfJtT5MDP3byu7f1npJuG2DBN', 'id': 'lumi-credits' },
  NFT: { 'address': 'TFczxzPhnThNSqr5by8tvxsdCFRRz6cPNq', 'id': 'apenft' },
  NOLE: { 'address': 'TPt8DTDBZYfJ9fuyRjdWJr4PP68tRfptLG', 'id': '_nole' },
  OLDJM: { 'address': 'TT8VkSkW6igkiRsV5WiJgLrsbVwY5bLLjA', 'id': 'justmoney' },
  SafeMoney: { 'address': 'TNBrVEzuVYbNbGF2ua3ivSX5Y5V9N4xhax', 'id': 'safemoney' },
  SUN: { 'address': 'TSSMHYeV2uE9qYH95DqyoCuNCzEL1NvU3S', 'id': 'sun-token' },
  TBT: { 'address': 'TJpCQC2gJRAbqG9nuQHvzYBmCuYJQzP3SS', 'id': '_tbt' },
  TNT: { 'address': 'TL33cN6t22RcKyqPKkb14iVrPHDFaFMH7t', 'id': '_tnt' },
  TRX: { 'address': 'TNUC9Qb1rRpS5CbWLmNMxXBjyFoydXjWFR', 'id': 'tron' },
  turu: { 'address': 'TK8K7HFDLkhYS6XnFC8MKQkVK6Xq8D13qJ', 'id': '_turu' },
  TREX: { 'address': 'THyYjzy42cy83Nwg6pbsUTcV1GBrPPqGE5', 'id': '_trex' },
  TWJ: { 'address': 'TNq5PbSssK5XfmSYU4Aox4XkgTdpDoEDiY', 'id': '_twj' },
  USDD: { 'address': 'TPYmHEhy5n8TCEfYGqW2rPxsghSfzghPDn', 'id': 'usdd' },
  USDT: { 'address': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t', 'id': 'tether' },
  USTX: { 'address': 'TYX2iy3i3793YgKU5vqKxDnLpiBMSa5EdV', 'id': '_ustx' },
  VBS: { 'address': 'TJRc6ZTMhHEPrWPtfsVvXW1mxHPLw1arZo', 'id': '_vbs' },
  WOX: { 'address': 'TYVFMntFj7xLMxp1CvuXwg9LpPw1dPwWhM', 'id': '_wox' },
  ZLF: { 'address': 'TXoPCbHtWTerfiNjFBpJdMQqQJoXoT87pq', 'id': '_zlf' },
}

const pairs = [
  [ tokens.TRX, tokens.OLDJM, 'TFijK2dCUsrXoZM7PYhFqnM9F4Tac8uBJt' ],
  [ tokens.TRX, tokens.USDT, 'TYA7DfE44XFsZEpBm7M2HAmEgU5kCtDDXg' ],
  [ tokens.USDT, tokens.OLDJM, 'TSGv8is6ZMeHRwMQCvq6f16YFTLbw2bpmr' ],
  [ tokens.SafeMoney, tokens.TRX, 'TTqB2CRJ2PF9qbCRkSVVGsFbx9mZUFNZS3' ],
  [ tokens.NOLE, tokens.USDT, 'TEg25qPxj9zecferiUbf2Senqmbuae7p55' ],
  [ tokens.TRX, tokens.SUN, 'TGzv3DHcsbxmCNj1Cd1W6P3Ao37fs2mot8' ],
  [ tokens.LUMI, tokens.USDT, 'TWEee7dNN7Zc2M8f13M28KhBGrroVrdGxM' ],
  [ tokens.BBT, tokens.TRX, 'TTFYn18KrMxpdoQCxsp5SYjmDgS6dDEQTv' ],
  [ tokens.ICR, tokens.TRX, 'TTHoKhr85UiMPSHmdTukLkv3mAjjSdsiH5' ],
  [ tokens.CREED, tokens.TRX, 'TVcbypQLttW96yHzBraXBVnhcKC7HDRSfD' ],
  [ tokens.TRX, tokens.CREEDX, 'TN4BUph6ubYbmBDy2u9wpqoNg3DR1vrZRN' ],
  [ tokens.USDT, tokens.CYFM, 'TYNTeRHHbqH4sm5GcrwhQqa89ZaBGipEuG' ],
  [ tokens.USDT, tokens.KLV, 'TBB26dZsWFPDfYNyPWpD8LtdKCCRr3aDbY' ],
  [ tokens.TRX, tokens.KTY, 'TGMgXjSEzf5h7qK7cMZPuvu4wAk9x21Vwu' ],
  [ tokens.NFT, tokens.TRX, 'TQy4L8yguUXEsxUZmyrLfADgtwRhL6GgWH' ],
  [ tokens.JST, tokens.TRX, 'TJAZ6MvFBUnRw8vVDvgvGRMWGzDVaS6eqr' ],
  [ tokens.TNT, tokens.TRX, 'TFT7z2ELWzPuUeP8FgPTEAYe7syQ4TTYfo' ],
  [ tokens.TRX, tokens.ZLF, 'TEwbxEXNd3P7fVP6v4W91mRhGCYeGUkEdE' ],
  [ tokens.turu, tokens.TRX, 'TVBdRMsCnaNmY7jDVRm6VJxfeZZW3qKWoE' ],
  [ tokens.TRX, tokens.KLV, 'TNMUT9h6zZDnxouGf1EfXQ4yt1nHhnM4Ae' ],
  [ tokens.TWJ, tokens.USDT, 'TA95HcnsqfzKarHJzfB4V4JvrnZnqnBvWU' ],
  [ tokens.BTT, tokens.TRX, 'TMz4JoDPUv8rgqUaZCkaSrH7kQ819z2Vd9' ],
  [ tokens.TRX, tokens.ACTIV, 'TG2ZRTv3WX9cD53TEcTyjuuHd8pWCAg11X' ],
  [ tokens.TRX, tokens.KODX, 'TL8wEwke3gGrnw4zEBxisSG2RxehZT7xXs' ],
  [ tokens.BEMT, tokens.TRX, 'TWXEXQyEwSzSBENrWyiGu69Dd3yU8QREHV' ],
  [ tokens.TRX, tokens.WOX, 'TG1CirSZHqQ3yGJBMfXHjBcWVctfihciQL' ],
  [ tokens.TREX, tokens.TRX, 'TVzgLYrKSf2ZrPkWP7SbFXk6iKfR7PNHtR' ],
  [ tokens.LDA, tokens.TRX, 'TDV1P9ZpN3VaE8Rti6PXDZ3gAWUNMbRfa2' ],
  [ tokens.TRX, tokens.CUBE, 'TCqsrTUsBHBFoDRwjvjn6zooj6Cp6e1wUk' ],
  [ tokens.TRX, tokens.JM, 'TR7SpMHzp5ZfsBedbXzQ5CJsqBmg8oxzzr' ],
  [ tokens.USDT, tokens.JM, 'THTWV7R3U7XQsHWQt8YHgsqirvY9QttB7u' ],
  [ tokens.USDD, tokens.USDT, 'TNR1gJVMjE47uZxCrQaQe1xat2uBs3jAHr' ],
  [ tokens.TBT, tokens.TRX, 'TWwbk4ypVR6aKb2CS8TvERg1rxATUfWavP' ],
  [ tokens.TRX, tokens.USTX, 'TUFeu1WbJwL4jCAyu9pcotuASnbxEUbphn' ],
  [ tokens.BBT, tokens.VBS, 'TH6yNkvtthsPJLqVE1M8ri7zX9G7pi3fRR' ],
]

async function tronTvl() {
  const balances = {}

  for (let [tokenA, tokenB, pool] of pairs) {
    if (!tokenA.id.startsWith('_')) sdk.util.sumSingleBalance(balances, tokenA.id, await getTokenBalance(tokenA.address, pool))
    if (!tokenB.id.startsWith('_')) sdk.util.sumSingleBalance(balances, tokenB.id, await getTokenBalance(tokenB.address, pool))
    await sleep(1000)
  }

  return balances
}

module.exports = {
  bsc: {
    tvl: getUniTVL({
      chain: 'bsc',
      factory: '0xF2Fb1b5Be475E7E1b3C31082C958e781f73a1712',
      coreAssets: [
        '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c', // WBNB
        '0xe9e7cea3dedca5984780bafc599bd69add087d56', // BUSD
        '0x55d398326f99059ff775485246999027b3197955', // USDT
      ],
    }),
  },
  // bittorrent: {
  //   tvl: async (ts, _block, { bittorrent: block }) => {
  //     const { balances } = await getUniTVL({
  //         chain: 'bittorrent',
  //         factory: '0x4dEb2f0976DC3Bf351555524B3A24A4feA4e137E',
  //         coreAssets: [
  //           '0x23181f21dea5936e24163ffaba4ea3b316b57f3c', // BTT
  //           '0xedf53026aea60f8f75fca25f8830b7e2d6200662', // TRX
  //         ],
  //         withMetaData: true,
  //     })(ts, _block, { bittorrent: block })

  //     const fixBalances = await getFixBalances('bittorrent')

  //     fixBalances(balances)

  //     return balances
  //   },
  // },
  polygon: {
    tvl: getUniTVL({
      chain: 'polygon',
      factory: '0xD36ABA9EC96523B0A89886C76065852ADFE2EB39',
      coreAssets: [
        '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270', // MATIC
        '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT
      ],
    }),
  },
  tron: {
    tvl: tronTvl
  },
}

'''
'''--- projects/juststable/index.js ---
const axios = require('axios')
const {getApiTvl} = require('../helper/historicalApi')
const { usdtAddress } = require('../helper/balances')

async function tvl(timestamp){
    const balances = await getApiTvl(timestamp, async ()=>{
      const r = (await axios.get("https://abc.ablesdxd.link/scan/collInfo/timeLine")).data.data
      return Number(r[r.length-1].wtrxLocked)/1e12
    }, async()=>{
      const r = await axios.get("https://abc.ablesdxd.link/scan/collInfo/timeLine")
      // {liquidity: "0.000000000000000000", time: 1597492800000}
      return r.data.data.map(d=>({
        date: d.t/1000,
        totalLiquidityUSD: Number(d.wtrxLocked)/1e12
      }))
    });
    return {
      "tron": Number(balances[usdtAddress])
    }
}

module.exports = {
    timetravel: true,
    tron:{
      tvl
    }
}

'''
'''--- projects/kaco/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { calculateUniTvl } = require("../helper/calculateUniTvl.js");
const { pool2 } = require("../helper/pool2");
const { staking, stakingUnknownPricedLP} = require("../helper/staking");

const KACMasterChefContract = {
  bsc: "0x81b71D0bC2De38e37978E6701C342d0b7AA67D59",
  shiden: "0x293A7824582C56B0842535f94F6E3841888168C8",
};
const KACFactory = {
  bsc: "0xa5e48a6E56e164907263e901B98D9b11CCB46C47",
  shiden: "0xcd8620889c1dA22ED228e6C00182177f9dAd16b7",
};
const KAC = {
  bsc: "0xf96429A7aE52dA7d07E60BE95A3ece8B042016fB",
  shiden: "0xb12c13e66ade1f72f71834f2fc5082db8c091358",
};
async function bscTvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(
    (addr) => `bsc:${addr}`,
    chainBlocks["bsc"],
    "bsc",
    KACFactory["bsc"],
    0,
    true
  );
}
async function poolsTvl(timestamp, ethBlock, chainBlocks) {
  const balances = {};
  const stakedKAC = sdk.api.erc20.balanceOf({
    target: KAC["bsc"],
    owner: KACMasterChefContract["bsc"],
    chain: "bsc",
    block: chainBlocks["bsc"],
  });
  sdk.util.sumSingleBalance(
    balances,
    "bsc:" + KAC["bsc"],
    (await stakedKAC).output
  );
  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Fast growing Defi on BSC and Shiden! Fractionalize and farm NFTs.",
  bsc: {
    staking: stakingUnknownPricedLP("0x81b71D0bC2De38e37978E6701C342d0b7AA67D59", "0xf96429A7aE52dA7d07E60BE95A3ece8B042016fB", "bsc", "0x315F25Cea80AC6c039B86e79Ffc46aE6b2e30922", addr=>`bsc:${addr}`),
    tvl: bscTvl,
  },
  shiden: {
    staking: staking(
      KACMasterChefContract["shiden"],
      KAC["shiden"],
      "shiden",
      KAC["bsc"],
      0
    ),
    tvl: calculateUsdUniTvl(
      "0xcd8620889c1dA22ED228e6C00182177f9dAd16b7",
      "shiden",
      "0x0f933Dc137D21cA519ae4C7E93f87a4C8EF365Ef",
      [
        // USDC
        "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f",
        // USDT
        "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b",
        // JPYC
        "0x735aBE48e8782948a37C7765ECb76b98CdE97B0F",
        // STND
        "0x722377A047e89CA735f09Eb7CccAb780943c4CB4",
      ],
      "shiden"
    ),
  },
};

'''
'''--- projects/kaddex/index.js ---
const axios = require("axios");
const { fetchLocal, mkMeta } = require("../helper/pact");

const chainId = "2";
const network = `https://api.chainweb.com/chainweb/0.0/mainnet01/chain/${chainId}/pact`;
const GAS_PRICE = 0.00000001;
const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const getReserve = (tokenData) => {
  return parseFloat(tokenData.decimal ? tokenData.decimal : tokenData);
};

const pairTokens = {

  "coin:runonflux.flux": {
    name: "coin:runonflux.flux",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "FLUX",
      code: "runonflux.flux",
    },
  },

  "coin:hypercent.prod-hype-coin": {
    name: "coin:hypercent.prod-hype-coin",
    token0: {
      name: "KDA",
      code: "coin",
    },
    token1: {
      name: "HYPE",
      code: "hypercent.prod-hype-coin",
    },
  }
}

const getPairList = async () => {
  const pairList = await Promise.all(
    Object.values(pairTokens).map(async (pair) => {
      let data = await fetchLocal(
        {
          pactCode: `
            (use kswap.exchange)
            (let*
              (
                (p (get-pair ${pair.token0.code} ${pair.token1.code}))
                (reserveA (reserve-for p ${pair.token0.code}))
                (reserveB (reserve-for p ${pair.token1.code}))
                (totalBal (kswap.tokens.total-supply (kswap.exchange.get-pair-key ${pair.token0.code} ${pair.token1.code})))
              )[totalBal reserveA reserveB])
             `,
          meta: mkMeta(
            "",
            chainId,
            GAS_PRICE,
            3000,
            creationTime(),
            600
          ),
        },
        network
      );

      return {

        reserves: [
          getReserve(data.result.data[1]),
          getReserve(data.result.data[2]),
        ],
      };
    })
  );
  return pairList;
};

const fetchKdaTotal = async (pairList) => {
  let kdaTotal = 0;
  for (let i = 0; i < pairList.length; i++) {
    let pair = pairList[i];
    kdaTotal += pair.reserves[0];
  }
  return kdaTotal;
};

async function fetch() {
  const pairList = await getPairList();
  const kdaTotal = await fetchKdaTotal(pairList);
  const kdaInFluxPair = pairList[0].reserves[0];
  const kdaInHypePair = pairList[1].reserves[0]
  return {
    'kadena': kdaTotal + kdaInFluxPair + kdaInHypePair
    
  }
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  kadena: {
    tvl: fetch,
  },
};
'''
'''--- projects/kafefinance/index.js ---
const utils = require("../helper/utils");
const {toUSDTBalances} = require("../helper/balances");
// Please refer to Github(https://github.com/kukafe/kafe-defillama/tree/main/kafe-defillama) for the codes to calculate the TVL via on-chain calls
const apiUrl = "http://142.93.53.244:5001/getTvl";

let responseData
async function fetchChain(chain, includePool2) {
  let totalTvl = 0;
  if (!responseData)  responseData = utils.fetchURL(apiUrl)
  let response = (await responseData).data;
  Object.keys(response).forEach((key) => {
    let entry = response[key];
    if (entry.chain !== chain) return;
    if (includePool2 == false) {
      if (key.startsWith("KAFE")) return;
    } else {
      if (!key.startsWith("KAFE")) return;
      if (key.startsWith("KAFE") && key.endsWith("KAFE")) return;
    }
    totalTvl = totalTvl + Number(entry.TVL);
  });
  return toUSDTBalances(Math.round(totalTvl));
}

async function fetchCronos() {
  return fetchChain("cronos", false);
}

async function fetchMoonriver() {
  return fetchChain("moonriver", false);
}

async function fetchMoonRiverPool2() {
  return fetchChain("moonriver", true);
}

async function fetchMoonriverStaking() {
  let response = (await utils.fetchURL(apiUrl)).data;
  return toUSDTBalances(Math.round(Number(response["KAFE"].TVL)));
}

async function fetch() {
  let cronosTvl = await fetchChain("cronos", false);
  let moonriverTvl = await fetchChain("moonriver", false);
  return cronosTvl + moonriverTvl;
}

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  cronos: {
    tvl: fetchCronos,
  },
  moonriver: {
    tvl: fetchMoonriver,
    staking: fetchMoonriverStaking,
    pool2: fetchMoonRiverPool2
  },
}

'''
'''--- projects/kagla/abi/addressProvider.json ---
{
  "get_registry": {
    "inputs": [],
    "name": "get_registry",
    "outputs": [{ "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/kagla/abi/registry.json ---
{
  "pool_count": {
    "inputs": [],
    "name": "pool_count",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  "pool_list": {
    "inputs": [{"name": "arg0", "type": "uint256"}],
    "name": "pool_list",
    "outputs": [{"name": "", "type": "address"}],
    "stateMutability": "view",
    "type": "function"
  },
  "get_coins": {
    "inputs": [{"name": "_pool", "type": "address"}],
    "name": "get_coins",
    "outputs": [{"name": "", "type": "address[8]"}],
    "stateMutability": "view",
    "type": "function"
  },
  "get_balances": {
    "inputs": [{"name": "_pool", "type": "address"}],
    "name": "get_balances",
    "outputs": [{"name": "", "type": "uint256[8]"}],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/kagla/addresses.js ---
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000"

const ADDRESS_PROVIDER_ADDRESS = "0x5a0ad8337E5C6895b3893E80c8333859DAcf7c01"
const KGL_ADDRESS = "0x257f1a047948f73158DaDd03eB84b34498bCDc60"
const VOTING_ESCROW_ADDRESS = "0x432c8199F548425F7d5746416D98126E521e8174"

const transformTokenAddress = (address) => TOKENS[address]

const TOKENS = {
  // KGL
  [KGL_ADDRESS]: "kagla-finance",
  // USDC
  "0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // Starlay lUSDC -> USDC
  "0xC404E12D3466acCB625c67dbAb2E1a8a457DEf3c": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  // USDT
  "0x3795C36e7D12A8c252A20C5a7B455f7c57b60283": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // Starlay lUSDT -> USDT
  "0x430D50963d9635bBef5a2fF27BD0bDDc26ed691F": "0xdac17f958d2ee523a2206206994597c13d831ec7",
  // DAI
  "0x6De33698e9e9b787e09d3Bd7771ef63557E148bb": "0x6b175474e89094c44da98b954eedeac495271d0f",
  // Starlay lDAI -> DAI
  "0x4dd9c468A44F3FEF662c35c1E9a6108B70415C2c": "0x6b175474e89094c44da98b954eedeac495271d0f",
  // BUSD
  "0x4Bf769b05E832FCdc9053fFFBC78Ca889aCb5E1E": "binance-usd",
  // BAI
  "0x733ebcC6DF85f8266349DEFD0980f8Ced9B45f35": "bai-stablecoin",
};

module.exports = {
  ZERO_ADDRESS,
  ADDRESS_PROVIDER_ADDRESS,
  VOTING_ESCROW_ADDRESS,
  KGL_ADDRESS,
  transformTokenAddress
}

'''
'''--- projects/kagla/index.js ---
const { getBalances } = require("./pools");
const { getStaked } = require("./staking");

const START_BLOCK = 724359

async function astar(_timestamp, _block, {astar: block}) {
  const chain = "astar"
  const balances = await getBalances(chain, block)
  return balances
}

async function staking(_timestamp, _block, {astar: block}) {
  const chain = "astar"
  const staked = await getStaked(chain, block)
  return staked
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  start: START_BLOCK,
  astar: {
    tvl: astar,
    staking: staking
  },
};

'''
'''--- projects/kagla/pools.js ---
const sdk = require("@defillama/sdk");
const { toBigNumberJsOrZero } = require("./utils.js");

const addressProviderABI = require("./abi/addressProvider.json");
const registryABI = require("./abi/registry.json");
const { ADDRESS_PROVIDER_ADDRESS, ZERO_ADDRESS, transformTokenAddress } = require("./addresses");

const getBalances = async (chain, block) => {
  const registryAddress = (await sdk.api.abi.call({
    target: ADDRESS_PROVIDER_ADDRESS,
    abi: addressProviderABI["get_registry"],
    block,
    chain,
  })).output

  const poolAddresses = await listPoolAddresses(chain, block, registryAddress)

  const poolCoinsArray = (await sdk.api.abi.multiCall({
    calls: poolAddresses.map(address => ({ target: registryAddress, params: address })),
    abi: registryABI["get_coins"],
    block,
    chain,
  })).output.map(({ output }) => output.filter(address => address !== ZERO_ADDRESS))

  const poolBalancesArray = (await sdk.api.abi.multiCall({
    calls: poolAddresses.map(address => ({ target: registryAddress, params: address })),
    abi: registryABI["get_balances"],
    block,
    chain,
  })).output.map(({ output }) => output)

  const balanceBNRecord = poolCoinsArray.reduce(
    (result, coins, poolIndex) => 
      coins.reduce((coinsResult, coin, coinIndex) => {
        const balance = toBigNumberJsOrZero(poolBalancesArray[poolIndex][coinIndex])
        const transformedCoin = transformTokenAddress(coin)
        const exisitingBalance = coinsResult[transformedCoin]
        if(!transformedCoin) return coinsResult
        if(!exisitingBalance)
            return { ...coinsResult, [transformedCoin]: balance }
        return { ...coinsResult, [transformedCoin]: exisitingBalance.plus(balance) }
      }, result),
    {}
  )

  return Object.keys(balanceBNRecord).reduce((result, key) => ({
    ...result,
    [key]: key.startsWith("0x")
      ? balanceBNRecord[key].toString()
      : balanceBNRecord[key].shiftedBy(-18)
  }), {})
}

const listPoolAddresses = async (chain, block, registryAddress) => {
  const numOfPools = (await sdk.api.abi.call({
    target: registryAddress,
    abi: registryABI["pool_count"],
    block,
    chain,
  })).output
  const poolAddressesCalls = []
  for (let i = 0; i < numOfPools; i++) {
    poolAddressesCalls.push({ target: registryAddress, params: i })
  }
  return (await sdk.api.abi.multiCall({
    calls: poolAddressesCalls,
    abi: registryABI["pool_list"],
    block,
    chain,
  })).output.map(({ output }) => output)
}

module.exports = {
  getBalances
}

'''
'''--- projects/kagla/staking.js ---
const sdk = require("@defillama/sdk");
const { toBigNumberJsOrZero } = require("./utils.js");

const { VOTING_ESCROW_ADDRESS, KGL_ADDRESS, transformTokenAddress } = require("./addresses");

const getStaked = async (chain, block) => {
  const lockedKGLBalance = (await sdk.api.abi.call({
    target: KGL_ADDRESS,
    abi: 'erc20:balanceOf',
    params: [VOTING_ESCROW_ADDRESS],
    block,
    chain,
  })).output

  return {
    [transformTokenAddress(KGL_ADDRESS)]: toBigNumberJsOrZero(lockedKGLBalance).shiftedBy(-18)
  }
}

module.exports = {
  getStaked
}

'''
'''--- projects/kagla/utils.js ---
const BigNumberJs = require("bignumber.js");
BigNumberJs.config({ EXPONENTIAL_AT: 1e9 })

const toBigNumberJsOrZero = (value) => {
  const bn = new BigNumberJs(value)
  return bn.isNaN() ? new BigNumberJs('0') : bn
}
  
module.exports = {
  toBigNumberJsOrZero
}

'''
'''--- projects/kaidex/index.js ---
const {getChainTvl} = require('../helper/getUniSubgraphTvl')

module.exports={
    kardia:{
        tvl: getChainTvl({
            kardia: 'https://ex-graph.kardiachain.io/subgraphs/name/kai/exchange-v2'
        }, 'kaiDexFactories')('kardia')
    }
}

'''
'''--- projects/kalata/index.js ---
const sdk = require('@defillama/sdk')
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')
const {staking} = require('../helper/staking')
const {pool2s} = require('../helper/pool2')

const kala = '0x32299c93960bb583a43c2220dc89152391a610c5'
const masterchef = '0x565bCba3eA730ac6987edE126B29DCf499fccEA1'
const pool2Lps = ["0x64330C8AcCd74E8EB30894F341eF45c743B875b5", "0x2401F882CA9952df2aF3e335D4606620Be19aE89"]

const trans = addr=>{
    if(addr.toLowerCase() === "0x598308047116a8055c1e3debd2b761e3bc3dbcb8"){ // kUSD
        return "0x0000000000085d4780b73119b644ae5ecd22b376" //tusd
    }
    return 'bsc:'+addr
}

async function tvl(time, ethBlock, chainBlocks){
    const chain = 'bsc'
    const block = chainBlocks.bsc
    const balances = {}
    // minting
    await sumTokensAndLPsSharedOwners(balances,[
        ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], //BUSD
        [kala, false],
        ["0x598308047116a8055c1e3debd2b761e3bc3dbcb8", false], //kUSD
    ], ["0x2d067575BE1f719f0b0865D357e67925B6f461C5"], block, chain, trans)
    return balances
}

async function masterchefTvl(time, ethBlock, chainBlocks){
    const chain = 'bsc'
    const block = chainBlocks.bsc
    const balances = {}
    await sumTokensAndLPsSharedOwners(balances,[
        ["0x598308047116a8055c1e3debd2b761e3bc3dbcb8", false], //kUSD
        ["0x6b2ADA69629592C04374FA27A17Fd538042BB299", true],
        ["0x9a1C5D24492b6A3B99472270E58E95EF705eAe39", true],
        ["0x6882911440c04Df3cBf2f82b6921097f53D7B767", true],
        ["0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c", false],
        ["0x2170Ed0880ac9A755fd29B2688956BD959F933F8", false],
        ["0x23396cf899ca06c4472205fc903bdb4de249d6fc", false],
        ["0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", false],
        ["0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", false],
        ["0x55d398326f99059ff775485246999027b3197955", false],
        ["0x85593d5786b89a5659dbe3784e7c296827d70389", true],
        ["0x2f5b3ab702b48b448d510200676af63630c6daa2", true],
        ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false],
        ["0x5066c68cae3b9bdacd6a1a37c90f2d1723559d18", false]
    ], [masterchef], block, chain, trans)
    return balances
}

module.exports={
    methodology: 'kUSD replaced by TUSD',
    bsc:{
        tvl: sdk.util.sumChainTvls([tvl, masterchefTvl]),
        masterchef: masterchefTvl,
        staking: staking(masterchef, kala, 'bsc'),
        pool2: pool2s([masterchef], pool2Lps, 'bsc', trans)
    }
}
'''
'''--- projects/kalmy-app/abi.json ---
{
  "vaultDebtVal": {
    "inputs": [],
    "name": "vaultDebtVal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalToken": {
    "inputs": [],
    "name": "totalToken",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "reservePool": {
    "inputs": [],
    "name": "reservePool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalETH": {
    "inputs": [],
    "name": "totalETH",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalBEP20": {
    "inputs": [],
    "name": "totalBEP20",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IPancakePair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "rewardDebt",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "pId": {
    "inputs": [],
    "name": "pid",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "ausdTotalStablecoinIssued": {
    "inputs": [],
    "name": "totalStablecoinIssued",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "xalpacaTotalSupply": {
    "inputs": [],
    "name": "supply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/kalmy-app/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs")

async function getProcolAddresses() {
  return (await axios.get(
    'https://raw.githubusercontent.com/kalmar-io/kalmar-assets/main/data/bsc-kalmar-contract.json'
  )).data
}

async function getFTMProcolAddresses() {
  return (await axios.get(
    'https://raw.githubusercontent.com/kalmar-io/kalmar-assets/main/data/ftm-kalmar-contract.json'
  )).data
}

async function getAvaxProcolAddresses() {
  return (await axios.get(
    'https://raw.githubusercontent.com/kalmar-io/kalmar-assets/main/data/avax-kalmar-contract.json'
  )).data
}

function getBSCAddress(address) {
  return `bsc:${address}`
}

function getFTMAddress(address) {
  return `fantom:${address}`
}

function getAvaxAddress(address) {
  return `avax:${address}`
}

async function tvl(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getProcolAddresses()

  const block = chainBlocks.bsc;

  for(let i = 0; i < addresses['Vaults'].length; i++) {
    /// @dev getting balances that each of workers holding
    const stakingTokenInfos = (await sdk.api.abi.multiCall({
      block,
      abi: abi.userInfo,
      calls: addresses['Vaults'][i]['workers'].map((worker) => {
        return {
          target: worker['stakingTokenAt'],
          params: [worker['pId'], worker['address']]
        }
      }),
      chain: 'bsc'
    })).output

    /// @dev unwrap LP to get underlaying token balances for workers that are working with LPs
    await unwrapUniswapLPs(balances,
      stakingTokenInfos.filter((n) => {
        /// @dev filter only workers that are working with LPs
        const name = addresses['Vaults'][i]['workers'].find((w) => w.address === n.input.params[1]).name
        if(name.includes("CakeMaxiWorker")) {
          return false
        }
        return true
      }).map((info) => {
        /// @dev getting LP address and return the object that unwrapUniswapLPs want
        const lpAddr = addresses['Vaults'][i]['workers'].find((w) => w.address === info.input.params[1]).stakingToken;
        return {
          token: lpAddr,
          balance: info.output.amount
        }
      }
    ), block, 'bsc', (addr) => `bsc:${addr}`)

    /// @dev update balances directly for single-asset workers
    const singleAssetWorkersBalances = stakingTokenInfos.filter((n) => {
      /// @dev filter only single-asset LYF workers
      const name = addresses['Vaults'][i]['workers'].find((w) => w.address === n.input.params[1]).name
      if(name.includes("CakeMaxiWorker")) {
        return true
      }
      return false
    }).map((n) => {
      /// @dev getting staking token address and return the object to be sum with balances
      const stakingTokenAddr = addresses['Vaults'][i]['workers'].find((w) => w.address === n.input.params[1]).stakingToken;
      return {
        token: stakingTokenAddr,
        balance: n.output.amount
      }
    })

    /// @dev sum single-asset balances to balances variable
    singleAssetWorkersBalances.forEach((s) => {
      balances[getBSCAddress(s.token)] = BigNumber(balances[getBSCAddress(s.token)] || 0).plus(BigNumber(s.balance)).toFixed(0)
    })
  }

  /// @dev getting all unused liquidity on each vault
  const unusedBTOKEN = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Vaults'].map((v) => {
      return {
        target: v['baseToken'],
        params: [v['address']]
      }
    }),
    chain: 'bsc'
  })).output

  unusedBTOKEN.forEach((u) => {
    balances[getBSCAddress(u.input.target)] = BigNumber(balances[getBSCAddress(u.input.target)] || 0).plus(BigNumber(u.output)).toFixed(0)
  })

  /// @dev getting unused BNB on iBNB vault
  const vBNB = addresses['Vaults'].filter((v) => v['symbol'] === 'iBNB')[0]  
  const unusedBNB = (await sdk.api.eth.getBalance({
      block,
      target: vBNB['address'],
      chain: 'bsc',
  })).output

  balances[getBSCAddress(vBNB['baseToken'])] = BigNumber(balances[getBSCAddress(vBNB['baseToken'])] || 0).plus(BigNumber(unusedBNB)).toFixed(0)

  /// @dev getting all unused liquidity on each lp staking
  const lpStakingInfos = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Liquidity'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['stakingTokenAt']]
      }
    }),
    chain: 'bsc'
  })).output

  /// @dev unwrap LP to get underlaying token balances for lp staking that are working with LPs
  await unwrapUniswapLPs(balances,
    lpStakingInfos.map((info) => {
      /// @dev getting LP address and return the object that unwrapUniswapLPs want
      const lpAddr = info.input.target;
      return {
        token: lpAddr,
        balance: info.output
      }
    }
  ), block, 'bsc', (addr) => `bsc:${addr}`)

  return balances
}

async function ftmTvl(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getFTMProcolAddresses()

  const block = chainBlocks.fantom;

  /// @dev getting all unused liquidity on each lp staking
  const lpStakingInfos = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Liquidity'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['stakingTokenAt']]
      }
    }),
    chain: 'fantom'
  })).output

  /// @dev unwrap LP to get underlaying token balances for lp staking that are working with LPs
  await unwrapUniswapLPs(balances,
    lpStakingInfos.map((info) => {
      /// @dev getting LP address and return the object that unwrapUniswapLPs want
      const lpAddr = info.input.target;
      return {
        token: lpAddr,
        balance: info.output
      }
    }
  ), block, 'fantom', (addr) => `fantom:${addr}`)

  return balances
}

async function avaxTvl(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getAvaxProcolAddresses()

  const block = chainBlocks.avax;

  /// @dev getting all unused liquidity on each lp staking
  const lpStakingInfos = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Liquidity'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['stakingTokenAt']]
      }
    }),
    chain: 'avax'
  })).output

  /// @dev unwrap LP to get underlaying token balances for lp staking that are working with LPs
  await unwrapUniswapLPs(balances,
    lpStakingInfos.map((info) => {
      /// @dev getting LP address and return the object that unwrapUniswapLPs want
      const lpAddr = info.input.target;
      return {
        token: lpAddr,
        balance: info.output
      }
    }
  ), block, 'avax', (addr) => `avax:${addr}`)

  return balances
}

async function staking(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getProcolAddresses()

  const block = chainBlocks.bsc;

  /// @dev getting staking amount on each vault
  const stakingTokens = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Staking'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['address']]
      }
    }),
    chain: 'bsc'
  })).output
  
  /// @dev getting Kalm staking balance
  const kalmObjIndex = addresses['Staking'].findIndex((s) => s.name.includes('Kalm'))
  const kalmStaking = addresses['Staking'][kalmObjIndex]
  const kalmStaked = stakingTokens[kalmObjIndex].output
  balances[getBSCAddress(kalmStaking['stakingToken'])] = BigNumber(balances[getBSCAddress(kalmStaking['stakingToken'])] || 0).plus(BigNumber(kalmStaked)).toFixed(0)

  /// @dev getting total base token
  const totalBNB = (await sdk.api.abi.multiCall({
    block,
    abi: abi.totalETH,
    calls: addresses['Staking'].filter((s) => s.name.includes('iBNB')).map((sObj) => {
      return {
        target: sObj['stakingToken']
      }
    }),
    chain: 'bsc'
  })).output

  const totalBEP20 = (await sdk.api.abi.multiCall({
    block,
    abi: abi.totalBEP20,
    calls: addresses['Staking'].filter((s) => !s.name.includes('iBNB') && !s.name.includes('Kalm')).map((sObj) => {
      return {
        target: sObj['stakingToken']
      }
    }),
    chain: 'bsc'
  })).output

  const totalBTOKEN = [...totalBNB, ...totalBEP20]
  const iTokens = addresses['Staking'].filter((s) => !s.name.includes('Kalm'))

  const totalITOKEN = (await sdk.api.abi.multiCall({
    block,
    abi: abi.totalSupply,
    calls: iTokens.map((sObj) => {
      return {
        target: sObj['stakingToken']
      }
    }),
    chain: 'bsc'
  })).output

  const onlyITOKENStaking = stakingTokens.filter((s, i) => i !== kalmObjIndex)

  totalITOKEN.forEach((t, i) => {
    const tokenPerShare = BigNumber(totalBTOKEN[i].output).div(totalITOKEN[i].output)
    const totalValue = BigNumber(onlyITOKENStaking[i].output).times(tokenPerShare)
    balances[getBSCAddress(iTokens[i]['baseToken'])] = BigNumber(balances[getBSCAddress(iTokens[i]['baseToken'])] || 0).plus(totalValue).toFixed(0)
  })

  return balances
}

async function ftmStaking(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getFTMProcolAddresses()

  const block = chainBlocks.fantom;

  /// @dev getting staking amount on each vault
  const stakingTokens = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Staking'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['address']]
      }
    }),
    chain: 'fantom'
  })).output
  
  /// @dev getting Kalm staking balance
  const kalmObjIndex = addresses['Staking'].findIndex((s) => s.name.includes('Kalm'))
  const kalmStaking = addresses['Staking'][kalmObjIndex]
  const kalmStaked = stakingTokens[kalmObjIndex].output
  balances[getFTMAddress(kalmStaking['stakingToken'])] = BigNumber(balances[getFTMAddress(kalmStaking['stakingToken'])] || 0).plus(BigNumber(kalmStaked)).toFixed(0)

  return balances
}

async function avaxStaking(timestamp, ethBlock, chainBlocks) {
  /// @dev Initialized variables
  const balances = {}

  /// @dev Getting all addresses from Github
  const addresses = await getAvaxProcolAddresses()

  const block = chainBlocks.avax;

  /// @dev getting staking amount on each vault
  const stakingTokens = (await sdk.api.abi.multiCall({
    block,
    abi: abi.balanceOf,
    calls: addresses['Staking'].map((s) => {
      return {
        target: s['stakingToken'],
        params: [s['address']]
      }
    }),
    chain: 'avax'
  })).output
  
  /// @dev getting Kalm staking balance
  const kalmObjIndex = addresses['Staking'].findIndex((s) => s.name.includes('Kalm'))
  const kalmStaking = addresses['Staking'][kalmObjIndex]
  const kalmStaked = stakingTokens[kalmObjIndex].output
  balances[getAvaxAddress(kalmStaking['stakingToken'])] = BigNumber(balances[getAvaxAddress(kalmStaking['stakingToken'])] || 0).plus(BigNumber(kalmStaked)).toFixed(0)

  return balances
}

module.exports = {
  bsc: {
    tvl,
    staking
  },
  fantom: {
    tvl: ftmTvl,
    staking: ftmStaking
  },
  avax: {
    tvl: avaxTvl,
    staking: avaxStaking
  }
};
  
'''
'''--- projects/kandyland-finance/index.js ---
const { ohmTvl } = require("../helper/ohm");

const kandy = "0x37ded665a387a6f170fb60376b3057f09df6c0ea";
const stakingContract = "0x0AFaBaba220CD10C50A192bd382D06ebB98fAaf2";
const treasury = "0xb1CE95694E02126BEeE66bD6614410cA27C00a5e";
const tokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
    ["0x7DEABc1670da88BbC050A9858aCDDE30AEEDcCac", true] // KANDY-MIM JLP
]

module.exports = {
    deadFrom: 1648765747,
    ...ohmTvl(treasury, tokens, "avax", stakingContract, kandy, undefined, undefined, false)
}
'''
'''--- projects/karma-dao/index.js ---
const { ohmTvl } = require("../helper/ohm");
const treasury = "0xAa50Ba30c9548cB34941C140e9CCe8Cc55829A71";
const treasuryTokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // mim
    ["0x6DB2bCcd11bb8dC29B7598dcf0D3d63cfb52A572", true], // karma-mim jlp
];
const karma = "0x5ccff6723f592c223e7b31c6872ba999a028653f";
const stakingcontract = "0x4c9b7D49C86220A91c0c8756940C7c27583dC5EB";

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "avax", stakingcontract, karma, undefined, undefined, false)
}
'''
'''--- projects/karura-dex/api.js ---

const { dex } = require('../helper/acala/dex')

module.exports = {
  karura: { tvl: async () => dex('karura') },
};
'''
'''--- projects/karura-dex/index.js ---
const { getExports } = require('../helper/heroku-api')

module.exports = {
  timetravel: false,
  ...getExports("karura-dex", ['karura']),
}
'''
'''--- projects/karura-lending/api.js ---

const { lending } = require('../helper/acala/lending')

module.exports = {
  karura: { tvl: async () => lending('karura') },
};
'''
'''--- projects/karura-lending/index.js ---
const {getExports} = require('../helper/heroku-api')

module.exports = {
    timetravel: false,
    ...getExports("karura-lending", ['karura'])
}
'''
'''--- projects/karura-staking/api.js ---

const { staking } = require('../helper/acala/liquidStaking')

module.exports = {
  karura: { tvl: async () => staking('karura') },
};
'''
'''--- projects/karura-staking/index.js ---
const {getExports} = require('../helper/heroku-api')

module.exports = {
    timetravel: false,
    ...getExports("karura-staking", ['karura'])
}
'''
'''--- projects/karura-staking/lksmToKsm.js ---
async function lksmToKsm(api, amount) {
    const toBond = Number(await api.query.homa.toBondPool());
    const bonded = Number(
      (await api.query.homa.stakingLedgers(0)).toJSON().bonded
    );
  
    const totalStaked = toBond + bonded;
  
    const voidLiquid = Number(await api.query.homa.totalVoidLiquid());
    const totalLKSM = Number(
      await api.query.tokens.totalIssuance({ token: "LKSM" })
    );
  
    const totalIssued = voidLiquid + totalLKSM;
  
    return amount * (totalStaked / totalIssued);
  }
  
  module.exports = lksmToKsm;
'''
'''--- projects/kasavadex/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

module.exports = {
    misrepresentedTokens: true,
    methodology: "Factory addresses (0x8F1fD6Ed57B0806FF114135F5b50B5f76e9542F2 for kava) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    kava: {
        tvl: getUniTVL({
            factory: '0x8F1fD6Ed57B0806FF114135F5b50B5f76e9542F2',
            chain: 'kava',
            coreAssets: [
                '0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b',
                "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f",
                "0xB44a9B6905aF7c801311e8F4E76932ee959c663C",
                "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b",
                "0x765277EebeCA2e31912C9946eAe1021199B39C61",
                "0x7C598c96D02398d89FbCb9d41Eab3DF0C16F227D",
                "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d",
            ]
        }),
    }
}

'''
'''--- projects/kassandra/abi.json ---
{
    "getCurrentTokens":{"inputs":[],"name":"getCurrentTokens","outputs":[{"internalType":"address[]","name":"tokens","type":"address[]"}],"stateMutability":"view","type":"function"}
}
'''
'''--- projects/kassandra/index.js ---
const sdk = require('@defillama/sdk')
const {sumTokens} = require('../helper/unwrapLPs')
const abi = require('./abi.json')

const indexToken = "0x17C1037B17b221f2f3b53f85cebD817C941f6bC5"

async function tvl(time, ethBlock, chainBlocks){
    const chain = "avax"
    const block = chainBlocks[chain]
    const tokens = await sdk.api.abi.call({
        target: indexToken,
        chain,
        block,
        abi: abi.getCurrentTokens
    })
    const balances = {}
    await sumTokens(balances, 
        tokens.output.map(t=>[t, indexToken]),
        block,
        chain,
        addr=>`${chain}:${addr}`
    )
    return balances
}

module.exports={
    tvl
}
'''
'''--- projects/katana-ronin.js ---
const sdk = require('@defillama/sdk');
const { default: BigNumber } = require('bignumber.js');
const { request, gql } = require("graphql-request");
const { getBlock } = require('./helper/getBlock');

// Ronin -> Mainnet lookup table
const token_lookup_table = { // needed to add 0x in front
  '0xc99a6a985ed2cac1ef41640596c5a5f9f4e19ef5': '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', // weth 
  '0x97a9107c1793bc407d6f527b77e7fff4d812bece': '0xbb0e17ef65f82ab018d8edd776e8dd940327b28b', // axs
  '0xa8754b9fa15fc18bb59458815510e40a12cd2014': '0xcc8fa225d80b9c7d42f96e9570156c65d6caaa25', // slp
  '0x0b7007c13325c48911f73a2dad5fa5dcbf808adc': '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // usdc
  '0xe514d9deb7966c8be0ca922de8a064264ea6bcd4': 'ronin'
}
// Don't count staking twice
// const axs_weth_LP_staking = '487671acdea3745b6dac3ae8d1757b44a04bfe8a' 
// const slp_weth_LP_staking = 'd4640c26c1a31cd632d8ae1a96fe5ac135d1eb52'

// Get pairs using the graph 
const graphUrl = 'https://thegraph.roninchain.com/subgraphs/name/axieinfinity/katana-subgraph-blue'

const pairsQuery = gql`
query pairs($block: Int, $skip: Int!) {
  pairs(
    block: { number: $block } # TODO: cjeck block fecthing works
    first: 500, 
    skip: $skip, 
    orderBy: trackedReserveETH, 
    orderDirection: desc
  ) {
    id
    token0 {
      id
      symbol
      name
    }
    token1 {
      id
      symbol
      name
    }
    __typename
    }
}
`

const tokensQuery = gql`
query tokens($block: Int) {
  tokens(first: 500, block: { number: $block }) {
    id
    name
    symbol
    totalLiquidity
    decimals
  }
}
`

const factoryQuery = gql`
query get_tvl($block: Int) {
  katanaFactories(
    block: { number: $block }
  ) {
    id
    totalLiquidity
  }
}
`

const blockQuery = gql`
query blocks($timestampFrom: Int!, $timestampTo: Int!) {
  blocks(first: 1, orderBy: timestamp, orderDirection: asc, where: {timestamp_gt: $timestampFrom, timestamp_lt: $timestampTo}) {
    id
    number
    timestamp
    __typename
  }
}
`

const blocksGraph = "https://thegraph.roninchain.com/subgraphs/name/axieinfinity/ronin-blocks"

// https://katana-analytics.roninchain.com/home

async function tvl(timestamp, ethBlock, chainBlocks) {
  const block = Number((await request(blocksGraph, blockQuery,
    {
      timestampFrom: timestamp - 30,
      timestampTo: timestamp + 30
    })
  ).blocks[0].number)

  const { tokens } = await request(
    graphUrl,
    tokensQuery,
    { block }
  )

  // const transform = addr => tokens.find(t => t.id == addr).symbol
  const transform = addr => token_lookup_table[addr.toLowerCase()]

  let balances = {};
  tokens.forEach(token=>{
    sdk.util.sumSingleBalance(balances, transform(token.id), BigNumber(token.totalLiquidity).times(10**token.decimals).toFixed(0))
  })
  if (balances[undefined]) {
    throw ('One balance is undefined, probably because the ronin-to-mainnet mapping is not defined for some tokens')
  }
  if (balances['ronin']) {
    balances['ronin'] /= 10 ** 18
  }
  return balances
}

/*
// Could also return USDT equivalent of LPs because uses the same graph as uni
const {getChainTvl} = require('./helper/getUniSubgraphTvl')
const tvl2 = (timestamp, block, chainBlocks) => getChainTvl({
  ronin: graphUrl
}, 'katanaFactories')('ronin')(timestamp, block, chainBlocks)
*/

module.exports = {
  methodology: `Counts the tokens locked on LPs pools, pulling the pairs data from the katana graphql endpoint`,
  ronin: { tvl: tvl }
}

'''
'''--- projects/katana/index.js ---
const axios = require("axios");

async function tvl() {
  let tvlSnapshotResponse = await axios.get(
    "https://raw.githubusercontent.com/Katana-Labs/statistics/master/tvl/tvl.json"
  );

  delete tvlSnapshotResponse.data[undefined]
  return tvlSnapshotResponse.data;
}

module.exports = {
  timetravel: false,
  methodology: "Snapshots of the TVL from app.katana.so are saved periodically into the statistics repo",
  solana: {
    tvl,  
  }
};
'''
'''--- projects/kava.js ---
const retry = require('./helper/retry')
const axios = require("axios");

async function tvl() {
  let balances = {};

  let deposits = (await retry(async bail => 
    await axios.get('https://api2.kava.io/cdp/totalCollateral'))).data.result;
  for (let i = 0; i < deposits.length; i++) {
    const info = convertSymbol(deposits[i].amount.denom);
    if (info.id in balances) {
      balances[info.id] = Number(balances[info.id]) + 
        Number(deposits[i].amount.amount / 10 ** info.decimals);
    } else {
      balances[info.id] = deposits[i].amount.amount / 10 ** info.decimals;
    };
  };

  // let borrowed = (await retry(async bail => 
  //   await axios.get('https://api2.kava.io/cdp/totalPrincipal'))).data.result;
  // for (let i = 0; i < borrowed.length; i++) {
  //   const symbol = borrowed[i].collateral_type.substring(
  //     0, borrowed[i].collateral_type.indexOf('-'));
  //   const info = convertSymbol(symbol);
  //   const tokenPrice = (await retry(async bail => await axios.get(
  //     `https://api.coingecko.com/api/v3/simple/price?ids=${info.id}&vs_currencies=usd`
  //     ))).data[info.id].usd;
  //   const borrowedQty = borrowed[i].amount.amount / (tokenPrice * 10 ** 6);
  //   balances[info.id] = Number(balances[info.id]) - Number(borrowedQty);
  // };
  return balances;
};

function convertSymbol(symbol) {
  switch (symbol) {
    case 'bnb':
      return {id: 'binancecoin', decimals: 8};
    case 'btcb':
      return {id: 'bitcoin', decimals: 8};
    case 'busd':
      return {id: 'binance-usd', decimals: 8};
    case 'hard':
      return {id: 'kava-lend', decimals: 6};
    case 'hbtc':
      return {id: 'bitcoin', decimals: 8};
    case 'swp':
      return {id: 'kava-swap', decimals: 6};
    case 'ukava':
      return {id: 'kava', decimals: 6};
    case 'xrpb':
      return {id: 'ripple', decimals: 8};
    case 'ibc/B448C0CA358B958301D328CCDC5D5AD642FC30A6D3AE106FF721DB315F3DDE5C':
      return {id: 'terra-usd', decimals: 6};
    default:
      console.log(symbol);
  };
};

module.exports = {
  timetravel: false,
  kava: { tvl }
};
// node test.js projects/kava.js
'''
'''--- projects/kavacave/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const kavaabi = require("./kavaAbi.json");
const abiGeneral = require("../helper/abis/masterchef.json");
const { getFixBalances } = require("../helper/portedTokens");

const masterChef = {
	kava:"0xf17BBB9698b50156Ee437E01e22D7C2080184934"
};
const abi = {
	kava: kavaabi,
};

async function getTokensInMasterChef(time, ethBlock, chainBlocks, chain) {
	const block = chainBlocks[chain];
	
	const transformAddress = (addr) => `${chain}:${addr}`; 
	// const transformAddress=(addr)=>kavaFixMapping[addr];
	const balances = {};
	const poolLength = (
		await sdk.api.abi.call({
			abi: abiGeneral.poolLength,
			target: masterChef[chain],
			block,
			chain,
		})
	).output;
	const poolInfo = (
		await sdk.api.abi.multiCall({
			block,
			calls: Array.from(Array(Number(poolLength)).keys()).map((i) => ({
				target: masterChef[chain],
				params: i,
			})),
			abi: abi[chain].poolInfo,
			chain,
		})
	).output;

	const [symbols] = await Promise.all([
		sdk.api.abi.multiCall({
			block,
			calls: poolInfo.map((p) => ({
				target: p.output[0],
			})),
			abi: "erc20:symbol",
			chain,
		}),
	]);
	const lpPositions = [];

	symbols.output.forEach((symbol, idx) => {
		const pool = poolInfo[idx].output;
		const balance = +pool.totalcap;
		const token = symbol.input.target;
		if (symbol.output.includes("LP") || symbol.output.includes("UNI-V2")) {
			lpPositions.push({
				balance,
				token,
			});
		} else {
			sdk.util.sumSingleBalance(balances, transformAddress(token), balance);
		}
	});

	await unwrapUniswapLPs(balances, lpPositions, block, chain, transformAddress);
	// console.log(balances)
	const fixbalances=await getFixBalances(chain);
	fixbalances(balances);
	return balances;
}

async function kavaTvl(timestamp, block, chainBlocks) {
	return await getTokensInMasterChef(timestamp, block, chainBlocks, "kava");
}

module.exports = {
	methodology:
		"Staked LP is counted as TVL.",
	kava: {
		tvl: kavaTvl,
	},
};

'''
'''--- projects/kavacave/kavaAbi.json ---
{
	"poolInfo":{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "poolInfo",
		"outputs": [
			{
				"internalType": "contract IERC20",
				"name": "lpToken",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "emi",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "lastRewardTime",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "accKavePerShare",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "depositFeeBP",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "totalcap",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "bonusBp",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "strat",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "sid",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
}
'''
'''--- projects/kavaswap.js ---
const utils = require('./helper/utils');
const sdk = require('@defillama/sdk')

async function tvl(timestamp, ethBlock, chainBlocks) {
    let balances = {};
    let url = `https://api2.kava.io/swap/pools`
    if(Math.abs(Date.now()/1000 - timestamp) > 3600){
        const block = await sdk.api.util.lookupBlock(timestamp, {chain:'kava'})
        url += `?height=${block.block}`
    }

    const response = await utils.fetchURL(url);

    for (let pool of response.data.result) {
        for (let coin of pool.coins) {
            let tokenInfo = generic(coin.denom);
            if(!tokenInfo) {
                console.log('unknown token', coin.denom)
                continue;
            }
            if (balances[tokenInfo[0]]) {
                balances[tokenInfo[0]] += coin.amount / 10**tokenInfo[1];
            } else {
                balances[tokenInfo[0]] = coin.amount / 10**tokenInfo[1];
            };
        };
    };
return balances;
}
function generic(ticker) {
    switch(ticker) {
        case 'bnb': return ['binancecoin',8];
        case 'btcb': return ['bitcoin',8];
        case 'busd': return ['binance-usd',8];
        case 'hard': return ['kava-lend',6];
        case 'swp': return ['kava-swap',6];
        case 'ukava': return ['kava',6];
        case 'xrpb': return ['ripple',8];
        case 'usdx': return ['usdx',6];
        case 'ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2': return ['cosmos',6];
        case 'ibc/799FDD409719A1122586A629AE8FCA17380351A51C1F47A80A1B8E7F2A491098': return ['akash-network',6];
        case 'ibc/B8AF5D92165F35AB31F3FC7C7B444B9D240760FA5D406C49D24862BD0284E395': return ['terra-luna',6];
        case 'ibc/0471F1C4E7AFD3F07702BEF6DC365268D64570F7C1FDC98EA6098DD6DE59817B': return ['osmosis',6];
        case 'ibc/B448C0CA358B958301D328CCDC5D5AD642FC30A6D3AE106FF721DB315F3DDE5C': return ['terrausd',6];
    };
};

module.exports = {
    timetravel: false,
    kava: { tvl }
}
'''
'''--- projects/kawaiiswap-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef")

const token = "0x9e236b43D779B385c3279820e322ABAE249D3405";
const masterchef = "0x1767B9aF34be444e3C727840d8D19dB0256dBCFA";

module.exports = {
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/kccguru/index.js ---
const sdk = require("@defillama/sdk")
const ITVL = [
 {
   "inputs": [],
   "name": "pool2",   //POOL2 TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "staking",   //STAKING TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
   "inputs": [],
   "name": "tvl",   //GLOABL TVL : 1e18 === 1 USD
   "outputs": [
     {
       "internalType": "uint256",
       "name": "",
       "type": "uint256"
     }
   ],
   "stateMutability": "view",
   "type": "function"
 },
 {
 "inputs": [],
 "name": "usd",   //On-chain USD Reference Token
 "outputs": [
   {
     "internalType": "address",
     "name": "",
     "type": "address"
   }
 ],
 "stateMutability": "view",
 "type": "function"
 }
]
const tvlGuru = "0x426a4A4B73d4CD173C9aB78d18c0d79d1717eaA9";   //On-Chain Universal TVL Finder
const USD = "kcc:0x0039f574eE5cC39bdD162E9A88e3EB1f111bAF48";   //same as abi.call({target:tvlGuru,abi:ITVL["usd"]})
//NOTE: USD===kcc:USDT is used explicitly to reduce EVM calls by this adapter. It makes this process faster.
async function pool2(timestamp,block) {
   let _pool2 = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[0],
    block: block,
    chain: 'kcc'
   });
   let balances={}
   balances[USD]=(_pool2.output)
   return balances;
}
async function staking(timestamp,block) {
   let _staking = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[1],
    block: block,
    chain: 'kcc'
   });
   let balances={}
   balances[USD]=(_staking.output)
   return balances;
}
async function tvl(timestamp,block) {
   let _tvl = await sdk.api.abi.call({
    target: tvlGuru,
    abi: ITVL[2],
    block: block,
    chain: 'kcc'
   });
   let balances={}
   balances[USD]=(_tvl.output)
   return balances;
}
module.exports = {
 methodology: "USD-denominated value aggregation of most Locked assets held across kcc.guru's & Kompound Protocol's smart contracts, powered by direct on-chain storage of quantity, pools and prices using ftm.guru's Universal TVL Finder Tool (tvlGuru.sol). More detailed documentation of TVL is available at https://ftm.guru/rawdata/tvl",
 kcc: {
   pool2: pool2,
   staking: staking,
   tvl: tvl
 },
}

'''
'''--- projects/kdlaunch/index.js ---
const axios = require("axios");
const { fetchLocal, mkMeta } = require("../helper/pact");

const network = (chainId) => `https://api.chainweb.com/chainweb/0.0/mainnet01/chain/${chainId}/pact`;
const GAS_PRICE = 0.00000001;
const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const getReserve = (tokenData) => {
  return parseFloat(tokenData.decimal ? tokenData.decimal : tokenData);
}

const getTokenToKadena = async (token) => {
  const chainId = '3';
  let data = await fetchLocal({
    pactCode: `
          (use free.exchange)
          (let*
            (
              (p (get-pair ${token} coin))
              (reserveA (reserve-for p ${token}))
              (reserveB (reserve-for p coin))
            )[reserveA reserveB])
           `,
    meta: mkMeta("account", chainId, GAS_PRICE, 3000, creationTime(), 600),
  }, network(chainId));

  if (data.result.status === "success") {
    const tokenReserve = getReserve(data.result.data[0]);
    const kadenaReserve = getReserve(data.result.data[1]);
    return kadenaReserve / tokenReserve;
  }

  throw new Error(`Kadena fetch failed`);
}

const fetchKdlPrice = async () => {
  return await getTokenToKadena("kdlaunch.token");
}

const getTotalStakedKdl = async () => {
  const chainId = '1';
  let data = await fetchLocal(
    {
      pactCode: '(kdlaunch.staking.get-staking-stats)',
      meta: mkMeta('', chainId, 0.01, 1000, 28800, creationTime())
    },
    network(chainId)
  );
  
  if (data.result.status === "success") {
    return getReserve(data.result.data.totalStaked);
  }

  throw new Error("Total KDL stacked failed");
}

async function fetchStakingTvl() {
  const kdlPrice = await fetchKdlPrice();
  const stakedKdl = await getTotalStakedKdl();
  return {
    kadena: stakedKdl * kdlPrice
  }
}

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  kadena: {
    tvl: ()=>({}),
    staking: fetchStakingTvl,
  }
}
'''
'''--- projects/kdswap/index.js ---
const { GraphQLClient, gql } = require('graphql-request')

const retry = require('../helper/retry')
const { fetchLocal, mkMeta } = require("../helper/pact");

const kdsExchangeContract = 'kdlaunch.kdswap-exchange';
const kdsExchangeTokenContract = 'kdlaunch.kdswap-exchange-tokens';
const chainId = "1";
const network = `https://api.chainweb.com/chainweb/0.0/mainnet01/chain/${chainId}/pact`;
const GAS_PRICE = 0.00000001;
const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const graphQLUrls = {
  "kadena": "https://kdswap-fd-prod-cpeabrdfgdg9hzen.z01.azurefd.net/graphql",
}

const getReserve = (tokenData) => {
  return parseFloat(tokenData.decimal ? tokenData.decimal : tokenData);
};

const getPairTokens = async (url) => {
  const graphQLClient = new GraphQLClient(url)
  const reserveQuery = gql`
    {
        pairs {
          id
          name: id
          token0 {
            name: tokenSymbol
            code
          }
          token1 {
            name: tokenSymbol
            code
          }
        }
      }
    `;
  return await retry(async bail => await graphQLClient.request(reserveQuery))
}

const normalizeTokens = (items, key) =>
  items.reduce((result, item) => {
    const selectedKey = item[key].replace('_', ':')
    const { token0, token1 } = item
    return {
      ...result,
      [selectedKey]: {
        name: selectedKey,
        token0,
        token1,
      }
    }
  }, {})

const getPairList = async (url, grouper) => {
  const { pairs } = await getPairTokens(url)
  const pairTokens = normalizeTokens(pairs, grouper);

  try {
    return await Promise.all(
      Object.values(pairTokens).map(async (pair) => {
        const data = await fetchLocal(
          {
            pactCode: `
                        (use ${kdsExchangeContract})
                        (let*
                        (
                            (p (get-pair ${pair.token0.code} ${pair.token1.code}))
                            (reserveA (reserve-for p ${pair.token0.code}))
                            (reserveB (reserve-for p ${pair.token1.code}))
                            (totalBal (${kdsExchangeTokenContract}.total-supply (${kdsExchangeContract}.get-pair-key ${pair.token0.code} ${pair.token1.code})))
                        )[totalBal reserveA reserveB])
                        `,
            meta: mkMeta("", chainId, GAS_PRICE, 3000, creationTime(), 600),
          },
          network
        );

        if (data.result.status === "success") {
          return {
            reserves: [
              getReserve(data.result.data[1]),
              getReserve(data.result.data[2]),
            ],
          };
        }
        throw new Error("Pair reserves fetch failed");
      })
    );
  } catch (err) {
    throw new Error(err);
  }
};

const calculateKdaTotal = (pairList) => pairList.reduce((amount, pair) => amount += pair.reserves[0], 0)

async function fetch() {
  const pairList = await getPairList(graphQLUrls['kadena'], 'id');
  const kdaTotal = calculateKdaTotal(pairList);

  /*
   * value of each pool taken to be twice the value of its KDA
   */
  return {
    kadena: 2 * kdaTotal
  };
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  methodology: "TVL accounts for the liquidity on all KDSWAP AMM pools, with all values calculated in terms of KDA price.",
  kadena: {
    tvl: fetch,
  },
}
'''
'''--- projects/kebab-finance/index.js ---
const sdk = require("@defillama/sdk");
const { transformBscAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");

const masterchef = "0x76FCeffFcf5325c6156cA89639b17464ea833ECd";
const kebab = "0x7979F6C54ebA05E18Ded44C4F986F49a5De551c2";
const poolInfoAbi = {
  inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
  name: "poolInfo",
  outputs: [
    { internalType: "contract IBEP20", name: "lpToken", type: "address" },
    { internalType: "uint256", name: "allocPoint", type: "uint256" },
    { internalType: "uint256", name: "lastRewardBlock", type: "uint256" },
    { internalType: "uint256", name: "accCakePerShare", type: "uint256" },
  ],
  stateMutability: "view",
  type: "function",
};

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  const transform = await transformBscAddress();
  await addFundsInMasterChef(
    balances,
    masterchef,
    chainBlocks.bsc,
    "bsc",
    transform,
    poolInfoAbi,
    [kebab]
  );

  return balances;
}

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  let stakeBalance = (
    await sdk.api.erc20.balanceOf({
      target: kebab,
      owner: masterchef,
      block: chainBlocks.bsc,
      chain: "bsc",
    })
  ).output;
  sdk.util.sumSingleBalance(balances, `bsc:${kebab}`, stakeBalance);
  return balances;
}

module.exports = {
  bsc: {
    tvl,
    staking,
  },
};

'''
'''--- projects/keep.js ---
const retry = require('./helper/retry')
const { GraphQLClient, gql } = require('graphql-request')
const utils = require('./helper/utils');
const sdk = require('@defillama/sdk')

async function tvl() {
  var q2 =  gql`{
  totalBondedECDSAKeeps {
      id
      totalAvailable
      totalBonded
      totalKeepActive
      totalKeepOpened
    }
  }
  `;
  var endpoint = 'https://api.thegraph.com/subgraphs/name/suntzu93/tbtc';
  var graphQLClient = new GraphQLClient(endpoint)
  const results2 = await retry(async bail => await graphQLClient.request(q2))
  var ethStaked = parseFloat(results2.totalBondedECDSAKeeps[0].totalBonded) + parseFloat(results2.totalBondedECDSAKeeps[0].totalAvailable);
  const balances = {
    ethereum: ethStaked
  }
  balances['0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa'] = (await sdk.api.erc20.totalSupply({ target: '0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa' })).output
  return balances
}

async function staking() {
  var q1 =  gql`{
      tokenStakings {
        contractAddress
        totalStaker
        totalTokenStaking
        totalTokenSlash
        members(first: 5, where: {stakingState: STAKED}, orderBy: amount, orderDirection: desc) {
          id
          amount
        }
      }
    }
  `;

  var endpoint = 'https://api.thegraph.com/subgraphs/name/suntzu93/keepnetwork';
  var graphQLClient = new GraphQLClient(endpoint)
  const results = await retry(async bail => await graphQLClient.request(q1))
  const keepPoolStaked = await utils.returnBalance('0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC', '0xCf916681a6F08fa22e9EF3e665F2966Bf3089Ff1')
  var keepStaked = parseFloat(results.tokenStakings[0].totalTokenStaking)+keepPoolStaked
  return {
    'keep-network': keepStaked
  }
  
}

module.exports = {
  timetravel: false, 
  ethereum: {
    tvl,
    staking,
  }
}

'''
'''--- projects/keep3r/abis.js ---
exports.abis = {
  userInfo: {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "userInfo",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "rewardDebt",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },

  totalBorrows: {
    constant: true,
    inputs: [],
    name: "totalBorrows",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    payable: false,
    stateMutability: "view",
    type: "function",
  },

  priceRegistry: {
    constant: true,
    inputs: [{ name: "_forex", type: "address" }],
    name: "price",
    outputs: [{ name: "", type: "uint256" }],
    type: "function",
  },

  totalSupply: {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "totalSupply", type: "uint256" }],
    type: "function",
  },

  getReserves: {
    constant: true,
    inputs: [],
    name: "getReserves",
    outputs: [{ name: "_reserve0", type: "uint112"}, { name: "_reserve1", type: "uint112"}, { name: "_blockTimestampLast", type: "uint32"} ]
  }
};

'''
'''--- projects/keep3r/index.js ---
// @ts-check
/**
* @typedef {{ [address: string]: string }} Balances
* @typedef {{ [address: string]: { price: string } }} TokenPrices
* @typedef {{ [address: string]: { price: string, balance: string } }} TokenData
*/
const sdk = require("@defillama/sdk");

const abis = require("./abis.js").abis;
const registry = require("./registry.js").registry;
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const utils = require("../helper/utils");

// =================== UTILS ===================

/**
 * @param {number} usd
 * @param {string} bn
 * @returns {bigint}
 */
const multiplyUSDby1e18 = (usd, bn) =>
  (BigInt(Math.round(usd * 100)) * BigInt(bn)) / BigInt(1e18) / BigInt(100);

/**
 * @param {Balances} balances
 * @param {TokenPrices} tokenPrices
 * @returns {bigint}
 */
const getTVLFromBalancesAndTokenPrices = (balances, tokenPrices) => {
  const ibTokenAddresses = Object.keys(tokenPrices).map((a) => a.toLowerCase());

  const ibTokensData = ibTokenAddresses.reduce((acc, addr) => {
    acc[addr].balance = balances[addr];
    return acc;
  }, /** @type {TokenData} */ (tokenPrices));

  return Object.values(ibTokensData).reduce(
    (acc, { price, balance }) =>
      acc + (BigInt(price) * BigInt(balance)) / BigInt(1e36),
      BigInt(0)
  );
};

// =================== TVL getters ===================

/**
 * WARNING: this method return prices with 1e18 base, those can't be used in `multiplyUSDby1e18` function
 * @param {any} options
 * @returns {Promise<TokenPrices>} prices
 */
const getIbTokenPrices = async ({ block }) => {
  const ibTokensAddresses = Object.values(registry.ibTokens);
  const { output } = await sdk.api.abi.multiCall({
    block: block,
    calls: ibTokensAddresses.map((address) => ({
      target: registry.FF_REGISTRY,
      params: address,
    })),
    abi: abis.priceRegistry,
  });

  return output.reduce((acc, curr) => {
    const address = curr.input.params[0].toLowerCase();

    acc[address] = {
      price: curr.output,
    };

    return acc;
  }, {});
};

/**
 * @param {{ balances: Balances, block: any }} options
 * @return {Promise<BigInt>} ibTokensTVL
 */
const getIbTokensTVL = async ({ balances, block }) => {
  const ibTokenPrices = await getIbTokenPrices({ block });

  return getTVLFromBalancesAndTokenPrices(balances, ibTokenPrices);
};

/**
 * @param {{ balances: Balances }} options
 * @return {Promise<BigInt>} kp3rTVL
 */
const getKLPsTVL = async ({ balances }) => {
  const WETH = registry.WETH.toLowerCase();
  const KP3R = registry.KP3R.toLowerCase();
  const klp = registry.Kp3rV2Klps.KP3R_WETH_1_PERCENT.toLowerCase();

  const addresses = [KP3R, WETH];

  const { data } = await utils.getPricesFromContract(addresses);

  const kp3rPrice = data[KP3R].usd;
  const wethPrice = data[WETH].usd;

  const klpPrice = 2 * Math.sqrt(kp3rPrice / wethPrice) * wethPrice;

  const klpTvl = multiplyUSDby1e18(klpPrice, balances[klp]);

  return klpTvl;
};

/**
 * @param {{ balances: Balances }} options
 * @return {Promise<BigInt>} kp3rTVL
 */
const getOtherTokensTVL = async ({ balances }) => {
  const addresses = [
    registry.KP3R,
    registry.WETH,
    registry.CVX,
    registry.DAI,
    registry.SUSHI,
    registry.CRV,
    registry.CVXCRV,
    registry.SPELL,
    registry.ARMOR,
    registry.HEGIC,
    registry.LDO,
    registry.MM,
  ];

  const { data } = await utils.getPricesFromContract(addresses);

  const othersTvl = addresses.reduce((acc, curr) => {
    const addr = curr.toLowerCase();
    const price = data[addr].usd;
    const balance = balances[addr];

    acc += multiplyUSDby1e18(price, balance);
    return acc;
  }, BigInt(0));

  return othersTvl;
};

// =================== MAIN FUNCTIONS ===================

/**
 * @param {string} timestamp
 * @param {any} block
 * @return {Promise<BigInt>} TVL
 */
async function fetch(timestamp, block) {
  const balances = /** @type {Balances} */ (await tvl(timestamp, block));

  const IB_TOKENS_TVL = await getIbTokensTVL({ balances, block });
  const KLPS_TVL = await getKLPsTVL({ balances });

  const OTHER_TOKENS_TVL = await getOtherTokensTVL({ balances });

  // @ts-ignore
  const TVL = IB_TOKENS_TVL + OTHER_TOKENS_TVL + KLPS_TVL;

  return TVL;
}

/**
 * @param {string} _timestamp
 * @param {any} block
 * @return {Promise<any>} TVL
 */
async function staking(_timestamp, block) {
  const { KP3R, VKP3R } = registry;
  const balances = {};

  await sumTokensAndLPsSharedOwners(balances, [[KP3R, false]], [VKP3R], block);

  // @dev should return stakingTvl
  return balances;
}

/**
 * @param {string} _timestamp
 * @param {any} block
 * @return {Promise<any>} TVL
 */
async function borrowed(_timestamp, block) {
  /** @type {Balances} */
  const balances = {};

  const cyTokens = Object.values(registry.cTokens);
  const { output: borrowed } = await sdk.api.abi.multiCall({
    block: block,
    calls: cyTokens.map((coin) => ({
      target: coin,
    })),
    abi: abis.totalBorrows,
  });

  const ib = Object.values(registry.ibTokens);
  for (const idx in borrowed) {
    sdk.util.sumSingleBalance(
      balances,
      ib[idx].toLowerCase(),
      borrowed[idx].output
    );
  }

  const ibTokenPrices = await getIbTokenPrices({ block });

  const borrowedTvl = getTVLFromBalancesAndTokenPrices(balances, ibTokenPrices);

  // @dev should return borrowedTvl
  return balances;
}

/**
 * @param {string} _timestamp
 * @param {any} block
 * @return {Promise<Balances>} balances
 */
async function tvl(_timestamp, block) {
  /** @type {Balances} */
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [
      [registry.CVX, false],
      [registry.DAI, false],
      [registry.KP3R, false],
      [registry.SUSHI, false],
      [registry.CRV, false],
      [registry.CVXCRV, false],
      [registry.SPELL, false],
      [registry.WETH, false],
    ].concat(
      [
        [registry.KPR_WETH_SUSHI_POOL, true],
        [registry.USDC_ibAUD_POOL, true],
        [registry.USDC_ibEUR_POOL, true],
        [registry.USDC_ibKRW_POOL, true],
        [registry.USDC_ibJPY_POOl, true],
        [registry.USDC_ibGBP_POOL, true],
        [registry.USDC_ibCHF_POOL, true],
      ],
      Object.values(registry.ibTokens).map((t) => [t, false])
    ),
    [registry.YEARN_DEPLOYER, registry.BOND_TREASURY].concat(
      Object.values(registry.cTokens),
      Object.values(registry.ibCrvGauges)
    ),
    block
  );

  await sumTokensAndLPsSharedOwners(
    balances,
    Object.values(registry.Kp3rV2Klps).map((t) => [t, false]),
    [registry.KP3RV2],
    block
  );

  await sumTokensAndLPsSharedOwners(
    balances,
    Object.values(registry.Kp3rV1Slps).map((t) => [t, true]),
    [registry.KP3R],
    block
  );

  return balances;
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    staking,
    borrowed
  },
  fetch,
};

'''
'''--- projects/keep3r/registry.js ---
exports.registry = {
  KP3R: "0x1ceb5cb57c4d4e2b2433641b95dd330a33185a44",
  KP3RV2: "0xeb02addCfD8B773A5FFA6B9d1FE99c566f8c44CC",
  VKP3R: "0x2FC52C61fB0C03489649311989CE2689D93dC1a2",
  KPR_LDO_SUSHI_POOL: "0x79e0d4858af8071349469b6589a3c23c1fe1586e",
  KPR_WETH_SUSHI_POOL: "0xaf988aff99d3d0cb870812c325c588d8d8cb7de8",
  KPR_MM_SUSHI_POOL: "0x18ee956e99cc606530c20d9cadd6af5ece08d89f",
  KPR_AMOR_SUSHI_POOL: "0x9c2efb900290402fd2b891170085b9d651bfc5ce",
  USDC_ibAUD_POOL: "0x71852e888a601c9bbb6f48172a9bfbd8010aa810",
  USDC_ibEUR_POOL: "0x5271d250bf9528981846a9dd94a97cbbe7318817",
  USDC_ibKRW_POOL: "0xa42f219d4394216d851d75dcb6b742595146379c",
  USDC_ibJPY_POOl: "0xeaebf8736ec441eecec31533ebd3a21d61caa252",
  USDC_ibGBP_POOL: "0x8704850232ab7f3490f64b14fd8c8b3e6e411914",
  USDC_ibCHF_POOL: "0x1f2bcc260483443a9dd686307bb2809a78400a4f",
  BOND_TREASURY: "0xc43b3b33b21dfcef48d8f35e6671c4f4be4ef8a2",
  SEUR: "0xd71ecff9342a5ced620049e616c5035f1db98620",
  SAUD: "0xF48e200EAF9906362BB1442fca31e0835773b8B4",
  SGBP: "0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F",
  SKRW: "0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B",
  SJPY: "0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d",
  SCHF: "0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d",
  MIM: "0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3",
  CVX: "0x4e3fbd56cd56c3e72c1403e103b45db9da5b9d2b",
  DAI: "0x6b175474e89094c44da98b954eedeac495271d0f",
  SUSHI: "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2",
  CRV: "0xD533a949740bb3306d119CC777fa900bA034cd52",
  CVXCRV: "0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7",
  SPELL: "0x090185f2135308BaD17527004364eBcC2D37e5F6",
  WETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  LDO: "0x5a98fcbea516cf06857215779fd812ca3bef1b32",
  ARMOR: "0x1337def16f9b486faed0293eb623dc8395dfe46a",
  HEGIC: "0x584bc13c7d411c00c01a62e8019472de68768430",
  MM: "0xa283aA7CfBB27EF0cfBcb2493dD9F4330E0fd304",
  YEARN_DEPLOYER: "0x0D5Dc686d0a2ABBfDaFDFb4D0533E886517d4E83",
  MASTERCHEF: "0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd",
  FF_REGISTRY: "0x5C08bC10F45468F18CbDC65454Cbd1dd2cB1Ac65",

  Kp3rV2Klps: {
    KP3R_WETH_1_PERCENT: "0x3f6740b5898c5D3650ec6eAce9a649Ac791e44D7",
  },

  Kp3rV1Slps: {
    SUSHI_KP3R_ETH: "0xaf988afF99d3d0cb870812C325C588D8D8CB7De8",
    SUSHI_KP3R_LDO: "0x79e0D4858AF8071349469B6589a3c23C1fE1586E",
    SUSHI_ARMOR_KP3R: "0x9C2Efb900290402fd2b891170085B9d651bfC5Ce",
    SUSHI_KP3R_MM: "0x18EE956E99cC606530C20d9CAdD6AF5EcE08d89F",
    SUSHI_KP3R_HEGIC: "0x19bF7b6821473BeA075F207D6269209c856896F6",
  },

  // v2 gauges
  ibCrvGauges: {
    EUR: "0x19b080FE1ffA0553469D20Ca36219F17Fcf03859",
    AUD: "0x3F1B0278A9ee595635B61817630cC19DE792f506",
    GBP: "0xD6Ac1CB9019137a896343Da59dDE6d097F710538",
    KRW: "0x8461A004b50d321CB22B7d034969cE6803911899",
    JPY: "0x8818a9bb44Fbf33502bE7c15c500d0C783B73067",
    CHF: "0x9c2C8910F113181783c249d8F6Aa41b51Cde0f0c",
  },

  // Iron Bank Collateral
  cTokens: {
    CYEUR: "0x00e5c0774a5f065c285068170b20393925c84bf3",
    CYJPY: "0x215F34af6557A6598DbdA9aa11cc556F5AE264B1",
    CYGBP: "0xecaB2C76f1A8359A06fAB5fA0CEea51280A97eCF",
    CYCHF: "0x1b3E95E8ECF7A7caB6c4De1b344F94865aBD12d5",
    CYAUD: "0x86BBD9ac8B9B44C95FFc6BAAe58E25033B7548AA",
    CYKRW: "0x3c9f5385c288cE438Ed55620938A4B967c080101",
  },

  ibTokens: {
    IBEUR: "0x96e61422b6a9ba0e068b6c5add4ffabc6a4aae27",
    IBJPY: "0x5555f75e3d5278082200Fb451D1b6bA946D8e13b",
    IBGBP: "0x69681f8fde45345C3870BCD5eaf4A05a60E7D227",
    IBCHF: "0x1CC481cE2BD2EC7Bf67d1Be64d4878b16078F309",
    IBAUD: "0xFAFdF0C4c1CB09d430Bf88c75D88BB46DAe09967",
    IBKRW: "0x95dFDC8161832e4fF7816aC4B6367CE201538253",
  },
};

'''
'''--- projects/keeper-dao/abi/liquidity.json ---
{
  "registeredTokens": {
    "constant": true,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "registeredTokens",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "kToken": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_token",
        "type": "address"
      }
    ],
    "name": "kToken",
    "outputs": [
      {
        "internalType": "contract IKToken",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "tokenByIndex": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "tokenByIndex",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract CToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOfUnderlying": {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "balanceOfUnderlying",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/keeper-dao/index.js ---

const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js');
const liquidityAbi = require('./abi/liquidity.json');

const ETH = '0x0000000000000000000000000000000000000000';

const LIQUIDITY_POOL_CONTRACTS = {
  liquidityPoolContractV3: '0x35fFd6E268610E764fF6944d07760D0EFe5E40E5',
  liquidityPoolContractV4: '0x4F868C1aa37fCf307ab38D215382e88FCA6275E2'
}
const HIDING_VAULT_START_BLOCK_NUMBER = 12690306;
const HIDING_VAULT_CONTRACT = '0xE2aD581Fc01434ee426BB3F471C4cB0317Ee672E';
const COMPOUND_COMPTROLLER_ADDRESS = '0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B';

// cache some data
let markets = {
  '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE': {
    symbol: 'ETH',
    decimals: 18,
    kToken: '0xC4c43C78fb32F2c7F8417AF5af3B85f090F1d327',
  },
  '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2': {
    symbol: 'WETH',
    decimals: 18,
    kToken: '0xac19815455C2c438af8A8b4623F65f091364be10',
  },
  '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': {
    symbol: 'USDC',
    decimals: 6,
    kToken: '0xac826952bc30504359a099c3a486d44E97415c77',
  },
  '0x6B175474E89094C44Da98b954EedeAC495271d0F': {
    symbol: 'DAI',
    decimals: 18,
    kToken: '0x0314b6CC36Ea9b48f34a350828Ce98F17B76bC44',
  },
  '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599': {
    symbol: 'WBTC',
    decimals: 8,
    kToken: '0xDfd1B73e7635D8bDA4EF16D5f364c6B6333769C8',
  },
  '0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D': {
    symbol: 'renBTC',
    decimals: 8,
    kToken: '0xDcAF89b0937c15eAb969Ea01f57AAacc92A21995',
  },
};

async function getToken(block, index, liquidityPool) {
  for (let i = 0; i < 5; i++) {
    try {
      return (await sdk.api.abi.call({
        block,
        target: liquidityPool,
        params: [index],
        abi: liquidityAbi['registeredTokens'],
      })).output
    } catch (e) {
    }
  }
  return null
}

async function getAllTokens(block, liquidityPool) {
  let tokens = []
  for (let i = 0; ; i++) {
    const token = await getToken(block, i, liquidityPool)

    if (!token) {
      break;
    }

    tokens.push(token)
  }

  return tokens;
}

async function getKToken(block, token, liquidityPool) {
  return (await sdk.api.abi.call({
    block,
    target: liquidityPool,
    params: [token],
    abi: liquidityAbi['kToken'],
  })).output;
}

// returns {[underlying]: {kToken, decimals, symbol}}
async function getMarkets(block, liquidityPool) {
  if (block < 11908288) {
    // the allMarkets getter was only added in this block.
    return markets;
  } else {
    let allTokens = await getAllTokens(block, liquidityPool);
    // if not in cache, get from the blockchain
    for (const token of allTokens) {
      let kToken = await getKToken(block, token, liquidityPool);

      if (!markets[token]) {
        let info = await sdk.api.erc20.info(token);
        markets[token] = { kToken, decimals: info.output.decimals, symbol: info.output.symbol };
      }
    }

    return markets;
  }
}

// Calculates all the token balances in Hiding Vault NFTs minted till the given block
async function getHidingVaultBalances(timestamp, block) {
  let hidingVaultBalances = {}

  // Track TVL of Hiding Vaults after it went live
  if (block > HIDING_VAULT_START_BLOCK_NUMBER) {
    // Get total Hiding Vault NFT count by calling totalSupply on Hiding Vault Contract
    // Using erc20 lib as erc721 lib isn't supported yet.
    let noOfHidingVaults = (await sdk.api.erc20.totalSupply({
      target: HIDING_VAULT_CONTRACT,
      block: block
    })).output;

    // numberRange to iterate over indexes of NFTs. Can migrate to any supported util func of erc721 when it is supported.
    const indexRange = [];
    for (let i = 0;i < +noOfHidingVaults; i++)
      indexRange.push(i)

    // Query Hiding Vault Contract's 'tokenByIndex' with index to get individual HidingVaultNFTs
    let totalHidingVaultNFTs = (await sdk.api.abi.multiCall({
      target: HIDING_VAULT_CONTRACT,
      calls: indexRange.map((index) => ({
        params: [index],
      })),
      abi: liquidityAbi['tokenByIndex'],
      block: block
    })).output;

    totalHidingVaultNFTs = totalHidingVaultNFTs.map(hidingVaultNFT => hidingVaultNFT.output);

    // all of Compound's supply & borrow assets adresses
    const { output: cTokens } = await sdk.api.abi.call(
      {
        block,
        target: COMPOUND_COMPTROLLER_ADDRESS,
        params: [],
        abi: liquidityAbi["getAllMarkets"]
      }
    )

    // for each of Compound's cTokens get all of hidingVaultNFT balance and the underlying token address
    await Promise.all(cTokens.map(async (cTokenAddress) => {
      // get the underlying token address
      const isCEth = cTokenAddress.toLowerCase() === "0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5"
      const { output: token } = isCEth
        ? { output: '0x0000000000000000000000000000000000000000' } // ETH has no underlying asset on Compound
        : await sdk.api.abi.call(
          {
            block,
            target: cTokenAddress,
            params: [],
            abi: liquidityAbi["underlying"]
          }
        )

      // making a call to get the asset balance for each hidingVaultNFT
      const calls = []

      totalHidingVaultNFTs.forEach(hidingVaultNFT => {
        calls.push({
          target: cTokenAddress,
          params: [hidingVaultNFT]
        })
      })

      const underlyingBalances = await sdk.api.abi.multiCall({
        abi: liquidityAbi["balanceOfUnderlying"],
        calls,
        block,
      });

      // accumulating all our hidingVaultNFT balances to calculate the TVL for this cToken
      const sumTotal = underlyingBalances.output.map(({ output }) => output).reduce((acc, val) => {
        return (new BigNumber(acc).plus(new BigNumber(val))).toString(10)
      }, "0")

      hidingVaultBalances[token] = (new BigNumber(hidingVaultBalances[token] || "0").plus(new BigNumber(sumTotal))).toString(10);
    }));
  }

  return hidingVaultBalances;
}

// Calculates the token balances in Liquidity Pool Contracts till the given block
async function getLiquidityPoolBalances(timestamp, block) {
  let liquidityPoolBalances = {};

  // Cumulative token balances from all liqudity pool contracts
  for (let liquidityPool of Object.values(LIQUIDITY_POOL_CONTRACTS)) {
    let markets = await getMarkets(block, liquidityPool);
    // Get token balances
    let balances = await sdk.api.abi.multiCall({
      block,
      calls: Object.keys(markets).map((token) => ({
        target: token,
        params: liquidityPool,
      })).filter(m => m.target !== "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"),
      abi: 'erc20:balanceOf',
    });

    sdk.util.sumMultiBalanceOf(liquidityPoolBalances, balances);

    let ethBalance = (await sdk.api.eth.getBalance({ target: liquidityPool, block })).output;
    sdk.util.sumSingleBalance(liquidityPoolBalances, ETH, ethBalance)
  }

  return liquidityPoolBalances;
}

async function tvl(timestamp, block) {
  const liquidityPoolBalances = await getLiquidityPoolBalances(timestamp, block);
  const hidingVaultBalances = await getHidingVaultBalances(timestamp, block);

  const totalBalances = {};

  const uniq = arry => [... new Set(arry)]
  uniq(Object.keys(hidingVaultBalances).concat(Object.keys(liquidityPoolBalances))).forEach(asset => {
    totalBalances[asset] = new BigNumber(hidingVaultBalances[asset] || "0").plus(new BigNumber(liquidityPoolBalances[asset] || "0")).toString(10);
  });

  return totalBalances;
}

module.exports = {
  start: 1611991703, // 01/30/2021 @ 07:28:23 AM +UTC
  ethereum: {
    tvl
  }
};

'''
'''--- projects/kefirswap/index.js ---
const { getUniTVL } = require('../helper/unknownTokens')

// const KEFIR = "0xf5E547C683f5d72D6A463542d3e2cC13C5470D71"
const FACTORY = "0xeEAbe2F15266B19f3aCF743E69105016277756Fb"
const WKAVA = "0xc86c7C0eFbd6A49B35E8714C5f59D99De09A225b"

module.exports = {
  methodology: "Count TVL as liquidity on the dex",
  misrepresentedTokens: true,
  kava: {
    tvl: getUniTVL({
      chain: 'kava',
      factory: FACTORY,
      coreAssets: [
        WKAVA
      ]
    }),
  }
} 

'''
'''--- projects/ketchupfinance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0x7bBcD33415984b820D31BBda6339E55A03b5F8cA";
const token = "0x5D266f324Eb3DD753fF828fA45d80F09D7C75dff";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/killswitch/index.js ---
const utils = require("../helper/utils");

const tvlUrl = "https://api.killswitch.finance/ksw/tvl";

function fetchChain(chain) {
  return async () => {
    const response = await utils.fetchURL(tvlUrl);

    let tvl = Number(response.data.summary[chain]);
    if (tvl === 0) {
      throw new Error(`chain ${chain} tvl is 0`);
    }

    return tvl;
  };
}

async function fetch() {
  const response = await utils.fetchURL(tvlUrl);

  let tvl = 0;
  for (const chain in response.data.summary) {
    tvl += Number(response.data.summary[chain]);
  }
  if (tvl === 0) {
    throw new Error("tvl is 0");
  }

  return tvl;
}

module.exports = {
  doublecounted: true,
  timetravel: false,
  misrepresentedTokens: true,
  bsc: {
    fetch: fetchChain("bsc"),
  },
  kcc: {
    fetch: fetchChain("kcc"),
  },
  aurora: {
    fetch: fetchChain("aurora"),
  },
  fetch,
};

'''
'''--- projects/kimochifinance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const MasterChefContract = "0xc88264770C43826dE89bCd48a5c8BC5073e482a5";
const KIMOCHI = "0x4dA95bd392811897cde899d25FACe253a424BfD4";

module.exports = {
  misrepresentedTokens: true,
  ...masterChefExports(MasterChefContract, "bsc", KIMOCHI),
  methodology: "TVL includes all farms in MasterChef contract",
};

'''
'''--- projects/kinefinance/abi.json ---
{
  "getAllMarkets": {
    "constant": true,
    "inputs": [],
    "name": "getAllMarkets",
    "outputs": [
      {
        "internalType": "contract KToken[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "underlying": {
    "constant": true,
    "inputs": [],
    "name": "underlying",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "totalBorrows": {
    "constant": true,
    "inputs": [],
    "name": "totalBorrows",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/kinefinance/index.js ---
const sdk = require("@defillama/sdk");
const { BigNumber } = require("bignumber.js");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const abi = require("./abi.json");

const translate = {
  "0xbfa9df9ed8805e657d0feab5d186c6a567752d7f":"0xcbfef8fdd706cde6f208460f2bf39aa9c785f05d",
  "0xa9c1740fa56e4c0f6ce5a792fd27095c8b6ccd87":"0xcbfef8fdd706cde6f208460f2bf39aa9c785f05d"
}

async function getUnitrollerTvl(block, chain, unitroller, cToken, cTokenEquivalent, kine, xKine, kMcd) {
  let balances = {};

  const allMarkets = (await sdk.api.abi.call({
    target: unitroller,
    abi: abi["getAllMarkets"],
    block,
    chain
  })).output;

  for (let i = allMarkets.length -1 ; i >= 0; i--) {
    let address = allMarkets[i].toLowerCase();
    if (address === cToken || address === kMcd) {
      allMarkets.splice(i, 1);
    }
  }

  const cTokenBalance = (await sdk.api.erc20.totalSupply({
    target: cToken,
    block,
    chain
  })).output;

  sdk.util.sumSingleBalance(balances, `${chain}:${cTokenEquivalent}`, cTokenBalance);

  const underlyings = (await sdk.api.abi.multiCall({
    calls: allMarkets.map(p => ({
      target: p
    })),
    abi: abi["underlying"],
    block,
    chain
  })).output;

  const underlyingBalances = (await sdk.api.abi.multiCall({
    calls: underlyings.map(p => ({
      target: p.output,
      params: p.input.target
    })),
    abi: "erc20:balanceOf",
    block,
    chain
  })).output;

  const symbols = (await sdk.api.abi.multiCall({
    calls: underlyings.map(p => ({
      target: p.input.target
    })),
    abi: "erc20:symbol",
    block,
    chain
  })).output;

  let lpPositions = [];

  for (let i = 0; i < underlyingBalances.length; i++) {
    let token = underlyingBalances[i].input.target.toLowerCase();
    let balance = underlyingBalances[i].output;
    let symbol = symbols[i].output;

    if (symbol.endsWith("LP")) {
      lpPositions.push({
        token,
        balance
      });
      continue;
    }

    if (token === xKine) {
      const totalSupply = (await sdk.api.erc20.totalSupply({
        target: xKine,
        block,
        chain
      })).output;
  
      const kineBal = (await sdk.api.erc20.balanceOf({
        target: kine,
        owner: xKine,
        block,
        chain
      })).output;
  
      const ratio = Number(kineBal) / Number(totalSupply);
      balance = BigNumber(balance).times(ratio).toFixed(0);
      token = kine;
    }

    if (translate[token] !== undefined) {
      sdk.util.sumSingleBalance(balances, translate[token], balance);
      continue;
    }
    sdk.util.sumSingleBalance(balances, `${chain}:${token}`, balance);
  }

  await unwrapUniswapLPs(balances, lpPositions, block, chain, addr=> {
    addr = addr.toLowerCase();
    if (translate[addr] !== undefined) {
      return translate[addr];
    }
    return `${chain}:${addr}`;
  });

  return balances;
}

async function getBorrowed(block, chain, kMcd) {
  let balances = {};

  const totalBorrows = (await sdk.api.abi.call({
    target: kMcd,
    abi: abi["totalBorrows"],
    block,
    chain
  })).output;

  sdk.util.sumSingleBalance(balances, "0xdac17f958d2ee523a2206206994597c13d831ec7", BigNumber(totalBorrows).div(1e12).toFixed(0));

  return balances;
}

const ethUnitroller = "0xbb7d94a423f4978545ecf73161f0678e8afd1a92";
const keth = "0xa58e822de1517aae7114714fb354ee853cd35780";
const weth = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const ethXKine = "0xa8d7643324df0f38764f514eb1a99d8f379cc692";
const ethKine = "0xcbfef8fdd706cde6f208460f2bf39aa9c785f05d";
const ethkMcd = "0xaf2617aa6fd98581bb8cb099a16af74510b6555f";

async function ethTvl(timestamp, block) {
  return await getUnitrollerTvl(block, "ethereum", ethUnitroller, keth, weth, ethKine, ethXKine, ethkMcd);
}

async function ethBorrow(timestamp, block) {
  return await getBorrowed(block, "ethereum", ethkMcd);
}

const bscUnitroller = "0x3c2ddd486c07343b711a4415cdc9ab90ed32b571";
const kbnb = "0x5fbe4eb536dadbcee54d5b55ed6559e29c60b055";
const wbnb = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c";
const bscXKine = "0x8f5abd0d891d293b13f854700ff89210da3d5ba3";
const bscKine = "0xbfa9df9ed8805e657d0feab5d186c6a567752d7f";
const bsckMcd = "0x4f1ab95b798084e44d512b8b0fed3ef933177986";

async function bscTvl(timestamp, block, chainBlocks) {
  return await getUnitrollerTvl(chainBlocks.bsc, "bsc", bscUnitroller, kbnb, wbnb, bscKine, bscXKine, bsckMcd);
}

async function bscBorrowed(timestamp, block, chainBlocks) {
  return await getBorrowed(chainBlocks.bsc, "bsc", bsckMcd);
}

const polygonUnitroller = "0xdff18ac4146d67bf2ccbe98e7db1e4fa32b96881";
const kmatic = "0xf186a66c2bd0509beaafca2a16d6c39ba02425f9";
const wmatic = "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270";
const polygonXKine = "0x66a782c9a077f5adc988cc0b5fb1cdcc9d7adeda";
const polygonKine = "0xa9c1740fa56e4c0f6ce5a792fd27095c8b6ccd87";
const polygonkMcd = "0xcd6b46443becad4996a70ee3d8665c0b86a0c54c";

async function polygonTvl(timestamp, block, chainBlocks) {
  return await getUnitrollerTvl(chainBlocks.polygon, "polygon", polygonUnitroller, kmatic, wmatic, polygonKine, polygonXKine, polygonkMcd);
}

async function polygonBorrowed(timestamp, block, chainBlocks) {
  return await getBorrowed(chainBlocks.polygon, "polygon", polygonkMcd);
}

const avaxUnitroller = "0x0ec3126390c606be63a0fa6585e68075f06679c6";
const kavax = "0x0544be6693763d64c02f49f16986ba1390a2fc39";
const wavax = "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7";
const avaxXKine = "0x68b9737ae74cf1a169890042f1aa359647aa3e47";
const avaxKine = "0xa9c1740fa56e4c0f6ce5a792fd27095c8b6ccd87";
const avaxkMcd = "0xcd6b46443becad4996a70ee3d8665c0b86a0c54c";

async function avaxTvl(timestamp, block, chainBlocks) {
  return await getUnitrollerTvl(chainBlocks.avax, "avax", avaxUnitroller, kavax, wavax, avaxKine, avaxXKine, avaxkMcd);
}

async function avaxBorrowed(timestamp, block, chainBlocks) {
  return await getBorrowed(chainBlocks.avax, "avax", avaxkMcd);
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
    borrowed: ethBorrow
  },
  bsc: {
    tvl: bscTvl,
    borrowed: bscBorrowed
  },
  polygon: {
    tvl: polygonTvl,
    borrowed: polygonBorrowed
  },
  avalanche: {
    tvl: avaxTvl,
    borrowed: avaxBorrowed
  }
}
'''
'''--- projects/kinesis/index.js ---
/*==================================================
  Modules
  ==================================================*/
  const axios = require("axios");
  const sdk = require("@defillama/sdk");
  const BigNumber = require("bignumber.js");

  const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
  // const {
  //   transformEvmosAddress
  // } = require("../helper/portedTokens");
  const { getChainTransform} = require("../helper/portedTokens")

/*** Arbitrum Addresses ***/
const poolAddresses_evmos = [
    //NomadBasePoolAddress
    "0x49b97224655AaD13832296b8f6185231AFB8aaCc",
    //CelerBasePool
    "0xbBD5a7AE45a484BD8dAbdfeeeb33E4b859D2c95C",
];

const madUSDC = "0x51e44FfaD5C2B122C8b635671FCC8139dc636E82"
const madUSDT = "0x7FF4a56B32ee13D7D4D405887E0eA37d61Ed919e"
const ceUSDC = "0xe46910336479F254723710D57e7b683F3315b22B"
const ceUSDT = "0xb72A7567847abA28A2819B855D7fE679D4f59846"
const FRAX = "0xE03494D0033687543a80c9B1ca7D6237F2EA8BD8"

async function tvl(timestamp, chainBlocks) {
    const balances = {};
    const transformAddress = await getChainTransform("evmos");
    await sumTokensAndLPsSharedOwners(
        balances,
        [
        [madUSDC, false],
        [madUSDT, false],
        [ceUSDC, false],
        [ceUSDT, false],
        [FRAX, false],
        ],
        poolAddresses_evmos,
        chainBlocks["evmos"],
        "evmos",
        transformAddress
    );
    return balances;
}

/*==================================================
  Exports
  ==================================================*/

module.exports = {
    misrepresentedTokens: true,
    evmos: {
      tvl
    },
    methodology:
      "Counts as TVL all the Assets deposited on EVMOS through different Pool Contracts",
};
'''
'''--- projects/kingdefi/index.js ---
const sdk = require("@defillama/sdk");
const { staking } = require("../helper/staking");
const { addFundsInMasterChef } = require("../helper/masterchef");
const {
  transformBscAddress,
  transformPolygonAddress,
} = require("../helper/portedTokens");

const masterChefContract_bsc = "0x49A44ea2B4126CC1C53C47Ed7f9a5905Cbecae8d";
//const masterChefContract_bscexp = "0x50302F18132d98ea4B0f7Fd2d98e0B1b5d3a3A60";
const masterChefContract_polygon = "0x445AcaE7E3e6248B9b6ebbb002126211e7836Dd8";

const stakingContract = "0x98F3b99198E164f50272ea5Ba44Ea76B1a439876";
const KRW = "0x1446f3cedf4d86a9399e49f7937766e6de2a3aab";

function calctvl(chain) {
  return async (chainBlocks) => {
    const balances = {};

    const transformAddress_bsc = await transformBscAddress();
    const transformAddress_polygon = await transformPolygonAddress();

    await addFundsInMasterChef(
      balances,
      chain == "bsc" ? masterChefContract_bsc : masterChefContract_polygon,
      chainBlocks[chain],
      chain,
      chain == "bsc" ? transformAddress_bsc : transformAddress_polygon
    );

    return balances;
  };
}

const bscTvl = calctvl("bsc");

const polygonTvl = calctvl("polygon");

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    staking: staking(stakingContract, KRW, "bsc"),
    tvl: bscTvl,
  },
  polygon: {
    tvl: polygonTvl,
  },
  methodology:
    "We count liquidity on the Farms seccion through MasterChef Contracts; and the staking part separtely",
};

'''
'''--- projects/kintsugi/index.js ---
const { request, gql } = require('graphql-request');

const graphUrl = 'https://api-kusama.interlay.io/graphql/graphql';
const graphQuery = gql`
query MyQuery {
   cumulativeVolumePerCurrencyPairs(limit: 1, orderBy: tillTimestamp_DESC, where: {type_eq: Collateral, collateralCurrency_eq: KSM}) {
     amount
   }
 }
`;

async function tvl(timestamp, block) {
   const { cumulativeVolumePerCurrencyPairs } = await request(graphUrl, graphQuery);
   const usdTvl = Number(cumulativeVolumePerCurrencyPairs[cumulativeVolumePerCurrencyPairs.length-1].amount);
   const totalTVL = usdTvl / 10 ** 12
   return {'kusama':totalTVL};
}

module.exports = {
   kintsugi: {
      tvl,
   },
};

'''
'''--- projects/kittyfinance/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { stakingUnknownPricedLP, staking } = require("../helper/staking");

const avaxKitty = "0x788AE3b5D153d49F8DB649aacbA1857f744b739e";
const polyKitty = "0x182dB1252C39073eeC9d743F13b5eeb80FDE314e";
const avaxCat = "0x094BFaC9894d2A2A35771D0BD6d2447689190F32";
const polyCat = "0xB932D203f83B8417Be0F61D9dAFad09cc24a4715";
const polyChef = "0xc17c09f7615c660dd5A7C1051E096240CF75685a";
const avaxChef = "0xb7e2eBb3E667A542cDd07e8d108D5fF618315a18";
const avaxNursery = "0xDB75c7b1f8D54Fd02C456609F985F5229634429A";
const polyNursery = "0xA87b3c515C5D50AF8c876709e2A92e5859cd198B";
const polyLPs = [
  "0xcA75C4aA579c25D6ab3c8Ef9A70859ABF566fA1d", // KITTY-MATIC LP
  "0x3C443ca1c986258bEb416cC35FAE95060Ac4Ab13", //CAT-MATIC LP
];
const avaxLPs = [
  "0xbC61C7eCEf56E40404fC359ef4dfd6E7528f2B09", // KITTY-AVAX LP
  "0x2d9A57C484C60241f5340a145a3004c7E4cfE040", // CAT-AVAX LP
];

async function calcPool2(masterchef, lps, block, chain) {
  let balances = {};
  const lpBalances = (
    await sdk.api.abi.multiCall({
      calls: lps.map((p) => ({
        target: p,
        params: masterchef,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;
  let lpPositions = [];
  lpBalances.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    block,
    chain,
    (addr) => `${chain}:${addr}`
  );
  return balances;
}

async function polyPool2(timestamp, block, chainBlocks) {
  return await calcPool2(polyChef, polyLPs, chainBlocks.polygon, "polygon");
}

async function avaxPool2(timestamp, block, chainBlocks) {
  return await calcPool2(avaxChef, avaxLPs, chainBlocks.avax, "avax");
}

module.exports = {
  polygon: {
    tvl: async () => ({}),
    pool2: polyPool2,
    staking: stakingUnknownPricedLP(
      polyNursery,
      polyCat,
      "polygon",
      polyLPs[1],
      (addr) => `polygon:${addr}`
    ),
  },
  avax: {
    tvl: async () => ({}),
    pool2: avaxPool2,
    staking: staking(avaxNursery, avaxCat, "avax"),
  },
};

'''
'''--- projects/klap/index.js ---
const { aaveChainTvl } = require("../helper/aave");
const { getFixBalances } = require("../helper/portedTokens");

async function transformKlaytnAddress() {
  const mapping = {
    "0x5388ce775de8f7a69d17fd5caa9f7dbfee65dfce":
      "0x4576E6825B462b6916D2a41E187626E9090A92c6", // Donkey
    "0x9eaefb09fe4aabfbe6b1ca316a3c36afc83a393f": "ripple", // XRP
    "0x02cbe46fb8a1f579254a9b485788f2d86cad51aa":
      "0x26fb86579e371c7aedc461b2ddef0a8628c93d3b", // bora
    "0x078dB7827a5531359f6CB63f62CFA20183c4F10c":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // dai
    "0x6270B58BE569a7c0b8f47594F191631Ae5b2C86C":
      "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", // USDC
    "0x0268dbed3832b87582b1fa508acf5958cbb1cd74":
      "bsc:0xf258f061ae2d68d023ea6e7cceef97962785c6c1", // IJM
    "0xd6dAb4CfF47dF175349e6e7eE2BF7c40Bb8C05A3":
      "0xdac17f958d2ee523a2206206994597c13d831ec7", // USDT
    "0x168439b5eebe8c83db9eef44a0d76c6f54767ae4":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // pUSD
    "0x4fa62f1f404188ce860c8f0041d6ac3765a72e67":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // KSD
    "0xce40569d65106c32550626822b91565643c07823":
      "0x6b175474e89094c44da98b954eedeac495271d0f", // KASH
    "0x210bc03f49052169d5588a52c317f71cf2078b85":
      "bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56", // kBUSD
    "0xDCbacF3f7a069922E677912998c8d57423C37dfA":
      "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599", // WBTC
    "0xCD6f29dC9Ca217d0973d3D21bF58eDd3CA871a86":
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", // WETH
    "0xe4f05A66Ec68B54A58B17c22107b02e0232cC817": "0xe4f05a66ec68b54a58b17c22107b02e0232cc817" // Klaytn
  };
  return addr => {
    const mappingResult = mapping[addr]
    addr = addr.toLowerCase();
    return mappingResult || `klaytn:${addr}`;
  };
}

function lending(borrowed) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const transform = await transformKlaytnAddress();
    const balances = await aaveChainTvl(
      "klaytn",
      "0x969E4A05c2F3F3029048e7943274eC2E762497AB",
      transform,
      undefined,
      borrowed
    )(timestamp, ethBlock, chainBlocks);
    const fixBalances = await getFixBalances('klaytn')
    fixBalances(balances)
    return balances
  };
}

module.exports = {
  timetravel: true,
  methodology:
    "Counts the tokens locked in the contracts to be used as collateral to borrow or to earn yield. Borrowed coins are not counted towards the TVL, so only the coins actually locked in the contracts are counted. There's multiple reasons behind this but one of the main ones is to avoid inflating the TVL through cycled lending",
  klaytn: {
    tvl: lending(false),
    borrowed: lending(true)
  },
};

'''
'''--- projects/klaybank/abi/IDefiLlamaViewer.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "getAllReserveData",
    "outputs": [
      {
        "components": [
          {
            "name": "symbol",
            "type": "string"
          },
          {
            "name": "underlyingAssetAddress",
            "type": "address"
          },
          {
            "name": "marketTvl",
            "type": "uint256"
          },
          {
            "name": "marketTvlInUsd",
            "type": "uint256"
          }
        ],
        "name": "",
        "type": "tuple[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "assetDataAddress",
        "type": "address"
      },
      {
        "name": "symbol",
        "type": "string"
      }
    ],
    "name": "_getReserveData",
    "outputs": [
      {
        "components": [
          {
            "name": "symbol",
            "type": "string"
          },
          {
            "name": "underlyingAssetAddress",
            "type": "address"
          },
          {
            "name": "marketTvl",
            "type": "uint256"
          },
          {
            "name": "marketTvlInUsd",
            "type": "uint256"
          }
        ],
        "name": "",
        "type": "tuple"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "getAllStakedData",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "getTreasuryData",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/klaybank/index.js ---
const sdk = require("@defillama/sdk")
const IDefiLlamaViewerAbi = require("./abi/IDefiLlamaViewer.json");
const BigNumber = require("bignumber.js");
const { toUSDTBalances } = require("../helper/balances");
// addresses
const IDefiLlamaViewerContractAddress = "0xCbAFD3b3b7CfFfFC542fF6986C2DB28C6ae8Cf27";
const chain = 'klaytn'

async function fetchLiquidity(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  const { output: reserves} = await sdk.api.abi.call({
    chain, block,
    target: IDefiLlamaViewerContractAddress,
    abi: IDefiLlamaViewerAbi.find(i => i.name === 'getAllReserveData')
  })

  let marketTvl = new BigNumber(0);
  for (const reserve of reserves) {
    marketTvl = marketTvl.plus(reserve.marketTvlInUsd);
  }
  return toUSDTBalances(marketTvl.div(1000000));
}

async function fetchStaked(ts, _block, chainBlocks) {
  const block = chainBlocks[chain]
  const { output: staked} = await sdk.api.abi.call({
    chain, block,
    target: IDefiLlamaViewerContractAddress,
    abi: IDefiLlamaViewerAbi.find(i => i.name === 'getAllStakedData')
  })

  let stakedTvl = new BigNumber(staked);
  return toUSDTBalances(stakedTvl.div(1000000));
}

module.exports = {
  klaytn: {
    tvl: fetchLiquidity,
    staking: fetchStaked,
  },
};

'''
'''--- projects/klayportal/abi.json ---
{
  "stakingPoolSum": {
    "constant": true,
    "inputs": [],
    "name": "stakingPoolSum",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/klayportal/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const abi = require("./abi.json");

const KlayPortalAddress = "0x67A7F7c9195214FdDE587E98f736466d26FaC5A0";
const ETHER = new BigNumber(10).pow(18);
const APIID = "klay-token";

async function tvl(timestamp, ethBlock, chainBlocks) {

  const balances = {};
  const chain = "klaytn";
  const block = chainBlocks[chain];

  const data = await sdk.api.abi.call({
    target: KlayPortalAddress,
    block,
    chain,
    abi: abi.stakingPoolSum,
    params: [],
  });

  await sdk.util.sumSingleBalance(balances, APIID, new BigNumber(data.output).dividedBy(ETHER).toNumber());

  return balances
}

module.exports = {
  timetravel: true,
  methodology: "TVL is equal to the amount of KLAY staked in the Staking pool",
  klaytn: {
    tvl: tvl,
  },
};

'''
'''--- projects/klaystation/index.js ---
const retry = require('async-retry')
const axios = require("axios");
const BigNumber = require("bignumber.js");

//////////    KLAYSTATION   ////////////////
//// TVL = OZYS stakedKlay * priceKlay ////
//////////////////////////////////////////
async function fetch() {
	const klaystationInfo = await retry(async bail => await axios.get('https://s.klaystation.io/staking/status.json'))
	const stakingAmount = klaystationInfo.data.stakingAmount;
	const priceKlay = klaystationInfo.data.priceUsd;
	var totalLiquidity = new BigNumber('0');

	const cnAddresses = ["0xe33337cb6fbb68954fe1c3fde2b21f56586632cd"];

	for (const cn of cnAddresses) {
		totalLiquidity = totalLiquidity.plus(stakingAmount[cn]);
	}
	
	totalLiquidity = totalLiquidity.shiftedBy(-18); 
	totalLiquidity = totalLiquidity.multipliedBy(priceKlay);

	return totalLiquidity.toFixed(2);
}

module.exports = {
    methodology: `TVL is equal to the amount of KLAY staked in the Liquiidy Staking pool "OZYS".`,
    timetravel: false,
    misrepresentedTokens: true,
    fetch
} //node test.js projects/klaystation/index.js
'''
'''--- projects/klayswap/index.js ---
const retry = require('async-retry')
const axios = require("axios");
const BigNumber = require("bignumber.js");
const { toUSDTBalances } = require('../helper/balances');

async function fetchLiquidity() {
  const klayswapInfo = await retry(async bail => await axios.get('https://s.klayswap.com/stat/klayswapInfo.json'))
  const recentPoolInfo = klayswapInfo.data.recentPoolInfo;
  var totalLiquidity = new BigNumber('0');

  for (const pool of recentPoolInfo) {
    totalLiquidity = totalLiquidity.plus(pool.poolVolume);
  }

  // Single-sided deposits
  const SinglePoolInfo = klayswapInfo.data.leveragePoolInfo.single;
  var totalSingleSided = new BigNumber('0');

  for (const spool of SinglePoolInfo) {
    totalSingleSided = totalSingleSided.plus(spool.totalDepositVol);
  }

  return toUSDTBalances(totalLiquidity.plus(totalSingleSided).toFixed(2));
}

async function fetchStakedToken() {
  const klayswapInfo = await retry(async bail => await axios.get('https://s.klayswap.com/stat/klayswapInfo.json'))
  var totalStaking = new BigNumber(klayswapInfo.data.common.stakingVol);
  return toUSDTBalances(totalStaking.toFixed(2));
}

module.exports = {
  methodology: 'TVL counts the liquidity of KlaySwap DEX and staking counts the KSP that has been staked. Data is pulled from:"https://s.klayswap.com/stat/klayswapInfo.json".',
  klaytn: {
    tvl: fetchLiquidity,
    staking: fetchStakedToken
  },
  misrepresentedTokens: true,
  timetravel: false,
}
'''
'''--- projects/klend/index.js ---
const sdk = require('@defillama/sdk');
const {compoundExports} = require('../helper/compound');
const {unwrapUniswapLPs} = require('../helper/unwrapLPs');

// BSC
const unitroller = "0xA6bEd5B7320941eA185A315D1292492F7Fdd1e5c";
const kBnb = "0x2C334c6cBC0547e759084bD8D469f933B17Ff481";
const wbnb = "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c"
const bscPools = [
    "0xf1D447656692d51d4DB7057104Ac6E97029A7790",
    "0x95D4D2D88C96cE96c97A912Aa7122715716013D4"
];
const okexPools = [
    "0x2404c9F6Ba2d4D5c73d86b3E3b9D7F6c70ba3448",
    "0x5A74de8e3D0c46c106AB769d50bf9CAF8681D30d"
];
const lpAbi = {"constant":true,"inputs":[],"name":"lp","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"};

// OKEX
const okexUnitroller = "0x9589c9c9b7A484F57d69aC09c14EcE4b6d785710";
const kOkt = "0x4923abEe988f7bB7A9ae136BEBE4A8455e8dE229";
const wokt = "0x8f8526dbfd6e38e3d8307702ca8469bae6c56c15"

async function pool2Tvl(balances, chainBlocks, chain, pools) {

    let lpofPools = (await sdk.api.abi.multiCall({
        calls: pools.map(p => ({
            target: p
        })),
        abi: lpAbi,
        block: chainBlocks,
        chain: chain
    })).output;

    let lpBalances = (await sdk.api.abi.multiCall({
        calls: lpofPools.map(p => ({
            target: p.output,
            params: p.input.target
        })),
        abi: "erc20:balanceOf",
        block: chainBlocks,
        chain: chain
    })).output;

    let lpPositions = [];
    for (let i in lpBalances) {
        lpPositions.push({
            balance: lpBalances[i].output,
            token: lpBalances[i].input.target
        });
    }

    await unwrapUniswapLPs(balances, lpPositions, chainBlocks, chain, addr=>`${chain}:${addr}`);

}

async function bscPool2(timestamp, block, chainBlocks) {
    let balances = {};

    await pool2Tvl(balances, chainBlocks.bsc, "bsc", bscPools);

    return balances;
}

async function okexPool2(timestamp, block, chainBlocks) {
    let balances = {};

    await pool2Tvl(balances, chainBlocks.okexchain, "okexchain", okexPools);

    return balances;
}

module.exports = {
    timetravel: true,
    doublecounted: false,
    bsc: {
        ...compoundExports(unitroller, "bsc", kBnb, wbnb),
        pool2: bscPool2
    },
    okexchain: {
        ...compoundExports(okexUnitroller, "okexchain", kOkt, wokt),
        pool2: okexPool2
    }
}
'''
'''--- projects/kleros/index.js ---
const { request, gql } = require("graphql-request");

const graphUrls = {
  ethereum: 'https://api.thegraph.com/subgraphs/name/salgozino/klerosboard',
  xdai: 'https://api.thegraph.com/subgraphs/name/salgozino/klerosboard-xdai',
}

const totalStakedQuery = gql`
query($block: Int) {
  klerosCounters(block: { number: $block }) {
    tokenStaked
  }
}
`

function getStakedTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};

    const graphUrl = graphUrls[chain]
    const block = chainBlocks[chain]

    const {klerosCounters} = await request(
      graphUrl, 
      totalStakedQuery,
      {block}
    )

    balances.kleros = klerosCounters[0].tokenStaked / (10 ** 18);

    return balances;
  }
}

module.exports = {
  methodology: "Counts PNK staked in courts",
  timetravel: true,
  ethereum: {
    tvl: ()=>([]),
    staking: getStakedTvl('ethereum')
  },
  xdai: {
    tvl: ()=>([]),
    staking: getStakedTvl('xdai')
  },
}

'''
'''--- projects/klima-dao/index.js ---
const { staking } = require('../helper/staking')
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs')
const {transformPolygonAddress} = require('../helper/portedTokens')

const treasury = "0x7Dd4f0B986F032A44F913BF92c9e8b7c17D77aD7"

async function tvl(time, ethBlock, chainBlocks){
    const balances = {}
    const transform = await transformPolygonAddress()
    await sumTokensAndLPsSharedOwners(balances, [
        ["0x2f800db0fdb5223b3c3f354886d907a671414a7f", false],
        ["0x1e67124681b402064cd0abe8ed1b5c79d2e02f64", true],
        ["0x9803c7ae526049210a1725f7487af26fe2c24614", true]
    ], [treasury], chainBlocks.polygon, "polygon", transform)
    return balances
}

module.exports={
    polygon:{
        tvl,
        staking: staking("0x25d28a24Ceb6F81015bB0b2007D795ACAc411b4d", "0x4e78011ce80ee02d2c3e649fb657e45898257815", "polygon")
    }
}
'''
'''--- projects/klondike/abi.json ---
{
    "allAllowedTokens": {
        "inputs": [],
        "name": "allAllowedTokens",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/klondike/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");

const stakingContract = "0xAcbdB82f07B2653137d3A08A22637121422ae747";
const KlonX = "0xbf15797BB5E47F6fB094A4abDB2cfC43F77179Ef";

const KlonXWBTCLPKlonXPool = "0x185bDc02aAFbEcDc8DC574e8319228B586764415";
const WBTC_KlonX_UNI = "0x69cda6eda9986f7fca8a5dba06c819b535f4fc50";

const KWBTCWBTCLPKlonXPool = "0x451D00AF6E751537a9A2cFF40CdFB1119cd1fA7d";
const WBTC_KBTC_UNI = "0x1F3D61248EC81542889535595903078109707941";

const KXUSDDAILPKlonXPool = "0xE301F632E573A3F8bd06fe623E4440560ab08692";
const KXUSD_DAI_UNI = "0x672C973155c46Fc264c077a41218Ddc397bB7532";

const fundContracts = [
  //stablFundContract
  "0x58285B88951DE1C9a5255DDfdE28A68b30EE7559",
  //devFundContract
  "0x3BE908C22D21ab32C5A04CFCa3a9A70d4FEfc098",
];

async function ethTvl(block) {
  const balances = {};

  for (const pool of [KWBTCWBTCLPKlonXPool, KXUSDDAILPKlonXPool]) {
    await sumTokensAndLPsSharedOwners(
      balances,
      pool == KWBTCWBTCLPKlonXPool
        ? [[WBTC_KBTC_UNI, true]]
        : [[KXUSD_DAI_UNI, true]],
      [pool]
    );
  }

  const tokenAddresses = (
    await sdk.api.abi.call({
      abi: abi.allAllowedTokens,
      target: fundContracts[0],
    })
  ).output;

  for (const token of tokenAddresses) {
    await sumTokensAndLPsSharedOwners(balances, [[token, false]], fundContracts);
  }

  return balances;
}

module.exports = {
  ethereum: {
    staking: staking(stakingContract, KlonX),
    pool2: pool2(KlonXWBTCLPKlonXPool, WBTC_KlonX_UNI),
    tvl: ethTvl,
  },
  methodology: "Counts liquidity on the Farms through their Contracts",
};

'''
'''--- projects/knightsfantom/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0x2166496575200E170310a34B5F697f7c124fF2C7"
const knights = "0xba36266B6565C96BD77815fa898f403Cc06F64cf"
const knightsFtmLP = "0x26ac59ee36965db597167c4a1b1b4367285aa4e3";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [knights, knightsFtmLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, knights, "fantom"),
      pool2: pool2Exports(chef, [knightsFtmLP], "fantom"),
  },
  
} 
'''
'''--- projects/knightswap/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { stakingUnknownPricedLP } = require("../helper/staking");

const bscFactory = "0xf0bc2E21a76513aa7CC2730C7A1D6deE0790751f";
const ftmFactory = "0x7d82F56ea0820A9d42b01C3C28F1997721732218";

const bscStaking = "0xE50cb76A71b0c52Ab091860cD61b9BA2FA407414";
const bscKnight = "0xd23811058eb6e7967d9a00dc3886e75610c4abba";
const knightBusdLP = "0xA12e1e2E2dea79694448aB9ef63bd4D82a26d90c";

const ftmStaking = "0xb02e3A4B5ebC315137753e24b6Eb6aEF7D602E40";
const ftmKnight = "0x6cc0e0aedbbd3c35283e38668d959f6eb3034856";
const knightUsdcLP = "0x68D47D67b893c44A72BCAC39b1b658D4Cbdf87CA";

const translateTokens = {
  "0x049d68029688eabf473097a2fc38ef61633a3c7a":
    "0xdac17f958d2ee523a2206206994597c13d831ec7", // fUSDT to USDT
  "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e":
    "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
};

async function bscTvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(
    (addr) => `bsc:${addr}`,
    chainBlocks.bsc,
    "bsc",
    bscFactory,
    0,
    true
  );
}

async function ftmTvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(
    (addr) => {
      addr = addr.toLowerCase();
      if (translateTokens[addr] !== undefined) {
        return translateTokens[addr];
      }
      return `fantom:${addr}`;
    },
    chainBlocks.fantom,
    "fantom",
    ftmFactory,
    0,
    true
  );
}

module.exports = {
  methodology: "TVL consists of pools created by the factory contract",
  bsc: {
    tvl: bscTvl,
    staking: stakingUnknownPricedLP(
      bscStaking,
      bscKnight,
      "bsc",
      knightBusdLP,
      (addr) => `bsc:${addr}`
    ),
  },
  fantom: {
    tvl: ftmTvl,
    staking: stakingUnknownPricedLP(
      ftmStaking,
      ftmKnight,
      "fantom",
      knightUsdcLP,
      (addr) => `fantom:${addr}`
    ),
  },
};

'''
'''--- projects/knitfinance/index.js ---
const { get } = require("../helper/http");
const { toUSDTBalances } = require("../helper/balances");

const url = "https://knit-admin.herokuapp.com/api/public/tvl/";

const chainConfig = {
  bsc: "bsc",
  polygon: "matic",
  ethereum: "eth",
  heco: "heco",
  fantom: "fantom",
  avalanche: "avalanche",
  kcc: "kcc",
  harmony: "harmony",
  okexchain: "okexchain",
  syscoin: "syscoin",
  telos: "telos",
  moonriver: "moonriver",
  milkomeda: "milkomeda",
  moonbeam: "moonbeam",
  bitgert: "bitgert",
  xdai: "gnosis",
  reef: "reef",
};

module.exports = {
  timetravel: false,
};

function addChain(chain) {
  module.exports[chain] = {
    tvl: async () => {
      const key = chainConfig[chain];
      let response = await get(url + key);
      return toUSDTBalances(response.data.data.tvl[key]);
    },
  };
}

Object.keys(chainConfig).map(addChain);

'''
'''--- projects/know-to-earn.js ---
// 0x515343ed04b054d098a0c15cbd7f98b0250d0b38  KNOW token
// 0x767eded9032ce68dc4e475addf0059baab936585    lp token
// 0xEA934138CFEF2c5efedf2b670B93Fb6827295cC4   owner

const sdk = require("@defillama/sdk");
const { getBlock } = require("./helper/getBlock");
const { sumLPWithOnlyOneToken } = require("./helper/unwrapLPs");

const iotx = "0x6fb3e0a217407efff7ca062d46c26e5d60a14d69";
const wiotx = "0xA00744882684C3e4747faEFD68D283eA44099D03";

function pool2(chain, gasToken) {
  return async (timestamp, block, chainBlocks) => {
    block = await getBlock(timestamp, chain, chainBlocks);
    let balances = { iotex: 0 };
    
    await sumLPWithOnlyOneToken(
      balances,
      '0x767eded9032ce68dc4e475addf0059baab936585',
      '0xEA934138CFEF2c5efedf2b670B93Fb6827295cC4',
      wiotx,
      block,
      "iotex"
    );

    if (iotx in balances) {
      balances["iotex"] += balances[iotx] / 10 ** 18;
      delete balances[iotx];
    }
    if (wiotx in balances) {
      balances["iotex"] += balances[wiotx] / 10 ** 18;
      delete balances[wiotx];
    }

    return balances;
  };
}

module.exports = {
  iotex: {
    pool2: pool2("iotex", "iotex"),
    tvl: () => ({}),
  },
};

'''
'''--- projects/koala-defi/index.js ---
const { addFundsInMasterChef } = require("../helper/masterchef");
const { stakingUnknownPricedLP } = require("../helper/staking");
const { pool2BalanceFromMasterChefExports } = require("../helper/pool2");

const bscNalis = "0xb2ebaa0ad65e9c888008bf10646016f7fcdd73c3";
const bscMC = "0x7b3cA828e189739660310B47fC89B3a3e8A0E564";
const polyNalis = "0x04f2e3ec0642e501220f32fcd9e26e77924929a9";
const polyMC = "0xf6948f00FC2BA4cDa934C931628B063ed9091019";

async function bscTvl (timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, bscMC, chainBlocks.bsc, "bsc", addr=>`bsc:${addr}`, undefined, [bscNalis], true, true, bscNalis);
    return balances;
}

async function polyTvl (timestamp, block, chainBlocks) {
    let balances = {};
    await addFundsInMasterChef(balances, polyMC, chainBlocks.polygon, "polygon", addr=>`polygon:${addr}`, undefined, [polyNalis], true, true, polyNalis);
    return balances;
}

module.exports = {
    bsc: {
        tvl: bscTvl,
        staking: stakingUnknownPricedLP(bscMC, bscNalis, "bsc", "0x138ACb44F9f2e4E7F3bbcB7BBb1a268068dC202C"),
        pool2: pool2BalanceFromMasterChefExports(bscMC, bscNalis, "bsc", addr=>`bsc:${addr}`)
    },
    polygon: {
        tvl: polyTvl,
        staking: stakingUnknownPricedLP(polyMC, polyNalis, "polygon", "0xff50A77412997FC86e78178A4b47000b9225ffd9"),
        pool2: pool2BalanceFromMasterChefExports(polyMC, polyNalis, "polygon", addr=>`polygon:${addr}`)
    }
}
'''
'''--- projects/koffeeswap/abi.json ---
{
    "stakingToken": {
        "inputs": [],
        "name": "stakingToken",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "constant": true,
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "constant": true,
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getReserves": {
        "constant": true,
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {
                "internalType": "uint112",
                "name": "_reserve0",
                "type": "uint112"
            },
            {
                "internalType": "uint112",
                "name": "_reserve1",
                "type": "uint112"
            },
            {
                "internalType": "uint32",
                "name": "_blockTimestampLast",
                "type": "uint32"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/koffeeswap/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const FeatureStaking = "0xc0ffee0000212c25e338100f46c962473ed0447a";
const KOFFEE = "0xc0ffee0000921eb8dd7d506d4de8d5b79b856157";

const brewContracts = [
  //KCS-USDT
  "0xc0Ffee000019988Ae7e8aaA41AF3886eB8750401",
  //KCS-USDC
  "0xc0FfeE000016Ed5788F82814bE35AE8c8Aba06Cc",
  //KCS-KOFFEE
  "0xC0FFeE0000123A0DfdE79aaAA124B4919393cd0F",
  //KOFFEE-USDT
  "0xC0FfeE0000c3C9087Bc012d00F13ad5c781cEe87",
  //KOFFEE-USDC
  "0xc0fFEe0000961b3e66C635e3395EAbc6A637c8A2",
];

/*** Staking of native token (KOFFEE) TVL Portion ***/
const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const stakingBalance = (
    await sdk.api.abi.call({
      abi: 'erc20:balanceOf',
      target: KOFFEE,
      params: FeatureStaking,
      chain: "kucoin",
      block: chainBlocks["kucoin"],
    })
  ).output;

  sdk.util.sumSingleBalance(balances, `kucoin:${KOFFEE}`, stakingBalance);

  return balances;
};

const kccTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const stakingTokens = (
    await sdk.api.abi.multiCall({
      abi: abi.stakingToken,
      calls: brewContracts.map((brew) => ({
        target: brew,
      })),
      chain: "kcc",
      block: chainBlocks["kcc"],
    })
  ).output.map((st) => st.output);

  for (let i = 0; i < stakingTokens.length; i++) {
    const token0 = (
      await sdk.api.abi.call({
        target: stakingTokens[i],
        abi: abi.token0,
        chain: "kcc",
        block: chainBlocks["kcc"],
      })
    ).output;

    const token1 = (
      await sdk.api.abi.call({
        target: stakingTokens[i],
        abi: abi.token1,
        chain: "kcc",
        block: chainBlocks["kcc"],
      })
    ).output;

    const getReserves = (
      await sdk.api.abi.call({
        target: stakingTokens[i],
        abi: abi.getReserves,
        chain: "kcc",
        block: chainBlocks["kcc"],
      })
    ).output;

    sdk.util.sumSingleBalance(balances, `kcc:${token0}`, getReserves[0]);

    sdk.util.sumSingleBalance(balances, `kcc:${token1}`, getReserves[1]);
  }

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  kcc: {
    staking,
    tvl: kccTvl,
  },
  methodology:
    "We count liquidity on the brews threw their contracts and the portion TVL staking the native token (KOFFEE) by FeatureStaking contract",
};

'''
'''--- projects/kogefarm/abi.json ---
{
  "balance": {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "constant": true,
    "inputs": [
        {
            "name": "_owner",
            "type": "address"
        }
    ],
    "name": "balanceOf",
    "outputs": [
        {
            "name": "balance",
            "type": "uint256"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
},
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "symbol": {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getPoolTokens": {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "poolId",
        "type": "bytes32"
      }
    ],
    "name": "getPoolTokens",
    "outputs": [
      {
        "internalType": "contract IERC20[]",
        "name": "tokens",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "balances",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256",
        "name": "lastChangeBlock",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getPoolId": {
    "inputs": [],
    "name": "getPoolId",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getRatio": {
    "inputs": [],
    "name": "getRatio",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accRewardPerShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalLiquidity": {
    "inputs": [],
    "name": "totalLiquidity",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/kogefarm/helper.js ---
const BigNumber = require('bignumber.js')
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const { unwrapCrv } = require('../helper/unwrapLPs')

function transformAddressKF(chain = 'polygon') {
  return (addr) => {
    // WETH
    if (addr.toLowerCase() === '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619') {
      return '0x0000000000000000000000000000000000000000'
    }

    // Special cases since coingecko doesn't find them
    if (
      // fUSDT
      (chain === 'fantom' &&
        addr.toLowerCase() === '0x049d68029688eabf473097a2fc38ef61633a3c7a') ||
      (chain === 'moonriver' &&
        addr.toLowerCase() === '0xe936caa7f6d9f5c9e907111fcaf7c351c184cda7')
    ) {
      // USDT
      return `ethereum:0xdac17f958d2ee523a2206206994597c13d831ec7`
    }
    if (
      // renbtc on Fantom
      (chain === 'fantom' &&
        addr.toLowerCase() === '0xdbf31df14b66535af65aac99c32e9ea844e14501')
    ) {
      // renbtc on Polygon
      return `polygon:0xDBf31dF14B66535aF65AaC99C32e9eA844e14501`
    }
    if (
      // staked spell on Fantom
      (chain === 'fantom' &&
        addr.toLowerCase() === '0xbb29d2a58d880af8aa5859e30470134deaf84f2b')
    ) {
      // spell on Fantom
      return `fantom:0x468003B688943977e6130F4F68F23aad939a1040`
    }
    if (
      // Dai on Fantom
      (chain === 'fantom' &&
        addr.toLowerCase() === '0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e')
    ) {
      // Dai on Eth
      return `ethereum:0x6b175474e89094c44da98b954eedeac495271d0f`
    }
    if (
      // wMemo on Fantom
      (chain === 'fantom' &&
        addr.toLowerCase() === '0xddc0385169797937066bbd8ef409b5b3c0dfeb52')
    ) {
      // Time on avax (per Wonderland docs, staked time = Memo at a 1:1 ratio)
      return `avax:0xb54f16fb19478766a268f172c9480f8da1a7c9c3`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x748134b5f553f2bcbd78c6826de99a70274bdeb3' // USDC.m
    ) {
      // USDC
      return `ethereum:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x15b9ca9659f5dff2b7d35a98dd0790a3cbb3d445' // DOT.m
    ) {
      // BSC DOT
      return `bsc:0x7083609fce4d1d8dc0c979aab8c869ea2c873402`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x9a92b5ebf1f6f6f7d93696fcd44e5cf75035a756' // FINN
    ) {
      // FINN
      return `moonriver:0x9a92b5ebf1f6f6f7d93696fcd44e5cf75035a756`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x576fde3f61b7c97e381c94e7a03dbc2e08af1111' // ETH.M
    ) {
      // WETH
      return `ethereum:0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x78f811a431d248c1edcf6d95ec8551879b2897c3' // BTC.m
    ) {
      // WBTC
      return `ethereum:0x2260fac5e5542a773aa44fbcfedf7c193bc2c599`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0x9d5bc9b873aed984e2b6a64d4792249d68bba2fe' // XRP.m
    ) {
      // Binance-Peg XRP
      return `bsc:0x1d2f0da169ceb9fc7b3144628db156f3f6c60dbe`
    }
    if (
      chain === 'moonriver' &&
      addr.toLowerCase() === '0xc005a7a1502c9de16ccdaba7cda0cee4ac304993' // AVAX.m
    ) {
      // WAVAX
      return `avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7`
    }
    // Special case for MIM, since coingecko doesn't find
    if (addr.toLowerCase() === '0x82f0b8b456c1a451378467398982d4834b6829c1') {
      // MIM
      return `ethereum:0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3`
    }
    // Special case for LINK, since coingecko doesn't find
    if (addr.toLowerCase() === '0xb3654dc3d10ea7645f8319668e8f54d2574fbdc8') {
      // LINK
      return `ethereum:0x514910771af9ca656af840dff83e8264ecf986ca`
    }
    // Special case for Bella, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x28c388fb1f4fa9f9eb445f0579666849ee5eeb42') {
      return `ethereum:0xa91ac63d040deb1b7a5e4d4134ad23eb0ba07e14`
    }
    // Special case for SFI, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x35b937583f04a24963eb685f728a542240f28dd8') {
      return `ethereum:0xb753428af26e81097e7fd17f40c88aaa3e04902c`
    }
    // Special case for Impermax, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x60bb3d364b765c497c8ce50ae0ae3f0882c5bd05') {
      return `ethereum:0x7b35ce522cb72e4077baeb96cb923a5529764a00`
    }
    // Special case for Avax, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x2c89bbc92bd86f8075d1decc58c7f4e0107f286b') {
      return `avax:0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7`
    }
    // Special case for sUSDT, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x29e38769f23701a2e4a8ef0492e19da4604be62c') {
      return `polygon:0xc2132d05d31c914a87c6611c10748aeb04b58e8f`
    }
    // Special case for sUSDC, since coingecko doesn't find
    if (
      chain === 'polygon' &&
      addr.toLowerCase() === '0x1205f31718499dbf1fca446663b532ef87481fe1') {
      return `polygon:0x2791bca1f2de4661ed88a30c99a7a9449aa84174`
    }

    return `${chain}:${addr}`
  }
}

async function getSinglePositions(
  balances,
  lpPositions,
  block,
  chain = 'ethereum',
  transformAddress = (addr) => addr,
) {
  await Promise.all(
    lpPositions.map((lpPosition) => {
      const underlyingToken = lpPosition.token
      const underlyingTokenBalance = lpPosition.balance
      sdk.util.sumSingleBalance(
        balances,
        transformAddress(underlyingToken),
        underlyingTokenBalance,
      )
    }),
  )
}

async function unwrapCrvLPs(
  balances,
  lpPositions,
  block,
  chain = 'ethereum',
  transformAddress = (addr) => addr,
  excludeTokensRaw=[]
) {
  await Promise.all(
    lpPositions.map(async (lp) => {
      const underlyingToken = lp.token
      const underlyingTokenBalance = lp.balance
      try {
        await unwrapCrv(balances, underlyingToken, underlyingTokenBalance, block, chain, transformAddress, excludeTokensRaw)
      } catch (e) {
        console.log(
          `Failed to get data for Curve LP token at ${lp.token} on chain ${chain}`,
        )
        throw e
      }
    }),
  )
}

async function unwrapBalancerLPs(
  vaultAddress,
  balances,
  lpPositions,
  block,
  chain = 'ethereum',
  transformAddress = (addr) => addr,
) {
  const vaultBalances = (
    await sdk.api.abi.multiCall({
      chain,
      block,
      abi: abi.balance,
      calls: lpPositions.map((lp) => ({ target: lp.vaultAddr })),
    })
  ).output
  const poolIds = (
    await sdk.api.abi.multiCall({
      chain,
      block,
      abi: abi.getPoolId,
      calls: lpPositions.map((lp) => ({ target: lp.token })),
    })
  ).output
  const poolTokens = (
    await sdk.api.abi.multiCall({
      chain,
      block,
      abi: abi.getPoolTokens,
      calls: poolIds.map((e) => ({ target: vaultAddress, params: [e.output] })),
    })
  ).output
  const totalSupply = (
    await sdk.api.abi.multiCall({
      chain,
      block,
      abi: abi.totalSupply,
      calls: lpPositions.map((e) => ({ target: e.token })),
    })
  ).output

  await Promise.all(
    poolTokens.map(async (lp, idx) => {
      try {
        const tokens = lp.output.tokens

        const tokenBalances = tokens.map((t, tidx) =>
          BigNumber(lp.output['1'][tidx])
            .times(
              BigNumber(lpPositions[idx].balance).div(totalSupply[idx].output),
            )
            .integerValue(),
        )

        tokenBalances.forEach(async (tokenBalance, tidx) => {
          sdk.util.sumSingleBalance(
            balances,
            await transformAddress(tokens[tidx].toLowerCase()),
            tokenBalance.toFixed(0),
          )
        })
      } catch (e) {
        console.log(
          `Failed to get data for LP token at ${lpPositions[idx].token} on chain ${chain}`,
        )
        throw e
      }
    }),
  )
}

module.exports = {
  transformAddressKF,
  getSinglePositions,
  unwrapBalancerLPs,
  unwrapCrvLPs,
}

'''
'''--- projects/kogefarm/index.js ---
const sdk = require('@defillama/sdk')
const abi = require('./abi.json')
const utils = require('../helper/utils')
const { unwrapUniswapLPs, unwrapCrv } = require('../helper/unwrapLPs')
const { transformPolygonAddress, getFixBalances } = require('../helper/portedTokens')
const {
  transformAddressKF,
  getSinglePositions,
  unwrapBalancerLPs,
  unwrapCrvLPs,
} = require('./helper.js')

const current_polygon_vaults_url =
  'https://raw.githubusercontent.com/kogecoin/vault-contracts/main/vaultaddresses'
const current_fantom_vaults_url =
  'https://raw.githubusercontent.com/kogecoin/vault-contracts/main/ftm_vault_addresses.json'
const current_moonriver_vaults_url =
  'https://raw.githubusercontent.com/kogecoin/vault-contracts/main/movr_vault_addresses.json'
const current_kava_vaults_url =
  'https://raw.githubusercontent.com/kogecoin/vault-contracts/main/kava_vault_addresses.json'

const beethovenX = '0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce'

const ftm_CrvVaultAddr = [
  '0x0a5E266afB071CB0F69310706154F2893a208D1c',
  '0x4Ef103DF324b20604e13170377233DDecD15074B',
]
const movr_CrvVaultAddr = []
const ftm_BalancerForks = [
  {
    name: 'beethoven',
    vault: beethovenX,
  },
]
const movr_BalancerForks = []
const kava_BalancerForks = []
const kava_CrvVaultAddr = []

const polygonMasterChef = (masterChef, pid) => async (
  timestamp,
  block,
  chainBlocks,
) => {
  const balances = {}

  const lp_addresses = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: [
        {
          target: masterChef,
          params: [pid],
        },
      ],
      abi: abi.poolInfo,
    })
  ).output.map((val) => val.output.lpToken)

  const lp_symbols = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: lp_addresses.map((address) => ({
        target: address,
      })),
      abi: abi.symbol,
    })
  ).output.map((val) => val.output)

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: lp_addresses.map((lp) => ({
        target: lp,
        params: masterChef,
      })),
      abi: 'erc20:balanceOf',
    })
  ).output.map((val) => val.output)

  const lpPositions = []
  const singlePositions = []

  lp_addresses.forEach((v, idx) => {
    if (lp_symbols[idx] === 'UNI-V2') {
      lpPositions.push({
        vaultAddr: lp_addresses[idx],
        balance: vault_balances[idx],
        token: lp_addresses[idx],
      })
    } else if (lp_addresses[idx] !== '') {
      singlePositions.push({
        vaultAddr: lp_addresses[idx],
        balance: vault_balances[idx],
        token: lp_addresses[idx],
      })
    }
  })

  const transformAddress = transformAddressKF()

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks['polygon'],
    'polygon',
    transformAddress,
  )

  await getSinglePositions(
    balances,
    singlePositions,
    chainBlocks['polygon'],
    'polygon',
    transformAddress,
  )

  return balances
}

const polygonTvl = ({ include, exclude }) => async (
  timestamp,
  block,
  chainBlocks,
) => {
  const balances = {}

/*  const vaults_full = (await utils.fetchURL(current_polygon_vaults_url)).data
  let vaults = vaults_full.map( v => v['vault']) */
  let vaults = (await utils.fetchURL(current_polygon_vaults_url)).data

  if (include) {
    vaults = include
  }
  if (exclude) {
    vaults = vaults.filter(
      (v) => !exclude.find((e) => e.toLowerCase() === v.toLowerCase()),
    )
  }

  const lp_addresses = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: vaults.map((vaultAddr) => ({
        target: vaultAddr,
      })),
      abi: abi.token,
    })
  ).output.map((val) => val.output)

  const lp_symbols = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: lp_addresses.map((address) => ({
        target: address,
      })),
      abi: abi.symbol,
    })
  ).output.map((val) => val.output)

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: 'polygon',
      block: chainBlocks['polygon'],
      calls: vaults.map((vaultAddr) => ({
        target: vaultAddr,
      })),
      abi: abi.balance,
    })
  ).output.map((val) => val.output)

  const lpPositions = []
  const singlePositions = []
  const crvPositions = []

  vaults.forEach((v, idx) => {
    if (
      lp_symbols[idx] === 'UNI-V2' ||
      (lp_symbols[idx] === 'DFYNLP') |
        (lp_symbols[idx] === 'SLP') |
        (lp_symbols[idx] === 'WLP') |
        (lp_symbols[idx] === 'ELP') |
        (lp_symbols[idx] === 'FLP') |
        (lp_symbols[idx] === 'pWINGS-LP') |
        (lp_symbols[idx] === 'APE-LP') |
        (lp_symbols[idx] === 'GLP') |
        (lp_symbols[idx] === 'Cafe-LP')
    ) {
      lpPositions.push({
        vaultAddr: vaults[idx],
        balance: vault_balances[idx],
        token: lp_addresses[idx],
      })
    } else if ((lp_symbols[idx] === 'crvUSDBTCETH') | (lp_symbols[idx] === 'am3CRV') | (lp_symbols[idx] === 'btcCRV')) {
      crvPositions.push({
        vaultAddr: vaults[idx],
        balance: vault_balances[idx],
        token: lp_addresses[idx],
      })
    } else if (vaults[idx] !== '') {
      singlePositions.push({
        vaultAddr: vaults[idx],
        balance: vault_balances[idx],
        token: lp_addresses[idx],
      })
    }
  })

  const transformAddress = transformAddressKF()

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks['polygon'],
    'polygon',
    transformAddress,
  )

  await unwrapCrvLPs(
    balances,
    crvPositions,
    chainBlocks['polygon'],
    'polygon',
    transformAddress,
  )

  await getSinglePositions(
    balances,
    singlePositions,
    chainBlocks['polygon'],
    'polygon',
    transformAddress,
  )

  return balances
}

const fantomTvl = async (timestamp, block, chainBlocks) => {
  let balances = {}

  let vaults = (await utils.fetchURL(current_fantom_vaults_url)).data

  const lp_addresses = (
    await sdk.api.abi.multiCall({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.token,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, lp_address: lp_addresses[idx] }))

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.balance,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, balance: vault_balances[idx] }))

  const uniV2Positions = []
  const balancerPositions = []
  const crvPositions = []

  // We populate the positions by protocol
  vaults.forEach((vault) => {
    const pushElem = (array) =>
      array.push({
        vaultAddr: vault.vault,
        balance: vault.balance,
        token: vault.lp_address,
        name: vault.__comment,
      })
    // Balancer
    if (
      ftm_BalancerForks
        .map((e) => String(vault.__comment).toLowerCase().includes(e.name))
        .reduce((p, c) => p && c, true)
    ) {
      pushElem(balancerPositions)
    }
    // CRV
    else if ((ftm_CrvVaultAddr.includes(vault.vault)) | (String(vault.__comment).toLowerCase().includes('curve '))) {
      pushElem(crvPositions)
    }
    // Uni-V2
    else {
      pushElem(uniV2Positions)
    }
  })

  const transformAddress = transformAddressKF('fantom')

  await unwrapUniswapLPs(
    balances,
    uniV2Positions,
    chainBlocks['fantom'],
    'fantom',
    transformAddress,
  )
  await unwrapCrvLPs(
    balances,
    crvPositions,
    chainBlocks['fantom'],
    'fantom',
    transformAddress,
  )

  await unwrapBalancerLPs(
    beethovenX,
    balances,
    balancerPositions,
    chainBlocks['fantom'],
    'fantom',
    transformAddress,
  )

  // Convert wMEMO into Time by dividing by 10 ** 9 and multiplying by the wMemo to Memo ratio
  const TIME = 'avax:0xb54f16fb19478766a268f172c9480f8da1a7c9c3';
  if (TIME in balances){
    // First, find the wMemo to Memo ratio by looking at the total supply of wMemo divided by the Memo locked
    const wMemoSupply = (
      await sdk.api.abi.call({
        chain: 'avax',
        block: chainBlocks['avax'],
        target: "0x0da67235dD5787D67955420C84ca1cEcd4E5Bb3b",
        abi: abi.totalSupply,
      })
    ).output
    const memoLocked = (
      await sdk.api.abi.call({
        chain: 'avax',
        block: chainBlocks['avax'],
        target: "0x136Acd46C134E8269052c62A67042D6bDeDde3C9",
        params: ["0x0da67235dD5787D67955420C84ca1cEcd4E5Bb3b"],
        abi: abi.balanceOf,
      })
    ).output
    const memoPerWMemo = memoLocked / wMemoSupply * 10 ** 9

    // Then, multiply the wMEMO balance by memo per wMemo ratio, use price of Time as price of Memo since they are 1:1
    balances[TIME] = Math.floor(balances[TIME] * memoPerWMemo / 10 ** 9);
  }

  // Convert sSpell into Spell by multiplying by the appropriate ratio
  const sSpell = 'fantom:0xbb29d2a58d880af8aa5859e30470134deaf84f2b';
  if (sSpell in balances){
    // First, find the spell to staked spell ratio by looking at the total supply of staked spell divided by the spell locked
    const sSpellSupply = (
      await sdk.api.abi.call({
        chain: 'ethereum',
        block: chainBlocks['ethereum'],
        target: "0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9",
        abi: abi.totalSupply,
      })
    ).output
    const spellLocked = (
      await sdk.api.abi.call({
        chain: 'ethereum',
        block: chainBlocks['ethereum'],
        target: "0x090185f2135308BaD17527004364eBcC2D37e5F6",
        params: ["0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9"],
        abi: abi.balanceOf,
      })
    ).output
    const spellPersSpell = spellLocked / sSpellSupply

    // Then, multiply the staked spell balance by spell to staked spell ratio
    balances[sSpell] = Math.floor(balances[sSpell] * spellPersSpell);
  }

  // Convert sUSDT into USDT by multiplying by the appropriate ratio
  const sUSDT = 'polygon:0x29e38769f23701A2e4A8Ef0492e19dA4604Be62c';
  if (sUSDT in balances){
    // First, find the USDT to staked USDT ratio by looking at the total supply of staked usdt divided by the s*usdt issued
    const sUSDTSupply = (
      await sdk.api.abi.call({
        chain: 'polygon',
        block: chainBlocks['polygon'],
        target: "0x29e38769f23701A2e4A8Ef0492e19dA4604Be62c",
        abi: abi.totalSupply,
      })
    ).output
    const sUSDTLiquidity = (
      await sdk.api.abi.call({
        chain: 'polygon',
        block: chainBlocks['polygon'],
        target: "0x29e38769f23701A2e4A8Ef0492e19dA4604Be62c",
        abi: abi.totalLiquidity,
      })
    ).output
    const usdtPersUSDT = sUSDTLiquidity / sUSDTSupply
    // Then, multiply the staked spell balance by spell to staked spell ratio
    balances[sUSDT] = Math.floor(balances[sUSDT] * usdtPersUSDT);
  }

  // Convert sUSDC into USDC by multiplying by the appropriate ratio
  const sUSDC = 'polygon:0x1205f31718499dBf1fCa446663B532Ef87481fe1';
  if (sUSDC in balances){
    // First, find the USDC to staked USDC ratio by looking at the total supply of staked usdc divided by the s*usdc issued
    const sUSDCSupply = (
      await sdk.api.abi.call({
        chain: 'polygon',
        block: chainBlocks['polygon'],
        target: "0x1205f31718499dBf1fCa446663B532Ef87481fe1",
        abi: abi.totalSupply,
      })
    ).output
    const sUSDCLiquidity = (
      await sdk.api.abi.call({
        chain: 'polygon',
        block: chainBlocks['polygon'],
        target: "0x1205f31718499dBf1fCa446663B532Ef87481fe1",
        abi: abi.totalLiquidity,
      })
    ).output
    const usdcPersUSDC = sUSDCLiquidity / sUSDCSupply

    // Then, multiply the staked spell balance by spell to staked spell ratio
    balances[sUSDC] = Math.floor(balances[sUSDC] * usdcPersUSDC);
  }

  return balances
}

const moonriverTvl = async (timestamp, block, chainBlocks) => {
  const balances = {}

  let vaults = (await utils.fetchURL(current_moonriver_vaults_url)).data

  const lp_addresses = (
    await sdk.api.abi.multiCall({
      chain: 'moonriver',
      block: chainBlocks['moonriver'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.token,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, lp_address: lp_addresses[idx] }))

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: 'moonriver',
      block: chainBlocks['moonriver'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.balance,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, balance: vault_balances[idx] }))

  const uniV2Positions = []
  const balancerPositions = []
  const crvPositions = []

  // We populate the positions by protocol
  vaults.forEach((vault) => {
    const pushElem = (array) =>
      array.push({
        vaultAddr: vault.vault,
        balance: vault.balance,
        token: vault.lp_address,
        name: vault.__comment,
      })
    // Balancer
    if (
      movr_BalancerForks.length &&
      movr_BalancerForks
        .map((e) => String(vault.__comment).toLowerCase().includes(e.name))
        .reduce((p, c) => p && c, true)
    ) {
      pushElem(balancerPositions)
    }
    // CRV
    else if (movr_CrvVaultAddr.includes(vault.vault)) {
      pushElem(crvPositions)
    }
    // Uni-V2
    else {
      pushElem(uniV2Positions)
    }
  })

  const transformAddress = transformAddressKF('moonriver')

  await unwrapUniswapLPs(
    balances,
    uniV2Positions,
    chainBlocks['moonriver'],
    'moonriver',
    transformAddress,
  )

  await unwrapCrvLPs(
    balances,
    crvPositions,
    chainBlocks['moonriver'],
    'moonriver',
    transformAddress,
  )

  await unwrapBalancerLPs(
    beethovenX,
    balances,
    balancerPositions,
    chainBlocks['moonriver'],
    'moonriver',
    transformAddress,
  )

  return balances
}

const kavaTvl = async (timestamp, block, chainBlocks) => {

  let balances = {};

  let vaults = (await utils.fetchURL(current_kava_vaults_url)).data
  if (typeof vaults === 'string') vaults = JSON.parse(vaults.replace(/\,(\s*[\}\]])/g, '$1'))

  const lp_addresses = (
    await sdk.api.abi.multiCall({
      chain: 'kava',
      block: chainBlocks['kava'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.token,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, lp_address: lp_addresses[idx] }))

  const vault_balances = (
    await sdk.api.abi.multiCall({
      chain: 'kava',
      block: chainBlocks['kava'],
      calls: vaults.map((vault) => ({
        target: vault.vault,
      })),
      abi: abi.balance,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, balance: vault_balances[idx] }))

  const lp_symbols = (
    await sdk.api.abi.multiCall({
      chain: 'kava',
      block: chainBlocks['kava'],
      calls: vaults.map((vault) => ({
        target: vault.lp_address,
      })),
      abi: abi.symbol,
    })
  ).output.map((val) => val.output)

  vaults = vaults.map((e, idx) => ({ ...e, symbol: lp_symbols[idx] }))

  const singlePositions = []
  const uniV2Positions = []
  const balancerPositions = []
  const crvPositions = []

  // We populate the positions by protocol
  vaults.forEach((vault) => {
    const pushElem = (array) =>
      array.push({
        vaultAddr: vault.vault,
        balance: vault.balance,
        token: vault.lp_address,
        symbol: vault.symbol,
        name: vault.__comment,
      })
    // Balancer
    if (
      kava_BalancerForks.length &&
      kava_BalancerForks
        .map((e) => String(vault.__comment).toLowerCase().includes(e.name))
        .reduce((p, c) => p && c, true)
    ) {
      pushElem(balancerPositions)
    }
    // CRV
    else if (kava_CrvVaultAddr.includes(vault.vault)) {
      pushElem(crvPositions)
    }
    // Uni-V2
    else if (vault.symbol==="Uni-V2" || vault.symbol==="SLP" || vault.symbol==="JUPITER-LP"){
      pushElem(uniV2Positions)
    }
    else{
      pushElem(singlePositions)
    }
  })

  const transformAddress = transformAddressKF('kava')

  await unwrapUniswapLPs(
    balances,
    uniV2Positions,
    chainBlocks['kava'],
    'kava',
    transformAddress,
  )

/*  const { updateBalances,
    pairBalances,
    prices,
    balances } = await getTokenPrices({
    block: kavablock,
    chain: kavachain,
    coreAssets: [wkava],
    lps: uniV2Positions.map(val => val.token),
    transformAddress: transformAddress,
    allLps: true
  })
*/
  await getSinglePositions(
    balances,
    singlePositions,
    chainBlocks['kava'],
    'kava',
    transformAddress,
  )

  const fixBalances = await getFixBalances('kava')
  fixBalances(balances)

  await unwrapCrvLPs(
    balances,
    crvPositions,
    chainBlocks['kava'],
    'kava',
    transformAddress,
  )

  await unwrapBalancerLPs(
    beethovenX,
    balances,
    balancerPositions,
    chainBlocks['kava'],
    'kava',
    transformAddress,
  )

  return balances
}

const kogeMasterChefAddr = '0x6275518a63e891b1bC54FEEBBb5333776E32fAbD'

// vKogeKoge
const _polygonStaking = polygonMasterChef(kogeMasterChefAddr, 1)

// Pool2
const kogecoinVaultAddr = '0x992Ae1912CE6b608E0c0d2BF66259ab1aE62A657'
const kogecoinMaticVaultAddr = '0xb7D3e1C5cb26D088d619525c6fD5D8DDC1B543d1'
const kogecoinSageVaultAddr = '0x4792b5943a05fc6AF3B20B5F1D1d7dDe33C42980'
const kogecoinIrisVaultAddr = '0x55A2FedB176C09488102596Db21937A753025466'
const kogecoinCollarVaultAddr = '0x64c20BB3D9aCD870f748fe73B6541D500643e490'
const kogecoinShieldVaultAddr = '0x7a9be7CdF26C8311625ed97c174869fcA9b791eC'
const kogecoinBetaVaultAddr = '0xEab5DAC8E6E3da7679b2a01FCD17DBE1Ed519904'
const kogecoinAlphaVaultAddr = '0xD02064bEd4126ACCCe79431A52F206C558479648'
const kogecoinTamagoVaultAddr = '0xA838F1e986b27d7AC5a977c7d0eCbADFFCDC7Bb5'

const _kogePool2 = [
  kogecoinVaultAddr,
  kogecoinMaticVaultAddr,
  kogecoinSageVaultAddr,
  kogecoinIrisVaultAddr,
  kogecoinCollarVaultAddr,
  kogecoinShieldVaultAddr,
  kogecoinBetaVaultAddr,
  kogecoinAlphaVaultAddr,
  kogecoinTamagoVaultAddr
]
const _polygonPool2 = async (timestamp, block, chainBlocks) => {
  return {
    ...(await polygonTvl({
      include: _kogePool2.filter((p) => p !== kogecoinVaultAddr),
    })(timestamp, block, chainBlocks)),
    ...(await polygonMasterChef(kogeMasterChefAddr, 0)(
      timestamp,
      block,
      chainBlocks,
    )),
  }
}
const _polygonTvl = polygonTvl({
  exclude: _kogePool2,
})

module.exports = {
  methodology: `The vaults are obtained through the following links: polygon:"${current_polygon_vaults_url}", fantom:"${current_fantom_vaults_url}, moonriver:"${current_moonriver_vaults_url}". By getting the vaults, we can then pull LP token deposit amounts. We then take the LP token deposits and unwrap them to count each token individually.`,
  polygon: {
    tvl: _polygonTvl,
    staking: _polygonStaking,
    pool2: _polygonPool2,
  },
  fantom: {
    tvl: fantomTvl,
  },
  moonriver: {
    tvl: moonriverTvl,
  },
  kava: {
    tvl: kavaTvl,
  },
}

'''
'''--- projects/kokoa-finance/Helper.json ---
{
  "address": "0x2b170005ADA0e616E78A7fa93ea4473c03A98aa0",
  "abi": [
    {
      "inputs": [],
      "name": "getCollateralTVL",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "collateralTVL",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSkokoaTVL",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "getKlayswapLpFarmTVL",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "getKokonutLpFarmTVL",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tvl",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ]
}
'''
'''--- projects/kokoa-finance/index.js ---
const ABI = require("./Helper.json");
const sdk = require("@defillama/sdk");
const chain = 'klaytn'

const { toUSDTBalances } = require("../helper/balances");
const BigNumber = require("bignumber.js");

const HELPER_ADDR = "0x2b170005ADA0e616E78A7fa93ea4473c03A98aa0";

const KLAYSWAP_POOLS = [
  {
    poolname: `KLAYKOKOA`,
    address: `0x53FE8c456C470A7214ed5caAd88c486449f3b196`,
    decimal: 18
  },
  {
    poolname: `AKLAYKOKOA`,
    address: `0x42cA952604ec07293ee463f6c5444C63339D53A0`,
    decimal: 18
  }
];

const KOKONUT_POOLS = [
  // {
  //   poolname: 'KLAYKSD',
  //   address: `0xc513524FDE442f2763c2A2Ba31D9A5c13Bcbab7b`,
  //   decimal: 18
  // },
  {
    poolname: 'AKLAYKSD',
    address: `0xB07D6D2534BfF886589064cc77CE025f2F61641a`,
    decimal: 18
  },
  {
    poolname: `KSD4EYE`,
    address: `0xa3A991273Ff9B1B9E0C2fD5e595830890F55D133`,
    decimal: 18
  }
]

const fetchCollateral = async (ts, _block, chainBlocks) => {
  const block = chainBlocks[chain]
  //calculate TVL sum of all collaterals locked in the protocol vaults
  const decimal = 18;

  var sum = new BigNumber(0);
  const { output: assetTvlLists } = await sdk.api.abi.call({
    chain, block,
    target: HELPER_ADDR,
    abi: ABI.abi.find(i => i.name === 'getCollateralTVL')
  })
  for (let assetTvl of assetTvlLists) {
    sum = sum.plus(assetTvl);
  }
  sum = sum.dividedBy(BigNumber(10).pow(decimal * 2))
  return toUSDTBalances(sum.toFixed(2));
}

const fetchPool2 = async (ts, _block, chainBlocks) => {
  const block = chainBlocks[chain]
  const decimal = 18;

  let klayswapPool2Tvl = BigNumber(0);
  for (let pool of KLAYSWAP_POOLS) {
    const { output: value } = await sdk.api.abi.call({
      chain, block,
      target: HELPER_ADDR,
      params: [pool[`address`]],
      abi: ABI.abi.find(i => i.name === 'getKlayswapLpFarmTVL')
    })
    klayswapPool2Tvl = klayswapPool2Tvl.plus(value);
  }
  let kokonutPool2Tvl = BigNumber(0);
  for (let pool of KOKONUT_POOLS) {
    const { output: value } = await sdk.api.abi.call({
      chain, block,
      target: HELPER_ADDR,
      params: [pool[`address`]],
      abi: ABI.abi.find(i => i.name === 'getKokonutLpFarmTVL')
    })
    kokonutPool2Tvl = kokonutPool2Tvl.plus(value);
  }
  const totalPool2 = klayswapPool2Tvl.plus(kokonutPool2Tvl).dividedBy(BigNumber(10 ** (decimal * 2)));
  return toUSDTBalances(totalPool2.toFixed(2));
}

const fetchStakedToken = async (ts, _block, chainBlocks) => {
  const block = chainBlocks[chain]
  //staked token prices are calculated using real-time KOKOA price from KLAY-KOKOA LP

  let { output: skokoaTvl } = await sdk.api.abi.call({
    chain, block,
    target: HELPER_ADDR,
    abi: ABI.abi.find(i => i.name === 'getSkokoaTVL')
  })
  const decimal = 18;
  skokoaTvl = BigNumber(skokoaTvl).dividedBy(BigNumber(10).pow(decimal * 2));
  return toUSDTBalances(BigNumber(skokoaTvl).toFixed(2));
}

module.exports = {
  klaytn: {
    staking: fetchStakedToken,
    tvl: fetchCollateral,
    pool2: fetchPool2
  },
  methodology:
    "tvl is calculated using the total collateral value locked in the protocol. Staked tokens include staked kokoa value. Pool2 includes staked LP tokens"
}
'''
'''--- projects/kokomoswap/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IBEP20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accKokomoPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/kokomoswap/index.js ---
const sdk = require("@defillama/sdk");
const tvlOnPairs = require("../helper/processPairs.js");

const FACTORY = "0x971A5f6Ef792bA565cdF61C904982419AA77989f";

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  await tvlOnPairs("bsc", chainBlocks, FACTORY, balances);

  return balances;
};

module.exports = {
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/kokonut-swap/abi.json ---
{
    "getPoolPriceInfo": {
        "inputs": [
            {
                "internalType": "contract II4ISwapPool",
                "name": "swap",
                "type": "address"
            }
        ],
        "name": "getPoolPriceInfo",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "tokens",
                "type": "address[]"
            },
            {
                "internalType": "uint256[]",
                "name": "balances",
                "type": "uint256[]"
            },
            {
                "internalType": "uint256[]",
                "name": "prices",
                "type": "uint256[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getStakedEyePriceInfo": {
        "inputs": [],
        "name": "getStakedEyePriceInfo",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "balance",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "price",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      "getPoolList": {
        "inputs": [],
        "name": "getPoolList",
        "outputs": [
          {
            "internalType": "address[]",
            "name": "",
            "type": "address[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
}
'''
'''--- projects/kokonut-swap/index.js ---
const abi = require("./abi.json");
const sdk = require("@defillama/sdk");
const { requery } = require('../helper/requery.js');

const registry_addr = "0xBd21dD5BCFE28475D26154935894d4F515A7b1C0";
const helper_addr = "0x1A09643f4D70B9Aa9da5737568C1935ED37423aa";
const chain = 'klaytn';

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  block = chainBlocks[chain]

  const poolList = (await sdk.api.abi.call({
    target: registry_addr,
    abi: abi.getPoolList,
    block,
    chain
  })).output;

  const info = await sdk.api.abi.multiCall({
    calls: poolList.map(p => ({
      target: helper_addr,
      params: p
    })),
    abi: abi.getPoolPriceInfo,
    block,
    chain
  });

  await requery(info, chain, chainBlocks[chain], abi.getPoolPriceInfo);
  const gasToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'.toLowerCase()
  const tokenSet = new Set()

  for (const data of info.output) {
    const { output: poolInfo, input: { params } } = data
    if (!poolInfo)  {
      console.log('pool info missing for ', params)
      continue;
    }
    for (let token of poolInfo.tokens) {
      token = token.toLowerCase()
      if (token !== gasToken) tokenSet.add(token)
    }
  }

  const { output: tokenResponse } = await sdk.api.abi.multiCall({
    abi: 'erc20:decimals',
    calls: [...tokenSet].map(i => ({ target: i })),
    chain, block,
  })

  const tokenMapping = {}
  tokenResponse.forEach(i => tokenMapping[i.input.target] = i.output)

  for (const { output: poolInfo } of info.output) {
    if (!poolInfo) continue;
    for (let j = 0; j < poolInfo.tokens.length;j++) {
      const token = poolInfo.tokens[j].toLowerCase()
      const decimal = token === gasToken ? 18 : tokenMapping[token]
      const balance = poolInfo.prices[j] / 1e18 * poolInfo.balances[j] / 10 ** (decimal);
      sdk.util.sumSingleBalance(balances, 'usd-coin', balance);
    }
  }

  return balances;
};

async function staking(timestamp, block, chainBlocks) {
  const info = (await sdk.api.abi.call({
    target: helper_addr,
    abi: abi.getStakedEyePriceInfo,
    block,
    chain
  })).output;

  return { 'usd-coin': info.price * info.balance / 10 ** 36 };
};

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  klaytn: {
    staking,
    tvl
  },
  methodology:
    "tvl is calculated using the total value of protocol's liquidity pool. Staked tokens include staked EYE values. Pool2 includes staked lp tokens eligible for KOKOS emissions"
};
'''
'''--- projects/kokoswap/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IBEP20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accKokomoPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/kokoswap/index.js ---
const sdk = require("@defillama/sdk");
const tvlOnPairs = require("../helper/processPairs.js");

const FACTORY = "0x971A5f6Ef792bA565cdF61C904982419AA77989f";

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  await tvlOnPairs("bsc", chainBlocks, FACTORY, balances);

  return balances;
};

module.exports = {
  methodology: "TVL could the liquidity on the DEX, pairs are found using the Factory address: '0x971A5f6Ef792bA565cdF61C904982419AA77989f'.",
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/kolibri/index.js ---
const axios = require("axios");
const {toUSDTBalances} = require('../helper/balances')

const tvlUrl = 'https://kolibri-data.s3.amazonaws.com/mainnet/totals.json';

async function tvl() {
    const response = await axios.get(tvlUrl)

    const xtzInOvens = Number(response.data.totalBalance)/1000000;
    const liquidityPoolBalance = Number(response.data.liquidityPoolBalance)
    
    return {
        "tezos": xtzInOvens,
        "true-usd": liquidityPoolBalance
    }
}
async function pool2() {
    return toUSDTBalances((await axios.get(tvlUrl)).data.quipuswapFarmBalanceUSD);
}
module.exports = {
    methodology: 'TVL counts the XTZ tokens that are deposited to mint kUSD, and kUSD in the liquidity pool. Borrowed tokens are not counted.',
    tezos:{
        tvl,
        pool2
    }
};

'''
'''--- projects/kommunitas/index.js ---
const { stakings } = require("../helper/staking");
const KOM_TOKEN_CONTRACT = '0xC004e2318722EA2b15499D6375905d75Ee5390B8';
const KOM_STAKING_CONTRACT = [
    "0x453d0a593d0af91e77e590a7935894f7ab1b87ec",
    "0x8d37b12DB32E07d6ddF10979c7e3cDECCac3dC13"
];

module.exports = {
    polygon: {
        tvl: () => ({}),
        staking: stakings(
            KOM_STAKING_CONTRACT,
            KOM_TOKEN_CONTRACT,
            "polygon",
            `polygon:${KOM_TOKEN_CONTRACT}`
        )
    }
};
'''
'''--- projects/koyo/constants.js ---
const { gql } = require("graphql-request");

const tvlExclusion = ["arbitrum", "avax", "bsc"];
const treasuryExclusion = [];
const stakingExclusion = ["arbitrum", "avax", "bsc", "aurora"];

const addresses = {
  boba: {
    treasury: "0x559dBda9Eb1E02c0235E245D9B175eb8DcC08398",
    staking: "0xD3535a7797F921cbCD275d746A4EFb1fBba0989F",
    feeCollector: "0xc9453BaBf4705F18e3Bb8790bdc9789Aaf17c2E1",
    KYO: "0x618CC6549ddf12de637d46CDDadaFC0C2951131C",
    BOBA: "0xa18bF3994C0Cc6E3b63ac420308E5383f53120D7",
    FRAX: "0x7562F525106F5d54E891e005867Bf489B5988CD9",
    USDC: "0x66a2A913e447d6b4BF33EFbec43aAeF87890FBbc",
    USDT: "0x5DE1677344D3Cb0D7D465c10b72A8f60699C062d",
    DAI: "0xf74195Bb8a5cf652411867c5C2C5b8C2a402be35",
    FRAX_KYO: "0xde7C350fA84B7fe792bfAA241303aeF04283c9d2",
  },
  arbitrum: {
    treasury: "0x7736DdFbf43eF2c4751F1E1D8f93EE15a5387DD9",
    USDC: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
  },
  avax: {
    treasury: "0x898125D67b9c8aD1029E42A2B16EF4CbB08c330f",
    USDC: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  },
  bsc: {
    treasury: "0x0F22D4765f66f2f8a9EF4Cd5D8F75B49933cF1CA",
    BUSD: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
  },
  aurora: {
    treasury: "0x0D9f7E01a3b8D35e56e3373AfD331340fFe9D7AF",
    feeCollector: "0x67900C87C756763F404926e188c21Eef959c7E06",
  },
};

const POOL_TOKENS = gql`
  {
    koyos {
      address
      pools(first: 1000) {
        tokens {
          address
        }
      }
    }
  }
`;

module.exports = {
  tvlExclusion,
  treasuryExclusion,
  stakingExclusion,
  addresses,
  POOL_TOKENS,
};

'''
'''--- projects/koyo/index.js ---
const sdk = require("@defillama/sdk");
const constants = require("./constants");
const { requery } = require("../helper/requery");
const { chainJoinExports, chainTypeExports } = require("./utils");
const { getBlock } = require("../helper/getBlock");
const { staking } = require("../helper/staking");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const {
  transformBobaAddress,
  transformArbitrumAddress,
  transformAvaxAddress,
  transformBscAddress,
  transformAuroraAddress,
} = require("../helper/portedTokens");
const { request } = require("graphql-request");

const DATA = {
  boba: async () => {
    const bobaTransform = transformBobaAddress();

    return [
      bobaTransform,
      {
        treasury: {
          addresss: [constants.addresses.boba.treasury],
          tokens: [
            [constants.addresses.boba.BOBA, false], // BOBA(Boba)
            [constants.addresses.boba.FRAX, false], // FRAX(Boba)
            [constants.addresses.boba.USDC, false], // USDC(Boba)
            [constants.addresses.boba.USDT, false], // USDT(Boba)
            [constants.addresses.boba.DAI, false], // DAI(Boba)
            [constants.addresses.boba.FRAX_KYO, true], // FRAX-KYO(Boba, OolongSwap)
          ],
        },
        staking: {
          address: constants.addresses.boba.staking,
          token: constants.addresses.boba.KYO,
        },
      },
    ];
  },
  arbitrum: async () => {
    const arbitrumTransform = await transformArbitrumAddress();

    return [
      arbitrumTransform,
      {
        treasury: {
          addresss: [constants.addresses.arbitrum.treasury],
          tokens: [
            [constants.addresses.arbitrum.USDC, false], // USDC(Arbitrum)
          ],
        },
      },
    ];
  },
  avax: async () => {
    const avalancheTransform = await transformAvaxAddress();

    return [
      avalancheTransform,
      {
        treasury: {
          addresss: [constants.addresses.avax.treasury],
          tokens: [
            [constants.addresses.avax.USDC, false], // USDC(Avalanche)
          ],
        },
      },
    ];
  },
  bsc: async () => {
    const bscTransform = await transformBscAddress();

    return [
      bscTransform,
      {
        treasury: {
          addresss: [constants.addresses.bsc.treasury],
          tokens: [
            [constants.addresses.bsc.BUSD, false], // BUSD(Binance Smart Chain)
          ],
        },
      },
    ];
  },
  aurora: async () => {
    const auroraTransform = await transformAuroraAddress();

    return [
      auroraTransform,
      {
        treasury: {
          addresss: [constants.addresses.aurora.treasury],
          tokens: [],
        },
      },
    ];
  },
};

const chainTVL = (chain) => {
  return async (timestamp, _ethBlock, chainBlocks) => {
    if (!DATA[chain] || constants.tvlExclusion.includes(chain)) return {};

    const balances = {};
    const block = await getBlock(timestamp, chain, chainBlocks);

    const [transform] = await DATA[chain]();
    const subgraphApi = `https://api.thegraph.com/subgraphs/name/koyo-finance/exchange-subgraph-${chain}`;

    const koyoVault = await request(subgraphApi, constants.POOL_TOKENS, {
      block,
    });

    let tokenAddresses = [];
    for (const pool of koyoVault.koyos[0].pools) {
      for (let address of pool.tokens) {
        tokenAddresses.push(address.address);
      }
    }
    tokenAddresses = [...new Set(tokenAddresses)];

    const balanceCalls = tokenAddresses.flatMap((address) => {
      return [
        {
          target: address,
          params: koyoVault.koyos[0].address,
        },
        { target: address, params: constants.addresses[chain].feeCollector },
      ];
    });
    const balancesCalled = await sdk.api.abi.multiCall({
      block,
      calls: balanceCalls,
      abi: "erc20:balanceOf",
    });
    await requery(balancesCalled, chain, block, "erc20:balanceOf");

    sdk.util.sumMultiBalanceOf(balances, balancesCalled, true, transform);

    return balances;
  };
};
const chainTreasury = (chain) => {
  return async (timestamp, _ethBlock, chainBlocks) => {
    if (!DATA[chain] || constants.treasuryExclusion.includes(chain)) return {};

    const balances = {};
    const block = await getBlock(timestamp, chain, chainBlocks);

    const [transform, data] = await DATA[chain]();

    await sumTokensAndLPsSharedOwners(
      balances,
      data.treasury.tokens,
      data.treasury.addresss,
      block,
      chain,
      transform
    );

    return balances;
  };
};
const chainStaking = (chain) => {
  return async (timestamp, ethBlock, chainBlocks) => {
    if (!DATA[chain] || constants.stakingExclusion.includes(chain)) return {};

    const [, data] = await DATA[chain]();

    return staking(data.staking.address, data.staking.token, chain)(
      timestamp,
      ethBlock,
      chainBlocks
    );
  };
};

module.exports = chainJoinExports(
  [
    (chains) => chainTypeExports("tvl", chainTVL, chains),
    (chains) => chainTypeExports("treasury", chainTreasury, chains),
    (chains) => chainTypeExports("staking", chainStaking, chains),
  ],
  ["boba", "arbitrum", "avax", "bsc", "aurora"]
);

module.exports = {
  ...module.exports,
  methodology:
    "Counts the tokens locked on swap pools based on their holdings.",
};

'''
'''--- projects/koyo/utils.js ---
const chainTypeExports = (chainType, chainFn, chains) => {
  const chainTypeProps = chains.reduce(
    (obj, chain) => ({
      ...obj,
      [chain === "avax" ? "avalanche" : chain]: {
        [chainType]: chainFn(chain),
      },
    }),
    {}
  );

  return chainTypeProps;
};

const chainJoinExports = (cExports, chains) => {
  const createdCExports = cExports.map((cExport) => cExport(chains));
  const chainJoins = chains.reduce((obj, chain) => {
    chain = chain === "avax" ? "avalanche" : chain;

    return {
      ...obj,
      [chain]: Object.fromEntries(
        createdCExports.flatMap((cExport) => [
          ...Object.entries(cExport[chain]),
        ])
      ),
    };
  }, {});

  return chainJoins;
};

module.exports = {
  chainTypeExports,
  chainJoinExports,
};

'''
'''--- projects/kromatika/abi.json ---
{
    "tokenByIndex": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "tokenByIndex",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "orders": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "orders",
        "outputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token0",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "token1",
                "type": "address"
            },
            {
                "internalType": "uint24",
                "name": "fee",
                "type": "uint24"
            },
            {
                "internalType": "int24",
                "name": "tickLower",
                "type": "int24"
            },
            {
                "internalType": "int24",
                "name": "tickUpper",
                "type": "int24"
            },
            {
                "internalType": "uint128",
                "name": "liquidity",
                "type": "uint128"
            },
            {
                "internalType": "uint256",
                "name": "processed",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "tokensOwed0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "tokensOwed1",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/kromatika/index.js ---
const sdk = require("@defillama/sdk")
const { getChainTransform } = require('../helper/portedTokens')
const abi = require('./abi.json')

const contracts = {
  optimism: {
    KROM: '0xf98dcd95217e15e05d8638da4c91125e59590b07',
    position: '0x7314Af7D05e054E96c44D7923E68d66475FfaAb8'
  },
  ethereum: {
    KROM: '0x3af33bef05c2dcb3c7288b77fe1c8d2aeba4d789',
    position: '0xd1fdf0144be118c30a53e1d08cc1e61d600e508e'
  },
  arbitrum: {
    KROM: '0x55ff62567f09906a85183b866df84bf599a4bf70',
    position: '0x02C282F60FB2f3299458c2B85EB7E303b25fc6F0'
  }
};

const tvl = (chain) => async function (timestamp, ethBlock, chainBlocks) {
  const krom_position = contracts[chain].position;

  let transform = await getChainTransform(chain);
  const block = chainBlocks[chain]
  const balances = {};

  // Get LP positions tokens owed
  const { output: positionsSupply } = await sdk.api.erc20.totalSupply({ target: krom_position, chain, block, });
  const position_indices = Array.from(Array(parseInt(positionsSupply)).keys());
  const calls = position_indices.map(idx => ({ target: krom_position, params: [idx] }))
  const tokenIds = await sdk.api.abi.multiCall({ calls, abi: abi['tokenByIndex'], chain, block, });
  const tokenCalls = tokenIds.output.map(idx => ({ target: krom_position, params: [idx.output] }))
  const orders = await sdk.api.abi.multiCall({ calls: tokenCalls, abi: abi['orders'], chain, block, });
  // Retrieve valid orders and add tokens owed to balances
  const valid_orders = orders.output
    .map(order => order.output)
  
  valid_orders.forEach(order => {
    sdk.util.sumSingleBalance(balances, transform(order.token0), order.tokensOwed0);
    sdk.util.sumSingleBalance(balances, transform(order.token1), order.tokensOwed1);
  });

  return balances;
}

const staking = (chain) => async function (timestamp, ethBlock, chainBlocks) {
  const krom = contracts[chain].KROM;
  const krom_position = contracts[chain].position;

  let transform = await getChainTransform(chain);
  const block = chainBlocks[chain]

  // Get Kroma deposited by users to pay for their fees
  const { output: balance } = await sdk.api.erc20.balanceOf({ target: krom, owner: krom_position, chain, block, });
  const balances = {};
  sdk.util.sumSingleBalance(balances, transform(krom), balance);

  return balances;
}

module.exports = {
  methodology: "Kromatika handles Uniswap-v3 positions for their users who submit limit orders - TVL is amounts of tokens of each LP as well as KROM held by the contract to pay for fees",
  optimism: {
    tvl: tvl('optimism'),
    staking: staking('optimism'),
  },
  arbitrum: {
    // tvl: tvl('arbitrum'),
    staking: staking('arbitrum'),
  },
  // ethereum: {
  //   tvl: tvl('ethereum')
  // }
}
// UniswapV3Pool NonfungiblePositionManager has a low level mint method
// this is what UniswapNFT uses and Kromatikaa is also using it; so in a way Kromatika is a different NFT LP manager for UniswapV3 but for limit orders
// users gets Kromatika NFT for their limit position;  same as they get Uniswap NFT for their LP; so it is a similar impl from Uniswap, but extended to support limit orders 
'''
'''--- projects/kronos/index.js ---
const sdk = require("@defillama/sdk");
const { getChainTransform, getFixBalances } = require("../helper/portedTokens")

const KDAI = "0x5c74070fdea071359b86082bd9f9b3deaafbe32b";
const KSD = "0x4fa62f1f404188ce860c8f0041d6ac3765a72e67";
const wrappedKlay = '0xd7a4d10070a4f7bc2a015e78244ea137398c3b74'
const TREASURY = "0x03c812eE50e244909efE72e8c729976ACc5C16bb";
const token = "0xd676e57ca65b827feb112ad81ff738e7b6c1048d";
const STAKING_ADDR = "0x39281362641da798de3801b23bfba19155b57f13";

const LPs = [
  {
    address: '0xdf5caf79899407da1c1b31389448861a9846956d', // KDAI_KRNO_LP
    tokens: [
      KDAI,
    ]
  },
  {
    address: '0x5876aa130de74d9d8924e8ff05a0bc4387ee93f0', // KSD_KRNO_LP
    tokens: [
      KSD,
    ]
  },
  {
    address: '0x193ce4066aebe1911feb03425d4312a7b6514081', // KRNO_KLAY_LP
    tokens: [ ]
  },
  {
    address: '0x2febbaed702b9a1d9f6ffccd67701550ac546115',  // KRNO_KSP_LP
    tokens: [
      '0xc6a2ad8cc6e4a7e08fc37cc5954be07d499e7654',
    ]
  }
]

const chain = 'klaytn'
let balanceResolve

async function addToBalance({ balances, lp, owner, transform, block }) {
  let valueToken = lp.tokens[0] || wrappedKlay
  const lpTokenValue = lp.tokens[0] ? sdk.api.erc20.balanceOf({ target: valueToken, owner: lp.address, block, chain }) : sdk.api.eth.getBalance({ target: lp.address, block, chain })

  const [
    valueBalance,
    lpSupply,
    lpBalance,
  ] = await Promise.all([
    lpTokenValue,
    sdk.api.erc20.totalSupply({ target: lp.address, block, chain }),
    sdk.api.erc20.balanceOf({ target: lp.address, owner, block, chain }),
  ]).then(all => all.map(i => i.output))

  const value = valueBalance * lpBalance * 2 / lpSupply
  sdk.util.sumSingleBalance(balances, transform(valueToken), value)
}

function getTvlPromise(key) {
  return async (ts, _block, chainBlocks) => {
    if (!balanceResolve)
      balanceResolve = getTvl(ts, _block, chainBlocks)
    return (await balanceResolve)[key]
  }
}

async function getTvl(timestamp, ethBlock, chainBlocks) {
  const block = chainBlocks[chain]

  const balances = {
    staking: {},
    tvl: {}
  }
  const transform = await getChainTransform(chain)
  const fixBalances = await getFixBalances(chain)

  await Promise.all(LPs.map(lp => addToBalance({
    balances: balances.tvl,
    owner: TREASURY,
    block,
    lp,
    transform,
  })))

  const [
    tokenBalance,
    kdaiBalance,
    stakingBalance,
  ] = await Promise.all([
    sdk.api.erc20.balanceOf({ target: token, owner: LPs[0].address, block, chain }),
    sdk.api.erc20.balanceOf({ target: KDAI, owner: LPs[0].address, block, chain }),
    sdk.api.erc20.balanceOf({ target: token, owner: STAKING_ADDR, block, chain }),
  ]).then(all => all.map(i => i.output))

  const tokenPrice = kdaiBalance / tokenBalance
  const staking = stakingBalance * tokenPrice / 10 ** 18

  sdk.util.sumSingleBalance(balances.staking, 'tether', staking)
  fixBalances(balances.tvl)

  return balances
};

module.exports = {
  misrepresentedTokens: true,
  klaytn:
    ['tvl', 'staking']
      .reduce((acc, key) => ({ ...acc, [key]: getTvlPromise(key) }), {}),
};

'''
'''--- projects/kronosdao/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { stakingUnknownPricedLP } = require("../helper/staking");

const kronosFactory = "0xcc045ebC2664Daf316aa0652E72237609EA6CB4f";
const kRONOSMasterChef = "0x30e9f20414515116598D073F3EBA116c68A6f4aC";
const kronosDaoToken = "0xbeC68a941feCC79E57762e258fd1490F29235D75";
const kronosBusdLP = "0xDBB34E29D345788273e85DE84814CfAA95c9c5f7";

async function bscTvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(
    (addr) => `bsc:${addr}`,
    chainBlocks.bsc,
    "bsc",
    kronosFactory,
    0,
    true
  );
}
module.exports = {
  methodology: "TVL consists of pools created by the factory contract",
  bsc: {
    tvl: bscTvl,
    staking: stakingUnknownPricedLP(
      kRONOSMasterChef,
      kronosDaoToken,
      "bsc",
      kronosBusdLP,
      (addr) => `bsc:${addr}`
    ),
  },
};

'''
'''--- projects/kryptodex/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')
module.exports = {
    misrepresentedTokens: true,
    methodology: "Factory address (0x33c04bD4Ae93336BbD1024D709f4A313cC858EBe) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
    cronos: {
        tvl: calculateUsdUniTvl("0x33c04bD4Ae93336BbD1024D709f4A313cC858EBe", "cronos", "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23", [
            //KRX
            "0xF0681BB7088Ac68A62909929554Aa22ad89a21fB",
            //CRONA
            "0xadbd1231fb360047525BEdF962581F3eee7b49fe",
            //USDC
            "0xc21223249CA28397B4B6541dfFaEcC539BfF0c59",
            //BUSD
            "0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8",
            //USDT
            "0x66e428c3f67a68878562e79A0234c1F83c208770",
            //DAI
            "0xF2001B145b43032AAF5Ee2884e456CCd805F677D"], "crypto-com-chain"),
        staking: stakingPricedLP("0x53cE820Ed109D67746a86b55713E30252275c127", "0xF0681BB7088Ac68A62909929554Aa22ad89a21fB", "cronos", "0xD2219106310E46D7FD308c0eC9d9FCc2d2c8a9B5", "crypto-com-chain")
    }
}
'''
'''--- projects/kswapfinance/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl.js");

const factory = "0x60DCD4a2406Be12dbe3Bb2AaDa12cFb762A418c1";
const wokt = "0x8F8526dbfd6E38E3D8307702cA8469Bae6C56C15";
const whitelist = [
  "0x382bB369d343125BfB2117af9c149795C6C65C50", // USDT
  "0x54e4622DC504176b3BB432dCCAf504569699a7fF", // BTCK
  "0xEF71CA2EE68F45B9Ad6F72fbdb33d707b872315C", // ETHK
  "0xdF54B6c6195EA4d948D03bfD818D365cf175cFC2", // OKB
  "0xab0d1578216A545532882e420A8C61Ea07B00B12", // KST
];

module.exports = {
  tvl: calculateUsdUniTvl(factory, "okexchain", wokt, whitelist, "okexchain"),
  methodology:
    "We count tvl on LiquidityPool(pairs) through factory contract",
};

'''
'''--- projects/kudexfinance/abi.json ---
{
    "poolLength": {
        "inputs": [],
        "name": "poolLength",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IKRC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accKudexPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "depositFeeBP",
                "type": "uint16"
            },
            {
                "internalType": "uint256",
                "name": "harvestInterval",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/kudexfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformKccAddress } = require("../helper/portedTokens");

const masterChefContract = "0x243e46d50130f346bede1d9548b41c49c6440872";

const kccTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const poolLength = (
    await sdk.api.abi.call({
      abi: abi.poolLength,
      target: masterChefContract,
      chain: "kcc",
      block: chainBlocks["kcc"],
    })
  ).output;

  const lpPositions = [];

  for (let index = 0; index < poolLength; index++) {
    const lpTokens_sToken = (
      await sdk.api.abi.call({
        abi: abi.poolInfo,
        target: masterChefContract,
        params: index,
        chain: "kcc",
        block: chainBlocks["kcc"],
      })
    ).output[0];

    const lpToken_sToken_bal = (
      await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: lpTokens_sToken,
        params: masterChefContract,
        chain: "kcc",
        block: chainBlocks["kcc"],
      })
    ).output;

    if (index == 1 || index == 3 || index == 5 || index == 8) {
      sdk.util.sumSingleBalance(
        balances,
        `kcc:${lpTokens_sToken}`,
        lpToken_sToken_bal
      );
    } else {
      lpPositions.push({
        token: lpTokens_sToken,
        balance: lpToken_sToken_bal,
      });
    }
  }

  const transformAddress = await transformKccAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["kcc"],
    "kcc",
    transformAddress
  );
  balances['0xdac17f958d2ee523a2206206994597c13d831ec7'] /= 10 ** 12;
  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  methodology: "We count liquidity on the farms (LP tokens) and pools(single tokens) threw masterchef contract",
  kcc: {
    tvl: kccTvl,
  },
};
'''
'''--- projects/kujira/index.js ---
const sdk = require("@defillama/sdk");
const { get } = require("../helper/http");

const COINGECKO_ID = "kujira";

const TOKENS = {
  ukuji: { coinGeckoId: "kujira", decimals: 6 },
  "ibc/1B38805B1C75352B28169284F96DF56BDEBD9E8FAC005BDCC8CF0378C82AA8E7": {
    coinGeckoId: "weth",
    decimals: 18,
  },
  "ibc/295548A78785A1007F232DE286149A6FF512F180AF5657780FC89C009E2C348F": {
    coinGeckoId: "axlusdc",
    decimals: 6,
  },
  "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2": {
    coinGeckoId: "cosmos",
    decimals: 6,
  },
  "ibc/47BD209179859CDE4A2806763D7189B6E6FE13A17880FE2B42DE1E6C1E329E23": {
    coinGeckoId: "osmosis",
    decimals: 6,
  },
  "ibc/EFF323CC632EC4F747C61BCE238A758EFDB7699C3226565F7C20DA06509D59A5": {
    coinGeckoId: "juno-network",
    decimals: 6,
  },
  "ibc/F3AA7EF362EC5E791FE78A0F4CCC69FEE1F9A7485EB1A8CAB3F6601C00522F10": {
    coinGeckoId: "evmos",
    decimals: 18,
  },
  "ibc/A358D7F19237777AF6D8AD0E0F53268F8B18AE8A53ED318095C14D6D7F3B2DB5": {
    coinGeckoId: "secret",
    decimals: 6,
  },
};

async function staking() {
  const res = await get(
    "https://lcd.kaiyo.kujira.setten.io/cosmos/staking/v1beta1/pool"
  );

  const { pool } = res;

  return { [COINGECKO_ID]: parseInt(pool.bonded_tokens) / 10 ** 6 };
}

async function tvl() {
  const { pairs } = await get("https://api.kujira.app/api/coingecko/pairs");
  const balances = {};
  await Promise.all(
    pairs.map(async (pair) => {
      const res = await get(
        `https://lcd.kaiyo.kujira.setten.io/cosmos/bank/v1beta1/balances/${pair.pool_id}`
      );
      res.balances.forEach((b) => {
        TOKENS[b.denom] &&
          sdk.util.sumSingleBalance(
            balances,
            TOKENS[b.denom].coinGeckoId,
            parseInt(b.amount) / 10 ** TOKENS[b.denom].decimals
          );
      });
    })
  );

  return balances;
}

module.exports = {
  kujira: {
    tvl,
    staking,
  },
};

'''
'''--- projects/kuswap/index.js ---
const { getUniTVL } = require('../helper/unknownTokens');

module.exports = {
  misrepresentedTokens: true,
  kcc: {
    tvl: getUniTVL({
      chain: 'kcc',
      factory: '0xAE46cBBCDFBa3bE0F02F463Ec5486eBB4e2e65Ae',
      coreAssets: [
        '0x4446Fc4eb47f2f6586f9fAAb68B3498F86C07521', // wkcs
        '0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d', // BUSD
        '0x4A81704d8C16d9FB0d7f61B747D0B5a272badf14', // kuswap
      ],
    }),
  },
}

'''
'''--- projects/kuufinance/abi.json ---
{
    "borrowableBalance": {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "uint256",
                "name": "",
                "internalType": "uint256"
            }
        ],
        "name": "borrowableBalance",
        "inputs": [
            {
                "type": "address",
                "name": "_token",
                "internalType": "address"
            }
        ]
    }
}
'''
'''--- projects/kuufinance/index.js ---
const sdk = require("@defillama/sdk");
const utils = require("../helper/utils");
const abi = require("./abi.json");

const JITU_CONTRACT_ADDRESS = "0x037BB12721A8876386411dAE5E31ff0c5bA991A8";
const WAVAX = '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7';
const AVAX_KUU = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";

const avaxTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const erc20TokenAddresses = (
    await utils.fetchURL(
      "https://distributor-public-data-itke7j4u7q-uc.a.run.app/getIndividualSnapshot/0x0Ba99dB0Da8201056831c359d9Ebd354f3466359"
    )
  ).data.assets.map((underlying) => underlying.underlyingTokenAddress);

  const balanceOfAssets = (
    await sdk.api.abi.multiCall({
      abi: abi.borrowableBalance,
      calls: erc20TokenAddresses.map((erc20) => ({
        target: JITU_CONTRACT_ADDRESS,
        params: erc20,
      })),
      chain: "avax",
      block: chainBlocks["avax"],
    })
  ).output.map((boa) => boa.output);

  for (let index = 0; index < erc20TokenAddresses.length; index++) {

    if(erc20TokenAddresses[index] == AVAX_KUU){
      sdk.util.sumSingleBalance(
        balances,
        `avax:${WAVAX}`,
        balanceOfAssets[index]
      );
    }else{
      sdk.util.sumSingleBalance(
        balances,
        `avax:${erc20TokenAddresses[index]}`,
        balanceOfAssets[index]
      );
    }
  }

  return balances;
};

module.exports = {
  deadFrom: 1648765747,
  misrepresentedTokens: true,
  avalanche: {
    tvl: avaxTvl,
  },
  methodology: `We count as TVL all the assets deposited in JITU contract`,
};

'''
'''--- projects/kyber/abi.json ---
{
  "getTokenWallet": {
    "inputs": [
      {
        "internalType": "contract IERC20",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "getTokenWallet",
    "outputs": [
      {
        "internalType": "address",
        "name": "wallet",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "allPools": {
    "inputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "name": "allPools",
    "outputs": [
        {
            "internalType": "address",
            "name": "",
            "type": "address"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
"allPoolsLength": {
    "inputs": [],
    "name": "allPoolsLength",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
"token0": {
    "inputs": [],
    "name": "token0",
    "outputs": [
        {
            "internalType": "contract IERC20",
            "name": "",
            "type": "address"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
"token1": {
    "inputs": [],
    "name": "token1",
    "outputs": [
        {
            "internalType": "contract IERC20",
            "name": "",
            "type": "address"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
"getReserves": {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
        {
            "internalType": "uint112",
            "name": "_reserve0",
            "type": "uint112"
        },
        {
            "internalType": "uint112",
            "name": "_reserve1",
            "type": "uint112"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}
}
'''
'''--- projects/kyber/index.js ---
const sdk = require("@defillama/sdk");
const retry = require("async-retry");
const { GraphQLClient, gql } = require("graphql-request");
const { getChainTransform } = require("../helper/portedTokens");
const { calcTvl } = require("./tvl.js");
const { getBlock } = require("../helper/getBlock");
const abi = require("./abi.json");

const chains = {
  ethereum: {
    graphId: "mainnet",
    factory: "0x833e4083B7ae46CeA85695c4f7ed25CDAd8886dE"
  },
  arbitrum: {
    graphId: "arbitrum-one",
    factory: "0x51E8D106C646cA58Caf32A47812e95887C071a62"
  },
  polygon: {
    graphId: "matic",
    factory: "0x5F1fe642060B5B9658C15721Ea22E982643c095c"
  },
  avax: {
    graphId: "avalanche",
    factory: "0x10908C875D865C66f271F5d3949848971c9595C9"
  },
  bsc: {
    graphId: "bsc",
    factory: "0x878dFE971d44e9122048308301F540910Bbd934c"
  },
  fantom: {
    graphId: "fantom",
    factory: "0x78df70615ffc8066cc0887917f2Cd72092C86409"
  },
  cronos: {
    graphId: "cronos",
    factory: "0xD9bfE9979e9CA4b2fe84bA5d4Cf963bBcB376974"
  },
  optimism: {
    graphId: "optimism",
    factory: "0x1c758aF0688502e49140230F6b0EBd376d429be5"
  },
  aurora: { factory: "0xD9bfE9979e9CA4b2fe84bA5d4Cf963bBcB376974" },
  //velas: { factory: "0xD9bfE9979e9CA4b2fe84bA5d4Cf963bBcB376974" },
  oasis: { factory: "0xD9bfE9979e9CA4b2fe84bA5d4Cf963bBcB376974" }
  //bittorrent: { factory: "0xD9bfE9979e9CA4b2fe84bA5d4Cf963bBcB376974" }
};

async function fetchPools(chain) {
  const url =
    chain == "cronos"
      ? "https://cronos-graph.kyberengineering.io/subgraphs/name/kybernetwork/kyberswap-elastic-cronos"
      : `https://api.thegraph.com/subgraphs/name/kybernetwork/kyberswap-elastic-${chain}`;
  const graphQLClient = new GraphQLClient(url);

  return (await retry(
    async bail =>
      await graphQLClient.request(gql`
        {
          pools {
            id
          }
        }
      `)
  )).pools.map(p => p.id);
}
function elastic(chain) {
  return async (_, block, chainBlocks) => {
    if (!("graphId" in chains[chain])) return {};

    block = chainBlocks[chain];
    const pools = await fetchPools(chains[chain].graphId);
    const balances = {};
    const transform = await getChainTransform(chain);

    const [{ output: token0s }, { output: token1s }] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: pools.map(p => ({
          target: p
        })),
        block,
        chain,
        abi: abi.token0
      }),
      sdk.api.abi.multiCall({
        calls: pools.map(p => ({
          target: p
        })),
        block,
        chain,
        abi: abi.token1
      })
    ]);
    const [token0Balances, token1Balances] = await Promise.all([
      sdk.api.abi.multiCall({
        calls: pools.map((p, i) => ({
          target: token0s[i].output,
          params: [p]
        })),
        block,
        chain,
        abi: "erc20:balanceOf"
      }),
      sdk.api.abi.multiCall({
        calls: pools.map((p, i) => ({
          target: token1s[i].output,
          params: [p]
        })),
        block,
        chain,
        abi: "erc20:balanceOf"
      })
    ]);

    sdk.util.sumMultiBalanceOf(balances, token0Balances, true, transform);
    sdk.util.sumMultiBalanceOf(balances, token1Balances, true, transform);

    return balances;
  };
}
function classic(chain) {
  return async (timestamp, block, chainBlocks) => {
    if (!("factory" in chains[chain])) return {};
    const transform = await getChainTransform(chain);
    return calcTvl(
      transform,
      getBlock(timestamp, chain, chainBlocks),
      chain,
      chains[chain].factory,
      0,
      true
    );
  };
}

const moduleExports = {};
Object.keys(chains).forEach(chain => {
  moduleExports[chain] = {
    tvl: sdk.util.sumChainTvls([elastic(chain), classic(chain)])
  };
});
module.exports = {
  misrepresentedTokens: true,
  ...moduleExports
};

'''
'''--- projects/kyber/tvl.js ---
const BigNumber = require('bignumber.js');
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const { getFixBalances } = require('../helper/portedTokens')

async function requery(results, chain, block, abi){
  if(results.some(r=>!r.success)){
    const failed = results.map((r,i)=>[r,i]).filter(r=>!r[0].success)
    const newResults = await sdk.api.abi
    .multiCall({
      abi,
      chain,
      calls: failed.map((f) => f[0].input),
      block,
    }).then(({ output }) => output);
    failed.forEach((f, i)=>{
      results[f[1]] = newResults[i]
    })
  }
}

async function calcTvl(getAddress, block, chain, FACTORY, START_BLOCK, useMulticall) {
  let poolAddresses;
  if (useMulticall) {
    const poolLength = (await sdk.api.abi.call({
      target: FACTORY,
      abi: abi.allPoolsLength,
      chain,
      block
    })).output
    if(poolLength === null){
      throw new Error("allPollsLength() failed")
    }
    const poolNums = Array.from(Array(Number(poolLength)).keys())
    const pools = (await sdk.api.abi.multiCall({
      abi: abi.allPools,
      chain,
      calls: poolNums.map(num => ({
        target: FACTORY,
        params: [num]
      })),
      block
    })).output
    await requery(pools, chain, block, abi.allPools);
    await requery(pools, chain, block, abi.allPools);
    await requery(pools, chain, block, abi.allPools);
    poolAddresses = pools.map(result => result.output.toLowerCase())
  } else {
    const logs = (
      await sdk.api.util
        .getLogs({
          keys: [],
          toBlock: block,
          chain,
          target: FACTORY,
          fromBlock: START_BLOCK,
          topic: 'poolCreated(address,address,address,uint32,uint256)',
        })
    ).output;

    poolAddresses = logs
      // sometimes the full log is emitted
      .map((log) =>
        typeof log === 'string' ? log : `0x${log.data.slice(64 - 40 + 2, 64 + 2)}`
      )
      // lowercase
      .map((poolAddress) => poolAddress.toLowerCase());
  }

  const [token0Addresses, token1Addresses, reserves] = await Promise.all([
    sdk.api.abi
      .multiCall({
        abi: abi.token0,
        chain,
        calls: poolAddresses.map((poolAddress) => ({
          target: poolAddress,
        })),
        block,
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: abi.token1,
        chain,
        calls: poolAddresses.map((poolAddress) => ({
          target: poolAddress,
        })),
        block,
      })
      .then(({ output }) => output),
    sdk.api.abi
      .multiCall({
        abi: abi.getReserves,
        chain,
        calls: poolAddresses.map((poolAddress) => ({
          target: poolAddress,
        })),
        block,
      }).then(({ output }) => output),
  ]);
  await requery(token0Addresses, chain, block, abi.token0);
  await requery(token1Addresses, chain, block, abi.token1);
  await requery(reserves, chain, block, abi.getReserves);
  await requery(token0Addresses, chain, block, abi.token0);
  await requery(token1Addresses, chain, block, abi.token1);
  await requery(reserves, chain, block, abi.getReserves);
  await requery(token0Addresses, chain, block, abi.token0);
  await requery(token1Addresses, chain, block, abi.token1);
  await requery(reserves, chain, block, abi.getReserves);
  const pools = {};
  // add token0Addresses
  token0Addresses.forEach((token0Address) => {
    const tokenAddress = token0Address.output.toLowerCase();

    const poolAddress = token0Address.input.target.toLowerCase();
    pools[poolAddress] = {
      token0Address: getAddress(tokenAddress),
    }
  });

  // add token1Addresses
  token1Addresses.forEach((token1Address) => {
    const tokenAddress = token1Address.output.toLowerCase();
    const poolAddress = token1Address.input.target.toLowerCase();
    pools[poolAddress] = {
      ...(pools[poolAddress] || {}),
      token1Address: getAddress(tokenAddress),
    }
  });

  const balances = reserves.reduce((accumulator, reserve, i) => {
      const poolAddress = reserve.input.target.toLowerCase();
      const pool = pools[poolAddress] || {};

      // handle reserve0
      if (pool.token0Address) {
        const reserve0 = new BigNumber(reserve.output['0']);
        if (!reserve0.isZero()) {
          const existingBalance = new BigNumber(
            accumulator[pool.token0Address] || '0'
          );

          accumulator[pool.token0Address] = existingBalance
            .plus(reserve0)
            .toFixed()
        }
      }

      // handle reserve1
      if (pool.token1Address) {
        const reserve1 = new BigNumber(reserve.output['1']);

        if (!reserve1.isZero()) {
          const existingBalance = new BigNumber(
            accumulator[pool.token1Address] || '0'
          );

          accumulator[pool.token1Address] = existingBalance
            .plus(reserve1)
            .toFixed()
        }
      }

    return accumulator
  }, {})

  const fix = await getFixBalances(chain)
  fix(balances)

  return balances
};

module.exports = {
  calcTvl,
};
'''
'''--- projects/kyrios/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const token = "0xdbf8a44f447cf6fa300fa84c2aac381724b0c6dd"
const masterchef = "0x7aAa607A456607dd03496065ebBAC52f74c905bE";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "fantom", token, false)
}
'''
'''--- projects/l2finance/abi.json ---
{
    "supplyToken": {
        "inputs": [],
        "name": "supplyToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "syncBalance": {
        "inputs": [],
        "name": "syncBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/l2finance/index.js ---
const sdk = require('@defillama/sdk')
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs')
const abi = require('./abi.json')

const rollupChain = "0xf86FD6735f88d5b6aa709B357AD5Be22CEDf1A05"
const registry = "0xfe81ab6930a30bdae731fe7b6c6abfbeafc014a8"

async function tvl(timestamp, block){
    const strategies = (await sdk.api.util.getLogs({
        target: registry,
        fromBlock: 12283733-1,
        toBlock: block,
        keys:[],
        topic:'StrategyRegistered(address,uint32)'
    })).output.map(s=>"0x"+s.data.slice(26, 66))
    const [syncBalances, tokens] = await Promise.all([abi.syncBalance,abi.supplyToken].map(abiMethod=>sdk.api.abi.multiCall({
        abi: abiMethod,
        block,
        calls: strategies.map(s=>({target:s}))
    })))
    const balances = {}
    syncBalances.output.forEach((bal, i)=>{
        sdk.util.sumSingleBalance(balances, tokens.output[i].output, bal.output)
    })
    await sumTokensAndLPsSharedOwners(balances, [
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", //usdc
        "0x6b175474e89094c44da98b954eedeac495271d0f", //dai
        "0x4fabb145d64652a948d72533023f6e7a623c7c53", //busd
        "0xdac17f958d2ee523a2206206994597c13d831ec7", //usdt
    ].map(t=>[t,false]), [rollupChain], block)
    return balances
}

module.exports={
    ethereum:{tvl}
}
'''
'''--- projects/lachain-yield-market.js ---
const utils = require('./helper/utils');

async function fetch() {
    const response = await utils.fetchURL(`https://farms-info.lachain.io/farms/beefy`); 
    var tvl_sum = 0;

    for (let i = 0; i < response.data.length; i++) {
        const f = response.data[i];
        tvl_sum += parseFloat(f['lachainTvl']);
    };

    return tvl_sum;
}

module.exports = {
  lachain: { fetch },
  fetch,
}

'''
'''--- projects/lachainBridge.js ---
const sdk = require("@defillama/sdk");
const { sumTokens } = require('./helper/unwrapLPs')
const { getChainTransform } = require('./helper/portedTokens')

const config = {
  polygon: {
    nativeBridge: ['0xE372D290F83c7487bdc925ddA187671bfF9e347b'], tokenBridge: ['0x82E4d5d7F36a22f2FEaaF87eCcDcDA7e0EFc98C3'], tokens: ['0xc2132D05D31c914a87C6611C10748AEb04B58e8F'],
  },
  bsc: {
    nativeBridge: ['0xC926f267418d69147c88Edf88e93E78F2153f923'], tokenBridge: ['0x6571DD15430a455118EC6e24Dc7820489ED7019b'], tokens: ['0x55d398326f99059fF775485246999027B3197955'],
  },
  ethereum: {
    nativeBridge: ['0xc7fc91a0a93d570738b2af6efb1595c3183809d7'], tokenBridge: ['0xAB49eb8Ca42f42fd7e8b745F2CC5BeDfb78d2D3E'], tokens: ['0xdAC17F958D2ee523a2206206994597C13D831ec7'],
  },
  avax: {
    nativeBridge: ['0xD4aE8F772dcf2e20b103c740AfD9D9f9E78dbfFC'], tokenBridge: ['0x8783256443217856B716464A068aabdecc3F0b95'], tokens: ['0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7'],
  },
  fantom: {
    nativeBridge: ['0x012cebA65fD071473a9E0d3C5048702734a1eE5e'], tokenBridge: ['0x73Ec53a1Ee3Ea275D95212b41Dcce8cb9e0206Cd'], tokens: ['0x049d68029688eabf473097a2fc38ef61633a3c7a'],
  },
  arbitrum: {
    nativeBridge: ['0xD4aE8F772dcf2e20b103c740AfD9D9f9E78dbfFC'], tokenBridge: ['0x43d92690D302C0e9f2fBD624eb9589F52b5AD115'], tokens: ['0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'],
  },
  harmony: {
    nativeBridge: ['0x0A19afbE4519A40Df3b48BE46EDc0720724B4A6B'], tokenBridge: ['0x5DDDc78C8a59CeD4d25a8FD96BF9D9FdA561D0FF'], tokens: ['0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f'],
  },
  heco: {
    nativeBridge: ['0xbBF0b12A0Be425Db284905A3Cb0Ab72b178b6A4F'], tokenBridge: ['0x334d6D6c5EaE4bf5ec7De39a1547e6bDBdDcfbf3'], tokens: ['0xa71edc38d189767582c38a3145b5873052c3e47a'],
  },
}

module.exports = {};

const nullAddress = "0x0000000000000000000000000000000000000000"

Object.keys(config).forEach(chain => {
  const { nativeBridge, tokenBridge, tokens} = config[chain]
  module.exports[chain] = {
    tvl: async (_, _block, { [chain]: block}) => {
      const balances = {}
      const transform = await getChainTransform(chain)
      const {output: balance} = await sdk.api.eth.getBalance({ target: nativeBridge[0], block, chain })
      sdk.util.sumSingleBalance(balances, transform(nullAddress), balance)
      const toa = tokenBridge.map(o => tokens.map(t => [t,o])).flat()
      return sumTokens(balances, toa, block, chain, transform)
    }
  }
})

'''
'''--- projects/ladex-exchange/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

const factory_contract = "0xD707d9038C1d976d3a01c770f01CB73a1fd305Cd"

const token_addresses = {
    "wUSDT": "0x32D2b9bBCf25525b8D7E92CBAB14Ca1a5f347B14",
    "wLA": "0x3a898D596840C6B6b586d722bFAdCC8c4761BF41",
    "wETH": "0x5ce9084e8ADa946AF09200c80fbAbCb1245E477F",
    "wMATIC": "0xC9AE905f288A3A3591CA7eee328eEd1568C14F32",
    "wBNB": "0x9483bDd8e088a2241f20F9241eFa3e3F6288ee20",
    "wAVAX": "0x690594910c2d58869d5F3FF205ebA1ff2A1B8245",
    "wFTM": "0x8c2E35a5825Ab407d2718402D15fFa8ec6D19acf",
    "wARBETH": "0x32DdEb2Cdd43eEF559d4B328cB14798E3C669215",
    "wHT": "0x20098F3A577fDb334FfBA2A128617664622eCBd6",
    "wONE": "0xC224866E0d39AC2d104Dd28F6398F3548ae0f318"
}

module.exports = {
    lachain: {
        tvl : calculateUsdUniTvl(factory_contract,
             "lachain",
              "0x3a898D596840C6B6b586d722bFAdCC8c4761BF41",
               [token_addresses['wUSDT'],
                token_addresses['wLA'],
                token_addresses['wETH'],
                token_addresses['wMATIC'],
                token_addresses['wBNB'],
                token_addresses['wAVAX'], 
                token_addresses['wFTM'],
                token_addresses['wARBETH'],
                token_addresses['wHT'],
                token_addresses['wONE']],
                "latoken")
    }
};

'''
'''--- projects/larix.js ---
const sdk = require("@defillama/sdk");
const { fetchURL } = require("./helper/utils");

const coingeckoMap = {
  USDT: 'tether',
  USDC: 'usd-coin',
  BTC: 'bitcoin',
  ETH: 'ethereum',
  SOL: 'solana',
  mSOL: 'solana',
  soFTT: 'ftx-token',
  SRM: 'serum',
  RAY: 'raydium',
  weWETH: 'ethereum',
  stSOL: 'solana',
  FTT: 'ftx-token',
  UST: 'terrausd',
  scnSOL: 'solana',
  JSOL: 'solana',
  FIDA: 'bonfida'
};

async function getTokenPrices() {
  const allApiIds = Object.values(coingeckoMap);
  const allTokens = allApiIds
    .filter((a,b) => a.indexOf(allApiIds) == a.lastIndexOf(b))
    .reduce((a, b) => a + '%2C' + b);
  
    const prices = (await fetchURL(
    `https://api.coingecko.com/api/v3/simple/price?ids=${allTokens}&vs_currencies=usd`
    )).data;
  
  return prices;
};

function tvl(borrowed) {
  return async () => {
    const balances = {};
    const markets = (await fetchURL('https://api.projectlarix.com/market')).data.detail;
    const tokenPrices = await getTokenPrices();

    const tokens = markets.filter(a => !a.mint_name.includes('-')).map(m => ({
      token: coingeckoMap[m.mint_name],
      usdValue: (borrowed ? m.borrow_value : m.available_value)
    }));
    for (let market of tokens) {
      const tokenQty = market.usdValue / tokenPrices[market.token].usd;
      sdk.util.sumSingleBalance(balances, market.token, tokenQty);
    };

    const lps = markets.filter(a => a.mint_name.includes('-')).map(m => ({
      token1: coingeckoMap[m.mint_name.substring(0, m.mint_name.indexOf('-'))],
      token2: coingeckoMap[m.mint_name.substring(m.mint_name.indexOf('-') + 1)],
      usdValue: (borrowed ? m.borrow_value : m.available_value)
    }));
    for (let market of lps) {
      const token1Qty = market.usdValue / (2 * tokenPrices[market.token1].usd);
      const token2Qty = market.usdValue / (2 * tokenPrices[market.token2].usd);
      sdk.util.sumSingleBalance(balances, market.token1, token1Qty);
      sdk.util.sumSingleBalance(balances, market.token2, token2Qty);
    };

    return balances;
  };
};

module.exports = {
  timetravel: false,
  solana: {
    tvl: tvl(),
    borrowed: tvl(true)
  }
}; // node test.js projects/larix.js 
'''
'''--- projects/laserswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  methodology: `Uses factory(0x23c7FA9A9f81B322684F25b8079e22C37e00b46b) address and whitelisted tokens address to find and price Liquidity Pool pairs`,
  thundercore: {
    tvl: calculateUsdUniTvl(
      "0x23c7FA9A9f81B322684F25b8079e22C37e00b46b",
      "thundercore",
      "0x413cEFeA29F2d07B8F2acFA69d92466B9535f717",
      [
        "0x4f3C8E20942461e2c3Bdd8311AC57B0c222f2b82",
        "0x22e89898A04eaf43379BeB70bf4E38b1faf8A31e",
        "0x6576Bb918709906DcbFDCeae4bB1e6df7C8a1077",
        "0xBEB0131D95AC3F03fd15894D0aDE5DBf7451d171",
        "0x47fe33d321EEF4719FdFf38EA72B1dFC7f0cdf10",
        "0x6E690DaC861fE7441770f84146F263d1CFBE909C",
        "0xfE146D5710015d4075355fb7bE8d133346EC63c2",
        "0x8EF1A1E0671Aa44852f4d87105eF482470bB3e69",
        "0xFd6Ec3E37F112bD30BbD726E7b0E73000CC2B98d",
        "0x0212b1f75503413b01a98158434c4570fb6e808c",
        "0x1F489E0282cFA883A4224C91309bC4D4c062ed93",
        "0xD441cD6eCfA027721B4d9ea5D9a6A9649ad8b3dA",
        "0xfF99e917cF1E081A4e52836bbE8DF610cbAb9DD7",
        "0x18fB0A62f207A2a082cA60aA78F47a1af4985190",
      ],
      "thunder-token"
    ),
  },
}

'''
'''--- projects/latte/index.js ---
// const utils = require('../helper/utils');
// const {toUSDTBalances} = require('../helper/balances');
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require("../helper/calculateUniTvl");

// const baseURL = 'https://api.latteswap.com/api'
// async function fetch() {
//   const totalTvl = await utils.fetchURL(`${baseURL}/v1/amm/defi-llama/tvl-exclude-latte`)
//   return Number(totalTvl.data)
// }

// async function staking() {
//   const latteTvl = await utils.fetchURL(`${baseURL}/v1/amm/defi-llama/tvl-latte-pool`)
//   return toUSDTBalances(Number(latteTvl.data))
// }

const factory = "0x4DcE5Bdb81B8D5EdB66cA1b8b2616A8E0Dd5f807";
const latteToken = "0x8D78C2ff1fB4FBA08c7691Dfeac7bB425a91c81A";
const lattev2Token = "0xa269A9942086f5F87930499dC8317ccC9dF2b6CB";
const masterchef = "0xbCeE0d15a4402C9Cc894D52cc5E9982F60C463d6";
const translate = {
  "0x8d78c2ff1fb4fba08c7691dfeac7bb425a91c81a":
    "bsc:0xa269a9942086f5f87930499dc8317ccc9df2b6cb", // LATTE to LATTEv2
};

async function tvl(timestamp, block, chainBlocks) {
  return await calculateUniTvl(
    (addr) => {
      if (translate[addr.toLowerCase()] !== undefined) {
        return translate[addr];
      }
      return `bsc:${addr}`;
    },
    chainBlocks.bsc,
    "bsc",
    factory,
    0,
    true
  );
}

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  let stakingBalances = (
    await sdk.api.abi.multiCall({
      calls: [
        {
          target: latteToken,
          params: masterchef,
        },
        {
          target: lattev2Token,
          params: masterchef,
        },
      ],
      abi: "erc20:balanceOf",
      block: chainBlocks.bsc,
      chain: "bsc",
    })
  ).output;
  stakingBalances.forEach((p) => {
    sdk.util.sumSingleBalance(balances, `bsc:${lattev2Token}`, p.output);
  });
  return balances;
}

module.exports = {
  bsc: {
    tvl,
    staking,
  },
};

'''
'''--- projects/lavafall/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0x04f9433A2CD21413Bc5641b84CaE0E40E86f9101"
const lavafall = "0x7A0Ac775d290A7a3016f153d757Fbc3c4De62488"
const lavafallFtmLP = "0xb58221b3c8eA491637e29f84D20bC95Bdd18D910"
const lavafallUsdcLP = "0x697B07a3c13D4fb23974ce56c353493AAF6bCaf1";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [lavafall, lavafallFtmLP, lavafallUsdcLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, lavafall, "fantom"),
      pool2: pool2Exports(chef, [lavafallFtmLP, lavafallUsdcLP], "fantom"),
  },
  
} 
'''
'''--- projects/leaguedao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const leag = "0x7b39917f9562C8Bc83c7a6c2950FF571375D505D";
const stakingContract = "0x67F60dA0F409AB8427e8a408efc4B137D0BD4e7B";
const yieldFarmStakingContract = "0x43921eb2E5C78D9e887d3Ecd4620a3Bd606f4F95";

//Tokens in Yield Farm Contract
const link = "0x514910771af9ca656af840dff83e8264ecf986ca";
const snx = "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f";
const ilv = "0x767fe9edc9e0df98e07454847909b5e959d7ca0e";
const sushi = "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2";
const bond = "0x0391D2021f89DC339F60Fff84546EA23E337750f";
const xyz = "0x618679df9efcd19694bb1daa8d00718eacfa2883";
const ionx = "0x02d3a27ac3f55d5d91fb0f52759842696a864217";
const entr = "0xd779eea9936b4e323cddff2529eb6f13d0a4d66e";
const leagUsdc = "0x4708713b4b6bd32e41bcb2f9c5901d74fedba447";

module.exports = {
  ...ohmTvl(
    yieldFarmStakingContract,
    [
      [link, false],
      [snx, false],
      [ilv, false],
      [sushi, false],
      [bond, false],
      [xyz, false],
      [ionx, false],
      [entr, false],
      [leagUsdc, true],
    ],
    "ethereum",
    stakingContract,
    leag
  ),
};

'''
'''--- projects/lemonswap/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const token = "0x9477477CdDC4A05419A402A9754725Bc9Ee6a40e"
const masterchef = "0xD2C91aA7ffAb4CE218f7F6fc9AED7029A57C4B97";

module.exports = {
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/lemuriafinance.js ---
const utils = require("./helper/utils");
 var chainId;
 var vault;

 async function fetch() {
   const response = await utils.fetchURL("https://api.lemuria.finance/tvl");

   let tvl = 0;
   for (chainId in response.data) {
     const chain = response.data[chainId];

     for (vault in chain) {
       tvl += chain[vault];
     }
   }

   return tvl;
 }

 module.exports = {
   methodology:
     'TVL data is pulled from the Lemuria Financial API "https://api.lemuria.finance/tvl".',
   milkomeda: {
     fetch
   },
   fetch,
 };

'''
'''--- projects/lendflare/convexBooster.js ---
const sdk = require('@defillama/sdk');
const BN = require("bignumber.js");
const utils = require('./utils.js');

const CONVEX_BOOSTER_PROXY = `0x4C3c78cEbc9Cc87436dEEd2782998bC002F2B69f`;

const convexPools = {
    // 3pool
    1: { lpToken: "0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490", virtualBalance: "0x51CeC58171863ea82cE3B99A190f3843FE7AAbF5", coinId: 2, coinName: "tether", decimals: 6 },
    // sbtc
    2: { lpToken: "0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3", virtualBalance: "0x85b7cc4Fd8767651c752D9ea76fC7dd388e391a0", coinId: 1, coinName: "wrapped-bitcoin", decimals: 8 },
    // ren
    3: { lpToken: "0x49849C98ae39Fff122806C06791Fa73784FB3675", virtualBalance: "0x2D3a0EcA75C429b00627af759a14223c34bF910F", coinId: 1, coinName: "wrapped-bitcoin", decimals: 8 },
    // hbtc
    4: { lpToken: "0xb19059ebb43466C323583928285a49f558E572Fd", virtualBalance: "0x99b496D54848f2a98C4aA0B934f23B0f5c298E31", coinId: 1, coinName: "wrapped-bitcoin", decimals: 8 },
    // seth
    5: { lpToken: "0xA3D87FffcE63B53E0d54fAa1cc983B7eB0b74A9c", virtualBalance: "0x247b24e945d604C896165cCb2F15e190560f2133", coinId: 0, coinName: "ethereum", decimals: 18 },
    // steth
    6: { lpToken: "0x06325440D014e39736583c165C2963BA99fAf14E", virtualBalance: "0xc0E4F5758E218762960bca9706fC7b6Cf337E3c2", coinId: 0, coinName: "ethereum", decimals: 18 },
    // ankreth
    7: { lpToken: "0xaA17A236F2bAdc98DDc0Cf999AbB47D47Fc0A6Cf", virtualBalance: "0x86CA9713762c04E10d2E2057952B91917DC650f2", coinId: 0, coinName: "ethereum", decimals: 18 },
    // reth
    8: { lpToken: "0x53a901d48795C58f485cBB38df08FA96a24669D5", virtualBalance: "0xCCBc7Fcc994Db1D8F5FFF17104532c0e0E78b449", coinId: 0, coinName: "ethereum", decimals: 18 },
    // susd
    9: { lpToken: "0xC25a3A3b969415c80451098fa907EC722572917F", virtualBalance: "0x518802D8764c2823610a619bE95BF089AA121BA5", coinId: 2, coinName: "tether", decimals: 6 },
    // mim
    10: { lpToken: "0x5a6A4D54456819380173272A5E8E9B9904BdF41B", virtualBalance: "0xa91d85B2E9fE1F0371559a9a7DcB1BbE1AcF9587", coinId: 3, coinName: "tether", decimals: 6 },
    // frax
    11: { lpToken: "0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B", virtualBalance: "0x86b26838f03C3724cB9a9D4d165df052c401a257", coinId: 3, coinName: "tether", decimals: 6 },
    // musd
    12: { lpToken: "0x1AEf73d49Dedc4b1778d0706583995958Dc862e6", virtualBalance: "0xEAE58fd59225A192eD897C3C8B382727dc322335", coinId: 3, coinName: "tether", decimals: 6 },
    // ust
    13: { lpToken: "0x94e131324b6054c0D789b190b2dAC504e4361b53", virtualBalance: "0x8856738191DcF0B582e491beA99e880aB734F4e6", coinId: 3, coinName: "tether", decimals: 6 },
    // lusd
    14: { lpToken: "0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA", virtualBalance: "0x2Cb79C6BB40346A08ad7A7baf65a8b4315876E26", coinId: 3, coinName: "tether", decimals: 6 },
    // alUSD
    15: { lpToken: "0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c", virtualBalance: "0x6F114A680915b3335c65225b7f61e2021419b24B", coinId: 3, coinName: "tether", decimals: 6 },
    // gusd
    16: { lpToken: "0xD2967f45c4f384DEEa880F807Be904762a3DeA07", virtualBalance: "0x0e44e003cA8B7A2dD0742286FC1a3FaD754a5450", coinId: 3, coinName: "tether", decimals: 6 },
    // usdn
    17: { lpToken: "0x4f3E8F405CF5aFC05D68142F3783bDfE13811522", virtualBalance: "0xa16D36ea387AEE0f625425ADa2540D1A95Dc2440", coinId: 3, coinName: "tether", decimals: 6 },
    // usdk
    18: { lpToken: "0x97E2768e8E73511cA874545DC5Ff8067eB19B787", virtualBalance: "0x83Ec519B6121eA1B6ae05177e7e9f9c046A5Fe20", coinId: 3, coinName: "tether", decimals: 6 },
    // busd
    19: { lpToken: "0x4807862AA8b2bF68830e4C8dc86D0e9A998e085a", virtualBalance: "0x8f48eB0d8C298abbc68Be5deCe86c6fAa4e33497", coinId: 3, coinName: "tether", decimals: 6 },
    // husd
    20: { lpToken: "0x5B5CFE992AdAC0C9D48E05854B2d91C73a003858", virtualBalance: "0x7fB09845695F6Bd88f4A0752e6a539a2209B6707", coinId: 3, coinName: "tether", decimals: 6 },
    // rsv
    21: { lpToken: "0xC2Ee6b0334C261ED60C72f6054450b61B8f18E35", virtualBalance: "0x83d6e9bA460130D82194620Ca0b16D025064d139", coinId: 3, coinName: "tether", decimals: 6 },
    // dusd
    22: { lpToken: "0x3a664Ab939FD8482048609f652f9a0B0677337B9", virtualBalance: "0x7538345c421467a2A58Cbe9FA3DfbDEb6Fb2C15a", coinId: 3, coinName: "tether", decimals: 6 },
    // usdp
    23: { lpToken: "0x7Eb40E450b9655f4B3cC4259BCC731c63ff55ae6", virtualBalance: "0xd8252a4EC16de33fAd1C69f2d3E80E9F7b8ceF12", coinId: 3, coinName: "tether", decimals: 6 },
    // obtc
    24: { lpToken: "0x2fE94ea3d5d4a175184081439753DE15AeF9d614", virtualBalance: "0x47A2eec0D7502Ba1FEc0cAe0eeafF64DCf28af60", coinId: 2, coinName: "wrapped-bitcoin", decimals: 8 },
    // bbtc
    25: { lpToken: "0x410e3E86ef427e30B9235497143881f717d93c2A", virtualBalance: "0xE1C0b5302E5a627141746ACB1025c43f9FE87ca8", coinId: 2, coinName: "wrapped-bitcoin", decimals: 8 },
    // tbtc
    26: { lpToken: "0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd", virtualBalance: "0x1ACc3ffb27c31C541695Ff75b21569CfaeDCA877", coinId: 2, coinName: "wrapped-bitcoin", decimals: 8 },
    // pbtc
    27: { lpToken: "0xDE5331AC4B3630f94853Ff322B66407e0D6331E8", virtualBalance: "0x0D66b49A68AffdDcDaDDdfE06CD6369307B2BA46", coinId: 2, coinName: "wrapped-bitcoin", decimals: 8 }
}

async function getTotalSupply(pools, timestamp, block, chainBlocks) {
    const output = (await sdk.api.abi.multiCall({
        block: chainBlocks.ethereum,
        chain: "ethereum",
        abi: 'erc20:totalSupply',
        calls: Object.keys(pools).map((pid, _) => {
            return {
                target: pools[pid].virtualBalance
            }
        })
    })).output.map((result, i) => {
        for (let pid of Object.keys(pools)) {
            if (pools[pid].virtualBalance == result.input.target) {
                pools[pid].totalSupply = (new BN(result.output));
                pools[pid].totalSupplyString = result.output;
            }
        }
    });

    return pools;
}

async function calculateTokenAmount(pools, timestamp, block, chainBlocks) {
    for (let pid of Object.keys(pools)) {
        await sdk.api.abi.call({
            block: chainBlocks.ethereum,
            chain: "ethereum",
            abi: { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }, { "internalType": "uint256", "name": "_tokens", "type": "uint256" }, { "internalType": "int128", "name": "_curveCoinId", "type": "int128" }], "name": "calculateTokenAmount", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            target: CONVEX_BOOSTER_PROXY,
            params: [pid, pools[pid].totalSupplyString, pools[pid].coinId]
        }).then(result => {
            pools[pid].calculateTokenAmount = new BN(result.output);
        }).catch(error => {
            pools[pid].calculateTokenAmount = new BN(0);
        });
    }

    return pools;
}

async function tvl(timestamp, block, chainBlocks) {
    let tvl = new BN(0);

    const pools = await getTotalSupply(convexPools, timestamp, block, chainBlocks).then(pools => {
        return calculateTokenAmount(pools, timestamp, block, chainBlocks);
    });
    const prices = await utils.getPricesfromString().then(result => {
        return result.data;
    });

    Object.keys(pools).map((pid, _) => {
        if (convexPools[pid].calculateTokenAmount.isGreaterThan(new BN(0))) {
            convexPools[pid].calculateTokenAmount = convexPools[pid].calculateTokenAmount.dividedBy(10 ** convexPools[pid].decimals);
        }

        convexPools[pid].tvl = convexPools[pid].calculateTokenAmount.multipliedBy(new BN(prices[convexPools[pid].coinName].usd));

        tvl = tvl.plus(convexPools[pid].tvl);
    });

    return tvl;
}

module.exports = {
    tvl
};

'''
'''--- projects/lendflare/index.js ---
const convexBooster = require('./convexBooster.js');
const supplyBooster = require('./supplyBooster.js');
const { toUSDTBalances } = require('./utils.js');

async function tvl(timestamp, block, chainBlocks) {
    const borrow = await convexBooster.tvl(timestamp, block, chainBlocks);
    const supply = await supplyBooster.tvl(timestamp, block, chainBlocks);

    console.log(`borrow ${borrow.toString()}`);
    console.log(`supply ${supply.toString()}`);

    return toUSDTBalances(borrow.plus(supply));
}

module.exports = {
    timetravel: true,
    ethereum: {
        tvl,
    }
};

'''
'''--- projects/lendflare/supplyBooster.js ---
const sdk = require('@defillama/sdk');
const BN = require("bignumber.js");
const utils = require('./utils.js');

const supplyPools = [
    // usdc
    { virtualBalance: "0x10A377BA353cd480E43800018a27742054904c1a", decimals: 6, coinName: "usd-coin" },
    // dai
    { virtualBalance: "0x2FbE41e4861B5d0936AA01bB32bd3402d34f11fA", decimals: 18, coinName: "dai" },
    // wbtc
    { virtualBalance: "0xcc29655C9F9A211fb11c25D905306aa93a685ef3", decimals: 8, coinName: "wrapped-bitcoin" },
    // eth
    { virtualBalance: "0x6d18E830A938F0eAF206f1BD80b79a851E5f37A3", decimals: 18, coinName: "ethereum" },
]

async function getTotalSupply(pools, timestamp, block, chainBlocks) {
    const output = (await sdk.api.abi.multiCall({
        block: chainBlocks.ethereum,
        chain: "ethereum",
        abi: 'erc20:totalSupply',
        calls: pools.map((pool, i) => {
            return {
                target: pool.virtualBalance
            }
        })
    })).output.map((result, i) => {
        for (let p of pools) {
            if (p.virtualBalance == result.input.target) {
                p.totalSupply = (new BN(result.output));
                p.totalSupplyString = p.totalSupply.toString();
            }
        }
    });

    return pools;
}

async function tvl(timestamp, block, chainBlocks) {
    let tvl = new BN(0);

    const pools = await getTotalSupply(supplyPools, timestamp, block, chainBlocks);
    const prices = await utils.getPricesfromString().then(result => {
        return result.data;
    });

    for (let pool of pools) {
        pool.tvl = pool.totalSupply.dividedBy(10 ** pool.decimals).multipliedBy(new BN(prices[pool.coinName].usd));

        tvl = tvl.plus(pool.tvl);
    };

    return tvl;
}

module.exports = {
    tvl
};

'''
'''--- projects/lendflare/utils.js ---
const { toUSDTBalances } = require('../helper/balances')
const utils = require("../helper/utils");

const COINS_LIST = `dai,bitcoin,ethereum,wrapped-bitcoin,frax,usd-coin,tether,fei-usd,true-usd,maker`;

function format(pools) {
    return pools.map((pool) => {
        return pool.output;
    })
}

async function getPricesfromString() {
    return utils.getPricesfromString(COINS_LIST)
}

module.exports = {
    toUSDTBalances,
    format,
    getPricesfromString
};

'''
'''--- projects/lendhub/abi.json ---
{
	"getAllMarkets": {
		"constant": true,
		"inputs": [],
		"name": "getAllMarkets",
		"outputs": [
			{
				"internalType": "contract CToken[]",
				"name": "",
				"type": "address[]"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	"underlying": {
		"constant": true,
		"inputs": [],
		"name": "underlying",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	"getCash": {
		"constant": true,
		"inputs": [],
		"name": "getCash",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	"valtToken": {
		"inputs": [],
		"name": "token",
		"outputs": [
			{
				"internalType": "contract IERC20",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	"totalBorrows": {
		"constant": true,
		"inputs": [],
		"name": "totalBorrows",
		"outputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	}
}
'''
'''--- projects/lendhub/index.js ---

const sdk = require('@defillama/sdk');
const cAbis = require('./abi.json');
const { getChainTransform } = require('../helper/portedTokens')
const { unwrapLPsAuto } = require('../helper/unwrapLPs')

const comptroller = "0x6537d6307ca40231939985BCF7D83096Dd1B4C09";
const chain = "heco";

async function getAllCTokens(block) {
  return (await sdk.api.abi.call({
    block,
    chain,
    target: comptroller,
    abi: cAbis['getAllMarkets'],
  })).output;
}

async function getMarkets(block) {
  let allCTokens = await getAllCTokens(block);
  const markets = []
  const calls = []
  for (const cToken of allCTokens) {
    if (cToken.toLowerCase() === '0x99a2114B282acC9dd25804782ACb4D3a2b1Ad215'.toLowerCase())
      markets.push({ cToken, underlying: '0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f' })
    else
      calls.push({ target: cToken })
  }
  const { output: underlyings } = await sdk.api.abi.multiCall({
    abi: cAbis['underlying'],
    calls,
    chain, block,
  })
  underlyings.forEach(({ output, input }) => markets.push({ cToken: input.target, underlying: output.toLowerCase() }))
  return markets;
}

function tvl(borrowed) {
  return async (_, _b, { [chain]: block }) => {
    let balances = {};
    let markets = await getMarkets(block)
    const transformAddress = await getChainTransform(chain)
    let { output: cashInfo} = await sdk.api.abi.multiCall({
      calls: markets.map((market) => ({
        target: market.cToken,
      })),
      chain, block,
      abi: borrowed ? cAbis.totalBorrows : cAbis['getCash'],
      requery: true,
    })

    const { output: symbols } = await sdk.api.abi.multiCall({
      calls: markets.map((market) => ({
        target: market.underlying,
      })),
      chain, block,
      abi: "erc20:symbol",
    })

    const symbolCalls = symbols.filter(({ output }) => output.toLowerCase().includes('lfHMDX'.toLowerCase())).map(i => ({ target: i.input.target }))
    const { output: sTransform } = await sdk.api.abi.multiCall({
      abi: cAbis['valtToken'],
      calls: symbolCalls,
      chain, block,
    });

    const transformMapping = {}
    sTransform.forEach(i => transformMapping[i.input.target] = i.output)
    markets.forEach(({ underlying}, idx) => {
      const balance = cashInfo[idx].output
      let label = transformAddress(transformMapping[underlying] ? transformMapping[underlying] : underlying)
      sdk.util.sumSingleBalance(balances, label, balance)
    })

    await unwrapLPsAuto({ balances, block, chain, transformAddress, })
    return balances;
  }
}

module.exports = {
  timetravel: false,
  heco: {
    tvl: tvl(false),
    borrowed: tvl(true),
  }
};
'''
'''--- projects/lendingpond/index.js ---
const { PromisePool } = require('@supercharge/promise-pool')
const { getAddressesUTXOs, getTxsMetadata } = require("../helper/cardano/blockfrost")

const scriptAddress = "addr1wxwrp3hhg8xdddx7ecg6el2s2dj6h2c5g582yg2yxhupyns8feg4m"

const tvl = async () => {

    const utxos = await getAddressesUTXOs(scriptAddress)
    let totalLovelaceLocked = 0
    
    await PromisePool
        .for(utxos)
        .withConcurrency(10)
        .process( async (utxo) => {

        const metadata = await getTxsMetadata(utxo.tx_hash)
        totalLovelaceLocked += metadata.reduce((p, c) => {
            let v = 0
            if (c.label == 1) { // all loans have label == 1
                v = parseInt(c?.json_metadata?.Listing?.Principal)
            }
            return p + v
        }, 0)
    })

    return {
        cardano: totalLovelaceLocked / 1e6,
    }
}

module.exports = {
    timetravel: false,
    cardano: {
      tvl,
    },
}
'''
'''--- projects/leonicornswap/index.js ---
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require("../helper/calculateUniTvl");

const leos = "0x2c8368f8F474Ed9aF49b87eAc77061BEb986c2f1";
const leon = "0x27E873bee690C8E161813DE3566E9E18a64b0381";
const factory = "0xEB10f4Fe2A57383215646b4aC0Da70F8EDc69D4F";
const masterchef = "0x72F8fE2489A4d480957d5dF9924166e7a8DDaBBf";

async function tvl(timestamp, block, chainBlocks) {
    return await calculateUniTvl(addr=>`bsc:${addr}`, chainBlocks.bsc, "bsc", factory, 0, true);
}

async function staking(timestamp, block, chainBlocks) {
    let balances = {};
    let stakingBalance = (await sdk.api.abi.multiCall({
        calls: [
            {
                target: leos,
                params: masterchef
            },
            {
                target: leon,
                params: masterchef
            }
        ],
        abi: "erc20:balanceOf",
        block: chainBlocks.bsc,
        chain: "bsc"
    })).output;
    stakingBalance.forEach(p => {
        sdk.util.sumSingleBalance(balances, `bsc:${p.input.target}`, p.output);
    })
    return balances;
}

module.exports = {
    bsc: {
        tvl,
        staking
    },
}
'''
'''--- projects/levinswap/index.js ---
const { calculateUniTvl } = require("../helper/calculateUniTvl");
const { staking } = require("../helper/staking");

const factory = "0x965769C9CeA8A7667246058504dcdcDb1E2975A5";
const levin = "0x1698cD22278ef6E7c0DF45a8dEA72EDbeA9E42aa";
const xlevin = "0xafa57Fb9d8D63Ff8124E17c1495C73bc3a7678D0";

async function tvl (timestamp, block, chainBlocks) {
  return await calculateUniTvl(addr=>`xdai:${addr}`, chainBlocks.xdai, "xdai", factory, 0, true);
}

module.exports = {
  xdai: {
    tvl,
    staking: staking(xlevin, levin, "xdai")
  }
}
'''
'''--- projects/libero/index.js ---
const sdk = require("@defillama/sdk");
const { getBlock } = require("../helper/getBlock");
const owner = "0xb2b11D8DA4cd9c20410de6EB55BAD2734983040E";
const target = "0x0DFCb45EAE071B3b846E220560Bbcdd958414d78";

async function staking(timestamp, block, chainBlocks) {
  block = await getBlock(timestamp, "bsc", chainBlocks);
  return {
    [`bsc:${target}`]: (
      await sdk.api.erc20.balanceOf({
        target,
        owner,
        block,
        chain: "bsc",
      })
    ).output,
  };
}

module.exports = {
    bsc: {
        tvl: () => ({}),
        staking,
      },
    methodology: "We count all LIBERO deposited into LIBERO BANK, which has been locked by users in exchange for xLIBERO",
};
'''
'''--- projects/lido/Lido.js ---
class Lido {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class SeedRange {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class Validator {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class PubKeyAndEntry {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class PubKeyAndEntryMaintainer {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class RewardDistribution {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class FeeRecipients {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class Validators {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class Maintainers {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class ExchangeRate {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class Metrics {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class LamportsHistogram {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  class WithdrawMetric {
    constructor(data) {
      Object.assign(this, data);
    }
  }
  
  const schema = new Map([
    [
      ExchangeRate,
      {
        kind: 'struct',
        fields: [
          ['computed_in_epoch', 'u64'],
          ['st_sol_supply', 'u64'],
          ['sol_balance', 'u64'],
        ],
      },
    ],
    [
      LamportsHistogram,
      {
        kind: 'struct',
        fields: [
          ['counts1', 'u64'],
          ['counts2', 'u64'],
          ['counts3', 'u64'],
          ['counts4', 'u64'],
          ['counts5', 'u64'],
          ['counts6', 'u64'],
          ['counts7', 'u64'],
          ['counts8', 'u64'],
          ['counts9', 'u64'],
          ['counts10', 'u64'],
          ['counts11', 'u64'],
          ['counts12', 'u64'],
          ['total', 'u64'],
        ],
      },
    ],
    [
      WithdrawMetric,
      {
        kind: 'struct',
        fields: [
          ['total_st_sol_amount', 'u64'],
          ['total_sol_amount', 'u64'],
          ['count', 'u64'],
        ],
      },
    ],
    [
      Metrics,
      {
        kind: 'struct',
        fields: [
          ['fee_treasury_sol_total', 'u64'],
          ['fee_validation_sol_total', 'u64'],
          ['fee_developer_sol_total', 'u64'],
          ['st_sol_appreciation_sol_total', 'u64'],
          ['fee_treasury_st_sol_total', 'u64'],
          ['fee_validation_st_sol_total', 'u64'],
          ['fee_developer_st_sol_total', 'u64'],
          ['deposit_amount', LamportsHistogram],
          ['withdraw_amount', WithdrawMetric],
        ],
      },
    ],
    [
      SeedRange,
      {
        kind: 'struct',
        fields: [
          ['begin', 'u64'],
          ['end', 'u64'],
        ],
      },
    ],
    [
      Validator,
      {
        kind: 'struct',
        fields: [
          ['fee_credit', 'u64'],
          ['fee_address', 'u256'],
          ['stake_seeds', SeedRange],
          ['unstake_seeds', SeedRange],
          ['stake_accounts_balance', 'u64'],
          ['unstake_accounts_balance', 'u64'],
          ['active', 'u8'],
        ],
      },
    ],
    [
      PubKeyAndEntry,
      {
        kind: 'struct',
        fields: [
          ['pubkey', 'u256'],
          ['entry', Validator],
        ],
      },
    ],
    [
      PubKeyAndEntryMaintainer,
      {
        kind: 'struct',
        fields: [
          ['pubkey', 'u256'],
          ['entry', [0]],
        ],
      },
    ],
    [
      RewardDistribution,
      {
        kind: 'struct',
        fields: [
          ['treasury_fee', 'u32'],
          ['validation_fee', 'u32'],
          ['developer_fee', 'u32'],
          ['st_sol_appreciation', 'u32'],
        ],
      },
    ],
    [
      FeeRecipients,
      {
        kind: 'struct',
        fields: [
          ['treasury_account', 'u256'],
          ['developer_account', 'u256'],
        ],
      },
    ],
    [
      Validators,
      {
        kind: 'struct',
        fields: [
          ['entries', [PubKeyAndEntry]],
          ['maximum_entries', 'u32'],
        ],
      },
    ],
    [
      Maintainers,
      {
        kind: 'struct',
        fields: [
          ['entries', [PubKeyAndEntryMaintainer]],
          ['maximum_entries', 'u32'],
        ],
      },
    ],
    [
      Lido,
      {
        kind: 'struct',
        fields: [
          ['lido_version', 'u8'],
  
          ['manager', 'u256'],
  
          ['st_sol_mint', 'u256'],
  
          ['exchange_rate', ExchangeRate],
  
          ['sol_reserve_authority_bump_seed', 'u8'],
          ['stake_authority_bump_seed', 'u8'],
          ['mint_authority_bump_seed', 'u8'],
          ['rewards_withdraw_authority_bump_seed', 'u8'],
  
          ['reward_distribution', RewardDistribution],
  
          ['fee_recipients', FeeRecipients],
  
          ['metrics', Metrics],
  
          ['validators', Validators],
  
          ['maintainers', Maintainers],
        ],
      },
    ],
  ]);

module.exports = {
    Lido,
    schema
}
'''
'''--- projects/lido/abis.json ---
[
    {
        "constant": true,
        "inputs": [],
        "name": "getTotalPooledEther",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
]
'''
'''--- projects/lido/index.js ---
const axios = require('axios');
const abis = require('./abis.json')
const sdk = require('@defillama/sdk')
const sol = require('./sol-helpers');
const { getBlock } = require('../helper/getBlock');
const { getConnection } = require('../helper/solana');

const ethContract = '0xae7ab96520de3a18e5e111b5eaab095312d7fe84';

async function terra(timestamp, ethBlock, chainBlocks) {
  /*
  const { block } = await sdk.api.util.lookupBlock(timestamp, {
    chain: 'terra'
  })
  const { total_bond_amount } = (
    await axios.get(`https://lcd.terra.dev/wasm/contracts/terra1mtwph2juhj0rvjz7dy92gvl6xvukaxu8rfv8ts/store?query_msg=%7B%22state%22%3A%20%7B%7D%7D&height=${block - (block % 100)}`) // Node is semi-pruned, only every 100th block is stored
  ).data.result;
  */
  const { total_bond_amount } = (
    await axios.get(`https://lcd.terra.dev/wasm/contracts/terra1mtwph2juhj0rvjz7dy92gvl6xvukaxu8rfv8ts/store?query_msg=%7B%22state%22%3A%20%7B%7D%7D`)
  ).data.result;
  return {
    'terra-luna': total_bond_amount / 1000000
  }
}

async function eth(timestamp, ethBlock, chainBlocks) {
  const pooledETH = await sdk.api.abi.call({
    block: ethBlock,
    target: ethContract,
    abi: abis.find(abi => abi.name === "getTotalPooledEther")
  })

  const pooledMatic = await sdk.api.abi.call({
    block: ethBlock,
    target: "0x9ee91F9f426fA633d227f7a9b000E28b9dfd8599",
    abi: {"inputs":[],"name":"getTotalPooledMatic","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
  })

  return {
    '0x0000000000000000000000000000000000000000': pooledETH.output,
    "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0": pooledMatic.output,
  }
}

async function ksm(timestamp, ethBlock, chainBlocks) {
  const chain = "moonriver"
  const block = await getBlock(timestamp, chain, chainBlocks, true)
  const pooledCoin = await sdk.api.abi.call({
    block,
    chain,
    target: "0xffc7780c34b450d917d557e728f033033cb4fa8c",
    abi: {"inputs":[],"name":"getTotalPooledKSM","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
  })

  return {
    'kusama': Number(pooledCoin.output)/1e12,
  }
}

async function solana(timestamp, ethBlock, chainBlocks) {
  const connection = getConnection()
  const validatorsBalance = await sol.retrieveValidatorsBalance(connection)
  const reserveAccountBalance = await sol.retrieveReserveAccountBalance(connection)

  const totalSolInLamports = validatorsBalance + reserveAccountBalance;
  return {
    'solana': totalSolInLamports/1e9
  }
}

module.exports = {
  hallmarks: [
    [1651881600,"UST depeg"]
  ],
  methodology: 'Staked tokens are counted as TVL based on the chain that they are staked on and where the liquidity tokens are issued, stMATIC is counted as Ethereum TVL since MATIC is staked in Ethereum and the liquidity token is also issued on Ethereum',
  timetravel: false, // solana
  doublecounted: true,
  solana: {
    tvl: solana
  },
  ethereum: {
    tvl: eth
  },
  terra: {
    tvl: terra
  },
  moonriver:{
    tvl: ksm
  },
}

'''
'''--- projects/lido/sol-helpers.js ---
const { Connection, PublicKey } = require('@solana/web3.js');
const { deserializeUnchecked } = require('borsh');
const { Lido, schema } = require('./Lido')

const SOLIDO_ADDRESS = "49Yi1TKkNyYjPAFdR9LBvoHcUjuPX4Df5T5yv39w2XTn";
const RESERVE_ACCOUNT_ADDRESS = "3Kwv3pEAuoe4WevPB4rgMBTZndGDb53XT7qwQKnvHPfX";

async function retrieveValidatorsBalance(connection) {
  const accountInfo = await connection.getAccountInfo(new PublicKey(SOLIDO_ADDRESS));
  const deserializedAccountInfo = deserializeUnchecked(
    schema,
    Lido,
    accountInfo.data,
  );
  return deserializedAccountInfo.validators.entries
    .map(pubKeyAndEntry => pubKeyAndEntry.entry)
    .map(validator => validator.stake_accounts_balance.toNumber())
    .reduce((prev, current) => prev + current, 0)
}

async function retrieveReserveAccountBalance(connection) {
  const accountInfo = await connection.getAccountInfo(new PublicKey(RESERVE_ACCOUNT_ADDRESS));
  const rent = await connection.getMinimumBalanceForRentExemption(accountInfo.data.byteLength);
  return accountInfo.lamports - rent;
}

module.exports = {
  retrieveValidatorsBalance,
  retrieveReserveAccountBalance
}
'''
'''--- projects/lien/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const contracts = [
  "0xE446158503d0F5c70579FCCE774C00E8Db544559", // aggregator1
  "0x5F3b6405dfcF8b21f8dEB4eb6DA44a89a652aCb0", // aggregator2
  "0xCc96397Cb86f98759BdbbF31802b366E7251F350", // aggregator3
  "0xDA6FC5625E617bB92F5359921D43321cEbC6BEf0", // bondmaker
  "0x2f84206b5ED3Eb855C886414f3905115DD166614", // GDOTC
  "0xaB37e1358b639Fd877f015027Bb62d3ddAa7557E", // Lien Token
  "0x54ea75daf8f0c71ef5ac918bd2eda4448e814925", // reserve1
  "0xca18201c57370df5684b7cbad9b1b886e03f198f", // reserve2
  "0x9f6ff467fd6ca8832d9e0eff95c34f4939e7becb", // reserve3
];
async function tvl(timestamp, block) {
  let ethBalances = await sdk.api.eth.getBalances({
    targets: contracts,
    block: block,
  });
  let balance = new BigNumber(0);
  ethBalances.output.forEach((ethBalance) => {
    balance = balance.plus(ethBalance.balance);
  });
  return { [ZERO_ADDRESS]: balance.toFixed() };
}

module.exports = {
  start: 1619798400, // 30/4/2021 @ 04:00PM (UTC)
  ethereum: { tvl }
};

'''
'''--- projects/life/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const chef = "0xa4Faa5774681AaccE968d5EC7Ff3C3eD0F7ABbEe"
const life = "0x8877E4B70C50CF275C2B77d6a0F69a312F5eE236"

module.exports = {
  ...masterChefExports(chef, "fantom", life, false),
} // node test.js projects/life/index.js
'''
'''--- projects/lifedao/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0x1e63a2eB2827db56d3CB1e1FF17ef1040B2d3D3f"
module.exports = ohmTvl(treasury, [
    //MIM
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false],
    //wAVAX
    ["0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7", false],
    //joe LP 
    ["0xd7cdc2e47ab29a6b651704e39374bb9857f02e02", true],
    //joe LP 
    ["0xdf9abadd06101e4e52128db30b055a7aa78b3537", true],
   ], "avax", "0x3C09c500829D09AfEA7575005fcAFBacFcde6902", "0x5684a087C739A2e845F4AaAaBf4FBd261edc2bE8")
'''
'''--- projects/lightning-network/index.js ---
const axios = require("axios");

const dayHistory = {};

async function GetDailyHistory() {
  let { data } = await axios.get('https://bitcoinvisuals.com/static/data/data_daily.csv');
  data = parseCSV(data);

  data.forEach((row) => {
    if (!row.capacity_total) return;
    dayHistory[row.day] = row.capacity_total;
  });
}

async function get1MLCapacity() {
  try {
    const { data } = await axios.get('https://1ml.com/statistics?json=true')
    return data.networkcapacity / 1e8
  } catch (e) {
    console.error(e)
    return getFromTxStat()
  }
}

async function getFromTxStat() {
  const { data } = await axios.get('https://txstats.com/api/datasources/proxy/1/query?db=p2shinfo&q=SELECT%20last(%22value%22)%20%20%2F%20100000000%20FROM%20%22ln_stats%22%20WHERE%20time%20%3E%3D%20now()%20-%201d%20GROUP%20BY%20time(6h)%20fill(null)&epoch=ms')
  return data.results[0].series[0].values.pop()[1]
}

async function getChannelCapacity(timestamp) {
  const day = new Date(timestamp * 1000).toISOString().slice(0,10)
  return dayHistory[day]
}

async function tvl(timestamp) {
  const getCurrentTVL = (Date.now() / 1000 - timestamp) < 24 * 3600 // if the time difference is under 24 hours i.e we are not refilling old data
  let channelCapacity

  if (getCurrentTVL) {
    channelCapacity = await get1MLCapacity()
  } else {
    await GetDailyHistory();
    channelCapacity = await getChannelCapacity(timestamp)
  }

  // if none of our scrape targets worked then throw an error
  if (channelCapacity == null)
    throw "Unable to determine LN channel capacity."

  return {
    bitcoin: channelCapacity
  }
}

module.exports = {
  start: 1516406400,
  bitcoin: { tvl },
};

function parseCSV(csvData) {
  csvData = csvData.replaceAll('\r', '').split('\n').map(i => i.split(','))
  const headers = csvData.shift()
  return csvData.map(row => toObject(headers, row))
}

function toObject(keys, values) {
  const res = {}
  keys.forEach((key, i) => {
    res[key] = values[i]
  })
  return res
}
'''
'''--- projects/linear.js ---
const { call } = require('./helper/near')

async function tvl() {
    return { 
      near: (await call(
        'linear-protocol.near', 
        'get_total_staked_balance', 
        {}
      ) / 1e24 )
    };
};

module.exports = {
  near: {
    tvl
  },
  timetravel: false,
};
'''
'''--- projects/linear/abis.json ---
{
  "totalLockedAmount": {
    "inputs": [],
    "name": "totalLockedAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalStakeAmount": {
    "inputs": [],
    "name": "totalStakeAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "totalSubscribedAmount": {
    "inputs": [],
    "name": "totalSubscribedAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/linear/index.js ---
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");

const abis = require("./abis.json");
const { pool2 } = require("../helper/pool2");

const LnCollateralSystemAddress = "0xcE2c94d40e289915d4401c3802D75f6cA5FEf57E";
const LnRewardLockerAddress = "0x66D60EDc3876b8aFefD324d4edf105fd5c4aBeDc";

const tokens = {
  lUSD: "0x23e8a70534308a4aaf76fb8c32ec13d17a3bd89e",
  LINA: "0x762539b45A1dCcE3D36d080F74d1AED37844b878",
  bUSD: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
  LPTOKEN: "0x392f351fc02a3b74f7900de81a9aaac13ec28e95",
};

const vaultpools = {
  bUSD: "0x072F11c46146Ce636691d387BFbF8fD28e818EE8",
  lUSD: "0xD36b669491ADFB5cDE87C281dF417148674f88B4",
  LP: "0x12efdFF85f717ac1738CF50Be5f4Cdc916b0B8B1",
};

function getBSCAddress(address) {
  if(address.toLowerCase() === tokens.lUSD){
    return "bsc:"+tokens.bUSD
  }
  return `bsc:${address}`;
}

async function tvl(timestamp, blockETH, chainBlocks) {
  const block = chainBlocks["bsc"];
  const balances = {};

  const stakedLina = await sdk.api.abi.call({
    block,
    chain: "bsc",
    target: tokens["LINA"],
    params: LnCollateralSystemAddress,
    abi: "erc20:balanceOf",
  });
  sdk.util.sumSingleBalance(balances, getBSCAddress(tokens["LINA"]), stakedLina.output)

  const bUSDPoolLockedlUSD = await sdk.api.abi.call({
    block,
    chain: "bsc",
    target: tokens["lUSD"],
    params: vaultpools["lUSD"],
    abi: "erc20:balanceOf",
  });

  const lUSDPoolLockedlUSD = await sdk.api.abi.call({
    block,
    chain: "bsc",
    target: tokens["lUSD"],
    params: vaultpools["bUSD"],
    abi: "erc20:balanceOf",
  });

  balances[getBSCAddress(tokens["bUSD"])] = BigNumber(bUSDPoolLockedlUSD.output)
    .plus(lUSDPoolLockedlUSD.output).toFixed(0);

  return balances;
}

module.exports = {
  timetravel: true,
  methodology: "Counts LINA used to collateralize lUSD and lUSD locked in the vaults. lUSD is replaced with BUSD.",
  bsc: {
    tvl,
    pool2: pool2(vaultpools["LP"], "0x392f351fc02a3b74f7900de81a9aaac13ec28e95", "bsc", getBSCAddress),
  },
};

'''
'''--- projects/liqee/abi.json ---
{
  "getBaseData": {
    "constant": false,
    "inputs": [],
    "name": "getBaseData",
    "outputs": [{
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  "balanceOfUnderlying":{
		"inputs": [
			{
				"internalType": "address",
				"name": "_account",
				"type": "address"
			}
		],
		"name": "balanceOfUnderlying",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "balanceOf":{
		"constant": true,
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "totalSupply":{
		"constant": true,
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
  "exchangeRateCurrent":{
	"inputs": [],
	"name": "exchangeRateCurrent",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "underlying":{
	"inputs": [],
	"name": "underlying",
	"outputs": [
	  {
		"internalType": "address",
		"name": "",
		"type": "address"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "getUnderlyingPrice":{
	"inputs": [
	  {
		"internalType": "address",
		"name": "_asset",
		"type": "address"
	  }
	],
	"name": "getUnderlyingPrice",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "getAlliTokens": {
	"inputs": [],
	"name": "getAlliTokens",
	"outputs": [
	  {
		"internalType": "address[]",
		"name": "_alliTokens",
		"type": "address[]"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  },
  "isiToken":{
	"inputs": [],
	"name": "isiToken",
	"outputs": [
	  {
		"internalType": "bool",
		"name": "",
		"type": "bool"
	  }
	],
	"stateMutability": "pure",
	"type": "function"
  },
  "totalBorrows":{
	"inputs": [],
	"name": "totalBorrows",
	"outputs": [
	  {
		"internalType": "uint256",
		"name": "",
		"type": "uint256"
	  }
	],
	"stateMutability": "view",
	"type": "function"
  }
}

'''
'''--- projects/liqee/index.js ---
  const sdk = require('@defillama/sdk');

  const BigNumber = require('bignumber.js');
  const abi = require('./abi.json');
  const BASE = BigNumber(10 ** 18)
  const Double = BASE * BASE;
  const {toUSDTBalances, usdtAddress} = require('../helper/balances')

let oracles = {
  "ethereum": "0x34BAf46eA5081e3E49c29fccd8671ccc51e61E79",
  "bsc": "0x7DC17576200590C4d0D8d46843c41f324da2046C",
}

let allControllers = {
  "ethereum": "0x8f1f15DCf4c70873fAF1707973f6029DEc4164b3",
  "bsc": "0x6d290f45A280A688Ff58d095de480364069af110",
}

async function getCurrentCash(chain, token, block) {
  let cash;
  const { output: isiToken } = await sdk.api.abi.call({
    block,
    target: token,
    abi: abi['isiToken'],
    chain: chain
  });

  if (isiToken) {
    const { output: iTokenTotalSupply } = await sdk.api.abi.call({
      block,
      target: token,
      abi: abi['totalSupply'],
      chain: chain
    });

    const { output: iTokenExchangeRate } = await sdk.api.abi.call({
      block,
      target: token,
      abi: abi['exchangeRateCurrent'],
      chain: chain
    });

    cash = BigNumber(iTokenTotalSupply).times(BigNumber(iTokenExchangeRate)).div(BigNumber(10 ** 18));
  } else {

    // Maybe need to accrue borrowed interests
    let { output: iMtokenSupply } = await sdk.api.abi.call({
      block,
      target: token,
      abi: abi['totalBorrows'],
      chain: chain
    });
    cash = BigNumber(iMtokenSupply);
  }
  return cash;
}

async function getAllMarketsByChain(chain, block) {
  const { output: markets } = await sdk.api.abi.call({
    block,
    target: allControllers[chain],
    abi: abi['getAlliTokens'],
    chain: chain
  });

  return markets;
}

async function getUnderlyingPrice(chain, token, block) {
  const { output: iTokenPrices }  = await sdk.api.abi.call({
    block,
    target: oracles[chain],
    params: token,
    abi: abi['getUnderlyingPrice'],
    chain: chain
  });

  return iTokenPrices;
}

async function getLendingTVLByChain(chain, block) {
  let iTokens = {};
  let lendingTVL = BigNumber("0");
  let markets = await getAllMarketsByChain(chain, block);

  await Promise.all(
    markets.map(async market => {
      let cash = await getCurrentCash(chain, market, block);
      let price = await getUnderlyingPrice(chain, market, block);

      iTokens[market] = cash;
      lendingTVL = lendingTVL.plus(cash.times(price).div(Double));
    })
  );

  return {iTokens, lendingTVL};
}

async function getTVLByChain(chain, block) {
  let balances = {};
  let tvl = BigNumber("0");

  // get balance and tvl of the lending protocol.
  let {
    iTokens: iTokensDetials,
    lendingTVL: lendingTVL
  } = await getLendingTVLByChain(chain, block);

  tvl = tvl.plus(lendingTVL);

  return toUSDTBalances(tvl.toNumber());
}

async function ethereum(timestamp, ethBlock, chainBlocks) {
  return getTVLByChain('ethereum', ethBlock);
}

async function bsc(timestamp, ethBlock, chainBlocks) {
  return getTVLByChain('bsc', chainBlocks['bsc']);
}

module.exports = {
  ethereum:{
    tvl: ethereum
  },
  bsc: {
    tvl: bsc
  },
  start: 1629776276, // Aug-24-2021 11:37:56 AM +UTC
}

'''
'''--- projects/liquiddriver/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IBEP20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accLqdrPerShare",
        "type": "uint256"
      },
      {
        "internalType": "uint16",
        "name": "depositFeeBP",
        "type": "uint16"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "strategies": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "strategies",
    "outputs": [
      {
        "internalType": "contract IStrategy",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "get_virtual_price": {
    "stateMutability": "view",
    "type": "function",
    "name": "get_virtual_price",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ]
  },
  "getPoolTokens": {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "poolId",
        "type": "bytes32"
      }
    ],
    "name": "getPoolTokens",
    "outputs": [
      {
        "internalType": "contract IERC20[]",
        "name": "tokens",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "balances",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256",
        "name": "lastChangeBlock",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getReserves": {
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "uint112",
        "name": "_reserve0",
        "type": "uint112"
      },
      {
        "internalType": "uint112",
        "name": "_reserve1",
        "type": "uint112"
      },
      {
        "internalType": "uint32",
        "name": "_blockTimestampLast",
        "type": "uint32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "totalSupply": {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "exchangeRateStored": {
    "constant": true,
    "inputs": [],
    "name": "exchangeRateStored",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/liquiddriver/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const BigNumber = require("bignumber.js");

// --- All sushitokens lp tokens are staked here for LQDR tokens ---
const MASTERCHEF = "0x742474dae70fa2ab063ab786b1fbe5704e861a0c";
const MINICHEF = "0x6e2ad6527901c9664f016466b8DA1357a004db0f";
const usdtTokenAddress = "0x049d68029688eabf473097a2fc38ef61633a3c7a";
const usdcTokenAddress = "0x04068da6c83afcfa0e13ba15a6696662335d5b75";
const wftmTokenAddress = "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83";
const spiritTokenAddress = "0x5Cc61A78F164885776AA610fb0FE1257df78E59B";
const hndTokenAddress = "0x10010078a54396F62c96dF8532dc2B4847d47ED3";
const beethovenVaultAddress = "0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce";
const spiritLinspiritLpInSpirit = "0x54d5b6881b429a694712fa89875448ca8adf06f4";
const linspiritStakingAddress = "0x1CC765cD7baDf46A215bD142846595594AD4ffe3";
const linspiritTokenAddress = "0xc5713B6a0F26bf0fdC1c52B90cd184D950be515C";
const liHndStakingAddress = "0xdf2dA1E24ADa883366972A73d23d1aDDA8CF7CD2";
const liHndTokenAddress = "0xA147268f35Db4Ae3932eabe42AF16C36A8B89690";

const LQDR = "0x10b620b2dbac4faa7d7ffd71da486f5d44cd86f9";
const xLQDR = "0x3Ae658656d1C526144db371FaEf2Fff7170654eE";

const masterchefTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const transformAddress = await transformFantomAddress();

  await addFundsInMasterChef(
    balances,
    MASTERCHEF,
    chainBlocks.fantom,
    "fantom",
    transformAddress,
    abi.poolInfo
  );

  return balances;
};

const minichefTvl = async (timestamp, ethBlock, chainBlocks) => {
  let balances = {};

  const transformAddress = await transformFantomAddress();

  // pool section tvl
  const poolLength = (
    await sdk.api.abi.call({
      abi: abi.poolLength,
      target: MINICHEF,
      chain: "fantom",
      block: chainBlocks["fantom"],
    })
  ).output;

  const [lpTokens, strategies] = await Promise.all([
    sdk.api.abi.multiCall({
      block: chainBlocks["fantom"],
      calls: Array.from(Array(Number(poolLength)).keys()).map((i) => ({
        target: MINICHEF,
        params: i,
      })),
      abi: abi.lpToken,
      chain: "fantom",
    }),
    sdk.api.abi.multiCall({
      block: chainBlocks["fantom"],
      calls: Array.from(Array(Number(poolLength)).keys()).map((i) => ({
        target: MINICHEF,
        params: i,
      })),
      abi: abi.strategies,
      chain: "fantom",
    }),
  ]);

  const [symbols, tokenBalances, strategyBalances] = await Promise.all([
    sdk.api.abi.multiCall({
      block: chainBlocks["fantom"],
      calls: lpTokens.output.map((p) => ({
        target: p.output,
      })),
      abi: "erc20:symbol",
      chain: "fantom",
    }),
    sdk.api.abi.multiCall({
      block: chainBlocks["fantom"],
      calls: lpTokens.output.map((p) => ({
        target: p.output,
        params: MINICHEF,
      })),
      abi: "erc20:balanceOf",
      chain: "fantom",
    }),
    sdk.api.abi.multiCall({
      block: chainBlocks["fantom"],
      calls: strategies.output
        .filter(
          (strategy) =>
            strategy.output !== "0x0000000000000000000000000000000000000000"
        )
        .map((strategy) => ({
          target: strategy.output,
        })),
      abi: abi.balanceOf,
      chain: "fantom",
    })
  ]);

  const lpPositions = [];
  let i = 0;

  tokenBalances.output.forEach(async (balance, idx) => {
    const strategy = strategies.output[idx].output;

    let totalBalance = new BigNumber(balance.output);

    if (strategy !== "0x0000000000000000000000000000000000000000") {
      totalBalance = totalBalance.plus(
        new BigNumber(strategyBalances.output[i].output)
      );
      i++;
    }

    const token = balance.input.target;
    if (symbols.output[idx].success) {
      if (token === "0x936D23C83c2469f6a14B9f5bEaec13879598A5aC") { // ICE-FTM SPIRIT LP
        const [reserves, totalSupply] = await Promise.all([
          sdk.api.abi.call({
            abi: abi.getReserves,
            target: token,
            chain: "fantom",
            block: chainBlocks["fantom"],
          }),
          sdk.api.abi.call({
            abi: abi.totalSupply,
            target: token,
            chain: "fantom",
            block: chainBlocks["fantom"],
          }),
        ]);
        const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
        sdk.util.sumSingleBalance(
          balances,
          transformAddress(wftmTokenAddress),
          new BigNumber(Number(reserves.output[0])).times(2).times(lpTokenRatio).toFixed(0)
        );
      } else if (symbols.output[idx].output.includes("LP")) {
        if (lpTokens.output[idx].output === "0xD163415BD34EF06f57C58D2AEd5A5478AfB464cC") { // BeetXLP_MIM_USDC_USDT
          // DO NOTHING
        } else {
          lpPositions.push({
            balance: totalBalance.toString(10),
            token,
          });
        }
      } else {
        if (symbols.output[idx].output === "3poolV2-f") {
          const virtual_price = (
            await sdk.api.abi.call({
              abi: abi.get_virtual_price,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            })
          ).output;
          const curveTvlInUsdt = totalBalance.times(virtual_price).div(1e30).toFixed(0);

          sdk.util.sumSingleBalance(
            balances,
            transformAddress(usdtTokenAddress),
            curveTvlInUsdt
          );
        } else if (lpTokens.output[idx].output === "0x30A92a4EEca857445F41E4Bb836e64D66920F1C0") { // BPT_LINSPIRIT LP
          const [tokenBalances, reserves, totalSupply] = await Promise.all([
            sdk.api.abi.call({
              abi: abi.getPoolTokens,
              target: beethovenVaultAddress,
              params: ["0x30a92a4eeca857445f41e4bb836e64d66920f1c0000200000000000000000071"],
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.getReserves,
              target: spiritLinspiritLpInSpirit,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.totalSupply,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
          ]);
          const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
          const linspiritPriceInSpirit = new BigNumber(Number(reserves.output[0])).div(Number(reserves.output[1]))
          const linSpiritBalanceInSpirit = linspiritPriceInSpirit.times(Number(tokenBalances.output['1'][1]))
          const bptLinspiritTvlInSpirit = new BigNumber(Number(tokenBalances.output['1'][0])).plus(linSpiritBalanceInSpirit).times(lpTokenRatio).toFixed(0);
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(spiritTokenAddress),
            bptLinspiritTvlInSpirit
          );
        } else if (lpTokens.output[idx].output === "0xf3A602d30dcB723A74a0198313a7551FEacA7DAc") { // BPT-QUARTET LP
          const [tokenBalances, totalSupply] = await Promise.all([
            sdk.api.abi.call({
              abi: abi.getPoolTokens,
              target: beethovenVaultAddress,
              params: ["0xf3a602d30dcb723a74a0198313a7551feaca7dac00010000000000000000005f"],
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.totalSupply,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
          ]);
          const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
          const bptQuartetTvlInUsdc = new BigNumber(tokenBalances.output['1'][0]).times(4).times(lpTokenRatio).toFixed(0);
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(usdcTokenAddress),
            bptQuartetTvlInUsdc
          );
        } else if (lpTokens.output[idx].output === "0xcdF68a4d525Ba2E90Fe959c74330430A5a6b8226") { // FTM-OPERA LP
          const [tokenBalances, totalSupply] = await Promise.all([
            sdk.api.abi.call({
              abi: abi.getPoolTokens,
              target: beethovenVaultAddress,
              params: ["0xcdf68a4d525ba2e90fe959c74330430a5a6b8226000200000000000000000008"],
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.totalSupply,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
          ]);
          const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
          const ftmOperaTvlInUsdc = new BigNumber(tokenBalances.output['1'][0]).times(100).div(30).times(lpTokenRatio).toFixed(0);
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(usdcTokenAddress),
            ftmOperaTvlInUsdc
          );
        } else if (lpTokens.output[idx].output === "0x8F6a658056378558fF88265f7c9444A0FB4DB4be") { // BPT_liHND LP
          const [tokenBalances, totalSupply] = await Promise.all([
            sdk.api.abi.call({
              abi: abi.getPoolTokens,
              target: beethovenVaultAddress,
              params: ["0x8f6a658056378558ff88265f7c9444a0fb4db4be0002000000000000000002b8"],
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.totalSupply,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
          ]);
          const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
          const bptLiHndTvlInHnd = new BigNumber(Number(tokenBalances.output['1'][0])).times(2).times(lpTokenRatio).toFixed(0);
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(hndTokenAddress),
            bptLiHndTvlInHnd
          );
        } else if (lpTokens.output[idx].output === "0x8B858Eaf095A7337dE6f9bC212993338773cA34e") { // DEI-USDC LP
          const [tokenBalances, totalSupply] = await Promise.all([
            sdk.api.abi.call({
              abi: abi.getPoolTokens,
              target: beethovenVaultAddress,
              params: ["0x8b858eaf095a7337de6f9bc212993338773ca34e00020000000000000000023c"],
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
            sdk.api.abi.call({
              abi: abi.totalSupply,
              target: token,
              chain: "fantom",
              block: chainBlocks["fantom"],
            }),
          ]);
          const lpTokenRatio = new BigNumber(totalSupply.output).isZero() ? new BigNumber(0) : totalBalance.div(totalSupply.output);
          const bptDeiUsdcTvlInUsdc = new BigNumber(Number(tokenBalances.output['1'][1])).div(1e12).plus(Number(tokenBalances.output['1'][0])).times(lpTokenRatio).toFixed(0);
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(usdcTokenAddress),
            bptDeiUsdcTvlInUsdc
          );
        } else {
          sdk.util.sumSingleBalance(
            balances,
            transformAddress(token),
            totalBalance.toString(10)
          );
        }
      }
    }
  });

  const turns = Math.floor(lpPositions.length / 10);
  let n = 0;

  for (let i = 0; i < turns; i++) {
    await unwrapUniswapLPs(
      balances,
      lpPositions.slice(n, n + 10),
      chainBlocks["fantom"],
      "fantom",
      transformAddress
    );
    n += 10;
  }

  // linspirit staking tvl
  const linspiritStakedBalance = ((await sdk.api.abi.call({
    chain: 'fantom',
    block: chainBlocks['fantom'],
    target: linspiritTokenAddress,
    abi: 'erc20:balanceOf',
    params: linspiritStakingAddress
  })).output);

  sdk.util.sumSingleBalance(
    balances,
    transformAddress(spiritTokenAddress),
    linspiritStakedBalance
  );

  // lihnd staking tvl
  const liHndStakedBalance = ((await sdk.api.abi.call({
    chain: 'fantom',
    block: chainBlocks['fantom'],
    target: liHndTokenAddress,
    abi: 'erc20:balanceOf',
    params: liHndStakingAddress
  })).output);

  sdk.util.sumSingleBalance(
    balances,
    transformAddress(hndTokenAddress),
    liHndStakedBalance
  );

  return balances;
};

const hundredchefTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const transformAddress = await transformFantomAddress();

  const hdaiChefAddress = "0x79364E45648Db09eE9314E47b2fD31c199Eb03B9";
  const husdcChefAddress = "0x9A07fB107b9d8eA8B82ECF453Efb7cFb85A66Ce9";
  const hmimChefAddress = "0xeD566B089Fc80Df0e8D3E0AD3aD06116433Bf4a7";
  const hfraxChefAddress = "0x669F5f289A5833744E830AD6AB767Ea47A3d6409";

  const chefAddressess = [
    hdaiChefAddress,
    husdcChefAddress,
    hmimChefAddress,
    hfraxChefAddress,
  ];

  for (let index = 0; index < chefAddressess.length; index++) {
    const chefAddress = chefAddressess[index];
    const token = ((await sdk.api.abi.call({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      target: chefAddress,
      abi: abi.lpToken,
      params: 0
    })).output);

    const exchangeRateStored = ((await sdk.api.abi.call({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      target: token,
      abi: abi.exchangeRateStored,
    })).output);

    const strategyAddress = ((await sdk.api.abi.call({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      target: chefAddress,
      abi: abi.strategies,
      params: 0
    })).output);

    const strategyBalanace = ((await sdk.api.abi.call({
      chain: 'fantom',
      block: chainBlocks['fantom'],
      target: strategyAddress,
      abi: abi.balanceOf,
    })).output);

    sdk.util.sumSingleBalance(
      balances,
      transformAddress(usdcTokenAddress),
      new BigNumber(Number(strategyBalanace)).times(exchangeRateStored).div(chefAddress === husdcChefAddress ? 1e18 : 1e30).toFixed(0)
    );
  };

  return balances;
};

module.exports = {
  fantom: {
    staking: staking(xLQDR, LQDR, "fantom", "fantom:" + LQDR),
    tvl: sdk.util.sumChainTvls([
      masterchefTvl,
      minichefTvl,
      hundredchefTvl,
    ]),
  }
}; // node test.js projects/liquiddriver/index.js
'''
'''--- projects/liquidrium/abi.json ---
{
    "getTotalAmounts": {
        "inputs": [],
        "name": "getTotalAmounts",
        "outputs": [
			{
				"internalType": "uint256",
				"name": "total0",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "total1",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
    }
}
	
'''
'''--- projects/liquidrium/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');
const {vaults} = require('./vaults');1

function calculateValue(amount, decimals){
	return amount / 10 ** decimals;
};
async function tvl(block, chain) {
	let balances = {};

	for(let i=0; i<vaults.length; i++){
		if(vaults[i].chain == chain){
			const poolTVL = await sdk.api.abi.call({
				target: vaults[i].address,
				abi: abi['getTotalAmounts'],
				block: block,
				chain: vaults[i].chain
			});

			const token0Amount = calculateValue(
				poolTVL.output.total0, vaults[i].token1decimal);
			const token1Amount = calculateValue(
				poolTVL.output.total1, vaults[i].token2decimal);

			sdk.util.sumSingleBalance(
				balances, vaults[i].token1Name, token0Amount);
			sdk.util.sumSingleBalance(
				balances, vaults[i].token2Name, token1Amount);
		};
	};

	return balances;
};
async function tvlPolygon(timestamp, block, chainBlocks) {
	return await tvl(chainBlocks['polygon'], 'polygon');
};
async function tvlArbitrum(timestamp, block, chainBlocks) {
	return await tvl(chainBlocks['arbitrum'], 'arbitrum');
};
async function tvlEth(timestamp, block, chainBlocks) {
	return await tvl(block, 'ethereum');
};
module.exports = {
	polygon: {
	  tvl: tvlPolygon,
	},
	arbitrum: {
	  tvl: tvlArbitrum,
	},
	ethereum: {
		tvl: tvlEth,
	},
	methodology: 'We iterate through each HyperLiquidrium and get the total amounts of each deposited asset, then multiply it by their USD dollar provided by CoinGecko'
};
'''
'''--- projects/liquidrium/vaults.js ---

const vaults = [
    {
        name: "usdc-eth",
        address: "0xF82aeDC7faA3Fe1F412C71fe5E432690C46cd1bb", 
        token1: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        token2: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        token1decimal: 6,
        token2decimal: 18,
        token1Name: "usd-coin",
        token2Name: "ethereum",
        chain: "ethereum"
    },
    {
        name: "wbtc-eth",
        address: "0x3FeE1B1C829DB1250B0e6B8605741E944Ed3A41e", 
        token1: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
        token2: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        token1decimal: 8,
        token2decimal: 18,
        token1Name: "wrapped-bitcoin",
        token2Name: "ethereum",
        chain: 'ethereum'
    },
    {
        name: "eth-usdc",
        address: "0x7F6d25dE79559e548f0417aeB1953Ab6D3D85b14", 
        token1: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        token2: "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
        token1decimal: 18,
        token2decimal: 6,
        token1Name: "ethereum",
        token2Name: "usd-coin",
        chain: "arbitrum"
    },
    {
        name: "wbtc-eth",
        address: "0x849668517a74535EC5ECc09Fa9A22e0CEf91443E",
        token1: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f",
        token2: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
        token1decimal: 8,
        token2decimal: 18,
        token1Name: "wrapped-bitcoin",
        token2Name: "ethereum",
        chain: "arbitrum"
    },
    {
        name: "matic-usdc",
        address: "0xB19e59b77E173363FB7Ce674f1279c76ee237c7A", 
        token1: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270", 
        token2: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", 
        token1decimal: 18,
        token2decimal: 6,
        token1Name: "wmatic",
        token2Name: "usd-coin",
        chain: "polygon"
    },
    {
        name: "matic-weth",
        address: "0x249403E3163aAA88259e0e79A513E999EF8AbEc3", 
        token1: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270", 
        token2: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619", 
        token1decimal: 18,
        token2decimal: 18,
        token1Name: "wmatic",
        token2Name: "ethereum",
        chain: "polygon"
    },
]
  
module.exports = {
    vaults
  }
'''
'''--- projects/liquidswap/index.js ---
const { getChainTvl } = require("../helper/getUniSubgraphTvl");

module.exports={
    timetravel: true,
    methodology: "We are counting all the liquidity on their DEX as TVL, data is sourced from the subgraph at 'https://subgraph.liquidchain.net/subgraphs/name/liquid/exchange'",
    liquidchain:{
        tvl: getChainTvl({
            liquidchain: "https://subgraph.liquidchain.net/subgraphs/name/liquid/exchange"
        }, "pancakeFactories")('liquidchain')
    }
}
'''
'''--- projects/liquity/getEntireSystemColl.abi.json ---
{
  "inputs": [],
  "name": "getEntireSystemColl",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "entireSystemColl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/liquity/index.js ---
const sdk = require("@defillama/sdk");
const getEntireSystemCollAbi = require("./getEntireSystemColl.abi.json");

const ETH_ADDRESS = "0x0000000000000000000000000000000000000000";
//const LUSD_TOKEN_ADDRESS = "0x5f98805a4e8be255a32880fdec7f6728c6568ba0";

// StabilityPool holds deposited LUSD
//const STABILITY_POOL_ADDRESS = "0x66017D22b0f8556afDd19FC67041899Eb65a21bb";

// TroveManager holds total system collateral (deposited ETH)
const TROVE_MANAGER_ADDRESS = "0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2";

async function tvl(_, block) {
  /*const stabilityPoolLusdTvl = (
    await sdk.api.erc20.balanceOf({
      target: LUSD_TOKEN_ADDRESS,
      owner: STABILITY_POOL_ADDRESS,
      block,
    })
  ).output;*/

  const troveEthTvl = (
    await sdk.api.abi.call({
      target: TROVE_MANAGER_ADDRESS,
      abi: getEntireSystemCollAbi,
      block,
    })
  ).output;

  return {
    [ETH_ADDRESS]: troveEthTvl,
    //[LUSD_TOKEN_ADDRESS]: stabilityPoolLusdTvl,
  };
}

module.exports = {
  timetravel: true,
  start: 1617607296,
  ethereum: {
    tvl,
  }
  
};

'''
'''--- projects/lixir/abi.json ---
{
    "getRoleMemberCount": {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "role",
                "type": "bytes32"
            }
        ],
        "name": "getRoleMemberCount",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getRoleMember": {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "role",
                "type": "bytes32"
            },
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "getRoleMember",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "calculateTotals": {
        "inputs": [],
        "name": "calculateTotals",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "total0",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "total1",
                "type": "uint256"
            },
            {
                "internalType": "uint128",
                "name": "mL",
                "type": "uint128"
            },
            {
                "internalType": "uint128",
                "name": "rL",
                "type": "uint128"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token0": {
        "inputs": [],
        "name": "token0",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "token1": {
        "inputs": [],
        "name": "token1",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "balanceOf": {
        "constant": true,
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "balanceOf",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      }
}
'''
'''--- projects/lixir/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json')
const {staking} = require('../helper/staking')

const oldRegistry = "0x3228f22d98d81A859aCC9890c3874FfF864a8Bd4";
const newRegistry = "0x18bf8A3eE39Be5730189A0C88D90f744e3c55B20";
const vault_role = "0x0e2208c692f4f271957e6c9d7c9785b7c2c3a7e329d54eecdfaa3c5f48b0cd51";
const lixirToken = "0xd0345D30FD918D7682398ACbCdf139C808998709";

// node test.js projects/lixir/index.js
async function ethTvl(timestamp, block) {
    let balances = await vaultTvl(oldRegistry, block, {});
    await vaultTvl(newRegistry, block, balances)
    return balances//await newVaultTvl(block, newVaults, balances);
};
async function vaultTvl(registry, block, balances, pool2 = false) {
    const count = Number((await sdk.api.abi.call({
        target: registry,
        block, 
        params: [vault_role],
        abi: abi.getRoleMemberCount
    })).output)

    const vaults = await sdk.api.abi.multiCall({
        block,
        abi: abi.getRoleMember,
        calls: [...Array(count)].map((_, i) => ({
            target: registry,
            params: [vault_role, i],
        }))
    })

    const calls = vaults.output.map(v=>({
        target: v.output
    }))

    const [totals, token0, token1] = await Promise.all([
        abi.calculateTotals, 
        abi.token0, 
        abi.token1
    ].map(abi=>sdk.api.abi.multiCall({
        block,
        abi,
        calls
    })))

    for(let i =0; i<count; i++){
        // if pool2, only sum pool2's, else leave out pool2's
        /*
        if ((!pool2 && (token0.output[i].output.toLowerCase() != lixirToken.toLowerCase() || 
                token1.output[i].output.toLowerCase() != lixirToken.toLowerCase()))
            || (pool2 && (token0.output[i].output.toLowerCase() == lixirToken.toLowerCase() || 
                token1.output[i].output.toLowerCase() == lixirToken.toLowerCase()))) {
        */
            sdk.util.sumSingleBalance(
                balances, 
                token0.output[i].output, 
                totals.output[i].output[0])
            sdk.util.sumSingleBalance(
                balances, 
                token1.output[i].output, 
                totals.output[i].output[1])
        //}
    }

    return balances;
};

module.exports={
    ethereum:{
        tvl: ethTvl,
        staking: staking("0x29adccf67821e9236b401df02080bac67f84192d", lixirToken)
    }
}
'''
'''--- projects/llama-airforce/abi.json ---
{
    "totalUnderlying": {
        "inputs": [],
        "name": "totalUnderlying",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "total",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "priceOracle": {
        "stateMutability": "view",
        "type": "function",
        "name": "price_oracle",
        "inputs": [],
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ]
    }
}
'''
'''--- projects/llama-airforce/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');

const contracts = {
    cvxCRVHolder: "0x83507cc8c8b67ed48badd1f59f684d5d02884c81",
    cvxCRV: "0x62b9c7356a2dc64a1969e19c23e4f579f9810aa7",
    cvxFXSHolder: "0xf964b0e3ffdea659c44a5a52bc0b82a24b89ce0e",
    cvxFXS: "0xFEEf77d3f69374f66429C91d732A244f074bdf74",
    cvxFXSOracle: "0xd658A338613198204DCa1143Ac3F01A722b5d94A",
    FXS: "0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0"
};

async function tvl(time, block){
    const balances = {};

    balances[contracts.cvxCRV] = (await sdk.api.abi.call({
        target: contracts.cvxCRVHolder,
        abi: abi.totalUnderlying,
        block
    })).output;

    const cvxFXS = (await sdk.api.abi.call({
        target: contracts.cvxFXSHolder,
        abi: abi.totalUnderlying,
        block
    })).output;

    const ratio = (await sdk.api.abi.call({
        target: contracts.cvxFXSOracle,
        abi: abi.priceOracle,
        block
    })).output;

    balances[contracts.FXS] = cvxFXS * ratio * 10**-18;

    return balances;
};

module.exports={
    ethereum:{
        tvl
    }
};
'''
'''--- projects/llamapay/abi.json ---
{
  "getLlamaPayContractCount": {
    "inputs": [],
    "name": "getLlamaPayContractCount",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "getLlamaPayContractByIndex": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "getLlamaPayContractByIndex",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      { "internalType": "contract IERC20", "name": "", "type": "address" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "escrows_length": {
    "stateMutability": "view",
    "type": "function",
    "name": "escrows_length",
    "inputs": [],
    "outputs": [{ "name": "", "type": "uint256" }],
    "gas": 2448
  },
  "vested_token": {
    "stateMutability": "view",
    "type": "function",
    "name": "token",
    "inputs": [],
    "outputs": [{ "name": "", "type": "address" }],
    "gas": 2688
  },
  "escrows": {
    "stateMutability": "view",
    "type": "function",
    "name": "escrows",
    "inputs": [{ "name": "arg0", "type": "uint256" }],
    "outputs": [{ "name": "", "type": "address" }],
    "gas": 2523
  }
}

'''
'''--- projects/llamapay/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { getChainTransform, getFixBalances } = require("../helper/portedTokens");

const llamaPayAvax = "0x7d507b4c2d7e54da5731f643506996da8525f4a3";
const llamaPayDefault = "0xde1C04855c2828431ba637675B6929A684f84C7F";
const llamaPayVesting = "0xB93427b83573C8F27a08A909045c3e809610411a";
const llamaPayMeter = "0xc666badd040d5e471d2b77296fef46165ffe5132";
const llamaPayMeterVesting = "0x6B24Fe659D1E91f8800E86600DE577A4cA8814a6";
const llamaPayMetis = "0x43634d1C608f16Fb0f4926c12b54124C93030600";

async function calculateTvl(llamapay, vesting, block, chain) {
  const transform = await getChainTransform(chain);
  const balances = {};

  const contractCount = (
    await sdk.api.abi.call({
      target: llamapay,
      abi: abi["getLlamaPayContractCount"],
      block,
      chain,
    })
  ).output;

  const llamaPayContracts = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(contractCount) }, (_, k) => ({
        target: llamapay,
        params: k,
      })),
      abi: abi["getLlamaPayContractByIndex"],
      block,
      chain,
    })
  ).output;

  const llamaPayTokens = (
    await sdk.api.abi.multiCall({
      calls: llamaPayContracts.map((p) => ({
        target: p.output,
      })),
      abi: abi["token"],
      block,
      chain,
    })
  ).output;

  const tokenBalances = (
    await sdk.api.abi.multiCall({
      calls: llamaPayTokens.map((p) => ({
        target: p.output,
        params: p.input.target,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;

  tokenBalances.map((p) => {
    const token = p.input.target.toLowerCase();
    const balance = p.output;
    sdk.util.sumSingleBalance(balances, transform(token), balance);
  });

  const vestingCount = (
    await sdk.api.abi.call({
      target: vesting,
      abi: abi["escrows_length"],
      block,
      chain,
    })
  ).output;

  const vestingContracts = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(vestingCount) }, (_, k) => ({
        target: vesting,
        params: k,
      })),
      abi: abi["escrows"],
      block,
      chain,
    })
  ).output;

  const vestedTokens = (
    await sdk.api.abi.multiCall({
      calls: vestingContracts.map((p) => ({
        target: p.output,
      })),
      abi: abi["vested_token"],
      block,
      chain,
    })
  ).output;

  const vestedTokenBalances = (
    await sdk.api.abi.multiCall({
      calls: vestedTokens.map((p) => ({
        target: p.output,
        params: p.input.target,
      })),
      abi: "erc20:balanceOf",
      block,
      chain,
    })
  ).output;

  if (vestedTokenBalances.length > 0) {
    vestedTokenBalances.map((p) => {
      const token = p.input.target.toLowerCase();
      const balance = p.output;
      sdk.util.sumSingleBalance(balances, transform(token), balance);
    });
  }

  (await getFixBalances(chain))(balances);

  return balances;
}

const chains = [
  "avax",
  "arbitrum",
  "bsc",
  "fantom",
  "ethereum",
  "optimism",
  "polygon",
  "xdai",
  "meter",
  "metis",
];

module.exports = {};

chains.forEach((chain) => {
  let contract = llamaPayDefault;
  let vestingContract = llamaPayVesting;

  switch (chain) {
    case "avax":
      contract = llamaPayAvax;
      break;
    case "meter":
      contract = llamaPayMeter;
      vestingContract = llamaPayMeterVesting;
      break;
    case "metis":
      contract = llamaPayMetis;
      break;
  }

  module.exports[chain] = {
    tvl: async (_, _b, { [chain]: block }) =>
      calculateTvl(contract, vestingContract, block, chain),
  };
});

'''
'''--- projects/lns/index.js ---
const { stakingPricedLP } = require('../helper/staking')

const xLNS = "0xBE7E034c86AC2a302f69ef3975e3D14820cC7660";
const LNS = "0x35b3Ee79E1A7775cE0c11Bd8cd416630E07B0d6f";
const WBCH_LNS_POOL = "0x7f3F57C92681c9a132660c468f9cdff456fC3Fd7";
const CHAIN = "smartbch";

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "LNS tokens locked in the staking contract are counted towards staking.",
  smartbch: {
    tvl: () => ({}),
    staking: stakingPricedLP(xLNS, LNS, CHAIN, WBCH_LNS_POOL, "bitcoin-cash", false, 18)
  },
};

'''
'''--- projects/lobis.js ---
const { ohmTvl } = require('./helper/ohm')

const treasury = "0x873ad91fA4F2aA0d557C0919eC3F6c9D240cDd05"
module.exports = ohmTvl(treasury, [
    //curve 
    ["0xD533a949740bb3306d119CC777fa900bA034cd52", false],
    //frax
    ["0x3432b6a60d23ca0dfca7761b7ab56459d9c964d0", false],
    //Sushi LP
    ["0x2734f4a846d1127f4b5d3bab261facfe51df1d9a", true],
], "ethereum", "0x3818eff63418e0a0ba3980aba5ff388b029b6d90", "0xdec41db0c33f3f6f3cb615449c311ba22d418a8d")

'''
'''--- projects/lolsurprisefinance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0xE1E5B476aa9d85a7df27839f7894406d2528aBBE"
const lol = "0x7AB619B5Bb51eF3ed099A8A81948481Fe5e6099c"

module.exports = {
    ...masterChefExports(masterchef, "bsc", lol)
}
'''
'''--- projects/longdrink/index.js ---
const sdk = require('@defillama/sdk')
const {unwrapUniswapLPs} = require('../helper/unwrapLPs')

const bev = "0xc7dac962c166a26038ec4bc5d0e2a3fe0ff3ce58"
const l1q = "0xf8d5c25a47d28866b4c1ce285f42997c690f941c"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  for(const token of [bev, l1q]){
    const supply = await sdk.api.erc20.totalSupply({
        target: token,
        block: chainBlocks.bsc,
        chain: 'bsc'
    })
    balances['bsc:'+token]= supply.output
  }

  return balances
}

const LPstaking = "0x986581a915f8abf4C8E21781a2c45FD4Eb21699D"
const lp = "0x5ab4dc6ec350e546103f6891299b467293c36c3e"

async function pool2(timestamp, block, chainBlocks) {
    const stakedLp = await sdk.api.erc20.balanceOf({
        target: lp,
        owner: LPstaking,
        block: chainBlocks.bsc,
        chain: 'bsc'
    })
    const balances = {}

    await unwrapUniswapLPs(balances, [{
        token: lp,
        balance: stakedLp.output
    }], chainBlocks.bsc, 'bsc', addr=>`bsc:${addr}`)

  return balances;
}

module.exports = {
  bsc: {
    tvl,
    pool2,
  },
};
'''
'''--- projects/looks-rare/index.js ---
const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");

const LOOKS = "0xf4d2888d29D722226FafA5d9B24F9164c092421E";
const tokenDistributor = "0x465a790b428268196865a3ae2648481ad7e0d3b1";
const stakingContract = "0xbcd7254a1d759efa08ec7c3291b2e85c5dcc12ce";
const LOOKS_ETH_univ2 = '0xdc00ba87cc2d99468f7f34bc04cbf72e111a32f7'
const LOOKS_ETH_univ2_staking = '0x2a70e7f51f6cd40c3e9956aa964137668cbfadc5'

// LOOKS staking send the looks token to the tokenDistributor contract
// https://etherscan.io/tx/0xcf9e2d958b2ca04f735e6643c8b3be098ce3befda72957abe94676e2db017dbb

module.exports = {
  methodology: `TVL for LOOKS.RARE consists of the staking of LOOKS and pool2 of uni-v2 LOOKS-WETH.`, 
  ethereum:{
    tvl: () => ({}),
    staking: staking(tokenDistributor, LOOKS, "ethereum"), 
    pool2: pool2(LOOKS_ETH_univ2_staking, LOOKS_ETH_univ2, "ethereum"), 
  }
}
'''
'''--- projects/loop-finance/index.js ---
const sdk = require("@defillama/sdk");
const { fetchURL } = require('../helper/utils')
const { getBalance, getDenomBalance } = require("../helper/terra");
const { getBlock } = require("../helper/getBlock");

async function getPairs() {
    const factory00 = (await fetchURL(
        queries.baseUrl + queries.factory0 + queries.query30
    )).data.result.pairs;
    const factory01 = (await fetchURL(
        queries.baseUrl + queries.factory0 + queries.factory0query60
    )).data.result.pairs;
    const factory10 = (await fetchURL(
        queries.baseUrl + queries.factory1 + queries.query30
    )).data.result.pairs;

    if (factory01.length > 29 || factory10.length > 29) {
        throw new Error(`We need another query since they're capped at 30 results and pools may be missing`);
    };

    return factory00.concat(factory01, factory10);
};

const tokenMapping = {
    "terra17wkadg0tah554r35x6wvff0y5s7ve8npcjfuhz": "prism-yluna",
    "terra1hzh9vpxhsk8253se0vv5jj6etdvxu3nv8z07zu": "anchorust",
    "terra1kcthelkax4j9x8d3ny6sdag0qmxxynl3qtcrpy": "pylon-protocol",
    "terra1nef5jf6c7js9x6gkntlehgywvjlpytm7pcgkn4": "loop-token",
    "terra1tlgelulz9pdkhls6uglfn5lmxarx7f2gxtdzh2": "prism-pluna",
    "terra1w8kvd6cqpsthupsk4l0clwnmek4l3zr7c84kwq": "angel-protocol",
    "terra1xfsdgcemqwxp4hhnyk4rle6wr22sseq7j07dnn": "kujira",
    "uusd": "terrausd",
    "uluna": "terra-luna",
    // waiting on team for these IBC token tickers
    "ibc/0471F1C4E7AFD3F07702BEF6DC365268D64570F7C1FDC98EA6098DD6DE59817B": "undefined",
    "ibc/18ABA66B791918D51D33415DA173632735D830E2E77E63C91C11D3008CFD5262": "undefined",
    "ibc/EB2CED20AB0466F18BE49285E56B31306D4C60438A022EA995BA65D5E3CF7E09": "undefined",
};

const queries = {
    "baseUrl": 'https://fcd.terra.dev/wasm/contracts/',
    "factory0": 'terra16hdjuvghcumu6prg22cdjl96ptuay6r0hc6yns',
    "factory1": 'terra10fp5e9m5avthm76z2ujgje2atw6nc87pwdwtww',
    "query30": '/store?query_msg=%7B%22pairs%22:%7B%22limit%22:30%7D%7D',
    "factory0query60": '/store?query_msg=%7B%22pairs%22:%7B%22start_after%22:[%7B%22token%22:%7B%22contract_addr%22:%22terra1mj4rkdr2l5cvse8089z45mlp5dxx0hrjy5ts94%22%7D%7D,%7B%22native_token%22:%7B%22denom%22:%22uusd%22%7D%7D],%22limit%22:30%7D%7D'
};

async function isDenom(balances, pair, block, index) {
    if (pair.asset_infos[index].native_token) {
        if (!tokenMapping[pair.asset_infos[index].native_token.denom]) {
            throw new Error(`no mapping for token ${pair.asset_infos[index].native_token.denom}`);
        };

        sdk.util.sumSingleBalance(
            balances,
            tokenMapping[pair.asset_infos[index].native_token.denom],
            2 * (await getDenomBalance(
                pair.asset_infos[index].native_token.denom,
                pair.contract_addr,
                block
            )) / 10 ** 6
        );

        return true;
    };
};

async function isToken(balances, pair, block, index) {
    if (tokenMapping[pair.asset_infos[index].token.contract_addr]) {
        if (!tokenMapping[pair.asset_infos[index].token.contract_addr]) {
            throw new Error(`no mapping for token ${pair.asset_infos[index].token.contract_addr}`);
        };

        sdk.util.sumSingleBalance(
            balances,
            tokenMapping[pair.asset_infos[index].token.contract_addr],
            2 * (await getBalance(
                pair.asset_infos[index].token.contract_addr,
                pair.contract_addr,
                block
            )) / 10 ** 6
        );

        return true;
    };
};

async function tvl(timestamp, block, chainBlocks) {
    const balances = {};
    block = await getBlock(timestamp, "terra", chainBlocks, true);
    const pairs = await getPairs();
    for (let pair of pairs) {
        (await isDenom(balances, pair, block, 0)) || (await isDenom(balances, pair, block, 1)) ||
            (await isToken(balances, pair, block, 0)) || (await isToken(balances, pair, block, 1))
    };
    return balances;
};

module.exports = {
    timetravel: false,
    terra: {
        tvl
    }
};
'''
'''--- projects/loopmarkets/index.js ---
const retry = require("../helper/retry");
const { GraphQLClient, gql } = require("graphql-request");

var graphql_url = "https://graphql.loop.markets/graphql?PairContractsQuery";

var graphQLClient = new GraphQLClient(graphql_url);

async function fetch() {
  var query1 = gql`
    {
      AssetPositions {
        token {
          token
        }
        second_token {
          token
        }
      }
    }
  `;

  let tvl = 0;
  const token0_token1 = (
    await retry(async (bail) => await graphQLClient.request(query1))
  ).AssetPositions;

  for (const token of token0_token1) {
    let query2 = gql`
    {
        tokenTotalLockedValue(
            token: "${token.token.token}",
            second_token: "${token.second_token.token}"
        ){
            liquidity
        }
    }
    `;

    const data = (await retry(
      async (bail) => await graphQLClient.request(query2)
    ));

    tvl += parseFloat(data.tokenTotalLockedValue.liquidity)/10**6;
  }

  return tvl;
}

module.exports = {
  timetravel: false,
  fetch,
};

'''
'''--- projects/loopring/index.js ---
 /*==================================================
  Modules
  ==================================================*/

  const sdk = require('@defillama/sdk');

  const BigNumber = require('bignumber.js');

 /*==================================================
  Vars
  ==================================================*/

  const oldLoopringExchange = '0x944644Ea989Ec64c2Ab9eF341D383cEf586A5777';
  const newLoopringExchangeDepositContract = '0x674bdf20A0F284D710BC40872100128e2d66Bd3f';

  const listedTokens = [
    '0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD',  // LRC
    '0xdac17f958d2ee523a2206206994597c13d831ec7',  // USDT
    '0x6B175474E89094C44Da98b954EedeAC495271d0F',  // DAI
    '0x514910771AF9Ca656af840dff83E8264EcF986CA',  // LINK
    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',  // USDC
    '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',  // WBTC
    '0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2',  // MKR
  ];

/*==================================================
  TVL
  ==================================================*/

  async function tvl(timestamp, block) {
    let ethBalanceOld = await sdk.api.eth.getBalance({target: oldLoopringExchange, block});
    let ethBalanceNew = await sdk.api.eth.getBalance({target: newLoopringExchangeDepositContract, block});
    let ethBlanaceTotal = BigNumber(ethBalanceOld.output || 0).plus(ethBalanceNew.output);

    let balances = {
      '0x0000000000000000000000000000000000000000': ethBlanaceTotal
    };

    let calls = [];
    listedTokens.forEach((token) => {
      calls.push({
        target: token,
        params: oldLoopringExchange
      });
      calls.push({
        target: token,
        params: newLoopringExchangeDepositContract
      });
    });

    let balanceOfResults = await sdk.api.abi.multiCall({
      block,
      calls,
      abi: 'erc20:balanceOf'
    });

    sdk.util.sumMultiBalanceOf(balances, balanceOfResults, true);

    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1574241665, // 11/20/2019 @ 09:21AM (UTC)
    ethereum: { tvl }
  }

'''
'''--- projects/lootswap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')

module.exports={
    harmony: {
        tvl:calculateUsdUniTvl("0x021AeF70c404aa9d70b71C615F17aB3a4038851A", "harmony", "0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a", [], "harmony")
    }
}
'''
'''--- projects/loterra/index.js ---
const { sumSingleBalance, TOKEN_LIST, getBalance, } = require('../helper/terra')

// Source: https://docs.loterra.io/resources/contract-addresses
const contracts = {
	multiSig: 'terra1s4twvkqy0eel5saah64wxezpckm7v9535jjshy',
	dogether: 'terra19h4xk8xxxew0ne6fuw0mvuf7ltmjmxjxssj5ts'
}

async function tvl(timestamp, ethBlock, { terra: block }) {
	const balances = {}

	// Add aUST tokens in the multi-sig
	const aUSTBalance = await getBalance(TOKEN_LIST.anchorust, contracts.dogether, block)
	sumSingleBalance(balances, TOKEN_LIST.anchorust, aUSTBalance)

	return balances
}

async function treasury(timestamp, ethBlock, { terra: block }) {
	const balances = {}

	// Add aUST tokens in the multi-sig
	const aUSTBalance = await getBalance(TOKEN_LIST.anchorust, contracts.multiSig, block)
	sumSingleBalance(balances, TOKEN_LIST.anchorust, aUSTBalance)

	return balances
}

module.exports = {
	methodology: 'TVL counts the UST that is available as a prize on the protocol.',
	terra: {
		tvl,
		treasury,
	},
	timetravel: false,
}
'''
'''--- projects/louverture/abi.json ---
{
    "totalNodeValue": {
        "inputs": [],
        "name": "totalNodeValue",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/louverture/index.js ---
const sdk = require('@defillama/sdk');
const abi = require('./abi.json');

const nodeManager = '0x3Cf1Dff7CCE2b7291456Bc2089b4bCB2AB5f311A'
const lvtContract = 'avax:0xff579d6259dEDcc80488c9b89d2820bCb5609160'

async function staking(timestamp, ethBlock, chainBlocks) {
    const totalNodeValue = await sdk.api.abi.call({
      target: nodeManager,
      abi: abi['totalNodeValue'],
      block: chainBlocks.avax,
      chain: 'avax'
    });
    
    
    return{
        [lvtContract]: totalNodeValue.output
    }
}

module.exports = {
  start: 1639872000,            // 19/12/2021 @ 00:00am (UTC)
  avalanche:{
      staking,
      tvl: async()=>({})
  }
}

'''
'''--- projects/lowcostswap/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0x57f70857aB735576ab5216Cd5e58c6dAe72F21D7";
const token = "0xDBfe47255CbA4A7623985444E730719E9F958E67";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/luaswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology:
    "Factory address on tomochain (0x0eAC91966b12b81db18f59D8e893b9ccef7e2c30) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  tomochain: {
    tvl: calculateUsdUniTvl(
      "0x28c79368257CD71A122409330ad2bEBA7277a396",
      "tomochain",
      "0xB1f66997A5760428D3a87D68b90BfE0aE64121cC",
      [
        "0x7262fa193e9590b2e075c3c16170f3f2f32f5c74",
        "0x381B31409e4D220919B2cFF012ED94d70135A59e",
        "0x2EAA73Bd0db20c64f53fEbeA7b5F5E5Bccc7fb8b",
      ],
      "tomochain"
    ),
  },
  ethereum: {
    tvl: calculateUsdUniTvl(
      "0x0388C1E0f210AbAe597B7DE712B9510C6C36C857",
      "ethereum",
      "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
      [
        "0xb1f66997a5760428d3a87d68b90bfe0ae64121cc",
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
        "0x05d3606d5c81eb9b7b18530995ec9b29da05faba",
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
      ],
      "ethereum"
    ),
  },
}

'''
'''--- projects/luchadores/index.js ---
const { staking } = require('../helper/staking');
const { pool2s } = require('../helper/pool2');
const {sumTokensAndLPsSharedOwners} = require('../helper/unwrapLPs');
const {transformPolygonAddress} = require('../helper/portedTokens');

// multisigs
const treasury = "0x0Cb11b92Fa5C30eAfe4aE84B7BB4dF3034C38b9d";
const rewardPool = "0x72104d619BaEDf632936d9dcE38C089CA3bf12Dc";

// LPs
const LUCHA_MATIC_comethLp = "0x5e1cd1b923674e99df95ce0f910dcf5a58a3ca2d";
const LUCHA_MUST_comethLp = "0x98503d87aa4e9c84ff5d2e558295a0967fbbbeff";

// staking
const luchaStk = "0xC5E9E8574c27747B4D537ef94e2448a3A0525dF4";
const luchaMaticStk = "0x0d008974359e5aD1B64c4edc4de3C46ED662b6D8";
const luchaMustStk = "0xe11f861dD5cE8407bb24dFD13b9710c0295276D6";

// ERC20
const LUCHA_polygon = "0x6749441Fdc8650b5b5a854ed255C82EF361f1596";
const MATIC_polygon = "0x0000000000000000000000000000000000001010";
const QI_polygon = "0x580A84C73811E1839F75d86d75d88cCa0c241fF4";
const MUST_polygon = "0x9C78EE466D6Cb57A4d01Fd887D2b5dFb2D46288f";
const PSP_polygon = "0x42d61D766B85431666B39B89C43011f24451bFf6";
const LINK_polygon = "0x53e0bca35ec356bd5dddfebbd1fc0fd03fabad39";
const WETH_polygon = "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619";
const VQI_polygon = "0xB424dfDf817FaF38FF7acF6F2eFd2f2a843d1ACA";
const GHST_polygon = "0x385eeac5cb85a38a9a07a70c73e0a3271cfb54a7";
const RAIDER_polygon = "0xcd7361ac3307d1c5a46b63086a90742ff44c63b3";
const AURUM_polygon = "0x34d4ab47bee066f361fa52d792e69ac7bd05ee23";

async function tvl(time, ethBlock, chainBlocks){
    const balances = {};
    const transform = await transformPolygonAddress();
    await sumTokensAndLPsSharedOwners(balances, [
        [MATIC_polygon, false],
        [QI_polygon, false],
        [MUST_polygon, false],
        [PSP_polygon, false],
        [VQI_polygon, false],
        [LINK_polygon, false],
        [WETH_polygon, false],
        [GHST_polygon, false],
        [RAIDER_polygon, false],
        [AURUM_polygon, false],
    ], [treasury, luchaStk, rewardPool, luchaMaticStk, luchaMustStk], chainBlocks.polygon, "polygon", transform);
    return balances;
}

module.exports={
    timetravel: true,
    polygon:{
        tvl,
        staking: staking(luchaStk, LUCHA_polygon, "polygon"),
        pool2: pool2s([luchaMaticStk, luchaMustStk], [LUCHA_MATIC_comethLp, LUCHA_MUST_comethLp], "polygon")
    },
    methodology: `- Staking : Players can stake their $LUCHA to earn $MASK and access in-game services or equipment.\r
    - Treasury : 100% of the funds collected during the first raffle (purchase of wearable) have been kept in treasury to build a long term economic strategy. Luchadores.io own 60% of LP token to improve liquidity and facilitate user swaps.\r
    - Reward Pool : 90% of the revenues generated in the game are redistributed to the players in this wallet (the 10% is shared between treasury and dev)\r`
}
'''
'''--- projects/luckychip/index.js ---
const { sumTokens } = require('../helper/unwrapLPs')
const sdk = require('@defillama/sdk')
const { transformBscAddress } = require('../helper/portedTokens');
const { staking } = require("../helper/staking");

const tokenHolderMap = [
    {
      tokens: [],
      holders: [
        "0x45218EDE6f026F0994C55b6Fa3554A8Ea989f819" // BNB table
      ],
      checkETHBalance: true,
    },
    {
      tokens: '0x55d398326f99059fF775485246999027B3197955',   // USDT
      holders: [
        "0x682ce0e340A0248B4554E14e834969F2E421dB2D" // USDT table
      ],
    }
]

const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"

function normalizeArray(arrayOrString){
    if(Array.isArray(arrayOrString)){
        return arrayOrString
    }else {
        return [arrayOrString]
    }
}

async function tvl(timestamp, ethBlock, chainBlocks) {
    const transform = await transformBscAddress();
    const block = chainBlocks.bsc;

    const tokensAndHolders = []
    let ethHolders = []
    for (const group of tokenHolderMap) {
        const holders = normalizeArray(group.holders);
        const tokens = normalizeArray(group.tokens)
        if (group.checkETHBalance === true) {
            ethHolders = ethHolders.concat(holders)
        }
        tokens.forEach(token => {
            holders.forEach(holder => {
                tokensAndHolders.push([token, holder])
            })
        })
    }

    const balances = {};
    await sumTokens(balances, tokensAndHolders, block, "bsc", transform);
    if (ethHolders.length > 0) {
        const ethBalances = await sdk.api.eth.getBalances({
            targets: ethHolders,
            block,
            chain: "bsc"
        })
        ethBalances.output.forEach(ethBal => {
            sdk.util.sumSingleBalance(balances, `bsc:${WBNB}`, ethBal.balance)
        })
    }
    return balances
}

const lcToken = '0x6012C3a742f92103d238F1c8306cF8fbcDEca8B3'
const masterChef = '0x15D2a6FC45aF66A2952dC27c40450C1F06A1eC2b';

// node test.js projects/luckychip/index.js
module.exports={
    misrepresentedTokens: false,
    methodology: 'TVL comes from the tables of LuckyChip for now.',
    bsc: {
        staking: staking(masterChef, lcToken, 'bsc'),
        tvl,
    }
}

'''
'''--- projects/lumenswap/index.js ---
const utils = require("../helper/utils");
const { getApiTvl } = require("../helper/historicalApi");

async function current() {
  var tvlAllPools = (
    await utils.fetchURL("https://api.lumenswap.io/amm/known-pools")
  ).data.map((t) => t.tvl);
  let tvl = 0;
  for (let tvlPool of tvlAllPools) {
    tvl += parseFloat(tvlPool);
  }
  return tvl;
}

function tvl(time) {
  return getApiTvl(time, current, async () => {
    const dayData = await utils.fetchURL(
      "https://api.lumenswap.io/amm/stats/overall"
    );
    return dayData.data.map((d) => ({
      date: Math.round(new Date(d.periodTime).getTime() / 1e3),
      totalLiquidityUSD: d.tvl,
    }));
  });
}

module.exports = {
  methodology:
    'TVL counts the liquidity of the Pools on AMM, data is pulled from the Lumenswap API:"https://api.lumenswap.io/amm/known-pools".',
  tvl,
};

'''
'''--- projects/luminous/index.js ---
const {
  getTokenBalance,
  getTrxBalance,
  unverifiedCall,
} = require("../helper/tron")

const stakingWaterContract = "THyHbFrG5wnxdp9Lv7AgwJ4k7Nt1dp2pzj";
const WATER = "TFMUZn349bztRCCkL2PAmkWfy23Gyn5g5r";

const stakingLumiContract = "TZD4xS3AFUixUwE28omTjeepCF6qUuxjCh";
const LUMI = "TDBNKiYQ8yfJtT5MDP3byu7f1npJuG2DBN";

async function Staking() {
  return {
    water: await getTokenBalance(WATER, stakingWaterContract),
    "lumi-credits": await getTokenBalance(LUMI, stakingLumiContract),
  };
}

const lumiFarm = "TJ6cgPpkri8cfrEh79TLdU2S16ugKHwAcW";
const waterLpToken = "TWH6NQ9tr28YoRdKuvcuQquVoEGrscPix4";

const waterFarm = "TY9mGUA8q1V9R9kmfUERpcG62SZ42gYuHW";
const lumiLpToken = "TUhZUbJaVicbQeNXHGBKxVsVuNL94usuoU";

async function Pool2() {
  const [
    waterLpTokenAmount,
    lumiLpTokenAmount,
    waterInLp,
    lumiInLp,
    trxInWaterLp,
    trxInLumiLp,
    waterLpTotalSupply,
    lumiLpTotalSupply,
  ] = await Promise.all([
    getTokenBalance(waterLpToken, lumiFarm),
    getTokenBalance(lumiLpToken, waterFarm),
    getTokenBalance(WATER, waterLpToken),
    getTokenBalance(LUMI, lumiLpToken),
    getTrxBalance(waterLpToken),
    getTrxBalance(lumiLpToken),
    unverifiedCall(waterLpToken, "totalSupply()", []),
    unverifiedCall(lumiLpToken, "totalSupply()", []),
  ]);

  return {
    water: (waterInLp * waterLpTokenAmount) / (waterLpTotalSupply / 10 ** 6),
    tron:
      (trxInWaterLp * waterLpTokenAmount) / waterLpTotalSupply +
      (trxInLumiLp * lumiLpTokenAmount) / lumiLpTotalSupply,
    "lumi-credits":
      (lumiInLp * lumiLpTokenAmount) / (lumiLpTotalSupply / 10 ** 6),
  };
}

module.exports = {
  tron: {
    staking: Staking,
    pool2: Pool2,
    tvl: (async) => ({}),
  },
};

'''
'''--- projects/luxor/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasury = "0xDF2A28Cc2878422354A93fEb05B41Bd57d71DB24"
const LUX = "0x6671e20b83ba463f270c8c75dae57e3cc246cb2b"

module.exports=ohmTvl(
    treasury,
    [
        ["0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e", false],
        ["0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83", false],
        ["0x46729c2AeeabE7774a0E710867df80a6E19Ef851", true],
        ["0x951BBB838e49F7081072895947735b0892cCcbCD", true]
    ],
    "fantom",
    "0xf3F0BCFd430085e198466cdCA4Db8C2Af47f0802",
    LUX,
    (addr) => {
        if (addr.toLowerCase() === "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e") {
          return "0x6b175474e89094c44da98b954eedeac495271d0f";
        }
        return `fantom:${addr}`;
    }
)

'''
'''--- projects/lydia/index.js ---
const { request, gql } = require("graphql-request");
const sdk = require('@defillama/sdk');
const { toUSDTBalances } = require('../helper/balances');
const graphUrl = 'https://api.thegraph.com/subgraphs/name/lydiacoder/lydia'

const graphQuery = gql`
query get_tvl($block: Int) {
  pangolinFactory(
    id: "0xe0C1bb6DF4851feEEdc3E14Bd509FEAF428f7655",
    block: { number: $block }
  ) {
        totalLiquidityETH
        totalLiquidityUSD
  },
  tokens(where: { symbol: "USDT" }, first:1) {
    derivedETH
  }
}
`;

async function tvl(timestamp) {
  const {block} = await sdk.api.util.lookupBlock(timestamp,{
    chain: 'avax'
  })
  const response = await request(
    graphUrl,
    graphQuery,
    {
      block,
    }
  );

  const usdTvl = Number(response.pangolinFactory.totalLiquidityETH) / Number(response.tokens[0].derivedETH)

  return toUSDTBalances(usdTvl)
}

module.exports = {
  misrepresentedTokens: true,
  avalanche:{
    tvl,
  },
  start: 0,
}

'''
'''--- projects/lyra/index.js ---
const { getBlock } = require('../helper/getBlock')
const { staking } = require('../helper/staking')
const { sumTokens } = require('../helper/unwrapLPs')

const v1_0_Pools = ['0x7Af4e1cE484f40D927b9C90fB6905Df4376fc3F6', '0xd7d974E81382D05E8D9fc6d0d17d0d852e9806dd']
const v1_1_LiquidityPool = [
    '0x2935CD347B79C319A6464fe3b1087170f142418C', 
    '0x69B4B35504a8c1d6179fef7AdDCDB37A8c663BC9', 
    '0x788843DE0Be1598155bFFaAB7Cfa2eCBd542E7f1'
]
const v1_1_ShortCollateral = [
    '0xE722F9aee66F649FBfc8CB0d4F906cb55803553c', 
    '0x585a72ccecde68dDFE5327B23134723a305D70F3', 
    '0x0A68E15f8E289b9f1Ad1BCAD524FeA30C6125c2D'
]

const pools = [...new Set([...v1_0_Pools, ...v1_1_LiquidityPool, ...v1_1_ShortCollateral].map(t=>t.toLowerCase()))]

const tokens = ['0x8c6f28f2f1a3c87f0f938b96d27520d9751ec8d9', '0xe405de8f52ba7559f9df3c368500b6e6ae6cee49',
    '0xc5db22719a06418028a40a9b5e9a7c02959d0d08', '0x298b9b95708152ff6968aafd889c6586e9169f1d']

const L2toL1Synths = {
    '0xe405de8f52ba7559f9df3c368500b6e6ae6cee49': '0x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb',
    '0x8c6f28f2f1a3c87f0f938b96d27520d9751ec8d9': '0x57ab1ec28d129707052df4df418d58a2d46d5f51',
    '0x298b9b95708152ff6968aafd889c6586e9169f1d': '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6',
    '0xc5db22719a06418028a40a9b5e9a7c02959d0d08': '0xbbc455cb4f1b9e4bfc4b73970d360c8f032efee6'
}

async function tvl(ttimestamp, _b, chainBlocks){
    const balances = {}
    const block = await getBlock(ttimestamp, 'optimism', chainBlocks)
    const transform = (addr)=>{
        return L2toL1Synths[addr] || addr;
    }
    await sumTokens(balances, tokens.map(t=>pools.map(p=>[t,p])).flat(), block, 'optimism', transform)
    return balances
}

module.exports = {
    methodology: 'TVL counts the option market locked synth value, along with USDC in safety module.',
    optimism:{
        tvl
    },
    ethereum:{
        tvl: staking("0x54d59c4596c7ea66fd62188ba1e16db39e6f5472", "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "ethereum"),
        staking: staking("0xb9619d73c08076bc5d4f0470593e98b9eb19a219", "0x01ba67aac7f75f647d94220cc98fb30fcc5105bf", "ethereum")
    },
 hallmarks:[
    [1635218174, "Lyra Token"],
    [1635822974, "Token Program Start"],
  ]
}

'''
'''--- projects/macaron/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IBEP20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardBlock",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accMacaronPerShare",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "isCLP",
        "type": "bool"
      },
      {
        "internalType": "contract ICakeStrategy",
        "name": "cakeStrategy",
        "type": "address"
      },
      {
        "internalType": "contract IBEP20",
        "name": "syrupToken",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "stakingToken": {
    "inputs": [],
    "name": "stakingToken",
    "outputs": [
      {
        "internalType": "contract IBEP20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpSupply": {
    "inputs": [],
    "name": "lpSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/macaron/config.js ---
const vaults_bsc = [
  {
    "sousId": 0,
    "stakingToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "earningToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "contractAddress": {
      "56": "0xCd59d44E94Dec10Bb666f50f98cD0B1593dC3a3A",
      "97": ""
    },
    "masterchef": {
      "56": "0x73feaa1eE314F8c655E354234017bE2193C9E24E",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "10",
    "sortOrder": 1,
    "isFinished": true
  },
  {
    "sousId": 1,
    "stakingToken": {
      "symbol": "BAKE",
      "address": {
        "56": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5",
        "97": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5"
      },
      "decimals": 18,
      "projectLink": "https://www.bakeryswap.org/"
    },
    "earningToken": {
      "symbol": "BAKE",
      "address": {
        "56": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5",
        "97": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5"
      },
      "decimals": 18,
      "projectLink": "https://www.bakeryswap.org/"
    },
    "contractAddress": {
      "56": "0xBB7ac3eB02c6d012cc8e2d916678De8843Eb8A56",
      "97": ""
    },
    "masterchef": {
      "56": "0x20eC291bB8459b6145317E7126532CE7EcE5056f",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.39375",
    "sortOrder": 1,
    "isFinished": true
  },
  {
    "sousId": 2,
    "stakingToken": {
      "symbol": "BANANA",
      "address": {
        "56": "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apeswap.finance/"
    },
    "earningToken": {
      "symbol": "BANANA",
      "address": {
        "56": "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apeswap.finance/"
    },
    "contractAddress": {
      "56": "0xd474366F6c80230507481495F3C1490e62E3093F",
      "97": ""
    },
    "masterchef": {
      "56": "0x5c8d727b265dbafaba67e050f2f739caeeb4a6f9",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "2.5",
    "sortOrder": 1,
    "isFinished": false
  },
  {
    "sousId": 3,
    "stakingToken": {
      "symbol": "BAKE",
      "address": {
        "56": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5",
        "97": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5"
      },
      "decimals": 18,
      "projectLink": "https://www.bakeryswap.org/"
    },
    "earningToken": {
      "symbol": "BAKE",
      "address": {
        "56": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5",
        "97": "0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5"
      },
      "decimals": 18,
      "projectLink": "https://www.bakeryswap.org/"
    },
    "contractAddress": {
      "56": "0x6dAc44A858Cb51e0d4d663A6589D2535A746607A",
      "97": ""
    },
    "masterchef": {
      "56": "0x6a8DbBfbB5a57d07D14E63E757FB80B4a7494f81",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.025315565",
    "sortOrder": 1,
    "isFinished": false
  }
]

const choco_pools_bsc = [
  {
    "sousId": 0,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0xFcDE390bF7a8B8614EC11fa8bde7565b3E64fe0b",
      "97": "0x09B7e4A3E9d3c5d5Da59B2F371ABC3a81Ff6c443"
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0715",
    "sortOrder": 1,
    "isFinished": false
  },
  {
    "sousId": 1,
    "stakingToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0xCded81aa5Ab3A433CadF77Fd5aC8B6fD973906e1",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0022",
    "sortOrder": 3,
    "isFinished": true,
    "isCLP": true,
    "syrupAddresses": {
      "56": "0x009cF7bC57584b7998236eff51b98A168DceA9B0",
      "97": ""
    }
  },
  {
    "sousId": 3,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "contractAddress": {
      "56": "0xF69bdcDB577F98753d4890Cc5aCfF3BE00177584",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.002",
    "sortOrder": 4,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 4,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "contractAddress": {
      "56": "0x7DB34B681c759918079C67EeF08868225F34fbcB",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.810185185",
    "sortOrder": 5,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 5,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "TBAKE",
      "address": {
        "56": "0x26d6e280f9687c463420908740ae59f712419147",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://bakerytools.io/"
    },
    "contractAddress": {
      "56": "0x13ED683DDf483d1f0bd2AE02b01D4d1D451D6c5b",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "1.099",
    "sortOrder": 6,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 6,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "BREW",
      "address": {
        "56": "0x790Be81C3cA0e53974bE2688cDb954732C9862e1",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://cafeswap.finance/"
    },
    "contractAddress": {
      "56": "0x0f819C8E6A7c0F0906CBc84b9b1e6642f9634E61",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.00498",
    "sortOrder": 5,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 7,
    "stakingToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "earningToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "contractAddress": {
      "56": "0x903A20CDbAC174250eAcc7437720929f0dE97B99",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.950347",
    "sortOrder": 7,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 8,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "Helmet",
      "address": {
        "56": "0x948d2a81086a075b3130bac19e4c6dee1d2e3fe8",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://www.helmet.insure/"
    },
    "contractAddress": {
      "56": "0x82cF07a989835b68260989F13Bc853f8fe48ad04",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.06510416",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 9,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "HOTCROSS",
      "address": {
        "56": "0x4FA7163E153419E0E1064e418dd7A99314Ed27b6",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://www.hotcross.com/"
    },
    "contractAddress": {
      "56": "0xc8De98F603af53a5D52AF6AA153d9e15b0002B2c",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0992476",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 10,
    "stakingToken": {
      "symbol": "SMG",
      "address": {
        "56": "0x6bfd576220e8444ca4cc5f89efbd7f02a4c94c16",
        "97": ""
      },
      "decimals": 8,
      "projectLink": "https://smaugs.com/"
    },
    "earningToken": {
      "symbol": "SMG",
      "address": {
        "56": "0x6bfd576220e8444ca4cc5f89efbd7f02a4c94c16",
        "97": ""
      },
      "decimals": 8,
      "projectLink": "https://smaugs.com/"
    },
    "contractAddress": {
      "56": "0xf3D514263239672455306D188DD5f045E61deD03",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.138",
    "sortOrder": 3,
    "isFinished": true,
    "isCLP": false
  },
  {
    "sousId": 11,
    "stakingToken": {
      "symbol": "SMG",
      "address": {
        "56": "0x6bfd576220e8444ca4cc5f89efbd7f02a4c94c16",
        "97": ""
      },
      "decimals": 8,
      "projectLink": "https://smaugs.com/"
    },
    "earningToken": {
      "symbol": "SMG",
      "address": {
        "56": "0x6bfd576220e8444ca4cc5f89efbd7f02a4c94c16",
        "97": ""
      },
      "decimals": 8,
      "projectLink": "https://smaugs.com/"
    },
    "contractAddress": {
      "56": "0xC85C50988AEC8d260853443B345CAE63B7432b7A",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.138",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 12,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "DUEL",
      "address": {
        "56": "0x297817ce1a8de777e7ddbed86c3b7f9dc9349f2c",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://www.duel.network/"
    },
    "contractAddress": {
      "56": "0xF60EDbF7D95E79878f4d448F0CA5622479eB8790",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.11574",
    "sortOrder": 2,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 13,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "contractAddress": {
      "56": "0x99d3334CC9dF44Fb2788C2161FB296fb6Cf14a57",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.001",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 14,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "wBNB",
      "address": {
        "56": "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
        "97": "0xae13d989dac2f0debff460ac112a837c89baa7cd"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0xD80bdF70b17bA4fDd0383171623D782D00c8be2E",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.000011574",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": true
  },
  {
    "sousId": 15,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "contractAddress": {
      "56": "0x28D0e8f18FA73824C91ca77e28727d79b815aEF1",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0008",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": true
  },
  {
    "sousId": 16,
    "stakingToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "earningToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "contractAddress": {
      "56": "0xa71aFD72A7ed03d2ad9D08A20cdadf17b067f33a",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.81",
    "sortOrder": 6,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 17,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "TAPE",
      "address": {
        "56": "0xf63400ee0420ce5b1ebdee0c942d7de1c734a41f",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apetools.co/"
    },
    "contractAddress": {
      "56": "0x765c1a0b22130d0e8a61dbb125c1eec5710383f1",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.81",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": true
  },
  {
    "sousId": 18,
    "stakingToken": {
      "symbol": "BANANA",
      "address": {
        "56": "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://apeswap.finance/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0x4f0a992B465C1D8482b4E2a0861B6cAEE8B3171f",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "",
    "sortOrder": 4,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": false,
    "isBBChef": true
  },
  {
    "sousId": 19,
    "stakingToken": {
      "symbol": "BSW",
      "address": {
        "56": "0x965F527D9159dCe6288a2219DB51fc6Eef120dD1",
        "97": ""
      },
      "decimals": 18,
      "projectLink": "https://biswap.org/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0x2a1Bf8e04633e397207d63F234d281fEf781B6F5",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "",
    "sortOrder": 4,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": false,
    "isBBChef": true
  },
  {
    "sousId": 20,
    "stakingToken": {
      "symbol": "CAKE",
      "address": {
        "56": "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82",
        "97": "0xa35062141Fa33BCA92Ce69FeD37D0E8908868AAe"
      },
      "decimals": 18,
      "projectLink": "https://pancakeswap.finance/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "56": "0xacb2d47827c9813ae26de80965845d80935afd0b",
        "97": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "56": "0x7C454456fc9E86EA1cF1e524FF8B8EbA613189E5",
      "97": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "",
    "sortOrder": 1,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": false,
    "isBBChef": true
  }
]

const choco_pools_polygon = [
  {
    "sousId": 0,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "137": "0xC200cE4853d97e5f11320Bb8ee17F4D895f5e7BB",
      "80001": "0xcE702936B63B6C9c3E059b315807BbE6212F1647"
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0085",
    "sortOrder": 1,
    "isFinished": false
  },
  {
    "sousId": 1,
    "stakingToken": {
      "symbol": "QUICK",
      "address": {
        "137": "0x831753dd7087cac61ab5644b308642cc1c33dc13",
        "80001": ""
      },
      "decimals": 18,
      "projectLink": "https://quickswap.exchange/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "137": "0xDeC7950840a32010410dcfFDC735911151604Ba5",
      "80001": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.002",
    "sortOrder": 2,
    "isFinished": true,
    "isCLP": true,
    "syrupAddresses": {
      "137": "0xf28164A485B0B2C90639E47b0f377b4a438a16B1",
      "80001": ""
    }
  },
  {
    "sousId": 2,
    "stakingToken": {
      "symbol": "QUICK",
      "address": {
        "137": "0x831753dd7087cac61ab5644b308642cc1c33dc13",
        "80001": ""
      },
      "decimals": 18,
      "projectLink": "https://quickswap.exchange/"
    },
    "earningToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "137": "0x4b68bA327Cad4d8C4d0Bc783d686d08CFAa5C5D3",
      "80001": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.002",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": true,
    "syrupAddresses": {
      "137": "0xf28164A485B0B2C90639E47b0f377b4a438a16B1",
      "80001": ""
    }
  },
  {
    "sousId": 3,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "QUICK",
      "address": {
        "137": "0x831753dd7087cac61ab5644b308642cc1c33dc13",
        "80001": ""
      },
      "decimals": 18,
      "projectLink": "https://quickswap.exchange/"
    },
    "contractAddress": {
      "137": "0xdb5640313fc4c958D3Fb2CF546d57dF142882acf",
      "80001": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0000125",
    "sortOrder": 4,
    "isFinished": false,
    "isCLP": false
  },
  {
    "sousId": 4,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "QUICK",
      "address": {
        "137": "0x831753dd7087cac61ab5644b308642cc1c33dc13",
        "80001": ""
      },
      "decimals": 18,
      "projectLink": "https://quickswap.exchange/"
    },
    "contractAddress": {
      "137": "0x337CC5daBaf1f874ACec0031d3d682CAF6DD2FC8",
      "80001": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.0000125",
    "sortOrder": 3,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": true
  },
  {
    "sousId": 5,
    "stakingToken": {
      "symbol": "MCRN",
      "address": {
        "137": "0xba25b552c8a098afdf276324c32c71fe28e0ad40",
        "80001": "0xfb53da50e544b06ecdc6827ab0df60a3b3801021"
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "earningToken": {
      "symbol": "wMATIC",
      "address": {
        "137": "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
        "80001": ""
      },
      "decimals": 18,
      "projectLink": "https://macaronswap.finance/"
    },
    "contractAddress": {
      "137": "0xA7661a7aeAF507a7782C230a45a002519cFC158C",
      "80001": ""
    },
    "poolCategory": "Core",
    "harvest": true,
    "tokenPerBlock": "0.00195216",
    "sortOrder": 2,
    "isFinished": false,
    "isCLP": false,
    "isLockPool": true
  }
]

module.exports = {
  bsc: {
    masterchef: '0xFcDE390bF7a8B8614EC11fa8bde7565b3E64fe0b',
    token: '0xacb2d47827c9813ae26de80965845d80935afd0b'.toLowerCase(),
    chocochef: 'https://api.macaronswap.finance/chocofalls?chainId=56',
    pools: choco_pools_bsc,
    masterchefPools: 'https://api.macaronswap.finance/magicboxes?chainId=56',
    vaults: 'https://api.macaronswap.finance/boostpools',
    vaults_json: vaults_bsc,
    LPs: [
      '0xe8D5d81dac092Ae61d097f84EFE230759BF2e522'.toLowerCase(),
      '0xc8f900cd8052862a8a5abf9278ad088611b2bd04'.toLowerCase(),
    ],
    erc20s: [
      //MCRN
      // "0xacb2d47827c9813ae26de80965845d80935afd0b",
      //BANANA
      "0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95",
      //CAKE
      "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82",

    ],
    treasury: "0x67f1D48a8991009e0b092e9C34ca16f7d6072ec1",
    chainId: 56,
  },
  polygon: {
    masterchef: '0xC200cE4853d97e5f11320Bb8ee17F4D895f5e7BB',
    token: '0xba25b552c8a098afdf276324c32c71fe28e0ad40'.toLowerCase(),
    chocochef: 'https://api.macaronswap.finance/chocofalls?chainId=137',
    pools: choco_pools_polygon,
    LPs: [
      '0xfc53defcF4e21B868DaCEAA6350D507493F57110'.toLowerCase(),
      '0xde84c8f0562eB56A5fc8f07819cEF1FAf9Df3EBc'.toLowerCase(),
    ],
    masterchefPools: 'https://api.macaronswap.finance/magicboxes?chainId=137',
    chainId: 137,
  }
}

'''
'''--- projects/macaron/index.js ---
const abi = require("./abi.json");
const config = require("./config");
const { sumTokens, unwrapUniswapLPs, } = require("../helper/unwrapLPs");
const sdk = require("@defillama/sdk");

const { getChainTransform, } = require("../helper/portedTokens");

module.exports = {}

function setChainTVL(chain) {
  const { masterchef, pools, vaults_json, chainId, treasury, erc20s, LPs, token, } = config[chain]
  let getTvl

  async function getAllTVL(ts, _block, chainBlocks) {
    const transform = await getChainTransform(chain)
    const block = chainBlocks[chain]
    const balances = {
      treasury: {},
      tvl: {},
      staking: {},
      pool2: {},
    }

    const lengthOfPool = (
      await sdk.api.abi.call({
        abi: abi.poolLength,
        target: masterchef,
        chain, block,
      })
    ).output

    const lpPositionCalls = [];

    for (let index = 0; index < lengthOfPool; index++)
      lpPositionCalls.push({ params: [index] })

    const { output: mcPools } = await sdk.api.abi.multiCall({
      target: masterchef, calls: lpPositionCalls, block, chain, abi: abi.poolInfo
    })

    const masterchefPools = []

    mcPools.forEach(({ output }) => {
      masterchefPools.push(output)
    })

    if (treasury) {
      let toa = erc20s.map(token => [token, treasury])
      balances.treasury = await sumTokens({}, toa, block, chain)
    }

    const toaTvl = []
    const toaSyrup = []
    const toaPool2 = []
    const toaStaking = []
    const syrupMapping = {}

    // handle masterchef
    masterchefPools.forEach(pool => {
      const addr = pool.lpToken.toLowerCase()
      if (pool.isCLP) {
        const syrup = pool.syrupToken.toLowerCase()
        toaSyrup.push([syrup, masterchef])
        syrupMapping[syrup] = addr
        return;
      }
      if (addr === token)
        toaStaking.push([addr, masterchef])
      else if (LPs.includes(addr))
        toaPool2.push([addr, masterchef])
      else
        toaTvl.push([addr, masterchef])
    })

    // handle chocochef and boost pools
    if (vaults_json)
      pools.push(...vaults_json)

    pools.forEach(pool => {
      const symbol = pool.stakingToken?.symbol?.toLowerCase()
      const masterchef = pool.contractAddress[chainId].toLowerCase()
      const addr = pool.stakingToken.address[chainId].toLowerCase()
      if (symbol === 'mcrn')
        toaStaking.push([addr, masterchef])
      else if (symbol.includes('mcrn') && symbol.endsWith('lp'))
        toaPool2.push([addr, masterchef])
      else
        toaTvl.push([addr, masterchef])
    })

    const balanceCalls = toaSyrup.map(([token, address]) => ({ target: token, params: [address] }))
    const { output: syrupBalances } = await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf', calls: balanceCalls, block, chain
    })

    const lpPositions = []
    syrupBalances.forEach(({ input, output }) => {
      lpPositions.push({
        token: syrupMapping[input.target],
        balance: output
      })
    })

    await sumTokens(balances.tvl, toaTvl, block, chain, transform, { resolveLP: true })
    await sumTokens(balances.pool2, toaPool2, block, chain, transform, { resolveLP: true })
    await sumTokens(balances.staking, toaStaking, block, chain, transform, { resolveLP: false })
    await unwrapUniswapLPs(balances.tvl, lpPositions, block, chain, transform)
    return balances
  }

  function getTvlFunction(key) {
    return async (ts, _block, chainBlocks) => {
      if (!getTvl) getTvl = getAllTVL(ts, _block, chainBlocks)
      return (await getTvl)[key]
    }
  }

  const chainExports = {
    tvl: getTvlFunction('tvl'),
    pool2: getTvlFunction('pool2'),
    treasury: getTvlFunction('treasury'),
    staking: getTvlFunction('staking'),
  }

  module.exports[chain] = chainExports
}

Object.keys(config).forEach(setChainTVL)
'''
'''--- projects/magicland/index.js ---
const sdk = require("@defillama/sdk");
const { transformArbitrumAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require('../helper/masterchef');
const IOTEX_CG_MAPPING = require("./iotex_coingecko_mapping.json")
const STAKING_CONTRACT_ARBITRUM = "0x6b614684742717114200dc9f30cBFdCC00fc73Ec";
const STAKING_CONTRACT_IOTEX = "0x9B4CF5d754455fD3Bc4212DCFF1b085DBCd5b0c0";

function compareAddresses(a, b){
    return a.toLowerCase() === b.toLowerCase()
}

async function transformIotexAddress() {
    return (addr) => {
        const dstToken = Object.keys(IOTEX_CG_MAPPING).find(token => compareAddresses(addr, token))
        if (dstToken !== undefined) {
            return IOTEX_CG_MAPPING[dstToken].contract || IOTEX_CG_MAPPING[dstToken].coingeckoId
        }
        return `iotex:${addr}`; 
    }
}

function fixIotexBalances(balances){
    for(const representation of ["game-fantasy-token", 'metanyx', 'imagictoken']){
        if(balances[representation] !== undefined){
            balances[representation] = Number(balances[representation])/1e18
        }
    }
}

const arbitrumTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};
  const transformAddress = await transformArbitrumAddress();

  await addFundsInMasterChef(
      balances, STAKING_CONTRACT_ARBITRUM, chainBlocks.arbitrum, 'arbitrum', transformAddress);
  delete balances['0x2c852d3334188be136bfc540ef2bb8c37b590bad'];
  delete balances['0x2c852D3334188BE136bFC540EF2bB8C37b590BAD'];

  return balances;
};

const iotexTvl = async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};
    const transformAddress = await transformIotexAddress();
    
    await addFundsInMasterChef(
        balances, STAKING_CONTRACT_IOTEX, chainBlocks.iotex, 'iotex', transformAddress);

    fixIotexBalances(balances);

    return balances;
};

module.exports={
    timetravel: true, //no archive node
    arbitrum: {
        tvl: arbitrumTvl
    },
    iotex: {
        tvl: iotexTvl
    },
}

'''
'''--- projects/magicland/iotex_coingecko_mapping.json ---
{
    "0x3cdb7c48e70b854ed2fa392e21687501d84b3afc": {
        "contract": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "coingeckoId": "tether"
    },
    "0x6fbcdc1169b5130c59e72e51ed68a84841c98cd1": {
        "contract": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "coingeckoId": "tether"
    },
    "0x3fe04320885e6124231254c802004871be681218": {
        "contract": "0xd91e9a0fef7c0fa4ebdaf4d0acf55888949a2a9b",
        "coingeckoId": "mcn-ventures"
    },
    "0x4d7b88403aa2f502bf289584160db01ca442426c": {
        "contract": "0x8861cff2366c1128fd699b68304ad99a0764ef9a",
        "coingeckoId": "cyclone-protocol"        
    },
    "0x0258866edaf84d6081df17660357ab20a07d0c80": {
        "contract": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
        "coingeckoId": "ethereum"     
    },
    "0xc7b93720f73b037394ce00f954f849ed484a3dea": {
        "contract": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "coingeckoId": "bitcoin"     
    },
    "0x62a9d987cbf4c45a550deed5b57b200d7a319632": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"   
    },
    "0xacee9b11cd4b3f57e58880277ac72c8c41abe4e4": {
        "contract": "0x4fabb145d64652a948d72533023f6e7a623c7c53",
        "coingeckoId": "iobusd"           
    },
    "0x84abcb2832be606341a50128aeb1db43aa017449": {
        "contract": "0x4fabb145d64652a948d72533023f6e7a623c7c53",
        "coingeckoId": "binance-usd"           
    },
    "0x3b2bf2b523f54c4e454f08aa286d03115aff326c":{
        "contract": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "coingeckoId": "usdc"         
    },
    "0x17df9fbfc1cdab0f90eddc318c4f6fcada730cf2":{
        "contract": "",
        "coingeckoId": "game-fantasy-token"         
    },
    "0x4752456e00def6025c77b55a88a2f8a1701f92f9":{
        "contract": "",
        "coingeckoId": "metanyx"         
    },
    "0x490cfbf9b9c43633ddd1968d062996227ef438a9":{
        "contract": "",
        "coingeckoId": "imagictoken"         
    },
    "0xa00744882684c3e4747faefd68d283ea44099d03":{
        "contract": "bsc:0x9678E42ceBEb63F23197D726B29b1CB20d0064E5",
        "coingeckoId": "wrapped-iotex"         
    },
    "0x99b2b0efb56e62e36960c20cd5ca8ec6abd5557a":{
        "contract": "polygon:0x300211def2a644b036a9bdd3e58159bb2074d388",
        "coingeckoId": "crosschain-iotx"         
    }
}

'''
'''--- projects/magik-finance/index.js ---
const { tombTvl } = require("../helper/tomb");

const magik = "0x87a5c9b60a3aaf1064006fe64285018e50e0d020";
const mshare = "0xc8ca9026ad0882133ef126824f6852567c571a4e";
const masonry = "0xac55a55676657d793d965ffa1ccc550b95535634";
const rewardPool = "0x38f006eb9c6778d02351fbd5966f829e7c4445d7";
const pool2LPs = [
    "0xdc71a6160322ad78dab0abb47c7a581cfe9709ee",
    "0x392c85ceccf9855986b0044a365a5532aec6fa31"
]

module.exports = {
    misrepresentedTokens: true,
    ...tombTvl(magik, mshare, rewardPool, masonry, pool2LPs, "fantom", undefined, false, pool2LPs[1])
}
'''
'''--- projects/magnet-dao/index.js ---
const { ohmTvl } = require("../helper/ohm");

const token = "0x1d60109178C48E4A937D8AB71699D8eBb6F7c5dE";
const staking = "0x587CB56D9d52C80267ca36c774eCECA98dEEc831"
const treasury = "0xD5310653Bf047503d30178CF4732BFfE3F2A4CD0";
const treasuryTokens = [
    ["0x130966628846bfd36ff31a822705796e8cb8c18d", false], // MIM
    ["0xd66b92fd29a6e1f9a1ccb8075a88d955fa4a409d", true] // MAG-MIM JLP
]

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "avax", staking, token)
}
'''
'''--- projects/mahadao/bsc.js ---
const { sumTokens } = require("../helper/unwrapLPs.js");
const { unwrapTroves } = require("../helper/unwrapLPs");

const bscTokens = require("./bscTokens.json");
Object.keys(bscTokens).forEach(
  (key) => (bscTokens[key] = bscTokens[key].toLowerCase())
);

const chain = "bsc";

async function pool2(_timestamp, _ethBlock, chainBlocks) {
  const balances = {};
  const block = chainBlocks[chain];
  const tokensAndOwners = [
    [bscTokens.ARTHBUSDLP, bscTokens.ARTHBUSDBasicStaking],
    [bscTokens.ARTHMAHAApeLP, bscTokens.ARTHMAHAApeLPStaking],
    [bscTokens.ARTHMAHALP, bscTokens.ARTHMAHABasicStaking],
    [bscTokens.ARTHuval3PS, bscTokens.ARTHuval3PSBasicStaking],
    [bscTokens.ARTHuval3PS, bscTokens.ARTHu3PXBasicStakingV2], // ellipsis masterchef, tvl belongs to them? SE: contains ARTH our stablecoin; we pay bribes for this tvl
    [bscTokens.ARTHu3PS, bscTokens.ARTHu3PSBasicStakingV2],
    [bscTokens.ARTHuval3PS, bscTokens.ARTHuval3PSDotBasicStaking], // ellipsis masterchef? SE: contains ARTH our stablecoin
  ];

  return sumTokens(balances, tokensAndOwners, block, chain, undefined, {
    resolveLP: true,
  });
}

async function tvl(ts, _block, chainBlocks) {
  const balances = {};
  const chain = "bsc";
  const block = chainBlocks[chain];
  const troves = [
    // troves
    "0x8F2C37D2F8AE7Bce07aa79c768CC03AB0E5ae9aE", // wbnb
    "0x1Beb8b4911365EabEC68459ecfe9172f174BF0DB", // busd
    "0xD31AC58374D4a0b3C58dFF36f2F59A22348159DB", // maha
    "0x0f7e695770e1bc16a9a899580828e22b16d93314", // BUSDUSDC-APE-LP
    "0x7A535496c5a0eF6A9B014A01e1aB9d7493F503ea", // BUSDUSDT-APE-LP
    "0x3a00861B7040386b580A4168Db9eD5D4D9dDa7BF", // BUSDUSDC-APE-LP-S
    "0x45Bc65D7Bb6d26676D12aC4646c8cC344DCe4e60", // BUSDUSDT-APE-LP-S
    "0x7cce62085AdEFa3fE9572546fD77fF1aA1088BEc", // BUSD-A
  ];
  await unwrapTroves({ balances, troves, chain, block });
  return balances;
}

module.exports = {
  pool2,
  tvl,
};

'''
'''--- projects/mahadao/bscTokens.json ---
{
  "3EPS": "0xaF4dE8E872131AE328Ce21D909C74705d3Aaf452",
  "3EPS-S": "0x26Da98b819e2b095E568237811923a8f84aEcB9C",
  "ARTH": "0xB69A424Df8C737a122D0e60695382B3Eec07fF4B",
  "ARTH.usd": "0x88fd584df3f97c64843cd474bdc6f78e398394f4",
  "ARTHBUSDBasicStaking": "0xe8b16cab47505708a093085926560a3eb32584b8",
  "ARTHBUSDLP": "0x80342bc6125a102a33909d124a6c26CC5D7b8d56",
  "ARTHMAHAApeLP": "0x84020eefe28647056eac16cb16095da2ccf25665",
  "ARTHMAHAApeLPStaking": "0x1599a0A579aD3Fc86DBe6953dfEc04eb365dd8e6",
  "ARTHMAHABasicStaking": "0x7699d230Ba47796fc2E13fba1D2D52Ecb0318c33",
  "ARTHMAHALP": "0xb955d5b120ff5b803cdb5a225c11583cd56b7040",
  "ARTHStablecoin": "0xB69A424Df8C737a122D0e60695382B3Eec07fF4B",
  "ARTHu3PS": "0xB38B49bAE104BbB6A82640094fd61b341a858f78",
  "ARTHuval3PS": "0x4cfaabd5920021359bb22bb6924cce708773b6ac",
  "ARTHuval3PSBasicStaking": "0x41efe9AD56D328449439c330b327Ca496C3e38BB",
  "ARTHuval3PSDotBasicStaking": "0x8189f0afdbf8fe6a9e13c69ba35528ac6abeb1af",
  "ARTHu3PSBasicStaking": "0x8fF204D06B39a19Bd8c8367302bfCB329214c14B",
  "ARTHu3PSBasicStakingV2": "0x6398C73761a802a7Db8f6418Ef0a299301bC1Fb0",
  "ARTHu3PXBasicStakingV2": "0x5b74c99aa2356b4eaa7b85dc486843edff8dfdbe",
  "ARTHusd3Pool": "0x98245Bfbef4e3059535232D68821a58abB265C45",
  "BUSD": "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
  "BUSDActivePool": "0x5479FB6a786c47227D355711154474989Ee76199",
  "BUSDBorrowerOperations": "0x36a669C9CF3e225c5F73efe065074f7D88a69fd8",
  "BUSDCollSurplusPool": "0x852a3Da0d262d4BC2B158b2BE040e0ceA0080f52",
  "BUSDCommunityIssuance": "0x77BFA6B2002146189946d2Ac32A2CF7915137699",
  "BUSDDefaultPool": "0xE22f6e5d350bf08F37525C9bfBff8A0391Bd1336",
  "BUSDGasPool": "0x138eD4d36899E57eD2d3B9e63f6710B711933258",
  "BUSDGovernance": "0x0CcA215E221154Fa5124d231CC9ea404C8540A2E",
  "BUSDHintHelpers": "0xd0d2DBdb27598fb2214bD6FB270560046A2Ff9A4",
  "BUSDLQTYStaking": "0x89069b7367162ffdF899Cf4E4eD6e951085f2312",
  "BUSDLQTYToken": "0x1D2400b674A886df9793290f65ff5A8d41c92CB8",
  "BUSDLockupContractFactory": "0xf672d00dDE62398B65Dd5b6CCc1Ca2188cb01cF9",
  "BUSDMultiTroveGetter": "0xa0c8c46F2859D3Cad9930806f5c125F8AB355162",
  "BUSDPriceFeed": "0x97651d5188af954ce1402Ca7288D6F74A6F5f09e",
  "BUSDSortedTroves": "0xCaD79d1a13A4c5290f5a6103043Bcf3129f6A5ed",
  "BUSDStabilityPool": "0xbF1a668501Ac288CfEaE57A2Eae7b5544d5B8A2D",
  "BUSDTroveManager": "0x1Beb8b4911365EabEC68459ecfe9172f174BF0DB",
  "BUSDTroveManagerImplementation": "0xCAdB73289F350E474744f9c930E988FB24B10e1e",
  "BUSDUSDC-APE-LP": "0xc087c78abac4a0e900a327444193dbf9ba69058e",
  "BUSDUSDC-APE-LP-S": "0xBb9858603B1FB9375f6Df972650343e985186Ac5",
  "BUSDUSDC-APE-LP-SPriceFeed": "0x6852F8bB8a476fCAD8D6a54aF4a1A61B29146484",
  "BUSDUSDC-APE-LP-S-Strategy": "0x5bAD523767e860308e468Cad4A68f73909284f68",
  "BUSDUSDC-APE-LP-S-V1-Strategy": "0x3F893bc356eC4932A1032588846F4c5e3BC670Dc",
  "BUSDUSDC-APE-LP-S-V1ActivePool": "0xb1CD1aBA6fB389aDDf2C87E72F391C8c25B46Fa3",
  "BUSDUSDC-APE-LP-S-V1BorrowerOperations": "0x3f3cdCC49599600EeaF7c6e11Da2E377BDEE95cA",
  "BUSDUSDC-APE-LP-S-V1CollSurplusPool": "0x531F1e386a1983599Dc850da525Bf8dEc5efcff8",
  "BUSDUSDC-APE-LP-S-V1CommunityIssuance": "0x8B2a55B10f88fc9A5a83a390CD0f458fecEF44fE",
  "BUSDUSDC-APE-LP-S-V1DefaultPool": "0xCdd2b660a5b41fd3845627C52749b486f17F90f7",
  "BUSDUSDC-APE-LP-S-V1GasPool": "0x7aC9dCd8B037F171F4b6497060115C55FbC4b749",
  "BUSDUSDC-APE-LP-S-V1Governance": "0x71C19F09037a9b8e6454f7F46fb720B45Ee15E05",
  "BUSDUSDC-APE-LP-S-V1HintHelpers": "0x6E55CFcE86B1157632e97ed578D039110d3A08f8",
  "BUSDUSDC-APE-LP-S-V1LQTYStaking": "0xf916aC0B74F6081Fea0A713214AB14e1aCDE255b",
  "BUSDUSDC-APE-LP-S-V1LQTYToken": "0xa885Fa48B2be6A98c17D40Dc82419430FA5d07ea",
  "BUSDUSDC-APE-LP-S-V1LockupContractFactory": "0xe1cF24Fb7cE7E951132D699EE67aE4aB3422Fd39",
  "BUSDUSDC-APE-LP-S-V1MultiTroveGetter": "0xe2e0db2d71038a08a4C6989dB97A902aE581BB10",
  "BUSDUSDC-APE-LP-S-V1PriceFeed": "0x6852F8bB8a476fCAD8D6a54aF4a1A61B29146484",
  "BUSDUSDC-APE-LP-S-V1SortedTroves": "0xfE85216454b78c119163fa34Ab3EebA34556C450",
  "BUSDUSDC-APE-LP-S-V1StabilityPool": "0xb222A3CC881e813F36C5FaEeF078E59E207eD235",
  "BUSDUSDC-APE-LP-S-V1TroveManager": "0x0F7e695770E1bC16a9A899580828e22B16d93314",
  "BUSDUSDC-APE-LP-S-V1TroveManagerImplementation": "0x21F2c7a2E91842961a66c729b96844a7c608D633",
  "BUSDUSDC-APE-LP-SActivePool": "0xEc490BA870468090f8D55B532C2F36B2846A5a9C",
  "BUSDUSDC-APE-LP-SBorrowerOperations": "0x7E44bba0078a7FC557E7722046a663df45B6dfDd",
  "BUSDUSDC-APE-LP-SCollSurplusPool": "0x857E29CBBC7F345A0C589a97c60Cf7e20b871108",
  "BUSDUSDC-APE-LP-SDefaultPool": "0x43508Dc4C2E40A65500B8309AA58F2c7b8228937",
  "BUSDUSDC-APE-LP-SGasPool": "0xecDC8ecB0394548D82D5b05A6a7ECb407A60eB51",
  "BUSDUSDC-APE-LP-SGovernance": "0x33aC8dCA19cD517604cAE730Fe67Fc2DA0A6abf4",
  "BUSDUSDC-APE-LP-SHintHelpers": "0x069d7dC472D498A5743f6487513C5a0eE8344396",
  "BUSDUSDC-APE-LP-SMultiTroveGetter": "0x6b88E9b3958134158Ba751c3c3db7a6432D12F0c",
  "BUSDUSDC-APE-LP-SSortedTroves": "0x4D9c5586b02a8fd02709A1E2e3EC87Ea533Ea322",
  "BUSDUSDC-APE-LP-SStabilityPool": "0xe070b1F9FA7De50049D3A38E9726815DAD81b2cf",
  "BUSDUSDC-APE-LP-STroveManager": "0x3a00861B7040386b580A4168Db9eD5D4D9dDa7BF",
  "BUSDUSDT-APE-LP": "0x2e707261d086687470b515b320478eb1c88d49bb",
  "BUSDUSDT-APE-LP-S": "0xc5FB6476a6518dd35687e0Ad2670CB8Ab5a0D4C5",
  "BUSDUSDT-APE-LP-S-Strategy": "0x2DA34C400ea606Bb5b1A715e5cc02d6E4FBaA869",
  "BUSDUSDT-APE-LP-S-V1-Strategy": "0x78DE5b23734EEbF408CEe5c06E51827e03bCD98d",
  "BUSDUSDT-APE-LP-S-V1ActivePool": "0x3c79637A9B626118e3bAa2535581b78269c4c91e",
  "BUSDUSDT-APE-LP-S-V1BorrowerOperations": "0xE4E773433Be8cc3ABDa9Bb5393C97336F27AE76b",
  "BUSDUSDT-APE-LP-S-V1CollSurplusPool": "0x088459186da49A6b3c2130c701a1d56C88D41B2d",
  "BUSDUSDT-APE-LP-S-V1CommunityIssuance": "0x7d758c24dD1a0eA5bd754D991e4ad9D300625765",
  "BUSDUSDT-APE-LP-S-V1DefaultPool": "0xdC0707DE5fF59977427F627ADd61c61bCb25155C",
  "BUSDUSDT-APE-LP-S-V1GasPool": "0x7774EB1529743C604808db2B76ac5e21143F4860",
  "BUSDUSDT-APE-LP-S-V1Governance": "0x33ca71a5d2A714921A60D1567E38e59110111d38",
  "BUSDUSDT-APE-LP-S-V1HintHelpers": "0xb54cc6ce3AC57D003e2EeB47206c18E23d38eC3C",
  "BUSDUSDT-APE-LP-S-V1LQTYStaking": "0xdd2f09a595F6392674900148E68F8D1F440A379e",
  "BUSDUSDT-APE-LP-S-V1LQTYToken": "0xc2B738307De2e9A1f00b611A0a4d039d9c997fC2",
  "BUSDUSDT-APE-LP-S-V1LockupContractFactory": "0xc147DaB2c9C3c313429769B14D06e6Be400f2a92",
  "BUSDUSDT-APE-LP-S-V1MultiTroveGetter": "0xF33844519F76b1D1fe2D6403a9FAeb1eF1A750f9",
  "BUSDUSDT-APE-LP-S-V1PriceFeed": "0x93dAe7A7763f95eC86006D9f38A497773ce47380",
  "BUSDUSDT-APE-LP-S-V1SortedTroves": "0x5334019952b9621E6E163759535EB3E575BB49B5",
  "BUSDUSDT-APE-LP-S-V1StabilityPool": "0xa536eA1A442D46b112A6376C88b11bBBa540f808",
  "BUSDUSDT-APE-LP-S-V1TroveManager": "0x7A535496c5a0eF6A9B014A01e1aB9d7493F503ea",
  "BUSDUSDT-APE-LP-S-V1TroveManagerImplementation": "0x8EDC060089D08D2C192E2649d059c5eF6986a4C0",
  "BUSDUSDT-APE-LP-SActivePool": "0x0410d549f37FA1954CF2349FaC1C8270184c4582",
  "BUSDUSDT-APE-LP-SBorrowerOperations": "0xc54194a22e5E401c584d17564dD265c0ae5F247d",
  "BUSDUSDT-APE-LP-SCollSurplusPool": "0x0b518d9B00e8e95911569ac90664Fa567a4a8956",
  "BUSDUSDT-APE-LP-SDefaultPool": "0x26ed66Fcebeb3cA907fe3fc301767B61189e6763",
  "BUSDUSDT-APE-LP-SGasPool": "0xA169041bC1Aaf68b3B3ae7D2e2995cA419D15f4e",
  "BUSDUSDT-APE-LP-SGovernance": "0xFCd4c9c878a44F41e0acaB0D10ADca7a0A29349A",
  "BUSDUSDT-APE-LP-SHintHelpers": "0x2BF72A5FDA4B4AE15d07f1ee4bb9a1c83908E46C",
  "BUSDUSDT-APE-LP-SMultiTroveGetter": "0x935c70e4B9371f63A598BdA58BF1B2b270C8eBFe",
  "BUSDUSDT-APE-LP-SPriceFeed": "0x93dAe7A7763f95eC86006D9f38A497773ce47380",
  "BUSDUSDT-APE-LP-SSortedTroves": "0xA6241b020B1476Aef3aE454c0585933368d06b69",
  "BUSDUSDT-APE-LP-SStabilityPool": "0x89449ff04cEBAF4E27d141E8874895115352A64E",
  "BUSDUSDT-APE-LP-STroveManager": "0x45Bc65D7Bb6d26676D12aC4646c8cC344DCe4e60",
  "EcosystemFund": "0x382E9f09eC39bD2b8Ef6b962572E7715EcbCf4ea",
  "GMUOracle": "0xdD465B9c68750a02c307744a749954B1F9787efb",
  "LeverageAccountRegistry": "0x3A076D0EBF9ff41473071864bf23Afdbd77A253E",
  "MAHA": "0xCE86F7fcD3B40791F63B86C3ea3B8B355Ce2685b",
  "MAHAActivePool": "0xC55aC41A828Ce582cEbda456f2625B4C4BfAd165",
  "MAHABorrowerOperations": "0xd55555376f9A43229Dc92abc856AA93Fee617a9A",
  "MAHACollSurplusPool": "0x9acCf06c773cA11A716378Aa95763a4a8A48Fe9c",
  "MAHACommunityIssuance": "0x0851d1cFf44253087Aec2b4DD8619EF897D0a516",
  "MAHADefaultPool": "0x63af9874fA39D65BFC17C286468003889037e937",
  "MAHAGasPool": "0xceD60d8f0055eFe6ce6837d253F0728ba4e6eC9c",
  "MAHAGovernance": "0x0C11545d943edD1b244328b578D4B0920a0f9b5b",
  "MAHAHintHelpers": "0x619fF5F55B205dbD91d7F705FFf045BAb6b7746f",
  "MAHALQTYStaking": "0xFCcb40A8D3A1d6E07dc39deed4d8F9ed68B91f3A",
  "MAHALQTYToken": "0x9915B26f068964cA4CB1e9ACCC9CEAA88af41Ead",
  "MAHALockupContractFactory": "0x8F9DeeEffD2005C1948F908fF311FbB45dE56a7E",
  "MAHAMultiTroveGetter": "0x72D34240e5d9fa7d87B08A67339B4A01e32c09Fb",
  "MAHAPriceFeed": "0xAa24b64C9B44D874368b09325c6D60165c4B39f2",
  "MAHASortedTroves": "0xD3726d37453F4470E4457c1635572DD46D78Bf1E",
  "MAHAStabilityPool": "0x062FbDf4c98CA68Ab02A1B09B5FCe4E227a69777",
  "MAHATroveManager": "0xD31AC58374D4a0b3C58dFF36f2F59A22348159DB",
  "MAHATroveManagerImplementation": "0xF933E2c48bE0186d6E36E5CdBf82E6111F29c4E7",
  "MahaToken": "0xCE86F7fcD3B40791F63B86C3ea3B8B355Ce2685b",
  "Multicall": "0x41263cba59eb80dc200f3e2544eda4ed6a90e76c",
  "SwapRouter": "0xABcEF4e6BC9fd225bd2dCaD9A45a80855001e6ba",
  "ARTHusd3EPSStableSwap": "0x98245Bfbef4e3059535232D68821a58abB265C45",
  "USDC": "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
  "USDT": "0x55d398326f99059ff775485246999027b3197955",
  "WBNB": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "WBNBActivePool": "0x115318B43f88f0CE19F61b4292C646997DD9D0bC",
  "WBNBBorrowerOperations": "0x20B8B7BA955617b8661D88709698DA15005cdCb3",
  "WBNBCollSurplusPool": "0x90a72748BF4Fc72C9d94D2d1Dfcbf307429063a7",
  "WBNBCommunityIssuance": "0x2749D7693dDfd5413Be3DC517DF211928B055400",
  "WBNBDefaultPool": "0xf032B8736eA0052bC163DbCF8228E33AB74247C2",
  "WBNBGasPool": "0x7a2A1b5B6e995AAd1979e0c7bBC1be3bCFcf598C",
  "WBNBGovernance": "0x89DA855d94dD60396E585B19072A30397A9355A1",
  "WBNBHintHelpers": "0x90f00d342C450E3BAB783F6f5648b1a1ed9CB0A4",
  "WBNBLQTYStaking": "0x356Da62fE004cD6C9fa9a45FAF732feF34FA28E2",
  "WBNBLQTYToken": "0x30D899cAa42F4395A9806Fd91aea260c1D6A568A",
  "WBNBLockupContractFactory": "0xF2A27d667e7DF400820B8124B6034ebfD12EEbd1",
  "WBNBMultiTroveGetter": "0xa33ae5950c25B8943d8b0E544F5339Bb684cDF7D",
  "BUSD-APriceFeed": "0x97651d5188af954ce1402Ca7288D6F74A6F5f09e",
  "BUSD-A": "0xe9e7cea3dedca5984780bafc599bd69add087d56",
  "BUSD-ASortedTroves": "0xE395CC66470f1149c2820df7657D822be6CbeE3e",
  "BUSD-ATroveManager": "0x7cce62085AdEFa3fE9572546fD77fF1aA1088BEc",
  "BUSD-AActivePool": "0x84f678A9743D26E9a9CDc4f121Fe7775F4993715",
  "BUSD-AStabilityPool": "0xBf11165A58216125FDB4eB1f701525A437445E05",
  "BUSD-AGasPool": "0x7138915FbA78d02BC1608bB62e0af872e85382a3",
  "BUSD-ADefaultPool": "0x635Aa27656D81C88f77A9286744407f3b5a6A55F",
  "BUSD-ACollSurplusPool": "0xd443659abe45C408aBd4DF32b763d621dD816E84",
  "BUSD-ABorrowerOperations": "0xBe0c5b6E94A21090B83D6E5f6F9BDBf733CDD9A0",
  "BUSD-AHintHelpers": "0xb34E8e2E1E726D9BD14f150F49107c0CdC890c4D",
  "BUSD-AGovernance": "0x26bbAe3e2Aa3BB9c3703CBB7F672C3a45Fd7dE4D",
  "BUSD-AMultiTroveGetter": "0x66F5385926f07C94bEd4A26dCe5918e9fE749BC9",
  "WBNBPriceFeed": "0xc953285D64A3c8DF09f3167ee250605984778B53",
  "WBNBSortedTroves": "0x44247faAC3000fcc2BC0336738BF7F243ECcCeF5",
  "WBNBStabilityPool": "0x48202b3f81e345c8F72aae88cC386dD1fbBeab97",
  "WBNBTroveManager": "0x8F2C37D2F8AE7Bce07aa79c768CC03AB0E5ae9aE",
  "WBNBTroveManagerImplementation": "0x3E97339651708043fd3e8c3392036e3e05F93C35",
  "WETH_WRAPPER": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  "ZapDepositor": "0x5035Cc9988f88F99CdEF210D833957A80236C0A4"
}

'''
'''--- projects/mahadao/ethereum.js ---
const { unwrapTroves, sumTokens } = require("../helper/unwrapLPs.js");
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");

const chain = "ethereum";

const eth = {
  ethMahaSLP: "0xB73160F333b563f0B8a0bcf1a25ac7578A10DE96",
  ethMahaSLP2: "0xC0897d6Ba893E31F42F658eeAD777AA15B8f824d",
  ethMahaSushiStaking: "0x20257283d7B8Aa42FC00bcc3567e756De1E7BF5a",
  maha: "0xb4d930279552397bba2ee473229f89ec245bc365",
  weth: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  frax: "0x853d955acef822db058eb8505911ed77f175b99e",
  arth: "0x8CC0F052fff7eaD7f2EdCCcaC895502E884a8a71",
  "arth.usd": "0x973F054eDBECD287209c36A2651094fA52F99a71",
  frxArthLP: "0x5a59fd6018186471727faaeae4e57890abc49b08",
  frxArthStaking: "0x7B2F31Fe97f32760c5d6A4021eeA132d44D22039",
};

Object.keys(eth).forEach((k) => (eth[k] = eth[k].toLowerCase()));

async function pool2(_, block) {
  const balances = {};
  const tokensAndOwners = [[eth.ethMahaSLP, eth.ethMahaSushiStaking]];
  const fraxArthbalances = {};
  const fraxArthTokensAndOwners = [
    [eth.frxArthLP, eth.frxArthStaking],
    [eth.frax, eth.frxArthLP],
    // [eth["arth.usd"], eth.frxArthLP,],
  ];

  await sumTokens(balances, tokensAndOwners, block, chain, undefined, {
    resolveLP: true,
  });
  await sumTokens(
    fraxArthbalances,
    fraxArthTokensAndOwners,
    block,
    chain,
    undefined
  );

  const { output: totalSupply } = await sdk.api.erc20.totalSupply({
    target: eth.frxArthLP,
    block,
  });

  const stakedRatio = BigNumber(fraxArthbalances[eth.frxArthLP]).dividedBy(
    totalSupply
  );

  sdk.util.sumSingleBalance(
    balances,
    eth.frax,
    stakedRatio
      .multipliedBy(2)
      .multipliedBy(fraxArthbalances[eth.frax])
      .toFixed(0)
  );

  return balances;
}

async function tvl(_, block) {
  const balances = {};
  const troves = [
    "0x4a47a8EB52c6213963727BF93baaa1CF66CBdF38", // FRAX Trove
  ];
  await unwrapTroves({ balances, chain, block, troves });
  return balances;
}

module.exports = {
  pool2,
  tvl,
};

'''
'''--- projects/mahadao/index.js ---
const polygon = require("./polygon");
const bsc = require("./bsc");
const ethereum = require("./ethereum");

module.exports = {
  misrepresentedTokens: true,
  methodology: "Deposited collateral in loans used to mint ARTH",
  polygon,
  bsc,
  ethereum,
};

'''
'''--- projects/mahadao/polygon.js ---
const { balanceOf, totalSupply } = require("@defillama/sdk/build/erc20");
const { staking } = require("../helper/staking");
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs.js");
const BigNumber = require("bignumber.js");
const sdk = require("@defillama/sdk");
const { unwrapTroves, sumTokens, } = require('../helper/unwrapLPs')
const { resolveCrvTokens, } = require('../helper/resolveCrvTokens')
const { getChainTransform } = require('../helper/portedTokens')

const chain = "polygon";

const polygon = {
  "arth.usd": "0x84f168e646d31F6c33fDbF284D9037f59603Aa28",
  "polygon.3pool": "0x19793b454d3afc7b454f206ffe95ade26ca6912c",
  am3CRV: "0xe7a24ef0c5e95ffb0f6684b813a78f2a3ad7d171",
  arth: "0xe52509181feb30eb4979e29ec70d50fd5c44d590",
  arthMahaLP: "0x95de8efD01dc92ab2372596B3682dA76a79f24c3",
  arthMahaStaking: "0xC82c95666bE4E89AED8AE10bab4b714cae6655d5",
  arthu3poolLP: "0xDdE5FdB48B2ec6bc26bb4487f8E3a4EB99b3d633",
  arthu3poolStaking: "0x245AE0bBc1E31e7279F0835cE8E93127A13a3781",
  arthUsdcLP: "0x34aAfA58894aFf03E137b63275aff64cA3552a3E",
  arthUsdcStaking: "0xD585bfCF37db3C2507e2D44562F0Dbe2E4ec37Bc",
  dai: "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
  maha: "0xedd6ca8a4202d4a36611e2fff109648c4863ae19",
  usdc: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
};
Object.keys(polygon).forEach(k => polygon[k] = polygon[k].toLowerCase())

async function getBalanceOfStakedCurveLP(balances, stakingContract, lpToken, tokens, block, chain) {
  const transformAddress = await getChainTransform(chain)
  const stakedLpTokens = await balanceOf({ target: lpToken, owner: stakingContract, block, chain, });
  const totalLPSupply = await totalSupply({ target: lpToken, block, chain, });
  const percentage = stakedLpTokens.output / totalLPSupply.output;

  const token1Balance = await balanceOf({ target: tokens[0], owner: lpToken, block, chain, });
  const token2Balance = await balanceOf({ target: tokens[1], owner: lpToken, block, chain, });

  const e18 = new BigNumber(10).pow(18);
  let token1Amount = new BigNumber(token1Balance.output * percentage);
  const token2Amount = new BigNumber(token2Balance.output * percentage);

  if (tokens[0] === polygon['arth.usd']) {
    token1Amount = token1Amount.dividedBy(e18)
    sdk.util.sumSingleBalance(balances, "usd-coin", token1Amount.toNumber());
  }
  else
    sdk.util.sumSingleBalance(balances, transformAddress(tokens[0]), token1Amount.toNumber())
  if (tokens[1] === polygon["polygon.3pool"])
    tokens[1] = polygon.am3CRV
  sdk.util.sumSingleBalance(balances, transformAddress(tokens[1]), token2Amount.toNumber())
}

async function getTVLv2(ret, troves, collaterals, chainBlocks) {
  const block = chainBlocks[chain];
  await unwrapTroves({ balances: ret, troves, chain, block })
  return ret;
}

async function getTVLv1(ret, pools, collaterals, chainBlocks) {
  const block = chainBlocks[chain];
  const tokensAndOwners = pools.map((owner, i) => [collaterals[i], owner])
  const transformAddress = await getChainTransform(chain)
  await sumTokens(ret, tokensAndOwners, block, chain, transformAddress)
  return ret;
}

function polygonTVL() {
  return async (_, ethBlock, chainBlocks) => {
    const ret = {};

    await getTVLv2(
      ret,
      [
        // troves
        "0x5344950d34E8959c7fb6645C839A7cA89BE18216", // weth
        "0x7df27F6B3C8A2b6219352A434872DcDd8f5a50E4", // dai
        "0x8C021C5a2910D1812542D5495E4Fbf6a6c33Cb4f", // wmatic
      ],
      [
        // trove collaterals
        "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619", // weth
        "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063", // dai
        "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      ],
      chainBlocks
    );

    await getTVLv1(
      ret,
      [
        // pool
        "0xa25687a15332Dcbc1319521FEc31FCDc5A33c5EC", // pool usdc
        "0xb40125f17f9517bc6396a7ed030ee6d6f41f3692", // pool wbtc
        "0xe8dc1c33724ff26b474846c05a69dfd8ca3873c9", // pool usdt
        "0x7b8f513da3ffb1e37fc5e44d3bfc3313094ae8cf", // pool weth
        "0xa9f1d7841b059c98c973ec90502cbf3fc2db287c", // pool wmatic
      ],
      [
        // collaterals
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", // pool usdc
        "0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6", // pool wbtc
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f", // pool usdt
        "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619", // pool weth
        "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270", // pool wmatic
      ],
      chainBlocks
    );

    return ret;
  };
}

function pool2s() {
  return async (_timestamp, _ethBlock, chainBlocks) => {
    const balances = {};

    // calculate tvl for regular uniswap lp tokens
    const stakingContracts = [polygon.arthUsdcStaking, polygon.arthMahaStaking];
    const lpTokens = [polygon.arthUsdcLP, polygon.arthMahaLP];
    await sumTokensAndLPsSharedOwners(
      balances,
      lpTokens.map((token) => [token, true]),
      stakingContracts,
      chainBlocks.polygon,
      "polygon",
      (addr) => `polygon:${addr}`
    );

    // calculate tvl for curve lp tokens
    await getBalanceOfStakedCurveLP(
      balances,
      polygon.arthu3poolStaking, // staked
      polygon.arthu3poolLP, // lp token
      [polygon["arth.usd"], polygon["polygon.3pool"]],
      chainBlocks.polygon,
      "polygon"
    );

    const transformAddress = await getChainTransform(chain)
    await resolveCrvTokens(balances, chainBlocks.polygon, chain, transformAddress)

    return balances;
  };
}

module.exports = {
  staking: staking(
    "0x8f2c37d2f8ae7bce07aa79c768cc03ab0e5ae9ae", // mahax contract
    "0xedd6ca8a4202d4a36611e2fff109648c4863ae19", // maha
    "polygon"
  ),
  pool2: pool2s(),
  tvl: polygonTVL(),
};

'''
'''--- projects/maia-dao/abis.json ---
{
  "locked": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "locked",
    "outputs": [
      {
        "internalType": "int128",
        "name": "amount",
        "type": "int128"
      },
      {
        "internalType": "uint256",
        "name": "end",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "gauges": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [{ "type": "address", "name": "", "internalType": "address" }],
    "name": "gauges",
    "inputs": [{ "type": "address", "name": "", "internalType": "address" }]
  },
  "balanceOf": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }],
    "name": "balanceOf",
    "inputs": [{ "type": "address", "name": "", "internalType": "address" }]
  },
  "pools": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [{ "type": "address", "name": "", "internalType": "address" }],
    "name": "pools",
    "inputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }]
  },
  "length": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }],
    "name": "length",
    "inputs": []
  }
}

'''
'''--- projects/maia-dao/index.js ---
const sdk = require("@defillama/sdk");
const { transformMetisAddress } = require('../helper/portedTokens');
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');
const abis = require("./abis.json");

const HERMES = '0xb27bbeaaca2c00d6258c3118bab6b5b6975161c8';
const multisig = '0x77314eAA8D99C2Ad55f3ca6dF4300CFC50BdBC7F';
const excludedTokens = ["0xa3e8e7eb4649ffc6f3cbe42b4c2ecf6625d3e802"];

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformMetisAddress();

  const hermesBalance = (await sdk.api.abi.multiCall({
    target: '0xa4C546c8F3ca15aa537D2ac3f62EE808d915B65b',
    calls: Array.from({ length: Number(38) }, (_, k) => ({
      params: [k],
    })),
    abi: abis.locked,
    block: chainBlocks.metis,
    chain: 'metis'
  })).output;

  var sum = 0;
  for (let i = 1; i < 38; i++) {
    sum += Number(hermesBalance[i].output.amount);
  }

  balances[`metis:${HERMES}`] = BigInt(sum).toString()

  const noPairs = (await sdk.api.abi.call({
    target: '0x879828da3a678D349A3C8d6B3D9C78e9Ee31137F',
    abi: abis.length,
    block: chainBlocks.metis,
    chain: 'metis'
  })).output;

  const pairAddresses = (await sdk.api.abi.multiCall({
    target: '0x879828da3a678D349A3C8d6B3D9C78e9Ee31137F',
    calls: Array.from({ length: Number(noPairs) }, (_, k) => ({
      params: k,
    })),
    abi: abis.pools,
    block: chainBlocks.metis,
    chain: 'metis'
  })).output;

  let gauges = (await sdk.api.abi.multiCall({
    target: '0x879828da3a678D349A3C8d6B3D9C78e9Ee31137F',
    calls: pairAddresses.map(a => ({
      params: a.output
    })),
    abi: abis.gauges,
    block: chainBlocks.metis,
    chain: 'metis'
  })).output;

  let pairBalances = []

  for (let i = 0; i < Number(noPairs); i++) {
    pairBalances.push(
      await sdk.api.abi.call({
        target: gauges[i].output,
        abi: abis.balanceOf,
        params: [multisig],
        block: chainBlocks.metis,
        chain: "metis",
      })
    );
  }

  let lpPositions = [];
  for (let i = 0; i < pairBalances.length; i++) {
    if (
      pairAddresses[i].output &&
      excludedTokens.includes(pairAddresses[i].output.toLowerCase())
    ) {
      continue;
    };
    lpPositions.push({
      balance: pairBalances[i].output,
      token: pairAddresses[i].output
    });
  };

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks.metis,
    'metis',
    transform
  );

  return balances;
};

module.exports = {
  metis: {
    tvl
  }
}

'''
'''--- projects/maiar/index.js ---
const { default: axios } = require("axios");
const { request, gql } = require("graphql-request");
const {toUSDTBalances} = require('../helper/balances')

const LiquidityQuery= gql`
{
    farms {
      farmingToken {
        identifier
      }
      farmTokenPriceUSD
      farmingTokenReserve
    }
    pairs {
      firstToken {
        decimals
      }
      secondToken {
        decimals
      }
      firstTokenPriceUSD
      secondTokenPriceUSD
      info {
        reserves0
        reserves1
      }
    }
  }
  
`

async function tvl(){
    const {pairs} = await request("https://graph.maiar.exchange/graphql", LiquidityQuery)
    const totalTvl = pairs.reduce((total, pair)=>{
        if(pair.firstTokenPriceUSD === "NaN" || pair.secondTokenPriceUSD === "NaN"){
            return total
        }
        return total 
        + (pair.firstTokenPriceUSD * pair.info.reserves0 / (10**(pair.firstToken.decimals)))
        + (pair.secondTokenPriceUSD * pair.info.reserves1 / (10**(pair.secondToken.decimals))) 
    }, 0)
    return toUSDTBalances(totalTvl)
}

const stakingContracts = [
  "erd1qqqqqqqqqqqqqpgq7qhsw8kffad85jtt79t9ym0a4ycvan9a2jps0zkpen",
  "erd1qqqqqqqqqqqqqpgqv4ks4nzn2cw96mm06lt7s2l3xfrsznmp2jpsszdry5"
]
async function staking(){
  let mexTvl = 0
  await Promise.all(stakingContracts.map(async owner=>{
    const data = await axios.get(`https://api.elrond.com/accounts/${owner}/tokens/MEX-455c57`)
    mexTvl += data.data.balance/1e18
  }))
  return {
    "maiar-dex": mexTvl
  }
}

module.exports={
  misrepresentedTokens: true,
  timetravel: false,
    elrond:{
        tvl,
        staking
    },
}
'''
'''--- projects/maker/abis/maker-mcd.js ---
module.exports = {
  // addresses for kovan version 0.2.17
  KOVANVAT: "0xba987bdb501d131f766fee8180da5d81b34b69d9",
  KOVANPOT: "0xea190dbdc7adf265260ec4da6e9675fd4f5a78bb",
  KOVANJUG: "0xcbb7718c9f39d05aeede1c472ca8bf804b2f1ead",
  KOVANSTARTBLOCK: 14764534,
  VAT: "0x35d1b3f3d7966a1dfe207aa4514c12a259a0492b",
  POT: "0x197e90f9fad81970ba7976f33cbd77088e5d7cf7",
  JUG: "0x19c0976f590d67707e62397c87829d896dc0f1f1",
  DAI: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
  STARTBLOCK: 8928152,
  ilk: {
    constant: true,
    inputs: [],
    name: "ilk",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    payable: false,
    stateMutability: "view",
    type: "function",
  },
  gem: {
    constant: true,
    inputs: [],
    name: "gem",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function",
  },
  Pie: {
    constant: true,
    inputs: [],
    name: "Pie",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function",
  },
  dog: {"inputs":[],"name":"dog","outputs":[{"internalType":"contract DogLike","name":"","type":"address"}],"stateMutability":"view","type":"function"}
};

'''
'''--- projects/maker/abis/makerdao.js ---
module.exports = {
  TUB_ADDRESS: "0x448a5065aebb8e423f0896e6c5d525c040f59af3",
  DAI_ADDRESS: "0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359",
  WETH_ADDRESS: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
};
'''
'''--- projects/maker/index.js ---
const BigNumber = require('bignumber.js');
// const utils = require('web3-utils');
const sdk = require('@defillama/sdk');
const MakerSCDConstants = require("./abis/makerdao.js");
const MakerMCDConstants = require("./abis/maker-mcd.js");
const { unwrapUniswapLPs } = require('../helper/unwrapLPs');
const { requery } = require('../helper/requery.js');

async function getJoins(block) {
  // let rely = utils.sha3("rely(address)").substr(0, 10);
  // let relyTopic = utils.padRight(rely, 64);
  let relyTopic = '0x65fae35e00000000000000000000000000000000000000000000000000000000'

  let joins = [];

  // get list of auths
  const logs = (
    await sdk.api.util
      .getLogs({
        keys: [],
        toBlock: block,
        target: MakerMCDConstants.VAT,
        fromBlock: MakerMCDConstants.STARTBLOCK,
        topics: [relyTopic],
      })
  ).output;

  let auths = logs.map(auth => {
    return `0x${auth.topics[1].substr(26)}`;
  });

  const ilks = await sdk.api.abi.multiCall({
    abi: MakerMCDConstants.ilk,
    calls: auths.map((auth) => ({
      target: auth,
    })),
    block
  });
  await requery(ilks, "ethereum", block, MakerMCDConstants.ilk)
  await requery(ilks, "ethereum", block, MakerMCDConstants.ilk)  // make sure that failed calls actually fail

  for (let ilk of ilks.output) {
    if (ilk.output) {
      joins.push(ilk.input.target)
    }
  }

  return joins;
}

async function tvl(timestamp, block) {
  let balances = {};
  balances[MakerSCDConstants.WETH_ADDRESS] = (await sdk.api.erc20.balanceOf({
    block,
    target: MakerSCDConstants.WETH_ADDRESS,
    owner: MakerSCDConstants.TUB_ADDRESS
  })).output;

  if (block >= MakerMCDConstants.STARTBLOCK) {
    let joins = await getJoins(block);

    await Promise.all(joins.map(async join => {
      try {
        const gem = (await sdk.api.abi.call({
          block,
          target: join,
          abi: MakerMCDConstants.gem
        })).output;
        const balance = (await sdk.api.erc20.balanceOf({
          target: gem,
          owner: join,
          block
        })).output;

        const symbol = join === "0xad37fd42185ba63009177058208dd1be4b136e6b"?"SAI": await sdk.api.erc20.symbol(gem)
        if (symbol.output === "UNI-V2") {
          await unwrapUniswapLPs(balances, [{
            token: gem,
            balance
          }],
            block)
        } else {
          sdk.util.sumSingleBalance(balances, gem, balance);
        }
      } catch (e) {
        try{
          if(join !== "0x7b3799b30f268ba55f926d7f714a3001af89d359"){
            await sdk.api.abi.call({
              block,
              target: join,
              abi: MakerMCDConstants.dog
            })
          }
          return
        } catch(e){
          throw new Error("failed gem() and dog() on "+join)
        }
      }
    }))
  }

  return balances;
}

module.exports = {
  timetravel: true,
  methodology: `Counts all the tokens being used as collateral of CDPs.
  
  On the technical level, we get all the collateral tokens by fetching events, get the amounts locked by calling balanceOf() directly, unwrap any uniswap LP tokens and then get the price of each token from coingecko`,
  start: 1513566671, // 12/18/2017 @ 12:00am (UTC)
  ethereum: {
    tvl
  },
};

'''
'''--- projects/makiswap/abi.json ---
{
  "totalPairs": {
    "constant": true,
    "inputs": [],
    "name": "totalPairs",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "allPairs": {
    "constant": true,
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "allPairs",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/makiswap/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const abi = require("./abi.json");

const factory = "0x11cdC9Bd86fF68b6A6152037342bAe0c3a717f56";
const maki = "0x5FaD6fBBA4BbA686bA9B8052Cf0bd51699f38B93";
const makiChef = "0x4cb4c9C8cC67B171Ce86eB947cf558AFDBcAB17E";

const ignoreLPs = [
  "0x329bae377d60df25e58a17b3d0b1d46cf2f4fd8b",
  "0x4db7c033137c2843481a686cc0cb415ad09fa764",
  "0x5e9cdc40d1acf45fef65313142e40c72059bcb98",
];

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  let poolLength = (
    await sdk.api.abi.call({
      target: factory,
      abi: abi.totalPairs,
      block: chainBlocks.heco,
      chain: "heco",
    })
  ).output;
  let allPools = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(poolLength) }, (_, k) => ({
        target: factory,
        params: k,
      })),
      abi: abi.allPairs,
      block: chainBlocks.heco,
      chain: "heco",
    })
  ).output;
  let supply = (
    await sdk.api.abi.multiCall({
      calls: allPools.map((p) => ({
        target: p.output,
      })),
      abi: "erc20:totalSupply",
      block: chainBlocks.heco,
      chain: "heco",
    })
  ).output;
  let ignoreLPSupply = (
    await sdk.api.abi.multiCall({
      calls: ignoreLPs.map((p) => ({
        target: p,
      })),
      abi: "erc20:totalSupply",
      block: chainBlocks.heco,
      chain: "heco",
    })
  ).output;
  let lpPositions = [];
  supply.forEach((p) => {
    let addr = p.output.toLowerCase();
    if (addr === "0") {
      return;
    }
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  ignoreLPSupply.forEach((p) => {
    lpPositions.push({
      balance: p.output,
      token: p.input.target,
    });
  });
  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks.heco,
    "heco",
    (addr) => {
      return `heco:${addr}`;
    },
    ignoreLPs
  );
  return balances;
}

async function staking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (
    await sdk.api.erc20.balanceOf({
      target: maki,
      owner: makiChef,
      block: chainBlocks.heco,
      chain: "heco",
    })
  ).output;
  sdk.util.sumSingleBalance(balances, `heco:${maki}`, balance);
  return balances;
}

module.exports = {
  methodology: "TVL consists of LPs created by the factory contract",
  heco: {
    tvl,
    staking,
  },
};

'''
'''--- projects/malt-money/index.js ---
const sdk = require("@defillama/sdk");
const {unwrapUniswapLPs} = require('../helper/unwrapLPs')
const {transformPolygonAddress} = require('../helper/portedTokens')
const axios = require('axios')

const maitFarm = '0x539618aa29c95c28c0b04abb9025815c014a9db9'
const treasury = '0xe444a7d44065b06ac551623d56ba610a44a20013'

async function tvl(timestamp, block, chainBlocks) {
    let balances = {}
    let lpPositions = []
    let transformAddress = await transformPolygonAddress()
    let maitFarmTokens = (await axios.get(`https://api.covalenthq.com/v1/137/address/${maitFarm}/balances_v2/?&key=ckey_72cd3b74b4a048c9bc671f7c5a6`)).data.data.items
    let treasuryTokens = (await axios.get(`https://api.covalenthq.com/v1/137/address/${treasury}/balances_v2/?&key=ckey_72cd3b74b4a048c9bc671f7c5a6`)).data.data.items

    await Promise.all(
        treasuryTokens.concat(maitFarmTokens).map(async (token) => {
            if(token.contract_ticker_symbol === 'UNI-V2')
            {
                const uniLocked = sdk.api.erc20.balanceOf({
                    target: token.contract_address,
                    owner: maitFarm,
                    block: chainBlocks['polygon'],
                    chain: 'polygon'
                })

                lpPositions.push({
                    token: token.contract_address,
                    balance: (await uniLocked).output
                })
            } else if(token.supports_erc) {
                const singleTokenLocked = sdk.api.erc20.balanceOf({
                    target: token.contract_address,
                    owner: maitFarm,
                    block: chainBlocks['polygon'],
                    chain: 'polygon'

                })
                sdk.util.sumSingleBalance(balances, transformAddress(token.contract_address), (await singleTokenLocked).output)
            }
    }))
    await unwrapUniswapLPs(balances, lpPositions, chainBlocks['polygon'], 'polygon', transformAddress)
    return balances
}

module.exports = {
    polygon: {
        tvl
    },
}

'''
'''--- projects/mama-dao/index.js ---
const {ohmTvl} = require("../helper/ohm");

const treasury = "0x884f6A98477b0F689f1da280A83a963f2B768972";
const treasuryTokens = [
    ["0x8f3cf7ad23cd3cadbd9735aff958023239c6a063", false], // DAI
    ["0xBdDB96D54E1434654f8E46Dba41120cd652039bb", true] // MAMA-DAI UNI LP
]
const stakingAddress = "0xe1B64E20921a38c20BE98f953F758e9DeD80F89b"
const stakingToken = "0xA9a779aeA33b6f40CfC78A29Cf56Fc7e6fb329AB";

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "polygon", stakingAddress, stakingToken, undefined, undefined, false)
}
'''
'''--- projects/manarium/index.js ---
const sdk = require('@defillama/sdk');
const { transformBscAddress } = require('../helper/portedTokens');
const ARI_TOKEN_CONTRACT = '0xc80a0a55caf6a7bfb4ee22f9380c4077312c4a35';
const ARI_STAKING_CONTRACT = '0x0C3542f48D26CF67e2DAc78f5588D12649F4D255';

async function tvl(timestamp, block, chainBlocks){
    const balances = {};
    const transform = await transformBscAddress();

    const collateralBalance = (await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        chain: 'bsc',
        target: ARI_TOKEN_CONTRACT,
        params: [ARI_STAKING_CONTRACT],
        block: chainBlocks['bsc'],
      })).output;

      sdk.util.sumSingleBalance(balances, transform(ARI_TOKEN_CONTRACT), collateralBalance)
      return balances;
}

module.exports = {
    bsc: {
      tvl: () => ({}),
      staking: tvl
    }
  }; 
'''
'''--- projects/mango-markets/index.js ---
const axios = require('axios')

const endpoint = 'https://mango-stats-v3.herokuapp.com/spot?mangoGroup=mainnet.1'

// Very inefficient
function findClosestToDate(values, date) {
    let min = values[0];
    for (const val of values) {
        const valDate = new Date(val.time).getTime()
        const minDate = new Date(min.time).getTime()
        if (Math.abs(valDate - date) < Math.abs(minDate - date)) {
            min = val
        }
    }
    if(Math.abs(new Date(min.time).getTime()-date) > 24*3600*1000){
        return {
            totalDeposits: 0,
            totalBorrows: 0
        }
    }
    return min
}

const coingeckoIds = {
    'ETH': 'ethereum',
    'BTC': 'bitcoin',
    'SOL': 'solana',
    'SRM': 'serum',
    'USDC': 'usd-coin',
    'USDT': 'tether',
    'MNGO': 'mango-markets',
    'RAY': 'raydium',
    'COPE': 'cope',
    'FTT': 'ftx-token',
    'MSOL': 'msol',
    'BNB': 'binance-coin',
    'AVAX': 'avalanche',
    'LUNA': 'terra-luna',
    'GMT': 'stepn',
}

async function tvl(timestamp) {
    const balances = {};
    const stats = await axios.get(endpoint)
    const date = new Date(timestamp * 1000).getTime()
    Object.entries(coingeckoIds).map(([mangoId, coingeckoId]) => {
        const assetDeposits = stats.data.filter(s => s.name === mangoId)
        if (assetDeposits.length > 0) {
            const closestVal = findClosestToDate(assetDeposits, date)
            balances[coingeckoId] = closestVal.totalDeposits - closestVal.totalBorrows
        }
    })
    return balances
}

module.exports = {
    timetravel: false,
    solana: {
        tvl,
    },
}

'''
'''--- projects/manhattan/abi.json ---
{
    "Token":     {
        "inputs": [],
        "name": "Token",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      "checkInvestedLast": {
        "inputs": [],
        "name": "checkInvestedLast",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      }
}
'''
'''--- projects/manhattan/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { transformFantomAddress } = require("../helper/portedTokens");

var ifTokens = [
  "0xbb4F9c4CaE5D08AB0C02De724B3c51C28e8c181d",
  "0x00C38025F12F239B72dadc09a4B93F8830c462C0",
  "0x20FF28c943DE978dd7Ff3Af1f94a921A257cC7Cc",
  "0xacdAe58fA05cc449A6f099Cf42cF6a2C7A0317a6",
  "0x51086a97a72AB9a7022d5Cf3Fd2a5FeDE4d7bec8",
  "0x391E1bfc9851a518022815Fe786707c2E786f0Ca",
  "0x4Bbd947d5E04D6fC90eaeD18084B68F88279D73e",
  "0x29e65a3846AE97DD4A584C20383C53Bffe2a0130",
  "0x614062ED8b4dAc60DED33f357bA2A604F2C65D18",
  "0xF842F73e47A5f191deFb79e61E836545712144Ad",
  "0x522225662A7050D890cFe7D3Ecd49ac411f09c69",
  "0xF2486A76368463dd463188E6ba09A6C66E1c7479",
  "0x81c2DbE1Cd07539eB1104cd267Bec21800F3bC20",
];

async function tvl(timestamp, block, chainBlocks) {
  let balances = {};
  let transform = await transformFantomAddress();

  const underlying = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.Token,
      calls: ifTokens.map((t) => ({
        target: t,
      })),
      chain: "fantom",
    })
  ).output.map((o) => o.output);

  const balance = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.checkInvestedLast,
      calls: ifTokens.map((t) => ({
        target: t,
      })),
      chain: "fantom",
    })
  ).output.map((o) => o.output);

  for (let i = 0; i < underlying.length; i++) {
    sdk.util.sumSingleBalance(
      balances,
      transform(underlying[i]),
      balance[i]
    );
  };

  return balances;
};

module.exports = {
  fantom: {
    tvl,
  },
};

'''
'''--- projects/manifest/index.js ---
const { ohmTvl } = require("../helper/ohm");

const treasuryAddress = "0x200a433086C37eB55bc4CD31f8195831052a67C6";
module.exports = ohmTvl(treasuryAddress, [
  ["0x04f2694c8fcee23e8fd0dfea1d4f5bb8c352111f", false], // sOHM
  ["0x89c4d11dfd5868d847ca26c8b1caa9c25c712cef", true], // MNFST-OHM
  ["0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", false] // WETH
], "ethereum", "0x9c9022c6a2e1ed9f3110e177763123c4400d5eb6", "0x21585bbcd5bdc3f5737620cf0db2e51978cf60ac")

'''
'''--- projects/mantradao.js ---
const { sumTokens } = require("./helper/unwrapLPs");
const { compoundExports } = require("./helper/compound");
const { stakingAssetsETH, stakingAssetsBSC, stakingAssetsPOLYGON, } = require("./config/mantra-dao/contracts/naked-staking-contracts");
const { lpStakingAssetsETH, lpStakingAssetsBSC, lpStakingAssetsPOLYGON, } = require("./config/mantra-dao/contracts/lp-staking-contracts");

const chainConfig = {
  ethereum: { staking: stakingAssetsETH, pool2: lpStakingAssetsETH, },
  bsc: { staking: stakingAssetsBSC, pool2: lpStakingAssetsBSC, },
  polygon: { staking: stakingAssetsPOLYGON, pool2: lpStakingAssetsPOLYGON, },
}

const comptroller = "0x606246e9EF6C70DCb6CEE42136cd06D127E2B7C7"
const zenETH = "0x4F905f75F5576228eD2D0EA508Fb0c32a0696090"
const zenETHEquivalent = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

module.exports = {}

Object.keys(chainConfig).forEach(chain => {
  const { staking, pool2 } = chainConfig[chain]
  let ethAdditional = {}

  if (chain === 'ethereum')
    ethAdditional = compoundExports(comptroller, "ethereum", zenETH, zenETHEquivalent)

  module.exports[chain] = {
    tvl: () => ({}),
    staking: async (ts, _block, chainBlocks) => {
      const block = chainBlocks[chain]
      const tokens = staking.map(i => [i.token, i.contract,])
      return sumTokens(undefined, tokens, block, chain)
    },
    pool2: async (ts, _block, chainBlocks) => {
      const block = chainBlocks[chain]
      const tokens = pool2.map((p) => [p.pairAddress, p.contract,])
      return sumTokens(undefined, tokens, block, chain, undefined, { resolveLP: true })
    },
    ...ethAdditional,
  }
})

'''
'''--- projects/maple/abi.json ---
{
    "pools": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "pools",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "poolsCreated": {
        "inputs": [],
        "name": "poolsCreated",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "liquidityAsset": {
        "inputs": [],
        "name": "liquidityAsset",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "liquidityLocker": {
        "inputs": [],
        "name": "liquidityLocker",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "principalOut": {
        "inputs": [],
        "name": "principalOut",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/maple/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { sumTokensAndLPsSharedOwners, sumTokens2 } = require("../helper/unwrapLPs");
const { staking, } = require("../helper/staking")
const { getConnection, getTokenBalance } = require('../helper/solana')
const { PublicKey } = require('@solana/web3.js')

const PoolFactory = "0x2Cd79F7f8b38B9c0D80EA6B230441841A31537eC";

const MapleTreasury = "0xa9466EaBd096449d650D5AEB0dD3dA6F52FD0B19";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const chain = 'ethereum'

/*** Treasury ***/
const Treasury = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    [[USDC, false]],
    [MapleTreasury],
    chainBlocks["ethereum"],
    "ethereum",
    addr => addr
  );

  return balances;
};

/*** Ethereum TVL Portions ***/
const ethTvl = async (timestamp, block) => {
  const poolsCreated = (
    await sdk.api.abi.call({
      abi: abi.poolsCreated,
      target: PoolFactory,
      block
    })
  ).output;
  const calls = []

  for (let i = 0; i < poolsCreated; i++)
    calls.push({ params: i })

  const { output: pools } = await sdk.api.abi.multiCall({
    target: PoolFactory,
    abi: abi.pools,
    calls,
    chain, block,
  })

  const { output: assetOfLiquidity } = await sdk.api.abi.multiCall({
    abi: abi.liquidityAsset,
    calls: pools.map(i => ({ target: i.output })),
    chain, block,
  })

  const { output: locker } = await sdk.api.abi.multiCall({
    abi: abi.liquidityLocker,
    calls: pools.map(i => ({ target: i.output })),
    chain, block,
  })

  const toa = assetOfLiquidity.map(({ output }, i) => [output, locker[i].output])

  return sumTokens2({ tokensAndOwners: toa, block })
};

const borrowed = async (timestamp, block) => {
  const poolsCreated = (
    await sdk.api.abi.call({
      abi: abi.poolsCreated,
      target: PoolFactory,
      block
    })
  ).output;
  const calls = []

  for (let i = 0; i < poolsCreated; i++)
    calls.push({ params: i })

  const { output: pools } = await sdk.api.abi.multiCall({
    target: PoolFactory,
    abi: abi.pools,
    calls,
    chain, block,
  })

  const { output: assetOfLiquidity } = await sdk.api.abi.multiCall({
    abi: abi.liquidityAsset,
    calls: pools.map(i => ({ target: i.output })),
    chain, block,
  })

  const { output: principalOut } = await sdk.api.abi.multiCall({
    abi: abi.principalOut,
    calls: pools.map(i => ({ target: i.output })),
    chain, block,
  })

  const balances = {}
  assetOfLiquidity.forEach(({ output }, i) => sdk.util.sumSingleBalance(balances, output, principalOut[i].output))
  return balances
};

/*** Solana TVL Portions ***/
const POOL_DISCRIMINATOR = "35K4P9PCU";
const TVL_OFFSET = 257;
const TVL_DATA_SIZE = 8;
const PROGRAM_ID = "5D9yi4BKrxF8h65NkVE1raCCWFKUs5ngub2ECxhvfaZe";

let _tvl
const usdc = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'

function getTvl(borrowed = false) {
  return async () => {
    if (!_tvl) _tvl = getSolanaTVL()
    const res = await _tvl
    return borrowed ? res.borrowed : res.tvl
  }
}

async function getSolanaTVL() {
  const programId = new PublicKey(PROGRAM_ID);
  const connection = getConnection();
  const accounts = await connection.getProgramAccounts(programId, {
    filters: [{
      memcmp: {
        offset: 0,
        bytes: POOL_DISCRIMINATOR
      }
    }]
  });

  let borrowed = 0;
  let tvlValue = 0;
  for (const account of accounts) {
    const data = account.account.data.slice(TVL_OFFSET, TVL_OFFSET + TVL_DATA_SIZE)
    const poolTvl = Number(data.readBigUint64LE())
    const loanBalance = await getTokenBalance(usdc, account.pubkey.toString())
    tvlValue += loanBalance * 1e6
    borrowed += poolTvl - loanBalance * 1e6
  }

  return {
    tvl: {
      [USDC]: tvlValue.toFixed(0),
    },
    borrowed: {
      [USDC]: borrowed.toFixed(0)
    }
  };
}

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  ethereum: {
    tvl: ethTvl,
    treasury: Treasury,
    staking: staking('0x4937a209d4cdbd3ecd48857277cfd4da4d82914c', '0x33349b282065b0284d756f0577fb39c158f935e6'),
    borrowed,
  },
  solana: {
    tvl: getTvl(),
    borrowed: getTvl(true),
  },
  methodology:
    "We count liquidity by USDC deposited on the pools through PoolFactory contract",
}

'''
'''--- projects/mapledefi/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const masterchef = "0x0283527f549Aef5e6fb91cC30eB1FC8c88545494";
const token = "0x8853759fEC86302F4291F001835E2383538F837A";

module.exports = {
    misrepresentedTokens: true,
    ...masterChefExports(masterchef, "bsc", token, false)
}
'''
'''--- projects/marginswap/index.js ---
const sdk = require("@defillama/sdk");
const retry = require("../helper/retry");
const { GraphQLClient, gql } = require("graphql-request");

function getChainTvl(chain) {
  return async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};

    var api = `https://api.thegraph.com/subgraphs/name/marginswap/marginswap-v2-${
      chain === "avax" ? "avalanche" : chain
    }`;

    var graphQLClient = new GraphQLClient(api);

    var query = gql`
      {
        aggregatedBalances {
          balance
          token
        }
      }
    `;

    const data = (
      await retry(async (bail) => await graphQLClient.request(query))
    ).aggregatedBalances;

    data.forEach((data) => {
      sdk.util.sumSingleBalance(
        balances,
        `${chain}:${data.token}`,
        data.balance
      );
    });
    
    return balances;
  };
}

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: getChainTvl("ethereum"),
  },
  bsc: {
    tvl: getChainTvl("bsc"),
  },
  avax: {
    tvl: getChainTvl("avax"),
  },
  polygon: {
    tvl: getChainTvl("polygon"),
  },
  methodology:
    "Counts liquidity of deposits, pulling data from Analytics Subgraphs",
};

'''
'''--- projects/marinade.js ---
const retry = require('async-retry')
const axios = require("axios");

async function tvl() {
    var response = await retry(async bail => await axios.get('https://api.marinade.finance/tlv'))

    return {
        'solana': response.data.total_sol
    }
}

module.exports = {
    timetravel: false,
    tvl,
    methodology: `To obtain the Marinade Finance TVL we make a dedicated API endpoint in our REST server. It is using values from the database with a separate update process. The *_sol fields of returned JSON object contains a number of SOL tokens held in our contract for us to then use Coingecko to get the price of SOL token in USD and export it. We are counting only SOL tokens because all other tokens used in our contract are mintable by us and represents a value of locked SOL tokens to our customers`,
}

'''
'''--- projects/market.xyz/abi.js ---
module.exports = {
  inputs: [],
  name: "getPublicPoolsWithData",
  outputs: [
    {
      internalType: "uint256[]",
      name: "",
      type: "uint256[]",
    },
    {
      components: [
        {
          internalType: "string",
          name: "name",
          type: "string",
        },
        {
          internalType: "address",
          name: "creator",
          type: "address",
        },
        {
          internalType: "address",
          name: "comptroller",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "blockPosted",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "timestampPosted",
          type: "uint256",
        },
      ],
      internalType: "struct FusePoolDirectory.FusePool[]",
      name: "",
      type: "tuple[]",
    },
    {
      internalType: "uint256[]",
      name: "",
      type: "uint256[]",
    },
    {
      internalType: "uint256[]",
      name: "",
      type: "uint256[]",
    },
    {
      internalType: "address[][]",
      name: "",
      type: "address[][]",
    },
    {
      internalType: "string[][]",
      name: "",
      type: "string[][]",
    },
    {
      internalType: "bool[]",
      name: "",
      type: "bool[]",
    },
  ],
  stateMutability: "nonpayable",
  type: "function",
};

'''
'''--- projects/market.xyz/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi");
const { getBlock } = require("../helper/getBlock.js");
const {
  transformPolygonAddress,
  transformFantomAddress,
} = require("../helper/portedTokens");

const fusePoolLensAddress = {
  polygon: "0x0e76288Ac7fD4643290Bc857E26A4E7BfBd5aADF",
  fantom: "0x5aB6215AB8344C28B899efdE93BEe47B124200Fb",
};

const WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';

async function getFusePools(
  timestamp,
  block,
  balances,
  borrowed,
  chain,
  transform = (a) => a
) {
  const data = (
    await sdk.api.abi.call({
      target: fusePoolLensAddress[chain],
      block,
      abi: abi,
      chain,
    })
  ).output;

  const length = data["0"].length;

  let totalSupplyInETH = 0;
  let totalBorrowInETH = 0;

  for (let i = 0; i < length; i++) {
    totalSupplyInETH += parseInt(data["2"][i]);
    totalBorrowInETH += parseInt(data["3"][i]);
  }

  if (borrowed) {
    balances[WETH] = totalBorrowInETH;
  } else {
    balances[WETH] = totalSupplyInETH - totalBorrowInETH;
  }
}

async function polygonTvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();
  block = getBlock(timestamp, "polygon", chainBlocks);
  await getFusePools(timestamp, block, balances, false, "polygon", transform);
  return balances;
}
async function polygonBorrowed(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();
  block = getBlock(timestamp, "polygon", chainBlocks);
  await getFusePools(timestamp, block, balances, true, "polygon", transform);
  return balances;
}
async function fantomTvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformFantomAddress();
  block = getBlock(timestamp, "fantom", chainBlocks);
  await getFusePools(timestamp, block, balances, false, "fantom", transform);
  return balances;
}
async function fantomBorrowed(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformFantomAddress();
  block = getBlock(timestamp, "fantom", chainBlocks);
  await getFusePools(timestamp, block, balances, true, "fantom", transform);
  return balances;
}
module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  polygon: {
    tvl: polygonTvl,
    borrowed: polygonBorrowed,
  },
  fantom: {
    tvl: fantomTvl,
    borrowed: fantomBorrowed,
  },
};

'''
'''--- projects/mars/index.js ---
const zero = (timestamp, block) => ({});

module.exports = {
  timetravel: false,
  methodology: "We query Mars protocol smart contracts to get the amount of assets deposited and borrowed, then use CoinGecko to price the assets in USD.",
  terra: {
    tvl: zero,
    borrowed: zero,
  },
};

'''
'''--- projects/marsecosystem/abi.json ---
{
  "sharesTotal": {
    "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }],
    "name": "sharesTotal",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/marsecosystem/index.js ---
const sdk = require("@defillama/sdk");
const utils = require('../helper/utils');
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");
const abi = require("./abi.json");

const url = 'https://api.marsecosystem.com/api/pools';

async function tvl(timestamp, chainBlocks) {
  const rows = (await utils.fetchURL(url)).data;
  const localPools = rows.filter(v => v.masterChef.includes('LiquidityMiningMaster') && !v.baseToken.includes('xms'));
  const remotePools = rows.filter(v => v.masterChef.includes('MarsFarmV2') && !v.baseToken.includes('xms'));
  return await calculate(chainBlocks, localPools, remotePools);
};
async function staking(timstamp, chainBlocks) {
  const rows = (await utils.fetchURL(url)).data;
  const localPools = rows.filter(v => v.masterChef.includes('LiquidityMiningMaster') && v.baseToken.includes('xms'));
  const remotePools = rows.filter(v => v.masterChef.includes('MarsFarmV2') && v.baseToken.includes('xms'));
  return await calculate(chainBlocks, localPools, remotePools);
};

async function calculate(chainBlocks, localPools, remotePools) {
  let balances = {};

  const localPoolsBalances = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      calls: localPools.map(v => ({ target: v.address, params: v.masterChefAddress })),
      abi: 'erc20:balanceOf',
      chain: "bsc",
    })
  ).output.map(v => v.output);

  const transformAdress = await transformBscAddress();

  const lpPositions = [];

  localPools.map((v, i) => {
    if (v.baseToken == v.quoteToken) {
      sdk.util.sumSingleBalance(
        balances,
        `bsc:${v.address}`,
        localPoolsBalances[i]
      );
    } else {
      lpPositions.push({
        token: v.address,
        balance: localPoolsBalances[i]
      });
    }
  });

  const remotePoolsBalances = (
    await sdk.api.abi.multiCall({
      block: chainBlocks["bsc"],
      calls: remotePools.map(v => ({ target: v.masterChefAddress, params: [ v.pid ] })),
      abi: abi.sharesTotal,
      chain: "bsc",
    })
  ).output.map(v => v.output);

  remotePools.map((v, i) => {
    if (v.baseToken == v.quoteToken) {
      sdk.util.sumSingleBalance(
        balances,
        `bsc:${v.address}`,
        remotePoolsBalances[i]
      );
    } else {
      lpPositions.push({
        token: v.address,
        balance: remotePoolsBalances[i]
      });
    }
  });

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["bsc"],
    "bsc",
    transformAdress
  );

  return balances;
}

module.exports = {
  bsc: {
    tvl,
    staking,
    masterchef: tvl,
  }
};

'''
'''--- projects/marshamallowdefi/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IBEP20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accEggPerShare",
                "type": "uint256"
            },
            {
                "internalType": "uint16",
                "name": "depositFeeBP",
                "type": "uint16"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/marshamallowdefi/index.js ---
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2s } = require("../helper/pool2");
const { transformBscAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");

// --- Farms Addresses ---
const masterChefFarms = "0x8932a6265b01D1D4e1650fEB8Ac38f9D79D3957b";
const MASH = "0x787732f27d18495494cea3792ed7946bbcff8db2";

const pool2LpsFarms = [
  "0x87c182edb12f74d561519ab586205fe6cd75363a",
  "0x7621886ac71e985dbea4f3f563bbb5a7865876a8",
  "0x0e70ff44229c6573cc020921345948ba4b5ec7cc",
  "0x9f8223b4b616aa9becb599c93b0430c6bef0443a",
  "0x16940bc578c30c7c10a2cf8a150b98a8b1cee152",
  "0x9EC365D77dCF2b3230399a23D35aEF4318de710D",
  "0xb442780739037577920857DaD91259416b72DE7a",
  "0xC6D926086b29774b10530ab9e02980e9586a061F",
];

// --- SafeFarms Addresses ---
const masterChefSafeFarms = "0xEE49Aa34833Ca3b7d873ED63CDBc031A09226a5d";
const TOFY = "0xe1f2d89a6c79b4242f300f880e490a70083e9a1c";

const pool2LpsSafeFarms = [
  "0x6f73FF29E47C0F49d6Db7EF4B2CE9393256a7C7A",
  "0x753f40F5CdeB085AD4540Dd02a1c0c712EaF51F6",
  "0xc36e93F6D92be42E2eAFB009dF74a0eBFeD5c0C2",
];

const Staking = async (...params) => {
  for (const token of [MASH, TOFY]) {
    if (token == MASH) {
      return staking(masterChefFarms, MASH, "bsc")(...params);
    } else {
      return staking(masterChefSafeFarms, TOFY, "bsc")(...params);
    }
  }
};

const Pool2 = async (...params) => {
  for (const stakingContract of [masterChefFarms, masterChefSafeFarms]) {
    if (stakingContract == masterChefFarms) {
      return pool2s([masterChefFarms], pool2LpsFarms, "bsc")(...params);
    } else {
      return pool2s([masterChefSafeFarms], pool2LpsSafeFarms, "bsc")(...params);
    }
  }
};

const bscTvl = async (chainBlocks) => {
  const balances = {};

  let transformAddress = await transformBscAddress();
  await addFundsInMasterChef(
    balances,
    masterChefFarms,
    chainBlocks["bsc"],
    "bsc",
    transformAddress,
    abi.poolInfo,
    ["0x00000000548997391c670a5179Af731A30e7c3Ad", MASH],
    true,
    true,
    MASH
  );

  await addFundsInMasterChef(
    balances,
    masterChefSafeFarms,
    chainBlocks["bsc"],
    "bsc",
    transformAddress,
    abi.poolInfo,
    [TOFY],
    true,
    true,
    TOFY
  );

  return balances;
};

module.exports = {
  bsc: {
    tvl: bscTvl,
    staking: Staking,
    pool2: Pool2,
  },
  methodology:
    "We count liquidity on the Farms and Pools through MasterChef (Marshamallow and SafeFarm) Contracts",
};

'''
'''--- projects/marspoolin/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const contracts = [
  // pETH18C_CONTRACT
  "0xf3da734c6040665eAc90F1466d23301d6d0b7Cb7",
  // pBTC35A_CONTRACT
  "0x5CBaDe4D03Ea436F792E9f939E70908524949efD",
];

const erc20TokenContracts = [
  // pETH18C_CONTRACT
  "0xA15690E9205De386Ce849889831C1668c300C1ad",
  // pBTC35A_CONTRACT
  "0xA8b12Cc90AbF65191532a12bb5394A714A46d358",
];

const vaultsContracts = [
  // pBTC35A-USDT
  "0xaE26170200ec3aE66B8AfAa87f2FA49C1E0A02B9",
  // pETH18C-USDT
  "0x16A60d78fE6F92D25EBDDAfF6B1efC9d193d4fC8",
  // MARS-USDT
  "0x9b9c2D202F9a0ed9Be9DaF9Df50CC0e327A809dd",
];

const lpVaults = [
  // pBTC35A-USDT LP
  "0x5B1e45cA08fA4d65aA7FDcF9e116990fB7FcE73B",
  // pETH18C-USDT LP
  "0x2Dc9d00DA9542f91D5391bE53Ed1D58a04EC1C07",
  // MARS-USDT LP
  "0x64b91b92240bC1901855Dd55AE632addB650d089",
];

const ethTvl = async (timestamp, ethBlock) => {
  const balances = {};

  const tokenBalance = (
    await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: erc20TokenContracts.map((etc, idx) => ({
        target: etc,
        params: contracts[idx],
      })),
      ethBlock,
    })
  ).output.map((bal) => bal.output);

  for (let index = 0; index < erc20TokenContracts.length; index++) {
    sdk.util.sumSingleBalance(
      balances,
      erc20TokenContracts[index],
      tokenBalance[index]
    );
  }

  const lpBalances = (
    await sdk.api.abi.multiCall({
      abi: 'erc20:balanceOf',
      calls: lpVaults.map((vc, idx) => ({
        target: vc,
        params: vaultsContracts[idx],
      })),
      ethBlock,
    })
  ).output.map((bal) => bal.output);

  const lpPositions = [];

  for (let i = 0; i < lpVaults.length; i++) {
    lpPositions.push({
      balance: lpBalances[i],
      token: lpVaults[i],
    });
  }

  await unwrapUniswapLPs(balances, lpPositions, ethBlock);

  return balances;
};

module.exports = {
  doublecounted: false,
  ethereum: {
    tvl: ethTvl,
  },
};

'''
'''--- projects/matrix.farm/index.js ---
const { get } = require('../helper/http')
const MATRIX_API = "https://api.matrix.farm/statistics/tvl";
let _response

function fetch(key) {
  return async () => {
    if (!_response) _response = get(MATRIX_API)
    return (await _response)[key] 
  }
}

module.exports = {
  doublecounted: true,
  timetravel: false,
  misrepresentedTokens: true,
  methodology: "The TVL is calculated using a google cloud function that runs every minute, it checks the value of all the LPs staked in our vaults and returns the total",
  fantom: {
    fetch: fetch('fantom'),
  },
  optimism: {
    fetch: fetch('optimism'),
  },
  fetch: fetch('tvl')
}

'''
'''--- projects/matrix/abi.json ---
{
  "poolInfo": {
    "type": "function",
    "stateMutability": "view",
    "outputs": [
      {
        "type": "address",
        "name": "lpToken",
        "internalType": "contract IBEP20"
      },
      { "type": "uint256", "name": "allocPoint", "internalType": "uint256" },
      {
        "type": "uint256",
        "name": "lastRewardTime",
        "internalType": "uint256"
      },
      {
        "type": "uint256",
        "name": "accMatrixPerShare",
        "internalType": "uint256"
      },
      { "type": "uint16", "name": "depositFeeBP", "internalType": "uint16" },
      {
        "type": "uint256",
        "name": "harvestInterval",
        "internalType": "uint256"
      }
    ],
    "name": "poolInfo",
    "inputs": [{ "type": "uint256", "name": "", "internalType": "uint256" }]
  }
}

'''
'''--- projects/matrix/index.js ---
const {masterChefExports} = require('../helper/masterchef')
const abi = require('./abi.json')

const MATRIX = "0x35c167b6a1Fc4D1D2b55293367ef5b8D4aF0a696"
module.exports={
    misrepresentedTokens: true,
    methodology: "Tokens in masterchef",
    ...masterChefExports("0xacAb1D5FaBD5c675db07d40De8E0E218EBe75A9e", "cronos", MATRIX, false, abi.poolInfo)
}

'''
'''--- projects/maximizer/allocatorAbi.json ---
{
    "balanceOf":{
        "inputs":[
            {
                "internalType":"address",
                "name":"_token",
                "type":"address"
            }
        ],
        "name":"balanceOf",
        "outputs":[
            {
                "internalType":"uint256",
                "name":"",
                "type":"uint256"
            }
        ],
        "stateMutability":"view",
        "type":"function"
    },
    "pending":{
        "inputs":[
            
        ],
        "name":"pending",
        "outputs":[
            {
                "internalType":"uint256",
                "name":"",
                "type":"uint256"
            }
        ],
        "stateMutability":"view",
        "type":"function"
    },
    "pendingOf":{
        "inputs":[
            {
                "internalType":"address",
                "name":"_token",
                "type":"address"
            }
        ],
        "name":"pendingOf",
        "outputs":[
            {
                "internalType":"uint256",
                "name":"",
                "type":"uint256"
            }
        ],
        "stateMutability":"view",
        "type":"function"
    }
}
'''
'''--- projects/maximizer/index.js ---
const BigNumber = require("bignumber.js");
const { sumTokensAndLPsSharedOwners, unwrapUniswapLPs } = require("../helper/unwrapLPs");
const sdk = require("@defillama/sdk");
const allocatorAbi = require("./allocatorAbi.json");
const pngStakingAbi = require("./stakingRewardsAbi.json");
const joeStakingAbi = require("./stableJoeStakingAbi.json");
const veptpAbi = require("./veptpAbi.json");
const qiTokenAbi = require("./qiTokenAbi.json");

const MaximizerStaking = "0x6d7AD602Ec2EFdF4B7d34A9A53f92F06d27b82B1";
const Treasury = "0x22cF6c46b4E321913ec30127C2076b7b12aC6d15";
const Deployer = "0xb2Fe117269292D41c3b5bdD6B600Fc80239AfBeC";
const PngAllocator = "0x1ff1E60e7af648DFE7B95E025214bfCd6f3D9524";
const JoeAllocator = "0x7613D00f7b49E514Ce84d6369EA12Cc98219Ed40";
const BenqiAllocator = '0x1e3834DA9a9B4d4016427554Ef31ff4e1F41d4Ed';

const MAXI = "0x7C08413cbf02202a1c13643dB173f2694e0F73f0";
const SMAXI = "0xEcE4D1b3C2020A312Ec41A7271608326894076b4";
const DAIe = "0xd586E7F844cEa2F87f50152665BCbc2C279D8d70";
const USDC = "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E";
const USDCe = "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664";
const WAVAX = "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7";
const PNG = "0x60781C2586D68229fde47564546784ab3fACA982";
const QI = "0x8729438EB15e2C8B576fCc6AeCdA6A148776C0F5";
const JOE = "0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd";
const XJOE = "0x57319d41F71E81F3c65F2a47CA4e001EbAFd4F33";
const ISA = "0x3EeFb18003D033661f84e48360eBeCD181A84709";
const PTP = "0x22d4002028f537599bE9f666d1c4Fa138522f9c8";
const VEPTP = "0x5857019c749147EEE22b1Fe63500F237F3c1B692";
const MORE = "0xd9D90f882CDdD6063959A9d837B05Cb748718A05";
const MONEY = "0x0f577433Bf59560Ef2a79c124E9Ff99fCa258948";
const HEC = "0xC7f4debC8072e23fe9259A5C0398326d8EfB7f5c";
const SAVAX = "0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE";
const MAXI_DAI_JLP = "0xfBDC4aa69114AA11Fae65E858e92DC5D013b2EA9";
const MAXI_WAVAX_PGL = "0xbb700450811a30c5ee0dB80925Cf1BA53dBBd60A";
const PNG_WAVAX_PGL = "0xd7538cABBf8605BdE1f4901B47B8D42c61DE0367";
const QI_WAVAX_PGL = "0xE530dC2095Ef5653205CF5ea79F8979a7028065c";
const JOE_WAVAX_JLP = "0x454E67025631C065d3cFAD6d71E6892f74487a15";
const ISA_WAVAX_JLP = "0x9155f441FFDfA81b13E385bfAc6b3825C05184Ee";
const PTP_WAVAX_JLP = "0xCDFD91eEa657cc2701117fe9711C9a4F61FEED23";
const MORE_WAVAX_JLP = "0xb8361D0E3F3B0fc5e6071f3a3C3271223C49e3d9";
const HEC_WAVAX_JLP = "0x4dc5291cdc7ad03342994e35d0ccc76de065a566";
const AVAX_QITOKEN = "0x5C0401e81Bc07Ca70fAD469b451682c0d747Ef1c";
const QI_QITOKEN = "0x35Bd6aedA81a7E5FC7A7832490e71F757b0cD9Ce";
const DAI_QITOKEN = "0x835866d37AFB8CB8F8334dCCdaf66cf01832Ff5D";
const USDC_QITOKEN = "0xB715808a78F6041E46d61Cb123C9B4A27056AE9C";
const SAVAX_QITOKEN = "0xF362feA9659cf036792c9cb02f8ff8198E21B4cB";

const PngStaking = "0x88afdaE1a9F58Da3E68584421937E5F564A0135b";
const JoeStaking = "0x1a731B2299E22FbAC282E7094EdA41046343Cb51";

const Allocators = [
  { allocator: PngAllocator, stakeToken: PNG, yieldToken: PNG, yieldStaking: PngStaking, abi: pngStakingAbi.balanceOf, params: [ PngAllocator ], transformResult: (result) => result.output },
  { allocator: JoeAllocator, stakeToken: JOE, yieldToken: JOE, yieldStaking: JoeStaking, abi: joeStakingAbi.getUserInfo, params: [ JoeAllocator, USDC ], transformResult: (result) => result.output.amount },
];
const Allocations = [
  { allocator: PngAllocator, token: PNG_WAVAX_PGL, pid: 0 },
  { allocator: PngAllocator, token: QI_WAVAX_PGL, pid: 19 },
  { allocator: PngAllocator, token: MAXI_WAVAX_PGL, pid: 42 },
  { allocator: JoeAllocator, token: JOE_WAVAX_JLP, pid: 0 },
  { allocator: JoeAllocator, token: ISA_WAVAX_JLP, pid: 36 },
  { allocator: JoeAllocator, token: HEC_WAVAX_JLP, pid: 41 },
  { allocator: JoeAllocator, token: MORE_WAVAX_JLP, pid: 44 },
];

const BenqiMarkets = [
  { qiToken: AVAX_QITOKEN, underlyingToken: WAVAX },
  { qiToken: QI_QITOKEN, underlyingToken: QI },
  { qiToken: DAI_QITOKEN, underlyingToken: DAIe },
  { qiToken: USDC_QITOKEN, underlyingToken: USDC },
  { qiToken: SAVAX_QITOKEN, underlyingToken: SAVAX },
];

const Tokens = [
  [MAXI, false],
  [SMAXI, false],
  [DAIe, false],
  [USDC, false],
  [WAVAX, false],
  [PNG, false],
  [QI, false],
  [JOE, false],
  [ISA, false],
  [PTP, false],
  [MORE, false],
  [MONEY, false],
  [HEC, false],
  [MAXI_DAI_JLP, true],
  [MAXI_WAVAX_PGL, true],
  [PNG_WAVAX_PGL, true],
  [QI_WAVAX_PGL, true],
  [JOE_WAVAX_JLP, true],
  [ISA_WAVAX_JLP, true],
  [PTP_WAVAX_JLP, true],
  [MORE_WAVAX_JLP, true],
  [HEC_WAVAX_JLP, true],
];

function compareToIgnoreCase(a, b) {
  return a.toLowerCase() === b.toLowerCase();
};

const transformAddress = (addr) => {
  let resultantAddress = addr;
  // sMAXI -> MAXI
  if (compareToIgnoreCase(addr, SMAXI)) {
    resultantAddress = MAXI;
  }
  // USDC -> USDC.e
  if (compareToIgnoreCase(addr, USDC)) {
    resultantAddress = USDCe;
  }
  // MONEY -> DAI
  if (compareToIgnoreCase(addr, MONEY)) {
    resultantAddress = DAIe;
  }
  // xJOE -> JOE
  if (compareToIgnoreCase(addr, XJOE)) {
    resultantAddress = JOE;
  }
  return `avax:${resultantAddress.toLowerCase()}`;
};

const chainConfig = (chainBlocks) => ({
  block: chainBlocks.avax,
  chain: "avax",
  transformAddress,
});

const staking = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const stakingBalance = await sdk.api.abi.call({
    abi: "erc20:balanceOf",
    target: MAXI,
    params: MaximizerStaking,
    block: chainBlocks.avax,
    chain: "avax",
  });

  sdk.util.sumSingleBalance(balances, "avax:" + MAXI, stakingBalance.output);

  return balances;
};

async function tvl(timestamp, block, chainBlocks) {
  const config = chainConfig(chainBlocks);
  const balances = {};

  await sumTokensAndLPsSharedOwners(
    balances,
    Tokens,
    [Treasury],
    config.block,
    config.chain,
    config.transformAddress,
  );

  const allocatedLps = await sdk.api.abi.multiCall({
    calls: Allocations.map(allocation => ({
      target: allocation.allocator,
      params: [allocation.token]
    })),
    abi: allocatorAbi.balanceOf,
    ...config,
  });
  
  await unwrapUniswapLPs(
    balances,
    Allocations.map((allocation, index) => ({
      balance: allocatedLps.output[index].output,
      token: allocation.token,
    })),
    config.block,
    config.chain,
    config.transformAddress,
  );

  const stakedYieldTokens = (await Promise.all(
    Allocators.map(allocator => (
      sdk.api.abi.call({
        target: allocator.yieldStaking,
        params: allocator.params,
        abi: allocator.abi,
        ...config,
      })
    ))
  )).map((result, index) => Allocators[index].transformResult(result));

  const pendingYieldTokens = (await sdk.api.abi.multiCall({
    calls: Allocators.map(allocator => ({
      target: allocator.allocator,
    })),
    abi: allocatorAbi.pending,
    ...config,
  })).output.map(result => result.output);

  for (const [index, allocator] of Allocators.entries()) {
    sdk.util.sumSingleBalance(balances, config.transformAddress(allocator.stakeToken), stakedYieldTokens[index]);
    sdk.util.sumSingleBalance(balances, config.transformAddress(allocator.yieldToken), pendingYieldTokens[index]);
  };

  for (const market of BenqiMarkets) {
    const [balance, exchangeRate] = await Promise.all([
      sdk.
      api.abi.call({ target: market.qiToken, abi: qiTokenAbi.balanceOf, params: [BenqiAllocator], ...config }),
      sdk.api.abi.call({ target: market.qiToken, abi: qiTokenAbi.exchangeRateStored, params: [], ...config }),
    ]);
    const underlyingTokenBalance = new BigNumber(balance.output).times(new BigNumber(exchangeRate.output)).div(new BigNumber(1e18));
    sdk.util.sumSingleBalance(balances, config.transformAddress(market.underlyingToken), underlyingTokenBalance.toFixed(0));
  }

  const stakedPtp = (await sdk.api.abi.call({
    target: VEPTP,
    abi: veptpAbi.getStakedPtp,
    params: [Deployer],
    ...config,
  })).output;
  sdk.util.sumSingleBalance(balances, config.transformAddress(PTP), stakedPtp);

  return balances;
};

module.exports = {
  avalanche: {
    tvl,
    staking,
  },
  methodology:
    "Counts MAXI, MAXI LP (MAXI-DAI.e JLP, MAXI-WAVAX PGL), DAI.e, USDC, WAVAX, liquidity tokens (PGL, JLP), single partner tokens on the treasury and allocators",
};

'''
'''--- projects/maximizer/qiTokenAbi.json ---
{
    "balanceOf": {
        "inputs": [
            {
                "internalType":"address",
                "name":"_token",
                "type":"address"
            }
        ],
        "name":"balanceOf",
        "outputs": [
            {
                "internalType":"uint256",
                "name":"",
                "type":"uint256"
            }
        ],
        "stateMutability":"view",
        "type":"function"
    },
    "exchangeRateStored": {
        "constant": true,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type":"uint256"
            }
        ]
    }
}
'''
'''--- projects/maximizer/stableJoeStakingAbi.json ---
{
    "getUserInfo": {
        "inputs": [
            {
                "internalType": "address",
                "name": "_user",
                "type": "address"
            },
            {
                "internalType": "contract IERC20Upgradeable",
                "name": "_rewardToken",
                "type": "address"
            }
        ],
        "name": "getUserInfo",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "rewardDebt",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/maximizer/stakingRewardsAbi.json ---
{
    "balanceOf": {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/maximizer/veptpAbi.json ---
{
    "getStakedPtp":{
        "inputs": [
            {
                "internalType": "address",
                "name": "_addr",
                "type": "address"
            }
        ],
        "name": "getStakedPtp",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/mcdex/index.js ---
const sdk = require('@defillama/sdk');
const {gql} = require('graphql-request')
const { blockQuery } = require('../helper/graph')
const {toUSDTBalances} = require('../helper/balances');
const {getBlock} = require('../helper/getBlock');

const axios = require('axios');

async function GenerateCallList() {
    const markets = (await axios.get('https://mcdex.io/api/markets')).data.data.markets;
    const marketStatus = (await axios.get('https://mcdex.io/api/markets/status')).data.data;
    let id2Info = {};
    markets.forEach(market => {
        const id = market.id;
        if (market.contractType === 'Perpetual') {
            id2Info[id] = {perpetualAddress: market.perpetualAddress};
        }
    });
    marketStatus.forEach(status => {
        if (status === null) {
            return;
        }
        const id = status.marketID;
        if (id2Info[id] && status.perpetualStorage && status.perpetualStorage.collateralTokenAddress !== '0x0000000000000000000000000000000000000000') {
            id2Info[id].collateralTokenAddress = status.perpetualStorage.collateralTokenAddress;
        }
    });
    let calls = []
    Object.values(id2Info).map((info, id) => {
        if (info.collateralTokenAddress && info.perpetualAddress) {
            calls.push({
                target: info.collateralTokenAddress,
                params: info.perpetualAddress
            })
        }
    });
    return calls;
}

async function ethereum(timestamp, block) {
    const ethBalance = (await sdk.api.eth.getBalance({
        target: '0x220a9f0DD581cbc58fcFb907De0454cBF3777f76',
        block
    })).output;
    let balances = {
        "0x0000000000000000000000000000000000000000": ethBalance,
    };

    const erc20Calls = await GenerateCallList();
    const balanceOfResults = await sdk.api.abi.multiCall({
        block,
        calls: erc20Calls,
        abi: 'erc20:balanceOf'
    });

    await sdk.util.sumMultiBalanceOf(balances, balanceOfResults);
    return balances;
}

async function getTVL(subgraphName, block) {
    const endpoint = `https://api.thegraph.com/subgraphs/name/mcdexio/${subgraphName}`

    const query = gql`
        query getTvl($block: Int) {
            factories(
                block: { number: $block }
            ) {
                id
                totalValueLockedUSD
            }
        }
    `;
    const results = await blockQuery(endpoint, query, block, 600)
    return results.factories[0].totalValueLockedUSD;
}

async function arbitrum(timestamp, ethBlock, chainBlocks) {
    return toUSDTBalances(await getTVL("mcdex3-arb-perpetual", await getBlock(timestamp, "arbitrum", chainBlocks)))
}

async function bsc(timestamp, ethBlock, chainBlocks) {
    return toUSDTBalances(await getTVL("mcdex3-bsc-perpetual", await getBlock(timestamp, "bsc", chainBlocks)))
}

module.exports = {
    misrepresentedTokens: true,
    methodology: `Includes all locked liquidity in AMM pools, pulling the data from the mcdex subgraph`,
    arbitrum: {
        tvl: arbitrum
    },
    bsc: {
        tvl: bsc
    },
    ethereum: {
        tvl: ethereum
    },
}

'''
'''--- projects/mdex/abi.json ---
{
    "allPairs": {
      "constant": true,
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allPairs",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    "allPairsLength": {
      "constant": true,
      "inputs": [],
      "name": "allPairsLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  }
  
'''
'''--- projects/mdex/api.js ---
const sdk = require("@defillama/sdk");
const { calculateUniTvl } = require('../helper/calculateUniTvl');
const { calculateUsdUniTvl } = require("../helper/getEfficientUsdUniTvl");
const { transformBscAddress } = require('../helper/portedTokens.js')

const factories = {
  heco: "0xb0b670fc1F7724119963018DB0BfA86aDb22d941",
  bsc: "0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8",
};

const hecoTvl = calculateUsdUniTvl(factories.heco, 'heco',
  "0xa71edc38d189767582c38a3145b5873052c3e47a", //USDT
  [
    "0x64ff637fb478863b7468bc97d30a5bf3a428a1fd", //ETH
    "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f", //WHT
    "0x66a79d23e58475d2738179ca52cd0b41d73f0bea", //HBTC
    "0x0298c2b32eae4da002a15f36fdf7615bea3da047", //HUSD
    "0x25d2e80cb6b86881fd7e07dd263fb79f4abe033c", //MDX
  ],
  "tether");

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const transform = await transformBscAddress();
  return calculateUniTvl(transform, chainBlocks.bsc, 'bsc', factories.bsc, 0, true)
};

module.exports = {
  misrepresentedTokens: true,
  timetravel: false,
  /*
  heco: {
    tvl: hecoTvl,
  },
  */
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/mdex/index.js ---
const retry = require('async-retry');
const axios = require("axios");

async function fetch(chainId) {
    return (await retry(async () => 
        await axios.get(`https://info.mdex.one/pair/tvl?chain_id=${chainId}`)
    )).data.result
    .map(p => p.tvl)
    .reduce((a, b) => a + parseFloat(b), 0);
}; 

async function heco() { 
    return (await fetch(128));
};
async function bsc() { 
    return (await fetch(56));
};
async function total() {
    return (await fetch(128)) + (await fetch(56));
};

module.exports = {
    timetravel: false,
    heco: {
        fetch: heco
    },
    bsc: {
        fetch: bsc
    },
    fetch: total
};

'''
'''--- projects/mdex/subgraphs.js ---
const { request, gql } = require("graphql-request");
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const { calculateUniTvl } = require('../helper/calculateUniTvl')
const {toUSDTBalances} = require('../helper/balances');
const { getBlock } = require("../helper/getBlock");

// --> bsc addresses found here:    https://github.com/mdexSwap/bscswap
// --> heco addresses found here:   https://github.com/mdexSwap/contracts

const factories = {
  heco: "0xb0b670fc1F7724119963018DB0BfA86aDb22d941",
  bsc: "0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8",
};

const REDUCE_BLOCK = 60;

const graphUrls = {
  heco: "https://heco-lite-graph.mdex.cc/subgraphs/name/chain/heco",
  bsc: "https://bsc-lite-graph.mdex.one/subgraphs/name/chain/bsc",
};

const graphQueries = {
  heco: gql`
    query tvl($block: Int) {
      mdexFactory(
        id: "0xb0b670fc1F7724119963018DB0BfA86aDb22d941"
        block: { number: $block }
      ) {
        totalLiquidityUSD
      }
    }
  `,
  bsc: gql`
    query tvl($block: Int) {
      mdexFactory(
        id: "0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8"
        block: { number: $block }
      ) {
        totalLiquidityUSD
      }
    }
  `,
};

// --- We need to token as ref for the balances object ---
const usdtToken = "0xdac17f958d2ee523a2206206994597c13d831ec7";

function getMDEXLiquidity(block, chain) {
  return request(graphUrls[chain], graphQueries[chain], {
    block,
  });
}

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const chain = "bsc"
  const block = await getBlock(timestamp, chain, chainBlocks)
  const results = await request(graphUrls[chain], graphQueries[chain], {
    block,
  });
  return toUSDTBalances(results.mdexFactory.totalLiquidityUSD)
};

const hecoTvl = async (timestamp, ethBlock, chainBlocks) => {
  let block = chainBlocks["heco"];

  if (block === undefined) {
    block = (await sdk.api.util.lookupBlock(timestamp, { chain: "heco" }))
      .block;
  }

  // --- Reduce a bit as the indexing takes time to catch up, otherwise error jumps somehow from endpoint ---
  const results = await getMDEXLiquidity(block - REDUCE_BLOCK, "heco");

  return {
    // --- Arrange to account the decimals as it was usdt (decimals = 6) ---
    [usdtToken]: BigNumber(results.mdexFactory.totalLiquidityUSD)
      .multipliedBy(10 ** 6)
      .toFixed(0),
  };
};

module.exports = {
  misrepresentedTokens: true,
  bsc: {
    tvl: bscTvl, //   individually outputs >1B    ---   breakdown per token             (OK)
  },
  heco: {
    tvl: hecoTvl, //  individually outputs >1B    ---   simply using graphql endpoint   (OK)
  },
};

'''
'''--- projects/meanfinance/abi.json ---
{
  "allPairs": {
    "inputs": [],
    "name": "allPairs",
    "outputs": [
      { "internalType": "address[]", "name": "_pairs", "type": "address[]" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "tokenA": {
    "inputs": [],
    "name": "tokenA",
    "outputs": [
      {
        "internalType": "contract IERC20Metadata",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "tokenB": {
    "inputs": [],
    "name": "tokenB",
    "outputs": [
      {
        "internalType": "contract IERC20Metadata",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "availableToBorrow": {
    "inputs": [],
    "name": "availableToBorrow",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "_amountToBorrowTokenA",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_amountToBorrowTokenB",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/meanfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { getChainTransform } = require("../helper/portedTokens")
const { request, gql } = require("graphql-request");

const STABLE_VERSION = '0x059d306A25c4cE8D7437D25743a8B94520536BD5'
const VULN_VERSION = '0x230C63702D1B5034461ab2ca889a30E343D81349'
const BETA_VERSION = '0x24F85583FAa9F8BD0B8Aa7B1D1f4f53F0F450038'

const VERSIONS = {
  optimism: [
    { contract: STABLE_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-optimism' },
    { contract: VULN_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-vulnerable-optimism' },
    { contract: BETA_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-optimism-beta' },
  ],
  polygon: [ 
    { contract: STABLE_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-polygon' },
    { contract: VULN_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-vulnerable-polygon' },
  ],
  arbitrum: [
    { contract: STABLE_VERSION, subgraph: 'https://api.thegraph.com/subgraphs/name/mean-finance/dca-v2-arbitrum' },
  ]
}

const query = gql`
  query tokens {
    tokens (where: { id_not: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" }) {
      id
    }
  }`
;

const getTokensInChain = async (subgraph) => {
  const result = await request(subgraph, query);
  return result.tokens.map(({ id }) => id)
};

function getV2TvlObject(chain) {
  return {
    tvl: (_, __, chainBlocks) => getV2TVL(chain, chainBlocks[chain])
  }
}

async function getV2TVL(chain, block) {
  const balances = {};
  for (const version of VERSIONS[chain]) {
    await getV2TVLForVersion(balances, chain, version, block)
  }
  return balances
}

async function getV2TVLForVersion(balances, chain, version, block) {
  const { contract, subgraph } = version
  const tokens = await getTokensInChain(subgraph)
  const chainTransform = await getChainTransform(chain)
  for (const token of tokens) {
    const balance = await sdk.api.erc20.balanceOf({
      target: token,
      owner: contract,
      block,
      chain
    })
    sdk.util.sumSingleBalance(balances, chainTransform(token), balance.output);
  }
}

//DCA Factory
const factoryAddress = "0xaC4a40a995f236E081424D966F1dFE014Fe0e98A";

//Helper for ABI calls
async function abiCall(target, abi, block) {
  let result = await sdk.api.abi.call({
    target: target,
    abi: abi,
    block: block,
  });
  return result;
}

async function ethTvl(timestamp, block) {
  const balances = {};
  //Gets all pairs
  const pairCall = await abiCall(factoryAddress, abi["allPairs"], block);

  const pairs = pairCall.output;

  //Calls for tokens in pair and balances of them then adds to balance
  for (let i = 0; i < pairs.length; i++) {
    const pool = pairs[i];
    const token1 = (await abiCall(pool, abi["tokenA"], block)).output;
    const token2 = (await abiCall(pool, abi["tokenB"], block)).output;
    const poolBalances = (await abiCall(pool, abi["availableToBorrow"], block)).output;
    const token1Balance = poolBalances[0];
    const token2Balance = poolBalances[1];
    sdk.util.sumSingleBalance(balances, token1, token1Balance);
    sdk.util.sumSingleBalance(balances, token2, token2Balance);
  }

  return balances;
}

module.exports = {
  ethereum: {
    tvl: ethTvl
  },
  optimism: getV2TvlObject('optimism'),
  polygon: getV2TvlObject('polygon'),
  arbitrum: getV2TvlObject('arbitrum'),
};

'''
'''--- projects/meld/index.js ---
const axios = require('axios')

async function staking(){
    const meldLocked = (await axios.get("https://cardano-mainnet.blockfrost.io/api/v0/addresses/addr1wxar2qwdzuxfvdyuxsk9aapy93vkkk904mxullqtkp90pmqh0xrmz", {
        headers:{
            project_id: "mainnetTV9qV3mfZXbE6e44TVGMe1UoRlLrpSQt"
        }
    })).data.amount.find(token=>token.unit==="6ac8ef33b510ec004fe11585f7c5a9f0c07f0c23428ab4f29c1d7d104d454c44").quantity
    return {
        "meld": meldLocked/1e6
    }
}

module.exports={
    timetravel: false,
    cardano:{
        staking,
        tvl:()=>({}),
    }
}

'''
'''--- projects/mensa/abi.json ---
{
  "getReservesList":{"inputs":[],"name":"getReservesList","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
  "getAMMReserveData":{"inputs":[{"internalType":"address","name":"asset","type":"address"}],"name":"getReserveData","outputs":[{"components":[{"components":[{"internalType":"uint256","name":"data","type":"uint256"}],"internalType":"struct DataTypes.ReserveConfigurationMap","name":"configuration","type":"tuple"},{"internalType":"uint128","name":"liquidityIndex","type":"uint128"},{"internalType":"uint128","name":"variableBorrowIndex","type":"uint128"},{"internalType":"uint128","name":"currentLiquidityRate","type":"uint128"},{"internalType":"uint128","name":"currentVariableBorrowRate","type":"uint128"},{"internalType":"uint128","name":"currentStableBorrowRate","type":"uint128"},{"internalType":"uint40","name":"lastUpdateTimestamp","type":"uint40"},{"internalType":"address","name":"aTokenAddress","type":"address"},{"internalType":"address","name":"stableDebtTokenAddress","type":"address"},{"internalType":"address","name":"variableDebtTokenAddress","type":"address"},{"internalType":"address","name":"interestRateStrategyAddress","type":"address"},{"internalType":"uint8","name":"id","type":"uint8"}],"internalType":"struct DataTypes.ReserveData","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},
  "getCurrentTokens":{"constant":true,"inputs":[],"name":"getCurrentTokens","outputs":[{"internalType":"address[]","name":"tokens","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},
  "getReserveData": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_reserve",
        "type": "address"
      }
    ],
    "name": "getReserveData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "totalLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "availableLiquidity",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalBorrowsStable",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalBorrowsVariable",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "averageStableBorrowRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "utilizationRate",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidityIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "variableBorrowIndex",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "aTokenAddress",
        "type": "address"
      },
      {
        "internalType": "uint40",
        "name": "lastUpdateTimestamp",
        "type": "uint40"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveConfigurationData": {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "_reserve",
        "type": "address"
      }
    ],
    "name": "getReserveConfigurationData",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "ltv",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidationThreshold",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidationBonus",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "interestRateStrategyAddress",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "usageAsCollateralEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "borrowingEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "stableBorrowRateEnabled",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "isActive",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getReserves": {
    "constant": true,
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  "getAddressesProvidersList": {
    "inputs": [],
    "name": "getAddressesProvidersList",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAddress": {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "id",
        "type": "bytes32"
      }
    ],
    "name": "getAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getAllATokens": {
    "inputs": [],
    "name": "getAllATokens",
    "outputs": [
      {
        "components": [
          {
            "internalType": "string",
            "name": "symbol",
            "type": "string"
          },
          {
            "internalType": "address",
            "name": "tokenAddress",
            "type": "address"
          }
        ],
        "internalType": "struct AaveProtocolDataProvider.TokenData[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getUnderlying": {
    "inputs": [],
    "name": "UNDERLYING_ASSET_ADDRESS",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "getReserveDataV2": {
      "inputs": [
          {
              "internalType": "address",
              "name": "asset",
              "type": "address"
          }
      ],
      "name": "getReserveData",
      "outputs": [
          {
              "internalType": "uint256",
              "name": "availableLiquidity",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "totalStableDebt",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "totalVariableDebt",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "liquidityRate",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "variableBorrowRate",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "stableBorrowRate",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "averageStableBorrowRate",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "liquidityIndex",
              "type": "uint256"
          },
          {
              "internalType": "uint256",
              "name": "variableBorrowIndex",
              "type": "uint256"
          },
          {
              "internalType": "uint40",
              "name": "lastUpdateTimestamp",
              "type": "uint40"
          }
      ],
      "stateMutability": "view",
      "type": "function"
  },
  "getBPool": {
    "inputs": [],
    "name": "bPool",
    "outputs": [
      {
        "internalType": "contract IBPool",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/mensa/index.js ---
const sdk = require("@defillama/sdk");

const abi = require('./abi.json');
const {transformFantomAddress} = require('../helper/portedTokens')

const _mensaCoreAddress = '0xa7D5d34207eb2EfB510Fb15b06feE6224Cd936Cd';

async function tvl(_, _ethBlock, chainBlocks) {

  const reserves_mensa = (
    await sdk.api.abi.call({
      target: _mensaCoreAddress,
      abi: abi["getReserves"],
      block: chainBlocks['fantom'],
      chain: 'fantom'
    })
  ).output.filter(t=>t!=="0x1111111111111111111111111111111111111111");

  const decimalsOfReserve = (
    await sdk.api.abi.multiCall({
      calls: reserves_mensa.map((reserve) => ({
        target: reserve
      })),
      abi: "erc20:decimals",
      block: chainBlocks['fantom'],
      chain: 'fantom'
    })
  ).output;

  const assets = [];
  reserves_mensa.map((reserve, i) => {

    let symbol;

    let decimals = decimalsOfReserve[i];
    if (decimals.success) {
      assets.push({
        address: reserve,
      })
    } else {
      throw new Error("Call failed")
    }
  })

  const balance_ftm = (
    await sdk.api.eth.getBalance({
      target: _mensaCoreAddress,
      block: chainBlocks['fantom'],
      chain: 'fantom'
    })
  ).output;

  const balanceOfResults = await sdk.api.abi.multiCall({
    block: chainBlocks['fantom'],
    chain: 'fantom',
    calls: assets.map((reserve) => ({
      target: reserve.address,
      params: _mensaCoreAddress,
    })),
    abi: "erc20:balanceOf",
  })

  const balances = {};
  const transform = await transformFantomAddress()

  assets.forEach((_item,_i)=>{
    balances[transform(_item.address)] = balanceOfResults.output[_i].output;
  })

  balances['fantom:0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83'] = balance_ftm

  return balances;

}

module.exports = {
  deadFrom: 1648765747,
  misrepresentedTokens: true,
  methodology: 'Using the same methodology applied to other lending platforms, TVL for Mensa consists deposits made to the protocol and borrowed tokens are not counted.',
  fantom:{
    tvl,
  },
};

'''
'''--- projects/mento/index.js ---
const sdk = require('@defillama/sdk')
const BigNumber = require("bignumber.js");
const { getBlock } = require('../helper/getBlock');

async function tvl(timestamp, ethBlock, chainBlocks) {

    /*
        Mento is an automated market maker (AMM) type of decentralized exchange thats native to the Celo platform. Its responsible 
        for helping the Celo Dollar (cUSD) maintain its peg to the USD. When demand for the stablecoin increases the Celo protocol 
        mints cUSD and sells them for CELO (Celos native asset) via Mento. The CELO assets are used as cUSD collateral and are 
        stored in the Celo reserve. This all happens on-chain. If demand for cUSD decreases then the reverse process happens. 
        Mento arbitrage opportunities arise in cases where theres cUSD/USD depeg. This incentive for traders should help 
        restore the cUSD/USD peg.
        More info here: https://medium.com/celoorg/zooming-in-on-the-celo-expansion-contraction-mechanism-446ca7abe4f
    */

    const mento_contract_address = '0x9380fA34Fd9e4Fd14c06305fd7B6199089eD4eb9';
    const mento_locked_contract_address = '0x246f4599eFD3fA67AC44335Ed5e749E518Ffd8bB';

    const block = chainBlocks.celo

    const mento_pooled = await sdk.api.eth.getBalance({
        target: mento_contract_address,
        block,
        chain: 'celo'
    })

    const mento_locked_pooled = await sdk.api.eth.getBalance({
        target: mento_locked_contract_address,
        block,
        chain: 'celo'
    })

    return {
        'celo': Number(mento_pooled.output) / 1e18 + Number(mento_locked_pooled.output) / 1e18
    };
}

module.exports = {
    methodology: 'TVL counts Celo deposited as collateral to mint cUSD.',
    celo: { tvl },
}

'''
'''--- projects/meowfinance/abi.json ---
{
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "totalToken": {
    "inputs": [],
    "name": "totalToken",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "vaultDebtVal": {
    "inputs": [],
    "name": "vaultDebtVal",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "poolInfo": {
    "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "name": "poolInfo",
    "outputs": [
      { "internalType": "address", "name": "stakeToken", "type": "address" },
      { "internalType": "uint256", "name": "allocPoint", "type": "uint256" },
      {
        "internalType": "uint256",
        "name": "lastRewardTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accMeowPerShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IUniswapV2Pair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "masterchef": {
    "inputs": [],
    "name": "masterChef",
    "outputs": [
      {
        "internalType": "contract ISpookyMasterChef",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "pid": {
    "inputs": [],
    "name": "pid",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfo": {
    "inputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "userInfo",
    "outputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/meowfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const { pool2Exports } = require("../helper/pool2");
const { stakingUnknownPricedLP } = require("../helper/staking");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");

const meow = "0x41F4CC9613E31d4E77C428b40D53537Da24264Ee";
const meowMining = "0xba1a3dACa919616aA462E93A80EFbe82753f9087";
const meowFtm = "0x150Aeb5389d56E258c2bbb42c7e67e944EDEE913";
const treasuryContract = "0x7d25f49C648B2a12B5f530Df929204352cb6080e";

const translate = {
  "0x049d68029688eabf473097a2fc38ef61633a3c7a":
    "0xdac17f958d2ee523a2206206994597c13d831ec7",
  "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e":
    "0x6b175474e89094c44da98b954eedeac495271d0f",
};

const workers = [
  "0x5f1D549826e1AE30D653aD17e7277Fb7C6AC7EDD", // SpiritswapWorker_USDC_FTM_Spirit_Worker
  "0x9719F0e303db3aA8F04199b74654925516a6E9d5", // SpiritswapWorker_fUSDT_FTM_Spirit_Worker
  "0x0aE50E933491Cc541840f3c4982fd290885abfb6", // SpookyswapWorker_BNB_FTM_Spooky_Worker
  "0x5a1F2E391873ef63F727fEA1eDe8E4F6cf98b386", // SpookyswapWorker_BOO_FTM_Spooky_Worker
  "0x585AC8672F43f81f3e39c2E22680F071eBbB6838", // SpookyswapWorker_BTC_FTM_Spooky_Worker
  "0x3AE6751A57b5e72E52451E8C51E5f7F295B419Bc", // SpookyswapWorker_DAI_FTM_Spooky_Worker
  "0xa5FA401ad612246fD57337472254E339fE02d3Be", // SpookyswapWorker_ETH_FTM_Spooky_Worker
  "0x2e66442814bb4555276614E6C62d1cc3AF64a721", // SpookyswapWorker_LINK_FTM_Spooky_Worker
  "0xAd93a6f25a9e50ee7DeaA270f50418EBC57dA021", // SpookyswapWorker_SUSHI_FTM_Spooky_Worker
  "0x42289105e0271535AB631098e0cfC358c01E7c18", // SpookyswapWorker_USDC_FTM_Spooky_Worker
  "0x498bfdF61Ab7ca100E246DB0bEd893600329e957", // SpookyswapWorker_WFTM_BOO_Spooky_Worker
  "0xEa61Ecd00dd603bA6C69E4B4323310285966F450", // SpookyswapWorker_WFTM_BTC_Spooky_Worker
  "0x4293F2f8B6817633D92b6FCA585Da42d856BFfA4", // SpookyswapWorker_WFTM_DAI_Spooky_Worker
  "0x6F2E8565335dDaC37AAc62a855e452D17ee98038", // SpookyswapWorker_WFTM_ETH_Spooky_Worker
  "0xfB1d7b5Bf5E59bF158553cdEbf8CF892BD3Ec503", // SpookyswapWorker_WFTM_USDC_Spooky_Worker
  "0xF7C0B655C7C676A715c5CEfa39A887779B2ab2b0", // SpookyswapWorker_WFTM_fUSDT_Spooky_Worker
  "0xC14f48826EB564201Bf7D7111f0b46e2301bF36A", // SpookyswapWorker_fUSDT_FTM_Spooky_Worker
];

async function calcTvl(block, chain, borrow) {
  let balances = {};
  const poolLength = (
    await sdk.api.abi.call({
      target: meowMining,
      abi: abi.poolLength,
      block,
      chain,
    })
  ).output;
  const poolInfo = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: Number(poolLength) }, (_, k) => ({
        target: meowMining,
        params: k,
      })),
      abi: abi.poolInfo,
      block,
      chain,
    })
  ).output;
  const symbols = (
    await sdk.api.abi.multiCall({
      calls: poolInfo.map((p) => ({
        target: p.output.stakeToken,
      })),
      abi: "erc20:symbol",
      block,
      chain,
    })
  ).output;
  let ibTokens = [];
  symbols.forEach((p) => {
    if (p.output.startsWith("ib")) {
      ibTokens.push(p.input.target);
    }
  });
  const underlyingtoken = (
    await sdk.api.abi.multiCall({
      calls: ibTokens.map((p) => ({
        target: p,
      })),
      abi: abi.token,
      block,
      chain,
    })
  ).output;
  const totalToken = (
    await sdk.api.abi.multiCall({
      calls: ibTokens.map((p) => ({
        target: p,
      })),
      abi: abi.totalToken,
      block,
      chain,
    })
  ).output;
  const vaultDebtVal = (
    await sdk.api.abi.multiCall({
      calls: ibTokens.map((p) => ({
        target: p,
      })),
      abi: abi.vaultDebtVal,
      block,
      chain,
    })
  ).output;
  for (let i = 0; i < ibTokens.length; i++) {
    let token = underlyingtoken[i].output.toLowerCase();
    let total = Number(totalToken[i].output);
    let debt = Number(vaultDebtVal[i].output);
    if (translate[token] !== undefined) {
      token = translate[token];
    } else {
      token = `fantom:${token}`;
    }
    if (!borrow) {
      sdk.util.sumSingleBalance(balances, token, total - debt);
    } else {
      sdk.util.sumSingleBalance(balances, token, debt);
    }
  }
  return balances;
}

async function tvl(timestamp, block, chainBlocks) {
  let balances = await calcTvl(chainBlocks.fantom, "fantom", false);
  const lpTokens = (
    await sdk.api.abi.multiCall({
      calls: workers.map((p) => ({
        target: p,
      })),
      abi: abi.lpToken,
      block: chainBlocks.fantom,
      chain: "fantom",
    })
  ).output;
  const masterchefs = (
    await sdk.api.abi.multiCall({
      calls: workers.map((p) => ({
        target: p,
      })),
      abi: abi.masterchef,
      block: chainBlocks.fantom,
      chain: "fantom",
    })
  ).output;
  const pids = (
    await sdk.api.abi.multiCall({
      calls: workers.map((p) => ({
        target: p,
      })),
      abi: abi.pid,
      block: chainBlocks.fantom,
      chain: "fantom",
    })
  ).output;
  const userInfos = (
    await sdk.api.abi.multiCall({
      calls: Array.from({ length: workers.length }, (_, k) => ({
        target: masterchefs[k].output,
        params: [pids[k].output, workers[k]],
      })),
      abi: abi.userInfo,
      block: chainBlocks.fantom,
      chain: "fantom",
    })
  ).output;
  let lpPos = [];
  for (let i = 0; i < workers.length; i++) {
    if (userInfos[i].output.amount === "0") continue;
    lpPos.push({
      token: lpTokens[i].output,
      balance: userInfos[i].output.amount,
    });
  }
  await unwrapUniswapLPs(
    balances,
    lpPos,
    chainBlocks.fantom,
    "fantom",
    (addr) => `fantom:${addr}`
  );
  return balances;
}

async function borrowed(timestamp, block, chainBlocks) {
  return await calcTvl(chainBlocks.fantom, "fantom", true);
}

module.exports = {
  fantom: {
    tvl,
    borrowed,
    pool2: pool2Exports(
      meowMining,
      [meowFtm],
      "fantom",
      (addr) => `fantom:${addr}`
    ),
    staking: stakingUnknownPricedLP(
      meowMining,
      meow,
      "fantom",
      meowFtm,
      (addr) => `fantom:${addr}`
    ),
    treasury: stakingUnknownPricedLP(
      treasuryContract,
      meow,
      "fantom",
      meowFtm,
      (addr) => `fantom:${addr}`
    ),
  },
};

'''
'''--- projects/meowswap.fi/index.js ---
const { default: axios } = require('axios');
async function fetch(){

    const allInfo =  (await axios.get('https://api.meowswap.fi/?method=Exchange.GetAllInfo', {data: {"id":1,"method":"Exchange.GetAllInfo","jsonrpc":"2.0","params":{}}})).data.result

    let allToken = allInfo.pools
    let adaUsd = allInfo.ADA_USD;

    const Pairs = (await axios.post('https://api.meowswap.fi/?method=Info.Pairs', {"jsonrpc": "2.0","method": "Info.Pairs","id": 3,"params": {}})).data.result.data

    let totalLiquid = 0;
    await Pairs.forEach((row) => {
        let rowSt = { ...row };
        if (rowSt.token1 === 'ADA') {
            const FindPair = allToken.find((obj) => {
                return obj.firstAsset.assetId === rowSt.token2;
            });
            rowSt.token1_lock_summ_in_usd = adaUsd * rowSt?.pair_sum_q1;
            rowSt.token2_lock_summ_in_usd = adaUsd * rowSt?.pair_sum_q2 * FindPair?.exchange ?? 0;

        } else {
            const FindPair = allToken.find((obj) => {
                return obj.firstAsset.assetId === rowSt.token1;
            });
            rowSt.token2_lock_summ_in_usd = adaUsd * rowSt?.pair_sum_q2;
            rowSt.token1_lock_summ_in_usd = adaUsd * rowSt?.pair_sum_q1 * FindPair?.exchange ?? 0;
        }
        rowSt.tvl_valid = rowSt.token1_lock_summ_in_usd + rowSt.token2_lock_summ_in_usd;
        totalLiquid += rowSt.tvl_valid;
    });
    return totalLiquid;
}

module.exports = {
    methodology: "Data is retrieved from the api at https://api.meowswap.fi/",
    timetravel: false,
    fetch
}

'''
'''--- projects/meowswap/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const meow = "0xE8658B07c555E9604329A6a0A82FF6D9c6F68D2F";
const masterchef = "0x4bdd4BdEf3a2e3b707012A31cd993149fE6dE7DF";

module.exports = {
    ...masterChefExports(masterchef, "bsc", meow)
}
'''
'''--- projects/mercurial.js ---
const { getTokenBalance } = require("./helper/solana");

async function tvl() {
  const [
    paiPoolUsdcAmount,
    paiPoolUsdtAmount,
    paiPoolPaiAmount,
    ustPoolUsdcAmount,
    ustPoolUsdtAmount,
    ustPoolUstAmount,
    psolPoolSolAmount,
    psolPoolPsolAmount,
    Usd4PoolUsdcAmount,
    Usd4PoolWUsdcAmount,
    Usd4PoolWUsdtAmount,
    Usd4PoolWDaiAmount,
    stsolPoolStsolAmount,
    stsolPoolSolAmount,
    msolPoolMsolAmount,
    msolPoolSolAmount,
  ] = await Promise.all([
    //pai3pool
    getTokenBalance(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "2dc3UgMuVkASzW4sABDjDB5PjFbPTncyECUnZL73bmQR"
    ),
    getTokenBalance(
      "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "2dc3UgMuVkASzW4sABDjDB5PjFbPTncyECUnZL73bmQR"
    ),
    getTokenBalance(
      "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
      "2dc3UgMuVkASzW4sABDjDB5PjFbPTncyECUnZL73bmQR"
    ),
    //ust3Pool
    getTokenBalance(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "FDonWCo5RJhx8rzSwtToUXiLEL7dAqLmUhnyH76F888D"
    ),
    getTokenBalance(
      "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
      "FDonWCo5RJhx8rzSwtToUXiLEL7dAqLmUhnyH76F888D"
    ),
    getTokenBalance(
      "CXLBjMMcwkc17GfJtBos6rQCo1ypeH6eDbB82Kby4MRm",
      "FDonWCo5RJhx8rzSwtToUXiLEL7dAqLmUhnyH76F888D"
    ),
    //psol2Pool
    getTokenBalance(
      "So11111111111111111111111111111111111111112",
      "8RXqdSRFGLX8iifT2Cu5gD3fG7G4XcEBWCk9X5JejpG3"
    ),
    getTokenBalance(
      "9EaLkQrbjmbbuZG9Wdpo8qfNUEjHATJFSycEmw6f1rGX",
      "8RXqdSRFGLX8iifT2Cu5gD3fG7G4XcEBWCk9X5JejpG3"
    ),
    //wusd4pool
    getTokenBalance(
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "3m15qNJDM5zydsYNJzkFYXE7iGCVnkKz1mrmbawrDUAH"
    ),
    getTokenBalance(
      "A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM",
      "3m15qNJDM5zydsYNJzkFYXE7iGCVnkKz1mrmbawrDUAH"
    ),
    getTokenBalance(
      "Dn4noZ5jgGfkntzcQSUZ8czkreiZ1ForXYoV2H8Dm7S1",
      "3m15qNJDM5zydsYNJzkFYXE7iGCVnkKz1mrmbawrDUAH"
    ),
    getTokenBalance(
      "EjmyN6qEC1Tf1JxiG1ae7UTJhUxSwk1TCWNWqxWV4J6o",
      "3m15qNJDM5zydsYNJzkFYXE7iGCVnkKz1mrmbawrDUAH"
    ),
    //stsol2pool
    getTokenBalance(
      "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj",
      "pG6noYMPVR9ykNgD4XSNa6paKKGGwciU2LckEQPDoSW"
    ),
    getTokenBalance(
      "So11111111111111111111111111111111111111112",
      "pG6noYMPVR9ykNgD4XSNa6paKKGGwciU2LckEQPDoSW"
    ),
    //msol2pool
    getTokenBalance(
      "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
      "GM48qFn8rnqhyNMrBHyPJgUVwXQ1JvMbcu3b9zkThW9L"
    ),
    getTokenBalance(
      "So11111111111111111111111111111111111111112",
      "EWy2hPdVT4uGrYokx65nAyn2GFBv7bUYA2pFPY96pw7Y"
    ),
  ]);
  return {
    "usd-coin":
      paiPoolUsdcAmount +
      ustPoolUsdcAmount +
      Usd4PoolUsdcAmount +
      Usd4PoolWUsdcAmount,
    usdp: paiPoolPaiAmount,
    tether: paiPoolUsdtAmount + ustPoolUsdtAmount + Usd4PoolWUsdtAmount,
    dai: Usd4PoolWDaiAmount,
    terrausd: ustPoolUstAmount,
    "lido-staked-sol": stsolPoolStsolAmount,
    msol: msolPoolMsolAmount,
    solana:
      psolPoolSolAmount +
      psolPoolPsolAmount +
      stsolPoolSolAmount +
      msolPoolSolAmount,
  };
}

module.exports = {
  timetravel: false,
  tvl,
  methodology:
    "To obtain the Mercurial TVL we make on-chain calls using the function getTokenBalance() that uses the address of the token and the address of the contract where the token is located. The addresses used are the 3pool addresses and the SOL 2pool address where the corresponding tokens were deposited and these addresses are hard-coded. This returns the number of tokens held in each contract. We then use Coingecko to get the price of each token in USD to export the sum of all tokens.",
};

'''
'''--- projects/mercurity/abi.json ---
{
    "getCurrentTokens": {
        "constant": true,
        "inputs": [],
        "name": "getCurrentTokens",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "tokens",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/mercurity/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const pool_factoryV1 = "0x20dC7DA7cFc8F5b465060496a170229dc4A47A87";
const pool_factoryV2 = "0xCD21ef2220596cba4A7DaE59b5eeeA6dB7859df7";

const toAddr = (d) => "0x" + d.substr(26);

const calc = async (balances, block, factory) => {

    const START_BLOCK = 11259517; // 11971199 -> start block for Factory Pool V2
    const END_BLOCK = block;
    const events = (
        await sdk.api.util.getLogs({
            target: factory,
            topic: `LOG_NEW_POOL(address,address)`,
            keys: [],
            fromBlock: START_BLOCK,
            toBlock: END_BLOCK,
        })
    ).output;

    const pools = events.map((event) => toAddr(event.topics[2]));

    for (const pool of pools) {
        const tokens = (
            await sdk.api.abi.call({
                abi: abi.getCurrentTokens,
                target: pool,
            })
        ).output;

        for (const token of tokens) {
            const getBalance = (
                await sdk.api.abi.call({
                    abi: 'erc20:balanceOf',
                    target: token,
                    params: pool,
                })
            ).output;

            sdk.util.sumSingleBalance(balances, token, getBalance);
        }
    }
};

const ethTvl = async (ethBlock) => {
    const balances = {};

    /*** Pool V1 TVL Portion ***/
    await calc(balances, ethBlock, pool_factoryV1)

    /*** Pool V2 TVL Portion ***/
    await calc(balances, ethBlock, pool_factoryV2)

    return balances;
};

module.exports = {
    misrepresentedTokens: true,
    ethereum: {
        tvl: ethTvl,
    },
    methodology:
        "Counts tvl on the Pools through MFactory (V1 and V2) Contracts",
};

'''
'''--- projects/meritcircle/index.js ---
const { pool2Exports } = require("../helper/pool2");
const { staking } = require("../helper/staking");

const mc = "0x949d48eca67b17269629c7194f4b727d4ef9e5d6";
const mcPool = "0x5c76aD4764A4607cD57644faA937A8cA16729e39";
const mcLPPool = "0x44c01e5e4216f3162538914d9c7f5E6A0d87820e";
const mcWETHUNILP = "0xcCb63225a7B19dcF66717e4d40C9A72B39331d61";

module.exports = {
  ethereum: {
    tvl: async () => ({}),
    pool2: pool2Exports(mcLPPool, [mcWETHUNILP]),
    staking: staking(mcPool, mc),
  },
};

'''
'''--- projects/merlinlab/index.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformBscAddress } = require("../helper/portedTokens");

const stakingABI = require("./staking.json");
const vaultABI = require("./vault.json");

const stakingContract = "0x73feaa1eE314F8c655E354234017bE2193C9E24E";
const vaults = [
  "0x4E5f611A964806c5fb79Aa0dC8cf945cDFdaa7E2",
  "0xBf3aa34aC3F6ea54DD0eC15e5011e0B5A09c17f1",
  "0x925697B5E8F9b1277ca9d94769E10C4cBf1676f5",
  "0x82089743e90562D001FECCE2EeF465a609829459",
  "0x4675D999c1896ADD7D839F090703269b721eD411",
  "0x92f8a3780D479DCaaeb85D84B9dB2296B96B8603",
  "0x3a8db48D7f995D281D894e819C016E8c356757fE",
  "0xDe5bA75b008e93B04Ef1b516f93D1D466e6Dd392",
  "0x680A8a7E94d1EcA0cF651b174727ac5DF36E85c8",
  "0xA37d23D2192a4A61949e3E8339E6B5453FDB2Ae1",
  "0x360DE98FDC44357CED3D0CbD44387160A8f270D4",
  "0xB6B4417552145C197B060e1CD617e8f1B016c84a",
  "0x5bb11D23c94B13FbA6D22eAbb83bF3fd2458763E",
  "0x8AFdA0Df3D9601B32B731f829060BC0C1C95270D",
  "0x2090b0477E4852f929018c78ba9DD57e3B551d40",
  "0xF02ef3DcD71F1881f7d1F6Fc6D6f95c021d874b1",
  "0x414C51d5e837514Ac133cC9C8E14516ddBCc09c1",
  "0x7E744494f57511CA6733C83F262b3f674e95F28E",
  "0x158522242FD31385F2DdF6762c6d32b337274775",
  "0xdc09704Bf547B6639D5911504bC3111Aec8e97Fc",
  "0x4fcB41f71E31437419ce3Dee4e9c1092cA9cDE1F",
  "0x758C6c9731Ee68aD278f8C2F2f27b84aCB092649",
  "0x6c859c5f371DD107c423d4e065bFa09A8De421a9",
  "0x3f6919f676d5C7d2A65984dbdf5ae35254be1683",
];

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const pids = (
    await sdk.api.abi.multiCall({
      abi: vaultABI.pid,
      chain: "bsc",
      calls: vaults.map((vault) => ({
        target: vault,
      })),
      block: chainBlocks["bsc"],
    })
  ).output.map((pid) => pid.output);

  const stakingTokens = (
    await sdk.api.abi.multiCall({
      abi: vaultABI.stakingToken,
      chain: "bsc",
      calls: vaults.map((vault) => ({
        target: vault,
      })),
      block: chainBlocks["bsc"],
    })
  ).output.map((stakingToken) => stakingToken.output);

  const userInfos = (
    await sdk.api.abi.multiCall({
      abi: stakingABI.userInfo,
      chain: "bsc",
      calls: pids.map((pid, idx) => ({
        target: stakingContract,
        params: [pid, vaults[idx]],
      })),
      block: chainBlocks["bsc"],
    })
  ).output.map((stakingToken) => stakingToken.output.amount);

  const lpPositions = userInfos.map((amount, idx) => ({
    token: stakingTokens[idx],
    balance: amount,
  }));

  const transformAdress = await transformBscAddress();

  await unwrapUniswapLPs(
    balances,
    lpPositions,
    chainBlocks["bsc"],
    "bsc",
    transformAdress
  );

  // --- One side staking asset "CAKE" ---
  const infoCAKEVault = (
    await sdk.api.abi.call({
      abi: stakingABI.userInfo,
      chain: "bsc",
      target: stakingContract,
      params: [0, "0xa69AC402a8Afe80C4Db293baF231242242A131Af"],
      block: chainBlocks["bsc"],
    })
  ).output.amount;

  sdk.util.sumSingleBalance(
    balances,
    "bsc:0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82",
    infoCAKEVault
  );

  return balances;
};

module.exports = {
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/merlinlab/staking.json ---
{
  "userInfo": {
    "inputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" },
      { "internalType": "address", "name": "", "type": "address" }
    ],
    "name": "userInfo",
    "outputs": [
      { "internalType": "uint256", "name": "amount", "type": "uint256" },
      { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/merlinlab/vault.json ---
{
  "stakingToken": {
    "inputs": [],
    "name": "stakingToken",
    "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
    "stateMutability": "view",
    "type": "function"
  },
  "pid": {
    "inputs": [],
    "name": "pid",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/meshswap/index.js ---
const retry = require('async-retry')
const axios = require("axios");
const BigNumber = require("bignumber.js");
const { toUSDTBalances } = require('../helper/balances');

async function tvl() {
  const meshswapInfo = await retry(async bail => await axios.get('https://s.meshswap.fi/stat/meshswapInfo.json'))
  const recentPoolInfo = meshswapInfo.data.recentPoolInfo;
  const tokenInfoObj = meshswapInfo.data.tokenInfo;
  const SinglePoolInfo = meshswapInfo.data.leveragePoolInfo.single;

  var totalLiquidity = new BigNumber('0');

  for(const pool of recentPoolInfo){
    totalLiquidity = totalLiquidity.plus(pool.poolVolume);
  }
  var tokenInfo = {};
  for(const token of tokenInfoObj){
    tokenInfo[token.address] = token
  }

  for(const spool of SinglePoolInfo){
    const totalDeposit = new BigNumber(spool.totalDeposit);
    const totalBorrow = new BigNumber(spool.totalBorrow);
    const singlePoolAmount =  totalDeposit.minus(totalBorrow);
    
    const tokenPrice = tokenInfo[spool.token].price;
    const tokenDecimal = tokenInfo[spool.token].decimal;
    const singlePoolVol = singlePoolAmount.div(10**tokenDecimal).times(tokenPrice);

    totalLiquidity = totalLiquidity.plus(singlePoolVol);
  }
  return toUSDTBalances(totalLiquidity);
}

async function staking() {
  const meshswapInfo = await retry(async bail => await axios.get('https://s.meshswap.fi/stat/meshswapInfo.json'))
  var totalStaking = new BigNumber(meshswapInfo.data.common.stakingVol);
  return toUSDTBalances(totalStaking);
}

module.exports = {
  methodology: "meshswap is an AMM-based Instant Swap Protocol",
  timetravel: false,
  misrepresentedTokens: true,
  polygon: {
    staking,
    tvl
  }
}
'''
'''--- projects/mesofinance/index.js ---
const { masterChefExports } = require("../helper/masterchef");

const chef = "0x30b65159dB82eFCf8CEde9861bc6B85336310EB2"
const meso = "0x4D9361A86D038C8adA3db2457608e2275B3E08d4"

module.exports = masterChefExports(chef, "fantom", meso)

'''
'''--- projects/metacrono-finance/index.js ---
const {masterChefExports} = require("../helper/masterchef");

const token = "0x92926DAcCE437955aa47F0DFC7F5C8FCd728b36E";
const masterchef = "0x5F680E57778651f7Cb14678655822ABc469acacf";

module.exports = {
    ...masterChefExports(masterchef, "cronos", token, false),
}
'''
'''--- projects/metapool.js ---
const utils = require('./helper/utils');

async function tvl() {
    const totalTvl = await utils.fetchURL('http://validators.narwallets.com:7000/metrics_json')

  return {
    near: totalTvl.data.tvl
  }
}

module.exports = {
    methodology: 'TVL counts the NEAR tokens that are staked.',
    tvl,
  }
'''
'''--- projects/metareserve/index.js ---
const { ohmTvl } = require("../helper/ohm");

const power = "0x000c6322Df760155bBe4F20F2EDD8F4Cd35733A6";
const staking = "0x5c643737AF2aD7A0B9ae62158b715793505967bE";
const treasury = "0x6651BDeE6A47F6962C86d680b498DC492a7E78C8";
const treasuryTokens = [
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false], // BUSD
    ["0xA1A64b7D85B92A19fdb628557cC44bCb40284B65", true] // POWER-BUSD
];

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "bsc", staking, power, undefined, undefined, false)
}
'''
'''--- projects/metavault-trade/abi.js ---
module.exports = {
  allWhitelistedTokens: {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "allWhitelistedTokens",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  allWhitelistedTokensLength: {
    "inputs": [],
    "name": "allWhitelistedTokensLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}
'''
'''--- projects/metavault-trade/index.js ---
const sdk = require("@defillama/sdk")
const abi = require('./abi')
const { staking } = require("../helper/staking");
const { sumTokens } = require('../helper/unwrapLPs')

// Polygon
const polygonVault = "0x32848E2d3aeCFA7364595609FB050A301050A6B4";
const polygonStaking = "0xE8e2E78D8cA52f238CAf69f020fA961f8A7632e9"; // Staked MVX, sMVX
const polygonMVX = "0x2760e46d9bb43dafcbecaad1f64b93207f9f0ed7";
const chain= 'polygon'

const polygonTVL = async (timestamp, _block, { [chain]: block}) => {
  const calls = []
  const { output: size } = await sdk.api.abi.call({
    target: polygonVault,
    abi: abi.allWhitelistedTokensLength,
    chain, block,
  })
  for (let i = 0;i < +size; i++)
    calls.push({params: i})
  const { output: tokens } = await sdk.api.abi.multiCall({
    target: polygonVault,
    abi: abi.allWhitelistedTokens,
    calls,
    chain, block,
  })
  const toa = tokens.map(i => [i.output, polygonVault])
  return sumTokens({}, toa, block, chain)
};

module.exports = {
  polygon: {
    staking: staking(polygonStaking, polygonMVX, "polygon"),
    tvl: polygonTVL,
  },
};
'''
'''--- projects/metavault/index.js ---
const {ohmTvl} = require("../helper/ohm");

const treasury = "0x7bE9BbB7373B675aBd25fA6d58085C8dACF6cc4a";

const treasuryTokens = [
    ["0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E", false], // DAI
    ["0x738F57002c3Ff4C3b418c2d37024996608f8E281", true], // MVD-DAI LP
];

const stakingAddress = "0x6eA8de8f643ba65D8be39bd8D3B72f6DaAda7E77";
const stakingToken = "0x27746007e821aeec6F9C65CBFda04870c236346c";

module.exports = {
    ...ohmTvl(treasury, treasuryTokens, "fantom", stakingAddress, stakingToken)
}

'''
'''--- projects/metaversepro/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0xb874ac3a21e3ffe06fb4b6dcf9b62c7ea753a9a0"
module.exports = ohmTvl(treasury, [
    //WBNB 
    ["0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", false],
    //BUSD
    ["0xe9e7cea3dedca5984780bafc599bd69add087d56", false],
    //Pancake LP
    ["0x512385e505615eb30ec80A2915575E344ACf792A", true],
    //Pancake LPs 1
    ["0x1dd778e874dc1b45a676e38aba1916517c3648c8", true],
    //Pancake LPs 2
    ["0x5438c0730e45ef25ec5e5110c939dc0c90aec4b4", true],
    //Pancake LPs 3
    ["0x1c8ed2f2cef333aa43f1ba9a4589899c53787d2f", true],
    // USDC 
    ["0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", false]
],  "bsc", "0xb91db0c2551aae4784119ce4c33234c9e3c9af71", "0x0a2046C7fAa5a5F2b38C0599dEB4310AB781CC83", undefined, undefined, false)
'''
'''--- projects/metf-finance/TreasuryContract.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "token",
      "type": "address"
    }
  ],
  "name": "balanceOf",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/metf-finance/getPairPrice.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "pair",
      "type": "address"
    },
    {
      "internalType": "uint256",
      "name": "amount",
      "type": "uint256"
    }
  ],
  "name": "getPairPrice",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "valueInMMF",
      "type": "uint256"
    },
    {
      "internalType": "uint256",
      "name": "valueInUSD",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/metf-finance/index.js ---
const abi = require("./TreasuryContract.json");
const pairPrice = require("./getPairPrice.json");
const valueOfAsset = require("./valueOfAsset.json");
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");
const { pool2 } = require('../helper/pool2')

const treasury = "0xE25737b093626233877EC0777755c5c4081580be"
const MMF_METF_BOND = "0x127966303484140EF3692C49CfF154eaAe50cEe3"
const calculator = "0xa2B417088D63400d211A4D5EB3C4C5363f834764"

const ZERO = new BigNumber(0);
const ETHER = new BigNumber(10).pow(18);

const tokens = ["0x97749c9B61F878a880DfE312d2594AE07AEd7656",
    "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23",
    "0x50c0C5bda591bc7e89A342A3eD672FB59b3C46a7"]

const LPs = ["0xbA452A1c0875D33a440259B1ea4DcA8f5d86D9Ae",
    "0xB6E1705BfAFcf1efEE83C135C0F0210653bAB8F0",
    // "0xd7385f46FFb877d8c8Fe78E5f5a7c6b2F18C05A7", //moved to pool2
]

    
async function newTVL(timestamp, block, chainBlocks) {
    const balances = {}
    const prices = {}

    let data = await sdk.api.abi.multiCall({
        calls: LPs.map((address) => ({
            target: MMF_METF_BOND,
            params: [address, ETHER.toString()],
        })),
        block,
        abi: pairPrice,
        chain: "cronos",
    });

    data.output.forEach((call) => {
        let value = call && call.output && new BigNumber(call.output.valueInUSD);
        if (value) {
            prices[call.input.params[0]] = value.dividedBy(ETHER);
        }
    });

    let data3 = await sdk.api.abi.multiCall({
        calls: tokens.map((address) => ({
            target: calculator,
            params: [address, ETHER.toString()],
        })),
        block,
        abi: valueOfAsset,
        chain: "cronos",
    });
    data3.output.forEach((call) => {
        let value = call && call.output && new BigNumber(call.output.valueInUSD);
        if (value) {
            prices[call.input.params[0]] = value.dividedBy(ETHER);
        }
    });

    let data2 = await sdk.api.abi.multiCall({
        calls: [...tokens, ...LPs].map((address) => ({
            target: treasury,
            params: address,
        })),
        block,
        abi: abi,
        chain: "cronos",
    })

    data2.output.forEach((call) => {
        let value = call && call.output && new BigNumber(call.output);
        if (value) {
            if (prices[call.input.params[0]]) {
                balances[`cronos:${call.input.params[0]}`] = value.dividedBy(ETHER).multipliedBy(prices[call.input.params[0]])
            } else {
                balances[`cronos:${call.input.params[0]}`] = value.dividedBy(ETHER)
            }
        }
    });

    let tvlall = Object.values(balances).reduce((tvl, bn) => {
        return tvl.plus(bn)
    }, ZERO)

    return {
        tether: tvlall.toNumber(),
    };
}

async function staking(timestamp, block, chainBlocks) {
    const staked = (await sdk.api.abi.call({
        target: "0xb8df27c687c6af9afe845a2afad2d01e199f4878",
        params: "0x1A6aD4bac521a98556A4C0Da5946654c5DC7Ce0A", // masterchef
        abi: 'erc20:balanceOf',
        block: block,
        chain: 'cronos'
    })).output
    const balances = {
        ["cronos:0xb8df27c687c6af9afe845a2afad2d01e199f4878"]: staked
    }
    // console.log(balances)
    return balances
}

module.exports = {
    cronos: {
        tvl: newTVL,
        staking: staking,
        pool2: pool2("0xE25737b093626233877EC0777755c5c4081580be", "0xd7385f46FFb877d8c8Fe78E5f5a7c6b2F18C05A7", "cronos")
    }
}
'''
'''--- projects/metf-finance/valueOfAsset.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "asset",
      "type": "address"
    },
    {
      "internalType": "uint256",
      "name": "amount",
      "type": "uint256"
    }
  ],
  "name": "valueOfAsset",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "valueInCRO",
      "type": "uint256"
    },
    {
      "internalType": "uint256",
      "name": "valueInUSD",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/metronome/index.js ---
/*==================================================
  Modules
  ==================================================*/

  const sdk = require('@defillama/sdk');
  const BigNumber = require("bignumber.js");

/*==================================================
  TVL
  ==================================================*/

  async function tvl(timestamp, block) {
    const acc = '0x686e5ac50D9236A9b7406791256e47feDDB26AbA';
    const met = '0xa3d58c4E56fedCae3a7c43A725aeE9A71F0ece4e';
    const proceeds = '0x68c4b7d05fae45bcb6192bb93e246c77e98360e1';

    const [accBalance, proceedsBalance] = await Promise.all([
      sdk.api.eth.getBalance({ target: acc, block }),
      sdk.api.eth.getBalance({ target: proceeds, block })
    ]);

    const ethBalance = ((BigNumber(accBalance.output || 0))
      .plus(BigNumber(proceedsBalance.output || 0)))
      .toFixed();

    let metBalance = (await sdk.api.abi.call({
      block,
      target: met,
      params: acc,
      abi: 'erc20:balanceOf'
    })).output;

    let balances = {
      [met]: metBalance,
      "0x0000000000000000000000000000000000000000": ethBalance,
    };

    return balances;
  }

/*==================================================
  Exports
  ==================================================*/

  module.exports = {
    start: 1527076766,        // block 5659904
    ethereum: { tvl }
  };

'''
'''--- projects/mfinance/abi.json ---
{
    "poolInfo": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "poolInfo",
        "outputs": [
            {
                "internalType": "contract IERC20",
                "name": "lpToken",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "allocPoint",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "lastRewardBlock",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "accMGPerShare",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/mfinance/index.js ---
const abi = require("./abi.json");
const { staking } = require("../helper/staking");
const { pool2BalanceFromMasterChefExports } = require("../helper/pool2");
const { masterChefExports } = require("../helper/masterchef");

const masterChef = "0x342A8A451c900158BA4f1367C55955b5Fbcb7CCe";
const MG = "0x06b0c26235699b15e940e8807651568b995a8e01";

const ethTvl = async (chainBlocks) => {
  const balances = {};

  await addFundsInMasterChef(
    balances,
    masterChef,
    chainBlocks["ethereum"],
    "ethereum",
    (addr) => addr,
    abi.poolInfo,
    [],
    true,
    true,
    MG
  );

  return balances;
};

module.exports = masterChefExports(masterChef, "ethereum", MG, false, abi.poolInfo)

'''
'''--- projects/midasdao.js ---
const { sumTokensAndLPsSharedOwners } = require("./helper/unwrapLPs");
const sdk = require('@defillama/sdk');

const TimeStaking = "0x9619BC1306B94130FBC70CF07e311E69949f07D4";
const CROWN = "0x39912d83acb4a373321387300f4fbe88aa5d6f14";

const JoePair = "0x089a9BF16453b519Fab02e40d143C0dcF9083778";
const TREASURY = "0x6D9Cfb705C7b7A5ca1C4565A47Fa1b26FC1bE3d0";
const MIM = "0x130966628846BFd36ff31a822705796e8cb8C18D";
const WAVAX = "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7"

const staking = async (timestamp, ethBlock, chainBlocks) => {
    const balances = {};

    const stakingBalance = await sdk.api.abi.call({
        abi: 'erc20:balanceOf',
        target: CROWN,
        params: TimeStaking,
        block: chainBlocks.avax,
        chain: 'avax'
    });

    sdk.util.sumSingleBalance(balances, 'avax:'+CROWN, stakingBalance.output);

    return balances;
};

async function tvl(timestamp, block, chainBlocks) {
    const balances = {};

    await sumTokensAndLPsSharedOwners(
        balances,
        [
            [MIM, false],
            [WAVAX, false],
            [JoePair, true],
        ],
        [TREASURY],
        chainBlocks.avax,
        'avax',
        addr=>`avax:${addr}`
    );

    return balances;
};

module.exports = {
    avalanche: {
        tvl,
        staking
    },
    methodology: "Counts tokens on the treasury for tvl and staked CROWN for staking",
};

'''
'''--- projects/milko-farm.js ---
const { masterChefExports } = require("./helper/masterchef");

const milko = "0x3c786134228b363fb2984619D7560AB56363B2bD";
const masterchef = "0x5d0C5db1D750721Ed3b13a8436c17e035B44c3D0";

module.exports = {
  ...masterChefExports(masterchef, "milkomeda", milko, false)
};
'''
'''--- projects/milkycow.js ---
const { masterChefExports } = require("./helper/masterchef");

const milko = "0xbd01b2CF2c514c7eC90827b8346354bb4f7832ab";
const masterchef = "0xA11213A5549629295bBfbc578CE5032266A5E827";

module.exports = {
  ...masterChefExports(masterchef, "milkomeda", milko, false)
};
'''
'''--- projects/milkydex/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x194Db21D9108f9da7a4E21f367d0eb8f8979144e) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  milkomeda: {
    tvl: calculateUsdUniTvl(
      "0x194Db21D9108f9da7a4E21f367d0eb8f8979144e",
      "milkomeda",
      "0xAE83571000aF4499798d1e3b0fA0070EB3A3E3F9",
      [
        "0x2403FDb3b42825df2013608f9defD3E120d87993",
        "0xB44a9B6905aF7c801311e8F4E76932ee959c663C",
        "0x80A16016cC4A2E6a2CACA8a4a498b1699fF0f844",
        "0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8",
        "0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D"
      ],
      "cardano"
    ),
  },
};

'''
'''--- projects/milkyswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0xD6Ab33Ad975b39A8cc981bBc4Aaf61F957A5aD29) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  milkomeda: {
    tvl: calculateUsdUniTvl(
      "0xD6Ab33Ad975b39A8cc981bBc4Aaf61F957A5aD29",
      "milkomeda",
      "0xAE83571000aF4499798d1e3b0fA0070EB3A3E3F9",
      [
        "0x063A5E4cD5e15ac66ea47134Eb60e6b30A51B2bf",
        "0xB44a9B6905aF7c801311e8F4E76932ee959c663C",
        "0x80A16016cC4A2E6a2CACA8a4a498b1699fF0f844",
        "0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8",
        "0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D"
      ],
      "cardano"
    ),
  },
}; // node test.js projects/milkyswap/index.js

'''
'''--- projects/milkyway/index.js ---
const { compoundExports } = require("../helper/compound");

module.exports = {
  timetravel: false, // milkomeda api's for staked coins can't be queried at historical points
  start: 1599552000, // 09/08/2020 @ 8:00am (UTC)
  milkomeda: compoundExports("0x0Dd4E2B7E0E8a2Cd1258a9023D3a5062381554Cf", "milkomeda"),
};

'''
'''--- projects/mimas-finance/index.js ---
const {compoundExports} = require('../helper/compound')

const { stakingUnknownPricedLP } = require("../helper/staking");
const token = "0x10C9284E6094b71D3CE4E38B8bFfc668199da677";
const stakingContract = "0x268E2E1e5a465034Ee5742DA578feb41B228ad7B";

const wCRO = "0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23";
const mmCRO = "0xff024211741059a2540b01f5Be2e75fC0c1b3d82";

module.exports = {
    cronos: {
        ...compoundExports(
            "0xdD8c94211dD19155EFFbd57EAb6D4e0DE31A3b9E",
            "cronos",
            mmCRO,
            wCRO,
            addr => `cronos:${addr}`,
        ),
        staking: stakingUnknownPricedLP(stakingContract, token, "cronos", "0xf56FDfeeF0Ba3de23DaB13a85602bd7BF135E80f", addr=>`cronos:${addr}`)
    }
}

'''
'''--- projects/mimo/index.js ---
const sdk = require("@defillama/sdk");
const { sumTokensAndLPsSharedOwners } = require('../helper/unwrapLPs');
const { transformPolygonAddress, transformFantomAddress } = require("../helper/portedTokens");

async function ethtvl(timestamp, block) {
    let balances = {};

    const Contracts = {
      ethereum : {
        vaultCore: ['0x4026BdCD023331D52533e3374983ded99CcBB6d4'],
        collaterals: [
          ['0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', false], //wETH
          ['0x2260fac5e5542a773aa44fbcfedf7c193bc2c599', false], //wBTC
          ['0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', false], //USDC
        ],
      },
    };

    await sumTokensAndLPsSharedOwners(balances, Contracts.ethereum.collaterals, Contracts.ethereum.vaultCore, block, "ethereum");

return balances

}

async function polytvl(timestamp, block) {
  let balances = {};

  const Contracts = {
    
    polygon: {
      vaultCore: ['0x03175c19cb1d30fa6060331a9ec181e04cac6ab0'],
      collaterals: [
        ['0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', false], //wMATIC
        ['0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', false], //wETH
        ['0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', false], //wBTC
        ['0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', false], //USDC
      ],
    },
  };
    
  await sumTokensAndLPsSharedOwners(balances, Contracts.polygon.collaterals, Contracts.polygon.vaultCore, block, "polygon", await transformPolygonAddress());

return balances

}

async function ftmtvl(timestamp, block) {
  let balances = {};

  const Contracts = {
    
    fantom: {
      vaultCore: ['0xB2b4feB22731Ae013344eF63B61f4A0e09fa370e'],
      collaterals:[
        ['0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83', false], //wFTM
        ['0x74b23882a30290451A17c44f4F05243b6b58C76d', false], //ETH
        ['0x321162Cd933E2Be498Cd2267a90534A804051b11', false], //BTC
        ['0x04068DA6C83AFCFA0e13ba15A6696662335D5B75', false], //USDC
      ],
    }
  };

  
  await sumTokensAndLPsSharedOwners(balances, Contracts.fantom.collaterals, Contracts.fantom.vaultCore, block, "fantom", await transformFantomAddress());

return balances

}

module.exports = {
  ethereum:{
    tvl: ethtvl,
  },
  polygon:{
    tvl: polytvl,
  },
  fantom:{
    tvl: ftmtvl
  }
}

'''
'''--- projects/mimoswap/index.js ---
const { calculateUsdUniTvl } = require('../helper/getUsdUniTvl');
module.exports = {
    misrepresentedTokens: true,
    iotex: {
      tvl: calculateUsdUniTvl(
          "0xda257cBe968202Dea212bBB65aB49f174Da58b9D", 
          "iotex", 
          "0xa00744882684c3e4747faefd68d283ea44099d03", 
          [
              "0x99b2b0efb56e62e36960c20cd5ca8ec6abd5557a",
              "0x6fbcdc1169b5130c59e72e51ed68a84841c98cd1",
              "0x17df9fbfc1cdab0f90eddc318c4f6fcada730cf2"
          ], 
          "iotex"
          )
    },
};
'''
'''--- projects/mindgames/index.js ---
const { getUniTVL, staking } = require('../helper/unknownTokens')

const xCELL = "0xbe334d7208366B3E4Fb40348576227b524d8CBA0";
const CELL = "0xa685F488DEe49b75469E9e866965daBc8Ed6083d";
const factory = "0x78f406B41C81eb4144C321ADa5902BBF5de28538";
const coreAssets = [
  "0xC42C30aC6Cc15faC9bD938618BcaA1a1FaE8501d",
]

const tvl = getUniTVL({ factory, chain: 'aurora', coreAssets })

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x78f406B41C81eb4144C321ADa5902BBF5de28538) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  aurora: {
    tvl,
    staking: staking({
      owner: xCELL,
      tokens: [CELL],
      chain: 'aurora',
      coreAssets,
      lps: ['0xcA5eD5745890C66026400F9b805466fB3984A345']
    })
  },
};
'''
'''--- projects/minidex.js ---
const retry = require('./helper/retry')
const { GraphQLClient, gql } = require('graphql-request')

async function fetch(timestamp, block) {
    var endpoint = 'https://api.thegraph.com/subgraphs/name/noberk/chapter3';
    var graphQLClient = new GraphQLClient(endpoint);

    var query = gql`
    query uniswapFactories {
        uniswapFactories(
            block: {number: ${block}}, 
            where: {id: "0x1E2C2102cf8EfCaAAf20fFe926469EC7cD0d0f6E"}
        ) {
            totalLiquidityUSD
        }}`;
    const results = await retry(
        async bail => await graphQLClient.request(query));
    return parseFloat(results.uniswapFactories[0].totalLiquidityUSD);
};

module.exports = {
  fetch
};
'''
'''--- projects/minimax/index.js ---
const retry = require('async-retry')
const axios = require("axios");

async function bsc() {
    const tvl_data = await retry(async bail => axios.get("https://api.minimax.finance/tvl/56"));
    return parseFloat(tvl_data.data.TvlTotal);
}

async function polygon() {
    const tvl_data = await retry(async bail => axios.get("https://api.minimax.finance/tvl/137"));
    return parseFloat(tvl_data.data.TvlTotal);
}

async function fantom() {
    const tvl_data = await retry(async bail => axios.get("https://api.minimax.finance/tvl/250"));
    return parseFloat(tvl_data.data.TvlTotal);
}

async function avalanche() {
    const tvl_data = await retry(async bail => axios.get("https://api.minimax.finance/tvl/43114"));
    return parseFloat(tvl_data.data.TvlTotal);
}

async function fetch() {
    const tvl_data = await retry(async bail => axios.get("https://api.minimax.finance/tvl"));
    return parseFloat(tvl_data.data.TvlTotal);
}

module.exports = {
    methodology: 'We store all user positions in our database, which is built using the blockchain data (it helps us fetch read data fast for our website). TVL is just a sum of all open positions in $ equivalent.',
    bsc: {
        fetch: bsc
    },
    polygon: {
        fetch: polygon
    },
    fantom: {
        fetch: fantom
    },
    avalanche: {
        fetch: avalanche
    },
    fetch
}

'''
'''--- projects/miningtycoon/index.js ---
const sdk = require('@defillama/sdk');

const tokenFarm = '0xBdfbeecF52bCfF5aa8cc1B8A4B737B2Af3D1BA2F';
const tokenFarm2 = '0x8A6AE8076A1866877e006cC9b4bd0378646A9bD5';

const NTToken = '0x8b70512b5248e7c1f0f6996e2fde2e952708c4c9';
const USDTToken = '0xa71edc38d189767582c38a3145b5873052c3e47a';

const bsc_tokenFarm = '0xA05Cbf21620553Ade9a3368f1b20D81eEe74a1FC';
const bsc_tokenFarm2 = '0x973fEAf394F5E882B0F8a9B5CDC0b3E28AA08926';

const bsc_NTToken = '0xfbcf80ed90856AF0d6d9655F746331763EfDb22c';
const bsc_USDTToken = '0x55d398326f99059fF775485246999027B3197955';

async function tvl(timestamp, ethBlock, chainBlocks) {
	let balances = {};

	const USDTBalance = (await sdk.api.abi.call({
		chain: "heco",
		target: USDTToken,
		params: [tokenFarm2],
		abi: 'erc20:balanceOf',
	})).output;
	
	const bsc_USDTBalance = (await sdk.api.abi.call({
		chain: "bsc",
		target: bsc_USDTToken,
		params: [bsc_tokenFarm2],
		abi: 'erc20:balanceOf',
	})).output;

	balances = {};
	balances['heco:'+USDTToken] = USDTBalance;
	balances['bsc:'+bsc_USDTToken] = bsc_USDTBalance;
		
	return balances;
}

async function staking(timestamp, ethBlock, chainBlocks) {
	const NTBalance = (await sdk.api.abi.call({
		chain: "heco",
		target: NTToken,
		params: [tokenFarm2],
		block: chainBlocks.heco,
		abi: 'erc20:balanceOf',
	})).output;

	const bsc_NTBalance = (await sdk.api.abi.call({
		chain: "bsc",
		target: bsc_NTToken,
		params: [bsc_tokenFarm2],
		block: chainBlocks.bsc,
		abi: 'erc20:balanceOf',
	})).output;

	return {
		['heco:'+NTToken]: NTBalance,
		['bsc:'+bsc_NTToken]: bsc_NTBalance,
	}
}

module.exports = {
	methodology: 'TVL counts USDT staked to earn NT tokens and the staking portion of TVL counts the NT tokens that are staked to earn more NT tokens',
	bsc:{
		tvl,
		staking
	},	
}
'''
'''--- projects/minipanther/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0xBc461eA008c586a1721c6bF6a712f38e199A3Ce7" 
const miniPantherToken = "0x3264810174f577F82DDD4FD08818F368AC363505"
const stakingAddress = "0x7dc10Ade8599bf5033577F60C6740479aa39DB41"
const treasuryTokens = [
    ["0x9cbccdaf10153edd092817a013470a0693852a77", false], //PantherUSD
    ["0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83", false], //WFTM
    ["0x321162Cd933E2Be498Cd2267a90534A804051b11", false], //WBTC
    ["0x74b23882a30290451A17c44f4F05243b6b58C76d", false], //WETH
    ["0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E", false], //DAI
    ["0x82f0b8b456c1a451378467398982d4834b6829c1", false], //MIM
    ["0x761D6a950c8F441D616f34d6D918230936a3F27b", true], //MiniPanther-DAI
   ]

   module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, treasuryTokens, "fantom", stakingAddress, miniPantherToken, addr=>{
        return `fantom:${addr}`
    }, (balances)=>{delete balances["fantom:0x9cbccdaf10153edd092817a013470a0693852a77"]}, false)
}

'''
'''--- projects/miniversefinance/index.js ---
const { tombTvl } = require("../helper/tomb");

const mvdollar = "0x35bED1E2f3033395a05CD0b1b5900209ECe42774";
const mshare = "0xb011EC534d9175cD7a69aFBfc1bcc9990862c462";
const rewardPool = "0x1D39015cEa46a977cC5752C05fF2Cb3c1a4038E7";
const masonry = "0x92c102Eab956c8d330709681AE74dc68815fC0bc";

const lps = [
    "0x35bED1E2f3033395a05CD0b1b5900209ECe42774",
    "0x92A7b2A9ca7D70573E3a0B0BF9e5232c70db8a89",
    "0x85E8DcBc11eF5C5F98277B20A041C8ab90E0e2f7"
];
//node test.js projects/miniversefinance/index.js
module.exports = {
    ...tombTvl(mvdollar, mshare, rewardPool, masonry, lps, "fantom")
}
'''
'''--- projects/minmax-finance/abi.json ---
{
    "getReserves": {
        "inputs": [],
        "name": "getReserves",
        "outputs": [{
            "internalType": "uint112",
            "name": "_reserve0",
            "type": "uint112"
        }, {
            "internalType": "uint112",
            "name": "_reserve1",
            "type": "uint112"
        }, {
            "internalType": "uint32",
            "name": "_blockTimestampLast",
            "type": "uint32"
        }],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/minmax-finance/index.js ---
/*==================================================
  Modules
  ==================================================*/
const sdk = require('@defillama/sdk');
const BigNumber = require('bignumber.js')

const abi = require("./abi.json");
const IOTEX_CG_MAPPING = require("./iotex_cg_stablecoin_mapping.json")

/*==================================================
  Addresses
  ==================================================*/
const MINMAX_B3_POOL = '0x09A1B7d922BcfECa097b06498Bc992A83b0BCc42';
const MINMAX_E4_POOL = '0x89963FCD25Cd3b369A2e0642521BCA7Cf0B9d547';
const MINMAX_M3_POOL = '0xdab7B4D2CA330dde50ce611E2177271fD3Eb3F5F';
const MINMAX_USDT_POOL = '0x074ec23e80bd1fd26b822305614fb10b97847a35';
const MINMAX_XIM_B3_POOL = '0xe409587F043f74e47eFB0C10aAf40808D4e037cE';
const MINMAX_XIM_M3_POOL = '0x73541e9ffb9F4B8d13C2E5621b1Cede1981aD0d9';
const MINMAX_XIM_E3_POOL = '0x2c1B1DE747043f7C7c8e0896EB33b09eD9ED55c5';
const MINMAX_E3_POOL = '0xC264ED05ed2aF451732EF05C480d9e51b92a07aC';
const MINMAX_XIM_E3_METAPOOL = '0x8360D306Be83f9A992b1657Ad68fe08Ca6f2757A';
const MINMAX_XIM_B3_METAPOOL = '0x833d89FA7dD693035678AB53Be792F6F4B352C01';
const MINMAX_XIM_M3_METAPOOL = '0x7B24cAA6a497bc79FDfBAeb8A71a38F15eB3d7F7';

const tokens = {
  // BUSD
  '0xacee9b11cd4b3f57e58880277ac72c8c41abe4e4':[MINMAX_E4_POOL, MINMAX_XIM_E3_POOL], // decimal: 18
  // USDC
  '0x3B2bf2b523f54C4E454F08Aa286D03115aFF326c':[MINMAX_E4_POOL, MINMAX_XIM_E3_POOL, MINMAX_E3_POOL, MINMAX_XIM_E3_METAPOOL], // decimal: 6
  // USDT
  '0x6fbCdc1169B5130C59E72E51Ed68A84841C98cd1':[MINMAX_E4_POOL, MINMAX_USDT_POOL, MINMAX_XIM_E3_POOL, MINMAX_E3_POOL, MINMAX_XIM_E3_METAPOOL], // decimal: 6
  // DAI
  '0x1CbAd85Aa66Ff3C12dc84C5881886EEB29C1bb9b':[MINMAX_E4_POOL, MINMAX_E3_POOL, MINMAX_XIM_E3_METAPOOL], // decimal: 18
  // BUSD_b
  '0x84abcb2832be606341a50128aeb1db43aa017449':[MINMAX_B3_POOL, MINMAX_XIM_B3_POOL, MINMAX_XIM_B3_METAPOOL], // decimal: 18
  // USDC_b
  '0x037346E5a5722957Ac2cAb6ceb8c74fC18Cea91D':[MINMAX_B3_POOL, MINMAX_XIM_B3_POOL, MINMAX_XIM_B3_METAPOOL], // decimal: 18
  // USDT_b
  '0x42C9255D5e522e83B16ea11a3BA04c2D3AfCA079':[MINMAX_B3_POOL, MINMAX_USDT_POOL, MINMAX_XIM_B3_POOL, MINMAX_XIM_B3_METAPOOL], // decimal: 18
  // DAI_m
  '0x62a9d987cbf4c45a550deed5b57b200d7a319632':[MINMAX_M3_POOL, MINMAX_XIM_M3_POOL, MINMAX_XIM_M3_METAPOOL], // decimal: 18
  // USDT_m
  '0x3cdb7c48e70b854ed2fa392e21687501d84b3afc':[MINMAX_M3_POOL, MINMAX_USDT_POOL, MINMAX_XIM_M3_POOL, MINMAX_XIM_M3_METAPOOL], // decimal: 6
  // USDC_m
  '0xc04da3a99d17135857bb937d2fbb321d3b6c6a81':[MINMAX_M3_POOL, MINMAX_XIM_M3_POOL, MINMAX_XIM_M3_METAPOOL], // decimal: 6
  // XIM
  '0xec690cdd448e3cbb51ed135df72301c3265a8f80': [MINMAX_XIM_B3_POOL, MINMAX_XIM_M3_POOL, MINMAX_XIM_E3_POOL, MINMAX_XIM_E3_METAPOOL, MINMAX_XIM_B3_METAPOOL, MINMAX_XIM_M3_METAPOOL] // decimal: 6
};

const lpTokens = {
  //MAX-XIM
  '0xDE7399eC841627bc68243832572086B9d2D41404': ['0xce5E67333E3E52860b8F2E5f02a7B9EdaA67f932'],
  // minmaxB3
  '0xC35257624b01932e521bc5D9dc07e4F9ed21ED28': ['0x7bCA7698F35FC04f4217059BfD7bA73062560204'],
  // minmaxM3
  '0xdFf5DC9d8dAC189324452D54e2df19d2Bdba78CE': ['0x2700f28B7B97a0881410D2eA688ee455713e87D4'],
  // minmaxE3
  '0xa546b5769f3F97F93Fc90F63Fbe7423250216b98': ['0x64D19dA38ca28ACbaE62c4B9143f5d867B593504'],
  // minmaxXIMB3Meta
  '0x834D27A61c7fE4F52Ad5435e59e85D64aA1375a7': ['0x3267E70dB372E42b25e79a5E35f3aED202cDe642'],
  // minmaxXIMM3Meta
  '0x69d9EAbd5b3f967BbaE9fF9b73e4dA3Ba0c46D08': ['0xB040FF8F8F5F2399c67c2cCBa8A7cc6777435306'],
  // minmaxXIME3Meta
  '0x89a7663c4ca176ACD8E6a054da67B0d301FC218A': ['0xE9E6CdDB08042f35e0ADAf62Ad0559b0F17E7e1c'],
  // minmaxXIMB3
  '0xd33f8a41e2ec9ff64fdc008e00f69f0e142948ad': ['0xce5E67333E3E52860b8F2E5f02a7B9EdaA67f932'],
  // minmaxXIME3
  '0xb581afb9c7aa567edbe6274bddc975b7926edaaf': ['0xce5E67333E3E52860b8F2E5f02a7B9EdaA67f932'],
  // minmaxXIMM3
  '0xf79fd0a6d1d8ce877fc70acd321fdf1626168398': ['0xce5E67333E3E52860b8F2E5f02a7B9EdaA67f932']
};

/*==================================================
  Helper
  ==================================================*/

function compareAddresses(a, b){
    return a.toLowerCase() === b.toLowerCase()
}

function transformIotexAddress(addr) {
    const dstToken = Object.keys(IOTEX_CG_MAPPING).find(token => compareAddresses(addr, token))
    if (dstToken !== undefined) {
        return IOTEX_CG_MAPPING[dstToken].contract || IOTEX_CG_MAPPING[dstToken].coingeckoId
    }
    return `iotex:${addr}`, 0; 
}

/*==================================================
  TVL
  ==================================================*/

async function tvl(block) {
  let balances = {};
  let calls = [];

  for (const token in tokens) {
    for(const poolAddress of tokens[token])
    calls.push({
      target: token,
      params: poolAddress
    })
  }

  // Pool Balances
  let balanceOfResults = await sdk.api.abi.multiCall({
    block,
    calls: calls,
    abi: 'erc20:balanceOf',
    chain: 'iotex'
  });

  // Compute Balances
  balanceOfResults.output.forEach((balanceOf) => {
      let address = balanceOf.input.target
      let amount =  balanceOf.output

      // align decimal from 6 to 18: USDC, USDT, USDT_m, USDC_m
      if (address == '0x3B2bf2b523f54C4E454F08Aa286D03115aFF326c' 
        || address == '0x6fbCdc1169B5130C59E72E51Ed68A84841C98cd1' 
        || address == '0x3cdb7c48e70b854ed2fa392e21687501d84b3afc' 
        || address == '0xc04da3a99d17135857bb937d2fbb321d3b6c6a81') {
          amount = amount * 1e12
      }
      address  = transformIotexAddress(address);

      balances[address] = BigNumber(balances[address]|| 0).plus(amount).toFixed()

  });

  // fix balance: usdc-coin, tether
  for(const representation of ['0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0xdac17f958d2ee523a2206206994597c13d831ec7']){
    if(balances[representation] !== undefined){
        balances[representation] = Number(balances[representation]) / 1e12
    }
  }

  let lpCalls = [];

  for (const lpToken in lpTokens) {
    for(const poolAddress of lpTokens[lpToken])
    lpCalls.push({
      target: lpToken,
      params: poolAddress
    })
  }

  // Farm balance
  let lpBalanceOfResults = await sdk.api.abi.multiCall({
    block,
    calls: lpCalls,
    abi: 'erc20:balanceOf',
    chain: 'iotex'
  });

  // Compute Balances
  lpBalanceOfResults.output.forEach((balanceOf) => {
      let address = balanceOf.input.target
      let amount =  balanceOf.output

      address  = transformIotexAddress(address);
      balances[address] = BigNumber(balances[address]|| 0).plus(amount).toFixed()

  });

  return balances;
}

module.exports = {
  timetravel: true,
  methodology: "All the assets in the pool.",
  iotex:{
    tvl,
  },
};

'''
'''--- projects/minmax-finance/iotex_cg_stablecoin_mapping.json ---
{
    "0x3cdb7c48e70b854ed2fa392e21687501d84b3afc": {
        "contract": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "coingeckoId": "tether"
    },
    "0x6fbcdc1169b5130c59e72e51ed68a84841c98cd1": {
        "contract": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "coingeckoId": "tether"
    },
    "0x42C9255D5e522e83B16ea11a3BA04c2D3AfCA079": {
        "contract": "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "coingeckoId": "tether"
    },
    "0x3b2bf2b523f54c4e454f08aa286d03115aff326c":{
        "contract": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "coingeckoId": "usd-coin"         
    },
    "0x037346E5a5722957Ac2cAb6ceb8c74fC18Cea91D":{
        "contract": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "coingeckoId": "usd-coin"         
    },
    "0xc04da3a99d17135857bb937d2fbb321d3b6c6a81":{
        "contract": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        "coingeckoId": "usd-coin"         
    },
    "0x84abcb2832be606341a50128aeb1db43aa017449": {
        "contract": "0x4fabb145d64652a948d72533023f6e7a623c7c53",
        "coingeckoId": "binance-usd"           
    },
    "0xacee9b11cd4b3f57e58880277ac72c8c41abe4e4": {
        "contract": "0x4fabb145d64652a948d72533023f6e7a623c7c53",
        "coingeckoId": "binance-usd"           
    },
    "0x62a9d987cbf4c45a550deed5b57b200d7a319632": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"   
    },
    "0x1CbAd85Aa66Ff3C12dc84C5881886EEB29C1bb9b": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"   
    },
    "0xec690cdd448e3cbb51ed135df72301c3265a8f80": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0xC35257624b01932e521bc5D9dc07e4F9ed21ED28": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0xdFf5DC9d8dAC189324452D54e2df19d2Bdba78CE": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0xa546b5769f3F97F93Fc90F63Fbe7423250216b98": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0x834D27A61c7fE4F52Ad5435e59e85D64aA1375a7": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0x69d9EAbd5b3f967BbaE9fF9b73e4dA3Ba0c46D08": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0x89a7663c4ca176ACD8E6a054da67B0d301FC218A": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"  
    },
    "0xDE7399eC841627bc68243832572086B9d2D41404": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"
    },
    "0xd33f8a41e2ec9ff64fdc008e00f69f0e142948ad": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"
    },
    "0xb581afb9c7aa567edbe6274bddc975b7926edaaf": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"
    },
    "0xf79fd0a6d1d8ce877fc70acd321fdf1626168398": {
        "contract": "0x6b175474e89094c44da98b954eedeac495271d0f",
        "coingeckoId": "dai"
    }
}

'''
'''--- projects/minotaur-money/index.js ---
const { ohmTvl } = require("../helper/ohm");

const mino = "0x3A1138075bd97a33F23A87824b811146FA44288E";
const staking = "0x844e265F24868F7e18D4f90d50b500c6C36bdBA7";
const treasury = "0x8A8cc2F5346b3C95EE343c62F89f41E0c1b68C7b";
const tokens = [
    ["0xe6052a9a4c0a2f14adc9876a3a1a7b2882f5f139", false], // xUSD
    ["0xf2001b145b43032aaf5ee2884e456ccd805f677d", false], // DAI
    ["0xf5a5f547612e95c688971fb68334a80ceb3c542b", true], // MINO-DAI
    ["0x1c139f4b953ce0c0f6aa1cd1755727ad5aba5080", true], // MINO-WCRO
    ["0x062e66477faf219f25d27dced647bf57c3107d52", false], // WBTC
    ["0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23", false], // WCRO
    ["0xe44fd7fcb2b1581822d0c862b68222998a0c299a", false] // WETH
];

module.exports = {
    misrepresentedTokens: true,
    ...ohmTvl(treasury, tokens, "cronos", staking, mino, addr=>{
        if (addr.toLowerCase() === "0xe6052a9a4c0a2f14adc9876a3a1a7b2882f5f139") {
            return "0x0000000000085d4780b73119b644ae5ecd22b376"
        }
        return `cronos:${addr}`
    }, undefined, false)
}
'''
'''--- projects/minswap/index.js ---
const axios = require("axios");

async function tvl() {
  const liquidityPoolLocked = (
    await axios.get(
      "https://cardano-mainnet.blockfrost.io/api/v0/addresses/addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxz2j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq0xmsha",
      {
        headers: {
          project_id: "mainnetTV9qV3mfZXbE6e44TVGMe1UoRlLrpSQt",
        },
      }
    )
  ).data.amount.find((token) => token.unit === "lovelace").quantity;
  const batchOrderLocked = (
    await axios.get(
      "https://cardano-mainnet.blockfrost.io/api/v0/addresses/addr1wxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwc0h43gt",
      {
        headers: {
          project_id: "mainnetTV9qV3mfZXbE6e44TVGMe1UoRlLrpSQt",
        },
      }
    )
  ).data.amount.find((token) => token.unit === "lovelace").quantity;
  return {
    cardano: (liquidityPoolLocked * 2) / 1e6 + batchOrderLocked / 1e6,
  };
}

module.exports = {
  timetravel: false,
  cardano: {
    tvl,
  },
};

'''
'''--- projects/mint-club/index.js ---
const sdk = require('@defillama/sdk');
const { transformBscAddress } = require('../helper/portedTokens');
const MINT_TOKEN_CONTRACT = '0x1f3Af095CDa17d63cad238358837321e95FC5915';
const MINT_CLUB_BOND_CONTRACT = '0x8BBac0C7583Cc146244a18863E708bFFbbF19975';

async function tvl(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformBscAddress();

  const collateralBalance = (await sdk.api.abi.call({
    abi: 'erc20:balanceOf',
    chain: 'bsc',
    target: MINT_TOKEN_CONTRACT,
    params: [MINT_CLUB_BOND_CONTRACT],
    block: chainBlocks['bsc'],
  })).output;

  sdk.util.sumSingleBalance(balances, transform(MINT_TOKEN_CONTRACT), collateralBalance)

  return balances;
}

module.exports = {
  bsc: {
    tvl,
  }
}; // node test.js projects/mint-club/index.js
'''
'''--- projects/minto/index.js ---
const { stakings } = require('../helper/staking')

const minto = '0x410a56541bD912F9B60943fcB344f1E3D6F09567'
const hminto = '0x410a56541bd912f9b60943fcb344f1e3d6f09567'
const stackingContracts = [
  '0x78ae303182fca96a4629a78ee13235e6525ebcfb',
  '0xe742FCE58484FF7be7835D95E350c23CE55A7E12',
]

module.exports = {
  bsc: {
    staking: stakings(stackingContracts, minto, 'bsc')
  },
  heco: {
    tvl: () => ({}),
    staking: stakings(stackingContracts, hminto, 'heco')
  }
}

'''
'''--- projects/mintswap/index.js ---
const { addFundsInMasterChef } = require("../helper/masterchef");
const { transformAvaxAddress } = require("../helper/portedTokens");

const masterChefContract = "0xAdD22604caf79139450e9fb4851394fFCE1692Be";

const avaxTvl = async (chainBlocks) => {
  const balances = {};

  const transformAddress = await transformAvaxAddress();
  await addFundsInMasterChef(
    balances,
    masterChefContract,
    chainBlocks.avax,
    "avax",
    transformAddress,
  );

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  avax: {
    tvl: avaxTvl,
  },
  methodology:
    "We count liquidity on the Farms and Pools through MasterChef Contract",
};

'''
'''--- projects/mirai/index.js ---
const {masterChefExports} = require("../helper/masterchef") 

const mirai = "0xC6db58E05F647e6D0EE1bf38aC2619867cb9D3cD";
const masterchef = "0x6C6e46c671C848F87A173E95b9511FDA0C84Ba15";

module.exports = {
    ...masterChefExports(masterchef, "polygon", mirai, false)
}
'''
'''--- projects/mirror/index.js ---
const { default: BigNumber } = require("bignumber.js");
const { request, gql } = require("graphql-request");

const graphUrl = 'https://graph.mirror.finance/graphql'
const mirLiquidityQuery = gql`
query liq($network: Network){
  assets{
    token
    symbol
    statistic{
      liquidity(network: $network)
    }
  }
}
`;

const tvlQuery = gql`
query statistic{
  statistic{
    totalValueLocked {
      total
      collateral
      liquidity
    }
    collateralRatio
  }
}
`

const ust = val=>Number(val)*1e12
const fixed = val=>BigNumber(val).toFixed(0)

function getMirLiquidity(network){
  return request(
    graphUrl,
    mirLiquidityQuery,
    {
      network,
    }
  ).then(data=> data.assets);
}

const getTotalLiq = assets => assets.reduce((acc, asset)=>acc+ust(asset.statistic.liquidity), 0)
const getPool2Liq = liq => ust(liq.find(asset=>asset.symbol==="MIR").statistic.liquidity)
const ustAddress = "0xa47c8bf37f92abed4a126bda807a7b7498661acd"

async function terraPool2() {
  const pool2TerraLiq = getPool2Liq(await getMirLiquidity('TERRA'))
  return {
    [ustAddress] : fixed(pool2TerraLiq),
  }
}

async function ethereumPool2() {
  const pool2EthLiq = getPool2Liq(await getMirLiquidity('ETH'))
  return {
    [ustAddress] : fixed(pool2EthLiq),
  }
}

async function terraTvl() {
  const totalTvl = request(graphUrl,tvlQuery).then(data=>ust(data.statistic.totalValueLocked.total))
  const ethLiquidity = getMirLiquidity('ETH')
  const terraLiquidity = getMirLiquidity('TERRA')
  const totalEthLiquidity = getTotalLiq(await ethLiquidity)
  const pool2TerraLiq = getPool2Liq(await terraLiquidity)

  return {
    [ustAddress] : fixed((await totalTvl)-totalEthLiquidity-pool2TerraLiq),
  }
}

async function ethereumTvl() {
  const ethLiquidity = getMirLiquidity('ETH')
  const totalEthLiquidity = getTotalLiq(await ethLiquidity)
  const pool2EthLiq = getPool2Liq(await ethLiquidity)

  return {
    [ustAddress]: fixed(totalEthLiquidity-pool2EthLiq)
  }
}

module.exports = {
  timetravel: false,
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethereumTvl,
    pool2: ethereumPool2
  },
  terra: {
    tvl: () => ({'0': 0}),
    //pool2: terraPool2
  }
}

'''
'''--- projects/mistswap/index.js ---
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { staking } = require('../helper/staking')

const xMIST = "0xC41C680c60309d4646379eD62020c534eB67b6f4";
const MIST = "0x5fA664f69c2A4A3ec94FaC3cBf7049BD9CA73129";
const FLEXUSD = "0x7b2B3C5308ab5b2a1d9a94d20D35CCDf61e05b72";
const WBCH = "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04";
const FACTORY = "0x6008247F53395E7be698249770aa1D2bfE265Ca0";

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "Factory address (0x6008247F53395E7be698249770aa1D2bfE265Ca0) is used to find the LP pairs. TVL is equal to the liquidity on the AMM.",
  smartbch: {
    tvl: calculateUsdUniTvl(
      FACTORY,
      "smartbch",
      WBCH,
      [MIST, FLEXUSD],
      "bitcoin-cash"
    ),
    staking: staking(xMIST, MIST, 'smartbch', 'mistswap', 18)
  },
};

'''
'''--- projects/mm-finance/index.js ---
const { staking } = require('../helper/staking')
const { getUniTVL } = require('../helper/unknownTokens')

const factory = '0xd590cC180601AEcD6eeADD9B7f2B7611519544f4'
const mmfToken = '0x97749c9B61F878a880DfE312d2594AE07AEd7656'
const masterChef = '0x6bE34986Fdd1A91e4634eb6b9F8017439b7b5EDc'

module.exports = {
  timetravel: true,
  misrepresentedTokens: true,
  methodology: 'TVL accounts for the liquidity on all AMM pools, using the TVL chart on https://mm.finance as the source. Staking accounts for the MMF locked in MasterChef (0x6bE34986Fdd1A91e4634eb6b9F8017439b7b5EDc)',
  cronos: {
    staking: staking(masterChef, mmfToken, 'cronos'),
    tvl: getUniTVL({
      chain: 'cronos',
      factory,
      coreAssets: [
        '0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23', // wcro
      ],
      blacklist:[
        "0xd8d40dcee0c2b486eebd1fedb3f507b011de7ff0", // 10SHARE, token went to 0 and liq collapsed
        "0xa60943a1B19395C999ce6c21527b6B278F3f2046", // HKN
        "0x388c07066aa6cea2be4db58e702333df92c3a074", // hakuna too
      ]
    }),
  },
}
'''
'''--- projects/mmo-finance/abi.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "pool",
      "type": "address"
    }
  ],
  "name": "tvlOfPool",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "tvl",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/mmo-finance/genericVaultBalance.json ---

  {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
  
'''
'''--- projects/mmo-finance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const genericVaultBalance = require("./genericVaultBalance.json");
const valueOfAsset = require("./valueOfAsset.json");
const BigNumber = require("bignumber.js");

const dashboardCronos = "0x55f040E3A6e0ff69f5095B3cbF458919C5e02A0B";
const calculator = "0xa2B417088D63400d211A4D5EB3C4C5363f834764"

const poolsCronos = [
  "0x443ec402BeC44dA7138a54413b6e09037Cf9CF41",
 "0xB130a35acD62eb4604c6Ba6479D660D97a0A5aBE",
 "0xD2B3BDd43Bf5f6f28bD8b12d432afA46a3B20234",
 "0x08d7EBb6fd9dC10EA21a6AA788693aB763616951",
 "0xe4bc967855Eb076fA971a40c0Aa4B16Ba206aec2",
 "0xFf89646FE7Ee62EA96050379A7A8c532dD431d10",
 "0xe2ca90FC315356DecF71133Ba5938153596433f3",
 "0x7A42441f5Cf40cF0fBdA98F494fA2cc500177e86",
 "0x55B5540B5C48a27FD17ebe2B9E6a06911f8aa45A",
 "0x00Db5925892274F276846F25C7fE81DEc3F3B769",
 "0x34375b4c4094eCaAb494E22DFFe1f88f1D5143af",
 "0x7D35398F35F1dAD6e7a48d6f6E470CB11C77fc46",
];

const specialPools = [
  "0xcA37dcfC10D0366DBA41B19e9EBe7354bbF1aEC2", //METF - MMF 
  "0x1B27765F0606904eD8ebB5a915df22981ea4A261", //MSHARE-MMF 
  "0xc385C326133078Be00cd32D3587c21934E29c2aB", //SVN-MMF 
]

const staking = [
  "0x692db42F84bb6cE6A6eA62495c804C71aA6887A7", //MMO single sided
  "0xe4bc967855Eb076fA971a40c0Aa4B16Ba206aec2", //VVS single
  "0x443ec402BeC44dA7138a54413b6e09037Cf9CF41", //MMF single
]

const vaultsLPAddresses = ["0xd7385f46FFb877d8c8Fe78E5f5a7c6b2F18C05A7",
"0xc924da29d37f3b8C62c4c3e4e6958bF2b5ebF677",
  "0xB6E1705BfAFcf1efEE83C135C0F0210653bAB8F0",
]

const vaultToLP = {
  "0xcA37dcfC10D0366DBA41B19e9EBe7354bbF1aEC2": "0xd7385f46FFb877d8c8Fe78E5f5a7c6b2F18C05A7",
  "0x1B27765F0606904eD8ebB5a915df22981ea4A261": "0xc924da29d37f3b8C62c4c3e4e6958bF2b5ebF677",
  "0xc385C326133078Be00cd32D3587c21934E29c2aB": "0xB6E1705BfAFcf1efEE83C135C0F0210653bAB8F0"
}

const ZERO = new BigNumber(0);
const ETHER = new BigNumber(10).pow(18);

async function fetchSavannaLPPrice(timestamp, ethBlock, chainBlock) {
  const mmfBalance = {}
  const block = chainBlock.cronos;

  let data1 = await sdk.api.abi.multiCall({
    calls: vaultsLPAddresses.map((address) => ({
      target: "0x97749c9B61F878a880DfE312d2594AE07AEd7656",
      params: address,
    })),
    block,
    abi: 'erc20:balanceOf',
    chain: "cronos",
  })

  data1.output.forEach((call) => {
    let value = call && call.output && new BigNumber(call.output);
    if (value) {
      mmfBalance[call.input.params[0]] = value.dividedBy(ETHER);
    }
  });

  const totalSupply = {}

  let data2 = await sdk.api.abi.multiCall({
    calls: vaultsLPAddresses.map((address) => ({
      target: address,
      params: [],
    })),
    block,
    abi: 'erc20:totalSupply',
    chain: "cronos",
  })

  data2.output.forEach((call) => {
    let value = call && call.output && new BigNumber(call.output);
    if (value) {
      totalSupply[call.input.target] = value.dividedBy(ETHER);
    }
  });

  let priceOfMMF = 0;
  let data3 = await sdk.api.abi.multiCall({
    calls: [{
      target: calculator,
      params: ["0x97749c9B61F878a880DfE312d2594AE07AEd7656", "1000000000000000000"],
    }],
    block,
    abi: valueOfAsset,
    chain: "cronos",
  });
  data3.output.forEach((call) => {
    let value = call && call.output && new BigNumber(call.output.valueInUSD);
    if (value) {
      priceOfMMF = value.dividedBy(ETHER);
    }
  });
  const finalLPPrices = {}
  Object.keys(mmfBalance).forEach(x => {
    finalLPPrices[x] = mmfBalance[x].dividedBy(totalSupply[x]).times(priceOfMMF).times(2);
  })
  return finalLPPrices
}

async function TVLPool(timestamp, ethBlock, chainBlock) {
  const block = chainBlock.cronos;
  try {

    let LPPRices = await fetchSavannaLPPrice(timestamp, ethBlock, chainBlock);

    const specialBalance = {}
    let data1 = await sdk.api.abi.multiCall({
      calls: specialPools.map((address) => ({
        target: address,
        params: [],
      })),
      block,
      abi: genericVaultBalance,
      chain: "cronos",
    })

    const total2 = data1.output.reduce((tvl, call) => {
      let value = call && call.output && new BigNumber(call.output);
      if (value) {
        specialBalance[call.input.target] = value.dividedBy(ETHER) * LPPRices[vaultToLP[call.input.target]];
        return tvl.plus(value.dividedBy(ETHER) * LPPRices[vaultToLP[call.input.target]]);
      }
    }, ZERO);

    const total = (
      await sdk.api.abi.multiCall({
        calls: poolsCronos.map((address) => ({
          target: dashboardCronos,
          params: address,
        })),
        block,
        abi: abi,
        chain: "cronos",
      })
    ).output.reduce((tvl, call) => {
      let value = call && call.output && new BigNumber(call.output);
      if (value) {
        return tvl.plus(value.dividedBy(ETHER));
      }
      return tvl;
    }, ZERO);

    return {
      tether: total.plus(total2).toNumber(),
    };
  } catch (err) {
    console.error(err)
  }
}

async function singleStaking(timestamp, ethBlock, chainBlock) {
  const block = chainBlock.cronos;
  const total = (
    await sdk.api.abi.multiCall({
      calls: staking.map((address) => ({
        target: dashboardCronos,
        params: address,
      })),
      block,
      abi: abi,
      chain: "cronos",
    })
  ).output.reduce((tvl, call) => {
    let value = call && call.output && new BigNumber(call.output);
    if (value) {
      return tvl.plus(value.dividedBy(ETHER));
    }
    return tvl;
  }, ZERO);

  return {
    tether: total.toNumber(),
  };
}

module.exports = {
  methodology: `Total value in pools`,
  misrepresentedTokens: true,
  cronos: {
    tvl: TVLPool,
    staking: singleStaking
  },
};

'''
'''--- projects/mmo-finance/valueOfAsset.json ---
{
  "inputs": [
    {
      "internalType": "address",
      "name": "asset",
      "type": "address"
    },
    {
      "internalType": "uint256",
      "name": "amount",
      "type": "uint256"
    }
  ],
  "name": "valueOfAsset",
  "outputs": [
    {
      "internalType": "uint256",
      "name": "valueInCRO",
      "type": "uint256"
    },
    {
      "internalType": "uint256",
      "name": "valueInUSD",
      "type": "uint256"
    }
  ],
  "stateMutability": "view",
  "type": "function"
}
'''
'''--- projects/mmo/helper/abis/MEtherInterfaceFull.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "thisFungibleMToken",
    "outputs": [
      {
        "internalType": "uint240",
        "name": "",
        "type": "uint240"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "uint240",
        "name": "",
        "type": "uint240"
      }
    ],
    "name": "totalBorrows",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "uint240",
        "name": "",
        "type": "uint240"
      }
    ],
    "name": "totalCashUnderlying",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/mmo/helper/abis/MtrollerInterfaceFull.json ---
[
  {
    "constant": true,
    "inputs": [],
    "name": "oracle",
    "outputs": [
      {
        "internalType": "contract PriceOracle",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "price",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "underlyingToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenID",
        "type": "uint256"
      }
    ],
    "name": "getUnderlyingPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]

'''
'''--- projects/mmo/helper/helper.js ---
const sdk = require("@defillama/sdk");
const retry = require("../../helper/retry");

const { GraphQLClient, gql } = require("graphql-request");
const mEtherABI = require("./abis/MEtherInterfaceFull.json");
const MtrollerABI = require("./abis/MtrollerInterfaceFull.json");

async function fetch(query) {
  var endpoint =
    "https://api.thegraph.com/subgraphs/name/ohan8/mmo-finance-active-loans";
  var graphQLClient = new GraphQLClient(endpoint);

  const results = await retry(
    async (bail) => await graphQLClient.request(query)
  );
  return results;
}

async function getTotalCash(block) {
  const getTotalSupply = gql`
    {
      vaults {
        id
      }
    }
  `;
  const results = await fetch(getTotalSupply);

  const thisFungibleMTokenABI = mEtherABI.find(
    (i) => i.name === "thisFungibleMToken"
  );
  const mEtherIDCalls = results.vaults.map((vaultObj) => ({
    target: vaultObj.id,
  }));

  const mEtherIDs = await sdk.api.abi.multiCall({
    abi: thisFungibleMTokenABI,
    calls: mEtherIDCalls,
    block: block,
  });

  const totalCashUnderlyingABI = mEtherABI.find(
    (i) => i.name === "totalCashUnderlying"
  );
  const totalCashUnderlyingCalls = results.vaults.map((vaultObj, idx) => ({
    target: vaultObj.id,
    params: mEtherIDs.output[idx].output,
  }));

  const totalCashUnderlying = await sdk.api.abi.multiCall({
    abi: totalCashUnderlyingABI,
    calls: totalCashUnderlyingCalls,
    block: block,
  });
  let totalCashObj
  let totalCashAvailable = 0;
  for (totalCashObj of totalCashUnderlying.output) {
    totalCashAvailable += totalCashObj.output / 10 ** 18;
  }

  return totalCashAvailable;
}

async function getTotalCollateral(block) {
  const getDepositedNFTs = gql`
    {
      depositedNFTsEntities {
        tokenID
        name
        tokenAddress
        mtroller
      }
    }
  `;
  const results = await fetch(getDepositedNFTs);
  let depositedNFTObj
  let totalCollateral = 0;
  for (depositedNFTObj of results.depositedNFTsEntities) {
    if (depositedNFTObj.name === "Glasses") {
      const getPriceABI = MtrollerABI.find((i) => i.name === "price");

      const price = await sdk.api.abi.call({
        abi: getPriceABI,
        target: depositedNFTObj.tokenAddress,
        block: block,
      });
      totalCollateral += price.output / 10 ** 18;
    } else {
      const getOracleABI = MtrollerABI.find((i) => i.name === "oracle");
      const oracle = await sdk.api.abi.call({
        abi: getOracleABI,
        target: depositedNFTObj.mtroller,
        block: block,
      });
      const getUnderlyingPriceABI = MtrollerABI.find(
        (i) => i.name === "getUnderlyingPrice"
      );
      const price = await sdk.api.abi.call({
        abi: getUnderlyingPriceABI,
        target: oracle.output,
        params: [depositedNFTObj.tokenAddress, depositedNFTObj.tokenID],
        block: block,
      });
      totalCollateral += price.output / 10 ** 18;
    }
  }

  return totalCollateral;
}

module.exports = {
  getTotalCash,
  fetch,
  getTotalCollateral,
};

'''
'''--- projects/mmo/index.js ---
const sdk = require("@defillama/sdk");

const { gql } = require("graphql-request");
const mEtherABI = require("./helper/abis/MEtherInterfaceFull.json");
const { getTotalCash, getTotalCollateral, fetch } = require("./helper/helper");

async function tvl(block) {
  const totalCashAvailable = await getTotalCash(block);
  const totalCollateral = await getTotalCollateral(block);
  return {
    ethereum: totalCashAvailable + totalCollateral,
  };
}

async function borrowed(block) {
  const getTotalBorrows = gql`
    {
      vaults {
        id
      }
    }
  `;
  const results = await fetch(getTotalBorrows);
  const thisFungibleMTokenABI = mEtherABI.find(
    (i) => i.name === "thisFungibleMToken"
  );
  const mEtherIDCalls = results.vaults.map((vaultObj) => ({
    target: vaultObj.id,
  }));

  const mEtherIDs = await sdk.api.abi.multiCall({
    abi: thisFungibleMTokenABI,
    calls: mEtherIDCalls,
  });

  const totalBorrowsABI = mEtherABI.find((i) => i.name === "totalBorrows");
  const totalBorrowsCall = results.vaults.map((vaultObj, idx) => ({
    target: vaultObj.id,
    params: mEtherIDs.output[idx].output,
  }));

  const totalBorrowsResults = await sdk.api.abi.multiCall({
    abi: totalBorrowsABI,
    calls: totalBorrowsCall,
    block: block,
  });
  let borrowObj
  let totalBorrows = 0;
  for (borrowObj of totalBorrowsResults.output) {
    totalBorrows += borrowObj.output / 10 ** 18;
  }

  return { ethereum: totalBorrows };
}

module.exports = {
  timetravel: false,
  methodology: `Counts the tokens locked in our vault as collateral and the available cash in the pools. Borrowed ETH is not counted towards the TVL`,
  ethereum: {
    tvl,
    borrowed,
  },
};

'''
'''--- projects/mobius/index.js ---
/*==================================================
  Modules
  ==================================================*/
const sdk = require("@defillama/sdk");
const BigNumber = require("bignumber.js");

/*==================================================
  Addresses
  ==================================================*/
const wBTC = "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599";
const wETH = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
const cUSD = "0x765DE816845861e75A25fCA122bb6898B8B1282a";
const wBTCO = "0xBe50a3013A1c94768A1ABb78c3cB79AB28fc1aCE";
const pUSDC = "0xcC82628f6A8dEFA1e2B0aD7ed448bef3647F7941";
const cUSDC = "0x2A3684e9Dc20B857375EA04235F2F7edBe818FA7";
const CELO = "0x471EcE3750Da237f93B8E339c536989b8978a438";
const cUSDC_V2 = "0xef4229c8c3250C675F21BCefa42f58EfbfF6002a";
const pUSDC_V2 = "0x1bfc26cE035c368503fAE319Cc2596716428ca44";
const wBTC_V2 = "0xBAAB46E28388d2779e6E31Fd00cF0e5Ad95E327B";

const decimals = {
  [wBTC]: 8,
  [wBTCO]: 8,
  [wBTC_V2]: 8,
  [cUSDC]: 6,
  [pUSDC]: 6,
  [cUSDC_V2]: 6,
  [pUSDC_V2]: 6,
  ["celo-dollar"]: 0,
  ["celo"]: 0,
};

// {[string: name]: {
//   address: string,
//   peggedTo: string
//   tokens: string[],
// }}
const pools = {
  poof_cusd_v2: {
    address: "0xa2F0E57d4cEAcF025E81C76f28b9Ad6E9Fbe8735",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xEadf4A7168A82D30Ba0619e64d5BCf5B30B45226",
    ],
  },
  poof_celo_v2: {
    address: "0xFc9e2C63370D8deb3521922a7B2b60f4Cff7e75a",
    peggedTo: CELO,
    tokens: [
      "0x471EcE3750Da237f93B8E339c536989b8978a438",
      "0x301a61D01A63c8D670c2B8a43f37d12eF181F997",
    ],
  },
  usdc_optics_v2: {
    address: "0x9906589Ea8fd27504974b7e8201DF5bBdE986b03",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xef4229c8c3250C675F21BCefa42f58EfbfF6002a",
    ],
  },
  dai_optics_v2: {
    address: "0xF3f65dFe0c8c8f2986da0FEc159ABE6fd4E700B4",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0x90Ca507a5D4458a4C6C6249d186b6dCb02a5BCCd",
    ],
  },
  weth_optics_v2: {
    address: "0x74ef28D635c6C5800DD3Cd62d4c4f8752DaACB09",
    peggedTo: wETH,
    tokens: [
      "0x2DEf4285787d58a2f811AF24755A8150622f4361",
      "0x122013fd7dF1C6F636a5bb8f03108E876548b455",
    ],
  },
  wbtc_optics_v2: {
    address: "0xaEFc4e8cF655a182E8346B24c8AbcE45616eE0d2",
    peggedTo: wBTC,
    tokens: [
      "0xD629eb00dEced2a080B7EC630eF6aC117e614f1b",
      "0xBAAB46E28388d2779e6E31Fd00cF0e5Ad95E327B",
    ],
  },
  pusdc_optics_v2: {
    address: "0xcCe0d62Ce14FB3e4363Eb92Db37Ff3630836c252",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0x1bfc26cE035c368503fAE319Cc2596716428ca44",
    ],
  },
  usdc_allbridge_avax: {
    address: "0x0986B42F5f9C42FeEef66fC23eba9ea1164C916D",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xb70e0a782b058BFdb0d109a3599BEc1f19328E36",
    ],
  },
  usdc_allbridge_solana: {
    address: "0x63C1914bf00A9b395A2bF89aaDa55A5615A3656e",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xCD7D7Ff64746C1909E44Db8e95331F9316478817",
    ],
  },
  usdc_eth_optics: {
    address: "0xA5037661989789d0310aC2B796fa78F1B01F195D",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0x2A3684e9Dc20B857375EA04235F2F7edBe818FA7",
    ],
  },
  usdc_poly_optics: {
    address: "0x2080AAa167e2225e1FC9923250bA60E19a180Fb2",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xcC82628f6A8dEFA1e2B0aD7ed448bef3647F7941",
    ],
  },
  wbtc: {
    address: "0x19260b9b573569dDB105780176547875fE9fedA3",
    peggedTo: wBTC,
    tokens: [
      "0xD629eb00dEced2a080B7EC630eF6aC117e614f1b",
      "0xBe50a3013A1c94768A1ABb78c3cB79AB28fc1aCE",
    ],
  },
  weth: {
    address: "0xE0F2cc70E52f05eDb383313393d88Df2937DA55a",
    peggedTo: wETH,
    tokens: [
      "0x2DEf4285787d58a2f811AF24755A8150622f4361",
      "0xE919F65739c26a42616b7b8eedC6b5524d1e3aC4",
    ],
  },
  usdt_moss: {
    address: "0xdBF27fD2a702Cc02ac7aCF0aea376db780D53247",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0xcFFfE0c89a779c09Df3DF5624f54cDf7EF5fDd5D",
    ],
  },
  usdc_moss: {
    address: "0x0ff04189Ef135b6541E56f7C638489De92E9c778",
    peggedTo: cUSD,
    tokens: [
      "0x765DE816845861e75A25fCA122bb6898B8B1282a",
      "0x93DB49bE12B864019dA9Cb147ba75cDC0506190e",
    ],
  },
};
/*==================================================
  TVL
  ==================================================*/

async function tvl(timestamp, ethBlock, { celo: block }) {
  const chain = "celo";
  const balances = {};

  const promises = Object.values(pools).map(async (pool) => {
    const { address, peggedTo, tokens } = pool;
    const peg =
      peggedTo === cUSD ? "celo-dollar" : peggedTo === CELO ? "celo" : peggedTo;
    if (!balances[peg]) {
      balances[peg] = BigNumber(0);
    }
    const tokenBalances = await Promise.all(
      tokens.map(async (token) => {
        const balance = await sdk.api.erc20.balanceOf({
          block,
          chain,
          target: token,
          owner: address,
        });
        const baseDecimals = decimals[token] ?? 18;
        const targetDecimals = decimals[peg] ?? 18;
        if (baseDecimals === targetDecimals) return BigNumber(balance.output);
        if (baseDecimals < targetDecimals)
          return BigNumber(balance.output).multipliedBy(
            BigNumber(10).exponentiatedBy(
              BigNumber(targetDecimals - baseDecimals)
            )
          );
        return BigNumber(balance.output).dividedBy(
          BigNumber(10).exponentiatedBy(
            BigNumber(baseDecimals - targetDecimals)
          )
        );
      })
    );
    balances[peg] = tokenBalances.reduce(
      (accum, cur) => accum.plus(cur),
      balances[peg]
    );
  });

  await Promise.all(promises);

  return balances;
}

/*==================================================
  Exports
  ==================================================*/

module.exports = {
  start: 8606077, // January 19, 2021 11:51:30 AM
  celo: { tvl }
};

///

'''
'''--- projects/mobiusfinance/abis/Resolver.json ---
{
  "contractName": "Resolver",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "assetType",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "assetName",
          "type": "bytes32"
        }
      ],
      "name": "getAsset",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "assetType",
          "type": "bytes32"
        }
      ],
      "name": "getAssets",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ]
}
'''
'''--- projects/mobiusfinance/index.js ---
const formatBytes32String = require('ethers').utils.formatBytes32String;
const { sumTokens, } = require('../helper/unwrapLPs')
const { resolveCrvTokens, } = require('../helper/resolveCrvTokens')
const { transformPolygonAddress } = require('../helper/portedTokens')
const ResolverAddr = "0x1E02cdbbA6729B6470de81Ad4D2cCA4c514521b9"

const ResolverJson = require('./abis/Resolver.json').abi;

const sdk = require('@defillama/sdk')
const chain = 'polygon'
const nullAddr = "0x0000000000000000000000000000000000000000"
const motToken = '0x2db0Db271a10661e7090b6758350E18F6798a49D'

async function tvl(ts, _block, { polygon: block }) {
  const mobiusStr = formatBytes32String("Mobius")
  const stakeStr = formatBytes32String("Stake")
  const motStr = formatBytes32String("MOT")
  const balances = {}
  const transform = await transformPolygonAddress()

  const [
    MobiusAddr,
    Collaterals,
  ] = await Promise.all([
    sdk.api.abi.call({
      target: ResolverAddr, abi: ResolverJson.find(i => i.name === 'getAddress'), params: [mobiusStr], block, chain,
    }),
    sdk.api.abi.call({
      target: ResolverAddr, abi: ResolverJson.find(i => i.name === 'getAssets'), params: [stakeStr], block, chain,
    }),
  ]).then(o => o.map(i => i.output))

  await Promise.all(Collaterals.map(async collateral => {

    if (collateral === motStr)
      return;

    let { output: r } = await sdk.api.abi.call({
      target: ResolverAddr, abi: ResolverJson.find(i => i.name === 'getAsset'), params: [stakeStr, collateral], block, chain,
    })

    if (!r[0])
      return;

    if (r[1] == nullAddr) {
      const response = await sdk.api.eth.getBalance({ target: MobiusAddr, block, chain, })
      sdk.util.sumSingleBalance(balances, transform(nullAddr), response.output)
    } else {
      const response = await sdk.api.erc20.balanceOf({ target: r[1], owner: MobiusAddr, block, chain, })
      sdk.util.sumSingleBalance(balances, transform(r[1]), response.output)
    }
  }))

  await resolveCrvTokens(balances, block, chain, transform)
  return balances
}

async function staking(ts, _block, { polygon: block }) {
  const mobiusStr = formatBytes32String("Mobius")

  const [
    MobiusAddr,
  ] = await Promise.all([
    sdk.api.abi.call({
      target: ResolverAddr, abi: ResolverJson.find(i => i.name === 'getAddress'), params: [mobiusStr], block, chain,
    }),
  ]).then(o => o.map(i => i.output))

  return sumTokens({}, [[motToken, MobiusAddr]], block, chain)
}

async function pool2(ts, _block, { polygon: block }) {
  const rewardAddrStr = formatBytes32String("RewardStaking")

  const [
    rewardAddr,
  ] = await Promise.all([
    sdk.api.abi.call({
      target: ResolverAddr, abi: ResolverJson.find(i => i.name === 'getAddress'), params: [rewardAddrStr], block, chain,
    }),
  ]).then(o => o.map(i => i.output))
  const toa = [
    '0x162b21ba1a90dd9384c615192fa4053217d2a8db',
    '0x53add4c98b2787f690042771ca8e512a5793e9c9',
    '0x49d8136336e3feb7128c12172ae5ff78238a88be',
  ].map(t => [t, rewardAddr])

  return sumTokens({}, toa, block, chain, undefined, { resolveLP: true, resolveCrv: true, })
}

module.exports = {
  polygon: {
    tvl,
    staking,
    pool2,
  },
}

'''
'''--- projects/mobox.js ---
const sdk = require("@defillama/sdk");
const { unwrapUniswapLPs } = require("./helper/unwrapLPs");
const abi = require("./pendle/abi.json");
const { stakings } = require("./helper/staking.js");

async function pool2(timestamp, block, chainBlocks) {
  const balances = {};

  const masterChefDeposits = await sdk.api.abi.call({
    target: "0x73feaa1ee314f8c655e354234017be2193c9e24e",
    abi: abi.userInfo,
    params: [405, "0x9442dad1df11c858a900f55291dc1cf645ff66df"],
    block: chainBlocks.bsc,
    chain: "bsc",
  });

  await unwrapUniswapLPs(
    balances,
    [
      {
        balance: masterChefDeposits.output.amount,
        token: "0x8FA59693458289914dB0097F5F366d771B7a7C3F",
      },
    ],
    chainBlocks.bsc,
    "bsc",
    (a) => `bsc:${a}`
  );

  return balances;
}

module.exports = {
  bsc: {
    tvl: () => ({}),
    pool2,
    staking: stakings(
      [
        "0xdad49e63f97c967955975490a432de3796c699e6",
        "0xf8c1bA88F1E4aeD152F945F1Df2a8fdc36127B5f",
        "0x3bD6a582698ECCf6822dB08141818A1a8512c68D",
      ],
      "0x3203c9e46ca618c8c1ce5dc67e7e9d75f5da2377",
      "bsc"
    ),
  },
};

'''
'''--- projects/mochifi/index.js ---
const { GraphQLClient, gql } = require('graphql-request');
// node test.js projects/mochifi/index.js
const BLOCK_SHIFT = 10

const endpoints = {
  ethereum: 'https://api.thegraph.com/subgraphs/name/ryuheimat/mochi-staging',
}

const query = gql`
query get_tvl($block: Int) {
  vaults(
    first: 1000,
    block: { number: $block }
  ) {
    asset
    deposits
  }
}
`;

async function ethereum(timestamp, block, chainBlocks) {
  const graphQLClient = new GraphQLClient(endpoints.ethereum);
  const { vaults } = await graphQLClient.request(
    query,
    { block: +block - BLOCK_SHIFT }
  );
  const results = vaults
    .filter(v => +v.deposits > 0)
    .reduce((acc, v) => {
      acc[v.asset] = v.deposits
      return acc
    }, {})
  delete results['0x60ef10edff6d600cd91caeca04caed2a2e605fe5']
  return results
}

module.exports = {
  methodology: "TVL counts collateral deposits to mint USDM",
  ethereum: {
    tvl: ethereum
  },
}

'''
'''--- projects/mochiswap/index.js ---
const sdk = require('@defillama/sdk');
const { getUniTVL } = require('../helper/unknownTokens');

const bscMochi = "0x055daB90880613a556a5ae2903B2682f8A5b8d27";
const bscBMochi = "0x2d0e75b683e8b56243b429b24f2b08bcc1ffd8da";
const bscChef = "0x464F1A30e5A5b5b2D3c5f4F0e823e01EeFE304df";
const bscFactory = '0xCBac17919f7aad11E623Af4FeA98B10B84802eAc'

async function bscStaking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (await sdk.api.erc20.balanceOf({
    target: bscBMochi,
    owner: bscChef,
    block: chainBlocks.bsc,
    chain: "bsc"
  })).output;
  sdk.util.sumSingleBalance(balances, `bsc:${bscMochi}`, balance);
  return balances;
}

const harmonyFactory = '0x3bEF610a4A6736Fd00EBf9A73DA5535B413d82F6'
const harmonyHMochi = "0x0dd740db89b9fda3baadf7396ddad702b6e8d6f5";
const harmonyStakingToken = "0x691f37653f2fbed9063febb1a7f54bc5c40bed8c";
const harmonyChef = "0xd0cb3e55449646c9735d53e83eea5eb7e97a52dc";

async function harmonyStaking(timestamp, block, chainBlocks) {
  let balances = {};
  let balance = (await sdk.api.erc20.balanceOf({
    target: harmonyStakingToken,
    owner: harmonyChef,
    block: chainBlocks.harmony,
    chain: "harmony"
  })).output;
  sdk.util.sumSingleBalance(balances, `harmony:${harmonyHMochi}`, balance);
  return balances;
}

module.exports = {
 bsc: {
   tvl: getUniTVL({
     chain: 'bsc',
     factory: bscFactory,
     coreAssets: [
       '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c', // wbnb
       bscBMochi,
       bscMochi,
     ]
   }),
   staking: bscStaking
 },
  harmony: {
    tvl: getUniTVL({
      chain: 'harmony',
      factory: harmonyFactory,
      coreAssets: [
        '0xE176EBE47d621b984a73036B9DA5d834411ef734', // BUSD
        '0xcF664087a5bB0237a0BAd6742852ec6c8d69A27a', // wone
        harmonyStakingToken, // hMOCHI
      ]
    }),
    staking: harmonyStaking
  },
  
}

'''
'''--- projects/mockingbird/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0x7a7d80c024192E946C8931CcD325ECb2F42f8361"
const mockingbird = "0x0A737c40E42b164B30c0d3E5A19152CB89aA3EB9"
const mockingbirdFtmLP = "0x04701bEef0caf3B623B3965323Ce3caa4B2b2d7D";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [mockingbird, mockingbirdFtmLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, mockingbird, "fantom"),
      pool2: pool2Exports(chef, [mockingbirdFtmLP], "fantom"),
  },
  
} 
'''
'''--- projects/mojitoswap/index.js ---
const { getChainTvl, getStakeLockValue } = require("./utils");

const MJT_GRAPH = "https://thegraph.kcc.network/subgraphs/name/mojito/swap";
const graphUrls = {
  kcc: MJT_GRAPH,
};

const chainTvl = getChainTvl(graphUrls);
const stakingValue = getStakeLockValue();

module.exports = {
  misrepresentedTokens: true,
  methodology:
    "We count liquidity and staking on the dexes, pulling data from subgraphs",
  kcc: {
    tvl: chainTvl("kcc"),
    staking: stakingValue(),
  },
  start: 3000000,
  timetravel: false,
};

'''
'''--- projects/mojitoswap/query.js ---
const {  gql } = require("graphql-request");

const KCC_BLOCK_GRAPH =
  "https://thegraph.kcc.network/subgraphs/name/kcc-blocks";

const GET_BLOCK = gql`
  query blocks($timestampFrom: Int!, $timestampTo: Int!) {
    blocks(
      first: 1
      orderBy: timestamp
      orderDirection: asc
      where: { timestamp_gt: $timestampFrom, timestamp_lt: $timestampTo }
    ) {
      id
      number
      timestamp
    }
  }
`;

module.exports = {
  KCC_BLOCK_GRAPH,
  GET_BLOCK,
};

'''
'''--- projects/mojitoswap/utils.js ---
const { request, gql } = require("graphql-request");
const { toUSDTBalances } = require("../helper/balances");
const sdk = require('@defillama/sdk')
const masterchefAddress = "0x25c6d6a65c3ae5d41599ba2211629b24604fea4f";
const masterchefV2Address = "0xfdfcE767aDD9dCF032Cbd0DE35F0E57b04495324";
const mjtAddress = "0x2ca48b4eea5a731c2b54e7c3944dbdb87c0cfb6f";

const {
  KCC_BLOCK_GRAPH,
  GET_BLOCK,
} = require("./query");

async function getLatestBlock(timestamp) {
  //  a few blocks behind the blockchain,so we write a hack here
  const unixTimeNow = Math.floor(Date.now()/1000)
  const utcCurrentTime = timestamp ?? unixTimeNow;
  const res = await request(KCC_BLOCK_GRAPH, GET_BLOCK, {
    timestampFrom: utcCurrentTime,
    timestampTo: utcCurrentTime + 600,
  });

  const block =
    res?.blocks[0]?.number ?? (await getLatestBlock(unixTimeNow - 600));
  return Number(block);
}

function getChainTvl(
  graphUrls,
  factoriesName = "uniswapFactories",
  tvlName = "totalLiquidityUSD"
) {
  const graphQuery = gql`
query get_tvl($block: Int) {
  ${factoriesName}(
    block: { number: $block }
  ) {
    ${tvlName}
  }
}
`;

  return (chain) => {
    return async (timestamp, ethBlock, chainBlocks) => {
      const block = await getLatestBlock(timestamp);
      const uniswapFactories = (
        await request(graphUrls[chain], graphQuery, {
          block,
        })
      )[factoriesName];
      const usdTvl = Number(uniswapFactories[0][tvlName]);
      return toUSDTBalances(usdTvl);
    };
  };
}

const getStakeLockValue = () => {
  return (chain) => {
    return async (timestamp, ethBlock, chainBlocks) => {
      const {output: mjBalances} = await sdk.api.abi.multiCall({
        calls: [masterchefAddress, masterchefV2Address].map(i => ({ params: i})),
        target: mjtAddress,
        abi: 'erc20:balanceOf',
        block: chainBlocks.kcc,
        chain: 'kcc',
      })

      let total = 0
      mjBalances.forEach(({ output }) => total += +output)

      return {
        mojitoswap: total / 1e18
      };
    };
  };
};

module.exports = {
  getChainTvl,
  getStakeLockValue,
};

'''
'''--- projects/mole/abi.json ---
{
  "vaultDebtVal": {
    "inputs": [],
    "name": "vaultDebtVal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "token": {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "pid": {
    "inputs": [],
    "name": "pid",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "reservePool": {
    "inputs": [],
    "name": "reservePool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "balanceOf": {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "lpToken": {
    "inputs": [],
    "name": "lpToken",
    "outputs": [
      {
        "internalType": "contract IPancakePair",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "userInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "rewardDebt",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "xmoleTotalSupply": {
    "inputs": [],
    "name": "supply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/mole/index.js ---
const { calLyfTvl } = require("./lyf");
const { calxMOLEtvl } = require('./xmole');

async function avaxTvl(timestamp, ethBlock, chainBlocks) {
  const lyfTvl = await calLyfTvl('avax', chainBlocks.avax);
  return {...lyfTvl};
}

async function avaxStaking(timestamp, ethBlock, chainBlocks) {
  return await calxMOLEtvl('avax', chainBlocks.avax);
}

// node test.js projects/mole/index.js
module.exports = {
  start: 1653840000,
  avax: {
    tvl: avaxTvl,
    staking: avaxStaking,
  }
};

'''
'''--- projects/mole/lyf.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const { transformAvaxAddress } = require("../helper/portedTokens");

async function getProcolAddresses(chain) {
  if (chain == 'avax') {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/Mole-Fi/mole-protocol/main/.avalanche_mainnet.json"
      )
    ).data;
  }
}

async function calLyfTvl(chain, block) {
  /// @dev Initialized variables
  const balances = {};
  const transform = await transformAvaxAddress()

  /// @dev Getting all addresses from Github
  const addresses = await getProcolAddresses(chain);

  for (let i = 0; i < addresses["Vaults"].length; i++) {
    /// @dev getting balances that each of workers holding
    const stakingTokenInfos = (
      await sdk.api.abi.multiCall({
        block,
        abi: abi.userInfo,
        calls: addresses["Vaults"][i]["workers"].map((worker) => {
          return {
            target: worker["stakingTokenAt"],
            params: [worker["pId"], worker["address"]],
          };
        }),
        chain,
      })
    ).output;

    /// @dev unwrap LP to get underlaying token balances for workers that are working with LPs
    await unwrapUniswapLPs(
      balances,
      stakingTokenInfos
        .map((info) => {
          /// @dev getting LP address and return the object that unwrapUniswapLPs want
          const lpAddr = addresses["Vaults"][i]["workers"].find(
            (w) => w.address === info.input.params[1]
          ).stakingToken;
          return {
            token: lpAddr,
            balance: info.output.amount,
          };
        }),
      block,
      chain,
      transform
    );
  }

  /// @dev getting all unused liquidity on each vault
  const unusedBTOKEN = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.balanceOf,
      calls: addresses["Vaults"].map((v) => {
        return {
          target: v["baseToken"],
          params: [v["address"]],
        };
      }),
      chain,
    })
  ).output;

  unusedBTOKEN.forEach((u) => {
    balances[transform(u.input.target.toLowerCase())] = BigNumber(
      balances[transform(u.input.target.toLowerCase())] || 0
    )
      .plus(BigNumber(u.output))
      .toFixed(0);
  });

  return balances;
}

module.exports = {
  calLyfTvl
}
  
'''
'''--- projects/mole/xmole.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");
const BigNumber = require("bignumber.js");
const axios = require("axios");

async function getProcolXMoleAddresses(chain) {
  if (chain == "avax") {
    return (
      await axios.get(
        "https://raw.githubusercontent.com/Mole-Fi/mole-protocol-xmole/main/.avalanche_mainnet.json"
      )
    ).data;
  }
}
  

async function calxMOLEtvl(chain, block) {
  const xmoleAddresses = await getProcolXMoleAddresses(chain);

  const xmoleTVL = (
    await sdk.api.abi.multiCall({
      block,
      abi: abi.xmoleTotalSupply,
      calls: [
        {
          target: xmoleAddresses["xMOLE"],
        },
      ],
      chain,
    })
  ).output;
  const moleAddress = xmoleAddresses["Tokens"]["MOLE"];
  return { [`${chain}:${moleAddress}`]: xmoleTVL[0].output };
}

module.exports = {
  calxMOLEtvl,
}
'''
'''--- projects/moneyonchain.js ---
// Money on Chain exists on the RSK chain
// Based on four tokens:
// The DoC, a USD price pegged Stablecoin token.
// The BPro (Bitpro) a token designed for BTC hodlers, to earn a rent on Bitcoin and gain free leverage.
// The BTCx, a token that represents a leveraged long bitcoin holding position.
// The MoC token, designed to govern a decentralized autonomous organization (DAO) that will govern the Smart Contracts.

// Various API endpoints: https://api.moneyonchain.com/api/report/

// stats from https://moneyonchain.com/stats/
const sdk = require('@defillama/sdk')

async function tvl(_, _b, { rsk: block }) {
  const docCollateral = '0xf773b590af754d597770937fa8ea7abdf2668370'
  const { output } = await sdk.api.eth.getBalances({
    targets: [docCollateral],
    chain: 'rsk', block,
  });
  let total = 0
  output.forEach(i => total += i.balance/1e18)
  return {
    'rootstock': total
  }
}

module.exports = {
  timetravel: false,
  rsk: {
    tvl,
  }
}
'''
'''--- projects/moneyrainfinance/index.js ---
const abi = require("../helper/abis/masterchef.json")
const { transformFantomAddress } = require("../helper/portedTokens");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { staking } = require("../helper/staking");
const { pool2Exports } = require('../helper/pool2')

const chef = "0xa1E756016D27E22eCA181D2dC1f6Bb462BbA199E"
const moneyrain = "0x9ce66Ef13D88cb1bC567E47459841483c5d9457C"
const moneyrainFtmLP = "0x18c7a09c1e0eb4045a1bdafd1fd78c016c4a2d84"
const moneyrainUsdcLP = "0x8e9d1a921f91c1f0d33c881d34de8d40a472be23";

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = await transformFantomAddress();
  await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [moneyrain, moneyrainFtmLP, moneyrainUsdcLP]);
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract",
  fantom: {
      tvl,
      staking: staking(chef, moneyrain, "fantom"),
      pool2: pool2Exports(chef, [moneyrainFtmLP, moneyrainUsdcLP], "fantom"),
  },
  
} 
'''
'''--- projects/monox/index.js ---
const {sumTokensSharedOwners} = require('../helper/unwrapLPs')

async function eth(timestamp, ethBlock, chainBlocks){
    const block = chainBlocks.ethereum
    const balances = {}
    await sumTokensSharedOwners(balances, [
        "0x99d8a9c45b2eca8864373a26d1459e3dff1e17f3",
        "0x92e187a03b6cd19cb6af293ba17f2745fd2357d5",
        "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
    ], ["0x59653E37F8c491C3Be36e5DD4D503Ca32B5ab2f4"], ethBlock)
    return balances
}

async function polygon(timestamp, ethBlock, chainBlocks){
    const block = chainBlocks.polygon
    const balances = {}
    await sumTokensSharedOwners(balances, [
        "0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
        "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
        "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
    ], ["0x3826367A5563eCE9C164eFf9701146d96cC70AD9"], block, "polygon")
    return balances
}

module.exports = {
    ethereum:{
        tvl:eth
    },
    polygon:{
        tvl:polygon
    }
}
'''
'''--- projects/monster/index.js ---
const sdk = require("@defillama/sdk");
const { transformFantomAddress } = require("../helper/portedTokens");
const { unwrapUniswapLPs } = require("../helper/unwrapLPs");
const MST_TOKEN_CONTRACT = "0x152888854378201e173490956085c711f1DeD565";
const VE_CONTRACT = "0xc8034b3dF18Ea4d607E86D6b6Bf23E2A8Ed70F89";
const LP_POOL_1 = "0x1a88e447c7468b28de490b25a076a4ffc0c68b16";
const LP_STAKING_1 = "0x06bFdfF7366DE711F363105F446f8399663db749";
const LP_POOL_2 = "0x1f5c5b104d6246B3d096135806cd6C6e53e206F1";
const LP_STAKING_2 = "0xc13926C5CB2636a29381Da874b1e2686163DC226";

async function staking(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformFantomAddress();

  const collateralBalance = (
    await sdk.api.abi.call({
      abi: "erc20:balanceOf",
      chain: "fantom",
      target: MST_TOKEN_CONTRACT,
      params: [VE_CONTRACT],
      block: chainBlocks["fantom"],
    })
  ).output;

  await sdk.util.sumSingleBalance(
    balances,
    transform(MST_TOKEN_CONTRACT),
    collateralBalance
  );

  return balances;
}

async function pool2(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformFantomAddress();

  const balance1 = (
    await sdk.api.abi.call({
      abi: "erc20:balanceOf",
      chain: "fantom",
      target: LP_POOL_1,
      params: [LP_STAKING_1],
      block: chainBlocks["fantom"],
    })
  ).output;

  await unwrapUniswapLPs(
    balances,
    [
      {
        token: LP_POOL_1,
        balance: balance1,
      },
    ],
    chainBlocks["fantom"],
    "fantom",
    transform
  );

  const balance2 = (
    await sdk.api.abi.call({
      abi: "erc20:balanceOf",
      chain: "fantom",
      target: LP_POOL_2,
      params: [LP_STAKING_2],
      block: chainBlocks["fantom"],
    })
  ).output;

  await unwrapUniswapLPs(
    balances,
    [
      {
        token: LP_POOL_2,
        balance: balance2,
      },
    ],
    chainBlocks["fantom"],
    "fantom",
    transform
  );

  return balances;
}

module.exports = {
  timetravel: true,
  misrepresentedTokens: false,
  methodology:
    "counts the number of MST tokens in the ve contract and the pairs in the staking pool",
  start: 22569995,
  fantom: {
    tvl: async () => ({}),
    pool2: pool2,
    staking: staking,
  },
};

'''
'''--- projects/moola/index.js ---
const { getBlock } = require('../helper/getBlock')
const { aaveChainTvl } = require('../helper/aave')
const { singleAssetV1Market } = require('../aave/v1')
const sdk = require('@defillama/sdk')

const v1PoolCore = "0xAF106F8D4756490E7069027315F4886cc94A8F73"
const gasAsset = "0x471ece3750da237f93b8e339c536989b8978a438"

function lending(borrowed) {
    return async (timestamp, ethBlock, chainBlocks) => {
        const chain = 'celo'
        const block = await getBlock(timestamp, chain, chainBlocks, true);
        const v1Balances = {};
        await singleAssetV1Market(v1Balances, v1PoolCore, block, borrowed, chain, gasAsset);

        const balances = await aaveChainTvl(chain, "0xF03982910d17d11670Dc3734DD73292cC4Ab7491", addr => `celo:${addr}`, ["0x43d067ed784D9DD2ffEda73775e2CC4c560103A1"], borrowed)(timestamp, ethBlock, {
            ...chainBlocks,
            celo: block
        })
        Object.entries(v1Balances).map(entry => sdk.util.sumSingleBalance(balances, "celo:" + entry[0], entry[1]))
        return balances
    }
}

// v2 addresses on https://github.com/moolamarket/moola-v2/commit/ab273248af81aa743310b4fd48533462aefe39e9
module.exports = {
    methodology: "Same as compound, we just get all the collateral (not borrowed money) on the lending markets",
    celo: {
        tvl: lending(false),
        borrowed: lending(true),
    }
}
'''
'''--- projects/moondao/index.js ---
const { ohmTvl } = require('../helper/ohm')

const treasury = "0xeC2aE8A3E2692E4b0836AB5cf88104d101DEBEf4"
module.exports = ohmTvl(treasury, [
    //DAI
    ["0x80a16016cc4a2e6a2caca8a4a498b1699ff0f844", false],
    //USDC
    ["0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d", false],
    //solarbeam LP
    ["0xdbf638d800190271f5473e76898c6c8e741cba51", true],
   ], "moonriver", "0x534F861B6BaFdF030E5b469D2d763834163f522f", "0x761cb807bFbF14A4f4bA980f29F43F009F6a18c0")
'''
'''--- projects/moonfarm.js ---
const utils = require('./helper/utils');
const farmDataEndpoint = "https://marketcap.moonfarm.finance/get-farms-data"

async function fetch() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlUSD
}

async function bsc() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlBSC
}

async function polygon() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlPoly
}

async function ethereum() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlETH
}

async function kava() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlKAVA
}
async function avalanche() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlAVAX
}

async function fantom() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlFANTOM
}

async function terra() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlLUNA
}

async function solana() {
  const data = await utils.fetchURL(farmDataEndpoint)
  return data.data.tvlSOLANA
}

module.exports = {
  bsc:{
    fetch:bsc
  },
  polygon:{
    fetch: polygon
  },
  ethereum:{
    fetch: ethereum
  },
  kava:{
    fetch: kava
  },
  avalanche:{
    fetch: avalanche
  },
  fantom:{
    fetch: fantom
  },
  terra:{
    fetch: terra
  },
  solana:{
    fetch: solana
  },
  fetch
}

'''
'''--- projects/moonflowerfarmers/index.js ---
const { sumTokensAndLPsSharedOwners } = require("../helper/unwrapLPs");
const MFF = "0x78b65477bba78fc11735801d559c386611d07529";
const contract = "0xDE707357D10D86aE21373b290eAbBA07360896F6";
const sdk = require("@defillama/sdk");
const abi = require("../vexchange/abi.json");
const { getBlock } = require("../helper/getBlock");

async function staking(timestamp, block, chainBlocks) {
  const balances = {};
  block = getBlock(timestamp, "aurora", chainBlocks);
  const MFFPrice = await getMFFPrice(block);

  await sumTokensAndLPsSharedOwners(
    balances,
    [[MFF, false]],
    [contract],
    block,
    "aurora",
    (addr) => `aurora:${addr}`
  );

  balances.terrausd = (balances[`aurora:${MFF}`] * MFFPrice) / 10 ** 18;
  delete balances[`aurora:${MFF}`];

  return balances;
}
async function getMFFPrice(block) {
  const reserves = (
    await sdk.api.abi.call({
      target: "0x3c508FC05C289BA989CF877bb2e3f6e54eF3fc95",
      abi: abi.getReserves,
      block,
      chain: "aurora",
    })
  ).output;
  return reserves[0] / reserves[1];
}

module.exports = {
  aurora: {
    tvl: () => ({}),
    staking,
  },
};

'''
'''--- projects/mooniswap/abi.json ---
{
    "getAllPools": {
        "inputs": [],
        "name": "getAllPools",
        "outputs": [
            {
                "internalType": "contract Mooniswap[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "getTokens": {
        "inputs": [],
        "name": "getTokens",
        "outputs": [
            {
                "internalType": "contract IERC20[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/mooniswap/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const factoryContract = "0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303";

const ethTvl = async () => {
  const balances = {};

  const getAllpools = (
    await sdk.api.abi.call({
      abi: abi.getAllPools,
      target: factoryContract,
    })
  ).output;

  for (const pool of getAllpools) {
    const getTokens = (
      await sdk.api.abi.call({
        abi: abi.getTokens,
        target: pool,
      })
    ).output;

    const getBalance = (
      await sdk.api.abi.multiCall({
        abi: 'erc20:balanceOf',
        calls: getTokens.map((token) => ({
          target: token,
          params: pool,
        })),
      })
    ).output.map((bal) => bal.output);

    getTokens.forEach((token, idx) => {
      if (getBalance[idx] === null) {
        return;
      } else {
        sdk.util.sumSingleBalance(balances, token, getBalance[idx]);
      }
    });
  }

  return balances;
};

module.exports = {
  misrepresentedTokens: true,
  ethereum: {
    tvl: ethTvl,
  },
  methodology: "Counts tvl on all AMM Pools through Factory Contract",
};

'''
'''--- projects/moonpot/index.js ---
const utils = require('../helper/utils');

function fetchForNetwork(network) {
  return async () => {
    const response = await utils.fetchURL('https://api.moonpot.com/v2/tvl/' + network);
    return response.data.total;
  }
}

async function fetch() {
  const response = await utils.fetchURL('https://api.moonpot.com/v2/tvl');
  return response.data.total;
}

module.exports = {
  bsc: {
    fetch: fetchForNetwork('bsc')
  },
  fantom:{
    fetch: fetchForNetwork('fantom')
  },
  fetch
}
'''
'''--- projects/moonswap/index.js ---
const {getChainTvl} = require('../helper/getUniSubgraphTvl')

const tvl = getChainTvl({
    'moonriver': 'https://api.thegraph.com/subgraphs/name/moonfarmin/moonswap-dex'
})

module.exports={
    tvl: tvl('moonriver'),
    methodology: "We get the tvl from the subgraph at graph.moonfarm.in/subgraphs/name/moonswap, it only includes liquidity on the DEX"
} // node test.js projects/moonswap/index.js
'''
'''--- projects/moonswap/onchain.js ---
const sdk = require("@defillama/sdk");
const axios = require('axios');
const factoryAbi = require("../helper/abis/factory.json");
const token0 = require("../helper/abis/token0.json");
const token1 = require("../helper/abis/token1.json");
const getReserves = require("../helper/abis/getReserves.json");

async function tvl(timestamp, ethBlock, chainBlocks) {
    let balances = {};
    let factoryAddress = '0x056973F631A5533470143bB7010C9229C19C04d2'

    // GET NUMBER OF POOLS FROM FACTORY
    const pairLength = Number((
        await sdk.api.abi.call({
            target: factoryAddress,
            abi: factoryAbi.allPairsLength,
            chain: 'moonriver',
            block: chainBlocks['moonriver'],
        })
    ).output);
    const allPairNums = Array.from(Array(pairLength).keys());

    // GET POOL ADDRESSES
    const pairs = await sdk.api.abi.multiCall({
        abi: factoryAbi.allPairs,
        chain: 'moonriver',
        calls: allPairNums.map((num) => ({
            target: factoryAddress,
            params: [num],
            })),
        });
    const pairAddresses = pairs.output.map(r => r.output.toLowerCase())

    // FIND TOKEN BALANCES
    const [token0Addresses, token1Addresses, reserves] = await Promise.all([
        sdk.api.abi
          .multiCall({
            abi: token0,
            chain: 'moonriver',
            calls: pairAddresses.map((pairAddress) => ({
              target: pairAddress,
            })),
            block: chainBlocks['moonriver'],
          })
          .then(({ output }) => output),
        sdk.api.abi
          .multiCall({
            abi: token1,
            chain: 'moonriver',
            calls: pairAddresses.map((pairAddress) => ({
              target: pairAddress,
            })),
            block: chainBlocks['moonriver'],
          })
          .then(({ output }) => output),
        sdk.api.abi
          .multiCall({
            abi: getReserves,
            chain: 'moonriver',
            calls: pairAddresses.map((pairAddress) => ({
              target: pairAddress,
            })),
            block: chainBlocks['moonriver'],
          })
          .then(({ output }) => output),
      ]);

    // CALCULATE VALUE OF POOLS WRT TOKENS OF KNOWN VALUE 
    for (let n = 0; n < pairLength; n++) {
        const tokenIds = [
            getTokenId(token0Addresses[n].output.toLowerCase()),
            getTokenId(token1Addresses[n].output.toLowerCase())
        ];
        
        const tokenId = tokenIds[0] ? tokenIds[0] : tokenIds[1];
        const side = tokenIds[0] ? 0 : 1;

        if (!tokenId) {
            continue;
        } else if (balances[tokenId[0]]) {
            balances[tokenId[0]] = Number(balances[tokenId[0]]) 
                + Number(reserves[n].output[side]) * 2 / 10**tokenId[1];
        } else {
            balances[tokenId[0]] =
                reserves[n].output[side] * 2 / 10**tokenId[1];
        };
    };
    return balances;
};

function getTokenId(address) {
    switch(address) {
        case '0x98878b06940ae243284ca214f92bb71a2b032b8a':
            return ['moonriver', 18]
        case '0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d':
            return ['usd-coin', 6]
        case '0xb44a9b6905af7c801311e8f4e76932ee959c663c':
            return ['tether', 6]
        case '0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c':
            return ['ethereum', 18]
        case '0x5d9ab5522c64e1f6ef5e3627eccc093f56167818':
            return ['binance-usd', 18]
        default:
            return false;
    };
};
// node test.js projects/moonswap/index.js
module.exports = {
    misrepresentedTokens: true,
    tvl,
    methodology: 'tvl is calculated by summing the value of moonswap pools that contain at least one of MOVR, USDC, USDT, ETH and BUSD. This is read from the blockchain, accounts for most of the value locked in the AMM, and was done because these tokens can be valued on CoinGecko. Currently, staking is not counted due to most moonriver tokens being difficult to value in USD.'
  };
'''
'''--- projects/moonwell-artemis/index.js ---
const { usdCompoundExports } = require('../helper/compound')
const { staking } = require('../helper/staking');

const moonbeamConfig = {
  comptroller: "0x8E00D5e02E65A19337Cdba98bbA9F84d4186a180",
  chain: "moonbeam",
  nativeTokenMarket: "0x091608f4e4a15335145be0A279483C0f8E4c7955",

  stakingContract: "0x8568A675384d761f36eC269D695d6Ce4423cfaB1",
  stakingTokenAddress: "0x511aB53F793683763E5a8829738301368a2411E3"
}

// Moonbeam 
const moonbeamTVL = usdCompoundExports(
  moonbeamConfig.comptroller,
  moonbeamConfig.chain,
  moonbeamConfig.nativeTokenMarket,
)

const moonbeamStaking = staking(moonbeamConfig.stakingContract, moonbeamConfig.stakingTokenAddress, 'moonbeam')

module.exports = {
  moonbeam: { ...moonbeamTVL, staking: moonbeamStaking, },
}
'''
'''--- projects/moonwell/index.js ---
const { usdCompoundExports } = require('../helper/compound')
const { staking } = require('../helper/staking');

const moonriverConfig = {
  comptroller: "0x0b7a0EAA884849c6Af7a129e899536dDDcA4905E",
  chain: "moonriver",
  nativeTokenMarket: "0x6a1A771C7826596652daDC9145fEAaE62b1cd07f",

  stakingContract: "0xCd76e63f3AbFA864c53b4B98F57c1aA6539FDa3a",
  stakingTokenAddress: "0xBb8d88bcD9749636BC4D2bE22aaC4Bb3B01A58F1"
}

// Moonriver
const moonriverTVL = usdCompoundExports(
  moonriverConfig.comptroller,
  moonriverConfig.chain,
  moonriverConfig.nativeTokenMarket,
)

const moonriverStaking = staking(moonriverConfig.stakingContract, moonriverConfig.stakingTokenAddress, 'moonriver')

module.exports = {
  moonriver: { ...moonriverTVL, staking: moonriverStaking, },
}
'''
'''--- projects/moremoney/IStrategy.json ---
{
  "abi": [
    {
      "inputs": [],
      "name": "viewAllApprovedTokens",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }]
}

'''
'''--- projects/moremoney/StrategyRegistry.json ---
{
  "abi": [{
    "inputs": [],
    "name": "allEnabledStrategies",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  } ]}

'''
'''--- projects/moremoney/StrategyViewer.json ---
{
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "lendingContract",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "oracleRegistry",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stable",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "strategies",
          "type": "address[]"
        }
      ],
      "name": "viewMetadataNoHarvestBalance",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "debtCeiling",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalDebt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stabilityFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "mintingFee",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "strategy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "APF",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalCollateral",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowablePer10k",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "valuePer1e18",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "strategyName",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tvl",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "harvestBalance2Tally",
              "type": "uint256"
            },
            {
              "internalType": "enum IStrategy.YieldType",
              "name": "yieldType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "underlyingStrategy",
              "type": "address"
            }
          ],
          "internalType": "struct StableLending.ILStrategyMetadata[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ]
}

'''
'''--- projects/moremoney/addresses.json ---
{
  "31337": {
    "AMMYieldConverter": "0x9025B317Ce8eAd9bD5C4934BcEef7309D8e8Aa86",
    "AlphaNftLending": "0x0E347D2Fc846b6Db66A1fE1c41cf92D8440097Bd",
    "ChainlinkOracle": "0x3Dc65b58ad56309349f9494eD8d920870aaa8c5B",
    "ContractManagement": "0x9fbdeb7249cC9D35E632591635615301688b4255",
    "CurveLPTOracle": "0xC1397F94587c6fE5946a20F3D74DBb02bb175e14",
    "CurvePool": "0xb3F21Fc59Bc06209D5fb82c474F21582AEf09a20",
    "CurvePoolRewards": "0x9727D535165e19590013bdDea8Fd85dd618b9aF7",
    "CurvePoolSL": "0xb0B057e998f7D3B38A2bC5e2dCBC97da14d47f54",
    "DependencyController": "0x8341978C376C293B3380a8921257D26ec31efEaF",
    "DirectFlashLiquidation": "0x4F6348543aD4311eAC349ED10B4b98b3EBA3038b",
    "DirectFlashStableLiquidation": "0x9F0714b64886289Be1569fb202E0D9a4c63A439D",
    "EquivalentScaledOracle": "0x8B7F12D8ba9BC81DAdDE3bf6e97B020AB2a8B82D",
    "IsolatedLending": "0xDc5CCAAA928De5D318605A76eEDE50f205Aa6D93",
    "IsolatedLendingLiquidation": "0x9A641E87c60472D90F9A7e2e60e006bE66408B6F",
    "LPTFlashLiquidation": "0x1a7C7c40c3E76AB44D5a9C552f223102526cedDD",
    "LPTFlashStableLiquidation": "0xb380874f3Aeec4ABe8a8A6E6F153f8f0a0023B4a",
    "MoreToken": "0xd9D90f882CDdD6063959A9d837B05Cb748718A05",
    "OracleActivation": "0x17fbcF5fbC62815f1cBA6F906C8AFae3f95f2d73",
    "OracleRegistry": "0x567Cf1675F5cb3c0457B35753d76e83E37CDBe96",
    "PangolinMiniChefStrategy": "0xDFa3bCda5f954A1E6CEF247bDfA89F15702a7473",
    "ProxyOracle": "0x056e2711C2F6A21563AaFA2F9AC8E8eC114b2B4b",
    "Roles": "0x9e1EE00d45252aA58623F7d771FB414aA38f0878",
    "SimpleHoldingStrategy": "0x21C971D78E1A398710d964Ed1AC4C80E5940ed25",
    "StableLending": "0x23082269Ea17C4f5103bAB6cD9DFE1f6CE138616",
    "StableLendingLiquidation": "0xB9961f2E9C9Caa52AaBdf83ADC1Ca0AD9A2DeC4f",
    "Stablecoin": "0x0f577433Bf59560Ef2a79c124E9Ff99fCa258948",
    "StrategyRegistry": "0x5C836f816732F064D6e985D8e38f4f78d594716e",
    "StrategyTokenActivation": "0xc97dcB37592302d9f75c7Ab3CE5F4BCc989B8f85",
    "StrategyViewer": "0x079126585b0a96fD0A76B45B59be0c54F93b6424",
    "TokenActivation": "0xD9A892075eff9a68b26Bc65bc4670c26C23ba5Cd",
    "TraderJoeMasterChef2Strategy": "0x10d71115360F9129623096E8108bC6856cf86D3A",
    "TraderJoeMasterChefStrategy": "0x0Db20d1643112fA00C4D3DDB58369Ad26c1F7c1d",
    "TrancheIDService": "0xc83f27c0180e8e29419f4Cab189c3529a2A3Fa8a",
    "TwapOracle": "0x4220a06bd4d15b4C3d1f3419AB2Ac8E4768b82B6",
    "UniswapV2LPTOracle": "0x3b825168716D79A656BB48Cb7Ae64fcB3bc32203",
    "VestingLaunchReward": "0x95dd4B039220D18FE41148786bde934a14c5e9CD",
    "VestingMoreToken": "0xba8983FdDe65354C1330E38D042C7d2F784cA3de",
    "WrapNativeIsolatedLending": "0xdA68388619Ca4ddC09e4d59B1BE2971A0DCd2Bad",
    "WrapNativeStableLending": "0xa89AE9FBa2e279e576e770C485a7D4cE1e3b8781",
    "WrapperTokenOracle": "0x575a21B34DFE94e46734252fEE17b5803538e905",
    "WsMAXIOracle": "0x5D1744D2e7C36f4BBDFB4Cb8D7D0E87794A15144",
    "YieldYakAVAXStrategy": "0xaa3Ea561a656cbE310F2E10981085DA2D989f17e",
    "YieldYakStrategy": "0x888fC8d90177a4097e196EF6BBDc7d2e8CfFDb17",
    "wsMAXIStableLiquidation": "0xA1D4Ec7f802CDE59f6ae1a986E7382593558F8FC",
    "xJoeStableLiquidation": "0xab3E6e4011B76346099520DA87ab08903929B59F",
    "xMore": "0xaEcf69a09369Db3556177484298d6348c7cf9a7f"
  },
  "43114": {
    "AMMYieldConverter": "0x9025B317Ce8eAd9bD5C4934BcEef7309D8e8Aa86",
    "AlphaNftLending": "0x0E347D2Fc846b6Db66A1fE1c41cf92D8440097Bd",
    "ChainlinkOracle": "0x3Dc65b58ad56309349f9494eD8d920870aaa8c5B",
    "ContractManagement": "0x9fbdeb7249cC9D35E632591635615301688b4255",
    "CurveLPTOracle": "0xC1397F94587c6fE5946a20F3D74DBb02bb175e14",
    "CurvePool": "0xb3F21Fc59Bc06209D5fb82c474F21582AEf09a20",
    "CurvePoolRewards": "0x9727D535165e19590013bdDea8Fd85dd618b9aF7",
    "CurvePoolSL": "0xb0B057e998f7D3B38A2bC5e2dCBC97da14d47f54",
    "DependencyController": "0x8341978C376C293B3380a8921257D26ec31efEaF",
    "DirectFlashLiquidation": "0x4F6348543aD4311eAC349ED10B4b98b3EBA3038b",
    "DirectFlashStableLiquidation": "0x9F0714b64886289Be1569fb202E0D9a4c63A439D",
    "EquivalentScaledOracle": "0x8B7F12D8ba9BC81DAdDE3bf6e97B020AB2a8B82D",
    "IsolatedLending": "0xDc5CCAAA928De5D318605A76eEDE50f205Aa6D93",
    "IsolatedLendingLiquidation": "0x9A641E87c60472D90F9A7e2e60e006bE66408B6F",
    "LPTFlashLiquidation": "0x1a7C7c40c3E76AB44D5a9C552f223102526cedDD",
    "LPTFlashStableLiquidation": "0xb380874f3Aeec4ABe8a8A6E6F153f8f0a0023B4a",
    "MoreToken": "0xd9D90f882CDdD6063959A9d837B05Cb748718A05",
    "OracleActivation": "0x17fbcF5fbC62815f1cBA6F906C8AFae3f95f2d73",
    "OracleRegistry": "0x567Cf1675F5cb3c0457B35753d76e83E37CDBe96",
    "PangolinMiniChefStrategy": "0xDFa3bCda5f954A1E6CEF247bDfA89F15702a7473",
    "ProxyOracle": "0x056e2711C2F6A21563AaFA2F9AC8E8eC114b2B4b",
    "Roles": "0x9e1EE00d45252aA58623F7d771FB414aA38f0878",
    "SimpleHoldingStrategy": "0x21C971D78E1A398710d964Ed1AC4C80E5940ed25",
    "StableLending": "0x23082269Ea17C4f5103bAB6cD9DFE1f6CE138616",
    "StableLendingLiquidation": "0xB9961f2E9C9Caa52AaBdf83ADC1Ca0AD9A2DeC4f",
    "Stablecoin": "0x0f577433Bf59560Ef2a79c124E9Ff99fCa258948",
    "StrategyRegistry": "0x5C836f816732F064D6e985D8e38f4f78d594716e",
    "StrategyTokenActivation": "0xD6C4Ba1aa5a41fA94a70208669873F56Ff6d3461",
    "StrategyViewer": "0x079126585b0a96fD0A76B45B59be0c54F93b6424",
    "TokenActivation": "0xD9A892075eff9a68b26Bc65bc4670c26C23ba5Cd",
    "TraderJoeMasterChef2Strategy": "0x10d71115360F9129623096E8108bC6856cf86D3A",
    "TraderJoeMasterChefStrategy": "0x0Db20d1643112fA00C4D3DDB58369Ad26c1F7c1d",
    "TrancheIDService": "0xc83f27c0180e8e29419f4Cab189c3529a2A3Fa8a",
    "TwapOracle": "0x4220a06bd4d15b4C3d1f3419AB2Ac8E4768b82B6",
    "UniswapV2LPTOracle": "0x3b825168716D79A656BB48Cb7Ae64fcB3bc32203",
    "VestingLaunchReward": "0x95dd4B039220D18FE41148786bde934a14c5e9CD",
    "VestingMoreToken": "0xba8983FdDe65354C1330E38D042C7d2F784cA3de",
    "WrapNativeIsolatedLending": "0xdA68388619Ca4ddC09e4d59B1BE2971A0DCd2Bad",
    "WrapNativeStableLending": "0xa89AE9FBa2e279e576e770C485a7D4cE1e3b8781",
    "WrapperTokenOracle": "0x575a21B34DFE94e46734252fEE17b5803538e905",
    "WsMAXIOracle": "0x5D1744D2e7C36f4BBDFB4Cb8D7D0E87794A15144",
    "YieldYakAVAXStrategy": "0xaa3Ea561a656cbE310F2E10981085DA2D989f17e",
    "YieldYakStrategy": "0x888fC8d90177a4097e196EF6BBDc7d2e8CfFDb17",
    "wsMAXIStableLiquidation": "0xA76182BDe886422655D24fd8f26AA0370d63DFEC",
    "xJoeStableLiquidation": "0xab3E6e4011B76346099520DA87ab08903929B59F",
    "xMore": "0xaEcf69a09369Db3556177484298d6348c7cf9a7f"
  }
}
'''
'''--- projects/moremoney/index.js ---
const sdk = require("@defillama/sdk");
const { ethers } = require("ethers");
const { getProvider } = require("@defillama/sdk/build/general");

const CurvePoolRewards = "0x9727D535165e19590013bdDea8Fd85dd618b9aF7";
const account = "0x0000000000000000000000000000000000000000";
const methodology = "";
const BigNumber = require("bignumber.js");
const addresses = require("./addresses.json");
const StrategyViewer = require("./StrategyViewer.json");
const StrategyRegistry = require("./StrategyRegistry.json");
const IStrategy = require("./IStrategy.json");

function useAddresses() {
  return addresses[43114];
}

async function tvl(timestamp, block) {
  const addresses = useAddresses();
  const provider = getProvider('avax');

  const stratRegistry = new ethers.Contract(
    addresses.StrategyRegistry,
    StrategyRegistry.abi,
    provider
  );

  const stratViewer = new ethers.Contract(
    addresses.StrategyViewer,
    StrategyViewer.abi,
    provider
  );

  const enabledStrategies = await stratRegistry.allEnabledStrategies();

  const approvedTokens = await Promise.all(
    enabledStrategies.map((address) => {
      const contract = new ethers.Contract(address, IStrategy.abi, provider);
      return contract.viewAllApprovedTokens();
    })
  );
  let token2Strat2 = {};

  for (let i = 0; i < enabledStrategies.length; i++) {
    const strategy = enabledStrategies[i];
    const tokens = approvedTokens[i];
    for (let j = 0; j < tokens.length; j++) {
      if (token2Strat2[tokens[j]] == undefined) {
        token2Strat2[tokens[j]] = strategy;
      }
    }
  }

  const tokens = Object.keys(token2Strat2);
  const strats = Object.values(token2Strat2);

  const noHarvestBalanceResults =
    await stratViewer.viewMetadataNoHarvestBalance(
      addresses.StableLending,
      addresses.OracleRegistry,
      addresses.Stablecoin,
      tokens,
      strats
    );

  const stratMeta = [...noHarvestBalanceResults];
  const stakingMeta = (
    await sdk.api.abi.call({
      target: CurvePoolRewards,
      block,
      chain: "avax",
      params: [account],
      abi: {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address",
          },
        ],
        name: "stakingMetadata",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "stakingToken",
                type: "address",
              },
              {
                internalType: "address",
                name: "rewardsToken",
                type: "address",
              },
              {
                internalType: "uint256",
                name: "totalSupply",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "tvl",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "aprPer10k",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "vestingCliff",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "periodFinish",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "stakedBalance",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "vestingStart",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "earned",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "rewards",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "vested",
                type: "uint256",
              },
            ],
            internalType: "struct VestingStakingRewards.StakingMetadata",
            name: "",
            type: "tuple",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
    })
  ).output;

  const tokensMeta = Object.values(stratMeta).map((strat) => {
    return strat.token;
  });
  const decimals = await Promise.all(
    tokensMeta.map((token) => {
      return sdk.api.erc20.decimals(token, "avax");
    })
  );

  const tokenList = [
    tokensMeta.map((token, index) => {
      return { address: token, decimals: decimals[index].output };
    }),
  ];

  const tvlsFarm = stakingMeta.tvl;

  const tvlNoFarm = Object.values(stratMeta)
    .map((row) => {
      let decimals = tokenList.filter((t) => t.address === row.token)[0]
        ?.decimals;
      const trueOne = ethers.utils.parseUnits("1", decimals);
      const valPerOne = trueOne
        .mul(row.valuePer1e18)
        .div(ethers.utils.parseEther("1"));
      return {
        ...row,
        tvlInPeg: row.tvl.mul(valPerOne).div(trueOne),
      };
    })
    .reduce((tvl, row) => {
      return tvl.plus(row.tvlInPeg.toString());
    }, BigNumber(0));
  const tvl = tvlNoFarm.plus(tvlsFarm);
  return {
    "avax:0xd586e7f844cea2f87f50152665bcbc2c279d8d70": tvl.toFixed(0),
  };
}

module.exports = {
  methodology: methodology,
  avalanche: {
    tvl,
  },
};

'''
'''--- projects/morpheusswap/abi.json ---
{
  "poolInfo": {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "poolInfo",
    "outputs": [
      {
        "internalType": "contract IBEP20",
        "name": "lpToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allocPoint",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "lastRewardTimestamp",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "accMorphPerShare",
        "type": "uint256"
      },
      {
				"internalType": "uint16",
				"name": "depositFeeBP",
				"type": "uint16"
			},
			{
				"internalType": "uint256",
				"name": "lpSupply",
				"type": "uint256"
			}
    ],
    "stateMutability": "view",
    "type": "function"
  },
  "poolLength": {
    "inputs": [],
    "name": "poolLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/morpheusswap/index.js ---
const abi = require("./abi.json");
const { calculateUsdUniTvl } = require("../helper/getUsdUniTvl");
const { addFundsInMasterChef } = require("../helper/masterchef");
const { stakings } = require("../helper/staking");
const sdk = require('@defillama/sdk')

const chef = "0xc7dad2e953Dc7b11474151134737A007049f576E"
const morph = "0x0789ff5ba37f72abc4d561d00648acadc897b32d"

async function tvl(timestamp, block, chainBlocks) {
  const balances = {}
  const transformAddress = addr=>`fantom:${addr}` //await transformFantomAddress();
  if(chainBlocks.fantom<21182441){ // Factory deployment block
    await addFundsInMasterChef(balances, chef, chainBlocks.fantom, "fantom", transformAddress, abi.poolInfo, [morph])
  } else {
    const dexTvl = calculateUsdUniTvl("0x9C454510848906FDDc846607E4baa27Ca999FBB6", "fantom", "0x82f0b8b456c1a451378467398982d4834b6829c1", [
      "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83"
    ], "magic-internet-money", 18, true)
    return dexTvl(timestamp, block, chainBlocks);
  }
  return balances;
}

module.exports = {
  methodology: "TVL includes all farms in MasterChef contract, as well as staking pools.",
  fantom: {
    tvl,
    staking: stakings(["0x7A93C6dDEbc2089F6D5bcccF1025d6D0E31d4DA4", "0x47775F72E8bfa98dE4613db6cD4b5772aC4aBEC8", "0x5406566EDCD5B108212Bb69382a8869D761E738E", "0xdf3A3D03a92F54f8859355924f4581443B80C714", "0x7373E5b59bf20345b0D452f9a294A51429ca1F9b", "0x9bd3dACe24745Eb117c1F7f93AAEC5e37333c079", "0x7928de9d6DB88280DBa4613864a518A98F32D342", "0xaDb29fBBb9962Fe643676e2433114F0446923221", "0x60131EC5BE073F1c34A9b506ce30eA7aAC7eed15", "0x62CfcABA772e90F743990A8bcEDAC04AbBF7E75f", 
                       "0x7E01c21789DEF6572E31Ab6c67A4182E0808428B", "0x2D5F05D8e578397889f5F5C88d8e3b81D8a6f865", "0x578fb737cf5F3814Ddd80Cd6a7b4FFF9504c0c39", "0xb6bA5d27b00c2E62e32c0716D7c6505463cFBbf2", "0xb31bF9a835584d18595d886D35157467576A76e8", "0xde1592f643F9c77f186970daa43D3cAB22C0fd22", "0xeF5627d8B7BC8102E0C9760F62E0c5b0b7F38AF6", "0x80da05De8B759B7A9399F43C04A859cC0eaA24AC", "0x983A4dA9E8baC8b8F2F04B161968906B780f3629", "0x63AD93bAb2842Fefec06630b9ddC7A2351D7cb91",
                       "0x616a0030688329b4FaaFda8Cf469f1899e58cBfC", "0x94005434C078e9d8cC23fF4b5D88FC9bc7c0E1A5", "0xc948EaD0069adc742539c7D6e038CD132010513D", "0x5D29690d7e9f4216dFE3F15C0A2db828D25e9aD5", "0x3BEef19946b0595621650793d45C1cb06e9F810a", "0x913473eaF564e3982E9fFb6D5c559E2adb669D61", "0xA75C807d43F75806DFbDd1f302C7F388E610Be87", "0x40F4F6473F39882645237f39900fc15C2E8dd56c", "0xC60044503dA0C800DEE0577f294862Fc1c1Aca1B", "0x04f429bBFa7032a046F24466F835284351Cef5E4",
                       "0xbC4f8A55fc3Aba02dA4E18aA66E9176EA476468D", "0xF6d428f7ee882C0bdd43AA060c69f35874609B9f", "0x23308c96cF9f46Fa6D7Ee714B960780551d35E16", "0x11d7A542ad2E12Bd0C033C85aeF6FB891CD92690", "0xc8C017674fb54F5F25f05AC0981116715465254A", "0xCCA9F9E68F7E7e1BE97DA2Ff91B016c234a13c88", "0xA431fDd6d23f0d7C4b4B92F4aD866a5939b53abB", "0x326A7D91B6F767458599E7d93DFc850d2e083d30", "0x5bCb5f2ed10aC292C9E281C5eAD4F0533666c3b6"], "0xB66b5D38E183De42F21e92aBcAF3c712dd5d6286", "fantom")
  }
}

'''
'''--- projects/mover/abi.json ---
{
    "inceptionLPPriceUSDC": {
        "inputs": [],
        "name": "inceptionLPPriceUSDC",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "lpTokensBalance": {
        "inputs": [],
        "name": "lpTokensBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/mover/baseLedgerPoolAbi.json ---
{
  "totalAssetAmount": {
    "inputs": [],
    "name": "totalAssetAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/mover/index.js ---
const sdk = require("@defillama/sdk");
const baseLedgerAbi = require("./baseLedgerPoolAbi.json");
const savingsPoolAbi = require("./savingsPoolAbi.json");
const savingsPlusPoolAbi = require("./savingsPlusPoolAbi.json");

const { staking } = require("../helper/staking");
const { pool2 } = require("../helper/pool2");
const { transformPolygonAddress } = require('../helper/portedTokens');

const treasuryContract = "0x94F748BfD1483750a7dF01aCD993213Ab64C960F";
const MOVER = "0x3FA729B4548beCBAd4EaB6EF18413470e6D5324C";
const MOVER_WETH_SLP = "0x87b918e76c92818DB0c76a4E174447aeE6E6D23f";

const savingsPool = "0xAF985437DCA19DEFf89e61F83Cd526b272523719";
const savingsPlusPolygonPool = "0x77D5333d97A092cA01A783468E53E550C379dc3C";
const USDC = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const USDCinPolygon = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174";
const baseLedgerPool = '0x1f15F293C1Cd3d05d58d3EdeAf0C72c5A2dfeaFf';
const UBT = '0x8400D94A5cb0fa0D041a3788e395285d61c9ee5e';

async function tvlEth(timestamp, block) {
  const balances = {};

  let stakedUBT = (await sdk.api.abi.call({
    abi: baseLedgerAbi.totalAssetAmount,
    target: baseLedgerPool,
    block
  })).output;

  sdk.util.sumSingleBalance(balances, UBT, stakedUBT);

  let savingsStakedUSDC = (await sdk.api.abi.call({
    abi: savingsPoolAbi.totalAssetAmount,
    target: savingsPool,
    block
  })).output;

  sdk.util.sumSingleBalance(balances, USDC, savingsStakedUSDC);
  return balances;
}

async function tvlPolygon(timestamp, block, chainBlocks) {
  const balances = {};
  const transform = await transformPolygonAddress();

  let savingsPlusStakedUSDC = (await sdk.api.abi.call({
    chain: "polygon",
    abi: savingsPlusPoolAbi.totalAssetAmount,
    target: savingsPlusPolygonPool,
    block: chainBlocks["polygon"],
  })).output;

  sdk.util.sumSingleBalance(balances, transform(USDCinPolygon), savingsPlusStakedUSDC);
  return balances;
}

module.exports = {
  ethereum: {
    staking: staking(treasuryContract, MOVER),
    pool2: pool2(treasuryContract, MOVER_WETH_SLP),
    tvl: tvlEth,
  },
  polygon: {
    tvl: tvlPolygon
  },
  methodology:
    "Counts tvl of the Assets deposited through get total assets methods of pools; also the Staking and Pool2 parts through Treasury Contract",
};

'''
'''--- projects/mover/savingsPlusPoolAbi.json ---
{
  "totalAssetAmount": {
    "inputs": [],
    "name": "totalAssetAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/mover/savingsPoolAbi.json ---
{
  "totalAssetAmount": {
    "inputs": [],
    "name": "totalAssetAmount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/mstable/abi-massetv1.json ---
{
  "getBassets": {
    "constant": true,
    "inputs": [],
    "name": "getBassets",
    "outputs": [{
        "components": [{
            "internalType": "address",
            "name": "addr",
            "type": "address"
          },
          {
            "internalType": "enum MassetStructs.BassetStatus",
            "name": "status",
            "type": "uint8"
          },
          {
            "internalType": "bool",
            "name": "isTransferFeeCharged",
            "type": "bool"
          },
          {
            "internalType": "uint256",
            "name": "ratio",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "maxWeight",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "vaultBalance",
            "type": "uint256"
          }
        ],
        "internalType": "struct MassetStructs.Basset[]",
        "name": "bAssets",
        "type": "tuple[]"
      },
      {
        "internalType": "uint256",
        "name": "len",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
}

'''
'''--- projects/mstable/abi-massetv2.json ---
{
  "getBassets": {

    "inputs": [],
    "name": "getBassets",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "addr",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "integrator",
            "type": "address"
          },
          {
            "internalType": "bool",
            "name": "hasTxFee",
            "type": "bool"
          },
          {
            "internalType": "enum MassetStructs.BassetStatus",
            "name": "status",
            "type": "uint8"
          }
        ],
        "internalType": "struct MassetStructs.BassetPersonal[]",
        "name": "personal",
        "type": "tuple[]"
      },
      {
        "components": [
          {
            "internalType": "uint128",
            "name": "ratio",
            "type": "uint128"
          },
          {
            "internalType": "uint128",
            "name": "vaultBalance",
            "type": "uint128"
          }
        ],
        "internalType": "struct MassetStructs.BassetData[]",
        "name": "data",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
}
'''
'''--- projects/mstable/index.js ---
const sdk = require('@defillama/sdk');

const MASSET_ABI_V2 = require('./abi-massetv2.json');

const ASSETS = {
  ethereum: [
    {
      // mUSD
      address: '0xe2f2a5c287993345a840db3b0845fbc70f5935a5',
      startBlock: 10148032,
      isMasset: true,
    },
    {
      // mBTC
      address: '0x945facb997494cc2570096c74b5f66a3507330a1',
      startBlock: 11840521,
      isMasset: true,
    },
    {
      // fPmBTC/HBTC
      address: '0x48c59199da51b7e30ea200a74ea07974e62c4ba7',
      startBlock: 12146645,
    },
    {
      // fPmBTC/TBTC
      address: '0xb61a6f928b3f069a68469ddb670f20eeeb4921e0',
      startBlock: 12146645,
    },
    {
      // fPmBTC/tBTCv2
      address: '0xc3280306b6218031E61752d060b091278d45c329',
      startBlock: 13460377,
    },
    {
      // fPmUSD/BUSD
      address: '0xfe842e95f8911dcc21c943a1daa4bd641a1381c6',
      startBlock: 12146707,
    },
    {
      // fPmUSD/GUSD
      address: '0x4fb30c5a3ac8e85bc32785518633303c4590752d',
      startBlock: 12146745,
    },
    {
      // fPmUSD/alUSD
      address: '0x4eaa01974b6594c0ee62ffd7fee56cf11e6af936',
      startBlock: 12806795,
    },
        {
      // fPmUSD/RAI
      address: '0x36F944B7312EAc89381BD78326Df9C84691D8A5B',
      startBlock: 13643595,
    },
    {
      // fPmUSD/FEI
      address: '0x2F1423D27f9B20058d9D1843E342726fDF985Eb4',
      startBlock: 13682060,
    },
  ],
  polygon: [
    {
      // mUSD
      address: '0xe840b73e5287865eec17d250bfb1536704b43b21',
      startBlock: 13630640,
      isMasset: true,
    },
    {
      // fpmUSD/FRAX
      address: '0xb30a907084ac8a0d25dddab4e364827406fd09f0',
      startBlock: 16099014,
    },
  ],
};

const OWN_ASSETS = new Set([
  '0xe2f2a5c287993345a840db3b0845fbc70f5935a5', // Ethereum mUSD
  '0x945facb997494cc2570096c74b5f66a3507330a1', // Ethereum mBTC
  '0xe840b73e5287865eec17d250bfb1536704b43b21', // Polygon mUSD
]);

async function getLockedForAsset(chain, asset, block) {
  const { output: { personal, data } } = await sdk.api.abi.call({
    chain,
    target: asset.address,
    block,
    abi: MASSET_ABI_V2.getBassets,
  });

  return personal.reduce(
    (lockedTokens, [address], i) => ({ ...lockedTokens, [address]: data[i][1] }),
    {},
  )
}

function tvlForChain(chain) {
  const assets = ASSETS[chain]
  const isEthereum = chain === 'ethereum'

  return async function tvl(timestamp, ethBlock, chainBlocks) {
    const block = isEthereum ? ethBlock : chainBlocks[chain];

    const assetBalances = await Promise.all(
      assets
        .filter(({ startBlock }) => block > startBlock)
        .map((asset) => getLockedForAsset(chain, asset, block))
    );

    const lockedBalances = {};

    assetBalances
      .forEach((locked) => Object.entries(locked)
        // No double-dipping; avoid double-counting mAssets
        .filter(([underlying]) => !OWN_ASSETS.has(underlying.toLowerCase()))
        .map(([underlying, balance]) => (
          [isEthereum ? underlying : `${chain}:${underlying}`, balance]
        ))
        .forEach(([address, balance]) =>
          sdk.util.sumSingleBalance(lockedBalances, address, balance)
        )
      );

    return lockedBalances;
  }
}

const ethereumTvl = tvlForChain('ethereum')
const polygonTvl = tvlForChain('polygon')

module.exports = {
  start: 1590624000, // May-28-2020 00:00:00
  polygon: {
    tvl: polygonTvl,
  },
  ethereum: {
    tvl: ethereumTvl,
  },
};

'''
'''--- projects/mtgo/index.js ---
const { getBlock } = require("../helper/getBlock");
const {
    sumLPWithOnlyOneTokenOtherThanKnown,
} = require("./../helper/unwrapLPs");

const lpToken = "0x2a382b6d2dac1cba6e4820fd04e3c2c14e1aa7b2";
const treasuryAddress = "0xdE2957506B6dC883963fbE9cE45a94a8A22c6006";
const mtgoToken = "0x1bc8547e3716680117d7ba26dcf07f2ed9162cd0";
const poolAddress = "0x1781d2e9b4c7c0a3657411a64d2c1dfc50118772";
const wiotx = "0xA00744882684C3e4747faEFD68D283eA44099D03";
const erc20Tokens = [
  ["0x1bc8547e3716680117d7ba26dcf07f2ed9162cd0", false], // MTGO
];

async function iotexPool2(timestamp, block, chainBlocks) {
  block = await getBlock(timestamp, "iotex", chainBlocks);
  const balances = {};
  await sumLPWithOnlyOneTokenOtherThanKnown(
    balances,
    lpToken,
    poolAddress,
    mtgoToken,
    block,
    "iotex"
  );
  return { iotex: (balances[wiotx] / 10 ** 18) };
}

async function treasury(timestamp, block, chainBlocks) {

  block = await getBlock(timestamp, "iotex", chainBlocks);
  const balances = {};
  await sumLPWithOnlyOneTokenOtherThanKnown(
    balances,
    lpToken,
    treasuryAddress,
    mtgoToken,
    block,
    "iotex"
  );
  return { iotex: (balances[wiotx] / 10 ** 18) };
}

module.exports = {
  iotex: {
    tvl: async () => ({}),
    pool2: iotexPool2,
    treasury,
  },
};

'''
'''--- projects/muesliswap/index.js ---
const {calculateUsdUniTvl} = require('../helper/getUsdUniTvl')
const { stakingPricedLP } = require('../helper/staking')
const { fetchURL } = require('../helper/utils')

async function staking(){
    const tvl = await fetchURL("https://staking.muesliswap.com/milk-locked")
    if(tvl.data<=0){
        throw new Error("muesliswap tvl is below 0")
    }
    const orders = (await fetchURL(`https://orders.muesliswap.com/orderbook/?policy-id=8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa&tokenname=MILK`)).data
    if(orders.fromToken !== "."){
        throw new Error("Tokens paired against something other than ADA")
    }
    const topPrice = orders.buy[0].price
    return {
        cardano: tvl.data * topPrice
    }
}

async function adaTvl(){
    const tokens = (await fetchURL("https://orders.muesliswap.com/known-tokens")).data
    let totalAda = 0
    await Promise.all(tokens.map(async t=>{
        const policyId = t.address.split(".")[0];
        const tokenname = t.address.split(".")[1];
        const orders = (await fetchURL(`https://orders.muesliswap.com/orderbook/?policy-id=${policyId}&tokenname=${encodeURIComponent(tokenname)}`)).data
        if(orders.fromToken !== "."){
            throw new Error("Tokens paired against something other than ADA")
        }
        let totalBuy= 0;
        orders.buy.forEach(o=>{
            totalBuy += o.totalPrice
        })
        if(orders.buy.length === 0 || orders.sell.length === 0){
            return
        }
        const topPrice = orders.buy[0].price
        let totalAmountOtherToken = 0
        orders.sell.forEach(o=>{
            totalAmountOtherToken += o.amount
        })
        const totalSell = totalAmountOtherToken * topPrice
        totalAda += totalBuy + totalSell
    }))
    const orderbooksv2 = (await fetchURL("https://pools.muesliswap.com/all-orderbooks")).data
    await Promise.all(orderbooksv2.map(async orders=>{
        if(orders.fromToken !== "."){
            throw new Error("Tokens paired against something other than ADA")
        }
        let totalBuy= 0;
        orders.buy.forEach(o=>{
            totalBuy += (o.totalLvl / 1e6)
        })
        if(orders.buy.length === 0 || orders.sell.length === 0){
            return
        }
        const topPrice = (orders.buy[0].lvlPerToken / 1e6)
        let totalAmountOtherToken = 0
        orders.sell.forEach(o=>{
            totalAmountOtherToken += o.amount
        })
        const totalSell = totalAmountOtherToken * topPrice
        totalAda += totalBuy + totalSell
    }))
    return {
        cardano: totalAda
    }
}

module.exports={
    misrepresentedTokens: true,
    timetravel: false,
    methodology: "The factory addresses are used to find the LP pairs on Smart BCH and Milkomeda. For Cardano we calculate the tokens on resting orders on the order book contracts. TVL is equal to the liquidity on the AMM plus the open orders in the order book",
    smartbch: {
        tvl:calculateUsdUniTvl("0x72cd8c0B5169Ff1f337E2b8F5b121f8510b52117", "smartbch", "0x3743eC0673453E5009310C727Ba4eaF7b3a1cc04", ["0xc8E09AEdB3c949a875e1FD571dC4b3E48FB221f0"], "bitcoin-cash"),
        staking: stakingPricedLP("0x4856BB1a11AF5514dAA0B0DC8Ca630671eA9bf56", "0xc8E09AEdB3c949a875e1FD571dC4b3E48FB221f0", "smartbch", "0x599061437d8455df1f86d401FCC2211baaBC632D", "bitcoin-cash", false, 18)
    },
    cardano:{
        tvl: adaTvl,
        staking
    },
    milkomeda: {
        tvl: calculateUsdUniTvl(
            '0x57A8C24B2B0707478f91D3233A264eD77149D408',
            'milkomeda',
            '0xAE83571000aF4499798d1e3b0fA0070EB3A3E3F9',
            [
                '0x80A16016cC4A2E6a2CACA8a4a498b1699fF0f844', //TETHER
                '0xb44a9b6905af7c801311e8f4e76932ee959c663c', //USDC
                '0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D', //ETH
                '0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c', //ceETH
                '0x65e66a61D0a8F1e686C2D6083ad611a10D84D97A', //AVAX
                '0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8', //BTC
                '0x7f27352D5F83Db87a5A3E00f4B07Cc2138D8ee52', //BNB
            ],
            'cardano'
        )
    }
}

'''
'''--- projects/multichainMiner.js ---
const sdk = require("@defillama/sdk");
const { transformBscAddress, transformPolygonAddress, transformFantomAddress, 
    transformAvaxAddress } = require("./helper/portedTokens");

const minedTokens = {
    'cake': '0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82',
    'busd': '0xe9e7cea3dedca5984780bafc599bd69add087d56',
    'matic': '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270',
    'ftm': '0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83',
    'avax': '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7',
    'usdc': '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // polygon
    'doge': '0xba2ae424d960c26247dd6c32edc70b295c744c43', // bsc
    'eth': '0x2170ed0880ac9a755fd29b2688956bd959f933f8'   // bsc
};
const minerContracts = {
    'cake': '0xD5d38f1815b4555527DE075a584268E08c5909EA',
    'busd': '0xe5973C042Cda75Dacd7bF36B3E7C7F1Ea2980A25',
    'matic': '0xf08665261ef76E56e732c711330e905020E445DA',
    'ftm': '0x69e7D335E8Da617E692d7379e03FEf74ef295899',
    'avax': '0x0c01328A0D8E996433Dd9720F40D896089eb966D',
    'usdc': '0xFF53b9822E114c0AE46cBdE4F7b4C642f8F9bbAA', // polygon
    'doge': '0x026d814935a053D10abA9987e4D047Aa9369c97E', // bsc
    'eth': '0x212A3A41a0e58CCdc86F013b003d4afF805a958c'   // bsc
};
const abi = {
        "constant": true,
        "inputs": [],
        "name": "getBalance",
        "outputs": [
          {
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
};
async function bscTvl(timestamp, block, chainBlocks) {
    let balances = await mineTvl({}, 'bsc', 'cake', chainBlocks, await transformBscAddress());
    balances = await mineTvl(balances, 'bsc', 'eth', chainBlocks, await transformBscAddress());
    balances = await mineTvl(balances, 'bsc', 'doge', chainBlocks, await transformBscAddress());
    return await mineTvl(balances, 'bsc', 'busd', chainBlocks, await transformBscAddress());
};
async function polygonTvl(timestamp, block, chainBlocks) {
    let balances = mineTvl({}, 'polygon', 'matic', chainBlocks, await transformPolygonAddress());
    return mineTvl(balances, 'polygon', 'usdc', chainBlocks, await transformPolygonAddress());
};
async function fantomTvl(timestamp, block, chainBlocks) {
    return mineTvl({}, 'fantom', 'ftm', chainBlocks, await transformFantomAddress());
};
async function avaxTvl(timestamp, block, chainBlocks) {
    return mineTvl({}, 'avax', 'avax', chainBlocks, await transformAvaxAddress());
};
async function mineTvl(balances, chain, miner, chainBlocks, transform=a=>a) {
    const balance = (await sdk.api.abi.call({
      target: minerContracts[miner],
      chain: chain,
      block: chainBlocks[chain],
      abi: abi
    })).output;
    sdk.util.sumSingleBalance(balances, transform(minedTokens[miner]), balance);
    return balances;
};
module.exports = {
    bsc: {
        tvl: bscTvl,
    },
    polygon: {
        tvl: polygonTvl,
    },
    fantom: {
        tvl: fantomTvl,
    },
    avalanche: {
        tvl: avaxTvl,
    },
};
// node test.js projects/multichainMiner.js
'''
'''--- projects/multiplierfinance/abi.json ---
{
    "getReserves": {
        "constant": true,
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getReserveData": {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "_reserve",
                "type": "address"
            }
        ],
        "name": "getReserveData",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "totalLiquidity",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "availableLiquidity",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalBorrowsStable",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "totalBorrowsVariable",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "liquidityRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "variableBorrowRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "stableBorrowRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "averageStableBorrowRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "utilizationRate",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "liquidityIndex",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "variableBorrowIndex",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "mTokenAddress",
                "type": "address"
            },
            {
                "internalType": "uint40",
                "name": "lastUpdateTimestamp",
                "type": "uint40"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "totalSupply": {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    "getNoOfErc20s": {
        "inputs": [],
        "name": "getNoOfErc20s",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "erc20List": {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "erc20List",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
}
'''
'''--- projects/multiplierfinance/index.js ---
const sdk = require("@defillama/sdk");
const abi = require("./abi.json");

const YieldContract = "0xE4Baf69B887843aB6A0e82E8BAeA49010fF619af";

const ETH = "0x0000000000000000000000000000000000000000";

const LendingPool = "0xbc3534b076EDB8E8Ef254D81b81DC193c53057F7";

/*** ETH TVL Portion ***
* Yield Contract is in ethereum network, neither at the protocol web nor at their docs, 
* they didn't mentioned anything about that.
*/
const ethTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const ethBalance = (
    await sdk.api.eth.getBalance({
      target: YieldContract,
      ethBlock,
    })
  ).output;

  sdk.util.sumSingleBalance(balances, ETH, ethBalance);

  const getNoOfErc20s = (
    await sdk.api.abi.call({
      abi: abi.getNoOfErc20s,
      target: YieldContract,
      ethBlock,
    })
  ).output;

  for (let index = 0; index < getNoOfErc20s; index++) {
    const erc20List = (
      await sdk.api.abi.call({
        abi: abi.erc20List,
        target: YieldContract,
        params: index,
        ethBlock,
      })
    ).output;

    try {
      const erc20Balance = (
        await sdk.api.erc20.balanceOf({
          target: erc20List,
          owner: YieldContract,
          ethBlock,
        })
      ).output;

      sdk.util.sumSingleBalance(balances, erc20List, erc20Balance);
    } catch (error) {
      console.error(error);
    }
  }

  return balances;
};

// *** BSC TVL Portion ***

const bscTvl = async (timestamp, ethBlock, chainBlocks) => {
  const balances = {};

  const getReserves = (
    await sdk.api.abi.call({
      abi: abi.getReserves,
      target: LendingPool,
      chain: "bsc",
      block: chainBlocks["bsc"],
    })
  ).output;

  for (let index = 0; index < getReserves.length; index++) {
    const mTokenAddress = (
      await sdk.api.abi.call({
        abi: abi.getReserveData,
        target: LendingPool,
        params: getReserves[index],
        chain: "bsc",
        block: chainBlocks["bsc"],
      })
    ).output[11];

    const totalSupply = (
      await sdk.api.abi.call({
        abi: abi.totalSupply,
        target: mTokenAddress,
        chain: "bsc",
        block: chainBlocks["bsc"],
      })
    ).output;

    sdk.util.sumSingleBalance(
      balances,
      `bsc:${getReserves[index]}`,
      totalSupply
    );
  }

  return balances;
};

module.exports = {
  ethereum: {
    tvl: ethTvl,
  },
  bsc: {
    tvl: bscTvl,
  },
};

'''
'''--- projects/murica.js ---
const { tombTvl } = require('./helper/tomb');

const bond = "0xeb3bA75334A58cB80C45dfBb551f03A5FdE452E6";
const share = "0x19F72Ffe6f5388523FDc30d785eF79E8132cfFF8";
const boardroom = "0xbE621f15e7e58e606D1226BCC192646f03e79C58";
const rewardPool = "0x5f137cb2e183BE293bc49ca770B6D11E07926D58";
const pool2lps = [
    "0x38c1aff09b3d759eddac307cc1f74b55ed54177d",
    "0x314edd39c85a76d0c255813c15097e5afc892074",
];

module.exports = {
    ...tombTvl(bond, share, rewardPool, boardroom, pool2lps, "fantom", undefined, false, pool2lps[1])
};
'''
'''--- projects/mushrooms.js ---
const sdk = require('@defillama/sdk')
const { getChainTransform } = require('./helper/portedTokens')
const { unwrapLPsAuto, } = require('./helper/unwrapLPs')
const abi = {
  balance: {
    "inputs": [],
    "name": "balance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  token: {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
}

const config = {
  ethereum: {
    vaults: [
      '0x0c0291f4c12f04da8b4139996c720a89d28ca069',
      '0x1e074d6da2987f0cb5a44f2ab1c5bfeddd81f23f',
      '0x6802377968857656fe8ae47fbece76aae588eef7',
      '0x23b197dc671a55f256199cf7e8bee77ea2bdc16d',
      '0x374513251ef47db34047f07998e31740496c6faa',
      '0xb0f1a38F5531b398E2081c2F9E61EdD2A924b488',
      '0x41e0c2a507415e25005b1713f5f68ad6648fcf43',
      '0xb06661A221Ab2Ec615531f9632D6Dc5D2984179A',
      '0x3edee5f69e9a8f88da9063b1aa78311e38dbe96c',
      '0x037B39EdAE767EA692884D51fc697c54e777710e',
      '0x076950237f8c0D27Ac25694c9078F96e535723BC',
      '0x5DEDEC994C11aB5F9908f33Aed2947F33B67a449',
      '0xe85e9fB53fe5E2fa74Dda1A1010555F55DbD347B',
      '0xe28b1d0d667824e74b408a02c101cf0c0652d2ea',
      '0x05c85ed5fd1a2088b42021f7ac42bad709da844a',
      '0x1B428B6C389E25133bf0f466Fc5d3E2764F3582b',
    ]
  },
  bsc: {
    vaults: [
      '0xa283aA7CfBB27EF0cfBcb2493dD9F4330E0fd304',
      '0x64bdf61de87920515c4cb1bc05c7f3f7d6c9d555',
      '0x386A8DCf07dc3Aa882Aa0A8f8Ee90473c177F6f3',
      '0xa1c6670f5b040831156641a669f0dca318272f7f',
      '0x73142be337c11f9c962b4aba80edebcfbc47e1e6',
      '0x4dDf7F8Ad6457bECcDFEA9c11006a77A4307c94B',
      '0xFE526BcD5aD38F28C685BDb045B4c1E30f19F224',
      '0x064213bc8cd6980efE41A4247f0Ed5e99257E5f9',
      '0x53e510f6242f841088e29c7d26a44c42aa2db200',
    ]
  },
  fantom: {
    vaults: [
      '0xE71FD0dC4c0349C320053B865a95aE29c09b92B5',
      '0xd21E83422335b21E2e11567c13780a3f3972c0E8',
      '0x5f8757eA9CB135E904a7483F2bae780B9DDbd507',
      '0xd324fbBDad6960e8003f8ec6B9D9D6B2D847fd12',
      '0xe74358fEc47B55F94F5aCb4f32a30a36623Fc373',
      '0x70b89c91ffcc6bd3325419ff63b23cd50d515bc2',
      '0x3371d92e633f7a49fcfa9114e55dafc485bd413b',
      '0xe09CD96100A0e9a19e064dc475568a428515d2e2',
      '0x4471332148688fAA64705a39ec630A6AD692B40a',
      '0x771fbBc372045424fE51Dc761F728870a5a7e933',
      '0x91B6d34679fdEae095B3873b39c5f17C59044339',
    ]
  },
  polygon: {
    vaults: [
      '0xa283aa7cfbb27ef0cfbcb2493dd9f4330e0fd304',
      '0x0c0291f4c12f04da8b4139996c720a89d28ca069',
      '0xe74358fEc47B55F94F5aCb4f32a30a36623Fc373',
      '0xC126A5f0688E87E4069159ad9Bd3cbe4EeEaD165',
      '0xa1c6670F5B040831156641a669F0DCa318272f7f',
      '0x2255A52Cd5549b8AA04E4ED7C8AD730628f6C747',
    ]
  },
  avax: {
    vaults: [
      '0xa33b55d868e57b20df957ddc2f044f09f676967b',
      '0x78ff341f2db10c10a7562227c7a28bc93bb0fbcf',
      '0xdd21bc823d58845f6126c9cef052a2d4340a07c8',
      '0x8F288A56A6c06ffc75994a2d46E84F8bDa1a0744',
      '0x4e504c6ca43cd1bbd9096a2c2e77a176d10910b1',
    ]
  }
}

// node test.js projects/mushrooms.js
module.exports = {
  misrepresentedTokens: true,
}

Object.keys(config).forEach((chain) => {
  module.exports[chain] = {
    tvl: async (_, _b, { [chain]: block }) => {
      const balances = {}
      const transform = await getChainTransform(chain)
      const vaults = config[chain].vaults
      const calls = vaults.map(i => ({ target: i }))
      const { output: tokens } = await sdk.api.abi.multiCall({
        abi: abi.token,
        calls, chain, block,
      })
      const { output: balance } = await sdk.api.abi.multiCall({
        abi: abi.balance,
        calls, chain, block,
      })

      tokens.forEach(({ output: token }, i) => {
        sdk.util.sumSingleBalance(balances, transform(token), balance[i].output)
      })
      return unwrapLPsAuto({ balances, chain, block, transformAddress: transform, })
    }
  }
})
'''
'''--- projects/mustcometh/index.js ---
const {calculateUniTvl} = require('../helper/calculateUniTvl.js')

const FACTORY = "0x800b052609c355cA8103E06F022aA30647eAd60a";

async function tvl(timestamp, block, chainBlocks) {
  return calculateUniTvl(addr=>`polygon:${addr}`, chainBlocks['polygon'], 'polygon', FACTORY, 0, true);
}

module.exports = {
  misrepresentedTokens: true,
  tvl
}
'''
'''--- pull_request_template.md ---
**NOTE**

1. The protocol is usually listed within 24 hours of merging the PR
2. Please fill the form below  **only if the PR is for listing a new protocol** else it can be ignored/replaced with reason/details about the PR
3. **For updating listing info** It is a different repo, you can find your listing in this file: https://github.com/DefiLlama/defillama-server/blob/master/defi/src/protocols/data2.ts, you can  edit it there and put up a PR
4. Do not edit/push `package-lock.json` file as part of your changes, we use lockfileVersion 2, and most use v1 and using that messes up our CI

---

##### Twitter Link:

##### List of audit links if any:

##### Website Link:

##### Logo (High resolution, preferably in .svg and .png, for application on both white and black backgrounds. Will be shown with rounded borders):

##### Current TVL:

##### Chain:

##### Coingecko ID (so your TVL can appear on Coingecko): (https://api.coingecko.com/api/v3/coins/list)

##### Coinmarketcap ID (so your TVL can appear on Coinmarketcap): (https://api.coinmarketcap.com/data-api/v3/map/all?listing_status=active,inactive,untracked&start=1&limit=10000)

##### Short Description (to be shown on DefiLlama):

##### Token address and ticker if any:

##### Category (full list at https://defillama.com/categories) *Please choose only one:

##### Oracle used (Chainlink/Band/API3/TWAP or any other that you are using):

##### forkedFrom (Does your project originate from another project):

##### methodology (what is being counted as tvl, how is tvl being calculated):

'''
'''--- speedTest.js ---

const { ethers } = require('ethers');
const allNetworks = [];

function createProvider(name, url, chainId) {
  allNetworks.push([
    name.toUpperCase() + '_RPC',
    url
  ].join('='));
  
  return new ethers.providers.JsonRpcProvider(url,
    {
      name: name,
      chainId: chainId,
    }
  );
}
(async () => {

  const providers = {
    ethereum: createProvider("ethereum", "https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161", 1),
    bsc: createProvider("bsc", "https://bsc-dataseed4.binance.org", 56),
    polygon: createProvider("polygon", "https://rpc-mainnet.maticvigil.com/", 137),
    heco: createProvider("heco", "https://http-mainnet.hecochain.com", 128),
    fantom: createProvider("fantom", "https://rpc.ftm.tools", 250),
    rsk: createProvider("rsk", "https://public-node.rsk.co", 30),
    tomochain: createProvider("tomochain", "https://rpc.tomochain.com", 88),
    xdai: createProvider("xdai", "https://xdai.poanetwork.dev", 100),
    avax: createProvider("avax", "https://api.avax.network/ext/bc/C/rpc", 43114),
    wan: createProvider("wan", "https://gwan-ssl.wandevs.org:56891", 888),
    harmony: createProvider("harmony", "https://api.s0.t.hmny.io", 1666600000),
    thundercore: createProvider("thundercore", "https://mainnet-rpc.thundercore.com", 108),
    okexchain: createProvider("okexchain", "https://exchainrpc.okex.org", 66),
    optimism: createProvider("optimism", "https://mainnet.optimism.io/", 10),
    arbitrum: createProvider("arbitrum", "https://arb1.arbitrum.io/rpc", 42161),
    kcc: createProvider("kcc", "https://rpc-mainnet.kcc.network", 321),
    celo: createProvider("celo", "https://forno.celo.org", 42220),
  }

  for (var name in providers) {
    const provider = providers[name];
    const start = Date.now();
    const lastBlockNumber = await provider.getBlockNumber();
    const spend = Date.now() - start
    console.log(name, "spend", spend / 1000, "s", "block", lastBlockNumber);
  }
  
  console.log('.env')
  console.log(allNetworks.join("\n"))
})();
'''
'''--- test.js ---
#!/usr/bin/env node
const path = require("path");
require("dotenv").config();
const { default: computeTVL } = require("@defillama/sdk/build/computeTVL");
const { chainsForBlocks } = require("@defillama/sdk/build/computeTVL/blocks");
const { getLatestBlock } = require("@defillama/sdk/build/util/index");
const {
  humanizeNumber,
} = require("@defillama/sdk/build/computeTVL/humanizeNumber");
const { util } = require("@defillama/sdk");
const sdk = require("@defillama/sdk");
const whitelistedExportKeys = require('./projects/helper/whitelistedExportKeys.json')
const chainList = require('./projects/helper/chains.json')
const handleError = require('./utils/handleError')
const { diplayUnknownTable } = require('./projects/helper/utils')

async function getLatestBlockRetry(chain) {
  for (let i = 0; i < 5; i++) {
    try {
      return await getLatestBlock(chain);
    } catch (e) {
      throw new Error(`Couln't get block heights for chain "${chain}"`, e);
    }
  }
}

const locks = [];
function getCoingeckoLock() {
  return new Promise((resolve) => {
    locks.push(resolve);
  });
}
function releaseCoingeckoLock() {
  const firstLock = locks.shift();
  if (firstLock !== undefined) {
    firstLock(null);
  }
}
// Rate limit is 50 calls/min for coingecko's API
// So we'll release one every 1.2 seconds to match it
setInterval(() => {
  releaseCoingeckoLock();
}, 2000);
const maxCoingeckoRetries = 5;

async function getTvl(
  unixTimestamp,
  ethBlock,
  chainBlocks,
  usdTvls,
  tokensBalances,
  usdTokenBalances,
  tvlFunction,
  isFetchFunction,
  storedKey,
  knownTokenPrices
) {
  if (!isFetchFunction) {
    const tvlBalances = await tvlFunction(unixTimestamp, ethBlock, chainBlocks);
    const tvlResults = await computeTVL(
      tvlBalances,
      "now",
      false,
      knownTokenPrices,
      getCoingeckoLock,
      maxCoingeckoRetries
    );
    await diplayUnknownTable({ tvlResults, storedKey, tvlBalances, })
    usdTvls[storedKey] = tvlResults.usdTvl;
    tokensBalances[storedKey] = tvlResults.tokenBalances;
    usdTokenBalances[storedKey] = tvlResults.usdTokenBalances;
  } else {
    usdTvls[storedKey] = Number(
      await tvlFunction(unixTimestamp, ethBlock, chainBlocks)
    );
  }
  if (
    typeof usdTvls[storedKey] !== "number" ||
    Number.isNaN(usdTvls[storedKey])
  ) {
    throw new Error(
      `TVL for key ${storedKey} is not a number, instead it is ${usdTvls[storedKey]}`
    );
  }
}

function mergeBalances(key, storedKeys, balancesObject) {
  if (balancesObject[key] === undefined) {
    balancesObject[key] = {};
    storedKeys.map((keyToMerge) => {
      Object.entries(balancesObject[keyToMerge]).forEach((balance) => {
        util.sumSingleBalance(balancesObject[key], balance[0], balance[1]);
      });
    });
  }
}

if (process.argv.length < 3) {
  console.error(`Missing argument, you need to provide the filename of the adapter to test.
    Eg: node test.js projects/myadapter.js`);
  process.exit(1);
}
const passedFile = path.resolve(process.cwd(), process.argv[2]);

const originalCall = sdk.api.abi.call
sdk.api.abi.call = async (...args)=>{
  try{
    return await originalCall(...args)
  } catch(e){
    console.log("sdk.api.abi.call errored with params:", args)
    throw e
  }
}

(async () => {
  let module = {};
  try {
    module = require(passedFile)
  } catch(e) {
    console.log(e)
  }
  const chains = Object.keys(module).filter(item => typeof module[item] === 'object' && !Array.isArray(module[item]));
  checkExportKeys(module, passedFile, chains)
  const unixTimestamp = Math.round(Date.now() / 1000) - 60;
  const chainBlocks = {};

  if (!chains.includes("ethereum")) {
    chains.push("ethereum");
  }
  await Promise.all(
    chains.map(async (chainRaw) => {
      const chain = chainRaw === "avalanche"?"avax":chainRaw
      if (chainsForBlocks.includes(chain) || chain === "ethereum") {
        chainBlocks[chain] = (await getLatestBlockRetry(chain)).number - 10;
      }
    })
  );
  const ethBlock = chainBlocks.ethereum;
  const usdTvls = {};
  const tokensBalances = {};
  const usdTokenBalances = {};
  const chainTvlsToAdd = {};
  const knownTokenPrices = {};

  let tvlPromises = Object.entries(module).map(async ([chain, value]) => {
    if (typeof value !== "object" || value === null) {
      return;
    }
    return Promise.all(
      Object.entries(value).map(async ([tvlType, tvlFunction]) => {
        if (typeof tvlFunction !== "function") {
          return;
        }
        let storedKey = `${chain}-${tvlType}`;
        let tvlFunctionIsFetch = false;
        if (tvlType === "tvl") {
          storedKey = chain;
        } else if (tvlType === "fetch") {
          storedKey = chain;
          tvlFunctionIsFetch = true;
        }
        await getTvl(
          unixTimestamp,
          ethBlock,
          chainBlocks,
          usdTvls,
          tokensBalances,
          usdTokenBalances,
          tvlFunction,
          tvlFunctionIsFetch,
          storedKey,
          knownTokenPrices
        );
        let keyToAddChainBalances = tvlType;
        if (tvlType === "tvl" || tvlType === "fetch") {
          keyToAddChainBalances = "tvl";
        }
        if (chainTvlsToAdd[keyToAddChainBalances] === undefined) {
          chainTvlsToAdd[keyToAddChainBalances] = [storedKey];
        } else {
          chainTvlsToAdd[keyToAddChainBalances].push(storedKey);
        }
      })
    );
  });
  if (module.tvl || module.fetch) {
    let mainTvlIsFetch;
    if (module.tvl) {
      mainTvlIsFetch = false;
    } else {
      mainTvlIsFetch = true;
    }
    const mainTvlPromise = getTvl(
      unixTimestamp,
      ethBlock,
      chainBlocks,
      usdTvls,
      tokensBalances,
      usdTokenBalances,
      mainTvlIsFetch ? module.fetch : module.tvl,
      mainTvlIsFetch,
      "tvl",
      knownTokenPrices
    );
    tvlPromises.push(mainTvlPromise);
  }
  await Promise.all(tvlPromises);
  Object.entries(chainTvlsToAdd).map(([tvlType, storedKeys]) => {
    if (usdTvls[tvlType] === undefined) {
      usdTvls[tvlType] = storedKeys.reduce(
        (total, key) => total + usdTvls[key],
        0
      );
      mergeBalances(tvlType, storedKeys, tokensBalances);
      mergeBalances(tvlType, storedKeys, usdTokenBalances);
    }
  });
  if (usdTvls.tvl === undefined) {
    throw new Error(
      "Protocol doesn't have total tvl, make sure to export a tvl key either on the main object or in one of the chains"
    );
  }

  Object.entries(usdTokenBalances).forEach(([chain, balances]) => {
    console.log(`--- ${chain} ---`);
    Object.entries(balances)
      .sort((a, b) => b[1] - a[1])
      .forEach(([symbol, balance]) => {
        console.log(symbol.padEnd(25, " "), humanizeNumber(balance));
      });
    console.log("Total:", humanizeNumber(usdTvls[chain]), "\n");
  });
  console.log(`------ TVL ------`);
  Object.entries(usdTvls).forEach(([chain, usdTvl]) => {
    if (chain !== "tvl") {
      console.log(chain.padEnd(25, " "), humanizeNumber(usdTvl));
    }
  });
  console.log("\ntotal".padEnd(25, " "), humanizeNumber(usdTvls.tvl), "\n");

  process.exit(0);
})();

function checkExportKeys(module, filePath, chains) {
  filePath = filePath.split(path.sep)
  filePath = filePath.slice(filePath.lastIndexOf('projects') + 1)

  if (filePath.length > 2  
    || (filePath.length === 1 && !['.js', ''].includes(path.extname(filePath[0]))) // matches .../projects/projectXYZ.js or .../projects/projectXYZ
    || (filePath.length === 2 && !['api.js', 'index.js'].includes(filePath[1])))  // matches .../projects/projectXYZ/index.js
    process.exit(0)

  const blacklistedRootExportKeys = ['tvl', 'staking', 'pool2', 'borrowed', 'treasury'];
  const rootexportKeys = Object.keys(module).filter(item => typeof module[item] !== 'object');
  const unknownChains = chains.filter(chain => !chainList.includes(chain));
  const blacklistedKeysFound = rootexportKeys.filter(key => blacklistedRootExportKeys.includes(key));
  let exportKeys = chains.map(chain => Object.keys(module[chain])).flat()
  exportKeys.push(...rootexportKeys)
  exportKeys = Object.keys(exportKeys.reduce((agg, key) => ({...agg, [key]: 1}), {})) // get unique keys
  const unknownKeys = exportKeys.filter(key => !whitelistedExportKeys.includes(key))

  if (unknownChains.length) {
    throw new Error(`
    Unknown chain(s): ${unknownChains.join(', ')}
    Note: if you think that the chain is correct but missing from our list, please add it to 'projects/helper/chains.json' file
    `)
  }

  if (blacklistedKeysFound.length) {
    throw new Error(`
    Please move the following keys into the chain: ${blacklistedKeysFound.join(', ')}

    We have a new adapter export specification now where tvl and other chain specific information are moved inside chain export.
    For example if your protocol is on ethereum and has tvl and pool2, the export file would look like:
    
        module.exports = {
          methodlogy: '...',
          ethereum: {
            tvl: 
            pool2:
          }
        }

    `)
  }

  if (unknownKeys.length) {
    throw new Error(`
    Found export keys that were not part of specification: ${unknownKeys.join(', ')}

    List of valid keys: ${['', '', ...whitelistedExportKeys].join('\n\t\t\t\t')}
    `)
  }
}

process.on('unhandledRejection', handleError)
process.on('uncaughtException', handleError)
'''
'''--- utils/handleError.js ---
const errorString = '------ ERROR ------'

function handleError(error){
  console.log('\n',errorString, '\n\n')
  const isGraphError = error.stack?.includes('graphql-request') && error.response?.errors?.length
  if (isGraphError)
    console.error(error.response.errors.map(e => e.message).join('\n'))
  else
    console.error(error.toString())
  const axiosError  = error?.response?.data?.message
  if (axiosError)
    console.log('Axios: ', axiosError)
  const stack = getStackMessage(error.stack)
  if (stack.length) {
    console.log('Truncated error stack:')
    console.log(stack.join('\n'))
  }
  process.exit(1)
}

function getStackMessage(stack) {
  if (/ at (checkExportKeys)/.test(stack)) return []

  const isNodeMolule = m => /node_modules/.test(m)
  const isNotLoggerMessage = m => !/log/.test(m)
  const isNotInternalMessage = m => !/node:internal/.test(m)

  const message = []
  stack = stack.split('\n')
  while (stack.length && !stack[0].includes('  at '))
    stack.shift()
  const firstNMStackMessage = stack.filter(isNodeMolule)
    .filter(isNotLoggerMessage)[0]
  stack = stack.filter(m => !isNodeMolule(m)).filter(isNotInternalMessage)
  message.push(firstNMStackMessage, ...stack)
  return message
}

module.exports = handleError
'''
'''--- utils/package-lock.json ---
{
  "name": "run-interactive",
  "version": "0.0.1",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "run-interactive",
      "version": "0.0.1",
      "license": "ISC",
      "devDependencies": {
        "inquirer": "^8.2.4",
        "inquirer-fuzzy-path": "^2.3.0"
      }
    },
    "node_modules/ansi-escapes": {
      "version": "4.3.2",
      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
      "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
      "dev": true,
      "dependencies": {
        "type-fest": "^0.21.3"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "dev": true,
      "dependencies": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "node_modules/buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chardet": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/chardet/-/chardet-0.7.0.tgz",
      "integrity": "sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==",
      "dev": true
    },
    "node_modules/cli-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
      "dev": true,
      "dependencies": {
        "restore-cursor": "^3.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/cli-spinners": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/cli-spinners/-/cli-spinners-2.6.1.tgz",
      "integrity": "sha512-x/5fWmGMnbKQAaNwN+UZlV79qBLM9JFnJuJ03gIi5whrob0xV0ofNVHy9DhwGdsMJQc2OKv0oGmLzvaqvAVv+g==",
      "dev": true,
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/cli-width": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cli-width/-/cli-width-3.0.0.tgz",
      "integrity": "sha512-FxqpkPPwu1HjuN93Omfm4h8uIanXofW0RxVEW3k5RKx+mJJYSthzNhp32Kzxxy3YAEZ/Dc/EWN1vZRY0+kOhbw==",
      "dev": true,
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/clone": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/clone/-/clone-1.0.4.tgz",
      "integrity": "sha1-2jCcwmPfFZlMaIypAheco8fNfH4=",
      "dev": true,
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "node_modules/defaults": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/defaults/-/defaults-1.0.3.tgz",
      "integrity": "sha1-xlYFHpgX2f8I7YgUd/P+QBnz730=",
      "dev": true,
      "dependencies": {
        "clone": "^1.0.2"
      }
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "node_modules/escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
      "dev": true,
      "engines": {
        "node": ">=0.8.0"
      }
    },
    "node_modules/external-editor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/external-editor/-/external-editor-3.1.0.tgz",
      "integrity": "sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==",
      "dev": true,
      "dependencies": {
        "chardet": "^0.7.0",
        "iconv-lite": "^0.4.24",
        "tmp": "^0.0.33"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/figures": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/figures/-/figures-3.2.0.tgz",
      "integrity": "sha512-yaduQFRKLXYOGgEn6AZau90j3ggSOyiqXU0F9JZfeXYhNa+Jk4X+s45A2zg5jns87GAFa34BBm2kXw4XpNcbdg==",
      "dev": true,
      "dependencies": {
        "escape-string-regexp": "^1.0.5"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/fuzzy": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/fuzzy/-/fuzzy-0.1.3.tgz",
      "integrity": "sha1-THbsL/CsGjap3M+aAN+GIweNTtg=",
      "dev": true,
      "engines": {
        "node": ">= 0.6.0"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dev": true,
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "node_modules/inquirer": {
      "version": "8.2.4",
      "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-8.2.4.tgz",
      "integrity": "sha512-nn4F01dxU8VeKfq192IjLsxu0/OmMZ4Lg3xKAns148rCaXP6ntAoEkVYZThWjwON8AlzdZZi6oqnhNbxUG9hVg==",
      "dev": true,
      "dependencies": {
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.1.1",
        "cli-cursor": "^3.1.0",
        "cli-width": "^3.0.0",
        "external-editor": "^3.0.3",
        "figures": "^3.0.0",
        "lodash": "^4.17.21",
        "mute-stream": "0.0.8",
        "ora": "^5.4.1",
        "run-async": "^2.4.0",
        "rxjs": "^7.5.5",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0",
        "through": "^2.3.6",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/inquirer-autocomplete-prompt": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/inquirer-autocomplete-prompt/-/inquirer-autocomplete-prompt-1.4.0.tgz",
      "integrity": "sha512-qHgHyJmbULt4hI+kCmwX92MnSxDs/Yhdt4wPA30qnoa01OF6uTXV8yvH4hKXgdaTNmkZ9D01MHjqKYEuJN+ONw==",
      "dev": true,
      "dependencies": {
        "ansi-escapes": "^4.3.1",
        "chalk": "^4.0.0",
        "figures": "^3.2.0",
        "run-async": "^2.4.0",
        "rxjs": "^6.6.2"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "inquirer": "^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/inquirer-autocomplete-prompt/node_modules/rxjs": {
      "version": "6.6.7",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.6.7.tgz",
      "integrity": "sha512-hTdwr+7yYNIT5n4AMYp85KA6yw2Va0FLa3Rguvbpa4W3I5xynaBZo41cM3XM+4Q6fRMj3sBYIR1VAmZMXYJvRQ==",
      "dev": true,
      "dependencies": {
        "tslib": "^1.9.0"
      },
      "engines": {
        "npm": ">=2.0.0"
      }
    },
    "node_modules/inquirer-autocomplete-prompt/node_modules/tslib": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
      "dev": true
    },
    "node_modules/inquirer-fuzzy-path": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/inquirer-fuzzy-path/-/inquirer-fuzzy-path-2.3.0.tgz",
      "integrity": "sha512-zfHC/97GSkxKKM7IctZM22x1sVi+FYBh9oaHTmI7Er/GKFpNykUgtviTmqqpiFQs5yJoSowxbT0PHy6N+H+QRg==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^3.2.1",
        "fuzzy": "^0.1.3",
        "inquirer": "^6.0.0",
        "inquirer-autocomplete-prompt": "^1.0.2",
        "strip-ansi": "^4.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/ansi-escapes": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-3.2.0.tgz",
      "integrity": "sha512-cBhpre4ma+U0T1oM5fXg7Dy1Jw7zzwv7lt/GoCpr+hDQJoYnKVPLL4dCvSEFMmQurOQvSrwT7SL/DAlhBI97RQ==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/ansi-regex": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.1.tgz",
      "integrity": "sha512-+O9Jct8wf++lXxxFc4hc8LsjaSq0HFzzL7cVsw8pRDIPdjKD2mT4ytDZlLuSBZ4cLKZFXIrMGO7DbQCtMJJMKw==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/ansi-styles": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
      "dev": true,
      "dependencies": {
        "color-convert": "^1.9.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/chalk": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
      "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^3.2.1",
        "escape-string-regexp": "^1.0.5",
        "supports-color": "^5.3.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/cli-cursor": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-2.1.0.tgz",
      "integrity": "sha512-8lgKz8LmCRYZZQDpRyT2m5rKJ08TnU4tR9FFFW2rxpxR1FzWi4PQ/NfyODchAatHaUgnSPVcx/R5w6NuTBzFiw==",
      "dev": true,
      "dependencies": {
        "restore-cursor": "^2.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/cli-width": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/cli-width/-/cli-width-2.2.1.tgz",
      "integrity": "sha512-GRMWDxpOB6Dgk2E5Uo+3eEBvtOOlimMmpbFiKuLFnQzYDavtLFY3K5ona41jgN/WdRZtG7utuVSVTL4HbZHGkw==",
      "dev": true
    },
    "node_modules/inquirer-fuzzy-path/node_modules/color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "dev": true,
      "dependencies": {
        "color-name": "1.1.3"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/color-name": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
      "dev": true
    },
    "node_modules/inquirer-fuzzy-path/node_modules/figures": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/figures/-/figures-2.0.0.tgz",
      "integrity": "sha1-OrGi0qYsi/tDGgyUy3l6L84nyWI=",
      "dev": true,
      "dependencies": {
        "escape-string-regexp": "^1.0.5"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/inquirer": {
      "version": "6.5.2",
      "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-6.5.2.tgz",
      "integrity": "sha512-cntlB5ghuB0iuO65Ovoi8ogLHiWGs/5yNrtUcKjFhSSiVeAIVpD7koaSU9RM8mpXw5YDi9RdYXGQMaOURB7ycQ==",
      "dev": true,
      "dependencies": {
        "ansi-escapes": "^3.2.0",
        "chalk": "^2.4.2",
        "cli-cursor": "^2.1.0",
        "cli-width": "^2.0.0",
        "external-editor": "^3.0.3",
        "figures": "^2.0.0",
        "lodash": "^4.17.12",
        "mute-stream": "0.0.7",
        "run-async": "^2.2.0",
        "rxjs": "^6.4.0",
        "string-width": "^2.1.0",
        "strip-ansi": "^5.1.0",
        "through": "^2.3.6"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/inquirer/node_modules/ansi-regex": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.1.tgz",
      "integrity": "sha512-ILlv4k/3f6vfQ4OoP2AGvirOktlQ98ZEL1k9FaQjxa3L1abBgbuTDAdPOpvbGncC0BTVQrl+OM8xZGK6tWXt7g==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/inquirer/node_modules/strip-ansi": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
      "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
      "dev": true,
      "dependencies": {
        "ansi-regex": "^4.1.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/mimic-fn": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.2.0.tgz",
      "integrity": "sha512-jf84uxzwiuiIVKiOLpfYk7N46TSy8ubTonmneY9vrpHNAnp0QBt2BxWV9dO3/j+BoVAb+a5G6YDPW3M5HOdMWQ==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/mute-stream": {
      "version": "0.0.7",
      "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.7.tgz",
      "integrity": "sha1-MHXOk7whuPq0PhvE2n6BFe0ee6s=",
      "dev": true
    },
    "node_modules/inquirer-fuzzy-path/node_modules/onetime": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-2.0.1.tgz",
      "integrity": "sha1-BnQoIw/WdEOyeUsiu6UotoZ5YtQ=",
      "dev": true,
      "dependencies": {
        "mimic-fn": "^1.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/restore-cursor": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-2.0.0.tgz",
      "integrity": "sha1-n37ih/gv0ybU/RYpI9YhKe7g368=",
      "dev": true,
      "dependencies": {
        "onetime": "^2.0.0",
        "signal-exit": "^3.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/rxjs": {
      "version": "6.6.7",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.6.7.tgz",
      "integrity": "sha512-hTdwr+7yYNIT5n4AMYp85KA6yw2Va0FLa3Rguvbpa4W3I5xynaBZo41cM3XM+4Q6fRMj3sBYIR1VAmZMXYJvRQ==",
      "dev": true,
      "dependencies": {
        "tslib": "^1.9.0"
      },
      "engines": {
        "npm": ">=2.0.0"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "dev": true,
      "dependencies": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "dev": true,
      "dependencies": {
        "ansi-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/inquirer-fuzzy-path/node_modules/tslib": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
      "dev": true
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-interactive": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-interactive/-/is-interactive-1.0.0.tgz",
      "integrity": "sha512-2HvIEKRoqS62guEC+qBjpvRubdX910WCMuJTZ+I9yvqKU2/12eSL549HMwtabb4oupdj2sMP50k+XJfB/8JE6w==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-unicode-supported": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true
    },
    "node_modules/log-symbols": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
      "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
      "dev": true,
      "dependencies": {
        "chalk": "^4.1.0",
        "is-unicode-supported": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/mute-stream": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.8.tgz",
      "integrity": "sha512-nnbWWOkoWyUsTjKrhgD0dcz22mdkSnpYqbEjIm2nhwhuxlSkpywJmBo8h0ZqJdkp73mb90SssHkN4rsRaBAfAA==",
      "dev": true
    },
    "node_modules/onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dev": true,
      "dependencies": {
        "mimic-fn": "^2.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ora": {
      "version": "5.4.1",
      "resolved": "https://registry.npmjs.org/ora/-/ora-5.4.1.tgz",
      "integrity": "sha512-5b6Y85tPxZZ7QytO+BQzysW31HJku27cRIlkbAXaNx+BdcVi+LlRFmVXzeF6a7JCwJpyw5c4b+YSVImQIrBpuQ==",
      "dev": true,
      "dependencies": {
        "bl": "^4.1.0",
        "chalk": "^4.1.0",
        "cli-cursor": "^3.1.0",
        "cli-spinners": "^2.5.0",
        "is-interactive": "^1.0.0",
        "is-unicode-supported": "^0.1.0",
        "log-symbols": "^4.1.0",
        "strip-ansi": "^6.0.0",
        "wcwidth": "^1.0.1"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/os-tmpdir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz",
      "integrity": "sha1-u+Z0BseaqFxc/sdm/lc0VV36EnQ=",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
      "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
      "dev": true,
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/restore-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
      "dev": true,
      "dependencies": {
        "onetime": "^5.1.0",
        "signal-exit": "^3.0.2"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/run-async": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz",
      "integrity": "sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==",
      "dev": true,
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/rxjs": {
      "version": "7.5.5",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.5.5.tgz",
      "integrity": "sha512-sy+H0pQofO95VDmFLzyaw9xNJU4KTRSwQIGM6+iG3SypAtCiLDzpeG8sJrNCWn2Up9km+KhkvTdbkrdy+yzZdw==",
      "dev": true,
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "dev": true
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
      "dev": true
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dev": true,
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha1-DdTJ/6q8NXlgsbckEV1+Doai4fU=",
      "dev": true
    },
    "node_modules/tmp": {
      "version": "0.0.33",
      "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz",
      "integrity": "sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==",
      "dev": true,
      "dependencies": {
        "os-tmpdir": "~1.0.2"
      },
      "engines": {
        "node": ">=0.6.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ==",
      "dev": true
    },
    "node_modules/type-fest": {
      "version": "0.21.3",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
      "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=",
      "dev": true
    },
    "node_modules/wcwidth": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/wcwidth/-/wcwidth-1.0.1.tgz",
      "integrity": "sha1-8LDc+RW8X/FSivrbLA4XtTLaL+g=",
      "dev": true,
      "dependencies": {
        "defaults": "^1.0.3"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    }
  },
  "dependencies": {
    "ansi-escapes": {
      "version": "4.3.2",
      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
      "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
      "dev": true,
      "requires": {
        "type-fest": "^0.21.3"
      }
    },
    "ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true
    },
    "ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "requires": {
        "color-convert": "^2.0.1"
      }
    },
    "base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "dev": true
    },
    "bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "dev": true,
      "requires": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "dev": true,
      "requires": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      }
    },
    "chardet": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/chardet/-/chardet-0.7.0.tgz",
      "integrity": "sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==",
      "dev": true
    },
    "cli-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
      "dev": true,
      "requires": {
        "restore-cursor": "^3.1.0"
      }
    },
    "cli-spinners": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/cli-spinners/-/cli-spinners-2.6.1.tgz",
      "integrity": "sha512-x/5fWmGMnbKQAaNwN+UZlV79qBLM9JFnJuJ03gIi5whrob0xV0ofNVHy9DhwGdsMJQc2OKv0oGmLzvaqvAVv+g==",
      "dev": true
    },
    "cli-width": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cli-width/-/cli-width-3.0.0.tgz",
      "integrity": "sha512-FxqpkPPwu1HjuN93Omfm4h8uIanXofW0RxVEW3k5RKx+mJJYSthzNhp32Kzxxy3YAEZ/Dc/EWN1vZRY0+kOhbw==",
      "dev": true
    },
    "clone": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/clone/-/clone-1.0.4.tgz",
      "integrity": "sha1-2jCcwmPfFZlMaIypAheco8fNfH4=",
      "dev": true
    },
    "color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "requires": {
        "color-name": "~1.1.4"
      }
    },
    "color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "defaults": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/defaults/-/defaults-1.0.3.tgz",
      "integrity": "sha1-xlYFHpgX2f8I7YgUd/P+QBnz730=",
      "dev": true,
      "requires": {
        "clone": "^1.0.2"
      }
    },
    "emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
      "dev": true
    },
    "external-editor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/external-editor/-/external-editor-3.1.0.tgz",
      "integrity": "sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==",
      "dev": true,
      "requires": {
        "chardet": "^0.7.0",
        "iconv-lite": "^0.4.24",
        "tmp": "^0.0.33"
      }
    },
    "figures": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/figures/-/figures-3.2.0.tgz",
      "integrity": "sha512-yaduQFRKLXYOGgEn6AZau90j3ggSOyiqXU0F9JZfeXYhNa+Jk4X+s45A2zg5jns87GAFa34BBm2kXw4XpNcbdg==",
      "dev": true,
      "requires": {
        "escape-string-regexp": "^1.0.5"
      }
    },
    "fuzzy": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/fuzzy/-/fuzzy-0.1.3.tgz",
      "integrity": "sha1-THbsL/CsGjap3M+aAN+GIweNTtg=",
      "dev": true
    },
    "has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true
    },
    "iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dev": true,
      "requires": {
        "safer-buffer": ">= 2.1.2 < 3"
      }
    },
    "ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "dev": true
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "inquirer": {
      "version": "8.2.4",
      "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-8.2.4.tgz",
      "integrity": "sha512-nn4F01dxU8VeKfq192IjLsxu0/OmMZ4Lg3xKAns148rCaXP6ntAoEkVYZThWjwON8AlzdZZi6oqnhNbxUG9hVg==",
      "dev": true,
      "requires": {
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.1.1",
        "cli-cursor": "^3.1.0",
        "cli-width": "^3.0.0",
        "external-editor": "^3.0.3",
        "figures": "^3.0.0",
        "lodash": "^4.17.21",
        "mute-stream": "0.0.8",
        "ora": "^5.4.1",
        "run-async": "^2.4.0",
        "rxjs": "^7.5.5",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0",
        "through": "^2.3.6",
        "wrap-ansi": "^7.0.0"
      }
    },
    "inquirer-autocomplete-prompt": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/inquirer-autocomplete-prompt/-/inquirer-autocomplete-prompt-1.4.0.tgz",
      "integrity": "sha512-qHgHyJmbULt4hI+kCmwX92MnSxDs/Yhdt4wPA30qnoa01OF6uTXV8yvH4hKXgdaTNmkZ9D01MHjqKYEuJN+ONw==",
      "dev": true,
      "requires": {
        "ansi-escapes": "^4.3.1",
        "chalk": "^4.0.0",
        "figures": "^3.2.0",
        "run-async": "^2.4.0",
        "rxjs": "^6.6.2"
      },
      "dependencies": {
        "rxjs": {
          "version": "6.6.7",
          "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.6.7.tgz",
          "integrity": "sha512-hTdwr+7yYNIT5n4AMYp85KA6yw2Va0FLa3Rguvbpa4W3I5xynaBZo41cM3XM+4Q6fRMj3sBYIR1VAmZMXYJvRQ==",
          "dev": true,
          "requires": {
            "tslib": "^1.9.0"
          }
        },
        "tslib": {
          "version": "1.14.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
          "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
          "dev": true
        }
      }
    },
    "inquirer-fuzzy-path": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/inquirer-fuzzy-path/-/inquirer-fuzzy-path-2.3.0.tgz",
      "integrity": "sha512-zfHC/97GSkxKKM7IctZM22x1sVi+FYBh9oaHTmI7Er/GKFpNykUgtviTmqqpiFQs5yJoSowxbT0PHy6N+H+QRg==",
      "dev": true,
      "requires": {
        "ansi-styles": "^3.2.1",
        "fuzzy": "^0.1.3",
        "inquirer": "^6.0.0",
        "inquirer-autocomplete-prompt": "^1.0.2",
        "strip-ansi": "^4.0.0"
      },
      "dependencies": {
        "ansi-escapes": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-3.2.0.tgz",
          "integrity": "sha512-cBhpre4ma+U0T1oM5fXg7Dy1Jw7zzwv7lt/GoCpr+hDQJoYnKVPLL4dCvSEFMmQurOQvSrwT7SL/DAlhBI97RQ==",
          "dev": true
        },
        "ansi-regex": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.1.tgz",
          "integrity": "sha512-+O9Jct8wf++lXxxFc4hc8LsjaSq0HFzzL7cVsw8pRDIPdjKD2mT4ytDZlLuSBZ4cLKZFXIrMGO7DbQCtMJJMKw==",
          "dev": true
        },
        "ansi-styles": {
          "version": "3.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
          "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
          "dev": true,
          "requires": {
            "color-convert": "^1.9.0"
          }
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "cli-cursor": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-2.1.0.tgz",
          "integrity": "sha512-8lgKz8LmCRYZZQDpRyT2m5rKJ08TnU4tR9FFFW2rxpxR1FzWi4PQ/NfyODchAatHaUgnSPVcx/R5w6NuTBzFiw==",
          "dev": true,
          "requires": {
            "restore-cursor": "^2.0.0"
          }
        },
        "cli-width": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/cli-width/-/cli-width-2.2.1.tgz",
          "integrity": "sha512-GRMWDxpOB6Dgk2E5Uo+3eEBvtOOlimMmpbFiKuLFnQzYDavtLFY3K5ona41jgN/WdRZtG7utuVSVTL4HbZHGkw==",
          "dev": true
        },
        "color-convert": {
          "version": "1.9.3",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
          "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
          "dev": true,
          "requires": {
            "color-name": "1.1.3"
          }
        },
        "color-name": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
          "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
          "dev": true
        },
        "figures": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/figures/-/figures-2.0.0.tgz",
          "integrity": "sha1-OrGi0qYsi/tDGgyUy3l6L84nyWI=",
          "dev": true,
          "requires": {
            "escape-string-regexp": "^1.0.5"
          }
        },
        "has-flag": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
          "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
          "dev": true
        },
        "inquirer": {
          "version": "6.5.2",
          "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-6.5.2.tgz",
          "integrity": "sha512-cntlB5ghuB0iuO65Ovoi8ogLHiWGs/5yNrtUcKjFhSSiVeAIVpD7koaSU9RM8mpXw5YDi9RdYXGQMaOURB7ycQ==",
          "dev": true,
          "requires": {
            "ansi-escapes": "^3.2.0",
            "chalk": "^2.4.2",
            "cli-cursor": "^2.1.0",
            "cli-width": "^2.0.0",
            "external-editor": "^3.0.3",
            "figures": "^2.0.0",
            "lodash": "^4.17.12",
            "mute-stream": "0.0.7",
            "run-async": "^2.2.0",
            "rxjs": "^6.4.0",
            "string-width": "^2.1.0",
            "strip-ansi": "^5.1.0",
            "through": "^2.3.6"
          },
          "dependencies": {
            "ansi-regex": {
              "version": "4.1.1",
              "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.1.tgz",
              "integrity": "sha512-ILlv4k/3f6vfQ4OoP2AGvirOktlQ98ZEL1k9FaQjxa3L1abBgbuTDAdPOpvbGncC0BTVQrl+OM8xZGK6tWXt7g==",
              "dev": true
            },
            "strip-ansi": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
              "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
              "dev": true,
              "requires": {
                "ansi-regex": "^4.1.0"
              }
            }
          }
        },
        "is-fullwidth-code-point": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
          "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
          "dev": true
        },
        "mimic-fn": {
          "version": "1.2.0",
          "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.2.0.tgz",
          "integrity": "sha512-jf84uxzwiuiIVKiOLpfYk7N46TSy8ubTonmneY9vrpHNAnp0QBt2BxWV9dO3/j+BoVAb+a5G6YDPW3M5HOdMWQ==",
          "dev": true
        },
        "mute-stream": {
          "version": "0.0.7",
          "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.7.tgz",
          "integrity": "sha1-MHXOk7whuPq0PhvE2n6BFe0ee6s=",
          "dev": true
        },
        "onetime": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/onetime/-/onetime-2.0.1.tgz",
          "integrity": "sha1-BnQoIw/WdEOyeUsiu6UotoZ5YtQ=",
          "dev": true,
          "requires": {
            "mimic-fn": "^1.0.0"
          }
        },
        "restore-cursor": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-2.0.0.tgz",
          "integrity": "sha1-n37ih/gv0ybU/RYpI9YhKe7g368=",
          "dev": true,
          "requires": {
            "onetime": "^2.0.0",
            "signal-exit": "^3.0.2"
          }
        },
        "rxjs": {
          "version": "6.6.7",
          "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.6.7.tgz",
          "integrity": "sha512-hTdwr+7yYNIT5n4AMYp85KA6yw2Va0FLa3Rguvbpa4W3I5xynaBZo41cM3XM+4Q6fRMj3sBYIR1VAmZMXYJvRQ==",
          "dev": true,
          "requires": {
            "tslib": "^1.9.0"
          }
        },
        "string-width": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
          "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
          "dev": true,
          "requires": {
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^4.0.0"
          }
        },
        "strip-ansi": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^3.0.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "tslib": {
          "version": "1.14.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
          "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
          "dev": true
        }
      }
    },
    "is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true
    },
    "is-interactive": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-interactive/-/is-interactive-1.0.0.tgz",
      "integrity": "sha512-2HvIEKRoqS62guEC+qBjpvRubdX910WCMuJTZ+I9yvqKU2/12eSL549HMwtabb4oupdj2sMP50k+XJfB/8JE6w==",
      "dev": true
    },
    "is-unicode-supported": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
      "dev": true
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true
    },
    "log-symbols": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
      "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
      "dev": true,
      "requires": {
        "chalk": "^4.1.0",
        "is-unicode-supported": "^0.1.0"
      }
    },
    "mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true
    },
    "mute-stream": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.8.tgz",
      "integrity": "sha512-nnbWWOkoWyUsTjKrhgD0dcz22mdkSnpYqbEjIm2nhwhuxlSkpywJmBo8h0ZqJdkp73mb90SssHkN4rsRaBAfAA==",
      "dev": true
    },
    "onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dev": true,
      "requires": {
        "mimic-fn": "^2.1.0"
      }
    },
    "ora": {
      "version": "5.4.1",
      "resolved": "https://registry.npmjs.org/ora/-/ora-5.4.1.tgz",
      "integrity": "sha512-5b6Y85tPxZZ7QytO+BQzysW31HJku27cRIlkbAXaNx+BdcVi+LlRFmVXzeF6a7JCwJpyw5c4b+YSVImQIrBpuQ==",
      "dev": true,
      "requires": {
        "bl": "^4.1.0",
        "chalk": "^4.1.0",
        "cli-cursor": "^3.1.0",
        "cli-spinners": "^2.5.0",
        "is-interactive": "^1.0.0",
        "is-unicode-supported": "^0.1.0",
        "log-symbols": "^4.1.0",
        "strip-ansi": "^6.0.0",
        "wcwidth": "^1.0.1"
      }
    },
    "os-tmpdir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz",
      "integrity": "sha1-u+Z0BseaqFxc/sdm/lc0VV36EnQ=",
      "dev": true
    },
    "readable-stream": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
      "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      }
    },
    "restore-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
      "dev": true,
      "requires": {
        "onetime": "^5.1.0",
        "signal-exit": "^3.0.2"
      }
    },
    "run-async": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz",
      "integrity": "sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==",
      "dev": true
    },
    "rxjs": {
      "version": "7.5.5",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.5.5.tgz",
      "integrity": "sha512-sy+H0pQofO95VDmFLzyaw9xNJU4KTRSwQIGM6+iG3SypAtCiLDzpeG8sJrNCWn2Up9km+KhkvTdbkrdy+yzZdw==",
      "dev": true,
      "requires": {
        "tslib": "^2.1.0"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "dev": true
    },
    "signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
      "dev": true
    },
    "string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dev": true,
      "requires": {
        "safe-buffer": "~5.2.0"
      }
    },
    "string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "requires": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      }
    },
    "strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "requires": {
        "ansi-regex": "^5.0.1"
      }
    },
    "supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "requires": {
        "has-flag": "^4.0.0"
      }
    },
    "through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha1-DdTJ/6q8NXlgsbckEV1+Doai4fU=",
      "dev": true
    },
    "tmp": {
      "version": "0.0.33",
      "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz",
      "integrity": "sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==",
      "dev": true,
      "requires": {
        "os-tmpdir": "~1.0.2"
      }
    },
    "tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ==",
      "dev": true
    },
    "type-fest": {
      "version": "0.21.3",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
      "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
      "dev": true
    },
    "util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=",
      "dev": true
    },
    "wcwidth": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/wcwidth/-/wcwidth-1.0.1.tgz",
      "integrity": "sha1-8LDc+RW8X/FSivrbLA4XtTLaL+g=",
      "dev": true,
      "requires": {
        "defaults": "^1.0.3"
      }
    },
    "wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      }
    }
  }
}

'''
'''--- utils/package.json ---
{
  "name": "run-interactive",
  "version": "0.0.1",
  "description": "",
  "main": "testInteractive.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "inquirer": "^8.2.4",
    "inquirer-fuzzy-path": "^2.3.0"
  }
}

'''
'''--- utils/testInteractive.js ---
const inquirer = require('inquirer')
const childProcess = require('child_process')
inquirer.registerPrompt('fuzzypath', require('inquirer-fuzzy-path'))

const adapterPrompt = {
  type: 'fuzzypath',
  name: 'adapterPath',
  excludePath: nodePath => nodePath.startsWith('helper'),
  excludeFilter: nodePath => nodePath == '.',
  itemType: 'any',
  rootPath: 'projects',
  message: 'Select an adapter to run:',
  suggestOnly: false,
  depthLimit: 0,
}
const enableDebugPrompt = {
  type: 'confirm',
  name: 'debugMode',
  message: 'Enable Debug Mode:',
  default: false
}

async function run() {
  let adapterPath
  const { debugMode, ...response } = await inquirer.prompt([
    // enableDebugPrompt, 
    adapterPrompt,
  ])
  adapterPath = response.adapterPath

  while (true) {
    adapterPrompt.default = adapterPath
    await runAdapter(adapterPath, true)
    const answer = await inquirer.prompt([adapterPrompt])
    adapterPath = answer.adapterPath
  }
}

async function runAdapter(adapterPath, debugMode) {
  const startTime = Date.now()
  return new Promise((resolve, reject) => {
    const env = {
      LLAMA_SDK_MAX_PARALLEL: 100,
      LLAMA_DEBUG_MODE: !!debugMode
    }

    const startTime = Date.now()

    const child = childProcess.fork('test.js', [adapterPath], {
      ...process.env,
      env,
    })

    child.on('error', reject)
    child.on('close', function (code) {
      console.log(`
      
      Run time: ${(Date.now() - startTime) / 1000} (seconds)
      
      `)
      resolve()
    })
  })
}

run()
'''
'''--- volume.md ---
#### 1inch
https://api.thegraph.com/subgraphs/name/1inch-exchange/oneinch-liquidity-protocol-v2

#### Balancer
https://api.thegraph.com/subgraphs/name/balancer-labs/balancer

#### Bancor
https://thegraph.com/explorer/subgraph/blocklytics/bancor

#### Curve
https://www.curve.fi/raw-stats/ren-1440m.json //where ren is the pool name

#### Dodo
https://thegraph.com/explorer/subgraph/dodoex/dodoex-v2

#### Dydx
https://docs.dydx.exchange/#get-markets

#### Pancake Swap
https://api.pancakeswap.finance/api/v1/stat

#### Champagne Swap
https://api.thegraph.com/subgraphs/name/champagneswap/exchangev3

#### Perp
https://thegraph.com/explorer/subgraph/perpetual-protocol/perp-position-subgraph
https://perp.gq/pairs

#### Uniswap
https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2

'''