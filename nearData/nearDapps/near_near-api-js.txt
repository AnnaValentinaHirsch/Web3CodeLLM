*GitHub Repository "near/near-api-js"*

'''--- commitlint.config.js ---
module.exports = {
    extends: [
        '@commitlint/config-conventional'
    ],
};

'''
'''--- packages/accounts/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/accounts/test/account.access_key.test.js ---
const { KeyPair } = require('@near-js/crypto');

const testUtils = require('./test-utils');

let nearjs;
let workingAccount;
let contractId;
let contract;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
});

beforeEach(async () => {
    contractId = testUtils.generateUniqueString('test');
    workingAccount = await testUtils.createAccount(nearjs);
    contract = await testUtils.deployContract(nearjs.accountCreator.masterAccount, contractId);
});

test('make function call using access key', async() => {
    const keyPair = KeyPair.fromRandom('ed25519');
    await workingAccount.addKey(keyPair.getPublicKey(), contractId, '', '2000000000000000000000000');

    // Override in the key store the workingAccount key to the given access key.
    await nearjs.connection.signer.keyStore.setKey(testUtils.networkId, workingAccount.accountId, keyPair);
    const setCallValue = testUtils.generateUniqueString('setCallPrefix');
    await contract.setValue({ args: { value: setCallValue } });
    expect(await contract.getValue()).toEqual(setCallValue);
});

test('remove access key no longer works', async() => {
    const keyPair = KeyPair.fromRandom('ed25519');
    let publicKey = keyPair.getPublicKey();
    await nearjs.accountCreator.masterAccount.addKey(publicKey, contractId, '', 400000);
    await nearjs.accountCreator.masterAccount.deleteKey(publicKey);
    // Override in the key store the workingAccount key to the given access key.
    await nearjs.connection.signer.keyStore.setKey(testUtils.networkId, nearjs.accountCreator.masterAccount.accountId, keyPair);
    try {
        await contract.setValue({ args: { value: 'test' } });
        fail('should throw an error');
    } catch (e) {
        expect(e.message).toEqual(`Can not sign transactions for account ${nearjs.accountCreator.masterAccount.accountId} on network ${testUtils.networkId}, no matching key pair exists for this account`);
        expect(e.type).toEqual('KeyNotFound');
    }
    nearjs = await testUtils.setUpTestConnection();
});

test('view account details after adding access keys', async() => {
    const keyPair = KeyPair.fromRandom('ed25519');
    await nearjs.accountCreator.masterAccount.addKey(keyPair.getPublicKey(), contractId, '', 1000000000);

    const contract2 = await testUtils.deployContract(nearjs.accountCreator.masterAccount, testUtils.generateUniqueString('test_contract2'));
    const keyPair2 = KeyPair.fromRandom('ed25519');
    await nearjs.accountCreator.masterAccount.addKey(keyPair2.getPublicKey(), contract2.contractId, '', 2000000000);

    const details = await nearjs.accountCreator.masterAccount.getAccountDetails();
    const expectedResult = {
        authorizedApps: [{
            contractId: contractId,
            amount: '1000000000',
            publicKey: keyPair.getPublicKey().toString(),
        },
        {
            contractId: contract2.contractId,
            amount: '2000000000',
            publicKey: keyPair2.getPublicKey().toString(),
        }],
        transactions: []
    };
    expect(details.authorizedApps).toEqual(jasmine.arrayContaining(expectedResult.authorizedApps));
});

test('loading account after adding a full key', async() => {
    const keyPair = KeyPair.fromRandom('ed25519');
    // wallet calls this with an empty string for contract id and method
    await workingAccount.addKey(keyPair.getPublicKey(), '', '');

    let accessKeys = await workingAccount.getAccessKeys();

    expect(accessKeys.length).toBe(2);
    const addedKey = accessKeys.find(item => item.public_key == keyPair.getPublicKey().toString());
    expect(addedKey).toBeTruthy();
    expect(addedKey.access_key.permission).toEqual('FullAccess');
});

test('load invalid key pair', async() => {
    // Override in the key store with invalid key pair
    await nearjs.connection.signer.keyStore.setKey(testUtils.networkId, nearjs.accountCreator.masterAccount.accountId, '');
    try {
        await contract.setValue({ args: { value: 'test' } });
        fail('should throw an error');
    } catch (e) {
        expect(e.message).toEqual(`no matching key pair found in ${nearjs.connection.signer}`);
        expect(e.type).toEqual('PublicKeyNotFound');
    }
});
'''
'''--- packages/accounts/test/account.test.js ---
const { getTransactionLastResult, Logger } = require('@near-js/utils');
const { actionCreators } = require('@near-js/transactions');
const { TypedError } = require('@near-js/types');
const fs = require('fs');

const { Account, Contract } = require('../lib');
const testUtils  = require('./test-utils');

let nearjs;
let workingAccount;

const { HELLO_WASM_PATH, HELLO_WASM_BALANCE } = testUtils;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
    workingAccount = await testUtils.createAccount(nearjs);
});

afterAll(async () => {
    await workingAccount.deleteAccount(workingAccount.accountId);
});

test('view pre-defined account works and returns correct name', async () => {
    let status = await workingAccount.state();
    expect(status.code_hash).toEqual('11111111111111111111111111111111');
});

test('create account and then view account returns the created account', async () => {
    const newAccountName = testUtils.generateUniqueString('test');
    const newAccountPublicKey = '9AhWenZ3JddamBoyMqnTbp7yVbRuvqAv3zwfrWgfVRJE';
    const { amount } = await workingAccount.state();
    const newAmount = BigInt(amount) / BigInt(10);
    await nearjs.accountCreator.masterAccount.createAccount(newAccountName, newAccountPublicKey, newAmount);
    const newAccount = new Account(nearjs.connection, newAccountName);
    const state = await newAccount.state();
    expect(state.amount).toEqual(newAmount.toString());
});

test('send money', async() => {
    const sender = await testUtils.createAccount(nearjs);
    const receiver = await testUtils.createAccount(nearjs);
    const { amount: receiverAmount } = await receiver.state();
    await sender.sendMoney(receiver.accountId, BigInt(10000));
    const state = await receiver.state();
    expect(state.amount).toEqual((BigInt(receiverAmount) + BigInt(10000)).toString());
});

test('send money through signAndSendTransaction', async() => {
    const sender = await testUtils.createAccount(nearjs);
    const receiver = await testUtils.createAccount(nearjs);
    const { amount: receiverAmount } = await receiver.state();
    await sender.signAndSendTransaction({
        receiverId: receiver.accountId,
        actions: [actionCreators.transfer(BigInt(10000))],
    });
    const state = await receiver.state();
    expect(state.amount).toEqual((BigInt(receiverAmount) + BigInt(10000)).toString());
});

test('delete account', async() => {
    const sender = await testUtils.createAccount(nearjs);
    const receiver = await testUtils.createAccount(nearjs);
    await sender.deleteAccount(receiver.accountId);
    const reloaded = new Account(sender.connection, sender);
    await expect(reloaded.state()).rejects.toThrow();
});

test('multiple parallel transactions', async () => {
    const PARALLEL_NUMBER = 5;
    await Promise.all([...Array(PARALLEL_NUMBER).keys()].map(async (_, i) => {
        const account = new Account(workingAccount.connection, workingAccount.accountId);
        // NOTE: Need to have different transactions outside of nonce, or they all succeed by being identical
        // TODO: Check if randomization of exponential back off helps to do more transactions without exceeding retries
        await account.sendMoney(account.accountId, BigInt(i));
    }));
});

test('findAccessKey returns the same access key when fetched simultaneously', async() => {
    const account = await testUtils.createAccount(nearjs);

    const [key1, key2] = await Promise.all([
        account.findAccessKey(),
        account.findAccessKey()
    ]);

    expect(key1.accessKey).toBe(key2.accessKey);
});

describe('errors', () => {
    let logs;

    beforeAll(async () => {
        const custom = {
            log: (...args) => {
                logs.push(args.join(' '));
            },
            warn: () => {},
            error: () => {},
        };

        Logger.overrideLogger(custom);
    });

    beforeEach(async () => {
        logs = [];

    });

    test('create existing account', async() => {
        await expect(workingAccount.createAccount(workingAccount.accountId, '9AhWenZ3JddamBoyMqnTbp7yVbRuvqAv3zwfrWgfVRJE', 100))
            .rejects.toThrow(/Can't create a new account .+, because it already exists/);
    });
});

describe('with deploy contract', () => {
    let logs;
    let contractId = testUtils.generateUniqueString('test_contract');
    let contract;

    beforeAll(async () => {
        const newPublicKey = await nearjs.connection.signer.createKey(contractId, testUtils.networkId);
        const data = [...fs.readFileSync(HELLO_WASM_PATH)];
        await nearjs.accountCreator.masterAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
        contract = new Contract(nearjs.accountCreator.masterAccount, contractId, {
            viewMethods: ['hello', 'getValue', 'returnHiWithLogs'],
            changeMethods: ['setValue', 'generateLogs', 'triggerAssert', 'testSetRemove', 'crossContract']
        });

        const custom = {
            log: (...args) => {
                logs.push(args.join(' '));
            },
            warn: () => {},
            error: () => {},
        };

        Logger.overrideLogger(custom);
    });

    beforeEach(async () => {
        logs = [];
    });

    test('cross-contact assertion and panic', async () => {
        await expect(contract.crossContract({
            args: {},
            gas: 300000000000000
        })).rejects.toThrow(/Smart contract panicked: expected to fail./);
        expect(logs.length).toEqual(7);
        expect(logs[0]).toMatch(new RegExp('^Receipts: \\w+, \\w+, \\w+$'));
        //  Log [test_contract1591458385248117]: test_contract1591458385248117
        expect(logs[1]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ${contractId}$`));
        expect(logs[2]).toMatch(new RegExp('^Receipt: \\w+$'));
        //   Log [test_contract1591459677449181]: log before planned panic
        expect(logs[3]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: log before planned panic$`));
        expect(logs[4]).toMatch(new RegExp('^Receipt: \\w+$'));
        expect(logs[5]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: log before assert$`));
        expect(logs[6]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ABORT: expected to fail, filename: \\"assembly/index.ts" line: \\d+ col: \\d+$`));
    });

    test('make function calls via account', async() => {
        const result = await workingAccount.viewFunction({
            contractId,
            methodName: 'hello', // this is the function defined in hello.wasm file that we are calling
            args: { name: 'trex' }
        });
        expect(result).toEqual('hello trex');

        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await workingAccount.functionCall({
            contractId,
            methodName: 'setValue',
            args: { value: setCallValue }
        });
        expect(getTransactionLastResult(result2)).toEqual(setCallValue);
        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue'
        })).toEqual(setCallValue);
    });

    test('view contract state', async() => {
        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        await workingAccount.functionCall({
            contractId,
            methodName: 'setValue',
            args: { value: setCallValue }
        });

        const contractAccount = new Account(nearjs.connection, contractId);
        const state = (await contractAccount.viewState('')).map(({ key, value }) => [key.toString('utf-8'), value.toString('utf-8')]);
        expect(state).toEqual([['name', setCallValue]]);
    });

    test('make function calls via account with custom parser', async() => {
        const result = await workingAccount.viewFunction({
            contractId,
            methodName:'hello', // this is the function defined in hello.wasm file that we are calling
            args: { name: 'trex' },
            parse: x => JSON.parse(x.toString()).replace('trex', 'friend')
        });
        expect(result).toEqual('hello friend');
    });

    test('make function calls via contract', async() => {
        const result = await contract.hello({ name: 'trex' });
        expect(result).toEqual('hello trex');

        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await contract.setValue({ args: { value: setCallValue } });
        expect(result2).toEqual(setCallValue);
        expect(await contract.getValue()).toEqual(setCallValue);
    });

    test('view function calls by block Id and finality', async() => {
        const setCallValue1 = testUtils.generateUniqueString('setCallPrefix');
        const result1 = await contract.setValue({ args: { value: setCallValue1 } });
        expect(result1).toEqual(setCallValue1);
        expect(await contract.getValue()).toEqual(setCallValue1);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { finality: 'optimistic' },
        })).toEqual(setCallValue1);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue'
        })).toEqual(setCallValue1);

        const block1 = await workingAccount.connection.provider.block({ finality: 'optimistic' });
        const blockHash1 = block1.header.hash;
        const blockIndex1 = block1.header.height;

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockHash1 },
        })).toEqual(setCallValue1);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockIndex1 },
        })).toEqual(setCallValue1);

        const setCallValue2 = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await contract.setValue({ args: { value: setCallValue2 } });
        expect(result2).toEqual(setCallValue2);
        expect(await contract.getValue()).toEqual(setCallValue2);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { finality: 'optimistic' },
        })).toEqual(setCallValue2);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue'
        })).toEqual(setCallValue2);

        // Old blockHash should still be value #1
        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockHash1 },
        })).toEqual(setCallValue1);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockIndex1 },
        })).toEqual(setCallValue1);

        const block2 = await workingAccount.connection.provider.block({ finality: 'optimistic' });
        const blockHash2 = block2.header.hash;
        const blockIndex2 = block2.header.height;

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockHash2 },
        })).toEqual(setCallValue2);

        expect(await workingAccount.viewFunction({
            contractId,
            methodName: 'getValue',
            blockQuery: { blockId: blockIndex2 },
        })).toEqual(setCallValue2);
    });

    test('make function calls via contract with gas', async() => {
        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await contract.setValue({
            args: { value: setCallValue },
            gas: 1000000 * 1000000
        });
        expect(result2).toEqual(setCallValue);
        expect(await contract.getValue()).toEqual(setCallValue);
    });

    test('can get logs from method result', async () => {
        await contract.generateLogs();
        expect(logs.length).toEqual(3);
        expect(logs[0].substr(0, 8)).toEqual('Receipt:');
        expect(logs.slice(1)).toEqual([`\tLog [${contractId}]: log1`, `\tLog [${contractId}]: log2`]);
    });

    test('can get logs from view call', async () => {
        let result = await contract.returnHiWithLogs();
        expect(result).toEqual('Hi');
        expect(logs).toEqual([`Log [${contractId}]: loooog1`, `Log [${contractId}]: loooog2`]);
    });

    test('can get assert message from method result', async () => {
        await expect(contract.triggerAssert()).rejects.toThrow(/Smart contract panicked: expected to fail.+/);
        expect(logs[1]).toEqual(`\tLog [${contractId}]: log before assert`);
        expect(logs[2]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ABORT: expected to fail, filename: \\"assembly/index.ts" line: \\d+ col: \\d+$`));
    });

    test('test set/remove', async () => {
        await contract.testSetRemove({
            args: { value: '123' }
        });
    });

    test('can have view methods only', async () => {
        const contract = new Contract(workingAccount, contractId, {
            viewMethods: ['hello'],
        });
        expect(await contract.hello({ name: 'world' })).toEqual('hello world');
    });

    test('can have change methods only', async () => {
        const contract = new Contract(workingAccount, contractId, {
            changeMethods: ['hello'],
        });
        expect(await contract.hello({
            args: { name: 'world' }
        })).toEqual('hello world');
    });

    test('make viewFunction call with object format', async() => {
        const result = await workingAccount.viewFunction({
            contractId,
            methodName: 'hello', // this is the function defined in hello.wasm file that we are calling
            args: { name: 'trex' },
        });
        expect(result).toEqual('hello trex');
    });

    test('get total stake balance and validator responses', async() => {
        const CUSTOM_ERROR = new TypedError('Querying failed: wasm execution failed with error: FunctionCallError(CompilationError(CodeDoesNotExist { account_id: AccountId("invalid_account_id") })).', 'UntypedError');
        const mockConnection = {
            ...nearjs.connection,
            provider: {
                ...nearjs.connection.provider,
                validators: () => ({
                    current_validators: [
                        {
                            account_id: 'testing1.pool.f863973.m0',
                            is_slashed: false,
                            num_expected_blocks: 7,
                            num_expected_chunks: 19,
                            num_produced_blocks: 7,
                            num_produced_chunks: 18,
                            public_key: 'ed25519:5QzHuNZ4stznMwf3xbDfYGUbjVt8w48q8hinDRmVx41z',
                            shards: [ 1 ],
                            stake: '73527610191458905577047103204'
                        },
                        {
                            account_id: 'testing2.pool.f863973.m0',
                            is_slashed: false,
                            num_expected_blocks: 4,
                            num_expected_chunks: 22,
                            num_produced_blocks: 4,
                            num_produced_chunks: 20,
                            public_key: 'ed25519:9SYKubUbsGVfxrMGaJ9tLMEfPdjD55FLqGoqy3cTnRm6',
                            shards: [ 2 ],
                            stake: '74531922534760985104659653178'
                        },
                        {
                            account_id: 'invalid_account_id',
                            is_slashed: false,
                            num_expected_blocks: 4,
                            num_expected_chunks: 22,
                            num_produced_blocks: 4,
                            num_produced_chunks: 20,
                            public_key: 'ed25519:9SYKubUbsGVfxrMGaJ9tLMEfPdjD55FLqGoqy3cTnRm6',
                            shards: [ 2 ],
                            stake: '0'
                        },
                    ],
                    next_validators: [],
                    current_proposals: [],
                }),
            },
        };

        const account = new Account(mockConnection, 'test.near');
        // mock internal functions that are being used on getActiveDelegatedStakeBalance
        account.viewFunction = async ({ methodName, ...args }) => {
            if (methodName === 'get_account_total_balance') {
                // getActiveDelegatedStakeBalance sums stake from active validators and ignores throws
                if (args.contractId === 'invalid_account_id') {
                    throw CUSTOM_ERROR;
                }
                return Promise.resolve('10000');
            } else {
                return await account.viewFunction({ methodName, ...args });
            }
        };
        account.connection.provider.block = async () => {
            return Promise.resolve({ header: { hash: 'dontcare' } });
        };
        const result = await account.getActiveDelegatedStakeBalance();
        expect(result).toEqual({
            stakedValidators: [{ validatorId: 'testing1.pool.f863973.m0', amount: '10000' }, { validatorId: 'testing2.pool.f863973.m0', amount: '10000' }],
            failedValidators: [{ validatorId: 'invalid_account_id', error: CUSTOM_ERROR }],
            total: '20000'
        });
    });
    test('Fail to get total stake balance upon timeout error', async () => {
        const ERROR_MESSAGE = 'Failed to get delegated stake balance';
        const CUSTOM_ERROR = new TypedError('RPC DOWN', 'TimeoutError');
        const mockConnection = {
            ...nearjs.connection,
            provider: {
                ...nearjs.connection.provider,
                validators: () => ({
                    current_validators: [
                        {
                            account_id: 'timeout_account_id',
                            is_slashed: false,
                            num_expected_blocks: 4,
                            num_expected_chunks: 22,
                            num_produced_blocks: 4,
                            num_produced_chunks: 20,
                            public_key: 'ed25519:9SYKubUbsGVfxrMGaJ9tLMEfPdjD55FLqGoqy3cTnRm6',
                            shards: [ 2 ],
                            stake: '0'
                        },
                    ],
                    next_validators: [],
                    current_proposals: [],
                }),
            },
        };

        const account = new Account(mockConnection, 'test.near');
        // mock internal functions that are being used on getActiveDelegatedStakeBalance
        account.viewFunction = async ({ methodName, ...args }) => {
            if (methodName === 'get_account_total_balance') {
                // getActiveDelegatedStakeBalance sums stake from active validators and ignores throws
                if (args.contractId === 'timeout_account_id') {
                    throw CUSTOM_ERROR;
                }
                return Promise.resolve('10000');
            } else {
                return await account.viewFunction({ methodName, ...args });
            }
        };
        account.connection.provider.block = async () => {
            return Promise.resolve({ header: { hash: 'dontcare' } });
        };

        try {
            await account.getActiveDelegatedStakeBalance();
        } catch(e) {
            expect(e).toEqual(new Error(ERROR_MESSAGE));
        }
    });
});

'''
'''--- packages/accounts/test/account_multisig.test.js ---
const { parseNearAmount } = require('@near-js/utils');
const { KeyPair } = require('@near-js/crypto');
const { InMemorySigner } = require('@near-js/signers');
const { actionCreators } = require('@near-js/transactions');
const fs = require('fs');
const semver = require('semver');

const { Account2FA, MULTISIG_DEPOSIT, MULTISIG_GAS, MultisigStateStatus } = require('../lib');
const testUtils  = require('./test-utils');

const { functionCall, transfer } = actionCreators;

let nearjs;
let startFromVersion;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

const getAccount2FA = async (account, keyMapping = ({ public_key: publicKey }) => ({ publicKey, kind: 'phone' })) => {
    // modifiers to functions replaces contract helper (CH)
    const { accountId } = account;
    const keys = await account.getAccessKeys();
    const account2fa = new Account2FA(nearjs.connection, accountId, {
        // skip this (not using CH)
        getCode: () => {},
        sendCode: () => {},
        // auto accept "code"
        verifyCode: () => ({  }), // TODO: Is there any content needed in result?
        onAddRequestResult: async () => {
            const { requestId } = account2fa.getRequest();
            // set confirmKey as signer
            const originalSigner = nearjs.connection.signer;
            nearjs.connection.signer = await InMemorySigner.fromKeyPair(nearjs.connection.networkId, accountId, account2fa.confirmKey);
            // 2nd confirmation signing with confirmKey from Account instance
            await account.signAndSendTransaction({
                receiverId: accountId,
                actions: [
                    functionCall('confirm', { request_id: requestId }, MULTISIG_GAS, MULTISIG_DEPOSIT)
                ]
            });
            nearjs.connection.signer = originalSigner;
        }
    });
    account2fa.confirmKey = KeyPair.fromRandom('ed25519');
    account2fa.postSignedJson = () => ({ publicKey: account2fa.confirmKey.getPublicKey() });
    account2fa.getRecoveryMethods = () => ({
        data: keys.map(keyMapping)
    });
    account2fa.checkMultisigCodeAndStateStatus = () => ({ codeStatus: 1, stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED });
    await account2fa.deployMultisig([...fs.readFileSync('./test/wasm/multisig.wasm')]);
    return account2fa;
};

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
    let nodeStatus = await nearjs.connection.provider.status();
    startFromVersion = (version) => semver.gte(nodeStatus.version.version, version);
    console.log(startFromVersion);
});

describe('deployMultisig key rotations', () => {

    test('full access key if recovery method is "ledger" or "phrase", limited access key if "phone"', async () => {
        const account = await testUtils.createAccount(nearjs);
        await account.addKey(KeyPair.fromRandom('ed25519').getPublicKey());
        await account.addKey(KeyPair.fromRandom('ed25519').getPublicKey());
        const keys = await account.getAccessKeys();
        const kinds = ['ledger', 'phrase', 'phone'];
        const account2fa = await getAccount2FA(
            account,
            ({ public_key: publicKey }, i) => ({ publicKey, kind: kinds[i] })
        );
        const currentKeys = await account2fa.getAccessKeys();
        expect(currentKeys.find(({ public_key }) => keys[0].public_key === public_key).access_key.permission).toEqual('FullAccess');
        expect(currentKeys.find(({ public_key }) => keys[1].public_key === public_key).access_key.permission).toEqual('FullAccess');
        expect(currentKeys.find(({ public_key }) => keys[2].public_key === public_key).access_key.permission).not.toEqual('FullAccess');
    });
    
});

describe('account2fa transactions', () => {

    test('add app key before deployMultisig', async() => {
        let account = await testUtils.createAccount(nearjs);
        const appPublicKey = KeyPair.fromRandom('ed25519').getPublicKey();
        const appAccountId = 'foobar';
        const appMethodNames = ['some_app_stuff','some_more_app_stuff'];
        await account.addKey(appPublicKey.toString(), appAccountId, appMethodNames, BigInt(parseNearAmount('0.25')));
        account = await getAccount2FA(account);
        const keys = await account.getAccessKeys();
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.method_names).toEqual(appMethodNames);
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.receiver_id).toEqual(appAccountId);
    });

    test('add app key', async() => {
        let account = await testUtils.createAccount(nearjs);
        account = await getAccount2FA(account);
        const appPublicKey = KeyPair.fromRandom('ed25519').getPublicKey();
        const appAccountId = 'foobar';
        const appMethodNames = ['some_app_stuff', 'some_more_app_stuff'];
        await account.addKey(appPublicKey.toString(), appAccountId, appMethodNames, BigInt(parseNearAmount('0.25')));
        const keys = await account.getAccessKeys();
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.method_names).toEqual(appMethodNames);
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.receiver_id).toEqual(appAccountId);
    });

    test('send money', async() => {
        let sender = await testUtils.createAccount(nearjs);
        let receiver = await testUtils.createAccount(nearjs);
        sender = await getAccount2FA(sender);
        receiver = await getAccount2FA(receiver);
        const { amount: receiverAmount } = await receiver.state();
        await sender.sendMoney(receiver.accountId, BigInt(parseNearAmount('1')));
        const state = await receiver.state();
        expect(BigInt(state.amount)).toBeGreaterThanOrEqual(BigInt(receiverAmount)+ BigInt(parseNearAmount('0.9').toString()));
    });

    test('send money through signAndSendTransaction', async() => {
        let sender = await testUtils.createAccount(nearjs);
        let receiver = await testUtils.createAccount(nearjs);
        sender = await getAccount2FA(sender);
        receiver = await getAccount2FA(receiver);
        const { amount: receiverAmount } = await receiver.state();
        await sender.signAndSendTransaction({ receiverId: receiver.accountId, actions: [transfer(BigInt(parseNearAmount('1')))] });
        const state = await receiver.state();
        expect(BigInt(state.amount)).toBeGreaterThanOrEqual(BigInt(receiverAmount) + BigInt(parseNearAmount('0.9').toString()));
    });
        
});

'''
'''--- packages/accounts/test/config.js ---
const { Worker } = require('near-workspaces');
const fs = require('fs');
let worker;
module.exports = async function getConfig(env) {
    switch (env) {
        case 'production':
        case 'mainnet':
            return {
                networkId: 'mainnet',
                nodeUrl: 'https://rpc.mainnet.near.org',
                walletUrl: 'https://wallet.near.org',
                helperUrl: 'https://helper.mainnet.near.org',
            };
        case 'development':
        case 'testnet':
            return {
                networkId: 'default',
                nodeUrl: 'https://rpc.testnet.near.org',
                walletUrl: 'https://wallet.testnet.near.org',
                helperUrl: 'https://helper.testnet.near.org',
                masterAccount: 'test.near',
            };
        case 'betanet':
            return {
                networkId: 'betanet',
                nodeUrl: 'https://rpc.betanet.near.org',
                walletUrl: 'https://wallet.betanet.near.org',
                helperUrl: 'https://helper.betanet.near.org',
            };
        case 'local':
            return {
                networkId: 'local',
                nodeUrl: 'http://localhost:3030',
                keyPath: `${process.env.HOME}/.near/validator_key.json`,
                walletUrl: 'http://localhost:4000/wallet',
            };
        case 'test':
        case 'ci': {
            if (!worker) worker = await Worker.init();
            const keyFile = fs.readFileSync(`${worker.rootAccount.manager.config.homeDir}/validator_key.json`);
            const keyPair = JSON.parse(keyFile.toString());
            return {
                networkId: worker.config.network,
                nodeUrl: worker.manager.config.rpcAddr,
                masterAccount: worker.rootAccount._accountId,
                secretKey: keyPair.secret_key || keyPair.private_key
            };
        }
        default:
            throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
    }
};

'''
'''--- packages/accounts/test/contract.test.js ---
const { PositionalArgsError } = require('@near-js/types');

const { Contract, Account } = require('../lib');
const testUtils  = require('./test-utils');

const account = Object.setPrototypeOf({
    getConnection() {
        return {};
    },
    viewFunction({ contractId, methodName, args, parse, stringify, jsContract, blockQuery }) {
        return { this: this, contractId, methodName, args, parse, stringify, jsContract, blockQuery };
    },
    functionCall() {
        return this;
    }
}, Account.prototype);

const contract = new Contract(account, 'contractId', {
    viewMethods: ['viewMethod'],
    changeMethods: ['changeMethod'],
});

['viewMethod', 'changeMethod'].forEach(method => {
    describe(method, () => {
        test('returns what you expect for .name', () => {
            expect(contract[method].name).toBe(method);
        });

        test('maintains correct reference to `this` when passed around an application', async () => {
            function callFuncInNewContext(fn) {
                return fn();
            }
            expect(await callFuncInNewContext(contract[method]));
        });

        test('throws PositionalArgsError if first argument is not an object', async() => {
            await expect(contract[method](1)).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method]('lol')).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method]([])).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](new Date())).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](null)).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](new Set())).rejects.toBeInstanceOf(PositionalArgsError);
        });

        test('throws PositionalArgsError if given too many arguments', () => {
            return expect(contract[method]({}, 1, 0, 'oops')).rejects.toBeInstanceOf(PositionalArgsError);
        });

        test('allows args encoded as Uint8Array (for borsh)', async () => {
            expect(await contract[method](new Uint8Array()));
        });
    });
});

describe('viewMethod', () => {
    test('passes options through to account viewFunction', async () => {
        function customParser () {}
        const stubbedReturnValue = await account.viewFunction({ parse: customParser });
        expect(stubbedReturnValue.parse).toBe(customParser);
    });

    describe.each([
        1,
        'lol',
        [],
        new Date(),
        null,
        new Set(),
    ])('throws PositionalArgsError if 2nd arg is not an object', badArg => {
        test(String(badArg), async () => {
            try {
                await contract.viewMethod({ a: 1 }, badArg);
                throw new Error(`Calling \`contract.viewMethod({ a: 1 }, ${badArg})\` worked. It shouldn't have worked.`);
            } catch (e) {
                if (!(e instanceof PositionalArgsError)) throw e;
            }
        });
    });
});

describe('changeMethod', () => {
    test('throws error message for invalid gas argument', () => {
        return expect(contract.changeMethod({ a: 1 }, 'whatever')).rejects.toThrow(/Expected number, decimal string or BigInt for 'gas' argument, but got.+/);
    });

    test('gives error message for invalid amount argument', () => {
        return expect(contract.changeMethod({ a: 1 }, 1000, 'whatever')).rejects.toThrow(/Expected number, decimal string or BigInt for 'amount' argument, but got.+/);
    });

    test('makes a functionCall and passes along walletCallbackUrl and walletMeta', async() => {
        account.functionCall = jest.fn(() => Promise.resolve(account));
        await contract.changeMethod({
            args: {},
            meta: 'someMeta',
            callbackUrl: 'http://neartest.test/somepath?and=query',
        });

        expect(account.functionCall).toHaveBeenCalledWith({
            args: {},
            contractId: 'contractId',
            methodName: 'changeMethod',
            walletMeta: 'someMeta',
            walletCallbackUrl: 'http://neartest.test/somepath?and=query'
        });
    });
});

describe('local view execution', () => {
    let nearjs;
    let contract;
    let blockQuery;

    jest.setTimeout(60000);

    beforeAll(async () => {
        nearjs = await testUtils.setUpTestConnection();
        contract = await testUtils.deployContractGuestBook(nearjs.accountCreator.masterAccount, testUtils.generateUniqueString('guestbook'));
        
        await contract.add_message({ text: 'first message' });
        await contract.add_message({ text: 'second message' });
        
        const block = await contract.account.connection.provider.block({ finality: 'optimistic' });

        contract.account.connection.provider.query = jest.fn(contract.account.connection.provider.query);
        blockQuery = { blockId: block.header.height };
    });
    
    afterEach(() => {
        jest.clearAllMocks();
    });

    test('calls total_messages() function using RPC provider', async () => {
        const totalMessages = await contract.total_messages({}, { blockQuery });

        expect(contract.account.connection.provider.query).toHaveBeenCalledWith({
            request_type: 'view_code',
            account_id: contract.contractId,
            ...blockQuery,
        });
        expect(totalMessages).toBe(2);
    });

    test('calls total_messages() function using cache data', async () => {
        const totalMessages = await contract.total_messages({}, { blockQuery });

        expect(contract.account.connection.provider.query).not.toHaveBeenCalled();
        expect(totalMessages).toBe(2);
    });

    test('calls get_messages() function using cache data', async () => {
        const messages = await contract.get_messages({}, { blockQuery });

        expect(contract.account.connection.provider.query).not.toHaveBeenCalled();
        expect(messages.length).toBe(2);
        expect(messages[0].text).toEqual('first message');
        expect(messages[1].text).toEqual('second message');
    });

    test('local execution fails and fallbacks to normal RPC call', async () => {
        const _contract = new Contract(contract.account, contract.contractId, { viewMethods: ['get_msg'], useLocalViewExecution: true });
        _contract.account.viewFunction = jest.fn(_contract.account.viewFunction);

        try {
            await _contract.get_msg({}, { blockQuery });
        } catch (error) {
            expect(_contract.account.viewFunction).toHaveBeenCalledWith({
                contractId: _contract.contractId,
                methodName: 'get_msg',
                args: {},
                blockQuery,
            });
        }
    }); 
});

describe('contract without account', () => {
    let nearjs;
    let contract;

    jest.setTimeout(60000);

    beforeAll(async () => {
        nearjs = await testUtils.setUpTestConnection();
        const contractId = testUtils.generateUniqueString('guestbook');
        await testUtils.deployContractGuestBook(nearjs.accountCreator.masterAccount, contractId);

        contract = new Contract(nearjs.connection, contractId, {
            viewMethods: ['total_messages', 'get_messages'],
            changeMethods: ['add_message'],
        });
    });

    test('view & change methods work', async () => {
        const totalMessagesBefore = await contract.total_messages({});
        expect(totalMessagesBefore).toBe(0);

        await contract.add_message({
            signerAccount: nearjs.accountCreator.masterAccount,
            args: {
                text: 'first message',
            }
        });
        await contract.add_message({
            signerAccount: nearjs.accountCreator.masterAccount,
            args: {
                text: 'second message',
            }
        });

        const totalMessagesAfter = await contract.total_messages({});
        expect(totalMessagesAfter).toBe(2);

        const messages = await contract.get_messages({});
        expect(messages.length).toBe(2);
        expect(messages[0].text).toEqual('first message');
        expect(messages[1].text).toEqual('second message');
    });

    test('fails to call add_message() without signerAccount', async () => {
        await expect(
            contract.add_message({ text: 'third message' })
        ).rejects.toThrow(/signerAccount must be specified/);
    });
});

'''
'''--- packages/accounts/test/contract_abi.test.js ---
const { Account, Contract, ArgumentSchemaError, UnknownArgumentError, UnsupportedSerializationError } = require('../lib');

let rawAbi = `{
  "schema_version": "0.3.0",
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      },
      {
        "name": "add_call",
        "doc": " Adds two pairs point-wise.",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      },
      {
        "name": "empty_call",
        "kind": "call"
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}`;

const account = Object.setPrototypeOf({
    getConnection() {
        return {};
    },
    viewFunction({ contractId, methodName, args, parse, stringify, jsContract, blockQuery }) {
        return { this: this, contractId, methodName, args, parse, stringify, jsContract, blockQuery };
    },
    functionCall() {
        return this;
    }
}, Account.prototype);

const abi = JSON.parse(rawAbi);

const contract = new Contract(account, 'contractId', {
    abi
});

describe('add', () => {
    test('can be called successfully', async () => {
        await contract.add({ a: [1, 2], b: [3, 4] });
    });

    test('throws ArgumentSchemaError if required argument was not supplied', async () => {
        await expect(contract.add({})).rejects.toBeInstanceOf(ArgumentSchemaError);
    });

    test('throws ArgumentSchemaError if argument has unexpected type', async () => {
        await expect(contract.add({ a: 1, b: [3, 4] })).rejects.toBeInstanceOf(ArgumentSchemaError);
    });

    test('throws UnknownArgumentError if unknown argument was supplied', async () => {
        await expect(contract.add({ a: [1, 2], b: [3, 4], c: 5 })).rejects.toBeInstanceOf(UnknownArgumentError);
    });
});

describe('add_call', () => {
    test('can be called successfully', async () => {
        await contract.add_call({ args: { a: [1, 2], b: [3, 4] } });
    });

    test('throws ArgumentSchemaError if required argument was not supplied', async () => {
        await expect(contract.add_call({ args: {} })).rejects.toBeInstanceOf(ArgumentSchemaError);
    });

    test('throws ArgumentSchemaError if argument has unexpected type', async () => {
        await expect(contract.add_call({ args: { a: 1, b: [3, 4] } })).rejects.toBeInstanceOf(ArgumentSchemaError);
    });

    test('throws UnknownArgumentError if unknown argument was supplied', async () => {
        await expect(contract.add_call({ args: { a: [1, 2], b: [3, 4], c: 5 } })).rejects.toBeInstanceOf(UnknownArgumentError);
    });
});

describe('empty_call', () => {
    test('can be called successfully', async () => {
        await contract.empty_call({});
    });
});

describe('Contract constructor', () => {
    test('throws UnsupportedSerializationError when ABI has borsh serialization', async () => {
        let rawAbi = `{
                "schema_version": "0.3.0",
                "body": {
                  "functions": [
                    {
                      "name": "add",
                      "kind": "view",
                      "params": {
                        "serialization_type": "borsh",
                        "args": [
                          {
                            "name": "b",
                            "type_schema": {
                              "type": "integer"
                            }
                          }
                        ]
                      }
                    }
                  ],
                  "root_schema": {
                    "$schema": "http://json-schema.org/draft-07/schema#",
                    "title": "String",
                    "type": "string"
                  }
                }
              }`;
        const contract = new Contract(account, 'contractId', { abi: JSON.parse(rawAbi) });
        await expect(contract.add({ a: 1 })).rejects.toBeInstanceOf(UnsupportedSerializationError);
    });
});

'''
'''--- packages/accounts/test/lve_runtime.test.js ---
const {
    GUESTBOOK_CONTRACT_ID,
    GUESTBOOK_CONTRACT_STATE,
    loadGuestBookContractCode,
} = require('./test-utils');
const { Runtime } = require('../lib/local-view-execution/runtime');

let contractCode;
const blockHeight = 1;
const blockTimestamp = Math.floor(Date.now() * 1000000);
const contractState = GUESTBOOK_CONTRACT_STATE;

const parse = (result) => JSON.parse(Buffer.from(result).toString());

const newRuntime = (methodArgs = {}) => {
    methodArgs = JSON.stringify(methodArgs);

    return new Runtime({
        contractId: GUESTBOOK_CONTRACT_ID,
        contractCode,
        contractState,
        blockHeight,
        blockTimestamp,
        methodArgs,
    });
};

describe('Local View Execution - Runtime', () => {
    beforeAll(async () => {
        contractCode = await loadGuestBookContractCode();
    });

    test('execute total_messages function in WASM runtime', async () => {
        const methodName = 'total_messages';
        const methodArgs = {};

        const runtime = newRuntime(methodArgs);

        const { result } = await runtime.execute(methodName);

        expect(parse(result)).toBe(2);
    });

    test('execute get_messages(0, 1) function in WASM runtime', async () => {
        const methodName = 'get_messages';
        const methodArgs = { from_index: 0, limit: 1 };

        const runtime = newRuntime(methodArgs);

        const { result } = await runtime.execute(methodName);
        const expected = contractState[1].value; // '{\'premium\':true,\'sender\':\'dev-1688987398360-47112266275867\',\'text\':\'a message\'}'

        expect(parse(result)).toEqual([parse(expected)]);
    });

    test('executes get_messages(0, 10) function in WASM runtime', async () => {
        const methodName = 'get_messages';
        const methodArgs = { from_index: 0, limit: 10 };

        const runtime = newRuntime(methodArgs);

        const { result } = await runtime.execute(methodName);

        expect(parse(result)).toEqual([
            parse(contractState[1].value),
            parse(contractState[2].value),
        ]);
    });

    test('executes get_messages(1, 1) function in WASM runtime', async () => {
        const methodName = 'get_messages';
        const methodArgs = { from_index: 1, limit: 1 };

        const runtime = newRuntime(methodArgs);

        const { result } = await runtime.execute(methodName);

        expect(parse(result)).toEqual([parse(contractState[2].value)]);
    });

    test('executes get_messages({}) function with ignored args in WASM runtime', async () => {
        const methodName = 'get_messages';
        const methodArgs = { fromInde: 0, Limit: 1 };

        const runtime = newRuntime(methodArgs);

        const { result } = await runtime.execute(methodName);

        expect(parse(result)).toEqual([
            parse(contractState[1].value),
            parse(contractState[2].value),
        ]);
    });

    test('throws UnknownContractMethodError on non-existing function from WASM runtime', async () => {
        const methodName = 'unknown_method';
        const methodArgs = { from_index: 1, limit: 1 };

        const runtime = newRuntime(methodArgs);

        await expect(runtime.execute(methodName)).rejects.toThrow();
    });
});

'''
'''--- packages/accounts/test/lve_storage.test.js ---
const crypto = require('crypto');
const { Storage } = require('../lib/local-view-execution/storage');
const {
    GUESTBOOK_CONTRACT_STATE,
    loadGuestBookContractCode,
} = require('./test-utils');

let contractCode;
const contractState = GUESTBOOK_CONTRACT_STATE;
const blockHash = 'G2DF9Pe4KegQK7PkcxDu5cxakvcy99zgrFZEadRCxrwF';

const blockHeight = 1;
const blockTimestamp = Math.floor(Date.now() * 1000000);

const createBlockHash = (data) =>
    crypto.createHash('sha256').update(JSON.stringify(data)).digest('base64');

describe('Local View Execution - Storage', () => {
    beforeAll(async () => {
        contractCode = await loadGuestBookContractCode();
    });

    test('load empty cached data', async () => {
        const storage = new Storage();

        const data = storage.load({});

        expect(data).toBe(undefined);
    });

    test('load empty cached data by block hash', async () => {
        const storage = new Storage();

        const data = storage.load({ blockId: blockHash });

        expect(data).toBe(undefined);
    });

    test('load empty cached data by block height', async () => {
        const storage = new Storage();

        const data = storage.load({ blockId: blockHeight });

        expect(data).toBe(undefined);
    });

    test('save & load cached data by block height', async () => {
        const storage = new Storage();
        const data = {
            blockHeight,
            blockTimestamp,
            contractCode,
            contractState,
        };

        storage.save(blockHash, data);

        const stored = storage.load({ blockId: blockHeight });

        expect(stored).toEqual(data);
    });

    test('save & load cached data by block hash', async () => {
        const storage = new Storage();
        const data = {
            blockHeight,
            blockTimestamp,
            contractCode,
            contractState,
        };

        storage.save(blockHash, data);

        const stored = storage.load({ blockId: blockHash });

        expect(stored).toEqual(data);
    });

    test('overwrite the less-recently used value', async () => {
        const storage = new Storage({ max: 2 });

        const data = {
            blockHeight,
            blockTimestamp,
            contractCode,
            contractState,
        };

        const firstData = { ...data, blockHeight: 0 };
        const secondData = { ...data, blockHeight: 1 };
        const newData = { ...data, blockHeight: 2 };

        storage.save(createBlockHash(firstData), firstData);
        storage.save(createBlockHash(secondData), secondData);

        // the less-recently used value
        expect(storage.load({ blockId: 0 })).toEqual(firstData);
        expect(storage.load({ blockId: 1 })).toEqual(secondData);

        storage.save(createBlockHash(newData), newData);

        expect(storage.load({ blockId: 0 })).toBe(undefined);
        expect(storage.load({ blockId: 1 })).toEqual(secondData);
        expect(storage.load({ blockId: 2 })).toEqual(newData);
    });
});

'''
'''--- packages/accounts/test/promise.test.js ---
const testUtils = require('./test-utils');

let nearjs;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 120000;

const CONTRACT_CALL_GAS = BigInt(300000000000000);

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
});

describe('with promises', () => {
    let contract, contract1, contract2;
    let oldLog;
    let logs;
    let contractName = testUtils.generateUniqueString('cnt');
    let contractName1 = testUtils.generateUniqueString('cnt');
    let contractName2 = testUtils.generateUniqueString('cnt');

    beforeAll(async () => {
        contract = await testUtils.deployContract(nearjs.accountCreator.masterAccount, contractName);
        contract1 = await testUtils.deployContract(nearjs.accountCreator.masterAccount, contractName1);
        contract2 = await testUtils.deployContract(nearjs.accountCreator.masterAccount, contractName2);
    });

    beforeEach(async () => {
        oldLog = console.log;
        logs = [];
        console.log = function() {
            logs.push(Array.from(arguments).join(' '));
        };
    });

    afterEach(async () => {
        console.log = oldLog;
    });

    // -> means async call
    // => means callback

    test('single promise, no callback (A->B)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callbackWithName',
                    args: null,
                    gas: '3000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '0',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult = await contract1.getLastResult();
        expect(lastResult).toEqual({
            rs: [],
            n: contractName1,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('single promise with callback (A->B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callbackWithName',
                    args: null,
                    gas: '3000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '2000000000000', 
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('two promises, no callbacks (A->B->C)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: null,
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '60000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '60000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        expect(realResult).toEqual(lastResult2);
    });

    test('two promises, with two callbacks (A->B->C=>B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('cross contract call with callbacks (A->B->A=>B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '40000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: {
                    rs: [],
                    n: contractName,
                },
            }],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('2 promises with 1 skipped callbacks (A->B->C=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '20000000000000',
                        balance: '0',
                        callback: null,
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '50000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000'
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('two promises, with one callbacks to B only (A->B->C=>B)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '40000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '0',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName1,
        });
        expect(realResult).toEqual(lastResult1);
    });

});

'''
'''--- packages/accounts/test/providers.test.js ---
const base58 = require('bs58');

const testUtils = require('./test-utils');
const { KeyPair } = require('@near-js/crypto');
let ERRORS_JSON = require('../../utils/lib/errors/error_messages.json');

jest.setTimeout(60000);

let provider;
let near;

beforeAll(async () => {
    near = await testUtils.setUpTestConnection();
    provider = near.connection.provider;
});

describe('providers', () => {
    test('txStatus with string hash and buffer hash', async () => {
        const sender = await testUtils.createAccount(near);
        const receiver = await testUtils.createAccount(near);
        const outcome = await sender.sendMoney(receiver.accountId, BigInt('1'));
        const responseWithString = await provider.txStatus(outcome.transaction.hash, sender.accountId);
        const responseWithUint8Array = await provider.txStatus(base58.decode(outcome.transaction.hash), sender.accountId);
        expect(responseWithString).toMatchObject(outcome);
        expect(responseWithUint8Array).toMatchObject(outcome);
    });
    
    test('txStatusReciept with string hash and buffer hash', async () => {
        const sender = await testUtils.createAccount(near);
        const receiver = await testUtils.createAccount(near);
        const outcome = await sender.sendMoney(receiver.accountId, BigInt('1'));
        const reciepts = await provider.sendJsonRpc('EXPERIMENTAL_tx_status', [outcome.transaction.hash, sender.accountId]);
    
        const responseWithString = await provider.txStatusReceipts(outcome.transaction.hash, sender.accountId);
        const responseWithUint8Array = await provider.txStatusReceipts(base58.decode(outcome.transaction.hash), sender.accountId);
        expect('transaction_outcome' in responseWithString).toBeTruthy();
        expect('logs' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect('receipt_ids' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect('gas_burnt' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect('tokens_burnt' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect('executor_id' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect('status' in responseWithString.transaction_outcome.outcome).toBeTruthy();
        expect(responseWithString).toMatchObject(reciepts);
        expect(responseWithUint8Array).toMatchObject(reciepts);
    });
    
    test('json rpc query account', async () => {
        const account = await testUtils.createAccount(near);
        let response = await provider.query({ 
            request_type: 'view_account',
            finality: 'optimistic',
            account_id: account.accountId });
        expect(response.code_hash).toEqual('11111111111111111111111111111111');
    });
    
    test('json rpc query view_state', async () => {
        const contract = await testUtils.deployContract(near.accountCreator.masterAccount, testUtils.generateUniqueString('test'));
    
        await contract.setValue({ args: { value: 'hello' } });
    
        return testUtils.waitFor(async () => {
            const response = await provider.query({
                request_type: 'view_state',
                finality: 'final',
                account_id: contract.contractId,
                prefix_base64: ''
            });
            expect(response).toEqual({
                block_height: expect.any(Number),
                block_hash: expect.any(String),
                values: [
                    { key: 'bmFtZQ==', value: 'aGVsbG8=' }
                ]
            });
        });
    });
    
    test('json rpc query view_code', async () => {
        const contract = await testUtils.deployContract(near.accountCreator.masterAccount, testUtils.generateUniqueString('test'));
    
        return testUtils.waitFor(async () => {
            const response = await provider.query({
                request_type: 'view_code',
                finality: 'final',
                account_id: contract.contractId
            });
    
            expect(response).toEqual({
                block_height: expect.any(Number),
                block_hash: expect.any(String),
                code_base64: expect.any(String),
                hash: expect.any(String)
            });
        });
    });
    
    test('json rpc query call_function', async () => {
        const contract = await testUtils.deployContract(near.accountCreator.masterAccount, testUtils.generateUniqueString('test'));
    
        await contract.setValue({ args: { value: 'hello' } });
    
        return testUtils.waitFor(async () => {
            const response = await provider.query({
                request_type: 'call_function',
                finality: 'final',
                account_id: contract.contractId,
                method_name: 'getValue',
                args_base64: ''
            });
            expect(response).toEqual({
                block_height: expect.any(Number),
                block_hash: expect.any(String),
                logs: [],
                result: [
                    34,
                    104,
                    101,
                    108,
                    108,
                    111,
                    34
                ]
            });
        });
    });
    
    test('json rpc light client proof', async () => {
        const workingAccount = await testUtils.createAccount(near);
        const executionOutcome = await workingAccount.sendMoney(workingAccount.accountId, BigInt(10000));
        const provider = near.connection.provider;
    
        async function waitForStatusMatching(isMatching) {
            const MAX_ATTEMPTS = 10;
            for (let i = 0; i < MAX_ATTEMPTS; i++) {
                await testUtils.sleep(500);
                const nodeStatus = await provider.status();
                if (isMatching(nodeStatus)) {
                    return nodeStatus;
                }
            }
            throw new Error(`Exceeded ${MAX_ATTEMPTS} attempts waiting for matching node status.`);
        }
    
        const comittedStatus = await waitForStatusMatching(status =>
            status.sync_info.latest_block_hash !== executionOutcome.transaction_outcome.block_hash);
        const BLOCKS_UNTIL_FINAL = 2;
        const finalizedStatus = await waitForStatusMatching(status =>
            status.sync_info.latest_block_height > comittedStatus.sync_info.latest_block_height + BLOCKS_UNTIL_FINAL);
    
        const block = await provider.block({ blockId: finalizedStatus.sync_info.latest_block_hash });
        const lightClientHead = block.header.last_final_block;
        let lightClientRequest = {
            type: 'transaction',
            light_client_head: lightClientHead,
            transaction_hash: executionOutcome.transaction.hash,
            sender_id: workingAccount.accountId,
        };
        const lightClientProof = await provider.lightClientProof(lightClientRequest);
        expect('prev_block_hash' in lightClientProof.block_header_lite).toBe(true);
        expect('inner_rest_hash' in lightClientProof.block_header_lite).toBe(true);
        expect('inner_lite' in lightClientProof.block_header_lite).toBe(true);
        expect('timestamp_nanosec' in lightClientProof.block_header_lite.inner_lite).toBe(true);
        expect(lightClientProof.outcome_proof.id).toEqual(executionOutcome.transaction_outcome.id);
        expect('block_hash' in lightClientProof.outcome_proof).toBe(true);
        expect(lightClientProof.outcome_root_proof).toEqual([]);
        expect(lightClientProof.block_proof.length).toBeGreaterThan(0);
    
        // pass nonexistent hash for light client head will fail
        lightClientRequest = {
            type: 'transaction',
            light_client_head: '11111111111111111111111111111111',
            transaction_hash: executionOutcome.transaction.hash,
            sender_id: workingAccount.accountId,
        };
        await expect(provider.lightClientProof(lightClientRequest)).rejects.toThrow('DB Not Found Error');
    
        // Use old block hash as light client head should fail
        lightClientRequest = {
            type: 'transaction',
            light_client_head: executionOutcome.transaction_outcome.block_hash,
            transaction_hash: executionOutcome.transaction.hash,
            sender_id: workingAccount.accountId,
        };
    
        await expect(provider.lightClientProof(lightClientRequest)).rejects.toThrow(/.+ block .+ is ahead of head block .+/);
    });
});

describe('providers errors', () => {
    test('JSON RPC Error - MethodNotFound', async () => {
        const contract = await testUtils.deployContract(
            near.accountCreator.masterAccount,
            testUtils.generateUniqueString('test')
        );

        await contract.setValue({ args: { value: 'hello' } });

        try {
            const response = await provider.query({
                request_type: 'call_function',
                finality: 'optimistic',
                account_id: contract.contractId,
                method_name: 'methodNameThatDoesNotExist',
                args_base64: '',
            });
            expect(response).toBeUndefined();
        } catch (e) {
            const errorType = 'MethodNotFound';
            expect(e.type).toEqual(errorType);
            expect(e.message).toEqual(ERRORS_JSON[errorType]);
        }
    });

    test('JSON RPC Error - CodeDoesNotExist', async () => {
        const { accountId } = await testUtils.createAccount(near);

        try {
            const response = await provider.query({
                request_type: 'call_function',
                finality: 'optimistic',
                account_id: accountId,
                method_name: 'methodNameThatDoesNotExistOnContractNotDeployed',
                args_base64: '',
            });
            expect(response).toBeUndefined();
        } catch (e) {
            const errorType = 'CodeDoesNotExist';
            expect(e.type).toEqual(errorType);
            expect(e.message.split(' ').slice(0, 5)).toEqual(
                ERRORS_JSON[errorType].split(' ').slice(0, 5)
            );
        }
    });

    test('JSON RPC Error - AccountDoesNotExist', async () => {
        const accountName = 'abc.near';
        try {
            const response = await provider.query({
                request_type: 'call_function',
                finality: 'optimistic',
                account_id: accountName,
                method_name: 'methodNameThatDoesNotExistOnContractNotDeployed',
                args_base64: '',
            });
            expect(response).toBeUndefined();
        } catch (e) {
            const errorType = 'AccountDoesNotExist';
            expect(e.type).toEqual(errorType);
            expect(e.message.split(' ').slice(0, 5)).toEqual(
                ERRORS_JSON[errorType].split(' ').slice(0, 5)
            );
        }
    });

    test('JSON RPC Error - AccessKeyDoesNotExist', async () => {
        const { accountId } = await testUtils.createAccount(near);

        try {
            const response = await provider.query({
                request_type: 'view_access_key',
                finality: 'optimistic',
                account_id: accountId,
                public_key: KeyPair.fromRandom('ed25519')
                    .getPublicKey()
                    .toString(),
            });
            expect(response).toBeUndefined();
        } catch (e) {
            const errorType = 'AccessKeyDoesNotExist';
            expect(e.type).toEqual(errorType);
            expect(e.message.split(' ').slice(0, 5)).toEqual(
                ERRORS_JSON[errorType].split(' ').slice(0, 5)
            );
        }
    });
});

'''
'''--- packages/accounts/test/test-utils.js ---
const { KeyPair } = require('@near-js/crypto');
const { InMemoryKeyStore } = require('@near-js/keystores');
const fs = require('fs').promises;
const path = require('path');

const { Account, AccountMultisig, Contract, Connection, LocalAccountCreator } = require('../lib');

const networkId = 'unittest';

const HELLO_WASM_PATH = process.env.HELLO_WASM_PATH || 'node_modules/near-hello/dist/main.wasm';
const HELLO_WASM_BALANCE = BigInt('10000000000000000000000000');
const HELLO_WASM_METHODS = {
    viewMethods: ['getValue', 'getLastResult'],
    changeMethods: ['setValue', 'callPromise']
};
const MULTISIG_WASM_PATH = process.env.MULTISIG_WASM_PATH || './test/wasm/multisig.wasm';
// Length of a random account. Set to 40 because in the protocol minimal allowed top-level account length should be at
// least 32.
const RANDOM_ACCOUNT_LENGTH = 40;

const GUESTBOOK_CONTRACT_ID = 'guestbook-1690363526419-7138950000000000';
const GUESTBOOK_WASM_PATH = path.resolve(__dirname, './wasm/guestbook.wasm');
const GUESTBOOK_CONTRACT_STATE = [
    {
        key: Buffer.from('U1RBVEU=', 'base64'),
        value: Buffer.from(
            'eyJtZXNzYWdlcyI6eyJwcmVmaXgiOiJ2LXVpZCIsImxlbmd0aCI6Mn19',
            'base64'
        ),
    },
    {
        key: Buffer.from('di11aWQAAAAA', 'base64'),
        value: Buffer.from(
            'eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJkZXYtMTY4ODk4NzM5ODM2MC00NzExMjI2NjI3NTg2NyIsInRleHQiOiJhIG1lc3NhZ2UifQ==',
            'base64'
        ),
    },
    {
        key: Buffer.from('di11aWQBAAAA', 'base64'),
        value: Buffer.from(
            'eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJkZXYtMTY4ODk4NzM5ODM2MC00NzExMjI2NjI3NTg2NyIsInRleHQiOiJzZWNvbmQgbWVzc2FnZSJ9',
            'base64'
        ),
    },
];

async function loadGuestBookContractCode() {
    const contractCode = await fs.readFile(GUESTBOOK_WASM_PATH);
    return contractCode.toString('base64');
}
async function setUpTestConnection() {
    const keyStore = new InMemoryKeyStore();
    const config = Object.assign(await require('./config')(process.env.NODE_ENV || 'test'), {
        networkId,
        keyStore
    });

    if (config.masterAccount) {
        // full accessKey on ci-testnet, dedicated rpc for tests.
        const secretKey = config.secretKey || 'ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw';
        await keyStore.setKey(networkId, config.masterAccount, KeyPair.fromString(secretKey));
    }

    const connection = Connection.fromConfig({
        networkId: config.networkId,
        provider: { type: 'JsonRpcProvider', args: { url: config.nodeUrl, headers: config.headers } },
        signer: { type: 'InMemorySigner', keyStore: config.keyStore },
    });

    return {
        accountCreator: new LocalAccountCreator(new Account(connection, config.masterAccount), BigInt('500000000000000000000000000')),
        connection,
    };
}

// Generate some unique string of length at least RANDOM_ACCOUNT_LENGTH with a given prefix using the alice nonce.
function generateUniqueString(prefix) {
    let result = `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
    let add_symbols = Math.max(RANDOM_ACCOUNT_LENGTH - result.length, 1);
    for (let i = add_symbols; i > 0; --i) result += '0';
    return result + '.test.near';
}

async function createAccount({ accountCreator, connection }) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await connection.signer.createKey(newAccountName, networkId);
    await accountCreator.createAccount(newAccountName, newPublicKey);
    return new Account(connection, newAccountName);
}

async function createAccountMultisig({ accountCreator, connection }, options) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await connection.signer.createKey(newAccountName, networkId);
    await accountCreator.createAccount(newAccountName, newPublicKey);
    // add a confirm key for multisig (contract helper sim)

    try {
        const confirmKeyPair = KeyPair.fromRandom('ed25519');
        const { publicKey } = confirmKeyPair;
        const accountMultisig = new AccountMultisig(connection, newAccountName, options);
        accountMultisig.useConfirmKey = async () => {
            await connection.signer.setKey(networkId, options.masterAccount, confirmKeyPair);
        };
        accountMultisig.getRecoveryMethods = () => ({ data: [] });
        accountMultisig.postSignedJson = async (path) => {
            switch (path) {
                case '/2fa/getAccessKey': return { publicKey };
            }
        };
        await accountMultisig.deployMultisig(new Uint8Array([...(await fs.readFile(MULTISIG_WASM_PATH))]));
        return accountMultisig;
    } catch (e) {
        console.log(e);
    }
}

async function deployContract(workingAccount, contractId) {
    const newPublicKey = await workingAccount.connection.signer.createKey(contractId, networkId);
    const data = [...(await fs.readFile(HELLO_WASM_PATH))];
    await workingAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
    return new Contract(workingAccount, contractId, HELLO_WASM_METHODS);
}

async function deployContractGuestBook(workingAccount, contractId) {
    const newPublicKey = await workingAccount.connection.signer.createKey(contractId, networkId);
    const data = [...(await fs.readFile(GUESTBOOK_WASM_PATH))];
    const account = await workingAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
    return new Contract(account, contractId, { viewMethods: ['total_messages', 'get_messages'],  changeMethods: ['add_message'], useLocalViewExecution: true });
}

function sleep(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

function waitFor(fn) {
    const _waitFor = async (count = 10) => {
        try {
            return await fn();
        } catch (e) {
            if (count > 0) {
                await sleep(500);
                return _waitFor(count - 1);
            }
            else throw e;
        }
    };

    return _waitFor();
}

module.exports = {
    setUpTestConnection,
    networkId,
    generateUniqueString,
    createAccount,
    createAccountMultisig,
    deployContract,
    HELLO_WASM_PATH,
    HELLO_WASM_BALANCE,
    loadGuestBookContractCode,
    deployContractGuestBook,
    GUESTBOOK_CONTRACT_ID,
    GUESTBOOK_CONTRACT_STATE,
    GUESTBOOK_WASM_PATH,
    sleep,
    waitFor,
};

'''
'''--- packages/biometric-ed25519/test/utils.test.js ---
const { sanitizeCreateKeyResponse, sanitizeGetKeyResponse } = require("../lib/utils");

// Define a mock PublicKeyCredential
class PublicKeyCredentialMock {
constructor({
  rawId,
  clientDataJSON,
  attestationObject,
  authenticatorData,
  signature,
  userHandle
}) {
    this.rawId = rawId;
    this.response = {
      clientDataJSON,
      ...(attestationObject ? { attestationObject } : {}),
      ...(signature ? { signature } : {}),
      ...(userHandle ? { userHandle } : {}),
      ...(authenticatorData ? { authenticatorData } : {}),
    };
  }
}

// Define global PublicKeyCredential to make it available during tests
global.PublicKeyCredential = PublicKeyCredentialMock;

jest.mock('../lib/utils', () => {
  const originalModule = jest.requireActual('../lib/utils');
  return {
    ...originalModule,
    convertUint8ArrayToArrayBuffer: jest.fn().mockImplementation(input => input.buffer),
  };
});

describe('sanitizeCreateKeyResponse', () => {
  it('should convert Uint8Array properties to ArrayBuffer for PublicKeyCredential', () => {
    const mockCredential = new PublicKeyCredentialMock({
      rawId: new Uint8Array([10, 20, 30]),
      clientDataJSON: new Uint8Array([40, 50, 60]),
      attestationObject: new Uint8Array([70, 80, 90]),
    });

    const result = sanitizeCreateKeyResponse(mockCredential);
    expect(result.rawId.constructor.name).toBe('ArrayBuffer');
    expect(result.response.clientDataJSON.constructor.name).toBe('ArrayBuffer');
    expect(result.response.attestationObject.constructor.name).toBe('ArrayBuffer');
  });

  it('should return the input unchanged if not PublicKeyCredential or without Uint8Arrays', () => {
    const mockCredential = new PublicKeyCredentialMock({
      rawId: [10, 20, 30],
      clientDataJSON: [40, 50, 60],
      attestationObject: [70, 80, 90],
    });

    const result = sanitizeCreateKeyResponse(mockCredential);
    expect(result).toEqual(mockCredential);
  });

  it('should handle non-PublicKeyCredential input gracefully', () => {
    const nonPublicKeyCredential = {
      someProp: 'test'
    }; // No casting needed

    const result = sanitizeCreateKeyResponse(nonPublicKeyCredential);
    expect(result).toEqual(nonPublicKeyCredential);
  });
});

describe('sanitizeGetKeyResponse', () => {
  it('should convert Uint8Array properties to ArrayBuffer in PublicKeyCredential', () => {
    const mockCredential = new PublicKeyCredentialMock({
      rawId: new Uint8Array([10, 20, 30]),
      clientDataJSON: new Uint8Array([40, 50, 60]),
      authenticatorData: new Uint8Array([70, 80, 90]),
      signature: new Uint8Array([100, 110, 120]),
      userHandle: new Uint8Array([130, 140, 150])
    });

    const result = sanitizeGetKeyResponse(mockCredential);
    expect(result.rawId.constructor.name).toBe('ArrayBuffer');
    expect(result.response.clientDataJSON.constructor.name).toBe('ArrayBuffer');
    expect(result.response.authenticatorData.constructor.name).toBe('ArrayBuffer');
    expect(result.response.signature.constructor.name).toBe('ArrayBuffer');
    expect(result.response.userHandle.constructor.name).toBe('ArrayBuffer');
  });

  it('should return the input unchanged if it does not meet conversion criteria', () => {
    const mockCredential = new PublicKeyCredentialMock({
      rawId: [10, 20, 30],
      clientDataJSON: [40, 50, 60],
      authenticatorData: [70, 80, 90],
      signature: [100, 110, 120],
      userHandle: [130, 140, 150]
    });

    const result = sanitizeGetKeyResponse(mockCredential);
    expect(result).toEqual(mockCredential);
  });

  it('should handle non-PublicKeyCredential input gracefully', () => {
    const nonPublicKeyCredential = {
      someProp: 'test value'
    };

    const result = sanitizeGetKeyResponse(nonPublicKeyCredential);
    expect(result).toEqual(nonPublicKeyCredential);
  });
});
'''
'''--- packages/cookbook/accounts/access-keys/create-full-access-key.js ---
const { KeyPair, keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "example.testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

createFullAccessKey(ACCOUNT_ID);

async function createFullAccessKey(accountId) {
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  const near = await connect(config);
  const account = await near.account(accountId);
  await keyStore.setKey(config.networkId, publicKey, keyPair);
  await account.addKey(publicKey);
}

'''
'''--- packages/cookbook/accounts/access-keys/create-function-access-key.js ---
const { KeyPair, keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "example.testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

addFunctionAccessKey(ACCOUNT_ID);

async function addFunctionAccessKey(accountId) {
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  const near = await connect(config);
  const account = await near.account(accountId);
  await keyStore.setKey(config.networkId, publicKey, keyPair);
  await account.addKey(
    publicKey,                   // public key for new account
    "example-account.testnet",   // contract this key is allowed to call (optional)
    "example_method",            // methods this key is allowed to call (optional)
    "2500000000000"              // allowance key can use to call methods (optional)
  );
}

'''
'''--- packages/cookbook/accounts/access-keys/delete-access-key.js ---
const { keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// NOTE: replace "example.testnet" with your accountId
const ACCOUNT_ID = "example.testnet";
// NOTE: replace this PK with the one that you are trying to delete
const PUBLIC_KEY = "ed25519:4yLYjwC3Rd8EkhKwVPoAdy6EUcCVSz2ZixFtsCeuBEZD";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

deleteAccessKey(ACCOUNT_ID, PUBLIC_KEY);

async function deleteAccessKey(accountId, publicKey) {
    const near = await connect(config);
    const account = await near.account(accountId);
    await account.deleteKey(publicKey);
}

'''
'''--- packages/cookbook/accounts/create-mainnet-account.js ---
const HELP = `Please run this script in the following format:

  node create-mainnet-account.js CREATOR_ACCOUNT.near NEW_ACCOUNT.near AMOUNT"
`;

const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

if (process.argv.length !== 5) {
  console.info(HELP);
  process.exit(1);
}

createAccount(process.argv[2], process.argv[3], process.argv[4]);

async function createAccount(creatorAccountId, newAccountId, amount) {
  const near = await connect(config);
  const creatorAccount = await near.account(creatorAccountId);
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  await keyStore.setKey(config.networkId, newAccountId, keyPair);

  return await creatorAccount.functionCall({
    contractId: "near",
    methodName: "create_account",
    args: {
      new_account_id: newAccountId,
      new_public_key: publicKey,
    },
    gas: "300000000000000",
    attachedDeposit: utils.format.parseNearAmount(amount),
  });
}

'''
'''--- packages/cookbook/accounts/create-testnet-account.js ---
const HELP = `Please run this script in the following format:

    node create-testnet-account.js CREATOR_ACCOUNT.testnet NEW_ACCOUNT.testnet AMOUNT
`;

const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

if (process.argv.length !== 5) {
  console.info(HELP);
  process.exit(1);
}

createAccount(process.argv[2], process.argv[3], process.argv[4]);

async function createAccount(creatorAccountId, newAccountId, amount) {
  const near = await connect({ ...config, keyStore });
  const creatorAccount = await near.account(creatorAccountId);
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  await keyStore.setKey(config.networkId, newAccountId, keyPair);

  return await creatorAccount.functionCall({
    contractId: "testnet",
    methodName: "create_account",
    args: {
      new_account_id: newAccountId,
      new_public_key: publicKey,
    },
    gas: "300000000000000",
    attachedDeposit: utils.format.parseNearAmount(amount),
  });
}

'''
'''--- packages/cookbook/api-keys/backup-provider.js ---
// demonstrates how to use multiple providers with different API-KEYs
const { providers } = require('near-api-js');

const RPC_API_ENDPOINT_1 = '<Replace this string with your RPC server URL>';
const API_KEY_1 = '<Replace this string with your API KEY>';

const RPC_API_ENDPOINT_2 = '<Replace this string with another RPC server URL>';
const API_KEY_2 = '<Replace this string with another API KEY>';

const jsonProviders = [
    new providers.JsonRpcProvider({
        url: RPC_API_ENDPOINT_1,
        headers: { 'x-api-key': API_KEY_1 },
    }),
    new providers.JsonRpcProvider({
        url: RPC_API_ENDPOINT_2,
        headers: { 'x-api-key': API_KEY_2 },
    }),
];
const provider = new providers.FailoverRpcProvider(jsonProviders);

getNetworkStatus();

async function getNetworkStatus() {
    const result = await provider.status();
    console.log(result);
}

'''
'''--- packages/cookbook/api-keys/near-connection.js ---
// demonstrates how to use API-KEY with 'connect' function. 
const { connect, keyStores } = require("near-api-js");
const path = require("path");

const homedir = require("os").homedir();
const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const RPC_API_ENDPOINT = '<Replace this string with your RPC server URL>';
const API_KEY = '<Replace this string with your API KEY>';

const ACCOUNT_ID = '<Replace this string with existing account ID>';

const config = {
    networkId: 'testnet',
    keyStore,
    nodeUrl: RPC_API_ENDPOINT,
    headers: { 'x-api-key': API_KEY },
};

async function getState(accountId) {
    const near = await connect(config);
    const account = await near.account(accountId);
    const state = await account.state();
    console.log(state);
}

getState(ACCOUNT_ID);
'''
'''--- packages/cookbook/api-keys/provider-example.js ---
// demonstrates how to use API-KEY with provider 
const { providers } = require("near-api-js");

const RPC_API_ENDPOINT = '<Replace this string with your RPC server URL>';
const API_KEY = '<Replace this string with your API KEY>';

const provider = new providers.JsonRpcProvider({
    url: RPC_API_ENDPOINT,
    headers: { 'x-api-key': API_KEY },
});

getNetworkStatus();

async function getNetworkStatus() {
    const result = await provider.status();
    console.log(result);
}
'''
'''--- packages/cookbook/transactions/batch-transactions.js ---
const { connect, transactions, keyStores } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// NOTE: replace "example" with your accountId
const CONTRACT_NAME = "contract.example.testnet";
const WHITELIST_ACCOUNT_ID = "whitelisted-account.example.testnet";
const WASM_PATH = path.join(__dirname, "../utils/wasm-files/staking_pool_factory.wasm");

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

sendTransactions();

async function sendTransactions() {
    const near = await connect({ ...config, keyStore });
    const account = await near.account(CONTRACT_NAME);
    const newArgs = { staking_pool_whitelist_account_id: WHITELIST_ACCOUNT_ID };
    const result = await account.signAndSendTransaction({
        receiverId: CONTRACT_NAME,
        actions: [
            transactions.deployContract(fs.readFileSync(WASM_PATH)),
            transactions.functionCall(
                "new",
                Buffer.from(JSON.stringify(newArgs)),
                10000000000000,
                "0"
            ),
        ],
    });

    console.log(result);
}

'''
'''--- packages/cookbook/transactions/get-tx-detail.js ---
const { connect, keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// block hash of query start (oldest block)
const START_BLOCK_HASH = "GZ8vKdcgsavkEndkDWHCjuhyqSR2TGnp9VDZbTzd6ufG";
// block hash of query end (newest block)
const END_BLOCK_HASH = "8aEcKhF7N1Jyw84e6vHW6Hzp3Ep7mSXJ6Rvnsy5qGJPF";
// contract ID or account ID you want to find transactions details for
const CONTRACT_ID = "relayer.ropsten.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

// NOTE: we're using the archival rpc to look back in time for a specific set
// of transactions. For a full list of what nodes are available, visit:
// https://docs.near.org/docs/develop/node/intro/types-of-node
const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://archival-rpc.testnet.near.org",
};

getTransactions(START_BLOCK_HASH, END_BLOCK_HASH, CONTRACT_ID);

async function getTransactions(startBlock, endBlock, accountId) {
  const near = await connect(config);

  // creates an array of block hashes for given range
  const blockArr = [];
  let blockHash = endBlock;
  do {
    const currentBlock = await getBlockByID(blockHash);
    blockArr.push(currentBlock.header.hash);
    blockHash = currentBlock.header.prev_hash;
    console.log("working...", blockHash);
  } while (blockHash !== startBlock);

  // returns block details based on hashes in array
  const blockDetails = await Promise.all(
    blockArr.map((blockId) =>
      near.connection.provider.block({
        blockId,
      })
    )
  );

  // returns an array of chunk hashes from block details
  const chunkHashArr = blockDetails.flatMap((block) =>
    block.chunks.map(({ chunk_hash }) => chunk_hash)
  );

  //returns chunk details based from the array of hashes
  const chunkDetails = await Promise.all(
    chunkHashArr.map(chunk => near.connection.provider.chunk(chunk))
  );

  // checks chunk details for transactions
  // if there are transactions in the chunk we
  // find ones associated with passed accountId
  const transactions = chunkDetails.flatMap((chunk) =>
    (chunk.transactions || []).filter((tx) => tx.signer_id === accountId)
  );

  //creates transaction links from matchingTxs
  const txsLinks = transactions.map((txs) => ({
    method: txs.actions[0].FunctionCall.method_name,
    link: `https://explorer.testnet.near.org/transactions/${txs.hash}`,
  }));
  console.log("MATCHING TRANSACTIONS: ", transactions);
  console.log("TRANSACTION LINKS: ", txsLinks);
}

async function getBlockByID(blockID) {
  const near = await connect(config);
  const blockInfoByHeight = await near.connection.provider.block({
    blockId: blockID,
  });
  return blockInfoByHeight;
}

'''
'''--- packages/cookbook/transactions/get-tx-status.js ---
// demonstrates how to get a transaction status
const { providers } = require("near-api-js");

//network config (replace testnet with mainnet or betanet)
const provider = new providers.JsonRpcProvider(
    "https://archival-rpc.testnet.near.org"
);

const TX_HASH = "9av2U6cova7LZPA9NPij6CTUrpBbgPG6LKVkyhcCqtk3";
// account ID associated with the transaction
const ACCOUNT_ID = "sender.testnet";

getState(TX_HASH, ACCOUNT_ID);

async function getState(txHash, accountId) {
    const result = await provider.txStatus(txHash, accountId);
    console.log("Result: ", result);
}

'''
'''--- packages/cookbook/transactions/meta-transaction-relayer.js ---
const { Account } = require('@near-js/accounts');
const { UnencryptedFileSystemKeyStore } = require('@near-js/keystores-node');
const { JsonRpcProvider, fetchJson } = require('@near-js/providers');
const { InMemorySigner } = require('@near-js/signers');
const { actionCreators, encodeSignedDelegate } = require('@near-js/transactions');
const os = require('os');
const path = require('path');

const { transfer } = actionCreators;

async function sendNearThroughRelayer({ amount, receiverId, senderAccount }) {
    const signedDelegate = await senderAccount.signedDelegate({
        actions: [transfer(amount)],
        blockHeightTtl: 60,
        receiverId
    });

    return fetchJson(
        'https://relayer.org/relay',
        JSON.stringify(Array.from(encodeSignedDelegate(signedDelegate)))
    );
}

module.exports = {
    sendNearThroughRelayer,
};

if (require.main === module) {
    (async function () {
        const networkId = 'testnet';
        const provider = new JsonRpcProvider({ url: 'https://rpc.testnet.near.org' });

        const CREDENTIALS_DIR = '.near-credentials';
        const credentialsPath = path.join(os.homedir(), CREDENTIALS_DIR);

        const RECEIVER_ACCOUNT_ID = 'receiver.testnet'; // the ultimate recipient of the meta transaction execution
        const SENDER_ACCOUNT_ID = 'sender.testnet';     // the account requesting the transaction be executed

        const senderAccount = new Account({
            networkId,
            provider,
            signer: new InMemorySigner(new UnencryptedFileSystemKeyStore(credentialsPath))
        }, SENDER_ACCOUNT_ID);

        console.log(await sendNearThroughRelayer({
            amount: BigInt('1000000000'),
            receiverId: RECEIVER_ACCOUNT_ID,
            senderAccount,
        }));
    }());
}
'''
'''--- packages/cookbook/transactions/meta-transaction.js ---
const { Account } = require('@near-js/accounts');
const { UnencryptedFileSystemKeyStore } = require('@near-js/keystores-node');
const { JsonRpcProvider } = require('@near-js/providers');
const { InMemorySigner } = require('@near-js/signers');
const { actionCreators } = require('@near-js/transactions');
const os = require('os');
const path = require('path');

const { signedDelegate, transfer } = actionCreators;

async function sendNearViaMetaTransaction({ amount, receiverId, senderAccount, signingAccount }) {
    const delegate = await senderAccount.signedDelegate({
        actions: [transfer(amount)],
        blockHeightTtl: 60,
        receiverId,
    });

    return signingAccount.signAndSendTransaction({
        actions: [signedDelegate(delegate)],
        receiverId: delegate.delegateAction.senderId,
    });
}

module.exports = {
    sendNearViaMetaTransaction,
};

if (require.main === module) {
    (async function () {
        const networkId = 'testnet';
        const provider = new JsonRpcProvider({ url: 'https://rpc.testnet.near.org' });

        const CREDENTIALS_DIR = '.near-credentials';
        const credentialsPath = path.join(os.homedir(), CREDENTIALS_DIR);

        // access keys are required for the sender and signer
        const RECEIVER_ACCOUNT_ID = 'receiver.testnet'; // the ultimate recipient of the meta transaction execution
        const SENDER_ACCOUNT_ID = 'sender.testnet';     // the account requesting the transaction be executed
        const SIGNER_ACCOUNT_ID = 'signer.testnet';     // the account executing the meta transaction on behalf (e.g. as a relayer) of the sender

        const senderAccount = new Account({
            networkId,
            provider,
            signer: new InMemorySigner(new UnencryptedFileSystemKeyStore(credentialsPath))
        }, SENDER_ACCOUNT_ID);

        const signingAccount = new Account({
            networkId,
            provider,
            signer: new InMemorySigner(new UnencryptedFileSystemKeyStore(credentialsPath))
        }, SIGNER_ACCOUNT_ID);

        console.log(await sendNearViaMetaTransaction({
            amount: BigInt('1000000000'),
            receiverId: RECEIVER_ACCOUNT_ID,
            senderAccount,
            signingAccount,
        }));
    }());
}
'''
'''--- packages/cookbook/utils/calculate-gas.js ---
const { connect, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const chalk = require("chalk");

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "near-example.testnet";
const CONTRACT_ID = "guest-book.testnet";
const METHOD_NAME = "addMessage";
const MAX_GAS = "300000000000000";
const ATTACHED_DEPOSIT = "0";

const args = {
  text: "Howdy!",
};

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

calculateGas(CONTRACT_ID, METHOD_NAME, args, ATTACHED_DEPOSIT);

async function calculateGas(contractId, methodName, args, depositAmount) {
  const near = await connect(config);
  const account = await near.account(ACCOUNT_ID);
  const result = await account.functionCall({
    contractId,
    methodName,
    args,
    gas: MAX_GAS,
    attachedDeposit: utils.format.parseNearAmount(depositAmount),
  });
  const { totalGasBurned, totalTokensBurned } = result.receipts_outcome.reduce(
    (acc, receipt) => {
      acc.totalGasBurned += receipt.outcome.gas_burnt;
      acc.totalTokensBurned += utils.format.formatNearAmount(
        receipt.outcome.tokens_burnt
      );
      return acc;
    },
    {
      totalGasBurned: result.transaction_outcome.outcome.gas_burnt,
      totalTokensBurned: utils.format.formatNearAmount(
        result.transaction_outcome.outcome.tokens_burnt
      ),
    }
  );

  console.log(chalk`{white ------------------------------------------------------------------------ }`)
  console.log(chalk`{bold.green RESULTS} {white for: [ {bold.blue ${METHOD_NAME}} ] called on contract: [ {bold.blue ${CONTRACT_ID}} ]}` )
  console.log(chalk`{white ------------------------------------------------------------------------ }`)
  console.log(chalk`{bold.white Gas Burnt}     {white |}  {bold.yellow ${totalGasBurned}}`);
  console.log(chalk`{bold.white Tokens Burnt}  {white |}  {bold.yellow ${totalTokensBurned}}`);
  console.log(chalk`{white ------------------------------------------------------------------------ }`)

  return {
    totalTokensBurned,
    totalGasBurned,
  };
}

'''
'''--- packages/cookbook/utils/check-account-existence.js ---
// Demonstrates checking if an account exists
const { providers } = require("near-api-js");

const provider = new providers.JsonRpcProvider(
    "https://archival-rpc.testnet.near.org"
);

async function accountExists() {
    let rawResult;

    for (const account_id of ["does-not-exist.mike.testnet", "mike.testnet"]) {
        let succeeded = true;
        try {
            rawResult = await provider.query({
                request_type: "view_account",
                account_id: account_id,
                finality: "final",
            });
        } catch (e) {
            if (e.type === 'AccountDoesNotExist') {
                succeeded = false;
            }
        }
        console.log(succeeded ? `The account ${account_id} exists.` : `There is no account ${account_id}.`)
    }
}

accountExists();

'''
'''--- packages/cookbook/utils/deploy-contract.js ---
const { keyStores, connect } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "near-example.testnet";
const WASM_PATH = path.join(__dirname, "/wasm-files/status_message.wasm");
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

deployContract(ACCOUNT_ID, WASM_PATH);

async function deployContract(accountId, wasmPath) { 
    const near = await connect(config);
    const account = await near.account(accountId);
    const result = await account.deployContract(fs.readFileSync(wasmPath));
    console.log(result);
}

'''
'''--- packages/cookbook/utils/get-state.js ---
// demonstrates how to query the state without setting 
// up an account. (View methods only)
const { providers } = require("near-api-js");
//network config (replace testnet with mainnet or betanet)
const provider = new providers.JsonRpcProvider(
  "https://rpc.testnet.near.org"
);

getState();

async function getState() {
  const rawResult = await provider.query({
    request_type: "call_function",
    account_id: "guest-book.testnet",
    method_name: "getMessages",
    args_base64: "e30=",
    finality: "optimistic",
  });

  // format result
  const res = JSON.parse(Buffer.from(rawResult.result).toString());
  console.log(res);
}

'''
'''--- packages/cookbook/utils/unwrap-near.js ---
const { connect, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const WRAP_NEAR_CONTRACT_ID = "wrap.near";

const credentialsPath = path.join(homedir, ".near-credentials");
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

// Unwrap 1 wNEAR to NEAR
unwrapNear("example.near", "1");

async function unwrapNear(accountId, unwrapAmount) {
    const near = await connect(config);
    const account = await near.account(accountId);
  
    return account.functionCall({
      contractId: WRAP_NEAR_CONTRACT_ID,
      methodName: "near_withdraw", // method to withdraw wNEAR for NEAR
      args: { amount: utils.format.parseNearAmount(unwrapAmount) },
      attachedDeposit: "1", // attach one yoctoNEAR
    });
  }
'''
'''--- packages/cookbook/utils/verify-signature.js ---
const { keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const ACCOUNT_ID = "near-example.testnet";
const CREDENTIALS_DIR = ".near-credentials";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

verifySignature();

async function verifySignature() {
    const keyPair = await keyStore.getKey(config.networkId, ACCOUNT_ID);
    const msg = Buffer.from("hi");

    const { signature } = keyPair.sign(msg);

    const isValid = keyPair.verify(msg, signature);

    console.log("Signature Valid?:", isValid);

    return isValid;
}

'''
'''--- packages/cookbook/utils/wrap-near.js ---
const HELP = `To convert N $NEAR to wNEAR,  run this script in the following format:

    node wrap-near.js YOU.near N

`;

const { connect, keyStores, transactions, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

// On mainnet it's wrap.near, by the way
const WRAP_NEAR_CONTRACT_ID = "wrap.testnet";

const credentialsPath = path.join(homedir, ".near-credentials");
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

if (process.argv.length !== 4) {
  console.info(HELP);
  process.exit(1);
}

wrapNear(process.argv[2], process.argv[3]);

async function wrapNear(accountId, wrapAmount) {
  const near = await connect(config);
  const account = await near.account(accountId);

  const actions = [
    transactions.functionCall(
      "near_deposit", // contract method to deposit NEAR for wNEAR
      {},
      30000000000000, // attached gas
      utils.format.parseNearAmount(wrapAmount) // amount of NEAR to deposit and wrap
    ),
  ];

  // check if storage has been paid (the account has a wNEAR account)
  const storage = await account.viewFunction({
    contractId: WRAP_NEAR_CONTRACT_ID,
    methodName: "storage_balance_of",
    args: { account_id: accountId },
  });

  // if storage hasn't been paid, pay for storage (create an account)
  if (!storage) {
    actions.unshift(
      transactions.functionCall(
        "storage_deposit", // method to create an account
        {},
        30000000000000, // attached gas
        utils.format.parseNearAmount('0.00125') // account creation costs 0.00125 NEAR for storage
      )
    );
  }

  // send batched transaction
  return account.signAndSendTransaction({
    receiverId: WRAP_NEAR_CONTRACT_ID,
    actions,
  });
}

'''
'''--- packages/crypto/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/crypto/test/key_pair.test.js ---
const { baseEncode } = require('@near-js/utils');
const { sha256 } = require('@noble/hashes/sha256');

const { KeyPair, KeyPairEd25519, PublicKey } = require('../lib');

test('test sign and verify', async () => {
    const keyPair = new KeyPairEd25519('26x56YPzPDro5t2smQfGcYAPy3j7R2jB2NUb7xKbAGK23B6x4WNQPh3twb6oDksFov5X8ts5CtntUNbpQpAKFdbR');
    expect(keyPair.publicKey.toString()).toEqual('ed25519:AYWv9RAN1hpSQA4p1DLhCNnpnNXwxhfH9qeHN8B4nJ59');
    const message = new Uint8Array(sha256('message'));
    const signature = keyPair.sign(message);
    expect(baseEncode(signature.signature)).toEqual('26gFr4xth7W9K7HPWAxq3BLsua8oTy378mC1MYFiEXHBBpeBjP8WmJEJo8XTBowetvqbRshcQEtBUdwQcAqDyP8T');
});

test('test sign and verify with random', async () => {
    const keyPair = KeyPairEd25519.fromRandom();
    const message = new Uint8Array(sha256('message'));
    const signature = keyPair.sign(message);
    expect(keyPair.verify(message, signature.signature)).toBeTruthy();
});

test('test sign and verify with public key', async () => {
    const keyPair = new KeyPairEd25519('5JueXZhEEVqGVT5powZ5twyPP8wrap2K7RdAYGGdjBwiBdd7Hh6aQxMP1u3Ma9Yanq1nEv32EW7u8kUJsZ6f315C');
    const message = new Uint8Array(sha256('message'));
    const signature = keyPair.sign(message);
    const publicKey = PublicKey.from('ed25519:EWrekY1deMND7N3Q7Dixxj12wD7AVjFRt2H9q21QHUSW');
    expect(publicKey.verify(message, signature.signature)).toBeTruthy();
});

test('test from secret', async () => {
    const keyPair = new KeyPairEd25519('5JueXZhEEVqGVT5powZ5twyPP8wrap2K7RdAYGGdjBwiBdd7Hh6aQxMP1u3Ma9Yanq1nEv32EW7u8kUJsZ6f315C');
    expect(keyPair.publicKey.toString()).toEqual('ed25519:EWrekY1deMND7N3Q7Dixxj12wD7AVjFRt2H9q21QHUSW');
});

test('convert to string', async () => {
    const keyPair = KeyPairEd25519.fromRandom();
    const newKeyPair = KeyPair.fromString(keyPair.toString());
    expect(newKeyPair.secretKey).toEqual(keyPair.secretKey);

    const keyString = 'ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw';
    const keyPair2 = KeyPair.fromString(keyString);
    expect(keyPair2.toString()).toEqual(keyString);
});

test('public key from too short string', async () => {
    const tooShortPublicKey = 'tooShortPublicKey';
    expect(() =>
        PublicKey.fromString(baseEncode(tooShortPublicKey))).toThrow(
        `Invalid public key size (${tooShortPublicKey.length}), must be 32`);
});

test('public key from string', async () => {
    const validPublicKey = '0123456789ABCDEF0123456789ABCDEF';
    expect(() =>
        PublicKey.fromString(baseEncode(validPublicKey))).not.toThrow();
});

'''
'''--- packages/keystores-browser/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/keystores-browser/test/browser_keystore.test.js ---
const { BrowserLocalStorageKeyStore } = require('../lib');

describe('Browser keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.keyStore = new BrowserLocalStorageKeyStore(require('localstorage-memory'));
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- packages/keystores-browser/test/keystore_common.js ---
const { KeyPairEd25519 } = require('@near-js/crypto');

const NETWORK_ID_SINGLE_KEY = 'singlekeynetworkid';
const ACCOUNT_ID_SINGLE_KEY = 'singlekey_accountid';
const KEYPAIR_SINGLE_KEY = new KeyPairEd25519('2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');

module.exports.shouldStoreAndRetriveKeys = ctx => {
    beforeEach(async () => {
        await ctx.keyStore.clear();
        await ctx.keyStore.setKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY, KEYPAIR_SINGLE_KEY);
    });

    test('Get all keys with empty network returns empty list', async () => {
        const emptyList = await ctx.keyStore.getAccounts('emptynetwork');
        expect(emptyList).toEqual([]);
    });  
    
    test('Get all keys with single key in keystore', async () => {
        const accountIds = await ctx.keyStore.getAccounts(NETWORK_ID_SINGLE_KEY);
        expect(accountIds).toEqual([ACCOUNT_ID_SINGLE_KEY]);
    });

    test('Get not-existing account', async () => {
        expect(await ctx.keyStore.getKey('somenetwork', 'someaccount')).toBeNull();
    });

    test('Get account id from a network with single key', async () => {
        const key = await ctx.keyStore.getKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY);
        expect(key).toEqual(KEYPAIR_SINGLE_KEY);
    });

    test('Get networks', async () => {
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY]);
    });

    test('Add two keys to network and retrieve them', async () => {
        const networkId = 'twoKeyNetwork';
        const accountId1 = 'acc1';
        const accountId2 = 'acc2';
        const key1Expected = KeyPairEd25519.fromRandom();
        const key2Expected = KeyPairEd25519.fromRandom();
        await ctx.keyStore.setKey(networkId, accountId1, key1Expected);
        await ctx.keyStore.setKey(networkId, accountId2, key2Expected);
        const key1 = await ctx.keyStore.getKey(networkId, accountId1);
        const key2 = await ctx.keyStore.getKey(networkId, accountId2);
        expect(key1).toEqual(key1Expected);
        expect(key2).toEqual(key2Expected);
        const accountIds = await ctx.keyStore.getAccounts(networkId);
        expect(accountIds).toEqual([accountId1, accountId2]);
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY, networkId]);
    });
};

'''
'''--- packages/keystores-node/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/keystores-node/test/keystore_common.js ---
const { KeyPairEd25519 } = require('@near-js/crypto');

const NETWORK_ID_SINGLE_KEY = 'singlekeynetworkid';
const ACCOUNT_ID_SINGLE_KEY = 'singlekey_accountid';
const KEYPAIR_SINGLE_KEY = new KeyPairEd25519('2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');

module.exports.shouldStoreAndRetriveKeys = ctx => {
    beforeEach(async () => {
        await ctx.keyStore.clear();
        await ctx.keyStore.setKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY, KEYPAIR_SINGLE_KEY);
    });

    test('Get all keys with empty network returns empty list', async () => {
        const emptyList = await ctx.keyStore.getAccounts('emptynetwork');
        expect(emptyList).toEqual([]);
    });  
    
    test('Get all keys with single key in keystore', async () => {
        const accountIds = await ctx.keyStore.getAccounts(NETWORK_ID_SINGLE_KEY);
        expect(accountIds).toEqual([ACCOUNT_ID_SINGLE_KEY]);
    });

    test('Get not-existing account', async () => {
        expect(await ctx.keyStore.getKey('somenetwork', 'someaccount')).toBeNull();
    });

    test('Get account id from a network with single key', async () => {
        const key = await ctx.keyStore.getKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY);
        expect(key).toEqual(KEYPAIR_SINGLE_KEY);
    });

    test('Get networks', async () => {
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY]);
    });

    test('Add two keys to network and retrieve them', async () => {
        const networkId = 'twoKeyNetwork';
        const accountId1 = 'acc1';
        const accountId2 = 'acc2';
        const key1Expected = KeyPairEd25519.fromRandom();
        const key2Expected = KeyPairEd25519.fromRandom();
        await ctx.keyStore.setKey(networkId, accountId1, key1Expected);
        await ctx.keyStore.setKey(networkId, accountId2, key2Expected);
        const key1 = await ctx.keyStore.getKey(networkId, accountId1);
        const key2 = await ctx.keyStore.getKey(networkId, accountId2);
        expect(key1).toEqual(key1Expected);
        expect(key2).toEqual(key2Expected);
        const accountIds = await ctx.keyStore.getAccounts(networkId);
        expect(accountIds).toEqual([accountId1, accountId2]);
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY, networkId]);
    });
};

'''
'''--- packages/keystores-node/test/unencrypted_file_system_keystore.test.js ---
const { KeyPairEd25519 } = require('@near-js/crypto');
const fs = require('fs').promises;
const path = require('path');
const rimraf  = require('util').promisify(require('rimraf'));

const { UnencryptedFileSystemKeyStore } = require('../lib');

const KEYSTORE_PATH = '../../test-keys';

describe('Unencrypted file system keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        await rimraf(KEYSTORE_PATH);
        try {
            await fs.mkdir(KEYSTORE_PATH, { recursive: true });
        } catch (err) {
            if (err.code !== 'EEXIST') throw err;
        }
        ctx.keyStore = new UnencryptedFileSystemKeyStore(KEYSTORE_PATH);
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);

    it('test path resolve', async() => {
        expect(ctx.keyStore.keyDir).toEqual(path.join(process.cwd(), KEYSTORE_PATH));
    });

    it('test public key exists', async () => {
        const key1 = KeyPairEd25519.fromRandom();
        await ctx.keyStore.setKey('network', 'account', key1);
        const keyFilePath = ctx.keyStore.getKeyFilePath('network', 'account');
        const content = await fs.readFile(keyFilePath);
        const accountInfo = JSON.parse(content.toString());
        expect(accountInfo.public_key).toEqual(key1.getPublicKey().toString());
    });
});

'''
'''--- packages/keystores/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/keystores/test/in_memory_keystore.test.js ---
const { InMemoryKeyStore } = require('../lib');

describe('In-memory keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.keyStore = new InMemoryKeyStore();
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- packages/keystores/test/keystore_common.js ---
const { KeyPairEd25519 } = require('@near-js/crypto');

const NETWORK_ID_SINGLE_KEY = 'singlekeynetworkid';
const ACCOUNT_ID_SINGLE_KEY = 'singlekey_accountid';
const KEYPAIR_SINGLE_KEY = new KeyPairEd25519('2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');

module.exports.shouldStoreAndRetriveKeys = ctx => {
    beforeEach(async () => {
        await ctx.keyStore.clear();
        await ctx.keyStore.setKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY, KEYPAIR_SINGLE_KEY);
    });

    test('Get all keys with empty network returns empty list', async () => {
        const emptyList = await ctx.keyStore.getAccounts('emptynetwork');
        expect(emptyList).toEqual([]);
    });  
    
    test('Get all keys with single key in keystore', async () => {
        const accountIds = await ctx.keyStore.getAccounts(NETWORK_ID_SINGLE_KEY);
        expect(accountIds).toEqual([ACCOUNT_ID_SINGLE_KEY]);
    });

    test('Get not-existing account', async () => {
        expect(await ctx.keyStore.getKey('somenetwork', 'someaccount')).toBeNull();
    });

    test('Get account id from a network with single key', async () => {
        const key = await ctx.keyStore.getKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY);
        expect(key).toEqual(KEYPAIR_SINGLE_KEY);
    });

    test('Get networks', async () => {
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY]);
    });

    test('Add two keys to network and retrieve them', async () => {
        const networkId = 'twoKeyNetwork';
        const accountId1 = 'acc1';
        const accountId2 = 'acc2';
        const key1Expected = KeyPairEd25519.fromRandom();
        const key2Expected = KeyPairEd25519.fromRandom();
        await ctx.keyStore.setKey(networkId, accountId1, key1Expected);
        await ctx.keyStore.setKey(networkId, accountId2, key2Expected);
        const key1 = await ctx.keyStore.getKey(networkId, accountId1);
        const key2 = await ctx.keyStore.getKey(networkId, accountId2);
        expect(key1).toEqual(key1Expected);
        expect(key2).toEqual(key2Expected);
        const accountIds = await ctx.keyStore.getAccounts(networkId);
        expect(accountIds).toEqual([accountId1, accountId2]);
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY, networkId]);
    });
};

'''
'''--- packages/keystores/test/merge_keystore.test.js ---
const { KeyPairEd25519 } = require('@near-js/crypto');

const { InMemoryKeyStore, MergeKeyStore } = require('../lib');

describe('Merge keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.stores = [new InMemoryKeyStore(), new InMemoryKeyStore()];
        ctx.keyStore = new MergeKeyStore(ctx.stores);
    });

    it('looks up key from fallback key store if needed', async () => {
        const key1 = KeyPairEd25519.fromRandom();
        await ctx.stores[1].setKey('network', 'account', key1);
        expect(await ctx.keyStore.getKey('network', 'account')).toEqual(key1);
    });

    it('looks up key in proper order', async () => {
        const key1 = KeyPairEd25519.fromRandom();
        const key2 = KeyPairEd25519.fromRandom();
        await ctx.stores[0].setKey('network', 'account', key1);
        await ctx.stores[1].setKey('network', 'account', key2);
        expect(await ctx.keyStore.getKey('network', 'account')).toEqual(key1);
    });

    it('sets keys only in first key store', async () => {
        const key1 = KeyPairEd25519.fromRandom();
        await ctx.keyStore.setKey('network', 'account', key1);
        expect(await ctx.stores[0].getAccounts('network')).toHaveLength(1);
        expect(await ctx.stores[1].getAccounts('network')).toHaveLength(0);
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- packages/near-api-js/browser-exports.js ---
window.nearApi = require('./lib/browser-index');
window.Buffer = Buffer;

'''
'''--- packages/near-api-js/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/near-api-js/test/config.js ---
const { Worker } = require('near-workspaces');
const fs = require('fs');
let worker;
module.exports = async function getConfig(env) {
    switch (env) {
    case 'production':
    case 'mainnet':
        return {
            networkId: 'mainnet',
            nodeUrl: 'https://rpc.mainnet.near.org',
            walletUrl: 'https://wallet.near.org',
            helperUrl: 'https://helper.mainnet.near.org',
        };
    case 'development':
    case 'testnet':
        return {
            networkId: 'default',
            nodeUrl: 'https://rpc.testnet.near.org',
            walletUrl: 'https://wallet.testnet.near.org',
            helperUrl: 'https://helper.testnet.near.org',
            masterAccount: 'test.near',
        };
    case 'betanet':
        return {
            networkId: 'betanet',
            nodeUrl: 'https://rpc.betanet.near.org',
            walletUrl: 'https://wallet.betanet.near.org',
            helperUrl: 'https://helper.betanet.near.org',
        };
    case 'local':
        return {
            networkId: 'local',
            nodeUrl: 'http://localhost:3030',
            keyPath: `${process.env.HOME}/.near/validator_key.json`,
            walletUrl: 'http://localhost:4000/wallet',
        };
    case 'test':
    case 'ci':
        if (!worker) worker = await Worker.init();
        const keyFile = fs.readFileSync(`${worker.rootAccount.manager.config.homeDir}/validator_key.json`);
        const keyPair = JSON.parse(keyFile.toString());
        return {
            networkId: worker.config.network,
            nodeUrl: worker.manager.config.rpcAddr,
            masterAccount: worker.rootAccount._accountId,
            secretKey: keyPair.secret_key || keyPair.private_key
        };
    default:
        throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
    }
};

'''
'''--- packages/near-api-js/test/test-utils.js ---
const fs = require('fs').promises;

const nearApi = require('../src/index');

const networkId = 'unittest';

const HELLO_WASM_PATH = process.env.HELLO_WASM_PATH || 'node_modules/near-hello/dist/main.wasm';
const HELLO_WASM_BALANCE = BigInt('10000000000000000000000000');
const HELLO_WASM_METHODS = {
    viewMethods: ['getValue', 'getLastResult'],
    changeMethods: ['setValue', 'callPromise']
};
const MULTISIG_WASM_PATH = process.env.MULTISIG_WASM_PATH || './test/wasm/multisig.wasm';
// Length of a random account. Set to 40 because in the protocol minimal allowed top-level account length should be at
// least 32.
const RANDOM_ACCOUNT_LENGTH = 40;

async function setUpTestConnection() {
    const keyStore = new nearApi.keyStores.InMemoryKeyStore();
    const config = Object.assign(await require('./config')(process.env.NODE_ENV || 'test'), {
        networkId,
        keyStore
    });

    if (config.masterAccount) {
        // full accessKey on ci-testnet, dedicated rpc for tests.
        const secretKey = config.secretKey || 'ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw';
        await keyStore.setKey(networkId, config.masterAccount, KeyPair.fromString(secretKey));
    }
    return nearApi.connect(config);
}

// Generate some unique string of length at least RANDOM_ACCOUNT_LENGTH with a given prefix using the alice nonce.
function generateUniqueString(prefix) {
    let result = `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
    let add_symbols = Math.max(RANDOM_ACCOUNT_LENGTH - result.length, 1);
    for (let i = add_symbols; i > 0; --i) result += '0';
    return result;
}

async function createAccount(near) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await near.connection.signer.createKey(newAccountName, networkId);
    await near.createAccount(newAccountName, newPublicKey);
    const account = new nearApi.Account(near.connection, newAccountName);
    return account;
}

async function createAccountMultisig(near, options) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await near.connection.signer.createKey(newAccountName, networkId);
    await near.createAccount(newAccountName, newPublicKey);
    // add a confirm key for multisig (contract helper sim)

    try {
        const confirmKeyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
        const { publicKey } = confirmKeyPair;
        // const account = new nearApi.Account(near.connection, newAccountName);
        // await account.addKey(publicKey, account.accountId, nearApi.multisig.MULTISIG_CONFIRM_METHODS, '0')
        // create multisig account instance and deploy contract
        const accountMultisig = new nearApi.multisig.AccountMultisig(near.connection, newAccountName, options);
        accountMultisig.useConfirmKey = async () => {
            await near.connection.signer.setKey(networkId, options.masterAccount, confirmKeyPair);
        };
        accountMultisig.getRecoveryMethods = () => ({ data: [] });
        accountMultisig.postSignedJson = async (path) => {
            switch (path) {
            case '/2fa/getAccessKey': return { publicKey };
            }
        };
        await accountMultisig.deployMultisig(new Uint8Array([...(await fs.readFile(MULTISIG_WASM_PATH))]));
        return accountMultisig;
    } catch (e) {
        console.log(e);
    }
}

async function deployContract(workingAccount, contractId) {
    const newPublicKey = await workingAccount.connection.signer.createKey(contractId, networkId);
    const data = [...(await fs.readFile(HELLO_WASM_PATH))];
    await workingAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
    return new nearApi.Contract(workingAccount, contractId, HELLO_WASM_METHODS);
}

function sleep(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

function waitFor(fn) {
    const _waitFor = async (count = 10) => {
        try {
            return await fn();
        } catch (e) {
            if (count > 0) {
                await sleep(500);
                return _waitFor(count - 1);
            }
            else throw e;
        }
    };

    return _waitFor();
}

async function ensureDir(dirpath) {
    try {
        await fs.mkdir(dirpath, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

module.exports = {
    setUpTestConnection,
    networkId,
    generateUniqueString,
    createAccount,
    createAccountMultisig,
    deployContract,
    sleep,
    waitFor,
    ensureDir,
    HELLO_WASM_PATH,
    HELLO_WASM_BALANCE,
};

'''
'''--- packages/providers/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/providers/test/fetch_json.test.js ---
const { fetchJson } = require('../lib');

describe('fetchJson', () => {
    test('string parameter in fetchJson', async () => {
        const RPC_URL = 'https://rpc.testnet.near.org';
        const statusRequest = {
            'jsonrpc': '2.0',
            'id': 'dontcare',
            'method': 'status',
            'params': []
        };
        const result = await fetchJson(RPC_URL, JSON.stringify(statusRequest));
        expect(result.result.chain_id).toBe('testnet');
    });
    test('object parameter in fetchJson', async () => {
        const connection = { url: 'https://rpc.testnet.near.org' };
        const statusRequest = {
            'jsonrpc': '2.0',
            'id': 'dontcare',
            'method': 'status',
            'params': []
        };
        const result = await fetchJson(connection, JSON.stringify(statusRequest));
        expect(result.result.chain_id).toBe('testnet');
    });
});

'''
'''--- packages/providers/test/providers.test.js ---
const { getTransactionLastResult } = require('@near-js/utils');
const { Worker } = require('near-workspaces');
const { JsonRpcProvider, FailoverRpcProvider } = require('../lib');

jest.setTimeout(20000);

['json provider', 'fallback provider'].forEach((name) => {
    describe(name, () => {
        let worker;
        let provider;

        beforeAll(async () => {
            worker = await Worker.init();

            if (name === 'json provider') {
                provider = new JsonRpcProvider({
                    url: worker.manager.config.rpcAddr,
                });
            } else if (name === 'fallback provider') {
                provider = new FailoverRpcProvider([
                    new JsonRpcProvider({
                        url: worker.manager.config.rpcAddr,
                    }),
                ]);
            }

            await new Promise((resolve) => setTimeout(resolve, 2000));
        });

        afterAll(async () => {
            await worker.tearDown();
        });

        test('rpc fetch node status', async () => {
            let response = await provider.status();
            expect(response.chain_id).toBeTruthy();
        });
        
        test('rpc fetch block info', async () => {
            let stat = await provider.status();
            let height = stat.sync_info.latest_block_height - 1;
            let response = await provider.block({ blockId: height });
            expect(response.header.height).toEqual(height);
        
            let sameBlock = await provider.block({ blockId: response.header.hash });
            expect(sameBlock.header.height).toEqual(height);
        
            let optimisticBlock = await provider.block({ finality: 'optimistic' });
            expect(optimisticBlock.header.height - height).toBeLessThan(5);
        
            let nearFinalBlock = await provider.block({ finality: 'near-final' });
            expect(nearFinalBlock.header.height - height).toBeLessThan(5);
        
            let finalBlock = await provider.block({ finality: 'final' });
            expect(finalBlock.header.height - height).toBeLessThan(5);
        });
        
        test('rpc fetch block changes', async () => {
            let stat = await provider.status();
            let height = stat.sync_info.latest_block_height - 1;
            let response = await provider.blockChanges({ blockId: height });
        
            expect(response).toMatchObject({
                block_hash: expect.any(String),
                changes: expect.any(Array)
            });
        });
        
        test('rpc fetch chunk info', async () => {
            let stat = await provider.status();
            let height = stat.sync_info.latest_block_height - 1;
            let response = await provider.chunk([height, 0]);
            expect(response.header.shard_id).toEqual(0);
            let sameChunk = await provider.chunk(response.header.chunk_hash);
            expect(sameChunk.header.chunk_hash).toEqual(response.header.chunk_hash);
            expect(sameChunk.header.shard_id).toEqual(0);
        });
        
        test('rpc fetch validators info', async () => {
            let validators = await provider.validators(null);
            expect(validators.current_validators.length).toBeGreaterThanOrEqual(1);
        });
        
        test('rpc query with block_id', async () => {
            const stat = await provider.status();
            let block_id = stat.sync_info.latest_block_height - 1;
        
            const response = await provider.query({
                block_id,
                request_type: 'view_account',
                account_id: 'test.near'
            });
        
            expect(response).toEqual({
                block_height: expect.any(Number),
                block_hash: expect.any(String),
                amount: expect.any(String),
                locked: expect.any(String),
                code_hash: '11111111111111111111111111111111',
                storage_usage: 182,
                storage_paid_at: 0,
            });
        });
        
        test('rpc query view_account', async () => {
            const response = await provider.query({
                request_type: 'view_account',
                finality: 'final',
                account_id: 'test.near'
            });
        
            expect(response).toEqual({
                block_height: expect.any(Number),
                block_hash: expect.any(String),
                amount: expect.any(String),
                locked: expect.any(String),
                code_hash: '11111111111111111111111111111111',
                storage_usage: 182,
                storage_paid_at: 0,
            });
        });
        
        test('json rpc fetch protocol config', async () => {
            const status = await provider.status();
            const blockHeight = status.sync_info.latest_block_height;
            const blockHash = status.sync_info.latest_block_hash;
            for (const blockReference of [{ sync_checkpoint: 'genesis' }, { blockId: blockHeight }, { blockId: blockHash }, { finality: 'final' }, { finality: 'optimistic' }]) {
                const response = await provider.experimental_protocolConfig(blockReference);
                expect('chain_id' in response).toBe(true);
                expect('genesis_height' in response).toBe(true);
                expect('runtime_config' in response).toBe(true);
                expect('storage_amount_per_byte' in response.runtime_config).toBe(true);
            }
        });
        
        test('json rpc gas price', async () => {
            let status = await provider.status();
            let positiveIntegerRegex = /^[+]?\d+([.]\d+)?$/;
        
            let response1 = await provider.gasPrice(status.sync_info.latest_block_height);
            expect(response1.gas_price).toMatch(positiveIntegerRegex);
        
            let response2 = await provider.gasPrice(status.sync_info.latest_block_hash);
            expect(response2.gas_price).toMatch(positiveIntegerRegex);
        
            let response3 = await provider.gasPrice();
            expect(response3.gas_price).toMatch(positiveIntegerRegex);
        });
        
        test('near json rpc fetch node status', async () => {
            let response = await provider.status();
            expect(response.chain_id).toBeTruthy();
        });
    });
});

describe('json provider', () => {
    test('JsonRpc connection object exist without connectionInfo provided', async () => {
        const provider = new JsonRpcProvider();
        expect(provider.connection).toStrictEqual({ url: '' });
    });
});

describe('failover provider', () => {
    beforeAll(async () => {});

    test('FailoverRpc throws error on empty list of providers in constructor', async () => {
        expect(() => new FailoverRpcProvider([])).toThrow();
    });

    test('FailoverRpc uses first provider as default', async () => {
        const jsonProviders = [
            Object.setPrototypeOf(
                {
                    status() {
                        return 'first';
                    },
                },
                JsonRpcProvider.prototype
            ),
            Object.setPrototypeOf(
                {
                    status() {
                        return 'second';
                    },
                },
                JsonRpcProvider.prototype
            ),
        ];

        const provider = new FailoverRpcProvider(jsonProviders);

        expect(await provider.status()).toBe('first');
    });

    test('FailoverRpc switches to next provider in case of error', async () => {
        const jsonProviders = [
            Object.setPrototypeOf(
                {
                    status() {
                        throw new Error();
                    },
                },
                JsonRpcProvider.prototype
            ),
            Object.setPrototypeOf(
                {
                    status() {
                        return 'second';
                    },
                },
                JsonRpcProvider.prototype
            ),
        ];

        const provider = new FailoverRpcProvider(jsonProviders);

        expect(await provider.status()).toBe('second');
    });

    test('FailoverRpc returns error if all providers are unavailable', async () => {
        const jsonProviders = [
            Object.setPrototypeOf(
                {
                    status() {
                        throw new Error();
                    },
                },
                JsonRpcProvider.prototype
            ),
            Object.setPrototypeOf(
                {
                    status() {
                        throw new Error();
                    },
                },
                JsonRpcProvider.prototype
            ),
        ];

        const provider = new FailoverRpcProvider(jsonProviders);

        await expect(() => provider.status()).rejects.toThrow();
    });
});

test('final tx result', async () => {
    const result = {
        status: { SuccessValue: 'e30=' },
        transaction: {
            id: '11111',
            outcome: {
                status: { SuccessReceiptId: '11112' },
                logs: [],
                receipt_ids: ['11112'],
                gas_burnt: 1,
            },
        },
        receipts: [
            {
                id: '11112',
                outcome: {
                    status: { SuccessValue: 'e30=' },
                    logs: [],
                    receipt_ids: ['11112'],
                    gas_burnt: 9001,
                },
            },
            {
                id: '11113',
                outcome: {
                    status: { SuccessValue: '' },
                    logs: [],
                    receipt_ids: [],
                    gas_burnt: 0,
                },
            },
        ],
    };
    expect(getTransactionLastResult(result)).toEqual({});
});

test('final tx result with null', async () => {
    const result = {
        status: 'Failure',
        transaction: {
            id: '11111',
            outcome: {
                status: { SuccessReceiptId: '11112' },
                logs: [],
                receipt_ids: ['11112'],
                gas_burnt: 1,
            },
        },
        receipts: [
            {
                id: '11112',
                outcome: {
                    status: 'Failure',
                    logs: [],
                    receipt_ids: ['11112'],
                    gas_burnt: 9001,
                },
            },
            {
                id: '11113',
                outcome: {
                    status: { SuccessValue: '' },
                    logs: [],
                    receipt_ids: [],
                    gas_burnt: 0,
                },
            },
        ],
    };
    expect(getTransactionLastResult(result)).toEqual(null);
});

// TODO: Use a near-workspaces Worker when time traveling is available
test('json rpc get next light client block', async () => {
    const provider = new JsonRpcProvider({ url: 'https://rpc.testnet.near.org' });
    const stat = await provider.status();

    // Get block in at least the last epoch (epoch duration 43,200 blocks on mainnet and testnet)
    const height = stat.sync_info.latest_block_height;
    const protocolConfig = await provider.experimental_protocolConfig({ finality: 'final' });

    // NOTE: This will underflow if the network used has not produced an epoch yet. If a new network
    // config is required, can retrieve a block a few height behind (1+buffer for indexing). If run
    // on a fresh network, would need to wait for blocks to be produced and indexed.
    const prevEpochHeight = height - protocolConfig.epoch_length;
    const prevBlock = await provider.block({ blockId: prevEpochHeight });
    const nextBlock = await provider.nextLightClientBlock({ last_block_hash: prevBlock.header.hash });
    expect('inner_lite' in nextBlock).toBeTruthy();
    // Verify that requesting from previous epoch includes the set of new block producers.
    expect('next_bps' in nextBlock).toBeTruthy();

    // Greater than or equal check because a block could have been produced during the test.
    // There is a buffer of 10 given to the height, because this seems to be lagging behind the
    // latest finalized block by a few seconds. This delay might just be due to slow or delayed
    // indexing in a node's db. If this fails in the future, we can increase the buffer.
    expect(nextBlock.inner_lite.height).toBeGreaterThanOrEqual(height - 10);
    expect(nextBlock.inner_lite.height).toBeGreaterThan(prevEpochHeight);
    expect('prev_block_hash' in nextBlock).toBeTruthy();
    expect('next_block_inner_hash' in nextBlock).toBeTruthy();
    expect('inner_rest_hash' in nextBlock).toBeTruthy();
    expect('approvals_after_next' in nextBlock).toBeTruthy();
});
'''
'''--- packages/signers/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/signers/test/signer.test.js ---
const { InMemoryKeyStore } = require('@near-js/keystores');

const { InMemorySigner } = require('../lib');

test('test no key', async() => {
    const signer = new InMemorySigner(new InMemoryKeyStore());
    await expect(signer.signMessage('message', 'user', 'network'))
        .rejects.toThrow(/Key for user not found in network/);
});

'''
'''--- packages/transactions/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/transactions/test/serialize.test.js ---
const { KeyPair, PublicKey } = require('@near-js/crypto');
const { InMemoryKeyStore } = require('@near-js/keystores');
const { InMemorySigner } = require('@near-js/signers');
const { Assignable } = require('@near-js/types');
const { baseDecode, baseEncode } = require('@near-js/utils');
const fs = require('fs');
const { deserialize, serialize } = require('borsh');

const {
    actionCreators,
    createTransaction,
    decodeSignedTransaction,
    decodeTransaction,
    encodeTransaction,
    SCHEMA,
    signTransaction,
} = require('../lib');

const {
    addKey,
    createAccount,
    deleteAccount,
    deleteKey,
    deployContract,
    functionCall,
    functionCallAccessKey,
    stake,
    transfer,
} = actionCreators;

class Test extends Assignable {
}

test('serialize object', async () => {
    const value = new Test({ x: 255, y: 20, z: '123', q: [1, 2, 3] });
    const schema = { struct: { x: 'u8', y: 'u16', z: 'string', q: { array: { type: 'u8' } } } };
    let buf = serialize(schema, value);
    let new_value = new Test(deserialize(schema, buf));
    expect(new_value.x).toEqual(255);
    expect(new_value.y.toString()).toEqual('20');
    expect(new_value.z).toEqual('123');
    expect(new_value.q).toEqual([1, 2, 3]);
});

test('deserialize delegate', async () => {
    const serialized = [8, 16, 0, 0, 0, 116, 104, 101, 45, 117, 115, 101, 114, 46, 116, 101, 115, 116, 110, 101, 116, 27, 0, 0, 0, 104, 101, 108, 108, 111, 46, 110, 101, 97, 114, 45, 101, 120, 97, 109, 112, 108, 101, 115, 46, 116, 101, 115, 116, 110, 101, 116, 1, 0, 0, 0, 2, 12, 0, 0, 0, 115, 101, 116, 95, 103, 114, 101, 101, 116, 105, 110, 103, 20, 0, 0, 0, 123, 34, 103, 114, 101, 101, 116, 105, 110, 103, 34, 58, 34, 72, 101, 108, 108, 111, 34, 125, 0, 224, 87, 235, 72, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 120, 166, 131, 144, 0, 0, 61, 158, 123, 9, 0, 0, 0, 0, 0, 154, 156, 80, 116, 108, 65, 42, 39, 47, 253, 146, 109, 67, 106, 83, 230, 57, 183, 195, 122, 150, 6, 246, 220, 173, 35, 120, 139, 167, 94, 183, 29, 0, 41, 98, 10, 45, 51, 177, 89, 159, 190, 247, 41, 255, 243, 17, 186, 140, 168, 139, 9, 81, 33, 8, 74, 73, 85, 254, 127, 62, 54, 193, 60, 50, 235, 49, 13, 37, 152, 94, 172, 24, 198, 220, 119, 148, 99, 89, 19, 187, 251, 80, 76, 230, 77, 28, 80, 140, 133, 81, 139, 159, 62, 245, 167, 4];
    const { signedDelegate: { delegateAction } } = deserialize(SCHEMA.Action, serialized);
    expect(delegateAction.senderId).toEqual('the-user.testnet');
    expect(delegateAction.receiverId).toEqual('hello.near-examples.testnet');
    expect(String(delegateAction.nonce)).toEqual('158895108000003');
});

test('serialize and sign multi-action tx', async () => {
    const keyStore = new InMemoryKeyStore();
    const keyPair = KeyPair.fromString('ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');
    await keyStore.setKey('test', 'test.near', keyPair);
    const publicKey = keyPair.publicKey;
    const actions = [
        createAccount(),
        deployContract(new Uint8Array([1, 2, 3])),
        functionCall('qqq', new Uint8Array([1, 2, 3]), 1000, 1000000),
        transfer(123),
        stake(1000000, publicKey),
        addKey(publicKey, functionCallAccessKey('zzz', ['www'], null)),
        deleteKey(publicKey),
        deleteAccount('123')
    ];
    const blockHash = baseDecode('244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM');
    let [hash, { transaction }] = await signTransaction('123', 1, actions, blockHash, new InMemorySigner(keyStore), 'test.near', 'test');
    expect(baseEncode(hash)).toEqual('Fo3MJ9XzKjnKuDuQKhDAC6fra5H2UWawRejFSEpPNk3Y');
    const serialized = Buffer.from(serialize(SCHEMA.Transaction, transaction));
    expect(serialized.toString('hex')).toEqual('09000000746573742e6e656172000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef80100000000000000030000003132330fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef608000000000103000000010203020300000071717103000000010203e80300000000000040420f00000000000000000000000000037b0000000000000000000000000000000440420f00000000000000000000000000000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef805000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef800000000000000000000030000007a7a7a010000000300000077777706000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef80703000000313233');
});

function createTransferTx() {
    const actions = [
        transfer(1),
    ];
    const blockHash = baseDecode('244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM');
    return createTransaction(
        'test.near',
        PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
        'whatever.near',
        1,
        actions,
        blockHash);
}

test('serialize transfer tx', async () => {
    const transaction = createTransferTx();

    const serialized = encodeTransaction(transaction);
    expect(Buffer.from(serialized).toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef6010000000301000000000000000000000000000000');

    const deserialized = decodeTransaction(serialized);
    expect(encodeTransaction(deserialized)).toEqual(serialized);
});

async function createKeyStore() {
    const keyStore = new InMemoryKeyStore();
    const keyPair = KeyPair.fromString('ed25519:3hoMW1HvnRLSFCLZnvPzWeoGwtdHzke34B2cTHM8rhcbG3TbuLKtShTv3DvyejnXKXKBiV7YPkLeqUHN1ghnqpFv');
    await keyStore.setKey('test', 'test.near', keyPair);
    return keyStore;
}

async function verifySignedTransferTx(signedTx) {
    expect(Buffer.from(signedTx.signature.data).toString('base64')).toEqual('lpqDMyGG7pdV5IOTJVJYBuGJo9LSu0tHYOlEQ+l+HE8i3u7wBZqOlxMQDtpuGRRNp+ig735TmyBwi6HY0CG9AQ==');
    const serialized = encodeTransaction(signedTx);
    expect(Buffer.from(serialized).toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef601000000030100000000000000000000000000000000969a83332186ee9755e4839325525806e189a3d2d2bb4b4760e94443e97e1c4f22deeef0059a8e9713100eda6e19144da7e8a0ef7e539b20708ba1d8d021bd01');

    const deserialized = decodeSignedTransaction(serialized);
    expect(encodeTransaction(deserialized)).toEqual(serialized);
}

test('serialize and sign transfer tx', async () => {
    const transaction = createTransferTx();
    const keyStore = await createKeyStore();

    let [, signedTx] = await signTransaction(transaction.receiverId, transaction.nonce, transaction.actions, transaction.blockHash, new InMemorySigner(keyStore), 'test.near', 'test');

    verifySignedTransferTx(signedTx);
});

test('serialize and sign transfer tx object', async () => {
    const transaction = createTransferTx();
    const keyStore = await createKeyStore();

    let [, signedTx] = await signTransaction(transaction, new InMemorySigner(keyStore), 'test.near', 'test');

    verifySignedTransferTx(signedTx);
});

describe('roundtrip test', () => {
    const dataDir = './test/data';
    const testFiles = fs.readdirSync(dataDir);
    for (const testFile of testFiles) {
        if (/.+\.json$/.test(testFile)) {
            const testDefinition = JSON.parse(fs.readFileSync(dataDir + '/' + testFile));
            test(testFile, () => {
                const data = Buffer.from(testDefinition.data, 'hex');
                const type = testDefinition.type;
                const deserialized = deserialize(SCHEMA[type], Uint8Array.from(data));
                const serialized = Buffer.from(serialize(SCHEMA[type], deserialized));
                expect(serialized).toEqual(data);
            });
        }
    }
});

describe('serialize and deserialize on different types of nonce', () => {
    const actions = [
        transfer(1),
    ];
    const blockHash = baseDecode('244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM');
    const targetNonce = BigInt(1);
    test('number typed nonce', async () => {
        const transaction = createTransaction(
            'test.near',
            PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
            'whatever.near',
            1,
            actions,
            blockHash);
        const serialized = encodeTransaction(transaction);
        expect(Buffer.from(serialized).toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef6010000000301000000000000000000000000000000');
        const deserialized = decodeTransaction(serialized);
        expect(encodeTransaction(deserialized)).toEqual(serialized);
        expect(deserialized.nonce.toString()).toEqual(targetNonce.toString());
    });

    test('string typed nonce', async () => {
        const transaction = createTransaction(
            'test.near',
            PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
            'whatever.near',
            '1',
            actions,
            blockHash);
        const serialized = encodeTransaction(transaction);
        expect(Buffer.from(serialized).toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef6010000000301000000000000000000000000000000');
        const deserialized = decodeTransaction(serialized);
        expect(encodeTransaction(deserialized)).toEqual(serialized);
        expect(deserialized.nonce.toString()).toEqual(targetNonce.toString());
    });

    test('BigInt typed nonce', async () => {
        const transaction = createTransaction(
            'test.near',
            PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
            'whatever.near',
            BigInt(1),
            actions,
            blockHash);
        const serialized = encodeTransaction(transaction);
        expect(Buffer.from(serialized).toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef6010000000301000000000000000000000000000000');
        const deserialized = decodeTransaction(serialized);
        expect(encodeTransaction(deserialized)).toEqual(serialized);
        expect(deserialized.nonce.toString()).toEqual(targetNonce.toString());
    });
});

'''
'''--- packages/transactions/test/transaction.test.js ---
const { actionCreators } = require('../lib');

const { functionCall } = actionCreators;

test('functionCall with already serialized args', () => {
    const serializedArgs = Buffer.from('{}');
    const action = functionCall('methodName', serializedArgs, BigInt(1), BigInt(2));    
    expect(action).toMatchObject({ 
        functionCall: {
            methodName: 'methodName',
            args: serializedArgs,
            gas: BigInt(1),
            deposit: BigInt(2)
        }
    });
});

test('functionCall with non-serialized args', () => {
    const serializedArgs = Buffer.from('{}');
    const action = functionCall('methodName', {}, BigInt(1), BigInt(2));    
    expect(action).toMatchObject({ 
        functionCall: {
            methodName: 'methodName',
            args: serializedArgs,
            gas: BigInt(1),
            deposit: BigInt(2)
        }
    });
});

'''
'''--- packages/utils/fetch_error_schema.js ---
const https = require('https');
const fs = require('fs');

const ERROR_SCHEMA_URL =
    'https://raw.githubusercontent.com/near/nearcore/master/chain/jsonrpc/res/rpc_errors_schema.json';
const TARGET_SCHEMA_FILE_PATH = `${process.argv[2] ||  process.cwd()}/src/errors/rpc_error_schema.json`;

https
    .get(ERROR_SCHEMA_URL, resp => {
        let data = '';

        resp.on('data', chunk => {
            data += chunk;
        });

        resp.on('end', () => {
            fs.writeFileSync(TARGET_SCHEMA_FILE_PATH, data);
        });
    })
    .on('error', err => {
        console.log('Unable to fetch schema file: ' + err.message);
    });

'''
'''--- packages/utils/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/utils/test/format.test.js ---
const { formatNearAmount, parseNearAmount, NEAR_NOMINATION } = require('../lib');

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

test.each`
    balance                              | fracDigits   | expected
    ${'8999999999837087887'}             | ${undefined} | ${'0.000008999999999837087887'}
    ${'8099099999837087887'}             | ${undefined} | ${'0.000008099099999837087887'}
    ${'999998999999999837087887000'}     | ${undefined} | ${'999.998999999999837087887'}
    ${'1'+'0'.repeat(13)}                | ${undefined} | ${'0.00000000001'}
    ${'9999989999999998370878870000000'} | ${undefined} | ${'9,999,989.99999999837087887'}
    ${'000000000000000000000000'}        | ${undefined} | ${'0'}
    ${'1000000000000000000000000'}       | ${undefined} | ${'1'}
    ${'999999999999999999000000'}        | ${undefined} | ${'0.999999999999999999'}
    ${'999999999999999999000000'}        | ${10}        | ${'1'}
    ${'1003000000000000000000000'}       | ${3}         | ${'1.003'}
    ${'3000000000000000000000'}          | ${3}         | ${'0.003'}
    ${'3000000000000000000000'}          | ${4}         | ${'0.003'}
    ${'3500000000000000000000'}          | ${3}         | ${'0.004'}
    ${'03500000000000000000000'}         | ${3}         | ${'0.004'}
    ${'10000000999999997410000000'}      | ${undefined} | ${'10.00000099999999741'}
    ${'10100000999999997410000000'}      | ${undefined} | ${'10.10000099999999741'}
    ${'10040000999999997410000000'}      | ${2}         | ${'10.04'}
    ${'10999000999999997410000000'}      | ${2}         | ${'11'}
    ${'1000000100000000000000000000000'} | ${undefined} | ${'1,000,000.1'}
    ${'1000100000000000000000000000000'} | ${undefined} | ${'1,000,100'}
    ${'910000000000000000000000'}        | ${0}         | ${'1'}
`('formatNearAmount($balance, $fracDigits) returns $expected', ({ balance, fracDigits, expected }) => {
    expect(formatNearAmount(balance, fracDigits)).toEqual(expected);
});

test.each`
    amt                               | expected
    ${null}                           | ${null}
    ${'5.3'}                          | ${'5300000000000000000000000'}
    ${'5'}                            | ${'5000000000000000000000000'}
    ${'1'}                            | ${'1000000000000000000000000'}
    ${'10'}                           | ${'10000000000000000000000000'}
    ${'0.000008999999999837087887'}   | ${'8999999999837087887'}
    ${'0.000008099099999837087887'}   | ${'8099099999837087887'}
    ${'999.998999999999837087887000'} | ${'999998999999999837087887000'}
    ${'0.000000000000001'}            | ${'1000000000'}
    ${'0'}                            | ${'0'}
    ${'0.000'}                        | ${'0'}
    ${'0.000001'}                     | ${'1000000000000000000'}
    ${'.000001'}                      | ${'1000000000000000000'}
    ${'000000.000001'}                | ${'1000000000000000000'}
    ${'1,000,000.1'}                  | ${'1000000100000000000000000000000'}
`('parseNearAmount($amt) returns $expected', ({ amt, expected }) => {
    expect(parseNearAmount(amt)).toStrictEqual(expected);
});

test('parseNearAmount fails when parsing values with 25 decimal places', () => {
    expect(() => {
        parseNearAmount('0.0000080990999998370878871');
    }).toThrowError(
        'Cannot parse \'0.0000080990999998370878871\' as NEAR amount'
    );
});

test('NEAR_NOMINATION value', () => {
    expect(NEAR_NOMINATION).toEqual(1000000000000000000000000n)
})

'''
'''--- packages/utils/test/logger.test.js ---
const { Logger } = require('../lib');

describe('logger', () => {
    let logs;

    beforeEach(async () => {
        logs = [];

        const custom = {
            verbose: (...args) => {
                logs.push(args.join(''));
            },
            debug: (...args) => {
                logs.push(args.join(''));
            },
            log: (...args) => {
                logs.push(args.join(''));
            },
            warn: (...args) => {
                logs.push(args.join(''));
            },
            error: (...args) => {
                logs.push(args.join(''));
            },
            fatal: (...args) => {
                logs.push(args.join(''));
            },
        };

        Logger.overrideLogger(custom);
    });

    test('test logger can be overrided', async () => {
        Logger.log('111');
        Logger.debug('11s1');
        Logger.warn('1111');
        Logger.error('1131');
        Logger.log('112');

        expect(logs.length).toBe(5);
    });

    test('test logger can be disabled', async () => {
        Logger.overrideLogger(undefined);

        Logger.log('111');
        Logger.log('222');

        expect(logs.length).toBe(0);
    });

    test('test logged data is accurate', async () => {
        Logger.log('lol');
        expect(logs[0]).toEqual('lol');

        Logger.log('his name is ', 'test');
        expect(logs[1]).toEqual('his name is test');
    });
});

'''
'''--- packages/utils/test/rpc-errors.test.js ---
const { formatError, getErrorTypeFromErrorMessage, parseRpcError, ServerError } = require('../lib');

describe('rpc-errors', () => {
    test('test AccountAlreadyExists error', async () => {
        let rpc_error = {
            TxExecutionError: {
                ActionError: {
                    index: 1,
                    kind: {AccountAlreadyExists: {account_id: 'bob.near'}}
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'AccountAlreadyExists').toBe(true);
        expect(error.index).toBe(1);
        expect(error.account_id).toBe('bob.near');
        expect(formatError(error.type, error)).toBe('Can\'t create a new account bob.near, because it already exists');
    });

    test('test ReceiverMismatch error', async () => {
        let rpc_error = {
            TxExecutionError: {
                InvalidTxError: {
                    InvalidAccessKeyError: {
                        ReceiverMismatch: {
                            ak_receiver: 'test.near',
                            tx_receiver: 'bob.near'
                        }
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'ReceiverMismatch').toBe(true);
        expect(error.ak_receiver).toBe('test.near');
        expect(error.tx_receiver).toBe('bob.near');
        expect(formatError(error.type, error)).toBe(
            'Wrong AccessKey used for transaction: transaction is sent to receiver_id=bob.near, but is signed with function call access key that restricted to only use with receiver_id=test.near. Either change receiver_id in your transaction or switch to use a FullAccessKey.'
        );
    });

    test('test InvalidIteratorIndex error', async () => {
        let rpc_error = {
            TxExecutionError: {
                ActionError: {
                    FunctionCallError: {
                        HostError: {
                            InvalidIteratorIndex: {iterator_index: 42}
                        }
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type).toBe('ActionError');
        expect(formatError(error.type, error)).toBe('{\"type\":\"ActionError\",\"kind\":{\"FunctionCallError\":{\"HostError\":{\"InvalidIteratorIndex\":{\"iterator_index\":42}}}}}');
    });

    test('test ActionError::FunctionCallError::GasLimitExceeded error', async () => {
        let rpc_error = {
            ActionError: {
                'index': 0,
                'kind': {
                    FunctionCallError: {
                        'HostError': 'GasLimitExceeded'
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type).toBe('ActionError');

        expect(formatError(error.type, error)).toBe('{\"type\":\"ActionError\",\"index\":0,\"kind\":{\"index\":0,\"kind\":{\"FunctionCallError\":{\"HostError\":\"GasLimitExceeded\"}}}}');
    });

    test('test parse error object', async () => {
        const errorStr = '{"status":{"Failure":{"ActionError":{"index":0,"kind":{"FunctionCallError":{"EvmError":"ArgumentParseError"}}}}},"transaction":{"signer_id":"test.near","public_key":"ed25519:D5HVgBE8KgXkSirDE4UQ8qwieaLAR4wDDEgrPRtbbNep","nonce":110,"receiver_id":"evm","actions":[{"FunctionCall":{"method_name":"transfer","args":"888ZO7SvECKvfSCJ832LrnFXuF/QKrSGztwAAA==","gas":300000000000000,"deposit":"0"}}],"signature":"ed25519:7JtWQ2Ux63ixaKy7bTDJuRTWnv6XtgE84ejFMMjYGKdv2mLqPiCfkMqbAPt5xwLWwFdKjJniTcxWZe7FdiRWpWv","hash":"E1QorKKEh1WLJwRQSQ1pdzQN3f8yeFsQQ8CbJjnz1ZQe"},"transaction_outcome":{"proof":[],"block_hash":"HXXBPjGp65KaFtam7Xr67B8pZVGujZMZvTmVW6Fy9tXf","id":"E1QorKKEh1WLJwRQSQ1pdzQN3f8yeFsQQ8CbJjnz1ZQe","outcome":{"logs":[],"receipt_ids":["ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL"],"gas_burnt":2428001493624,"tokens_burnt":"2428001493624000000000","executor_id":"test.near","status":{"SuccessReceiptId":"ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL"}}},"receipts_outcome":[{"proof":[],"block_hash":"H6fQCVpxBDv9y2QtmTVHoxHibJvamVsHau7fDi7AmFa2","id":"ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL","outcome":{"logs":[],"receipt_ids":["DgRyf1Wv3ZYLFvM8b67k2yZjdmnyUUJtRkTxAwoFi3qD"],"gas_burnt":2428001493624,"tokens_burnt":"2428001493624000000000","executor_id":"evm","status":{"Failure":{"ActionError":{"index":0,"kind":{"FunctionCallError":{"EvmError":"ArgumentParseError"}}}}}}},{"proof":[],"block_hash":"9qNVA235L9XdZ8rZLBAPRNBbiGPyNnMUfpbi9WxbRdbB","id":"DgRyf1Wv3ZYLFvM8b67k2yZjdmnyUUJtRkTxAwoFi3qD","outcome":{"logs":[],"receipt_ids":[],"gas_burnt":0,"tokens_burnt":"0","executor_id":"test.near","status":{"SuccessValue":""}}}]}';
        const error = parseRpcError(JSON.parse(errorStr).status.Failure);
        expect(error).toEqual(new ServerError('{"index":0,"kind":{"index":0,"kind":{"FunctionCallError":{"EvmError":"ArgumentParseError"}}}}'));
    });

    test('test getErrorTypeFromErrorMessage', () => {
        const err1 = 'account random.near does not exist while viewing';
        const err2 = 'Account random2.testnet doesn\'t exist';
        const err3 = 'access key ed25519:DvXowCpBHKdbD2qutgfhG6jvBMaXyUh7DxrDSjkLxMHp does not exist while viewing';
        const err4 = 'wasm execution failed with error: CompilationError(CodeDoesNotExist { account_id: "random.testnet" })';
        const err5 = '[-32000] Server error: Invalid transaction: Transaction nonce 1 must be larger than nonce of the used access key 1';
        const err6 = 'wasm execution failed with error: MethodResolveError(MethodNotFound)';
        const err7 = 'wasm execution failed with error: FunctionCallError(CompilationError(CodeDoesNotExist { account_id: "random.testnet" }))';
        const err8 = 'wasm execution failed with error: FunctionCallError(MethodResolveError(MethodNotFound))';
        expect(getErrorTypeFromErrorMessage(err1)).toEqual('AccountDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err2)).toEqual('AccountDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err3)).toEqual('AccessKeyDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err4)).toEqual('CodeDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err5)).toEqual('InvalidNonce');
        expect(getErrorTypeFromErrorMessage(err6)).toEqual('MethodNotFound');
        expect(getErrorTypeFromErrorMessage(err7)).toEqual('CodeDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err8)).toEqual('MethodNotFound');
    });

    test('test NotEnoughBalance message uses human readable values', () => {
        const error = parseRpcError({
            NotEnoughBalance: {
                balance: '1000000000000000000000000',
                cost: '10000000000000000000000000',
                signer_id: 'test.near'
            }
        });

        expect(error.message).toEqual('Sender test.near does not have enough balance 1 for operation costing 10');
    });

    test('test TriesToStake message uses human readable values', () => {
        const error = parseRpcError({
            TriesToStake: {
                account_id: 'test.near',
                balance: '9000000000000000000000000',
                locked: '1000000000000000000000000',
                stake: '10000000000000000000000000',
            }
        });

        expect(error.message).toEqual('Account test.near tried to stake 10, but has staked 1 and only has 9');
    });
});

'''
'''--- packages/utils/test/validator.test.js ---
const { diffEpochValidators, findSeatPrice } = require('../lib');

test('find seat price', async () => {
    expect(findSeatPrice(
        [{stake: '1000000'}, {stake: '1000000'}, {stake: '100'}], 2, [1, 6250], 49
    )).toEqual(BigInt('101'));
    expect(findSeatPrice(
        [{stake: '1000000'}, {stake: '1000000'}, {stake: '100'}], 3, [1, 6250]
    )).toEqual(BigInt('101'));
    expect(findSeatPrice(
        [{stake: '1000000'}, {stake: '1000000'}, {stake: '100'}], 4, [1, 6250], 49
    )).toEqual(BigInt('320'));
    expect(findSeatPrice(
        [{stake: '1000000'}, {stake: '1000000'}, {stake: '100'}], 4, [1, 6250], 48
    )).toEqual(BigInt('500000'));
    expect(findSeatPrice(
        [{stake: '1000'}, {stake: '1000'}, {stake: '200'}], 100, [1, 25]
    )).toEqual(BigInt('88'));
});

test('diff validators', async () => {
    expect(diffEpochValidators(
        [{account_id: 'x', stake: '10'}],
        [{ account_id: 'x', stake: '10' }]
    )).toEqual({newValidators: [], removedValidators: [], changedValidators: []});
    expect(diffEpochValidators(
        [{ account_id: 'x', stake: '10' }, { account_id: 'y', stake: '10' }],
        [{ account_id: 'x', stake: '11' }, { account_id: 'z', stake: '11' }]
    )).toEqual({
        newValidators: [{ account_id: 'z', stake: '11' }],
        removedValidators: [{ account_id: 'y', stake: '10' }],
        changedValidators: [{ 
            current: { account_id: 'x', stake: '10' },
            next: { account_id: 'x', stake: '11' }
        }]
    });
});

'''
'''--- packages/wallet-account/jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- packages/wallet-account/test/wallet_account.test.js ---
const { KeyPair, PublicKey } = require('@near-js/crypto');
const { InMemoryKeyStore } = require('@near-js/keystores');
const { InMemorySigner } = require('@near-js/signers');
const { baseDecode } = require('@near-js/utils');
const { actionCreators, createTransaction, SCHEMA } = require('@near-js/transactions');
const { deserialize } = require('borsh');
const localStorage = require('localstorage-memory');
const url = require('url');

const { WalletConnection } = require('../lib/wallet_account');

const { functionCall, transfer } = actionCreators;

// If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
const MULTISIG_HAS_METHOD = 'add_request_and_confirm';

let lastRedirectUrl;
let lastTransaction;
global.window = {
    localStorage
};
global.document = {
    title: 'documentTitle'
};

let history;
let nearFake;
let walletConnection;
let keyStore = new InMemoryKeyStore();
beforeEach(() => {
    keyStore.clear();
    nearFake = {
        config: {
            networkId: 'networkId',
            contractName: 'contractId',
            walletUrl: 'http://example.com/wallet',
        },
        connection: {
            networkId: 'networkId',
            signer: new InMemorySigner(keyStore)
        },
        account() {
            return {
                state() {}
            };
        }
    };
    lastRedirectUrl = null;
    history = [];
    Object.assign(global.window, {
        location: {
            href: 'http://example.com/location',
            assign(url) {
                lastRedirectUrl = url;
            }
        },
        history: {
            replaceState: (state, title, url) => history.push([state, title, url])
        }
    });
    walletConnection = new WalletConnection(nearFake, '');
});

it('not signed in by default', () => {
    expect(walletConnection.isSignedIn()).not.toBeTruthy();
});

it('throws if non string appKeyPrefix', () => {
    expect(() => new WalletConnection(nearFake)).toThrow(/appKeyPrefix/);
    expect(() => new WalletConnection(nearFake, 1)).toThrow(/appKeyPrefix/);
    expect(() => new WalletConnection(nearFake, null)).toThrow(/appKeyPrefix/);
    expect(() => new WalletConnection(nearFake, undefined)).toThrow(/appKeyPrefix/);
});

describe('fails gracefully on the server side (without window)', () => {
    const windowValueBefore = global.window;

    beforeEach(() => {
        global.window = undefined;
        keyStore.clear();
    });

    afterEach(() => {
        global.window = windowValueBefore;
    });

    it('does not throw on instantiation', () => {
        expect(() => new WalletConnection(nearFake, '')).not.toThrowError();
    });

    it('throws if non string appKeyPrefix in server context', () => {
        expect(() => new WalletConnection(nearFake)).toThrow(/appKeyPrefix/);
        expect(() => new WalletConnection(nearFake, 1)).toThrow(/appKeyPrefix/);
        expect(() => new WalletConnection(nearFake, null)).toThrow(/appKeyPrefix/);
        expect(() => new WalletConnection(nearFake, undefined)).toThrow(/appKeyPrefix/);
    });

    it('returns an empty string as accountId', () => {
        const serverWalletConnection = new WalletConnection(nearFake, '');
        expect(serverWalletConnection.getAccountId()).toEqual('');
    });

    it('returns false as isSignedIn', () => {
        const serverWalletConnection = new WalletConnection(nearFake, '');
        expect(serverWalletConnection.isSignedIn()).toEqual(false);
    });

    it('throws explicit error when calling other methods on the instance', () => {
        const serverWalletConnection = new WalletConnection(nearFake, '');
        expect(() => serverWalletConnection.requestSignIn('signInContract', 'signInTitle', 'http://example.com/success',  'http://example.com/fail')).toThrow(/please ensure you are using WalletConnection on the browser/);
        expect(() => serverWalletConnection.requestSignInUrl('signInContract', 'signInTitle', 'http://example.com/success',  'http://example.com/fail')).toThrow(/please ensure you are using WalletConnection on the browser/);
        expect(() => serverWalletConnection.requestSignTransactions('signInContract', 'signInTitle', 'http://example.com/success',  'http://example.com/fail')).toThrow(/please ensure you are using WalletConnection on the browser/);
        expect(() => serverWalletConnection.requestSignTransactionsUrl('signInContract', 'signInTitle', 'http://example.com/success',  'http://example.com/fail')).toThrow(/please ensure you are using WalletConnection on the browser/);
    });

    it('can access other props on the instance', () => {
        const serverWalletConnection = new WalletConnection(nearFake, '');
        expect(serverWalletConnection['randomValue']).toEqual(undefined);
    });
});

describe('can request sign in', () => {
    beforeEach(() => keyStore.clear());
    
    it('V2', () => {
        return walletConnection.requestSignIn({
            contractId: 'signInContract',
            successUrl: 'http://example.com/success', 
            failureUrl: 'http://example.com/fail'
        });
    });

    afterEach(async () => {
        let accounts = await keyStore.getAccounts('networkId');
        expect(accounts).toHaveLength(1);
        expect(accounts[0]).toMatch(/^pending_key.+/);
        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                contract_id: 'signInContract',
                success_url: 'http://example.com/success',
                failure_url: 'http://example.com/fail',
                public_key: (await keyStore.getKey('networkId', accounts[0])).publicKey.toString()
            }
        });
    });
});

it('can request sign in with methodNames', async () => {
    await walletConnection.requestSignIn({
        contractId: 'signInContract',
        methodNames: ['hello', 'goodbye'],
        successUrl: 'http://example.com/success', 
        failureUrl: 'http://example.com/fail'
    });

    let accounts = await keyStore.getAccounts('networkId');
    expect(accounts).toHaveLength(1);
    expect(accounts[0]).toMatch(/^pending_key.+/);
    expect(url.parse(lastRedirectUrl, true)).toMatchObject({
        protocol: 'http:',
        host: 'example.com',
        query: {
            contract_id: 'signInContract',
            methodNames: ['hello', 'goodbye'],
            success_url: 'http://example.com/success',
            failure_url: 'http://example.com/fail',
            public_key: (await keyStore.getKey('networkId', accounts[0])).publicKey.toString()
        }
    });
});

it('can complete sign in', async () => {
    const keyPair = KeyPair.fromRandom('ed25519');
    global.window.location.href = `http://example.com/location?account_id=near.account&public_key=${keyPair.publicKey}`;
    await keyStore.setKey('networkId', 'pending_key' + keyPair.publicKey, keyPair);

    await walletConnection._completeSignInWithAccessKey();

    expect(await keyStore.getKey('networkId', 'near.account')).toEqual(keyPair);
    expect(localStorage.getItem('contractId_wallet_auth_key'));
    expect(history.slice(1)).toEqual([
        [{}, 'documentTitle', 'http://example.com/location']
    ]);
});

it('Promise until complete sign in', async () => {
    const keyPair = KeyPair.fromRandom('ed25519');
    global.window.location.href = `http://example.com/location?account_id=near2.account&public_key=${keyPair.publicKey}`;
    await keyStore.setKey('networkId', 'pending_key' + keyPair.publicKey, keyPair);

    const newWalletConn = new WalletConnection(nearFake, 'promise_on_complete_signin');

    expect(newWalletConn.isSignedIn()).toEqual(false);
    expect(await newWalletConn.isSignedInAsync()).toEqual(true);
    expect(await keyStore.getKey('networkId', 'near2.account')).toEqual(keyPair);
    expect(localStorage.getItem('promise_on_complete_signin_wallet_auth_key'));
    expect(history).toEqual([
        [{}, 'documentTitle', 'http://example.com/location']
    ]);
});

const BLOCK_HASH = '244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM';
const blockHash = baseDecode(BLOCK_HASH);
function createTransferTx() {
    const actions = [
        transfer(1),
    ];
    return createTransaction(
        'test.near',
        PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
        'whatever.near',
        1,
        actions,
        blockHash);
}

describe('can request transaction signing', () => {
    it('V1', async () => {
        await walletConnection.requestSignTransactions({
            transactions: [createTransferTx()],
            callbackUrl: 'http://example.com/callback'
        });

        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                callbackUrl: 'http://example.com/callback',
                transactions: 'CQAAAHRlc3QubmVhcgCRez0mjUtY9/7BsVC9aNab4+5dTMOYVeNBU4Rlu3eGDQEAAAAAAAAADQAAAHdoYXRldmVyLm5lYXIPpHP9JpAd8pa+atxMxN800EDvokNSJLaYaRDmMML+9gEAAAADAQAAAAAAAAAAAAAAAAAAAA=='
            }
        });
    });

    it('V2', async () => {
        await walletConnection.requestSignTransactions({
            transactions: [createTransferTx()],
            meta: 'something',
            callbackUrl: 'http://example.com/after'
        });

        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                meta: 'something',
                callbackUrl: 'http://example.com/after',
                transactions: 'CQAAAHRlc3QubmVhcgCRez0mjUtY9/7BsVC9aNab4+5dTMOYVeNBU4Rlu3eGDQEAAAAAAAAADQAAAHdoYXRldmVyLm5lYXIPpHP9JpAd8pa+atxMxN800EDvokNSJLaYaRDmMML+9gEAAAADAQAAAAAAAAAAAAAAAAAAAA=='
            }
        });
    });
});

function parseTransactionsFromUrl(urlToParse, callbackUrl = 'http://example.com/location') {
    const parsedUrl = url.parse(urlToParse, true);
    expect(parsedUrl).toMatchObject({
        protocol: 'http:',
        host: 'example.com',
        query: {
            callbackUrl
        }
    });
    const transactions = parsedUrl.query.transactions.split(',')
        .map(txBase64 => deserialize(
            SCHEMA.Transaction,
            Buffer.from(txBase64, 'base64')));
    return transactions;
}

function setupWalletConnectionForSigning({ allKeys, accountAccessKeys }) {
    walletConnection._authData = {
        allKeys: allKeys,
        accountId: 'signer.near'
    };
    nearFake.connection.provider = {
        query(params) {
            if (params.request_type === 'view_account' && params.account_id === 'signer.near') {
                return { };
            }
            if (params.request_type === 'view_access_key_list' && params.account_id === 'signer.near') {
                return { keys: accountAccessKeys };
            }
            if (params.request_type === 'view_access_key' && params.account_id === 'signer.near') {
                for (let accessKey of accountAccessKeys) {
                    if (accessKey.public_key === params.public_key) {
                        return accessKey;
                    }
                }
            }
            fail(`Unexpected query: ${JSON.stringify(params)}`);
        },
        sendTransaction(signedTransaction) {
            lastTransaction = signedTransaction;
            return {
                transaction_outcome: { outcome: { logs: [] } },
                receipts_outcome: []
            };
        },
        block() {
            return {
                header: {
                    hash: BLOCK_HASH
                }
            };
        }
    };
}

describe('requests transaction signing automatically when there is no local key', () => {
    const keyPair = KeyPair.fromRandom('ed25519');
    let transactions;
    beforeEach(() => {
        setupWalletConnectionForSigning({
            allKeys: [ 'no_such_access_key', keyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: 'FullAccess'
                },
                public_key: keyPair.publicKey.toString()
            }]
        });
    });

    it('V2', async() => {
        try {
            await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [transfer(1)],
                walletCallbackUrl: 'http://callback.com/callback'
            });
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
        transactions = parseTransactionsFromUrl(lastRedirectUrl, 'http://callback.com/callback');
    });

    afterEach(() => {
        expect(transactions).toHaveLength(1);
        expect(transactions[0]).toMatchObject({
            signerId: 'signer.near',
            // nonce: BigInt(2)
            receiverId: 'receiver.near',
            actions: [{
                transfer: {
                    // deposit: BigInt(1)
                }
            }]
        });
        expect(transactions[0].nonce.toString()).toEqual('2');
        expect(transactions[0].actions[0].transfer.deposit.toString()).toEqual('1');
        expect(Buffer.from(transactions[0].publicKey.data)).toEqual(Buffer.from(keyPair.publicKey.data));
    });
});

describe('requests transaction signing automatically when function call has attached deposit', () => {
    beforeEach(async() => {
        const localKeyPair = KeyPair.fromRandom('ed25519');
        const walletKeyPair = KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'receiver.near',
                            method_names: []
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }, {
                access_key: {
                    nonce: 1,
                    permission: 'FullAccess'
                },
                public_key: walletKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V2', async() => {
        try {
            await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [functionCall('someMethod', new Uint8Array(), BigInt('1'), BigInt('1'))],
                walletCallbackUrl: 'http://example.com/after',
                walletMeta: 'someStuff'
            });
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
    
        const transactions = parseTransactionsFromUrl(lastRedirectUrl, 'http://example.com/after');
        expect(transactions).toHaveLength(1);
    });
});

describe('requests transaction signing with 2fa access key', () => {
    beforeEach(async () => {
        let localKeyPair = KeyPair.fromRandom('ed25519');
        let walletKeyPair = KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'signer.near',
                            method_names: [MULTISIG_HAS_METHOD]
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V2', async () => {
        try {
            const res = await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [functionCall('someMethod', new Uint8Array(), BigInt('1'), BigInt('1'))]
            });

            // multisig access key is accepted res is object representing transaction, populated upon wallet redirect to app
            expect(res).toHaveProperty('transaction_outcome');
            expect(res).toHaveProperty('receipts_outcome');
        } catch (e) {
            fail('expected transaction outcome');
        }
    });
});

describe('fails requests transaction signing without 2fa access key', () => {
    beforeEach(async () => {
        const localKeyPair = KeyPair.fromRandom('ed25519');
        const walletKeyPair = KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'signer.near',
                            method_names: ['not_a_valid_2fa_method']
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V2', () => {
        return expect(
            walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [functionCall('someMethod', new Uint8Array(), BigInt('1'), BigInt('1'))]
            })
        ).rejects.toThrow('Cannot find matching key for transaction sent to receiver.near');
    });
});

describe('can sign transaction locally when function call has no attached deposit', () => {
    beforeEach(async () => {
        const localKeyPair = KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ /* no keys in wallet needed */ ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'receiver.near',
                            method_names: []
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it.each([
        functionCall('someMethod', new Uint8Array(), BigInt('1'), BigInt('0')),
        functionCall('someMethod', new Uint8Array(), BigInt('1')),
        functionCall('someMethod', new Uint8Array())
    ])('V2', async (functionCall) => {
        await walletConnection.account().signAndSendTransaction({
            receiverId: 'receiver.near',
            actions: [ functionCall ]
        });
        // NOTE: Transaction gets signed without wallet in this test
        expect(lastTransaction).toMatchObject({
            transaction: {
                receiverId: 'receiver.near',
                signerId: 'signer.near',
                actions: [{
                    functionCall: {
                        methodName: 'someMethod',
                    }
                }]
            }
        });
    });
});

'''