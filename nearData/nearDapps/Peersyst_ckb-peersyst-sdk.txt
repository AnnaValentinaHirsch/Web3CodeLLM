*GitHub Repository "Peersyst/ckb-peersyst-sdk"*

'''--- README.md ---
# Description

Peersyst typescrypt sdk to connect with nervos network

## Examples

In the folder example you can find examples on how to use the sdk.

To run any example use:
```
npm run example --name=wallet-balance
```

Where _wallet-balance_ can be any other example file name (import-wallet, create-wallet, get-transactions...)

## Installation
- To install the package with yarn use:
```
yarn add git+https://github.com/Peersyst/ckb-peersyst-sdk#1.0.0
```
- To install the package with npm use:
```
npm install --save git+https://github.com/Peersyst/ckb-peersyst-sdk#1.0.0
```
You can change the version changing what comes after #

## Usage
1. Instantiate connection service:
```typescrypt
import { ConnectionService, Environments, WalletService, Logger } from "@peersyst/ckb-peersyst-sdk";

const ckbUrl = "YourMainNodeRpcUrl";
const indexerUrl = "YourMainNodeIndexerUrl";
const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Mainnet);
```
2. Instantiate wallet service:
```typescrypt
// To create mnemonic if you do not have one:
const mnemonic = WalletService.createNewMnemonic();
const wallet = new WalletService(connectionService, mnemonic);
```
3. Refresh wallet data:
```typescrypt
await wallet.synchronize();
```
4. Make any call from the wallet:
```typescrypt
const totalBalance = await wallet.getBalance();
Logger.info(totalBalance);

const amount = BigInt(500 * 10 ** 8);
const txHash = await wallet.depositInDAO(amount, mnemonic);
```
'''
'''--- examples/create-wallet.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const main = async () => {
    try {
        const mnemonic = WalletService.createNewMnemonic();
        Logger.info(mnemonic); // Your new generated mnemonic, save it

        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // You can have more than 1 public address per mnemonic
        const nextAddress = wallet.getNextAddress();
        Logger.info(nextAddress);

        // To get your private key you need to put you mnemonic as sdk does not keep it
        const { privateKey, address } = wallet.getAddressAndPrivateKey(mnemonic);
        Logger.info(privateKey);
        Logger.info(address);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/deposit-in-dao.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const amount = BigInt(500 * 10 ** 8);

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.depositInDAO(amount, mnemonic);
        Logger.info(txHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-dao-statistics.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const statistics = await wallet.getDAOStatistics();
        Logger.info(statistics);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-dao-unlockable-amounts.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        Logger.info(unlockableAmounts);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-transactions.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const transactions = wallet.getTransactions();
        Logger.info(transactions);
        Logger.info(transactions.length);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/import-wallet-error.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        new WalletService(connectionService, mnemonic);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/import-wallet.ts ---
import { ConnectionService, Environments, WalletService, Logger, WalletState } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);

        // The third parameter given in the constructor is a callback called when a synchronize finishes
        const wallet = new WalletService(connectionService, mnemonic, null, async (walletState: WalletState) => {
            Logger.info("Got wallet State:");
            Logger.info(walletState);
        });

        await wallet.synchronize();
        const accounts = wallet.getAccountIndexes();
        Logger.info(accounts);
        const addresses = wallet.getAllAddresses();
        Logger.info(addresses);
        const newAddress = wallet.getNextAddress();
        Logger.info(newAddress);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/issue-tokens.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.issueTokens(1000, mnemonic);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/send-transaction.ts ---
import { ConnectionService, Environments, WalletService, Logger, FeeRate } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const amount = BigInt(513 * 10 ** 8); // 513 CKB

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // No need to sync as sendTransactions syncs before building the transaction
        const txHash = await wallet.sendTransaction(amount, mnemonic, receivingAddress, FeeRate.NORMAL);
        Logger.info(txHash);

        // You can view newly generated transaction through wallet.getTransactions when the tx is committed
        // If you want to know transaction status
        const transaction = await connectionService.getTransactionFromHash(txHash);
        Logger.info(JSON.stringify(transaction, null, 2));
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/transfer-tokens.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const quantity = 10;
const token = "0x099472fc82e74d050d524ba32f8efc05d4a53800f4ab0bf88be9c3383586339a";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.transferTokens(quantity, mnemonic, receivingAddress, token);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/unlock-from-dao.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // We will try to unlock first unlockable amount
        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        if (unlockableAmounts.length === 0) {
            throw new Error("No unlockable or withdrawable amount. Deposit before trying to withdraw");
        }

        Logger.info("Withdrawing or unlocking the following unlockable amount:");
        Logger.info(unlockableAmounts[0]);
        const unlockHash = await wallet.withdrawOrUnlock(unlockableAmounts[0], mnemonic);
        Logger.info(unlockHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
        Logger.error(`${error.stack}`);
    }
};

main();

'''
'''--- examples/wallet-balance.ts ---
import { ConnectionService, Environments, WalletService, Logger, AddressType } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const balanceAcc0Rec = await wallet.getBalanceFromAccount(0, AddressType.Receiving);
        Logger.info(balanceAcc0Rec);
        const balanceAcc0Chg = await wallet.getBalanceFromAccount(0, AddressType.Change);
        Logger.info(balanceAcc0Chg);
        const balanceAcc1 = await wallet.getBalanceFromAccount(1, AddressType.Receiving);
        Logger.info(balanceAcc1);
        const totalBalance = await wallet.getBalance();
        Logger.info(totalBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- package.json ---
{
    "name": "@peersyst/ckb-peersyst-sdk",
    "version": "1.4.4",
    "description": "Nervos CKB peersyst SDK for wallet",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
        "build": "tsc",
        "prepare": "npm run build",
        "start": "ts-node src/index.ts",
        "example": "ts-node examples/$npm_config_name.ts",
        "lint": "eslint . --ext .ts,.json",
        "test": "jest --passWithNoTests --detectOpenHandles",
        "test:coverage": "jest --coverage --passWithNoTests"
    },
    "files": [
        "dist/src/",
        "dist/index.d.ts",
        "dist/index.js",
        "dist/index.js.map"
    ],
    "repository": {
        "type": "git",
        "url": "https://github.com/Peersyst/ckb-peersyst-sdk"
    },
    "jest": {
        "moduleFileExtensions": [
            "js",
            "json",
            "ts"
        ],
        "rootDir": ".",
        "testRegex": ".*\\.spec\\.ts$",
        "transform": {
            "^.+\\.ts$": "ts-jest"
        },
        "collectCoverageFrom": [
            "./src/modules/**/*.ts"
        ],
        "coverageDirectory": "./coverage",
        "testEnvironment": "node",
        "coverageThreshold": {
            "global": {
                "branches": 90,
                "statements": 90
            }
        }
    },
    "author": "Joan Grau <jgrau@peersyst.com>",
    "license": "ISC",
    "dependencies": {
        "@ckb-lumos/lumos": "^0.18.0-rc6",
        "@rather-labs/nrc-721-sdk": "0.0.16",
        "cross-fetch": "^3.1.5",
        "rimraf": "^3.0.2"
    },
    "devDependencies": {
        "@types/node": "^17.0.21",
        "@typescript-eslint/eslint-plugin": "^5.11.0",
        "@typescript-eslint/parser": "^5.11.0",
        "eslint": "^8.8.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.4",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.5.1",
        "prettier": "^2.5.1",
        "supertest": "^6.2.2",
        "ts-jest": "^27.1.3",
        "ts-loader": "^9.2.6",
        "ts-node": "^10.5.0",
        "tsconfig-paths": "^3.14.1",
        "typescript": "^4.5.5",
        "webpack": "^5.68.0"
    }
}

'''
'''--- src/core/assets/ckb.service.ts ---
import { TransactionSkeleton } from "@ckb-lumos/helpers";
import { common } from "@ckb-lumos/common-scripts";
import { ConnectionService } from "../connection.service";
import { TransactionService, FeeRate } from "../transaction.service";
import { Cell } from "@ckb-lumos/lumos";

export interface CKBBalance {
    totalBalance: number;
    occupiedBalance: number;
    freeBalance: number;
}

export class CKBService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly transferCellSize = BigInt(61 * 10 ** 8);
    private readonly transferData = "0x";

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;
    }

    async transfer(from: string, to: string, amount: bigint, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        if (amount < this.transferCellSize) {
            throw new Error("Minimum transfer (cell) value is 61 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await common.transfer(txSkeleton, [from], to, amount, null, null, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async transferFromCells(
        cells: Cell[],
        fromAddresses: string[],
        to: string,
        amount: bigint,
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        if (amount < this.transferCellSize) {
            throw new Error("Minimum transfer (cell) value is 61 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });

        // Add output
        const toScript = this.connection.getLockFromAddress(to);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                },
                data: this.transferData,
            });
        });

        // Inject capacity
        txSkeleton = this.transactionService.addSecp256CellDep(txSkeleton);
        txSkeleton = this.transactionService.injectCapacity(txSkeleton, amount, cells);

        // Pay fee
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, fromAddresses, feeRate, null, this.connection.getConfigAsObject());

        // Get signing private keys
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, fromAddresses, privateKeys);

        return this.transactionService.signTransaction(txSkeleton, signingPrivKeys);
    }

    async getBalance(address: string): Promise<CKBBalance> {
        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const cells: Cell[] = [];
        for await (const cell of collector.collect()) {
            cells.push(cell);
        }

        return this.getBalanceFromCells(cells);
    }

    getBalanceFromCells(cells: Cell[]): CKBBalance {
        let totalBalanceBI = BigInt(0);
        let occupiedBalanceBI = BigInt(0);

        for (const cell of cells) {
            totalBalanceBI += BigInt(cell.cell_output.capacity);
            if (cell.cell_output.type) {
                occupiedBalanceBI += BigInt(cell.cell_output.capacity);
            }
        }
        const freeBalance = Number(totalBalanceBI - occupiedBalanceBI) / 10 ** 8;
        const totalBalance = Number(totalBalanceBI) / 10 ** 8;
        const occupiedBalance = Number(occupiedBalanceBI) / 10 ** 8;

        return { totalBalance, occupiedBalance, freeBalance };
    }
}

'''
'''--- src/core/assets/nft.service.ts ---
import { Cell } from "@ckb-lumos/lumos";
import * as NrcSdk from "@rather-labs/nrc-721-sdk";
import { Logger } from "../../utils/logger";
import { ConnectionService } from "../connection.service";
import { ScriptType } from "../transaction.service";
import { NftScript, NftSdk } from "./nft.types";

export interface Nft {
    tokenId: string;
    tokenUri: string;
    nftName: string;
    nftSymbol?: string;
    data?: any;
    nftExtraData?: string;
    issued?: number;
    total?: number;
}

export interface MNft {
    name: string;
    description: string;
    renderer: string;
    version: number;
    configure: number;
    issued: number;
    total: number;
}

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export class NftService {
    private readonly connection: ConnectionService;
    private readonly logger = new Logger(NftService.name);
    private readonly mNftCodeHash = "0x2b24f0d644ccbdd77bbf86b27c8cca02efa0ad051e447c212636d9ee7acaaec9";
    private readonly mNftClassCodeHash = "0xd51e6eaf48124c601f41abe173f1da550b4cbca9c6a166781906a287abbb3d9a";
    private nftSdk: NftSdk = null;
    private initializing = false;

    constructor(connectionService: ConnectionService) {
        this.connection = connectionService;
    }

    private static mNftFormat(dataHex: string): MNft {
        const data = dataHex.slice(2);
        const version = parseInt(data.slice(0, 1), 16);
        const total = parseInt(data.slice(1, 10), 16);
        const issued = parseInt(data.slice(10, 18), 16);
        const configure = parseInt(data.slice(18, 20), 16);
        const nameSize = parseInt(data.slice(20, 24), 16);
        const nameEnd = 24 + nameSize * 2;
        const name = decodeURIComponent(data.slice(24, nameEnd).replace(/[0-9a-f]{2}/g, "%$&"));
        const descriptionSizeEnd = nameEnd + 4;
        const descriptionSize = parseInt(data.slice(nameEnd, descriptionSizeEnd), 16);
        const descriptionEnd = descriptionSizeEnd + descriptionSize * 2;
        const description = decodeURIComponent(data.slice(descriptionSizeEnd, descriptionEnd).replace(/[0-9a-f]{2}/g, "%$&"));
        const rendererSizeEnd = descriptionEnd + 4;
        const rendererSize = parseInt(data.slice(descriptionEnd, rendererSizeEnd), 16);
        const rendererEnd = rendererSizeEnd + rendererSize * 2;
        const renderer = decodeURIComponent(data.slice(rendererSizeEnd, rendererEnd).replace(/[0-9a-f]{2}/g, "%$&"));

        return {
            name: name,
            description: description,
            renderer: renderer,
            version: version,
            configure: configure,
            issued: issued,
            total: total,
        };
    }

    async initialize() {
        if (!this.nftSdk && !this.initializing) {
            this.initializing = true;
            this.nftSdk = await NrcSdk.initialize({
                nodeUrl: this.connection.getCKBUrl(),
                indexerUrl: this.connection.getIndexerUrl(),
            });
            this.logger.info("NftService initialized");
        } else if (!this.nftSdk) {
            while (!this.nftSdk) {
                await sleep(100);
            }
        }
    }

    async isScriptNftScript(scriptType: ScriptType): Promise<boolean> {
        await this.initialize();

        let isNftCell: boolean;
        try {
            isNftCell = await this.nftSdk.nftCell.isCellNRC721(scriptType);
        } catch (error) {
            isNftCell = false;
        }

        return isNftCell;
    }

    private cellToNftScript(cell: Cell): NftScript {
        if (!cell.cell_output.type) {
            return null;
        }

        return {
            codeHash: cell.cell_output.type.code_hash,
            args: cell.cell_output.type.args,
            hashType: cell.cell_output.type.hash_type,
        };
    }

    private async getNftFromCell(cell: Cell): Promise<Nft | null> {
        const cellTypeScript = this.cellToNftScript(cell);
        if (!cellTypeScript) {
            return null;
        }

        let isNftCell: boolean;
        try {
            isNftCell = await this.nftSdk.nftCell.isCellNRC721(cellTypeScript);
        } catch (error) {
            isNftCell = false;
        }

        if (isNftCell) {
            const nft = await this.nftSdk.nftCell.read(cellTypeScript);

            return {
                tokenId: nft.tokenId,
                tokenUri: nft.tokenUri,
                data: JSON.parse(nft.data),
                nftName: nft.factoryData.name,
                nftSymbol: nft.factoryData.symbol,
                nftExtraData: nft.factoryData.extraData,
            };
        }
        if (cellTypeScript.codeHash === this.mNftCodeHash) {
            const cellProvider = this.connection.getCellProvider({
                type: {
                    code_hash: this.mNftClassCodeHash,
                    args: cellTypeScript.args.slice(0, -8),
                    hash_type: "type",
                },
            });

            const cells: Cell[] = [];
            const cellCollector = cellProvider.collector({});
            for await (const cell of cellCollector.collect()) {
                cells.push(cell);
            }

            if (cells.length === 1) {
                const mNft = NftService.mNftFormat(cells[0].data);

                return {
                    nftName: mNft.name,
                    tokenId: parseInt(cellTypeScript.args.slice(-8), 16).toString(),
                    tokenUri: mNft.renderer,
                    issued: mNft.issued,
                    total: mNft.total,
                    data: {
                        description: mNft.description,
                        version: mNft.version,
                        configure: mNft.configure,
                        type: "m-NFT",
                    },
                };
            }
        }

        return null;
    }

    async getBalance(address: string): Promise<Nft[]> {
        await this.initialize();

        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const nfts: Nft[] = [];
        for await (const cell of collector.collect()) {
            const nft = await this.getNftFromCell(cell);
            if (nft) {
                nfts.push(nft);
            }
        }

        return nfts;
    }

    async getBalanceFromCells(cells: Cell[]): Promise<Nft[]> {
        await this.initialize();

        const nfts: Nft[] = [];
        for await (const cell of cells) {
            const nft = await this.getNftFromCell(cell);
            if (nft) {
                nfts.push(nft);
            }
        }

        return nfts;
    }
}

'''
'''--- src/core/assets/nft.types.ts ---
// TODO change @nervosnetwork/ckb-sdk-core Cell and RawTransaction types
import { Cell, RawTransaction } from "@ckb-lumos/lumos";

export interface NftScript {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface MintNftParams {
    name: string;
    symbol: string;
    baseTokenUri: string;
    sourceAddress: string;
    targetAddress: string;
    extraData: Buffer;
    fee?: number;
    factoryContractTypeScript?: NftScript;
    factoryContractDep?: NftScript;
    extraDeps?: string[];
}

export interface MintNftResponse {
    rawTransaction: RawTransaction;
    typeScript: NftScript;
    usedCapacity: bigint;
    inputCells: Cell[];
}

export interface FactoryData {
    name: string;
    symbol: string;
    baseTokenUri: string;
    extraData: string;
}

export interface ReadFactoryResponse {
    data: FactoryData;
    rawCell: Cell;
}

export interface FactoryConstants {
    TYPE_CODE_HASH_SIZE: number;
    TYPE_ARGS_SIZE: number;
}

export interface CreateNewTypeScriptParams {
    rawTransaction: RawTransaction;
    factoryTypeScript: NftScript;
    nftTypeCodeHash: string;
    outputIndex: string;
}

export interface MintParams {
    nftContractTypeScript: NftScript;
    factoryTypeScript: NftScript;
    sourceAddress: string;
    targetAddress: string;
    nftContractDep?: NftScript;
    extraDeps?: string[];
    fee?: number;
    data?: any;
}

export interface MintResponse {
    rawTransaction: RawTransaction;
    nftTypeScript: NftScript;
    usedCapacity: bigint;
    inputCells: Cell[];
}

export interface ReadNftResponse {
    tokenId: string;
    tokenUri: string;
    data: string;
    factoryData: FactoryData;
    rawCell: Cell;
}

export interface NftFactoryCell {
    mint: (mintData: MintNftParams) => Promise<MintNftResponse>;
    readOne: (typeScript: NftScript) => Promise<ReadFactoryResponse>;
    isCellNRC721: (factoryTypeScript: NftScript) => Promise<boolean>;
    CONSTANTS: FactoryConstants;
}

export interface NftSdkCell {
    getAllFactoryNftsByAdress: ({ userAdress, factoryTypeScript }: { userAdress: string; factoryTypeScript: NftScript }) => Promise<Cell[]>;
    createNewTypeScript: (params: CreateNewTypeScriptParams) => NftScript;
    mint: (params: MintParams) => Promise<MintResponse>;
    read: (nftTypeScript: NftScript) => Promise<ReadNftResponse>;
    isCellNRC721: (nftTypeScript: NftScript) => Promise<boolean>;
}

export interface NftSdkUtils {
    getCellOccupiedCapacity: (cell: Cell, data: string) => number;
    bigNumberCKBToShannon: (amount: number | StringConstructor) => bigint;
    serializeInputCell: (inputCell: Cell) => Buffer;
    hxShannonToCKB: (hexNumber: string) => number;
    CKBToShannon: (amount: number) => bigint;
    shannonToCKB: (amount: number) => number;
    hexToBytes: (hexString: string) => number[];
}

export interface NftSdk {
    factoryCell: NftFactoryCell;
    nftCell: NftSdkCell;
    utils: NftSdkUtils;
}

'''
'''--- src/core/assets/token.service.ts ---
import { Cell, Script, utils } from "@ckb-lumos/lumos";
import { TransactionSkeleton } from "@ckb-lumos/helpers";
import { sudt, common } from "@ckb-lumos/common-scripts";
import { ConnectionService } from "../connection.service";
import { FeeRate, TransactionService } from "../transaction.service";

export interface TokenType {
    args: string;
    codeHash: string;
    hashType: string;
}
export interface TokenAmount {
    type: TokenType;
    amount: number;
}

export class TokenService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    // private readonly sudtCellSize = BI.from(142 * 10 ** 8);

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;
    }

    private isTokenScriptType(script: Script): boolean {
        if (!script) {
            return false;
        }

        const sudtScript = this.connection.getConfig().SCRIPTS.SUDT;
        return script.code_hash === sudtScript.CODE_HASH && script.hash_type === sudtScript.HASH_TYPE;
    }

    async issue(address: string, amount: number, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await sudt.issueToken(txSkeleton, address, amount, undefined, undefined, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [address], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async transfer(
        from: string,
        to: string,
        token: string,
        amount: number,
        privateKey: string,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getCellProvider() });
        txSkeleton = await sudt.transfer(txSkeleton, [from], token, to, amount, undefined, undefined, undefined, {
            config: this.connection.getConfig(),
        });
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async getBalance(address: string): Promise<TokenAmount[]> {
        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const cells: Cell[] = [];
        for await (const cell of collector.collect()) {
            cells.push(cell);
        }

        return this.getBalanceFromCells(cells);
    }

    getBalanceFromCells(cells: Cell[]): TokenAmount[] {
        const tokenMap = new Map<string, number>();
        for (const cell of cells) {
            if (this.isTokenScriptType(cell.cell_output.type)) {
                const key = cell.cell_output.type.args;

                if (!tokenMap.has(key)) {
                    tokenMap.set(key, Number(utils.readBigUInt128LE(cell.data)));
                } else {
                    tokenMap.set(key, Number(utils.readBigUInt128LE(cell.data)) + tokenMap.get(key));
                }
            }
        }

        const tokens: TokenAmount[] = [];
        const { CODE_HASH: codeHash, HASH_TYPE: hashType } = this.connection.getConfig().SCRIPTS.SUDT;
        tokenMap.forEach((value, key) =>
            tokens.push({
                type: { args: key, codeHash, hashType },
                amount: value,
            }),
        );

        return tokens;
    }
}

'''
'''--- src/core/connection.service.ts ---
import { RPC, config, Script, helpers, OutPoint, Indexer } from "@ckb-lumos/lumos";
import {
    TransactionWithStatus,
    Header,
    ChainInfo,
    CellWithStatus,
    Indexer as IndexerType,
    CellProvider,
    CellCollector,
    QueryOptions,
} from "@ckb-lumos/base";
import { Config, ScriptConfig } from "@ckb-lumos/config-manager";
import { isSecp256k1Blake160Address, isAcpAddress, isSecp256k1Blake160MultisigAddress } from "@ckb-lumos/common-scripts/lib/helper";

// AGGRON4 for test, LINA for main
const { AGGRON4, LINA } = config.predefined;

export enum Environments {
    Mainnet = "mainnet",
    Testnet = "testnet",
}

const OnepassConfig: { [key in Environments]: ScriptConfig } = {
    [Environments.Mainnet]: {
        CODE_HASH: "0xd01f5152c267b7f33b9795140c2467742e8424e49ebe2331caec197f7281b60a",
        HASH_TYPE: "type",
        TX_HASH: "0x86a5e91ad93475caf30a3d3b0258786dd463984f71e8471abc5574f206f6207a",
        INDEX: "0x0",
        DEP_TYPE: "code",
    },
    [Environments.Testnet]: {
        CODE_HASH: "0x3e1eb7ed4809b2d60650be96a40abfbdafb3fb942b7b37ec7709e64e2cd0a783",
        HASH_TYPE: "type",
        TX_HASH: "0x8b98ede6bf7b5baba767b1d2d46a13749fc810375b14152abbc259a7fc98e46d",
        INDEX: "0x0",
        DEP_TYPE: "code",
    },
};

class CustomCellProvider implements CellProvider {
    public readonly uri: string;

    constructor(private readonly indexer: IndexerType, private readonly myQueryOptions: QueryOptions) {
        this.uri = indexer.uri;
    }

    collector(queryOptions: QueryOptions): CellCollector {
        return this.indexer.collector({ ...queryOptions, ...this.myQueryOptions });
    }
}

export class ConnectionService {
    private readonly ckbUrl: string;
    private readonly indexerUrl: string;
    private readonly env: Environments;
    private readonly rpc: RPC;
    private readonly indexer: IndexerType;
    private readonly config: Config;
    private blockHeaderNumberMap = new Map<string, Header>();
    private blockHeaderHashMap = new Map<string, Header>();
    private transactionMap = new Map<string, TransactionWithStatus>();

    // ckbUrl is the url of the node rpc
    // indexerUrl is the url of the node indexer
    // env is the environment of the node
    constructor(ckbUrl: string, indexerUrl: string, env: Environments) {
        this.ckbUrl = ckbUrl;
        this.indexerUrl = indexerUrl;
        this.env = env;
        this.rpc = new RPC(this.ckbUrl);
        this.indexer = new Indexer(this.indexerUrl, this.ckbUrl);
        this.config = env === Environments.Mainnet ? LINA : AGGRON4;
        config.initializeConfig(this.config);
    }

    // Returns info of the blockchain connected by the rpc
    async getBlockchainInfo(): Promise<ChainInfo> {
        return this.rpc.get_blockchain_info();
    }

    setBlockHeaderMaps(header: Header): void {
        this.blockHeaderHashMap.set(header.hash, header);
        this.blockHeaderNumberMap.set(header.number, header);
    }

    // Gets latest block header in the blockchain
    async getCurrentBlockHeader(): Promise<Header> {
        const lastBlockHeader = await this.rpc.get_tip_header();
        this.setBlockHeaderMaps(lastBlockHeader);
        return lastBlockHeader;
    }

    // Gets a block header from its hash
    async getBlockHeaderFromHash(blockHash: string): Promise<Header> {
        if (!this.blockHeaderHashMap.has(blockHash)) {
            const header = await this.rpc.get_header(blockHash);
            this.setBlockHeaderMaps(header);
        }
        return this.blockHeaderHashMap.get(blockHash);
    }

    // Get a block header from its hex number
    async getBlockHeaderFromNumber(blockNumber: string): Promise<Header> {
        if (!this.blockHeaderNumberMap.has(blockNumber)) {
            const header = await this.rpc.get_header_by_number(blockNumber);
            this.setBlockHeaderMaps(header);
        }
        return this.blockHeaderNumberMap.get(blockNumber);
    }

    // Gets a cell by its out point
    async getCell(outPoint: OutPoint): Promise<CellWithStatus> {
        return this.rpc.get_live_cell(outPoint, true);
    }

    // Gets a transaction with status from a hash
    // Useful for when the transaction is still not committed
    // For transactions that fave not finished you should set useMap = false to not receive the same!
    async getTransactionFromHash(transactionHash: string, useMap = true): Promise<TransactionWithStatus> {
        if (!useMap || !this.transactionMap.has(transactionHash)) {
            const transaction = await this.rpc.get_transaction(transactionHash);
            this.transactionMap.set(transactionHash, transaction);
        }
        return this.transactionMap.get(transactionHash);
    }

    getConfig(): Config {
        return this.config;
    }

    getConfigAsObject(): helpers.Options {
        return { config: this.config };
    }

    getRPC(): RPC {
        return this.rpc;
    }

    // Get current environment
    getEnvironment(): Environments {
        return this.env;
    }

    getIndexer(): IndexerType {
        return this.indexer;
    }

    getCellProvider(queryOptions: QueryOptions = {}): CellProvider {
        return new CustomCellProvider(this.indexer, queryOptions);
    }

    getEmptyCellProvider(queryOptions: QueryOptions = {}): CellProvider {
        return this.getCellProvider({ ...queryOptions, type: "empty" });
    }

    // Get current ckb url
    getCKBUrl(): string {
        return this.ckbUrl;
    }

    // Get current indexer url
    getIndexerUrl(): string {
        return this.indexerUrl;
    }

    // Generates an address from a lock script
    getAddressFromLock(lock: Script): string {
        // return helpers.generateAddress(lock, { config: this.config });
        return helpers.encodeToAddress(lock, { config: this.config });
    }

    // Gets the locks script from an address
    getLockFromAddress(address: string): Script {
        return helpers.parseAddress(address, { config: this.config });
    }

    static getLockFromAddress(address: string, config: Config): Script {
        return helpers.parseAddress(address, { config });
    }

    isAddress(address: string): boolean {
        try {
            return (
                isSecp256k1Blake160Address(address, this.config) ||
                isAcpAddress(address, this.config) ||
                isSecp256k1Blake160MultisigAddress(address, this.config) ||
                this.isOnepassAddress(address)
            );
        } catch (err) {
            return false;
        }
    }

    isOnepassAddress(address: string): boolean {
        const lock = this.getLockFromAddress(address);
        return lock.code_hash === OnepassConfig[this.env].CODE_HASH && lock.hash_type === OnepassConfig[this.env].HASH_TYPE;
    }

    // Providing an environment and addres returns a boolean indicating:
    // true address is Blake160, Blake160Multisig, ACP, Onepass
    // false address is of another kind or invalid
    static isAddress(network: Environments, address: string): boolean {
        const config = network === Environments.Mainnet ? LINA : AGGRON4;
        try {
            return (
                isSecp256k1Blake160Address(address, config) ||
                isAcpAddress(address, config) ||
                isSecp256k1Blake160MultisigAddress(address, config) ||
                ConnectionService.isOnepassAddress(network, address)
            );
        } catch (err) {
            return false;
        }
    }

    static isOnepassAddress(network: Environments, address: string): boolean {
        const config = network === Environments.Mainnet ? LINA : AGGRON4;
        const lock = ConnectionService.getLockFromAddress(address, config);
        return lock.code_hash === OnepassConfig[network].CODE_HASH && lock.hash_type === OnepassConfig[network].HASH_TYPE;
    }
}

'''
'''--- src/core/dao/dao.service.ts ---
import { Cell, Script } from "@ckb-lumos/base";
import { since } from "@ckb-lumos/lumos";
import { TransactionSkeleton, TransactionSkeletonType } from "@ckb-lumos/helpers";
import { dao, common } from "@ckb-lumos/common-scripts";
import { ConnectionService, Environments } from "../connection.service";
import { FeeRate, TransactionService } from "../transaction.service";
import { Logger } from "../../utils/logger";

export interface DAOStatistics {
    maximumWithdraw: bigint;
    daoEarliestSince: bigint;
}

export interface DAOBalance {
    daoDeposit: number;
    daoCompensation: number;
}

export interface DAOUnlockableAmount {
    type: "deposit" | "withdraw";
    amount: bigint;
    compensation: bigint;
    unlockable: boolean;
    remainingCycleMinutes: number;
    remainingEpochs: number;
    txHash: string;
}

export enum DAOCellType {
    DEPOSIT = "deposit",
    WITHDRAW = "withdraw",
    ALL = "all",
}

export class DAOService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly logger = new Logger(DAOService.name);
    private readonly daoCellSize = BigInt(102 * 10 ** 8);
    private readonly daoScriptArgs = "0x";
    private readonly depositDaoData = "0x0000000000000000";
    private blockTime = 8.02;

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;

        if (this.connection.getEnvironment() === Environments.Mainnet) {
            this.blockTime = 11.25;
        } else {
            this.blockTime = 7.5;
        }
    }

    private getDAOScript(): Script {
        const daoConfig = this.connection.getConfig().SCRIPTS.DAO;

        return {
            code_hash: daoConfig.CODE_HASH,
            hash_type: daoConfig.HASH_TYPE,
            args: this.daoScriptArgs,
        };
    }

    private isCellDAO(cell: Cell): boolean {
        const daoScript = this.getDAOScript();
        if (!cell.cell_output.type) {
            return false;
        }
        const { code_hash, hash_type, args } = cell.cell_output.type;

        return code_hash === daoScript.code_hash && hash_type === daoScript.hash_type && args === daoScript.args;
    }

    private addDAOCellDep(txSkeleton: TransactionSkeletonType): TransactionSkeletonType {
        const template = this.connection.getConfig().SCRIPTS.DAO;
        return TransactionService.addCellDep(txSkeleton, template);
    }

    isCellDeposit(cell: Cell): boolean {
        return cell.data === this.depositDaoData;
    }

    async isCellUnlockable(cell: Cell): Promise<boolean> {
        let sinceBI: bigint;
        const currentBlockHeader = await this.connection.getCurrentBlockHeader();
        const currentEpoch = since.parseEpoch(currentBlockHeader.epoch);

        if (this.isCellDeposit(cell)) {
            sinceBI = await this.getDepositDaoEarliestSince(cell);
        } else {
            sinceBI = await this.getWithdrawDaoEarliestSince(cell);
        }
        const earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());

        const unlockable =
            currentEpoch.number > earliestSince.number ||
            (currentEpoch.number === earliestSince.number && currentEpoch.index >= earliestSince.index);
        return unlockable;
    }

    async getCells(address: string, cellType: DAOCellType = DAOCellType.ALL): Promise<Cell[]> {
        const cells = [];
        const daoScript = this.getDAOScript();
        const data = cellType === DAOCellType.DEPOSIT ? this.depositDaoData : "any";

        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
            type: daoScript,
            data,
        });

        for await (const inputCell of collector.collect()) {
            if (cellType === DAOCellType.WITHDRAW && this.isCellDeposit(inputCell)) {
                continue;
            }

            if (!inputCell.block_hash && inputCell.block_number) {
                const header = await this.connection.getBlockHeaderFromNumber(inputCell.block_number);
                cells.push({ ...inputCell, block_hash: header.hash });
            } else {
                cells.push(inputCell);
            }
        }

        return cells;
    }

    async filterDAOCells(cells: Cell[], cellType: DAOCellType = DAOCellType.ALL): Promise<Cell[]> {
        const filteredCells: Cell[] = [];
        for (const cell of cells) {
            if (this.isCellDAO(cell)) {
                if (
                    (cellType === DAOCellType.WITHDRAW && this.isCellDeposit(cell)) ||
                    (cellType === DAOCellType.DEPOSIT && !this.isCellDeposit(cell))
                ) {
                    continue;
                }

                if (!cell.block_hash && cell.block_number) {
                    const header = await this.connection.getBlockHeaderFromNumber(cell.block_number);
                    filteredCells.push({ ...cell, block_hash: header.hash });
                } else {
                    filteredCells.push(cell);
                }
            }
        }

        return filteredCells;
    }

    async getBalance(address: string): Promise<DAOBalance> {
        const cells = await this.getCells(address, DAOCellType.ALL);
        let daoDeposit = BigInt(0);
        let daoCompensation = BigInt(0);

        for (let i = 0; i < cells.length; i += 1) {
            let maxWithdraw = BigInt(0);
            daoDeposit += BigInt(cells[i].cell_output.capacity);

            if (this.isCellDeposit(cells[i])) {
                maxWithdraw = await this.getDepositCellMaximumWithdraw(cells[i]);
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(cells[i]);
            }

            daoCompensation += maxWithdraw - BigInt(cells[i].cell_output.capacity);
        }

        return { daoDeposit: Number(daoDeposit) / 10 ** 8, daoCompensation: Number(daoCompensation) / 10 ** 8 };
    }

    async getBalanceFromCells(cells: Cell[]): Promise<DAOBalance> {
        const daoCells = await this.filterDAOCells(cells, DAOCellType.ALL);
        let daoDeposit = BigInt(0);
        let daoCompensation = BigInt(0);

        for (let i = 0; i < daoCells.length; i += 1) {
            let maxWithdraw = BigInt(0);
            daoDeposit += BigInt(daoCells[i].cell_output.capacity);

            if (this.isCellDeposit(daoCells[i])) {
                maxWithdraw = await this.getDepositCellMaximumWithdraw(daoCells[i]);
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(daoCells[i]);
            }

            daoCompensation += maxWithdraw - BigInt(daoCells[i].cell_output.capacity);
        }

        return { daoDeposit: Number(daoDeposit) / 10 ** 8, daoCompensation: Number(daoCompensation) / 10 ** 8 };
    }

    async deposit(amount: bigint, from: string, to: string, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        if (amount < this.daoCellSize) {
            throw new Error("Minimum deposit value is 102 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await dao.deposit(txSkeleton, from, to, amount, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async depositMultiAccount(
        amount: bigint,
        cells: Cell[],
        fromAddresses: string[],
        to: string,
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        if (amount < this.daoCellSize) {
            throw new Error("Minimum deposit value is 102 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = this.addDAOCellDep(txSkeleton);

        // Add output
        const toScript = this.connection.getLockFromAddress(to);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                    type: this.getDAOScript(),
                },
                data: this.depositDaoData,
            });
        });
        const outputIndex = txSkeleton.get("outputs").size - 1;

        // Fix output entry
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
            return fixedEntries.push({
                field: "outputs",
                index: outputIndex,
            });
        });

        // Inject capacity
        txSkeleton = this.transactionService.addSecp256CellDep(txSkeleton);
        txSkeleton = this.transactionService.injectCapacity(txSkeleton, amount, cells);

        // Pay fee
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, fromAddresses, feeRate, null, this.connection.getConfigAsObject());

        // Get signing private keys
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, fromAddresses, privateKeys);

        return this.transactionService.signTransaction(txSkeleton, signingPrivKeys);
    }

    async withdraw(
        inputCell: Cell,
        privateKey: string,
        feeAddresses: string[],
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await dao.withdraw(txSkeleton, inputCell, null, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, feeAddresses, feeRate, null, this.connection.getConfigAsObject());
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, feeAddresses, privateKeys);
        const sortedSignPKeys = [privateKey, ...signingPrivKeys.filter((pkey) => pkey !== privateKey)];

        return this.transactionService.signTransaction(txSkeleton, sortedSignPKeys);
    }

    async unlock(
        withdrawCell: Cell,
        privateKey: string,
        from: string,
        to: string,
        feeAddresses: string[],
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        const depositCell = await this.getDepositCellFromWithdrawCell(withdrawCell);
        if (!(await this.isCellUnlockable(withdrawCell))) {
            throw new Error("Cell can not be unlocked. Minimum time is 30 days.");
        }

        txSkeleton = await dao.unlock(txSkeleton, depositCell, withdrawCell, to, from, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, feeAddresses, feeRate, null, this.connection.getConfigAsObject());
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, feeAddresses, privateKeys);
        const sortedSignPKeys = [privateKey, ...signingPrivKeys.filter((pkey) => pkey !== privateKey)];

        return this.transactionService.signTransaction(txSkeleton, sortedSignPKeys);
    }

    async findCorrectInputFromWithdrawCell(withdrawCell: Cell): Promise<{ index: string; txHash: string }> {
        const transaction = await this.connection.getTransactionFromHash(withdrawCell.out_point.tx_hash);

        let index: string;
        let txHash: string;
        for (let i = 0; i < transaction.transaction.inputs.length && !index; i += 1) {
            const prevOut = transaction.transaction.inputs[i].previous_output;

            const possibleTx = await this.connection.getTransactionFromHash(prevOut.tx_hash);
            const output = possibleTx.transaction.outputs[parseInt(prevOut.index, 16)];
            if (
                output.type &&
                output.capacity === withdrawCell.cell_output.capacity &&
                output.lock.args === withdrawCell.cell_output.lock.args &&
                output.lock.hash_type === withdrawCell.cell_output.lock.hash_type &&
                output.lock.code_hash === withdrawCell.cell_output.lock.code_hash &&
                output.type.args === withdrawCell.cell_output.type.args &&
                output.type.hash_type === withdrawCell.cell_output.type.hash_type &&
                output.type.code_hash === withdrawCell.cell_output.type.code_hash
            ) {
                index = prevOut.index;
                txHash = prevOut.tx_hash;
            }
        }

        return { index, txHash };
    }

    async findCellFromUnlockableAmount(unlockableAmount: DAOUnlockableAmount, address: string): Promise<Cell> {
        const cells = await this.getCells(address);
        return this.findCellFromUnlockableAmountAndCells(unlockableAmount, cells);
    }

    async findCellFromUnlockableAmountAndCells(unlockableAmount: DAOUnlockableAmount, cells: Cell[]): Promise<Cell> {
        const filtCells = await this.filterDAOCells(cells);
        const capacity = `0x${unlockableAmount.amount.toString(16)}`;

        for (let i = 0; i < filtCells.length; i += 1) {
            if (filtCells[i].cell_output.capacity === capacity && filtCells[i].out_point.tx_hash === unlockableAmount.txHash) {
                return filtCells[i];
            }
        }

        return null;
    }

    async getDepositCellFromWithdrawCell(withdrawCell: Cell): Promise<Cell> {
        const { index, txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return {
            cell_output: {
                capacity: withdrawCell.cell_output.capacity,
                lock: { ...withdrawCell.cell_output.lock },
                type: { ...withdrawCell.cell_output.type },
            },
            out_point: {
                tx_hash: txHash,
                index,
            },
            data: this.depositDaoData,
            block_hash: depositBlockHeader.hash,
            block_number: depositBlockHeader.number,
        };
    }

    async getWithdrawCellFromCapacityTx(capacity: string, address: string, txHash: string): Promise<Cell> {
        const cells = await this.getCells(address, DAOCellType.WITHDRAW);
        this.logger.info(`finding cell with capacity ${capacity} address ${address} and txHash ${txHash}`);

        for (let i = 0; i < cells.length; i += 1) {
            this.logger.info(cells[i]);
            if (cells[i].cell_output.capacity === capacity && cells[i].out_point.tx_hash === txHash) {
                return cells[i];
            }
        }

        return null;
    }

    async getStatistics(address: string): Promise<DAOStatistics> {
        const cells = await this.getCells(address, DAOCellType.ALL);

        return this.getStatisticsFromCells(cells);
    }

    async getStatisticsFromCells(cells: Cell[]): Promise<DAOStatistics> {
        const filtCells = await this.filterDAOCells(cells, DAOCellType.ALL);
        const statistics: DAOStatistics = { maximumWithdraw: BigInt(0), daoEarliestSince: null };

        for (let i = 0; i < filtCells.length; i += 1) {
            if (this.isCellDeposit(filtCells[i])) {
                const maxWithdraw = await this.getDepositCellMaximumWithdraw(filtCells[i]);
                statistics.maximumWithdraw += maxWithdraw;
                const earliestSince = await this.getDepositDaoEarliestSince(filtCells[i]);
                if (!statistics.daoEarliestSince || statistics.daoEarliestSince > earliestSince) {
                    statistics.daoEarliestSince = earliestSince;
                }
            } else {
                const maxWithdraw = await this.getWithdrawCellMaximumWithdraw(filtCells[i]);
                statistics.maximumWithdraw += maxWithdraw;
                const earliestSince = await this.getWithdrawDaoEarliestSince(filtCells[i]);
                if (!statistics.daoEarliestSince || statistics.daoEarliestSince > earliestSince) {
                    statistics.daoEarliestSince = earliestSince;
                }
            }
        }
        this.logger.info(since.parseSince("0x20070801d300112e"));

        return statistics;
    }

    async getDepositCellMaximumWithdraw(depositCell: Cell): Promise<bigint> {
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositCell.block_hash);
        const withdrawBlockHeader = await this.connection.getCurrentBlockHeader();

        return dao.calculateMaximumWithdraw(depositCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
    }

    async getWithdrawCellMaximumWithdraw(withdrawCell: Cell): Promise<bigint> {
        const withdrawBlockHeader = await this.connection.getBlockHeaderFromHash(withdrawCell.block_hash);
        const { txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return dao.calculateMaximumWithdraw(withdrawCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
    }

    async getDepositDaoEarliestSince(depositCell: Cell): Promise<bigint> {
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositCell.block_hash);
        const withdrawBlockHeader = await this.connection.getCurrentBlockHeader();

        return dao.calculateDaoEarliestSince(depositBlockHeader.epoch, withdrawBlockHeader.epoch);
    }

    async getWithdrawDaoEarliestSince(withdrawCell: Cell): Promise<bigint> {
        const withdrawBlockHeader = await this.connection.getBlockHeaderFromHash(withdrawCell.block_hash);
        const { txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return dao.calculateDaoEarliestSince(depositBlockHeader.epoch, withdrawBlockHeader.epoch);
    }

    async getUnlockableAmounts(address: string): Promise<DAOUnlockableAmount[]> {
        const cells = await this.getCells(address);
        return this.getUnlockableAmountsFromCells(cells);
    }

    async getUnlockableAmountsFromCells(cells: Cell[]): Promise<DAOUnlockableAmount[]> {
        const unlockableAmounts: DAOUnlockableAmount[] = [];
        const filtCells = await this.filterDAOCells(cells);
        const currentBlockHeader = await this.connection.getCurrentBlockHeader();
        const currentEpoch = since.parseEpoch(currentBlockHeader.epoch);

        for (let i = 0; i < filtCells.length; i += 1) {
            const unlockableAmount: DAOUnlockableAmount = {
                amount: BigInt(filtCells[i].cell_output.capacity),
                compensation: BigInt(0),
                unlockable: true,
                remainingCycleMinutes: 0,
                type: "withdraw",
                txHash: filtCells[i].out_point.tx_hash,
                remainingEpochs: 0,
            };
            let maxWithdraw = BigInt(0);
            let earliestSince: since.EpochSinceValue;

            if (this.isCellDeposit(filtCells[i])) {
                unlockableAmount.type = "deposit";
                maxWithdraw = await this.getDepositCellMaximumWithdraw(filtCells[i]);
                const sinceBI = await this.getDepositDaoEarliestSince(filtCells[i]);
                earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(filtCells[i]);
                const sinceBI = await this.getWithdrawDaoEarliestSince(filtCells[i]);
                earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());
            }

            const remainingEpochs = earliestSince.number - currentEpoch.number;
            unlockableAmount.compensation = maxWithdraw - unlockableAmount.amount;
            if (remainingEpochs === 0) {
                unlockableAmount.remainingEpochs = 0;
                const remainingBlocks = earliestSince.index - currentEpoch.index;
                if (remainingBlocks <= 0) {
                    unlockableAmount.remainingCycleMinutes = 0;
                } else {
                    unlockableAmount.remainingCycleMinutes = (remainingBlocks * this.blockTime) / 60;
                }
            } else if (remainingEpochs < 0) {
                unlockableAmount.remainingEpochs = 0;
                unlockableAmount.remainingCycleMinutes = 0;
            } else {
                unlockableAmount.remainingEpochs = remainingEpochs;
                let remainingBlocks = currentEpoch.length - currentEpoch.index;
                remainingBlocks += (remainingEpochs - 1) * currentEpoch.length;
                remainingBlocks += earliestSince.index;
                unlockableAmount.remainingCycleMinutes = (remainingBlocks * this.blockTime) / 60;
            }
            unlockableAmount.unlockable =
                currentEpoch.number > earliestSince.number ||
                (currentEpoch.number === earliestSince.number && currentEpoch.index >= earliestSince.index);
            unlockableAmounts.push(unlockableAmount);
        }

        return unlockableAmounts;
    }
}

'''
'''--- src/core/transaction.service.ts ---
import { ScriptConfig } from "@ckb-lumos/config-manager";
import { Cell, commons, hd, Script, utils } from "@ckb-lumos/lumos";
import { sealTransaction, TransactionSkeletonType } from "@ckb-lumos/helpers";
import { TransactionWithStatus, values, core, WitnessArgs } from "@ckb-lumos/base";
import { TransactionCollector as TxCollector } from "@ckb-lumos/ckb-indexer";
import { Reader, normalizers } from "@ckb-lumos/toolkit";
import { CKBIndexerQueryOptions } from "@ckb-lumos/ckb-indexer/src/type";
import { ConnectionService } from "./connection.service";
import { Logger } from "../utils/logger";
import { NftService } from "./assets/nft.service";

const { ScriptValue } = values;

export interface ScriptType {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface DataRow {
    quantity: number;
    address: string;
    type?: ScriptType;
    data?: number;
}

export interface Transaction {
    status: TransactionStatus;
    transactionHash: string;
    inputs: DataRow[];
    outputs: DataRow[];
    type: TransactionType;
    scriptType?: ScriptType;
    amount: number;
    blockHash?: string;
    blockNumber?: number;
    timestamp?: Date;
}

export enum TransactionStatus {
    PENDING = "pending",
    PROPOSED = "proposed",
    COMMITTED = "committed",
    REJECTED = "rejected",
}

export enum TransactionType {
    SEND_CKB = "send_ckb",
    RECEIVE_CKB = "receive_ckb",
    SEND_TOKEN = "send_token",
    RECEIVE_TOKEN = "receive_token",
    SEND_NFT = "send_nft",
    RECEIVE_NFT = "receive_nft",
    DEPOSIT_DAO = "deposit_dao",
    WITHDRAW_DAO = "withdraw_dao",
    UNLOCK_DAO = "unlock_dao",
    SMART_CONTRACT_SEND = "smart_contract_send",
    SMART_CONTRACT_RECEIVE = "smart_contract_receive",
}

export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}

export class TransactionService {
    private readonly connection: ConnectionService;
    private readonly nftService: NftService;
    private readonly TransactionCollector: any;
    private readonly logger = new Logger(TransactionService.name);
    private readonly transactionMap = new Map<string, Transaction>();
    private readonly secpSignaturePlaceholder =
        "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    public readonly defaultFee = BigInt(100000);

    constructor(connectionService: ConnectionService, nftService: NftService) {
        this.connection = connectionService;
        this.nftService = nftService;
        this.TransactionCollector = TxCollector;
    }

    static addCellDep(txSkeleton: TransactionSkeletonType, scriptConfig: ScriptConfig): TransactionSkeletonType {
        return txSkeleton.update("cellDeps", (cellDeps) => {
            return cellDeps.push({
                out_point: {
                    tx_hash: scriptConfig.TX_HASH,
                    index: scriptConfig.INDEX,
                },
                dep_type: scriptConfig.DEP_TYPE,
            });
        });
    }

    static isScriptTypeScript(scriptType: ScriptType, scriptConfig: ScriptConfig): boolean {
        return scriptConfig.CODE_HASH === scriptType.codeHash && scriptConfig.HASH_TYPE === scriptType.hashType;
    }

    private getTransactionCollector(address: string, includeStatus = false, toBlock?: string, fromBlock?: string): any {
        const queryOptions: CKBIndexerQueryOptions = { lock: this.connection.getLockFromAddress(address) };
        if (toBlock) {
            queryOptions.toBlock = toBlock;
        }
        if (fromBlock) {
            queryOptions.fromBlock = fromBlock;
        }

        return new this.TransactionCollector(this.connection.getIndexer(), queryOptions, this.connection.getCKBUrl(), { includeStatus });
    }

    async getTransactionFromLumosTx(lumosTx: TransactionWithStatus, address: string, allAddresses: string[]): Promise<Transaction> {
        const inputs: DataRow[] = [];
        const inputAddresses: string[] = [];
        let scriptType: ScriptType;
        let inputIndex = null;
        let amount = 0;
        let complexAmount = 0;
        let inputType = null;
        let isRealSender = false;
        for (let i = 0; i < lumosTx.transaction.inputs.length; i += 1) {
            const input = lumosTx.transaction.inputs[i];
            const transaction = await this.connection.getTransactionFromHash(input.previous_output.tx_hash);
            const output = transaction.transaction.outputs[parseInt(input.previous_output.index, 16)];
            const inputAddress = this.connection.getAddressFromLock(output.lock);
            inputs.push({
                quantity: parseInt(output.capacity, 16) / 100000000,
                address: this.connection.getAddressFromLock(output.lock),
            });
            if (allAddresses.includes(inputAddress)) {
                inputIndex = i;
                amount -= parseInt(output.capacity, 16) / 100000000;
                complexAmount -= parseInt(output.capacity, 16) / 100000000;
                inputAddresses.push(inputAddress);
                if (output.type) {
                    inputType = {
                        args: output.type.args,
                        codeHash: output.type.code_hash,
                        hashType: output.type.hash_type,
                    };
                }
            }
            if (address === inputAddress) {
                isRealSender = true;
            }
        }

        let outputIndex = null;
        let receiveAmount = 0;
        const outputs: DataRow[] = lumosTx.transaction.outputs.map((output, index) => {
            const outputAddress = this.connection.getAddressFromLock(output.lock);
            if (allAddresses.includes(outputAddress)) {
                amount += parseInt(output.capacity, 16) / 100000000;
                if (output.type) {
                    outputIndex = index;
                }
            }
            if (inputAddresses.includes(outputAddress)) {
                complexAmount += parseInt(output.capacity, 16) / 100000000;
            }
            if (address === outputAddress) {
                receiveAmount = parseInt(output.capacity, 16) / 100000000;
            }
            return {
                quantity: parseInt(output.capacity, 16) / 100000000,
                address: this.connection.getAddressFromLock(output.lock),
                type: output.type
                    ? { args: output.type.args, codeHash: output.type.code_hash, hashType: output.type.hash_type }
                    : undefined,
            };
        });
        lumosTx.transaction.outputs_data.map((data, index) => {
            if (data !== "0x") {
                if (data.length === 34) {
                    outputs[index].data = Number(utils.readBigUInt128LE(data));
                } else if (data.length === 18) {
                    outputs[index].data = Number(utils.readBigUInt64LE(data));
                }
            }
        });

        let type: TransactionType;
        const isReceive = inputIndex === null;
        if (inputType === null && outputIndex === null) {
            // If neither input or output has type then it is a simple ckb transaction
            if (Math.abs(amount) < 1) {
                // It is fee, same receiver and sender
                if (isRealSender) {
                    type = TransactionType.SEND_CKB;
                    amount = complexAmount;
                } else {
                    type = TransactionType.RECEIVE_CKB;
                    amount = receiveAmount;
                }
            } else {
                type = !isReceive ? TransactionType.SEND_CKB : TransactionType.RECEIVE_CKB;
            }
        } else if (outputIndex !== null) {
            const { type: outputType, data, quantity } = outputs[outputIndex];
            scriptType = outputType;
            if (TransactionService.isScriptTypeScript(scriptType, this.connection.getConfig().SCRIPTS.SUDT)) {
                type = !isReceive ? TransactionType.SEND_TOKEN : TransactionType.RECEIVE_TOKEN;
            } else if (TransactionService.isScriptTypeScript(scriptType, this.connection.getConfig().SCRIPTS.DAO)) {
                if (data === 0) {
                    type = TransactionType.DEPOSIT_DAO;
                    amount = Math.abs(amount) < 1 ? -quantity : amount;
                } else {
                    type = TransactionType.WITHDRAW_DAO;
                    amount = Math.abs(amount) < 1 ? quantity : amount;
                }
            } else if (await this.nftService.isScriptNftScript(scriptType)) {
                type = !isReceive ? TransactionType.SEND_NFT : TransactionType.RECEIVE_NFT;
            } else {
                type = !isReceive ? TransactionType.SMART_CONTRACT_SEND : TransactionType.SMART_CONTRACT_RECEIVE;
            }
        } else {
            scriptType = inputType;
            type = TransactionType.UNLOCK_DAO;
        }

        const transaction: Transaction = {
            status: lumosTx.tx_status.status as TransactionStatus,
            transactionHash: lumosTx.transaction.hash,
            inputs,
            outputs,
            type: type,
            scriptType: scriptType,
            amount,
        };
        if (lumosTx.tx_status.block_hash) {
            const header = await this.connection.getBlockHeaderFromHash(lumosTx.tx_status.block_hash);
            transaction.blockHash = lumosTx.tx_status.block_hash;
            transaction.blockNumber = parseInt(header.number, 16);
            transaction.timestamp = new Date(parseInt(header.timestamp, 16));
        }

        return transaction;
    }

    addSecp256CellDep(txSkeleton: TransactionSkeletonType): TransactionSkeletonType {
        return TransactionService.addCellDep(txSkeleton, this.connection.getConfig().SCRIPTS.SECP256K1_BLAKE160);
    }

    injectCapacity(txSkeleton: TransactionSkeletonType, capacity: bigint, cells: Cell[]): TransactionSkeletonType {
        let lastScript: Script | undefined;
        let changeCell: Cell;
        let changeCapacity = BigInt(0);
        let currentAmount = BigInt(capacity);

        for (const cell of cells) {
            // Cell is empty
            if (!cell.cell_output.type) {
                txSkeleton = txSkeleton.update("inputs", (inputs) => inputs.push(cell));
                txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));

                const inputCapacity = BigInt(cell.cell_output.capacity);
                let deductCapacity = inputCapacity;
                if (deductCapacity > currentAmount) {
                    deductCapacity = currentAmount;
                }
                currentAmount -= deductCapacity;
                changeCapacity += inputCapacity - deductCapacity;

                const lockScript = cell.cell_output.lock;
                if (
                    !lastScript ||
                    lastScript.args !== lockScript.args ||
                    lastScript.code_hash !== lockScript.code_hash ||
                    lastScript.hash_type !== lockScript.hash_type
                ) {
                    txSkeleton = this.addWitnesses(txSkeleton, lockScript);
                    lastScript = lockScript;
                }

                // Got enough amount
                if (Number(currentAmount) === 0 && Number(changeCapacity) > 0) {
                    changeCell = {
                        cell_output: {
                            capacity: "0x" + changeCapacity.toString(16),
                            lock: cell.cell_output.lock,
                            type: undefined,
                        },
                        data: "0x",
                        out_point: undefined,
                        block_hash: undefined,
                    };
                    break;
                }
            }
        }

        if (changeCapacity > BigInt(0)) {
            txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        }

        return txSkeleton;
    }

    getScriptFirstIndex(txSkeleton: TransactionSkeletonType, fromScript: Script): number {
        return txSkeleton
            .get("inputs")
            .findIndex((input) =>
                new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })),
            );
    }

    addWitnesses(txSkeleton: TransactionSkeletonType, fromScript: Script): TransactionSkeletonType {
        // posar el index i from script
        const firstIndex = this.getScriptFirstIndex(txSkeleton, fromScript);

        if (firstIndex !== -1) {
            while (firstIndex >= txSkeleton.get("witnesses").size) {
                txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
            }

            let witness: string = txSkeleton.get("witnesses").get(firstIndex);
            const newWitnessArgs: WitnessArgs = { lock: this.secpSignaturePlaceholder };
            if (witness !== "0x") {
                const witnessArgs = new core.WitnessArgs(new Reader(witness));
                const lock = witnessArgs.getLock();
                if (lock.hasValue() && new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                    throw new Error("Lock field in first witness is set aside for signature!");
                }

                const inputType = witnessArgs.getInputType();
                if (inputType.hasValue()) {
                    newWitnessArgs.input_type = new Reader(inputType.value().raw()).serializeJson();
                }
                const outputType = witnessArgs.getOutputType();
                if (outputType.hasValue()) {
                    newWitnessArgs.output_type = new Reader(outputType.value().raw()).serializeJson();
                }
            }
            witness = new Reader(core.SerializeWitnessArgs(normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
        }

        return txSkeleton;
    }

    extractPrivateKeys(txSkeleton: TransactionSkeletonType, fromAddresses: string[], privateKeys: string[]): string[] {
        const signingPrivKeys: string[] = [];

        for (let i = 0; i < fromAddresses.length; i += 1) {
            if (this.getScriptFirstIndex(txSkeleton, this.connection.getLockFromAddress(fromAddresses[i])) !== -1) {
                this.logger.info(i);
                signingPrivKeys.push(privateKeys[i]);
            }
        }

        return signingPrivKeys;
    }

    async addressHasTransactions(address: string, toBlock?: string, fromBlock?: string): Promise<boolean> {
        const transactionCollector = this.getTransactionCollector(address, false, toBlock, fromBlock);

        const txs = await transactionCollector.count();
        return txs > 0;
    }

    async getLumosTransactions(address: string, toBlock?: string, fromBlock?: string): Promise<TransactionWithStatus[]> {
        const transactionCollector = this.getTransactionCollector(address, true, toBlock, fromBlock);
        const transactions: TransactionWithStatus[] = [];

        for await (const lumosTx of transactionCollector.collect()) {
            transactions.push(lumosTx);
        }

        return transactions;
    }

    async getTransactions(address: string, allAddresses: string[], toBlock?: string, fromBlock?: string): Promise<Transaction[]> {
        const transactionCollector = this.getTransactionCollector(address, true, toBlock, fromBlock);
        const transactions: Transaction[] = [];
        let lumosTx: TransactionWithStatus;

        for await (lumosTx of transactionCollector.collect()) {
            const key = `${address}-${lumosTx.transaction.hash}`;
            if (!this.transactionMap.has(key)) {
                const transaction = await this.getTransactionFromLumosTx(lumosTx, address, allAddresses);
                this.transactionMap.set(key, transaction);
            }

            const transaction = this.transactionMap.get(key);
            if (!transactions.includes(transaction)) {
                transactions.push(transaction);
            }
        }

        return transactions;
    }

    async getTransactionFromHash(txHash: string, addresses: string[]): Promise<Transaction> {
        const transaction = await this.connection.getTransactionFromHash(txHash, false);
        return this.getTransactionFromLumosTx(transaction, addresses[addresses.length - 1], addresses);
    }

    async signTransaction(txSkeleton: TransactionSkeletonType, privateKeys: string[]): Promise<string> {
        const txSkeletonWEntries = commons.common.prepareSigningEntries(txSkeleton, this.connection.getConfigAsObject());
        if (privateKeys.length !== txSkeletonWEntries.get("signingEntries").count()) {
            this.logger.error("Invalid private keys length");
            throw new Error("Invalid private keys length");
        }

        const signatures = [];
        for (let i = 0; i < privateKeys.length; i += 1) {
            const entry = txSkeletonWEntries.get("signingEntries").get(i);
            signatures.push(hd.key.signRecoverable(entry.message, privateKeys[i]));
        }
        const tx = sealTransaction(txSkeletonWEntries, signatures);
        const hash = await this.connection.getRPC().send_transaction(tx, "passthrough");

        return hash;
    }
}

'''
'''--- src/core/wallet.service.ts ---
import { mnemonic, ExtendedPrivateKey, AccountExtendedPublicKey, AddressType } from "@ckb-lumos/hd";
import { TransactionWithStatus } from "@ckb-lumos/base";
import { ConnectionService } from "./connection.service";
import { TransactionService, Transaction, FeeRate } from "./transaction.service";
import { TokenService, TokenAmount } from "./assets/token.service";
import { CKBBalance, CKBService } from "./assets/ckb.service";
import { DAOBalance, DAOService, DAOStatistics, DAOUnlockableAmount } from "./dao/dao.service";
import { Cell, Script } from "@ckb-lumos/lumos";
import { QueryOptions } from "@ckb-lumos/base";
import { Nft, NftService } from "./assets/nft.service";
import { Logger } from "../utils/logger";

export { AddressType };

export enum AddressScriptType {
    SECP256K1_BLAKE160 = "SECP256K1_BLAKE160",
    SUDT = "SUDT",
    DAO = "DAO",
}

export interface Balance {
    ckb: CKBBalance;
    tokens: TokenAmount[];
    nfts: Nft[];
    dao: DAOBalance;
}

export interface addressMapI {
    [key: string]: string;
}

export interface cellMapI {
    [key: string]: Cell[];
}

export interface transactionMapI {
    [key: string]: Transaction[];
}

export interface WalletState {
    addressMap: addressMapI;
    firstRIndexWithoutTxs: number;
    firstCIndexWithoutTxs: number;
    lastHashBlock: string;
    accountCellsMap: cellMapI;
    accountTransactionMap: transactionMapI;
}

export class WalletService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly ckbService: CKBService;
    private readonly tokenService: TokenService;
    private readonly daoService: DAOService;
    private readonly nftService: NftService;
    private readonly accountPublicKey: AccountExtendedPublicKey;
    private readonly logger = new Logger(WalletService.name);
    private addressMap: addressMapI = {};
    private firstRIndexWithoutTxs = 0;
    private firstCIndexWithoutTxs = 0;
    private lastHashBlock!: string;
    private accountCellsMap: cellMapI = {};
    private accountTransactionMap: transactionMapI = {};
    private onSync!: (walletState: WalletState) => Promise<void>;
    private onSyncStart!: () => void;
    private synchronizing = false;

    // The connectionService and a mnemonic are mandatory
    // walletState is useful if you will close the instance and want to sync from a given state
    // onSync method is called when sync finished. Useful to persist current state
    // onSyncStart is called when a synchronization start
    // It throws an error when mnemonic is invalid
    constructor(
        connectionService: ConnectionService,
        mnemo: string,
        walletState?: WalletState,
        onSync?: (walletState: WalletState) => Promise<void>,
        onSyncStart?: () => void,
    ) {
        if (!WalletService.validateMnemonic(mnemo)) {
            this.logger.error("Invalid Mnemonic");
            throw new Error("Invalid Mnemonic");
        }

        this.connection = connectionService;
        this.nftService = new NftService(this.connection);
        this.transactionService = new TransactionService(this.connection, this.nftService);
        this.ckbService = new CKBService(this.connection, this.transactionService);
        this.tokenService = new TokenService(this.connection, this.transactionService);
        this.daoService = new DAOService(this.connection, this.transactionService);

        if (walletState) {
            this.addressMap = walletState.addressMap ? { ...walletState.addressMap } : this.addressMap;
            this.firstRIndexWithoutTxs = walletState.firstRIndexWithoutTxs || 0;
            this.firstCIndexWithoutTxs = walletState.firstCIndexWithoutTxs || 0;
            this.lastHashBlock = walletState.lastHashBlock || null;
            this.accountCellsMap = walletState.accountCellsMap ? { ...walletState.accountCellsMap } : this.accountCellsMap;
            this.accountTransactionMap = walletState.accountTransactionMap
                ? { ...walletState.accountTransactionMap }
                : this.accountTransactionMap;
        }

        if (onSync) {
            this.onSync = onSync;
        }
        if (onSyncStart) {
            this.onSyncStart = onSyncStart;
        }

        this.accountPublicKey = WalletService.getPrivateKeyFromMnemonic(mnemo).toAccountExtendedPublicKey();
    }

    // Creates a new mnemonic
    static createNewMnemonic(): string {
        return mnemonic.generateMnemonic();
    }

    // Validates a mnemonic
    static validateMnemonic(mnemo: string): boolean {
        return mnemonic.validateMnemonic(mnemo);
    }

    private static getPrivateKeyFromMnemonic(mnemo: string): ExtendedPrivateKey {
        const seed = mnemonic.mnemonicToSeedSync(mnemo);
        return ExtendedPrivateKey.fromSeed(seed);
    }

    // ----------------------
    // -- Wallet functions --
    // ----------------------

    // Gets current wallet state
    getWalletState(): WalletState {
        return {
            addressMap: { ...this.addressMap },
            firstRIndexWithoutTxs: this.firstRIndexWithoutTxs,
            firstCIndexWithoutTxs: this.firstCIndexWithoutTxs,
            lastHashBlock: this.lastHashBlock,
            accountCellsMap: { ...this.accountCellsMap },
            accountTransactionMap: { ...this.accountTransactionMap },
        };
    }

    // Synchronizes and returns new wallet state
    // Calls onSyncStart at start and and onSync when finishes
    async synchronize(): Promise<WalletState> {
        if (this.synchronizing) return this.getWalletState();
        this.synchronizing = true;
        if (this.onSyncStart) this.onSyncStart();
        let toBlock: string;
        let fromBlock: string;
        const currentBlock = await this.connection.getCurrentBlockHeader();

        if (!this.lastHashBlock) {
            toBlock = currentBlock.number;
        } else {
            fromBlock = this.lastHashBlock;
            toBlock = currentBlock.number;
        }

        const cellProvider = this.connection.getCellProvider({ toBlock });
        const addressTypes: AddressType[] = [AddressType.Receiving, AddressType.Change];
        const keysArr: string[] = [];
        const addressesArr: string[] = [];
        const lumosTxsArr: TransactionWithStatus[][] = [];

        for (const addressType of addressTypes) {
            let currentIndex = 0;
            let firstIndex = addressType === AddressType.Receiving ? this.firstRIndexWithoutTxs : this.firstCIndexWithoutTxs;

            while (currentIndex <= firstIndex) {
                const address = this.getAddress(currentIndex, addressType as AddressType);
                const lumosTxs = await this.transactionService.getLumosTransactions(address, toBlock, fromBlock);

                if (lumosTxs.length > 0) {
                    const lock = this.getLock(currentIndex, addressType as AddressType);
                    const mapKey = `${addressType}-${currentIndex}`;
                    keysArr.push(mapKey);
                    addressesArr.push(address);
                    lumosTxsArr.push(lumosTxs);

                    // Update cells
                    const newCells: Cell[] = [];
                    const collectorOptions: QueryOptions = { lock, toBlock };
                    const cellCollector = cellProvider.collector(collectorOptions);
                    for await (const cell of cellCollector.collect()) {
                        newCells.push(cell);
                    }
                    this.accountCellsMap[mapKey] = newCells;

                    // Update indexes
                    if (currentIndex === firstIndex) {
                        firstIndex += 1;
                    }
                }
                currentIndex += 1;
            }
            if (addressType === AddressType.Receiving) {
                this.firstRIndexWithoutTxs = firstIndex;
            } else {
                this.firstCIndexWithoutTxs = firstIndex;
            }
        }

        const allAddresses = this.getAllAddresses();
        for (let i = 0; i < keysArr.length && i < lumosTxsArr.length && i < addressesArr.length; i += 1) {
            const address = addressesArr[i];
            const promises = lumosTxsArr[i].map((tx) => this.transactionService.getTransactionFromLumosTx(tx, address, allAddresses));
            const transactions = await Promise.all(promises);

            // Update transactions
            const currentTxs: Transaction[] = this.accountTransactionMap[keysArr[i]] || [];
            this.accountTransactionMap[keysArr[i]] = [...currentTxs, ...transactions];
        }

        this.lastHashBlock = currentBlock.number;

        const walletState = this.getWalletState();
        if (this.onSync) {
            await this.onSync(walletState);
        }
        this.synchronizing = false;

        return walletState;
    }

    getCells(): Cell[] {
        return [...Object.values(this.accountCellsMap)].flat(1);
    }

    // Returns next receive address without any transactions
    getNextAddress(): string {
        return this.getAddress(this.firstRIndexWithoutTxs, AddressType.Receiving);
    }

    getAccountIndexes(addressType: AddressType = AddressType.Receiving): number[] {
        if (addressType === AddressType.Receiving) {
            return [...Array(this.firstRIndexWithoutTxs).keys()];
        }
        return [...Array(this.firstCIndexWithoutTxs).keys()];
    }

    // Gets lock from a specific accountId, addressType and script type
    getLock(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): Script {
        const template = this.connection.getConfig().SCRIPTS[script];
        const lockScript = {
            code_hash: template.CODE_HASH,
            hash_type: template.HASH_TYPE,
            args: this.accountPublicKey.publicKeyInfo(addressType, accountId).blake160,
        };

        return lockScript;
    }

    // Gets address from a specific accountId, addressType and script type
    getAddress(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): string {
        const key = `${accountId}-${addressType}-${script}`;
        if (!this.addressMap[key]) {
            const address = this.connection.getAddressFromLock(this.getLock(accountId, addressType, script));
            this.addressMap[key] = address;
        }

        return this.addressMap[key];
    }

    // Gets all addresses with at least one transactions
    getAllAddresses(): string[] {
        const addresses = [];
        for (let i = 0; i < this.firstRIndexWithoutTxs; i += 1) {
            addresses.push(this.getAddress(i, AddressType.Receiving));
        }
        for (let i = 0; i < this.firstCIndexWithoutTxs; i += 1) {
            addresses.push(this.getAddress(i, AddressType.Change));
        }

        return addresses;
    }

    getAllPrivateKeys(mnemo: string): string[] {
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const privateKeys = [];
        for (let i = 0; i < this.firstRIndexWithoutTxs; i += 1) {
            privateKeys.push(extPrivateKey.privateKeyInfo(AddressType.Receiving, i).privateKey);
        }
        for (let i = 0; i < this.firstCIndexWithoutTxs; i += 1) {
            privateKeys.push(extPrivateKey.privateKeyInfo(AddressType.Change, i).privateKey);
        }

        return privateKeys;
    }

    getAddressAndPrivateKey(
        mnemo: string,
        accountId = 0,
        script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160,
    ): { address: string; privateKey: string } {
        const address = this.getAddress(accountId, AddressType.Receiving, script);
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const privateKey = extPrivateKey.privateKeyInfo(AddressType.Receiving, accountId).privateKey;

        return { address, privateKey };
    }

    getAddressAndPrivKeyFromLock(mnemo: string, lock: Script): { address: string; privateKey: string } {
        const address = this.connection.getAddressFromLock(lock);
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const addresses = this.getAllAddresses();

        let privateKey: string;
        if (addresses.indexOf(address) < this.firstRIndexWithoutTxs) {
            ({ privateKey } = extPrivateKey.privateKeyInfo(AddressType.Receiving, addresses.indexOf(address)));
        } else {
            ({ privateKey } = extPrivateKey.privateKeyInfo(AddressType.Change, addresses.indexOf(address) - this.firstRIndexWithoutTxs));
        }

        return { address, privateKey };
    }

    // Gets balance from a single account
    async getBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Balance> {
        const address = this.getAddress(accountId, addressType);
        const ckb = await this.ckbService.getBalance(address);
        const tokens = await this.tokenService.getBalance(address);
        const nfts = await this.nftService.getBalance(address);
        const dao = await this.daoService.getBalance(address);

        return { ckb, tokens, dao, nfts };
    }

    // Gets wallet total balance
    async getBalance(): Promise<Balance> {
        const cells = this.getCells();
        const ckb = this.ckbService.getBalanceFromCells(cells);
        const tokens = this.tokenService.getBalanceFromCells(cells);
        const nfts = await this.nftService.getBalanceFromCells(cells);
        const dao = await this.daoService.getBalanceFromCells(cells);

        return { ckb, tokens, dao, nfts };
    }

    // -----------------------------------
    // -- Transaction service functions --
    // -----------------------------------

    // Gets all transactions from a single account
    async getTransactionsFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Transaction[]> {
        const address = this.getAddress(accountId, addressType);

        return this.transactionService.getTransactions(address, this.getAllAddresses());
    }

    // Gets all transactions of the wallet
    getTransactions(): Transaction[] {
        const sortedTxs = [...Object.values(this.accountTransactionMap)].flat(1).sort((txa, txb) => txa.blockNumber - txb.blockNumber);

        // Remove equal transactions
        for (let i = 0; i < sortedTxs.length; i += 1) {
            let j = i + 1;

            while (j < sortedTxs.length) {
                if (sortedTxs[i].transactionHash === sortedTxs[j].transactionHash && sortedTxs[i].type === sortedTxs[j].type) {
                    sortedTxs.splice(j, 1);
                } else {
                    j += 1;
                }
            }
        }

        return sortedTxs;
    }

    // Get a transaction from hash
    // Useful from uncommitted transactions
    async getTransactionFromHash(txHash: string): Promise<Transaction> {
        return this.transactionService.getTransactionFromHash(txHash, [...this.getAllAddresses(), this.getNextAddress()]);
    }

    // ---------------------------
    // -- CKB service functions --
    // ---------------------------

    // Sends a transaction from a single account
    // Returns the transaction hash
    async sendTransactionSingleAccount(
        amount: bigint,
        mnemo: string,
        to: string,
        accountId: number,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);
        await this.synchronize();

        return this.ckbService.transfer(address, to, amount, privateKey, feeRate);
    }

    // Sends a transaction from all the accounts in the wallet
    // Returns the transaction hash
    async sendTransaction(amount: bigint, mnemo: string, to: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const addresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);

        return this.ckbService.transferFromCells(this.getCells(), addresses, to, amount, privateKeys, feeRate);
    }

    // Gets the ckb balance of a single account
    async getCKBBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<CKBBalance> {
        const address = this.getAddress(accountId, addressType);
        return this.ckbService.getBalance(address);
    }

    // Get the ckb balance of the wallet
    // Should be synchronized first
    getCKBBalance(): CKBBalance {
        return this.ckbService.getBalanceFromCells(this.getCells());
    }

    // -----------------------------
    // -- Token service functions --
    // -----------------------------

    // Deprecated in accounts
    // Issue a new token from a specific account
    // Returns transaction hash
    async issueTokens(amount: number, mnemo: string, accountId = 0, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);

        return this.tokenService.issue(address, amount, privateKey, feeRate);
    }

    // Deprecated in accounts
    // Transfer a token with where its type has args token (4th param)
    // Amount is the number of token to transfer. Minumum cell size required.
    // Returns transaction hash
    async transferTokens(
        amount: number,
        mnemo: string,
        to: string,
        token: string,
        accountId = 0,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);

        return this.tokenService.transfer(address, to, token, amount, privateKey, feeRate);
    }

    // Gets the token balance from a single account
    async getTokensBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<TokenAmount[]> {
        const address = this.getAddress(accountId, addressType);
        return this.tokenService.getBalance(address);
    }

    // Get the token balance of the whole wallet
    // Should be synchronized first
    getTokensBalance(): TokenAmount[] {
        return this.tokenService.getBalanceFromCells(this.getCells());
    }

    // -----------------------------
    // -- Nft service functions --
    // -----------------------------

    // Gets all nfts from a single account
    async getNftsBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Nft[]> {
        const address = this.getAddress(accountId, addressType);
        return this.nftService.getBalance(address);
    }

    // Gets the nfts from the whole wallet
    // Should be synchronized first
    async getNftsBalance(): Promise<Nft[]> {
        return this.nftService.getBalanceFromCells(this.getCells());
    }

    // ---------------------------
    // -- DAO service functions --
    // ---------------------------

    // Deposits in the DAO from a single account
    // Returns the hash of the transaction
    async depositInDAOSingleAccount(amount: bigint, mnemo: string, accountId = 0, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);
        return this.daoService.deposit(amount, address, address, privateKey, feeRate);
    }

    // Deposits in DAO from all the accounts with enough balance
    // Returns the hash of the transaction
    async depositInDAO(amount: bigint, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const addresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);

        return this.daoService.depositMultiAccount(amount, this.getCells(), addresses, this.getNextAddress(), privateKeys, feeRate);
    }

    private async withdrawOrUnlockFromCell(cell: Cell, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivKeyFromLock(mnemo, cell.cell_output.lock);
        const feeAddresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);
        const to = this.getNextAddress();

        if (!this.daoService.isCellDeposit(cell)) {
            this.logger.info("Unlocking withdraw cell");

            // Check real unlockability
            if (!(await this.daoService.isCellUnlockable(cell))) {
                throw new Error("Cell can not yet be unlocked.");
            }
            return this.daoService.unlock(cell, privateKey, address, to, feeAddresses, privateKeys, feeRate);
        }

        this.logger.info("Withdrawing deposit cell");
        return this.daoService.withdraw(cell, privateKey, feeAddresses, privateKeys, feeRate);
    }

    // Gets DAO unlockable amounts from a single account
    async getDAOUnlockableAmountsFromAccount(
        accountId = 0,
        addressType: AddressType = AddressType.Receiving,
    ): Promise<DAOUnlockableAmount[]> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getUnlockableAmounts(address);
    }

    // Gets DAO unlockable amounts from the whole wallet
    // Should be synchronized first
    async getDAOUnlockableAmounts(): Promise<DAOUnlockableAmount[]> {
        return this.daoService.getUnlockableAmountsFromCells(this.getCells());
    }

    // Withdraws or unlocks an unlockable amount
    // Returns the hash of the transaction
    async withdrawOrUnlock(unlockableAmount: DAOUnlockableAmount, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const cells = await this.daoService.filterDAOCells(this.getCells());

        const cell = await this.daoService.findCellFromUnlockableAmountAndCells(unlockableAmount, cells);
        if (!cell) {
            throw new Error("Cell related to unlockable amount not found!");
        }
        this.logger.info(cell);
        return this.withdrawOrUnlockFromCell(cell, mnemo, feeRate);
    }

    // Gets DAO statistic from a single account
    async getDAOStatisticsFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<DAOStatistics> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getStatistics(address);
    }

    // Gets DAO statistic from the whole wallet
    // Should be synchronized first
    async getDAOStatistics(): Promise<DAOStatistics> {
        return this.daoService.getStatisticsFromCells(this.getCells());
    }

    // Get DAO balance from a single account
    async getDAOBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<DAOBalance> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getBalance(address);
    }

    // Get DAO balance from the whole wallet
    // Should be synchronized first
    async getDAOBalance(): Promise<DAOBalance> {
        return this.daoService.getBalanceFromCells(this.getCells());
    }
}

'''
'''--- src/index.ts ---
export * from "./core/connection.service";
export * from "./core/wallet.service";
export * from "./core/transaction.service";
export * from "./core/assets/ckb.service";
export * from "./core/assets/token.service";
export * from "./core/assets/nft.service";
export * from "./core/assets/nft.types";
export * from "./core/dao/dao.service";
export * from "./utils/logger";

'''
'''--- src/utils/logger.ts ---
/* eslint-disable no-console */
export enum LoggingLevel {
    DEBUG = "debug",
    INFO = "info",
    WARN = "warn",
    ERROR = "error",
}

export class Logger {
    private readonly name: string;
    private readonly loggingLevel: LoggingLevel;

    // In the constructor we can pass a name that will always be added in the log
    // and a logging level to choose which level of logs you want to be logged.
    // If you choose logging level WARN only logger.warn and logger.error will be logged
    constructor(name = "", loggingLevel: LoggingLevel = LoggingLevel.INFO) {
        this.name = name;
        this.loggingLevel = loggingLevel;
    }

    // Sends a message to standard output with tag debug
    static debug(message: any, name = ""): void {
        console.debug(`${name}[debug] >> `, message);
    }

    // Sends a message to standard output with tag debug if logging level DEBUG or greater
    debug(message: any): void {
        if (this.loggingLevel === LoggingLevel.DEBUG) {
            Logger.debug(message, this.name);
        }
    }

    // Sends a message to standard output with tag info
    static info(message: any, name = ""): void {
        console.info(`${name}[info] >> `, message);
    }

    // Sends a message to standard output with tag info if logging level INFO or greater
    info(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO].includes(this.loggingLevel)) {
            Logger.info(message, this.name);
        }
    }

    // Sends a message to standard output with tag log
    static log(message: any, name = ""): void {
        console.log(`${name}[log] >> `, message);
    }

    // Sends a message to standard output with tag log if logging level INFO or greater
    log(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO].includes(this.loggingLevel)) {
            Logger.log(message, this.name);
        }
    }

    // Sends a message to standard error output with tag warn
    static warn(message: any, name = ""): void {
        console.warn(`${name}[warn] >> `, message);
    }

    // Sends a message to standard error output with tag warn if logging level WARN or greater
    warn(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO, LoggingLevel.WARN].includes(this.loggingLevel)) {
            Logger.warn(message, this.name);
        }
    }

    // Sends a message to standard error output with tag error
    static error(message: any, name = ""): void {
        console.error(`${name}[error] >> `, message);
    }

    // Sends a message to standard error output with tag error if logging level ERROR
    error(message: any): void {
        Logger.error(message, this.name);
    }
}

'''
'''--- src/utils/parser.ts ---
import { fromJS } from "immutable";
import { Cell, CellDep, Hash, HexString, PackedSince } from "@ckb-lumos/base";
import { List, Map, Record } from "immutable";
import { TransactionSkeletonInterface } from "@ckb-lumos/helpers";

const TransactionSkeletonRecord = Record<TransactionSkeletonInterface>({
    cellProvider: null,
    cellDeps: List<CellDep>(),
    headerDeps: List<Hash>(),
    inputs: List<Cell>(),
    outputs: List<Cell>(),
    witnesses: List<HexString>(),
    fixedEntries: List<{ field: string; index: number }>(),
    signingEntries: List<{ type: string; index: number; message: string }>(),
    inputSinces: Map<number, PackedSince>(),
});

const TransactionSkeletonTypeReviver = (key: string, value: any) => {
    if (key === "") return TransactionSkeletonRecord(value);
    else if (key === "cellProvider") return value;
    else if (key === "cellDeps") return List<CellDep>(value);
    else if (key === "headerDeps") return List<Hash>(value);
    else if (key === "inputs" || key === "outputs") return List<Cell>(value);
    else if (key === "witnesses") return List<HexString>(value);
    else if (key === "fixedEntries") return List<{ field: string; index: number }>(value);
    else if (key === "signingEntries") return List<{ type: string; index: number; message: string }>(value);
    else if (key === "inputSinces") return Map<number, PackedSince>(value);
};

export const jsonToTransactionSkeletonInterface = (json: object) => {
    return fromJS(json, TransactionSkeletonTypeReviver);
};

'''
'''--- tsconfig.build.json ---
{
    "extends": "./tsconfig.json",
    "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "module": "commonjs",
        "declaration": true,
        "removeComments": true,
        "emitDecoratorMetadata": true,
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true,
        "resolveJsonModule": true,
        "target": "es2016",
        "moduleResolution": "node",
        "sourceMap": true,
        "outDir": "./dist",
        "baseUrl": "./",
        "incremental": true,
        "skipLibCheck": true
    },
    "include": ["src/**/*", "test/**/*.spec.ts"]
}

'''