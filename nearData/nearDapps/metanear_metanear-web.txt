*GitHub Repository "metanear/metanear-web"*

'''--- README.md ---
# [Meta NEAR Website](https://metanear.com)

Live: [metanear.com](https://metanear.com)

## Setup
```bash
yarn
```

## Run locally
```bash
yarn start
```

## Build and Deploy
```bash
yarn deploy
```

'''
'''--- package.json ---
{
    "name": "metanear-web",
    "version": "0.1.0",
    "license": "MIT",
    "private": true,
    "repository": "metanear/metanear-web",
    "homepage": "https://metanear.com",
    "dependencies": {
        "gh-pages": "^2.2.0",
        "js-cookie": "^2.2.1",
        "react": "^16.11.0",
        "react-dom": "^16.11.0",
        "react-files": "^2.4.8",
        "react-router-dom": "^5.1.2",
        "react-router-tabs": "^1.3.2",
        "react-scripts": "^3.4.0",
        "near-seed-phrase": "^0.0.2",
        "react-tabs": "3.1.0",
        "near-api-js": "^0.29.0",
        "metanear-react-components": "^0.2.0",
        "metanear-sdk-js": "^0.3.3"
    },
    "scripts": {
        "start": "react-scripts start",
        "build:frontend": "react-scripts build",
        "test": "react-scripts test",
        "eject": "react-scripts eject",
        "deploy:pages": "yarn build && gh-pages -d build",
        "deploy": "npm run deploy:pages",
        "build": "react-scripts build",
        "prepare": "yarn build"
    },
    "eslintConfig": {
        "extends": "react-app"
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en" class="h100">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="User-centric web"
    />
    <link rel="apple-touch-icon" href="favicon.ico" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Meta NEAR - User-centric web</title>
  </head>
  <body class="h100">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root" class="h100"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->

  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "Open Web Home",
  "name": "NEAR Open Web Home",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *

'''
'''--- src/Auth.js ---
import React from "react";
import queryString from 'query-string';

export class Auth extends React.Component {
  constructor(props) {
    super(props);
    const values = queryString.parse(this.props.location.search);
    let {app_id, pub_key} = values;
    if (app_id && pub_key) {
      this.state = {
        authorized:false,
        new_app_id:app_id,
        new_pub_key:pub_key
      };
    } else {
      this.state = {
        authorized:false,
        new_app_id:"",
        new_pub_key:""
      }
    }
  }

 componentDidMount() {
    if (!this.props.loading && this.state.new_app_id && this.state.new_pub_key) {
      this.props.initMetaNearApp(this.state.new_app_id, this.state.new_pub_key)
        .then(res => {
          this.setState({
            authorized: true
          })
        });
    }
  }

  componentDidUpdate(prevProps) {
    if (this.props.app && !this.state.initialized) {
      // this.init();
    }
  }

  // async fetchProfile(accountId) {
  //   if (accountId in this.profileCache) {
  //     return this.profileCache[accountId];
  //   } else {
  //     console.log("Fetching profile for " + accountId);
  //     try {
  //       const values = await Promise.all([
  //         this.props.app.getFrom(accountId, 'displayName', 'profile'),
  //         this.props.app.getFrom(accountId, 'profileUrl', 'profile'),
  //       ]);
  //       this.profileCache[accountId] = {
  //         displayName: values[0] || "",
  //         profileUrl: values[1],
  //       };
  //     } catch (e) {
  //       this.profileCache[accountId] = false;
  //     }
  //     return this.profileCache[accountId];
  //   }
  // }

  // async registerNewApp(accountId) {
  //   if (accountId in this.profileCache) {
  //     return this.profileCache[accountId];
  //   } else {
  //     console.log("Fetching profile for " + accountId);
  //     try {
  //       const values = await Promise.all([
  //         this.props.app.getFrom(accountId, 'displayName', 'profile'),
  //         this.props.app.getFrom(accountId, 'profileUrl', 'profile'),
  //       ]);
  //       this.profileCache[accountId] = {
  //         displayName: values[0] || "",
  //         profileUrl: values[1],
  //       };
  //     } catch (e) {
  //       this.profileCache[accountId] = false;
  //     }
  //     return this.profileCache[accountId];
  //   }
  // }

  render() {
    return (
      <div>
        {this.state.authorized ?
        <div>
          <p>App <strong>{this.state.new_app_id}</strong> was added</p>
          <p> Using the public key: {this.state.new_pub_key} </p>
        </div> :
        "You need pass a key in order to add an app"
        }
      </div>
    )
  }
}

'''
'''--- src/Home.js ---
import React, { Component } from 'react';
import nearlogo from './assets/gray_near_logo.svg';
import './css/App.css';
import * as nearlib from "near-api-js";
import { MetaNearApp } from 'metanear-sdk-js';
import { ProfileApp } from "./apps/ProfileApp";
import { ChatApp } from "./apps/Chat/ChatApp";
import { MailApp } from "./apps/MailApp";
// import { KeysApp } from "./apps/KeysApp";
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs';
import 'react-tabs/style/react-tabs.css';
import { PowFaucet, AuthDataKey}  from "./components/PowFaucet";
import {Channel} from "./apps/Chat/Channel";

const GAS = 200_000_000_000_000;
const TITLE = "Meta NEAR - User-centric web"
const DefaultTabIndexKey = "metanearDefaultTabIndex";

export class Home extends Component {
  constructor(props) {
    super(props);
    this.state = {
      login: false,
      apps: {},
      logs: [],
      mailUnread: 0,
      chatUnread: 0,
      loading: false,
      defaultTabIndex: JSON.parse(window.localStorage.getItem(DefaultTabIndexKey) || '0'),
      offlineChatApp: null,
    }
    this.signedInFlow = this.signedInFlow.bind(this);
    this.requestSignIn = this.requestSignIn.bind(this);
    this.requestSignOut = this.requestSignOut.bind(this);
    this.signedOutFlow = this.signedOutFlow.bind(this);
    this.checkSignIn = this.checkSignIn.bind(this);
    this.initMetaNearApp = this.initMetaNearApp.bind(this);
    window.nearlib = nearlib;
  }

  componentDidMount() {
    this.checkSignIn();
  }

  async checkSignIn() {
    let loggedIn = window.walletAccount.isSignedIn();
    let authData = JSON.parse(window.localStorage.getItem(AuthDataKey) || '{}');
    if (loggedIn || authData.accountId) {
      await this.signedInFlow(authData);
    } else {
      this.signedOutFlow();
    }
  }

  log(message) {
    console.log(message);
    this.setState({
      logs: this.state.logs.concat([message])
    })
  }

  async signedInFlow(authData) {
    const accountId = authData.accountId || await this.props.wallet.getAccountId();
    this.setState({
      login: true,
      loading: true,
      accountId,
    })
    if (window.location.search.includes("account_id")) {
      window.location.replace(window.location.origin + window.location.pathname)
    }
    if (window.location.search.includes("all_keys")) {
      window.location.replace(window.location.origin + window.location.pathname)
    }
    // Initializing our contract APIs by contract name and configuration.

    this.log("Connecting to account...");
    const account = await new nearlib.Account(window.near.connection, accountId);
    this.log("Querying state...");
    let state = await account.state();
    /*
    await new Promise((resolve, reject) =>{
      setTimeout(() => {
        resolve();
      }, 5000);
    })
     */
    console.log(state);
    if (state.code_hash !== 'F6iocDrCDzBCxUN9PKPeVp7GqDuPve4g3ypHQQrmEw5E') {
      this.log("Going to deploy the code");
      // no code. Need to deploy.
      this.log("Downloading started...");
      let data = await fetch('/metanear_user.wasm');
      let buf = await data.arrayBuffer();
      this.log("Downloading done. Deploying contract...");
      await account.deployContract(new Uint8Array(buf));
      if (state.code_hash === '11111111111111111111111111111111') {
        this.log("Deploying done. Initializing contract...");
        // Gotta init it.
        let contract = await new nearlib.Contract(account, accountId, {
          viewMethods: [],
          // Change methods can modify the state. But you don't receive the returned value when called.
          changeMethods: ['new'],
          // Sender is the account ID to initialize transactions.
          sender: accountId
        });
        console.log(await contract.new());
      }
      this.log("The contract is deployed");
    }

    const masterContract = await new nearlib.Contract(account, accountId, {
      // View methods are read only. They don't modify the state, but usually return some value.
      viewMethods: ['apps'],
      // Change methods can modify the state. But you don't receive the returned value when called.
      changeMethods: ['add_app_key', 'remove_app_key'],
      // Sender is the account ID to initialize transactions.
      sender: accountId
    });

    this.masterContract = masterContract;
    window.masterContract = masterContract;
    this.log("Fetching authorized apps...");
    console.log("Apps:", await masterContract.apps());

    this.log("Initializing local apps...");
    const apps = {
      profile: await this.initMetaNearApp('profile', accountId),
      chat: await this.initMetaNearApp('chat', accountId),
      mail: await this.initMetaNearApp('mail', accountId),
      // keys: await this.initMetaNearApp('keys', accountId)
    };
    window.apps = apps;
    this.apps = apps;
    this.setState({
      apps,
      loading: false,
    })
  }

  async initMetaNearApp(appId, accountId) {
    this.log("Initializing app: " + appId + " ...");
    const app = new MetaNearApp(appId, accountId, window.nearConfig);
    await app.init();
    if (!await app.ready()) {
      let pk = await app.getAccessPublicKey();
      this.log("Authorizing app for key " + pk.toString() + " ...");
      const serializedPk = await app.getSerializedAccessPublicKey();
      const args = {
        public_key: [...serializedPk],
        app_id: appId,
      };
      await this.masterContract.add_app_key(args, GAS);
      await app.onKeyAdded();
    }
    return app;
  }

  async requestSignIn() {
    const appTitle = 'Open Web Home';
    await this.props.wallet.requestSignIn(
      "",
      appTitle
    )
  }

  requestSignOut() {
    this.props.wallet.signOut();
    setTimeout(this.signedOutFlow, 500);
    console.log("after sign out", this.props.wallet.isSignedIn())
  }

  async signedOutFlow() {
    if (window.location.search.includes("account_id")) {
      window.location.replace(window.location.origin + window.location.pathname)
    }
    this.setState({
      login: false,
    })
    if (!this.state.offlineChatApp) {
      const app = new MetaNearApp("chat", null, window.nearConfig);
      await app.init();
      this.setState({
        offlineChatApp: app,
      })
    }
  }

  selectTab = (index) => {
    window.localStorage.setItem(DefaultTabIndexKey, JSON.stringify(index));
    this.setState({
      defaultTabIndex: index,
    })
  }

  render() {
    const unread = this.state.mailUnread + this.state.chatUnread;
    document.title = (unread ? `(${unread}) ` : "") + TITLE;
    if (!this.state.login) {
      return <div className="App-header">
        <div>
          <div className="image-wrapper">
            <img className="logo" src={nearlogo} alt="NEAR logo"/>
          </div>
          <div>
            <button
                className="btn btn-primary"
                onClick={this.requestSignIn}>Log in with NEAR Wallet</button>
          </div>
          <PowFaucet onLogin={this.signedInFlow}/>
          <hr/>
          <div>
            <h3>To join #public chat </h3>
            <Channel channelId="public" app={this.state.offlineChatApp}/>
          </div>
        </div>
      </div>
    } else if (this.state.loading) {
      return <div className="loading-div">
        <div className="spinner-grow loading-spinner" role="status">
          <span className="sr-only">Loading...</span>
        </div>
        <pre className="text-left">
          {this.state.logs.join("\n")}
        </pre>
      </div>
    } else {
      return <div className={"h100 apps" + (this.state.loading ? " d-none" : "")}>
        <Tabs className="h100 cflex" forceRenderTabPanel={true} defaultIndex={this.state.defaultTabIndex} onSelect={(i) => this.selectTab(i)}>
          <TabList>
            <Tab>Profile</Tab>
            <Tab>Public Chat {this.state.chatUnread ? `(${this.state.chatUnread})` : ""}</Tab>
            <Tab>Mail {this.state.mailUnread ? `(${this.state.mailUnread})` : ""}</Tab>
            {/*<Tab>Keys</Tab>*/}
          </TabList>

          <TabPanel>
            <ProfileApp app={this.state.apps.profile} logOut={this.requestSignOut}/>
          </TabPanel>
          <TabPanel style={{flexGrow: '1'}}>
            <ChatApp app={this.state.apps.chat} onUnread={(chatUnread) => this.setState({chatUnread})}/>
          </TabPanel>
          <TabPanel>
            <MailApp app={this.state.apps.mail} onUnread={(mailUnread) => this.setState({mailUnread})}/>
          </TabPanel>
          {/*<TabPanel>
            <KeysApp app={this.state.apps.keys}/>
          </TabPanel>*/}
        </Tabs>
      </div>
    }
  }
}

'''
'''--- src/Router.js ---
import React, { Component } from 'react';
import {HashRouter, Route, Switch} from "react-router-dom";
import { Home } from './Home';
import { Auth } from './Auth';

class Router extends Component {
  render() {
    return (
      <HashRouter basename={process.env.PUBLIC_URL} hashType="noslash">
        <Switch>
          <Route exact path="/" component={() => <Home {...this.props}/>} />
          <Route path="/auth" component={() => <Auth {...this.props}/>} />
        </Switch>
      </HashRouter>
    );
  }
}

export default Router;

'''
'''--- src/apps/Chat/Channel.js ---
import React from "react";
import { ChatMessage } from "./ChatMessage";

export const ChatContract = 'metanear-chat';

const FetchMessagesLimit = 10;
const MinTimeDiffForMetaMs = 5 * 60 * 1000;

export class Channel extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            initialized: false,
            appReady: false,
            messages: [],
        };
        this.channelId = null;
        this.channelHash = null;
        this.cachedRanges = null;
        this.cachedMessages = {};
        this.fetchingMessages = false;
        this.fetchTimeoutId = null;
        this.channelInnerRef = React.createRef();
        this.mounted = false;
    }

    async loadCache(channelId) {
        const textEncoder = new TextEncoder('utf-8');
        const buf = textEncoder.encode('c:' + channelId);

        this.channelId = channelId;
        this.cachedMessages = {};
        this.channelHash =  Buffer.from(await crypto.subtle.digest('SHA-256', buf)).toString('base64');

        this.cachedRanges = JSON.parse(window.localStorage.getItem(this.channelHash + ':cachedRanges') || "null") || []
        this.cachedRanges.forEach((r) => {
            for (let i = r.first; i < r.last; ++i) {
                this.cachedMessages[i] = JSON.parse(window.localStorage.getItem(this.channelHash + ':m:' + i) || "null");
            }
        });
        this.updateState(true);
    }

    scrollDown() {
        this.channelInnerRef.current.scrollTop = this.channelInnerRef.current.scrollHeight;
    }

    updateState(scrollDown) {
        if (!this.mounted) {
            return;
        }
        this.setState({
            messages: Object.values(this.cachedMessages)
        }, () => {
            if (scrollDown)  {
                this.scrollDown();
            }
        })
    }

    maybeInit() {
        if (this.props.channelId && this.channelId !== this.props.channelId) {
            const cache = this.loadCache(this.props.channelId);
            if (this.state.appReady) {
                cache.then(() => {
                    this.fetchNewMessages();
                });
            }
        }
        if (this.props.app && !this.state.initialized) {
            this.setState({
                initialized: true,
                appReady: true,
            });
            this.fetchNewMessages();
        }
    }

    componentDidMount() {
        this.maybeInit()
        this.mounted = true;
    }

    componentDidUpdate(prevProps) {
        this.maybeInit()
        if (this.props.currentMessage) {
            setTimeout(() => {
                this.scrollDown();
            }, 10);
        }
        if (!this.props.currentMessage && prevProps.currentMessage) {
            this.fetchNewMessages();
        }
    }

    componentWillUnmount() {
        this.mounted = false;
        if (this.fetchTimeoutId) {
            clearTimeout(this.fetchTimeoutId);
            this.fetchTimeoutId = null;
        }
    }

    addNewMessage(channelId, message) {
        if (channelId !== this.channelId) {
            return;
        }
        const index = message.index;
        if (index in this.cachedMessages) {
            return;
        }
        this.cachedMessages[index] = message;
        window.localStorage.setItem(this.channelHash + ':m:' + index, JSON.stringify(message));

        this.cachedRanges.push({
            first: index,
            last: index + 1,
        });
        this.cachedRanges.sort((a, b) => a.first - b.first);
        this.cachedRanges = this.cachedRanges.reduce((rs, r) => {
            if (r.first === r.last) {
                return rs;
            }
            if (!rs.length) {
                rs.push(r);
            }
            if (rs[rs.length - 1].last === r.first) {
                rs[rs.length - 1].last = r.last;
            }
            return rs;
        }, []);
        window.localStorage.setItem(this.channelHash + ':cachedRanges', JSON.stringify(this.cachedRanges));
    }

    async fetchMessages(channelId, fromIndex, toIndex) {
        fromIndex = Math.max(fromIndex, toIndex - FetchMessagesLimit);
        let messages = await this.props.app.getFrom(ChatContract, JSON.stringify({
            ChannelMessages: {
                channel_id: channelId,
                from_index: fromIndex,
                limit: toIndex - fromIndex,
            }
        }), {});
        messages.messages.forEach((m, i) => {
          this.addNewMessage(channelId, {
              index: fromIndex + i,
              senderId: m.sender_id,
              text: m.text,
              time: m.time,
          });
        })
    }

    async fetchNewMessages() {
        if (this.fetchingMessages) {
            return;
        }
        try {
            this.fetchingMessages = true;
            if (this.fetchTimeoutId) {
                clearTimeout(this.fetchTimeoutId);
                this.fetchTimeoutId = null;
            }
            console.log("Fetching chat messages");
            const channel = this.channelId;
            let channelStatus = await this.props.app.getFrom(ChatContract, JSON.stringify({
                ChannelStatus: {
                    channel_id: channel,
                }
            }), {});
            let numChannelMessages = channelStatus.num_messages;
            let lastNumMessages = this.cachedRanges.length ? this.cachedRanges[this.cachedRanges.length - 1].last : 0;
            if (lastNumMessages < numChannelMessages) {
                await this.fetchMessages(channel, lastNumMessages, numChannelMessages);
                this.updateState(true);
            }
        }
        finally {
            this.fetchingMessages = false;
            if (this.mounted) {
                this.fetchTimeoutId = setTimeout(() => this.fetchNewMessages(), 2000);
            }
        }
    }

    render() {
        let lastMessage = null;
        return (
            <div className="channel fgrow" ref={this.channelInnerRef}>
                {this.state.messages.map((message) => {
                    const chatMessage = <ChatMessage
                        key={this.channelHash + message.index}
                        message={message}
                        onReply={() => this.onReply(message)}
                        showMeta={!lastMessage || message.senderId !== lastMessage.senderId || message.time - lastMessage.time > MinTimeDiffForMetaMs}
                    />;
                    lastMessage = message;
                    return chatMessage;
                })}
                {this.props.currentMessage && (
                    <ChatMessage
                        key={"currentMessage"}
                        message={this.props.currentMessage}
                        pending={true}
                        showMeta={true}
                    />
                )}
            </div>
        );
    }
}

'''
'''--- src/apps/Chat/Chat.css ---
.channel {
    border: 1px solid #ddd;
    padding: 0 0.5em;
    overflow-y: auto;
    overflow-x: hidden;
    height: 20em;
    background: #fff;
    text-align: left;
}

.chat-message {
    margin-top: 0.5em;
    clear: both;
}

.chat-message-no-meta {
    margin-top: 0.0em;
}

.chat-message-pending {
    background: #ffe;
}

.chat-message-profile {
    height: 3em;
    width: 3em;
    border-radius: 50%;
    vertical-align: top;
    float: left;
    margin-right: 0.5em;
}

.chat-message-no-meta .chat-message-profile,
.chat-message-no-meta .chat-message-meta {
    display: none;
}

.chat-message-sender-name {
    display: inline-block;
    font-weight: bold;
}

.chat-message-sender-id {
    display: inline-block;
    color: #999;
}

.chat-message-time {
    display: inline-block;
    margin-left: 1.5em;
    color: #ddd;
}

.chat-message-content {
    min-height: 3em;
    margin-left: 3.5em;
}

.chat-message-no-meta .chat-message-content {
    min-height: 1.5em;
}

.chat-message:hover {
    background: #f7f7f7;
}

'''
'''--- src/apps/Chat/ChatApp.js ---
import React from "react";
import anon from "../../assets/anon.png";
import { Profile } from "metanear-react-components";
import { Channel, ChatContract } from "./Channel";
import './Chat.css';

const ProfileInlineStyle = {
  profile: {
    whiteSpace: 'nowrap',
    display: 'inline-block',
  },
  profileImage: {
    height: '2em',
    width: '2em',
    borderRadius: '50%',
    verticalAlign: 'middle',
    marginRight: '0.5em',
  },
  profileName: {
    display: 'none',
  },
  profileDisplayName: {},
  profileAccountId: {},
};

export class ChatApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      initialized: false,
      appReady: false,
      text: "",
      channelId: "public",
      sending: false,
      currentMessage: null,
    };
    this.textInput = React.createRef();
  }

  maybeInit() {
    if (this.props.app && !this.state.initialized) {
      this.setState({
        initialized: true,
      });
      this.props.app.waitReady().then(() => {
        this.setState({
          appReady: true,
        }, () => {
          this.textInput.current.focus();
        })
      })
    }
  }

  componentDidMount() {
    this.maybeInit()
  }

  componentDidUpdate(prevProps) {
    this.maybeInit()
  }

  handleChange(key, value) {
    this.setState({
      [key]: value,
    });
  }

  async sendMessage() {
    console.log("Sending chat message");
    let text = this.state.text;
    this.setState({
      sending: true,
      text: "",
      currentMessage: {
        text,
        senderId: this.props.app.accountId,
        time: new Date().getTime(),
      }
    });
    try {
      let message = JSON.stringify({
        ChatMessage: {
          channel_id: this.state.channelId,
          text,
        }
      });
      await this.props.app.sendMessage(ChatContract, message);
      text = "";
    } catch (e) {
      console.log("Failed to send the chat message", e);
    } finally {
      this.setState({
        text,
        sending: false,
        currentMessage: null,
      });
    };
  }

  onKeyDown(event) {
    // 'keypress' event misbehaves on mobile so we track 'Enter' key via 'keydown' event
    if (event.key === 'Enter') {
      event.preventDefault();
      event.stopPropagation();
      this.sendMessage();
    }
  }

  render() {
    return (
      <div className="chat-app h100 cflex">
        <div className="channels">
          <div className="current-channel">#{this.state.channelId}</div>
        </div>
        <Channel channelId={this.state.channelId} app={this.props.app} currentMessage={this.state.currentMessage}/>
        <br/>
        <div className="input-group">
          <div className="input-group-prepend">
            {this.state.appReady && (<Profile accountId={this.props.app.accountId} defaultProfileUrl={anon} styles={ProfileInlineStyle}/>)}
          </div>
          <input ref={this.textInput}
                 id="text"
                 placeholder={"Message #" + this.state.channelId}
                 className="form-control form-control"
                 disabled={!this.state.appReady || this.state.sending}
                 value={this.state.text}
                 onKeyDown={(e) => this.onKeyDown(e)}
                 onChange={(e) => this.handleChange('text', e.target.value)}/>
          <div className="input-group-append">
            <button
                className='btn btn-primary'
                disabled={!this.state.appReady || this.state.sending}
                onClick={() => this.sendMessage()}
            >
              {this.state.sending && (
                  <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
              )} Send
            </button>
          </div>
        </div>
      </div>
    )
  }
}

'''
'''--- src/apps/Chat/ChatMessage.js ---
import React from "react";
import anon from "../../assets/anon.png";
import {Profile} from "metanear-react-components";

const ProfileMessageStyle = {
    profile: {
        display: 'none',
    },
};

const formatTime = (t) => {
    const d = new Date(t);
    const c = new Date();
    if (c.getDate() === d.getDate()) {
        return d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    } else {
        return d.toLocaleDateString()
    }
}

export class ChatMessage extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            displayName: "",
            profileUrl: anon,
        };
    }

    onProfile(p) {
        this.setState({
            displayName: (p && p.displayName) || "",
            profileUrl: (p && p.profileUrl) || anon,
        })
    }

    render() {
        const message = this.props.message;
        const content = message.text;
        const senderId = message.senderId;
        const time = formatTime(message.time);
        const p = this.props.showMeta && <Profile accountId={senderId} styles={ProfileMessageStyle} onFetch={(p) => this.onProfile(p)}/>;
        return (
            <div className={"chat-message" + (this.props.pending ? " chat-message-pending" : "") + (!this.props.showMeta ? " chat-message-no-meta" : "")}>
                {p}
                <img className="chat-message-profile" src={this.state.profileUrl} alt={`Profile @${senderId}`}/>
                <div className="chat-message-content">
                    <div className="chat-message-meta">
                        <div className="chat-message-sender-name">{this.state.displayName || ("@" + senderId)}</div>
                        {this.state.displayName && <div className="chat-message-sender-id">{"(@" + senderId + ")"}</div>}
                        {this.props.pending ?
                            <div className="chat-message-time"><span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span> sending</div> :
                            <div className="chat-message-time">{time}</div>
                        }
                    </div>
                    {content}
                </div>
            </div>
        )
    }
}

'''
'''--- src/apps/KeysApp.js ---
import React from "react";

const Status = {
  Initializing: "initializing",
  Ready: "ready",
  OtherKey: "otherKey",
  RequestedKey: "requestedKey",
};

const RequestStatus = {
  NotStarted: "notStarted",
  Pending: "pending",
  Declined: "declined",
  Invalid: "invalid",
  Approved: "approved",
}

const masterKeyRequest = "masterKeyRequest";

export class KeysApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      initialized: false,
      appReady: false,
      status: Status.Initializing,
      keyRequest: null,
      requestMessage: "",
      sendingRequest: false,
      forceShowRequestMessage: false,
    };
  }

  async init() {
    this.setState({
      appReady: true,
    });
    const app = this.props.app;
    const currentKey = await app.getStoredEncryptionPublicKey(null, {});
    const myKey = app.getEncryptionPublicKey();
    if (currentKey == null) {
      await app.storeEncryptionPublicKey();
      this.setState({
        status: Status.Ready,
      });
    } else if (currentKey !== myKey) {
      await this.checkRequestStatus();
    } else {
      // same key
      this.setState({
        status: Status.Ready,
      });
    }
  }

  async checkRequestStatus() {
    const app = this.props.app;
    const currentKey = await app.getStoredEncryptionPublicKey(null, {});
    const myKey = app.getEncryptionPublicKey();
    // Already have a key. Need to make a key request.
    const requestKey = `request:${myKey}`;
    let requestStatus = await app.get(requestKey) || RequestStatus.NotStarted;
    if (requestStatus === RequestStatus.Approved) {
      try {
        const responseKey = `request:${myKey}`;
        const response = await app.get(responseKey);
        const currentSecretKey = await app.decryptMessage(response, {
          theirPublicKey64: currentKey,
        });
        app.updateEncryptionKey(currentSecretKey);
        await app.remove(responseKey);
        await app.remove(requestKey);
        this.setState({
          status: Status.Ready,
        });
        return;
      } catch (e) {
        console.log("Failed to decrypt response:", e);
        requestStatus = RequestStatus.Invalid;
      }
    }
    this.setState({
      status: Status.OtherKey,
      keyRequest: {
        requestStatus,
        myKey,
        currentKey,
      }
    });
  }

  maybeInit() {
    if (this.props.app && !this.state.initialized) {
      this.setState({
        initialized: true,
      });
      this.props.app.waitReady().then(() => this.init());
    }
  }

  componentDidMount() {
    this.maybeInit()
  }

  componentDidUpdate(prevProps) {
    this.maybeInit()
  }

  handleChange(key, value) {
    const stateChange = {
      [key]: value,
    };
    this.setState(stateChange);
  }

  async makeKeyRequest() {
    this.setState({
      sendingRequest: true,
    });
    const app = this.props.app;
    const keyRequest = this.state.keyRequest;
    const requestKey = `request:${keyRequest.myKey}`;
    console.log(requestKey);
    await app.set(requestKey, RequestStatus.Pending);
    await app.sendMessage(app.accountId, JSON.stringify({
      type: masterKeyRequest,
      key: keyRequest.myKey,
      message: await app.encryptMessage(this.state.requestMessage, {
        theirPublicKey64: keyRequest.currentKey,
      })
    }));
    this.setState({
      keyRequest: Object.assign({}, keyRequest, {
        requestStatus: RequestStatus.Pending,
      }),
      sendingRequest: false,
      forceShowRequestMessage: false,
    })
  }

  render() {
    if (!this.state.appReady) {
      return <div>App is preparing...</div>;
    }
    if (this.state.status === Status.Initializing) {
      return <div>Initializing...</div>;
    }
    if (this.state.status === Status.OtherKey) {
      const alert =(
        <div className="alert alert-danger" role="alert">
          The app has a different encryption key!
        </div>
      );
      const showRequest = this.state.keyRequest.requestStatus === RequestStatus.NotStarted || this.state.forceShowRequestMessage;
      const newRequest = (
        <div>
          <label htmlFor="request-message">Request the encryption key from another device:</label>
          <div className="input-group">
            <input
              placeholder={"Enter a personalized message, e.g. \"It's me from mobile\""}
              id="request-message"
              className="form-control"
              value={this.state.requestMessage}
              onChange={(e) => this.handleChange('requestMessage', e.target.value)}/>
            <div className="input-group-append">
              <button
                className="btn btn-primary"
                disabled={this.state.sendingRequest || !this.state.requestMessage}
                onClick={() => this.makeKeyRequest()}
              >
                {this.state.sendingRequest && (
                  <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                )} Request
              </button>
            </div>
          </div>
        </div>
      );
      const showPendingRequest = this.state.keyRequest.requestStatus === RequestStatus.Pending;
      const pendingRequest = (
        <div>
          You've already sent a request. Open it on another authorized device to approve this request.
          <div>
            <button className="btn btn-primary" onClick={() => this.checkRequestStatus()}>Refresh</button>
            <button className="btn btn-secondary" onClick={() => this.setState({forceShowRequestMessage: true})}>Request again</button>
          </div>
        </div>
      );
      return (
        <div>
          {alert}
          {showPendingRequest && pendingRequest}
          {showRequest && newRequest}
        </div>
      );
    }
    if (this.state.status === Status.OtherKey) {

    }
    return (
      <div>
        <h3>Key management is here</h3>
      </div>
    )
  }
}

'''
'''--- src/apps/MailApp.js ---
import React from "react";
import anon from "../assets/anon.png";
import encryptionOn from "../assets/encryptionOn.png";
import encryptionOff from "../assets/encryptionOff.png";
import { Profile } from "metanear-react-components";

const RE = "Re: ";
const currentVersion = 2;

export class MailApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      initialized: false,
      receiverId: "",
      subject: "",
      content: "",
      sending: false,
      numLetters: 0,
      unread: 0,
      expandedId: -1,
      profileFound: false,
      profileLoading: false,
      keyLoading: false,
      theirPublicKey64: null,
      inbox: [],
    }
    this.textarea = React.createRef();
    this.keyCache = {};
  }

  modifyLetter(letter, messageId) {
    if (messageId === undefined) {
      if (!letter) {
        return;
      }
      messageId = letter.messageId;
    }
    const inbox = this.state.inbox.filter((a) => a.messageId !== messageId);
    if (letter) {
      inbox.push(letter);
    }
    inbox.sort((a, b) => b.time - a.time);
    const unread = inbox.reduce((acc, letter) => acc + (letter.read ? 0: 1), 0);
    this.setState({
      inbox,
      unread,
    });
    this.props.onUnread(unread);
  }

  async migrateFrom(version) {
    if (version === 0) {
      console.log("Migrating from version #0");
      let num = 0;
      try {
        num = await this.props.app.get('numLetters');
      } catch (e) {
        // whatever. Probably died during migration.
      }
      const allMigrations = [];
      for (let i = 0; i < num; ++i) {
        allMigrations.push(this.props.app.get('letter_' + i).then((letter) => {
          if (letter) {
            return this.props.app.set('letter_' + i, letter, {encrypted: true}).then(() => {
              console.log("Migrated letter #" + i);
            })
          }
          return Promise.resolve();
        }).catch((e) => console.log("Can't migrate letter #", i, e)));
      }
      await Promise.all(allMigrations);
      await this.props.app.set('numLetters', num, { encrypted: true });
      version++;
    }
    if (version === 1) {
      console.log("Migrating from version #1");
      await this.props.app.storeEncryptionPublicKey();
      version++;
    }
    await this.props.app.set('version', version, { encrypted: true });
  }

  async init() {
    let version;
    try {
      version = await this.props.app.get('version', {encrypted: true}) || 0;
    } catch (e) {
      // likely mismatched keys
      console.log(e);
      return;
    }
    if (version < currentVersion) {
      await this.migrateFrom(version);
    }
    const num = await this.props.app.get('numLetters', { encrypted: true }) || 0;
    this.setState({
      numLetters: num,
    });
    for (let i = Math.max(0, num - 10); i < num; ++i) {
      this.props.app.get('letter_' + i, {encrypted: true}).then((letter) => this.modifyLetter(letter));
    }
    this.fetchMessages();
  }

  maybeInit() {
    if (this.props.app && !this.state.initialized) {
      this.setState({
        initialized: true,
      });
      this.props.app.waitReady().then(() => this.init());
    }
  }

  componentDidMount() {
    this.maybeInit()
  }

  componentDidUpdate(prevProps) {
    this.maybeInit()
  }

  async fetchKey(accountId) {
    if (accountId in this.keyCache) {
      return await this.keyCache[accountId];
    } else {
      console.log("Fetching key for " + accountId);
      this.keyCache[accountId] = this.props.app.getStoredEncryptionPublicKey(accountId, {}).catch((e) => false);
      return await this.keyCache[accountId];
    }
  }

  updateKey(profile) {
    if (!this.props.app) {
      return;
    }
    this.setState({
      profileLoading: false,
      profileFound: !!profile,
    });
    if (!profile) {
      return;
    }
    this.setState({
      keyLoading: true,
    })
    this.fetchKey(profile.accountId).then((theirPublicKey64) => {
      this.setState({
        keyLoading: false,
        theirPublicKey64,
      })
    });
  }

  handleChange(key, value) {
    const stateChange = {
      [key]: value,
    };
    if (key === 'receiverId') {
      value = value.toLowerCase().replace(/[^a-z0-9\-_.]/, '');
      stateChange[key] = value;
      stateChange.profileLoading = true;
      stateChange.theirPublicKey64 = false;
    }
    this.setState(stateChange);
  }

  async fetchMessages() {
    if (!this.props.app) {
      return;
    }
    if (this.fetchTimeoutId) {
      clearTimeout(this.fetchTimeoutId);
      this.fetchTimeoutId = null;
    }
    console.log("Fetching messages");
    const message = await this.props.app.pullMessage();
    if (!message) {
      this.fetchTimeoutId = setTimeout(() => { this.fetchMessages() }, 60 * 1000);
      return;
    }
    try {
      console.log(message);
      let inner = JSON.parse(message.message);
      const isEncrypted = inner.type === 'encrypted';
      const fromAppId = inner.fromAppId || this.props.app.appId;
      if (isEncrypted) {
        const decryptedMessage = await this.props.app.decryptMessage(inner.content, {
          accountId: message.sender,
          appId: inner.fromAppId,
        });
        inner = JSON.parse(decryptedMessage);
      }
      if (inner.type === 'mail') {
        const letter = {
          messageId: this.state.numLetters,
          isEncrypted,
          fromAppId,
          sender: message.sender,
          subject: inner.subject,
          content: inner.content,
          time: Math.trunc(message.time / 1000000),
        }
        const newNumLetters = this.state.numLetters + 1;
        this.setState({
          numLetters: newNumLetters,
        });

        this.props.app.set("letter_" + letter.messageId, letter, {encrypted: true}).then(() => {
          console.log("Saved the letter: ", letter);
        });
        this.props.app.set("numLetters", newNumLetters, {encrypted: true}).then(() => {
            console.log("Saved the new number of letters: ", newNumLetters);
        });
        this.modifyLetter(letter);
      } else {
        console.warn("Unknown message", message);
      }
    } catch (e) {
      console.error(e);
    } finally {
      this.fetchMessages()
    }
  }

  async sendMail() {
    if (!this.state.profileFound) {
      return;
    }
    console.log("Sending mail");
    this.setState({
      sending: true,
    });
    try {
      let message = JSON.stringify({
        type: "mail",
        subject: this.state.subject,
        content: this.state.content,
      });
      if (this.state.theirPublicKey64) {
        const content = await this.props.app.encryptMessage(message, {
          theirPublicKey64: this.state.theirPublicKey64,
        });
        message = JSON.stringify({
          type: "encrypted",
          fromAppId: this.props.app.appId,
          content,
        })
      }
      await this.props.app.sendMessage(this.state.receiverId, message);
      this.setState({
        subject: "",
        content: "",
      })
    } catch (e) {
      console.log("Failed to send the message", e);
    } finally {
      this.setState({
        sending: false,
      });
      setTimeout(() => this.fetchMessages(), 2000);
    };
  }

  receiverClass() {
    if (!this.state.receiverId || this.state.profileLoading) {
      return "form-control";
    } else if (this.state.profileFound) {
      return "form-control is-valid";
    } else {
      return "form-control is-invalid";
    }
  }

  replyTo(letter, displayName) {
    this.handleChange("receiverId", letter.sender);
    this.setState({
      subject: (letter.subject.startsWith(RE) ? "" : RE) + letter.subject,
      content: [
        "",
        "",
        ["On", new Date(letter.time).toLocaleDateString(), displayName, "@" + letter.sender, "wrote:"].join(' '),
        ...letter.content.split(/\r?\n/).map(s => "| " + s)
      ].join("\n"),
    }, () => {
      this.textarea.current.focus();
      this.textarea.current.setSelectionRange(0, 0);
      this.textarea.current.scrollLeft = 0;
      this.textarea.current.scrollTop = 0;
    });
  }

  selectLetter(letter) {
    this.setState({
      expandedId: (this.state.expandedId === letter.messageId) ? -1 : letter.messageId,
    });
    if (!letter.read) {
      letter = JSON.parse(JSON.stringify(letter));
      letter.read = true;
      this.props.app.set("letter_" + letter.messageId, letter, {encrypted: true}).then(() => {
        console.log("Saved the letter: ", letter);
      });
      this.modifyLetter(letter);
    }
  }

  deleteLetter(letter) {
    this.props.app.remove("letter_" + letter.messageId).then(() => {
      console.log("Deleted the letter: ", letter);
    });
    this.modifyLetter(null, letter.messageId);
  }

  render() {
    const encryptionEnabled = this.state.theirPublicKey64;
    const displayEncryptionIcon = this.state.profileFound && !this.state.keyLoading;
    const encryptionAlt = encryptionEnabled ? "Encryption is ON" : "Not secure! Encryption is OFF";
    const encryptionIcon = displayEncryptionIcon &&
      <img className="encryption-icon" src={encryptionEnabled ? encryptionOn : encryptionOff}
          title={encryptionAlt} alt={encryptionAlt}/>;
    const profile = <Profile accountId={this.state.receiverId} onFetch={(profile) => this.updateKey(profile)} defaultProfileUrl={anon}/>;
    const inbox = this.state.inbox.map((letter, i) => (
      <Letter
        key={letter.messageId}
        letter={letter}
        expanded={letter.messageId === this.state.expandedId}
        deleteLetter={(letter) => this.deleteLetter(letter)}
        replyTo={(letter, displayName) => this.replyTo(letter, displayName)}
        selectLetter={(letter) => this.selectLetter(letter)} />
    ));
    return (
      <div>
        Inbox <button className="btn btn-sm" onClick={() => this.fetchMessages()}><span role="img" aria-label="Refresh">ðŸ”„</span></button>
        <div>
          {inbox}
        </div>
        <h3>Send</h3>
        <div className="form-row">
          <div className="col">
            <div className="form-group">
              <label className="sr-only" htmlFor="toAccountId">To Account ID</label>
              <div className="input-group">
                <div className="input-group-prepend">
                  <div className="input-group-text">@</div>
                </div>
                <input type="text" className={this.receiverClass()} id="toAccountId" placeholder="To Account ID" value={this.state.receiverId} disabled={!this.props.app} onChange={(e) => this.handleChange('receiverId', e.target.value)} />
              </div>
            </div>
          </div>
          {profile}
        </div>
        <div className="form-group">
          <label className="sr-only" htmlFor="subject">Subject</label>
          <input type="text" className="form-control" id="subject" placeholder="Subject" disabled={!this.props.app} value={this.state.subject} onChange={(e) => this.handleChange('subject', e.target.value)} />
        </div>
        <div className="form-group">
          <textarea ref={this.textarea} id="content" className="form-control" rows="7" disabled={!this.props.app} value={this.state.content} onChange={(e) => this.handleChange('content', e.target.value)} />
        </div>
        <div className="form-group">
          <button className={"form-control form-control-lg btn " + (displayEncryptionIcon && !encryptionEnabled ? "btn-danger" : "btn-primary")} disabled={!this.state.profileFound || this.state.sending} onClick={() => this.sendMail()}>
            Send {encryptionIcon}</button>
        </div>
      </div>
    )
  }
}

export class Letter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      profile: {
        profileUrl: null,
        displayName: '@' + props.letter.sender,
      },
    };
  }

  onClick() {
    this.props.selectLetter(this.props.letter);
  }

  render() {
    const profile = (
      <div className="col-sm-6 col-md-4 col-lg-4 letter-profile">
        <Profile accountId={this.props.letter.sender} onFetch={(profile) => profile && this.setState({displayName: profile.displayName})} defaultProfileUrl={anon}/>
      </div>
    );
    const subject = (
      <div className="col-sm-4 col-md">
        <div className="letter-subject">{this.props.letter.subject}</div>
      </div>
    );
    const time = this.props.expanded ? (
      <div className="col-sm-2 col-lg-2">
        <div className="letter-time">{longTimeFormat(this.props.letter.time)}</div>
      </div>
    ) : (
      <div className="col-sm-2 col-lg-1 d-none d-md-block">
        <div className="letter-time">{timeFormat(this.props.letter.time)}</div>
      </div>
    );
    if (this.props.expanded) {
      return (
        <div className="letter letter-expanded">
          <div className="row letter-expanded-header" onClick={() => this.onClick()}>
            {profile}
            {subject}
            {time}
          </div>
          <div className="letter-content-expanded">
            <pre>{this.props.letter.content}</pre>
            <div className="row">
              <div className="col-sm">
                <button className="btn btn-primary" onClick={() => this.props.replyTo(this.props.letter, this.state.displayName)}>Reply</button>
              </div>
              <div className="col-sm">
                <button className="btn btn-danger float-right" onClick={() => this.props.deleteLetter(this.props.letter)}>DELETE THIS!</button>
              </div>
            </div>
          </div>
        </div>
      );
    } else {
      return (
        <div className={"row letter letter-small" + (this.props.letter.read ? " letter-read" : " letter-unread")} onClick={() => this.onClick()}>
          {profile}
          {subject}
          <div className="col-sm d-none d-lg-block">
            <div className="letter-content">{this.props.letter.content}</div>
          </div>
          {time}
        </div>
      );
    }
  }
}

function longTimeFormat(t) {
  return new Date(t).toLocaleString();
}

function timeFormat(t) {
  const d = new Date(t);
  const now = new Date();
  if (now.getDate() === d.getDate()) {
    const hour = d.getHours() % 12;
    const minute = d.getMinutes().toString().padStart(2, '0');
    const daytime = d.getHours() >= 12 ? "PM" : "AM";
    return `${hour}:${minute} ${daytime}`;
  } else {
    return d.toLocaleDateString();
  }
}

'''
'''--- src/apps/ProfileApp.js ---
import React from "react";
import anon from "../assets/anon.png";
import Files from "react-files";
import { Profile } from "metanear-react-components";

const uploadResizeWidth = 96;
const uploadResizeHeight = 96;

export class ProfileApp extends React.Component {
  constructor(props) {
    super(props);
    const keys = [
      "displayName",
      "profileUrl",
      "bio",
    ];
    this.state = keys.reduce((acc, key) => {
      acc[key] = "";
      acc.chainValues[key] = null;
      return acc;
    }, {
      keys,
      chainValues: {},
      initialized: false,
      saving: false,
      hasChanges: false,
      appReady: false,
    });
  }

  async init(profile) {
    if (!profile) {
      return;
    }
    const newState = this.state.keys.reduce((state, key) => {
      state[key] = profile[key] || "";
      state.chainValues[key] = state[key];
      return state;
    }, {
      chainValues: {}
    });
    this.setState(newState);
  }

  maybeInit() {
    if (this.props.app && !this.state.initialized) {
      this.setState({
        initialized: true,
      });
      this.props.app.waitReady().then(() => {
        this.setState({
          appReady: true,
        })
      })
    }
  }

  componentDidMount() {
    this.maybeInit()
  }

  componentDidUpdate(prevProps) {
    this.maybeInit()
  }

  handleChange(key, value) {
    this.setState({
      [key]: value,
    });
  }

  hasChanges() {
    return this.state.keys.some(key => this.state.chainValues[key] !== this.state[key]);
  }

  async save() {
    this.setState({
      saving: true,
    });
    console.log("Saving");
    const chainValues = Object.assign({}, this.state.chainValues);
    const promises = [];
    this.state.keys.forEach(key => {
      if (this.state.chainValues[key] !== this.state[key]) {
        chainValues[key] = this.state[key];
        promises.push(this.props.app.set(key, this.state[key]).then(() => {
          console.log("Updated key `" + key + "` to value `" + this.state[key] + '`');
        }));
      }
    });
    Promise.all(promises).then(() => {
      this.setState({
        chainValues,
        saving: false,
      })
    });
  }

  async onFilesChange(f) {
    let sourceImage = new Image();
    let reader = new FileReader();

    reader.readAsDataURL(f[0]);

    sourceImage.onload = () => {
      // Create a canvas with the desired dimensions
      let canvas = document.createElement("canvas");
      const aspect = sourceImage.naturalWidth / sourceImage.naturalHeight;
      const width = Math.round(uploadResizeWidth * Math.max(1, aspect));
      const height = Math.round(uploadResizeHeight * Math.max(1, 1 / aspect));
      canvas.width = uploadResizeWidth;
      canvas.height = uploadResizeHeight;
      const ctx = canvas.getContext("2d");

      // Scale and draw the source image to the canvas
      ctx.imageSmoothingQuality = "high";
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, uploadResizeWidth, uploadResizeHeight);
      ctx.drawImage(sourceImage, (uploadResizeWidth - width) / 2, (uploadResizeHeight - height) / 2, width, height);

      // Convert the canvas to a data URL in PNG format
      const options = [
        canvas.toDataURL('image/jpeg', 0.92),
        // Disabling webp because it doesn't work on iOS.
        // canvas.toDataURL('image/webp', 0.92),
        canvas.toDataURL('image/png')
      ];
      options.sort((a, b) => a.length - b.length);

      this.handleChange('profileUrl', options[0]);
    }

    reader.onload = function(event) {
      sourceImage.src = event.target.result;
    };
  }

  async onFilesError(e, f) {
    console.log(e, f);
  }

  render() {
    return (
      <div>
        <div>
          <button className="float-right" onClick={this.props.logOut}>Log out</button>
          <Profile
            accountId={this.props.app && this.props.app.accountId}
            profileUrl={this.state.profileUrl}
            displayName={this.state.displayName}
            bio={this.state.bio}
            defaultProfileUrl={anon}
            onFetch={(profile) => this.init(profile)}
          />
        </div>
        <hr/>
        <div>
          <div className="form-group">
            <label htmlFor="displayName">Display Name</label>
            <input placeholder="The REAL Satoshi" id="displayName" className="form-control" disabled={!this.props.app} value={this.state.displayName} onChange={(e) => this.handleChange('displayName', e.target.value)} />
          </div>
          <label htmlFor="profileUrl">Profile URL</label>
          <div className="input-group">
            <input placeholder={"https://metanear.com" + anon} id="profileUrl" className="form-control" disabled={!this.props.app} value={this.state.profileUrl}
                   onChange={(e) => this.handleChange('profileUrl', e.target.value)}/>
            <div className="input-group-append">
              <Files
                type="button"
                className='btn btn-outline-primary'
                onChange={(f) => this.onFilesChange(f)}
                onError={(e, f) => this.onFilesError(e, f)}
                multiple={false}
                accepts={['image/*']}
                minFileSize={1}
                clickable
              >
                Click to upload
              </Files>
            </div>

          </div>
          <div className="form-group">
            <label htmlFor="bio">Bio</label>
            <textarea placeholder="I'm working on Bitcoin, so bankers can go home." id="bio" className="form-control" disabled={!this.props.app} value={this.state.bio} onChange={(e) => this.handleChange('bio', e.target.value)} />
          </div>
          <div className="form-group">
            <button
                className="btn btn-primary"
                disabled={this.state.saving || !this.hasChanges()}
                onClick={() => this.save()}
            >
              {this.state.saving && (
                  <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
              )} Save changes
            </button>
          </div>
        </div>
      </div>
    )
  }
}

'''
'''--- src/assets/gray_near_logo.svg ---
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 433 180.5"><defs><style>.cls-1{fill:url(#linear-gradient);}.cls-2{fill:#4a4f54;}</style><linearGradient id="linear-gradient" x1="40.11" y1="140.87" x2="140.87" y2="40.11" gradientUnits="userSpaceOnUse"><stop offset="0.21" stop-color="#4a4f54"/><stop offset="0.42" stop-color="#4a4f54" stop-opacity="0"/><stop offset="0.59" stop-color="#4a4f54" stop-opacity="0"/><stop offset="0.81" stop-color="#4a4f54"/></linearGradient></defs><title>near_logo</title><path class="cls-1" d="M48.84,144.5a12.32,12.32,0,0,0,9.35-4.28h0l84.42-97.93a12.32,12.32,0,0,0-10.45-5.79h0a12.31,12.31,0,0,0-9.31,4.24L38,138.09A12.34,12.34,0,0,0,48.84,144.5Z"/><path class="cls-2" d="M48.84,144.5a12.38,12.38,0,0,0,5.66-1.37V61.36l65.58,78.7a12.37,12.37,0,0,0,9.49,4.44h2.59a12.35,12.35,0,0,0,12.34-12.34V48.84A12.35,12.35,0,0,0,132.16,36.5h0a12.45,12.45,0,0,0-5.62,1.35v81.79L60.92,40.94a12.37,12.37,0,0,0-9.49-4.44H48.84A12.35,12.35,0,0,0,36.5,48.84v83.32A12.35,12.35,0,0,0,48.84,144.5Z"/><path class="cls-2" d="M225.71,64.25v52.5a.76.76,0,0,1-.75.75h-5.51a7.49,7.49,0,0,1-6.3-3.43l-24.78-38.3.85,19.13v21.85a.76.76,0,0,1-.75.75h-7.22a.76.76,0,0,1-.75-.75V64.25a.76.76,0,0,1,.75-.75h5.43a7.52,7.52,0,0,1,6.3,3.42l24.78,38.24L217,86.1V64.25a.75.75,0,0,1,.75-.75H225A.76.76,0,0,1,225.71,64.25Z"/><path class="cls-2" d="M299.51,117.5h-7.64a.75.75,0,0,1-.7-1L311.4,64.22a1.14,1.14,0,0,1,1.05-.72H322a1.14,1.14,0,0,1,1.05.72l20.23,52.26a.75.75,0,0,1-.7,1H335a.76.76,0,0,1-.71-.48L317.94,74a.75.75,0,0,0-1.41,0l-16.31,43A.76.76,0,0,1,299.51,117.5Z"/><path class="cls-2" d="M396.34,116.29,381.16,96.9c8.57-1.62,13.58-7.4,13.58-16.27,0-10.19-6.63-17.13-18.36-17.13H355.21a1.12,1.12,0,0,0-1.12,1.12h0a7.2,7.2,0,0,0,7.2,7.21h14.17c7.09,0,10.49,3.63,10.49,8.87s-3.32,9-10.49,9H355.21a1.13,1.13,0,0,0-1.12,1.13v26a.75.75,0,0,0,.75.75h7.22a.76.76,0,0,0,.75-.75V97.37h8.33l13.17,17.19a7.51,7.51,0,0,0,6,2.94h5.48A.75.75,0,0,0,396.34,116.29Z"/><path class="cls-2" d="M276.67,63.5h-33.5a1,1,0,0,0-1,1h0a7.33,7.33,0,0,0,7.33,7.33h27.17a.74.74,0,0,0,.75-.75V64.25A.75.75,0,0,0,276.67,63.5Zm0,45.67h-25a.76.76,0,0,1-.75-.75V94.88a.75.75,0,0,1,.75-.75h23.11a.75.75,0,0,0,.75-.75V86.54a.75.75,0,0,0-.75-.75H243.29a1.13,1.13,0,0,0-1.12,1.13v29.45a1.12,1.12,0,0,0,1.12,1.13h33.38a.75.75,0,0,0,.75-.75v-6.83A.74.74,0,0,0,276.67,109.17Z"/></svg>
'''
'''--- src/assets/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3">
    <g fill="#61DAFB">
        <path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/>
        <circle cx="420.9" cy="296.5" r="45.7"/>
        <path d="M520.5 78.1z"/>
    </g>
</svg>

'''
'''--- src/assets/near.svg ---
<svg width="97px" height="97px" viewBox="0 0 97 97" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <linearGradient x1="8.03545747%" y1="96.638877%" x2="92.2738738%" y2="3.34259955%" id="linearGradient-1">
            <stop stop-color="#4B4F54" offset="21%"></stop>
            <stop stop-color="#4B4F54" stop-opacity="0" offset="42%"></stop>
            <stop stop-color="#4B4F54" stop-opacity="0" offset="59%"></stop>
            <stop stop-color="#4B4F54" offset="81%"></stop>
        </linearGradient>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="create" transform="translate(-1054.000000, -595.000000)" fill-rule="nonzero">
            <g id="Group-5" transform="translate(1054.000000, 595.000000)">
                <path d="M12.094392,97.0000195 C15.2088036,97.0039527 18.1698244,95.6000877 20.2022804,93.1559341 L20.2022804,93.1559341 L93.4074074,5.20030368 C91.4546314,1.96447154 88.0299073,1.95462232e-05 84.3456498,1.95462232e-05 L84.3456498,1.95462232e-05 C81.2486381,-0.0036811685 78.3027381,1.38590639 76.2724476,3.80817433 L2.69444444,91.2428789 C4.57536204,94.7980982 8.18030259,97.0059941 12.094392,97.0000195 Z" id="Path" fill="url(#linearGradient-1)"></path>
                <path d="M11.0831481,97 C12.8513879,97 14.5941045,96.5780666 16.1666667,95.769537 L16.1666667,22.327963 L75.0672222,93.0122222 C77.1773546,95.5384707 80.2990545,96.9989921 83.5906481,97 L85.9168519,97 C92.0358529,96.9950473 96.9950473,92.0358529 97,85.9168519 L97,11.0831481 C96.9950473,4.96414708 92.0358529,0.00495265405 85.9168519,0 L85.9168519,0 C84.1625017,0.00260840866 82.4333785,0.417967183 80.8692593,1.2125 L80.8692593,74.672037 L21.9327778,3.98777778 C19.8226454,1.4615293 16.7009455,0.00100794796 13.4093519,0 L11.0831481,0 C4.96414708,0.00495265405 0.00495265405,4.96414708 0,11.0831481 L0,85.9168519 C0.00495265405,92.0358529 4.96414708,96.9950473 11.0831481,97 Z" id="Path" fill="#4B4F54"></path>
            </g>
        </g>
    </g>
</svg>
'''
'''--- src/components/PowFaucet.js ---
import React from 'react';
import * as nearlib from 'near-api-js';
import { generateSeedPhrase } from 'near-seed-phrase';

const FaucetPrivateKey = 'ed25519:2Rtn6ms22rCRMgmGgLRSPPd6gYDCgWDuFrX6gERknSA8GKiCHE5L9Rksc1ihsSCDvMSptfbipzq29H7cDZhR1Ze3';
const FaucetName = 'meta';
const MinAccountIdLen = 2;
const MaxAccountIdLen = 64;
const ValidAccountRe = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
export const AuthDataKey = "meta-faucet-auth-data";

export class PowFaucet extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            connected: false,
            signedIn: false,
            accountId: null,
            newAccountId: "",
            creating: false,
            accountLoading: false,
            newAccountExists: false,
            computingProofOfWork: false,
        };
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    componentDidMount() {
        this.mounted = true;
        this.initNear().then(() => {
            this.mounted && this.setState({
                connected: true,
                signedIn: !!this._authData.accountId,
                accountId: this._authData.accountId,
            })
        })
    }

    async initFaucet() {
        let key = await this._keyStore.getKey(this._nearConfig.networkId, FaucetName);
        if (!key) {
            const keyPair = nearlib.KeyPair.fromString(FaucetPrivateKey);
            await this._keyStore.setKey(this._nearConfig.networkId, FaucetName, keyPair);
        }
        const account = new nearlib.Account(this._near.connection, FaucetName);
        this._faucetContract =  new nearlib.Contract(account, FaucetName, {
            viewMethods: ['get_min_difficulty', 'get_account_suffix', 'get_num_created_accounts'],
            changeMethods: ['create_account'],
            sender: FaucetName
        });
        this._accountSuffix = await this._faucetContract.get_account_suffix();
        this._minDifficulty = await this._faucetContract.get_min_difficulty();
        this.mounted && this.setState({
            numCreatedAccounts: await this._faucetContract.get_num_created_accounts(),
        });
        // console.log(JSON.stringify([...key.getPublicKey().data]));
    }

    async initNear() {
        const nearConfig = {
            networkId: 'default',
            nodeUrl: 'https://rpc.nearprotocol.com',
            contractName: FaucetName,
            walletUrl: 'https://wallet.nearprotocol.com',
        };
        const keyStore = new nearlib.keyStores.BrowserLocalStorageKeyStore();
        const near = await nearlib.connect(Object.assign({ deps: { keyStore } }, nearConfig));
        this._keyStore = keyStore;
        this._nearConfig = nearConfig;
        this._near = near;

        this._authData = JSON.parse(window.localStorage.getItem(AuthDataKey) || '{}');
        await this.initFaucet();
    }

    handleChange(key, value) {
        const stateChange = {
            [key]: value,
        };
        if (key === 'newAccountId') {
            value = value.toLowerCase().replace(/[^a-z0-9\-_.]/, '');
            stateChange[key] = value;
            stateChange.newAccountExists = false;
            if (this.isValidAccount(value)) {
                stateChange.accountLoading = true;
                this._near.connection.provider.query(`account/${value + this._accountSuffix}`, '').then((_a) => {
                    if (this.state.newAccountId === value) {
                        this.setState({
                            accountLoading: false,
                            newAccountExists: true,
                        })
                    }
                }).catch((e) => {
                    if (this.state.newAccountId === value) {
                        this.setState({
                            accountLoading: false,
                            newAccountExists: false,
                        })
                    }
                })
            }
        }
        this.setState(stateChange);
    }

    isValidAccount(newAccountId) {
        if (newAccountId.includes('.')) {
            return false;
        }
        const accountId = newAccountId + this._accountSuffix;
        return accountId.length >= MinAccountIdLen &&
            accountId.length <= MaxAccountIdLen &&
            accountId.match(ValidAccountRe);
    }

    newAccountClass() {
        if (!this.state.newAccountId || this.state.accountLoading) {
            return "form-control form-control-large";
        } else if (!this.state.newAccountExists && this.isValidAccount(this.state.newAccountId)) {
            return "form-control form-control-large is-valid";
        } else {
            return "form-control form-control-large is-invalid";
        }
    }

    async computeProofOfWork(accountId, publicKey) {
        let msg = [...new TextEncoder('utf-8').encode(accountId + ':')];
        // curve
        msg.push(0);
        // key
        msg.push(...publicKey.data);
        // separator
        msg.push(':'.charCodeAt(0));
        // salt
        msg.push(0, 0, 0, 0, 0, 0, 0, 0);
        msg = new Uint8Array(msg);
        const len = msg.length;
        let bestDifficulty = 0;
        for (let salt = 0; ; ++salt) {
            // compute hash
            const hashBuffer = new Uint8Array(await crypto.subtle.digest('SHA-256', msg));
            // compute number of leading zero bits
            let totalNumZeros = 0;
            for (let i = 0; i < hashBuffer.length; ++i) {
                let numZeros = Math.clz32(hashBuffer[i]) - 24;
                totalNumZeros += numZeros;
                if (numZeros < 8) {
                    break;
                }
            }
            // checking difficulty
            if (totalNumZeros >= this._minDifficulty) {
                this.setState({
                    computingProofOfWork: false,
                });
                return salt;
            } else if (totalNumZeros > bestDifficulty) {
                bestDifficulty = totalNumZeros;
                this.setState({
                    proofOfWorkProgress: Math.trunc(bestDifficulty * 100 / this._minDifficulty),
                    proofOfWorkDifficulty: bestDifficulty,
                    proofOfWorkSalt: salt,
                });
            } else if (salt % 10000 === 0) {
                this.setState({
                    proofOfWorkSalt: salt
                });
            }
            // incrementing salt
            for (let i = len - 8; i < len; ++i) {
                if (msg[i] === 255) {
                    msg[i] = 0;
                } else {
                    ++msg[i];
                    break;
                }
            }
        }
    }

    async createAccount() {
        this.setState({
            creating: true,
            computingProofOfWork: true,
            proofOfWorkProgress: 0,
            proofOfWorkDifficulty: 0,
            proofOfWorkSalt: 0,
        })
        const newAccountId = this.state.newAccountId + this._accountSuffix;
        const seed = generateSeedPhrase();
        const newKeyPair = nearlib.KeyPair.fromString(seed.secretKey);
        const salt = await this.computeProofOfWork(newAccountId, newKeyPair.getPublicKey());
        await this._faucetContract.create_account({
            account_id: newAccountId,
            public_key: [0, ...newKeyPair.getPublicKey().data],
            salt,
        });
        await this._keyStore.setKey(this._nearConfig.networkId, newAccountId, newKeyPair);
        this._authData = {
            accountId: newAccountId,
            seed,
        };
        window.localStorage.setItem(AuthDataKey, JSON.stringify(this._authData));
        this.setState({
            signedIn: true,
            accountId: newAccountId,
            creating: false,
            numCreatedAccounts: await this._faucetContract.get_num_created_accounts(),
        })
        this.props.onLogin(this._authData);
    }

    moveAccountToWallet() {
        window.location = `https://wallet.nearprotocol.com/recover-with-link/${this._authData.accountId}/${this._authData.seed.seedPhrase}`;
    }

    logout() {
        window.localStorage.removeItem(AuthDataKey);
        this._authData = {};
        this.setState({
            signedIn: false,
            accountId: null,
            newAccountId: "",
            creating: false,
            accountLoading: false,
            newAccountExists: false,
            computingProofOfWork: false,
        });
    }

    render() {
        const content = !this.state.connected ? (
            <div>Connecting... <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span></div>
        ) : (this.state.signedIn ? (
            <div>
                <h3>Hello, {this.state.accountId}</h3>
                <div className="form-group">
                    <button
                        className="btn btn-success"
                        onClick={() => this.moveAccountToWallet()}
                    >
                        Move account to NEAR Wallet
                    </button>
                </div>
                <div className="form-group">
                    <button
                        className="btn btn-danger"
                        onClick={() => this.logout()}
                    >
                        Logout from Faucet
                    </button>
                </div>
            </div>
        ) : (
            <div>
                <div className="form-group">
                    <div className="input-group">
                        <div className="input-group-prepend">
                            <div className="input-group-text">{"@"}</div>
                        </div>
                        <input
                            placeholder="bob"
                            id="accountId"
                            className={this.newAccountClass()}
                            value={this.state.newAccountId}
                            onChange={(e) => this.handleChange('newAccountId', e.target.value)}
                            disabled={this.state.creating}
                        />
                        <div className="input-group-append">
                            <div className="input-group-text">{this._accountSuffix}</div>
                        </div>
                    </div>
                </div>
                {this.state.newAccountExists && (
                    <div className="alert alert-warning" role="alert">
                        Account {'"' + this.state.newAccountId + this._accountSuffix + '"'} already exists!
                    </div>
                )}
                <div className="form-group">
                    <button
                        className="btn btn-primary"
                        disabled={this.state.creating || this.state.accountLoading || this.state.newAccountExists || !this.isValidAccount(this.state.newAccountId)}
                        onClick={() => this.createAccount()}
                    >
                        {(this.state.creating || this.state.accountLoading) && (
                            <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                        )} Create Account {this.isValidAccount(this.state.newAccountId) ? ('"' + this.state.newAccountId + this._accountSuffix + '"') : ""}
                    </button>
                </div>
                {this.state.creating && (
                    <div>
                        {this.state.computingProofOfWork ? (
                            <div>
                                Computing Proof of Work. Done {this.state.proofOfWorkSalt} operations.
                                <div className="progress">
                                    <div className="progress-bar" role="progressbar" style={{width: this.state.proofOfWorkProgress + '%'}} aria-valuenow={this.state.proofOfWorkProgress} aria-valuemin="0"
                                         aria-valuemax="100">{this.state.proofOfWorkDifficulty} out of {this._minDifficulty}
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <div>
                                Proof of Work is Done! Creating account {'"' + this.state.newAccountId + this._accountSuffix + '"'}
                            </div>
                        )}
                    </div>
                )}
            </div>
        ));
        return (
            <div>
                <h3>or create a new account</h3>
                {content}
            </div>
        );
    }
}

'''
'''--- src/css/App.css ---
.App-header {
  min-height: 100vh;
  font-size: 1rem;
  text-align: left;
  padding:2%;
}

.App-link {
  color: #61dafb;
}

.apps {
  background: #fff;
  text-align: left;
  padding: 0.5em;
}

.App-logo {
  animation: App-logo-spin infinite 20s linear;
  pointer-events: none;
}

.margin-logo {
  margin: 20px;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.files-dropzone {

}

.loading-div pre {
  background: #000;
  color: #0f0;
}

.loading-spinner {
  width: 3em;
  height: 3em;
}

.encryption-icon {
  height: 2em;
  width: 2em;
}

.letter-small {
  line-height: 3em;
  cursor: pointer;
}

.letter-expanded {
}

.letter-expanded-header {
  background: #eee;
  line-height: 3em;
  cursor: pointer;
  margin: 0;
}

.letter {
  border-bottom: 1px solid #ddd;
  border-left: 1px solid #fff;
  border-right: 1px solid #fff;
  margin: 0;
}

.letter:hover {
  border-bottom: 1px solid #ccc;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  box-shadow: 0px 2px 5px rgba(64, 64, 64, .5);
}

.letter-read {
  background: #eee;
}

.letter .profile-image {
  height: 2.7em;
  width: 2.7em;
  border-radius: 50%;
}

.letter-unread {
  font-weight: bold;
}

.letter-subject {
  overflow: hidden;
}

.letter-content {
  color: #999;
  overflow: hidden;
  font-weight: normal;
  height: 3em;
}

.letter-content-expanded {
  color: #333;
  padding: 0.5em;
}

.letter-time {
  font-size: 12px;
  white-space: nowrap;
}

.image-wrapper {
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: center;
}

.logo {
  width: 33%;
}

p {
  color: #25282A;
  font-family: sans-serif;
}

button {
  padding: 5px;
  color: #0072CE;
  border-radius: 10px;
  border: 3px solid #0072CE;
}

button:hover {
  cursor: pointer;
  color: white;
  background: #0072CE;
}

.h100 {
  height: 100%;
}

.cflex {
  display: flex;
  flex-direction: column;
}

.fgrow {
  flex-grow: 1;
}

#chat-tab {
  flex-grow: 1;
}

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import Router from './Router';
import * as nearlib from 'near-api-js';

// Initializing contract
async function InitContract() {
    window.nearConfig = {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
    };

    // Initializing connection to the NEAR DevNet.
    window.near = await nearlib.connect(Object.assign({ deps: { keyStore: new nearlib.keyStores.BrowserLocalStorageKeyStore() } }, window.nearConfig));

    // Needed to access wallet login
    window.walletAccount = new nearlib.WalletAccount(window.near);

    // Getting the Account ID. If unauthorized yet, it's just empty string.
    window.accountId = window.walletAccount.getAccountId();

}

window.nearInitPromise = InitContract().then(() => {
    ReactDOM.render(<Router contract={window.contract} wallet={window.walletAccount}/>,
      document.getElementById('root')
    );
  }).catch(console.error)

'''