*GitHub Repository "near/octopus"*

'''--- .github/FUNDING.yml ---
github: [pventuzelo]

'''
'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# Octopus

<p align="center">
	<img src="/images/logo-medium.png" height="300px"/>
</p>

[![made-with-python](https://img.shields.io/badge/Made%20with-Python-1f425f.svg)](https://www.python.org/)
[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/quoscient/octopus/graphs/commit-activity)
[![MIT license](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)

Huge thanks to [QuoScient](https://www.quoscient.io/) for having sponsored this project.

**Octopus is a security analysis framework for WebAssembly module and Blockchain Smart Contract.**

The purpose of Octopus is to provide an easy way to analyze closed-source WebAssembly module and smart contracts bytecode to understand deeper their internal behaviours.

## Features

- **Explorer**: Octopus JSON-RPC client implementation to communicate with blockchain platforms
- **Disassembler**: Octopus can translate bytecode into assembly representation
- **Control Flow Analysis**: Octopus can generate a Control Flow Graph (CFG) 
- **Call Flow Analysis**: Octopus can generate a Call Flow Graph (function level) 
- **IR conversion (SSA)**: Octopus can simplify assembly into Static Single Assignment (SSA) representation
- **Symbolic Execution**: Octopus use symbolic execution to find new paths into a program

## Platforms / Architectures

Octopus support the following types of programs/smart contracts:
* WebAssembly module (WASM)
* Bitcoin script (BTC script)
* Ethereum smart contracts (EVM bytecode & Ewasm)
* EOS smart contracts (WASM)
* NEO smart contracts (AVM bytecode)

|| BTC | ETH (EVM) | ETH (WASM) | EOS | NEO || WASM |
|:--------------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **Explorer** | :heavy_check_mark: | :heavy_check_mark:| :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | | :o: |
|**Disassembler** | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | | :heavy_check_mark: |
|**Control Flow Analysis** | :heavy_multiplication_x: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | | :heavy_check_mark: |
|**Call Flow Analysis** | :heavy_multiplication_x: | :heavy_plus_sign: | :heavy_check_mark: | :heavy_check_mark: | :heavy_plus_sign: | | :heavy_check_mark: |
|**IR conversion (SSA)** | :heavy_multiplication_x: | :heavy_check_mark: | :heavy_plus_sign: | :heavy_plus_sign: | :heavy_multiplication_x: | | :heavy_check_mark: |
|**Symbolic Execution** | :heavy_multiplication_x: | :heavy_plus_sign: | :heavy_plus_sign: | :heavy_plus_sign: | :heavy_multiplication_x: | | :heavy_plus_sign: |

* PyPI package :heavy_check_mark:
* Docker :heavy_check_mark:

:heavy_check_mark: **DONE** / :heavy_plus_sign: **WIP** / :heavy_multiplication_x: **TODO** / :o: **N/A**

## Requirements

Octopus is supported on Linux (ideally Ubuntu 16.04) and requires Python >=3.5 (ideally 3.6).

Dependencies:
* Graph generation: [graphviz](https://graphviz.gitlab.io/download/)
* Explorer: [requests](http://docs.python-requests.org/en/master/#)
* Symbolic Execution: [z3-solver](https://pypi.org/project/z3-solver/)
* Wasm: [wasm](https://github.com/athre0z/wasm)

## Quick Start

- Install system dependencies
```
# Install system dependencies
sudo apt-get update && sudo apt-get install python-pip graphviz xdg-utils -y
```

- Install Octopus:
```
# Download Octopus
git clone https://github.com/quoscient/octopus
cd octopus

# Install Octopus library/CLI and its dependencies
python3 setup.py install
```
or
```
# but prefer the first way to install if possible
pip3 install octopus
```

- Run tests
```
# Run tests for all platforms (disassembly, CFG, ...)
./run_tests.sh
# Run tests that require internet access (explorer tests)
./run_explorer_tests.sh

# Run tests for only one platforms
# {btc, eth, eos, neo, wasm}_run_tests.sh
cd octopus/tests/
./wasm_run_tests.sh
```

#### Docker container

A docker container providing the toolset is available at [docker hub](https://hub.docker.com/r/smartbugs/octopus). 
In a terminal, run the following commands:

```
docker pull smartbugs/octopus
docker run -it smartbugs/octopus
cd octopus
python3 octopus_eth_evm.py -s -f examples/ETH/evm_bytecode/61EDCDf5bb737ADffE5043706e7C5bb1f1a56eEA.bytecode
```

## Command-line tools

* WebAssembly: [octopus_wasm.py](octopus_wasm.py)
* Ethereum (EVM): [octopus_eth_evm.py](octopus_eth_evm.py)

## In-depth Examples using APIs

<details><summary>WebAssembly</summary>
<p>

#### Disassembler

Disassembly of a Wasm module:
```python
from octopus.arch.wasm.disassembler import WasmDisassembler

FILE = "examples/wasm/samples/helloworld.wasm"

with open(FILE, 'rb') as f:
    module_bytecode = f.read()

disasm = WasmDisassembler()
# return list of functions instructions (list)
print(disasm.disassemble_module(module_bytecode))
#[[<octopus.arch.wasm.instruction.WasmInstruction at 0x7f85e4904278>,<octopus.arch.wasm.instruction.WasmInstruction at 0x7f85e4904f60>,<octopus.arch.wasm.instruction.WasmInstruction at 0x7f85e4904ef0>]]

print()
# return text of functions code
print(disasm.disassemble_module(module_bytecode, r_format='text'))
# func 0
# i32.const 0
# call 0
# end
```

Disassembly of wasm bytecode:
```python
from octopus.arch.wasm.disassembler import WasmDisassembler

# bytecode in WebAssembly is the function code (i.e. function body)
bytecode = b'\x02\x7fA\x18\x10\x1cA\x00\x0f\x0b'
# create a WasmDisassembler object
disasm = WasmDisassembler(bytecode)

# disassemble bytecode into a list of WasmInstruction
# attributes r_format='list' by default
print(disasm.disassemble())

#[<octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904eb8>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904278>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904390>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904ef0>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904f60>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4901048>]
print()
print(disasm.disassemble(r_format='reverse'))

#{0: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4901048>, 1: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904240>, 2: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904f60>, 3: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904ef0>, 4: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904278>, 5: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904390>}
print()
print(disasm.disassemble(r_format='text'))
# block -1
# i32.const 24
# call 28
# i32.const 0
# return
# end
```

#### ModuleAnalyzer

```python
from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

FILE = "examples/wasm/samples/hello_wasm_studio.wasm"

with open(FILE, 'rb') as f:
    module_bytecode = f.read()

# return list of functions instructions (list)
# attributes analysis=True by default
analyzer = WasmModuleAnalyzer(module_bytecode)

# show analyzer attributes
print(analyzer.func_prototypes)
# [('putc_js', 'i32', ''),
#  ('__syscall0', 'i32', 'i32'),
#  ('__syscall3', 'i32 i32 i32 i32', 'i32'),
#  ('__syscall1', 'i32 i32', 'i32'),
#  ('__syscall5', 'i32 i32 i32 i32 i32 i32', 'i32'),
#  ('__syscall4', 'i32 i32 i32 i32 i32', 'i32'),
#  ('$func6', '', ''),
#  ('main', '', 'i32'),
#  ('writev_c', 'i32 i32 i32', 'i32'),
#  ('$func9', '', 'i32'),
#  ('$func10', 'i32', 'i32'),
#  ('$func11', 'i32', 'i32'),
#  ('$func12', 'i32', ''),
#  ('$func13', 'i32', 'i32'),
#  ('$func14', 'i32 i32 i32 i32', 'i32'),
#  ('$func15', 'i32 i32', 'i32'),
#  ('$func16', 'i32 i32', 'i32'),
#  ('$func17', 'i32', 'i32'),
#  ('$func18', 'i32', 'i32'),
#  ('$func19', 'i32', 'i32'),
#  ('$func20', 'i32 i32 i32', 'i32'),
#  ('$func21', 'i32 i32 i32', 'i32'),
#  ('$func22', 'i32 i64 i32', 'i64'),
#  ('$func23', 'i32 i32 i32', 'i32'),
#  ('$func24', 'i32', 'i32'),
#  ('$func25', 'i32 i32 i32 i32', '')]
print()
print(analyzer.contains_emscripten_syscalls())
#[('__syscall0', 'restart_syscall'),
# ('__syscall3', 'read'),
# ('__syscall1', 'exit'),
# ('__syscall5', 'open'),
# ('__syscall4', 'write')]
```

#### Control Flow Analysis

```python
from octopus.arch.wasm.cfg import WasmCFG

# complete wasm module
file_name = "examples/wasm/samples/fib.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = WasmCFG(raw)

# visualize CFGGraph 
# generate graph.dot and graph.pdf file
cfg.visualize()
```

<p align="center">
    <img src="/images/wasm-cfg-fib.png" height="400px"/>
</p>

#### Functions' instructions analytics

```python
from octopus.arch.wasm.cfg import WasmCFG

# complete wasm module
file_name = "examples/wasm/samples/hello_wasm_studio.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = WasmCFG(raw)

# visualization
cfg.visualize_instrs_per_funcs()
```

<p align="center">
    <img src="/images/wasm-instr-func-analytics.png" height="400px"/>
</p>

#### Call Flow Analysis

```python
from octopus.arch.wasm.cfg import WasmCFG

# fibonacci wasm module
file_name = "examples/wasm/samples/hello_wasm_studio.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = WasmCFG(raw)

# visualize Call Flow Graph
# generate call_graph.dot and call_graph.pdf file
# 
# color similar to https://webassembly.studio/
# imported func == turquoise / exported func == grey
# edge label = number of different calls to the function
cfg.visualize_call_flow()
```

<p align="center">
    <img src="/images/wasm-callflow-hello-studio.png" height="400px"/>
</p>

Legend:  

<p align="center">
    <img src="/images/legend_callgraph.png" height="400px"/>
</p>

#### IR conversion (SSA)

```python
from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine

# complete wasm module
file_name = "examples/wasm/samples/fib.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# run the emulator for SSA
emul = WasmSSAEmulatorEngine(raw)
emul.emulate_one_function('fib')
# or emul.emulate_functions(['fib'])
# or emul.emulate_functions() # emulate all the function

# visualization of the cfg with SSA
emul.cfg.visualize(ssa=True)
```

<p align="center">
    <img src="/images/ssa-cfg-fib-wasm.png" height="400px"/>
</p>

</p>
</details>

<details><summary>Ethereum (ETH) - EVM</summary>
<p>

#### Explorer

```python
from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
from octopus.platforms.ETH.explorer import INFURA_ROPSTEN

KEY_API = "bHuaQhX91nkQBac8Wtgj"
# connection to ROPSTEN network (testnet)
explorer = EthereumInfuraExplorer(KEY_API, network=INFURA_ROPSTEN)

# connection to MAINNET network (mainnet)
# explorer = EthereumInfuraExplorer(KEY_API)

# Test ROPSTEN network current block number
block_number = explorer.eth_blockNumber()
print(block_number)
# 3675552

# Retrieve code of this smart contract
addr = "0x3c6B10a5239B1a8A27398583F49771485382818F"
code = explorer.eth_getCode(addr)
print(code)
# 0x6060604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c14606e575b600080fd5b3415605857600080fd5b606c60048080359060200190919050506094565b005b3415607857600080fd5b607e609e565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820e1f98c821c12eea52047d7324b034ddccc41eaa7365d369b34580ab73c71a8940029
```

#### Disassembler

```python
from octopus.platforms.ETH.disassembler import EthereumDisassembler

# smart contract bytecode
bytecode_hex = "60606040526000357c0100000000000000000000000000000000000000000000000000000000900480635fd8c7101461004f578063c0e317fb1461005e578063f8b2cb4f1461006d5761004d565b005b61005c6004805050610099565b005b61006b600480505061013e565b005b610083600480803590602001909190505061017d565b6040518082815260200191505060405180910390f35b3373ffffffffffffffffffffffffffffffffffffffff16611111600060005060003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054604051809050600060405180830381858888f19350505050151561010657610002565b6000600060005060003373ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819055505b565b34600060005060003373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828282505401925050819055505b565b6000600060005060008373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505490506101b6565b91905056"

disasm = EthereumDisassembler()
disasm.disassemble(bytecode_hex)

# disassemble bytecode into a list of EthereumInstruction
# attributes r_format='list' by default
print(disasm.disassemble(bytecode_hex))

#[<octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4add5c0>, <octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4ad8588>, <octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4ad8c50>]

print()
print(disasm.disassemble(bytecode_hex, r_format='reverse'))

# {0: <octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4ad8160>, ..., 229: <octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4ad8630>, 230: <octopus.platforms.ETH.instruction.EthereumInstruction object at 0x7f85d4ad87b8>}

print()
print(disasm.disassemble(bytecode_hex,r_format='text'))
# PUSH1 0x60
# PUSH1 0x40
# MSTORE
# PUSH1 0x0
# CALLDATALOAD
# PUSH29 0x100000000000000000000000000000000000000000000000000000000
# SWAP1
# DIV
# DUP1
# PUSH4 0x5fd8c710
# EQ
# PUSH2 0x4f
# JUMPI
# ...
# SWAP2
# SWAP1
# POP
# JUMP
```

#### Control Flow Analysis

```python
from octopus.analysis.graph import CFGGraph
from octopus.platforms.ETH.cfg import EthereumCFG

# ethernaut0 bytecode
file_name = "examples/ETH/evm_bytecode/Zeppelin_Hello_ethernaut0.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex)

# generic visualization api
# generate graph.dot and graph.pdf file
graph = CFGGraph(cfg)
graph.view()
# or directly using the cfg binding
# cfg.visualize()
# and you can get a simplify cfg representation using
# cfg.visualize(simplify=True) or graph.view(simplify=True)
```

<p align="center">
    <img src="/images/eth-cfg-evm.png"/>
</p>

#### IR conversion (SSA)

```python
# The conversion to SSA is already done by the SSAEmulator
# when the CFG is reconstruct
# by default you have just to visualize it
from octopus.platforms.ETH.cfg import EthereumCFG

# ethernaut0 bytecode
file_name = "examples/ETH/evm_bytecode/Zeppelin_Hello_ethernaut0.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex)

# SSA visualization
cfg.visualize(ssa=True)
```

<p align="center">
    <img src="/images/eth-cfg-evm-ssa.png"/>
</p>

</p>
</details>

<details><summary>Ethereum (WASM)</summary>
<p>

#### Explorer

```python
from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
from octopus.platforms.ETH.explorer import INFURA_KOVAN

# connection to ROPSTEN network (testnet)
explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj",
                                  network=INFURA_KOVAN)
# connection to MAINNET network (mainnet)
# explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj")

# test infura access
block_number = explorer.eth_blockNumber()
print('blockNumber = %d' % block_number)

# retrieve code of this smart contract
addr = "0x1120e596b173d953ba52ce262f73ce3734b0e40e"
code = explorer.eth_getCode(addr)
print()
print(code)
# blockNumber = 8803487
# 
# 0x0061736d0100000001090260000060027f7f00021a0203656e7603726574000103656e76066d656d6f7279020102100303020000040501700101010501000601000708010463616c6c00010a120205001002000b0a00418008410b1000000b0b1201004180080b0b48656c6c6f20776f726c64000b076c696e6b696e6703010b0066046e616d65015f060003726574010570616e6963020463616c6c032f5f5a4e3134707761736d5f657468657265756d3365787433726574313768363034643830393864313638366338304504066465706c6f790511727573745f626567696e5f756e77696e64
```

#### Disassembler

Disassembly of a Wasm module:
```python
from octopus.platforms.ETH.disassembler import EthereumDisassembler

FILE = "examples/ETH/wasm/helloworld_kovan.bytecode"

with open(FILE, 'r') as f:
    module_bytecode = f.read()

disasm = EthereumDisassembler(arch='wasm')
# return list of functions instructions (list)
print(disasm.disassemble_module(module_bytecode))
#[[<octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa898>], [<octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa7b8>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa780>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa748>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa6d8>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7efc0ceaa710>]]

print()
# return text of functions code
print(disasm.disassemble_module(module_bytecode, r_format='text'))
# func 0
# end
# 
# func 1
# call 1
# i32.const 1036
# i32.const 232
# call 0
# end

```

Disassembly of wasm bytecode:
```python
from octopus.platforms.ETH.disassembler import EthereumDisassembler

# bytecode in WebAssembly is the function code (i.e. function body)
bytecode = b'\x02\x7fA\x18\x10\x1cA\x00\x0f\x0b'
# create a WasmDisassembler object
disasm = EthereumDisassembler(bytecode, arch='wasm')

# disassemble bytecode into a list of WasmInstruction
# attributes r_format='list' by default
print(disasm.disassemble())

#[<octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904eb8>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904278>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904390>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904ef0>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904f60>, <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4901048>]
print()
print(disasm.disassemble(r_format='reverse'))

#{0: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4901048>, 1: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904240>, 2: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904f60>, 3: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904ef0>, 4: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904278>, 5: <octopus.arch.wasm.instruction.WasmInstruction object at 0x7f85e4904390>}
print()
print(disasm.disassemble(r_format='text'))
# block -1
# i32.const 24
# call 28
# i32.const 0
# return
# end
```

#### ModuleAnalyzer

```python
from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

FILE = "examples/ETH/wasm/helloworld_kovan.bytecode"

with open(FILE, 'r') as f:
    module_bytecode = f.read()

# return list of functions instructions (list)
# attributes analysis=True by default
analyzer = WasmModuleAnalyzer(module_bytecode)

# show analyzer attributes
print(analyzer.func_prototypes)
# [('ret', 'i32 i32', '', 'import'), ('$func1', '', '', 'local'), ('call', '', '', 'export')]
print()
print(analyzer.exports)
# [{'field_str': 'call', 'kind': 0, 'index': 2}]
print()
print(analyzer.imports_func)
# [('env', 'ret', 1)]
print()
print(analyzer.datas)
# [{'data': b'Hello world', 'index': 0, 'offset': None, 'size': 11},
# {'data': b'\x00asm\x01\x00\x00\x00\x01\t\x02`\x00\x00`\x02\x7f\x7f\x00\x02\x1a\x02\x03env\x03ret\x00\x01\x03env\x06memory\x02\x01\x02\x10\x03\x03\x02\x00\x00\x04\x05\x01p\x01\x01\x01\x05\x01\x00\x06\x01\x00\x07\x08\x01\x04call\x00\x01\n\x12\x02\x05\x00\x10\x02\x00\x0b\n\x00A\x80\x08A\x0b\x10\x00\x00\x0b\x0b\x12\x01\x00A\x80\x08\x0b\x0bHello world\x00\x0b\x07linking\x03\x01\x0b\x00f\x04name\x01_\x06\x00\x03ret\x01\x05panic\x02\x04call\x03/_ZN14pwasm_ethereum3ext3ret17h604d8098d1686c80E\x04\x06deploy\x05\x11rust_begin_unwind',
# 'index': 0,
# 'offset': None,
# 'size': 232}]

```

#### Control Flow Analysis

```python
from octopus.platforms.ETH.cfg import EthereumCFG

# HelloWorld on Kovan Parity Network
file_name = "examples/ETH/wasm/helloworld_kovan.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex, arch='wasm')
cfg.visualize()
```

<p align="center">
    <img src="/images/eth-wasm-cfg-hello-parity.png" height="400px"/>
</p>

#### Functions' instructions analytics

```python
from octopus.platforms.ETH.cfg import EthereumCFG

# HelloWorld on Kovan Parity Network
file_name = "examples/ETH/wasm/helloworld_kovan.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex, arch='wasm')

# visualization
cfg.visualize_instrs_per_funcs()
```

<p align="center">
    <img src="/images/eth-wasm-func-analytics.png" height="400px"/>
</p>

#### Call Flow Analysis

```python
from octopus.platforms.ETH.cfg import EthereumCFG

# HelloWorld on Kovan Parity Network
file_name = "examples/ETH/wasm/helloworld_kovan.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex, arch='wasm')

# visualization
cfg.visualize_call_flow()
```

<p align="center">
    <img src="/images/eth-wasm-callflow-hello-parity.png" height="400px"/>
</p>

Legend:  

<p align="center">
    <img src="/images/legend_callgraph.png" height="400px"/>
</p>

#### IR conversion (SSA)

```python
# TODO
```

</p>
</details>

<details><summary>NEO</summary>
<p>

#### Explorer

```python
from octopus.platforms.NEO.explorer import NeoExplorerRPC

# get list nodes here: http://monitor.cityofzion.io/
explorer = NeoExplorerRPC(host='seed2.neo.org')

# get current number of block on the blockchain
print(explorer.getblockcount())
# 2534868

# get information on a contract
# lock smart contract address: d3cce84d0800172d09c88ccad61130611bd047a4
contract = explorer.getcontractstate("d3cce84d0800172d09c88ccad61130611bd047a4")
print(contract)
# {'author': 'Erik Zhang',
# 'code_version': '2.0',
# 'description': 'Lock 2.0',
# 'email': 'erik@neo.org',
# 'hash': '0xd3cce84d0800172d09c88ccad61130611bd047a4',
# 'name': 'Lock',
# 'parameters': ['Integer', 'PublicKey', 'Signature'],
# 'properties': {'dynamic_invoke': False, 'storage': False},
# 'returntype': 'Boolean',
# 'script': '56c56b6c766b00527ac46c766b51527ac46c766b52527ac4616168184e656f2e426c6f636b636861696e2e4765744865696768746168184e656f2e426c6f636b636861696e2e4765744865616465726c766b53527ac46c766b00c36c766b53c36168174e656f2e4865616465722e47657454696d657374616d70a06c766b54527ac46c766b54c3640e00006c766b55527ac4621a006c766b51c36c766b52c3617cac6c766b55527ac46203006c766b55c3616c7566',
# 'version': 0}

# smart contract code in contract['script']
print(contract['script'])
```

#### Disassembler

```python
from octopus.platforms.NEO.disassembler import NeoDisassembler

# lock contract
file_name = "examples/NEO/samples/Lock.bytecode"

# read file
with open(file_name) as f:
    bytecode = f.read()

disasm = NeoDisassembler()

print(disasm.disassemble(bytecode, r_format='text'))
# PUSH6
# NEWARRAY
# TOALTSTACK
# FROMALTSTACK
# DUP
# TOALTSTACK
# PUSH0
# PUSH2
# ROLL
# SETITEM
# FROMALTSTACK
# ....
# PICKITEM
# NOP
# FROMALTSTACK
# DROP
# RET
```

#### Control Flow Analysis

```python
from octopus.analysis.graph import CFGGraph
from octopus.platforms.NEO.cfg import NeoCFG

# lock contract
file_name = "examples/NEO/samples/Lock.bytecode"

# read file
with open(file_name) as f:
    raw = f.read()

# create neo cfg - automatic static analysis
cfg = NeoCFG(raw)

# graph visualization
graph = CFGGraph(cfg, filename="Lock_cfg")
graph.view_functions()
```

<p align="center">
    <img src="/images/neo-cfg.png"/>
</p>

</p>
</details>

<details><summary>EOS</summary>
<p>

#### Explorer

```python
from octopus.platforms.EOS.explorer import EosExplorer

host = "api.cypherglass.com"

# by defaul the port is 8888
explo = EosExplorer(host=host)

# get info about the node
explo.get_info()

'''
{'block_cpu_limit': 180289,
 'block_net_limit': 1045680,
 'chain_id': 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
 'head_block_id': '018d6e2bcf6295126cd74cf694b5cca3529eefc42b334b394ef87c3a43876739',
 'head_block_num': 26045995,
 'head_block_producer': 'eosswedenorg',
 'head_block_time': '2018-11-09T14:11:29.500',
 'last_irreversible_block_id': '018d6cdcff78bbd9f25c605b02fb67c47a337ece78ddcf73089cee4bf6a410ee',
 'last_irreversible_block_num': 26045660,
 'server_version': 'c71d2245',
 'server_version_string': 'mainnet-1.3.0',
 'virtual_block_cpu_limit': 38092879,
 'virtual_block_net_limit': 1048576000}
'''
explo.get_block(1337)

'''
{'action_mroot': 'bcb9763baa3bbf98ed36379b4be0ecb2d9cd21c75df01729c63b2b021001c10c',
 'block_extensions': [],
 'block_num': 1337,
 'confirmed': 0,
 'header_extensions': [],
 'id': '00000539d17a03af7126e073be4c4d99a72b7f58793cf2c87b9bfd41b6c711fb',
 'new_producers': None,
 'previous': '00000538b374c1cbfaeed7253ad3075ddc72a28f0a0515301fc1bbed675f2316',
 'producer': 'eosio',
 'producer_signature': 'SIG_K1_K5jWf36t6j454Hb2fGuV37YTwMTvuQ51ZPBtpru8Ud2axtMTEauWyvtpJuTpnvqzReUndDgEDXvoeEP4jdj2bpnYKBt6g2',
 'ref_block_prefix': 1944069745,
 'schedule_version': 0,
 'timestamp': '2018-06-09T12:09:21.500',
 'transaction_mroot': '0000000000000000000000000000000000000000000000000000000000000000',
 'transactions': []}
'''
```

#### Disassembler

```python
from octopus.platforms.EOS.disassembler import EosDisassembler

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# just disassembly
disasm = EosDisassembler()

# because we provide full module bytecode
# we need to use disassemble_module()
# otherwise just disassemble() is enough
text = disasm.disassemble_module(raw, r_format="text")
print(text)
# func 0
# get_local 0
# get_local 1
# i32.const 32
# call 12
# i32.eqz
# end
# 
# func 1
# get_local 0
# i64.load 3, 0
# get_local 0
# i64.load 3, 8
# call 6
# end
# 
# func 2
# ...
# end
# 
# ...
```

#### ModuleAnalyzer

```python

from octopus.platforms.EOS.analyzer import EosAnalyzer

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

with open(file_name, 'rb') as f:
    module_bytecode = f.read()

# return list of functions instructions (list)
# attributes analysis=True by default
analyzer = EosAnalyzer(module_bytecode)

# show analyzer attributes
print(analyzer.func_prototypes)
#[('action_data_size', '', 'i32', 'import'), ('eosio_assert', 'i32 i32', '', 'import'), ('eosio_exit', 'i32', '', 'import'), ('memcpy', 'i32 i32 i32', 'i32', 'import'), ('prints', 'i32', '', 'import'), ('read_action_data', 'i32 i32', 'i32', 'import'), ('require_auth2', 'i64 i64', '', 'import'), ('_ZeqRK11checksum256S1_', 'i32 i32', 'i32', 'export'), ('_ZN5eosio12require_authERKNS_16permission_levelE', 'i32', '', 'export'), ('apply', 'i64 i64 i64', '', 'export'), ('$func10', 'i32 i64', '', 'local'), ('$func11', 'i32 i32', 'i32', 'local'), ('memcmp', 'i32 i32 i32', 'i32', 'export'), ('malloc', 'i32', 'i32', 'export'), ('$func14', 'i32 i32', 'i32', 'local'), ('$func15', 'i32', 'i32', 'local'), ('free', 'i32', '', 'export'), ('$func17', '', '', 'local')]
print()
print(analyzer.exports)
# [{'field_str': 'memory', 'kind': 2, 'index': 0}, {'field_str': '_ZeqRK11checksum256S1_', 'kind': 0, 'index': 7}, {'field_str': '_ZN5eosio12require_authERKNS_16permission_levelE', 'kind': 0, 'index': 8}, {'field_str': 'apply', 'kind': 0, 'index': 9}, {'field_str': 'memcmp', 'kind': 0, 'index': 12}, {'field_str': 'malloc', 'kind': 0, 'index': 13}, {'field_str': 'free', 'kind': 0, 'index': 16}]
print()
print(analyzer.imports_func)
# [('env', 'action_data_size', 3), ('env', 'eosio_assert', 5), ('env', 'eosio_exit', 2), ('env', 'memcpy', 6), ('env', 'prints', 2), ('env', 'read_action_data', 4), ('env', 'require_auth2', 1)]
```

#### Control Flow Analysis

```python
from octopus.platforms.EOS.cfg import EosCFG
from octopus.analysis.graph import CFGGraph

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualize
graph = CFGGraph(cfg)
graph.view_functions()
```

<p align="center">
    <img src="/images/eos-cfg.png"/>
</p>

#### Call Flow Analysis

```python
from octopus.platforms.EOS.cfg import EosCFG

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualize
cfg.visualize_call_flow()
```

<p align="center">
    <img src="/images/eos-callgraph.png"/>
</p>

#### Functions' instructions analytics

```python
from octopus.platforms.EOS.cfg import EosCFG

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualize
cfg.visualize_instrs_per_funcs()
```

<p align="center">
    <img src="/images/eos-func-instrucs.png"/>
</p>

</p>
</details>

<details><summary>Bitcoin</summary>
<p>

#### Explorer

```python
from octopus.platforms.BTC.explorer import BitcoinExplorerRPC

RPC_USER = 'test'
RPC_PASSWORD = 'test'
RPC_HOST = 'localhost'

host = '%s:%s@%s' % (RPC_USER, RPC_PASSWORD, RPC_HOST)

explorer = BitcoinExplorerRPC(host)

explorer.getbestblockhash()
# '00000000000000000012085cfe8c79bcdacf81fbd82f6ab52c3cb3a454d4987c'

explorer.getblockcount()
#550859
```

#### Disassembler

```python
from octopus.platforms.BTC.disassembler import BitcoinDisassembler

# Witness Script
file_name = "examples/BTC/witness_script.hex"

# read file
with open(file_name) as f:
    bytecode = f.read()

disasm = BitcoinDisassembler()

print(disasm.disassemble(bytecode, r_format='text'))
# 0
# OP_ROT
# OP_ROT
# 2
# 0203f4d01d0b35588638631ebb7d46d8387fd1aeb3dbecfdd3faf7c056b023c833
# 03aa6677e3ce1bd634f4f2e1cd60a60af002e1b30484d4d1611b183b16d391ee96
# 03bf164811abb8c91ed39e58d4e307f86cb4e487c83f727a2c482bc71a0f96f1db
# 3
# OP_CHECKMULTISIG
```

</p>
</details>

Please find examples in [examples](examples) folder.

## Publications and Videos

* BLACKALPS 2018 [Reversing and Vulnerability research of Ethereum Smart Contracts](https://www.blackalps.ch/ba-18/talks.php#111)
* Devcon iv. [Reversing Ethereum Smart Contracts to find out what's behind EVM bytecode](https://guidebook.com/guide/117233/event/21956134/)
* hack.lu 2018 [Reversing and Vulnerability research of Ethereum Smart Contracts](https://2018.hack.lu/talks/#Reversing+and+Vulnerability+research+of+Ethereum+Smart+Contracts)
* ToorCon XX - 2018 [Reversing Ethereum Smart Contracts (Introduction)](https://frab.toorcon.net/en/toorcon20/public/events/97)
* ToorCon XX - 2018 [Dissection of WebAssembly module](https://frab.toorcon.net/en/toorcon20/public/events/92)
* REcon Montreal 2018: [Reverse Engineering Of Blockchain Smart Contracts](https://recon.cx/2018/montreal/schedule/system/event_attachments/attachments/000/000/053/original/RECON-MTL-2018-Reversing_blockchains_smart_contracts.pdf)

## Authors

**Patrick Ventuzelo** - *Creator* - [@Pat_Ventuzelo](https://twitter.com/pat_ventuzelo)

See also the list of [contributors](https://github.com/quoscient/octopus/contributors) who participated in this project.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details

## Acknowledgments

Sponsor:
* [QuoScient](https://www.quoscient.io/)

Inspired by:
* [Manticore](https://github.com/trailofbits/manticore)
* [Mythril](https://github.com/ConsenSys/mythril)
* [Rattle](https://github.com/trailofbits/rattle)
* [ethersplay](https://github.com/trailofbits/ethersplay)
* ...

# Trainings & Contact

Patrick Ventuzelo - [@pat_ventuzelo](https://twitter.com/pat_ventuzelo) - Independent Security Researcher.

More details about my trainings:
* 4-days **WebAssembly security** training: [here](https://webassembly-security.com/trainings/)
* 2-days **Rustlang security** training: [here](https://webassembly-security.com/rust-security-training/)

'''
'''--- examples/BTC/disasm_witness.py ---
from octopus.platforms.BTC.disassembler import BitcoinDisassembler

# Witness Script
file_name = "examples/BTC/witness_script.hex"

# read file
with open(file_name) as f:
    bytecode = f.read()

disasm = BitcoinDisassembler()

print(disasm.disassemble(bytecode, r_format='text'))
'''
'''--- examples/EOS/bytecode_analytic.py ---
#
# Title: Visualization of instructions count
#        per function and group of EOS smart contract
#
# Date: 08/08/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.EOS.cfg import EosCFG

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualization
cfg.visualize_instrs_per_funcs()

'''
'''--- examples/EOS/call_graph_module.py ---
#
# Title: Call graph EOS smart contract (.wasm)
# Date: 07/04/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.EOS.cfg import EosCFG

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualize
cfg.visualize_call_flow()

'''
'''--- examples/EOS/cfg_module.py ---
#
# Title: CFG reconstruction EOS smart contract (.wasm)
# Date: 07/04/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.EOS.cfg import EosCFG
from octopus.analysis.graph import CFGGraph

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = EosCFG(raw)

# visualize
graph = CFGGraph(cfg)
graph.view_functions()

'''
'''--- examples/EOS/disasm_module.py ---
#
# Title: Disassemble EOS smart contract (.wasm)
# Date: 06/29/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.EOS.disassembler import EosDisassembler

# complete wasm module
file_name = "examples/EOS/samples/eos_ping.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# just disassembly
disasm = EosDisassembler()

# because we provide full module bytecode
# we need to use disassemble_module()
# otherwise just disassemble() is enough
text = disasm.disassemble_module(raw, r_format="text")
print(text)

'''
'''--- examples/EOS/source/eos_ping.cpp ---
/* source: https://github.com/tylerdiaz/ping-eos
**
** compile to wast with: 	eosiocpp -o ping.wast ping.cpp
** generate ABI with: 		eosiocpp -g ping.abi ping.cpp
*/

#include <eosiolib/eosio.hpp>
#include <eosiolib/print.hpp>

class ping_contract : public eosio::contract {
  public:
      using eosio::contract::contract;
      void ping(account_name receiver) {
         eosio::print("Pong");
      }
};

EOSIO_ABI( ping_contract, (ping) )

'''
'''--- examples/ETH/evm_cfg_ethernaut0.py ---
#
# Title: CFG reconstruction of ETH smart contract (evm)
# Date: 06/29/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.analysis.graph import CFGGraph
from octopus.platforms.ETH.cfg import EthereumCFG

# ethernaut0 bytecode
file_name = "examples/ETH/evm_bytecode/Zeppelin_Hello_ethernaut0.bytecode"

# read file
with open(file_name) as f:
    bytecode_hex = f.read()

# create the CFG
cfg = EthereumCFG(bytecode_hex)

# generic visualization api
graph = CFGGraph(cfg)
graph.view()

'''
'''--- examples/ETH/evm_explorer_infura.py ---
#
# Title: Retreive smart contract code using InfuraExplorer
# Date: 06/29/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
from octopus.platforms.ETH.explorer import INFURA_ROPSTEN
from octopus.platforms.ETH.contract import EthereumContract

# connection to ROPSTEN network (testnet)
explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj",
                                  network=INFURA_ROPSTEN)
# connection to MAINNET network (mainnet)
# explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj")

# test infura access
block_number = explorer.eth_blockNumber()
print('blockNumber = %d' % block_number)

# retrieve code of this smart contract
addr = "0x3c6B10a5239B1a8A27398583F49771485382818F"
code = explorer.eth_getCode(addr)
print('code = %s' % code)

# equivalent using contract class
# get_online_bytecode used eth_getCode
contract = EthereumContract(address=addr)
contract.get_online_bytecode(explorer)
code2 = contract.bytecode
print('code2 = %s' % code2)

# same value?
print()
print('code == code2: %s' % (str(code) == str(code2)))

'''
'''--- examples/ETH/wasm_getcode_infura_kovan.py ---
#
# Title: Retrieve ETHereum wasm smart contract bytecode
#        using InfuraExplorer on KOVAN network
# Date: 07/24/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
from octopus.platforms.ETH.explorer import INFURA_KOVAN

# connection to ROPSTEN network (testnet)
explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj",
                                  network=INFURA_KOVAN)
# connection to MAINNET network (mainnet)
# explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj")

# test infura access
block_number = explorer.eth_blockNumber()
print('blockNumber = %d' % block_number)

# retrieve code of this smart contract
addr = "0x1120e596b173d953ba52ce262f73ce3734b0e40e"
code = explorer.eth_getCode(addr)
print()
print(code)

'''
'''--- examples/NEO/cfg_lock.py ---
#
# Title: CFG reconstruction of Neo smart contract (.avm)
# Date: 06/13/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.analysis.graph import CFGGraph
from octopus.platforms.NEO.cfg import NeoCFG

# lock contract
file_name = "examples/NEO/samples/Lock.bytecode"

# read file
with open(file_name) as f:
    raw = f.read()

# create neo cfg - automatic static analysis
cfg = NeoCFG(raw)

# graph visualization
graph = CFGGraph(cfg, filename="Lock_cfg")
graph.view_functions()

'''
'''--- examples/NEO/disasm_lock.py ---
from octopus.platforms.NEO.disassembler import NeoDisassembler

# lock contract
file_name = "examples/NEO/samples/Lock.bytecode"

# read file
with open(file_name) as f:
    bytecode = f.read()

disasm = NeoDisassembler()

print(disasm.disassemble(bytecode, r_format='text'))
# PUSH6
# NEWARRAY
# TOALTSTACK
# FROMALTSTACK
# DUP
# TOALTSTACK
# PUSH0
# PUSH2
# ROLL
# SETITEM
# FROMALTSTACK
# ....
# PICKITEM
# NOP
# FROMALTSTACK
# DROP
# RET

'''
'''--- examples/NEO/explorer_get_code_lock.py ---
from octopus.platforms.NEO.explorer import NeoExplorerRPC

# get list nodes here: http://monitor.cityofzion.io/
explorer = NeoExplorerRPC(host='pyrpc1.nodeneo.ch')

# get current number of block on the blockchain
print(explorer.getblockcount())
# 2534868

# get information on a contract
# lock smart contract address: d3cce84d0800172d09c88ccad61130611bd047a4
print(explorer.getcontractstate("d3cce84d0800172d09c88ccad61130611bd047a4"))
# {'author': 'Erik Zhang',
# 'code_version': '2.0',
# 'description': 'Lock 2.0',
# 'email': 'erik@neo.org',
# 'hash': '0xd3cce84d0800172d09c88ccad61130611bd047a4',
# 'name': 'Lock',
# 'parameters': ['Integer', 'PublicKey', 'Signature'],
# 'properties': {'dynamic_invoke': False, 'storage': False},
# 'returntype': 'Boolean',
# 'script': '56c56b6c766b00527ac46c766b51527ac46c766b52527ac4616168184e656f2e426c6f636b636861696e2e4765744865696768746168184e656f2e426c6f636b636861696e2e4765744865616465726c766b53527ac46c766b00c36c766b53c36168174e656f2e4865616465722e47657454696d657374616d70a06c766b54527ac46c766b54c3640e00006c766b55527ac4621a006c766b51c36c766b52c3617cac6c766b55527ac46203006c766b55c3616c7566',
# 'version': 0}
'''
'''--- examples/wasm/bytecode_analytic.py ---
#
# Title: Visualization of instructions count
#        per function and group
#
# Date: 08/08/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.arch.wasm.cfg import WasmCFG

# complete wasm module
file_name = "examples/wasm/samples/hello_wasm_studio.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = WasmCFG(raw)

# visualization
cfg.visualize_instrs_per_funcs()

'''
'''--- examples/wasm/cfg_and_callgraph_fibo.py ---
#
# Title: Call & CFG graph for fibonacci wasm module
# Date: 07/16/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.arch.wasm.cfg import WasmCFG
from octopus.analysis.graph import CFGGraph

# complete wasm module
file_name = "examples/wasm/samples/fib.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the cfg
cfg = WasmCFG(raw)

# visualize CFGGraph
graph = CFGGraph(cfg)
graph.view_functions()

# visualize CallGraph
cfg.visualize_call_flow()

'''
'''--- examples/wasm/ssa_fibo.py ---
from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine

# complete wasm module
file_name = "examples/wasm/samples/fib.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# run the emulator for SSA
emul = WasmSSAEmulatorEngine(raw, 'fib')
emul.emulate()

# visualization of the cfg with SSA
emul.cfg.visualize(ssa=True)

'''
'''--- examples/wasm/wasm_module_analysis.py ---
#
# Title: WebAssembly module analysis
#
# Date: 20/08/18
#
# Author: Patrick Ventuzelo - @Pat_Ventuzelo
#

from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

# complete wasm module
file_name = "examples/wasm/samples/hello_wasm_studio.wasm"

# read file
with open(file_name, 'rb') as f:
    raw = f.read()

# create the WasmModuleAnalyzer
# analysis set to True by default
an = WasmModuleAnalyzer(raw, analysis=True)

print('list functions:')
print(an.func_prototypes)
print()

# detect if wasm module contains emscripten syscalls
print('contains emscripten syscalls ?')
print(an.contains_emscripten_syscalls())

'''
'''--- octopus/__init__.py ---
name = "octopus"
'''
'''--- octopus/analysis/__init__.py ---

'''
'''--- octopus/analysis/cfg.py ---
class CFG(object):

    def __init__(self):
        """ TODO """
        raise NotImplementedError

    def visualize(self):
        """ TODO """
        raise NotImplementedError

    def visualize_call_flow(self):
        """ TODO """
        raise NotImplementedError

    def visualize_instrs_per_funcs(self):
        """ TODO """
        raise NotImplementedError

'''
'''--- octopus/analysis/graph.py ---
from graphviz import Digraph

from octopus.core.edge \
    import (EDGE_UNCONDITIONAL,
            EDGE_CONDITIONAL_TRUE, EDGE_CONDITIONAL_FALSE,
            EDGE_FALLTHROUGH, EDGE_CALL)

def insert_edges_to_graph(graph, edges, call=False):
    # remove duplicate edges
    edges = list(set(edges))

    # create link between block
    for edge in edges:

        if edge.type == EDGE_UNCONDITIONAL:
            graph.edge(edge.node_from, edge.node_to, color='blue')
        elif edge.type == EDGE_CONDITIONAL_TRUE:
            graph.edge(edge.node_from, edge.node_to, color='green')
        elif edge.type == EDGE_CONDITIONAL_FALSE:
            graph.edge(edge.node_from, edge.node_to, color='red')
        elif edge.type == EDGE_FALLTHROUGH:
            graph.edge(edge.node_from, edge.node_to, color='cyan')
        elif edge.type == EDGE_CALL and call:
            graph.edge(edge.node_from, edge.node_to, color='yellow')
        else:
            raise Exception('Edge type unknown')

class Graph(object):

    def __init__(self, basicblocks, edges, functions=None,
                 filename='graph.gv', design=None):
        self.basicblocks = basicblocks
        self.edges = edges
        self.filename = filename
        self.design = design or {'shape': 'box', 'fontname': 'Courier',
                                 'fontsize': '30.0', 'rank': 'same'}

    def view_ssa(self, call=False, view=True):
        self.view(view=view, call=call, ssa=True)

    def view_simplify(self, call=False, view=True):
        self.view(view=view, call=call, simplify=True)

    def view(self, view=True, simplify=False, call=False, ssa=False):
        g = Digraph(self.filename, filename=self.filename)

        with g.subgraph(name='global', node_attr=self.design) as c:
            c.label = 'global'

            # create all the basicblocks (blocks)
            for basicblock in self.basicblocks:
                if simplify:
                    # create node
                    c.node(basicblock.name, label=basicblock.name)
                else:
                    if ssa:
                        label = basicblock.instructions_ssa()
                    else:
                        label = basicblock.instructions_details()
                    # the escape sequences "\n", "\l" and "\r"
                    # divide the label into lines, centered,
                    # left-justified, and right-justified, respectively.
                    label = label.replace('\n', '\l')
                    # create node
                    c.node(basicblock.name, label=label)

        # insert edges on the graph
        insert_edges_to_graph(g, self.edges, call)

        g.render(self.filename, view=view)
        # g.view()

class CallGraph(object):
    def __init__(self, nodes, edges,
                 filename='call_graph.gv', design=None):
        self.nodes = nodes
        self.edges = edges
        self.filename = filename
        self.design = design or {'shape': 'box'}

    def view(self, view=True):
        g = Digraph(self.filename, filename=self.filename,
                    graph_attr=self.design)
        g.attr(rankdir='LR')

        with g.subgraph(name='global', node_attr=self.design) as c:

            # create all the graph nodes (function name)
            for idx, node in enumerate(self.nodes):
                # print('%d %s' % (idx, node))
                c.node(node)

            # check if multiple same edges
            # in that case, put the number into label
            edges_counter = dict((x,self.edges.count(x)) for x in set(self.edges))
            # insert edges on the graph
            for edge, count in edges_counter.items():
                label = None
                if count > 1:
                    label = str(count)
                c.edge(edge.node_from, edge.node_to, label=label, color='black')

        g.render(self.filename, view=view)

class CFGGraph(Graph):

    def __init__(self, cfg, filename='graph.cfg.gv', design=None):
        Graph.__init__(self, cfg.basicblocks, cfg.edges, filename=filename,
                       design=design)
        self.cfg = cfg

    def view_functions_ssa(self, call=False, view=True):
        self.view_functions(view=view, call=call, ssa=True)

    def view_functions_simplify(self, call=False, view=True):
        self.view_functions(view=view, call=call, simplify=True)

    def view_functions(self, only_func_name=None, view=True, simplify=False, call=False, ssa=False, color='grey'):
        g = Digraph('G', filename=self.filename)
        g.attr(rankdir='TB')
        g.attr(overlap='scale')
        g.attr(splines='polyline')
        g.attr(ratio='fill')

        functions = self.cfg.functions
        # only show functions listed
        if only_func_name:
            functions = [func for func in self.cfg.functions if func.name in only_func_name]

        for idx, func in enumerate(functions):
            with g.subgraph(name='cluster_%d' % idx, node_attr=self.design) as c:
                if func.name == func.prefered_name:
                    name = func.name
                else:
                    name = func.prefered_name + ' - ' + func.name
                c.attr(label=name)
                c.attr(color=color)
                c.attr(fontsize='50.0')
                c.attr(overlap='false')
                c.attr(splines='polyline')
                c.attr(ratio='fill')

                # create all the basicblocks (blocks)
                for basicblock in func.basicblocks:
                    if simplify:
                        # create node
                        c.node(basicblock.name, label=basicblock.name, splines='true')
                    else:
                        if ssa:
                            label = basicblock.instructions_ssa()
                        else:
                            label = basicblock.instructions_details()
                        # the escape sequences "\n", "\l" and "\r"
                        # divide the label into lines, centered,
                        # left-justified, and right-justified, respectively.
                        label = label.replace('\n', '\l')
                        # create node
                        c.node(basicblock.name, label=label)

        edges = self.cfg.edges
        # only get corresponding edges
        if only_func_name:
            functions_block = [func.basicblocks for func in functions]
            block_name = [b.name for block_l in functions_block for b in block_l]
            edges = [edge for edge in edges if (edge.node_from in block_name or edge.node_to in block_name)]
        # insert edges on the graph
        insert_edges_to_graph(g, edges, call)

        g.render(self.filename, view=view)
        # g.view()

'''
'''--- octopus/arch/__init__.py ---

'''
'''--- octopus/arch/evm/__init__.py ---

'''
'''--- octopus/arch/evm/cfg.py ---
from octopus.analysis.cfg import CFG
from octopus.analysis.graph import CFGGraph
from octopus.core.function import Function
from octopus.core.basicblock import BasicBlock

from octopus.arch.evm.disassembler import EvmDisassembler

import json
import os

from logging import getLogger
logging = getLogger(__name__)

SIGNATURE_FILE_PATH = '/signatures.json'

def enum_func_static(instructions):

    functions = list()

    # first function is *usually* the function dispatcher
    function = Function(start_offset=0,
                        start_instr=instructions[0],
                        name='Dispatcher',
                        prefered_name='Dispatcher')
    functions.append(function)

    # parse the instructions and create Function object
    for inst in instructions:
        try:
            # PUSH4 are used to push the function signature on the stack
            if inst.name == 'PUSH4':
                index = instructions.index(inst)
                list_inst = instructions[index:index + 4]
                push4, eq, push, jumpi = list_inst[0], list_inst[1], list_inst[2], list_inst[3]

                # check if this basicblock test function signature
                if eq.name == 'EQ' and push.name in ['PUSH1', 'PUSH2'] and jumpi.name == 'JUMPI':
                    xref = int.from_bytes(push.operand, byteorder='big')
                    sign = int.from_bytes(push4.operand, byteorder='big')
                    name = 'func_%x' % sign
                    prefered_name = find_signature(sign)

                    # find instr with offset == xref
                    begin_function = next(filter(lambda i: i.offset == xref, instructions))
                    # create new function
                    function = Function(xref,
                                        start_instr=begin_function,
                                        name=name,
                                        prefered_name=prefered_name)

                    functions.append(function)
        except:
            logging.warning('enum_func_static Exception')
            pass
    return functions

def find_signature(sign):
    path = os.path.dirname(os.path.realpath(__file__)) + SIGNATURE_FILE_PATH
    with open(path) as data_file:
        data = json.load(data_file)

    list_name = [name for name, hexa in data.items() if hexa == str(hex(sign))]

    if len(list_name) > 1:
        logging.warning('function signatures collision: %s', list_name)
        return '_or_'.join(list_name)
    elif list_name:
        return list_name[0]
    else:
        return None

def enum_blocks_static(instructions):

    """
    Return a list of basicblock after
    statically parsing given instructions
    """

    basicblocks = list()
    index = 0

    # create the first block
    new_block = False
    end_block = False
    block = BasicBlock(instructions[0].offset,
                       instructions[0],
                       name='block_%x' % instructions[0].offset)

    for inst in instructions:
        if new_block:
            block = BasicBlock(inst.offset,
                               inst,
                               name='block_%x' % inst.offset)
            new_block = False

        # add current instruction to the basicblock
        block.instructions.append(inst)

        # absolute JUMP
        if inst.is_branch_unconditional:
            new_block = True

        # conditionnal JUMPI
        elif inst.is_branch_conditional:
            new_block = True

        # Halt instruction : RETURN, STOP, ...
        elif inst.is_halt:  # and inst != instructions[-1]:
            new_block = True

        # just falls to the next instruction
        elif inst != instructions[-1] and \
                instructions[index + 1].name == 'JUMPDEST':
            new_block = True

        # last instruction of the entire bytecode
        elif inst == instructions[-1]:
            end_block = True

        if new_block or end_block:
            block.end_offset = inst.offset_end
            block.end_instr = inst
            basicblocks.append(block)
            new_block = True
            end_block = False

        index += 1

    return basicblocks

'''
def enum_calls(instructions):
    for inst in instructions:
        # inst is a call instruction and ssa repr is not null
        if inst.is_call and inst.ssa:
            to_addr = inst.ssa.args[1]
            print('%s to %s' % (inst.name, str(to_addr)))
'''

class EvmCFG(CFG):

    def __init__(self, bytecode=None, analysis='dynamic'):
        """ TODO """

        self.bytecode = bytecode
        self.disasm = EvmDisassembler(self.bytecode)
        self.instructions = self.disasm.disassemble()
        self.analysis = analysis

        self.basicblocks = list()
        self.functions = list()
        self.edges = list()

        if self.analysis == 'dynamic':
            self.run_dynamic_analysis()
        elif self.analysis == 'static':
            self.run_static_analysis()

    def run_static_analysis(self):
        self.functions = enum_func_static(self.instructions)
        self.basicblocks = enum_blocks_static(self.instructions)

    def run_dynamic_analysis(self):

        from octopus.platforms.ETH.emulator import EvmSSAEngine

        emul = EvmSSAEngine(self.bytecode)
        emul.emulate()
        self.functions = emul.functions
        self.basicblocks = emul.basicblocks
        self.edges = emul.edges

    def visualize(self, simplify=False, ssa=False):
        """Visualize the cfg
        used CFGGraph
        equivalent to:
            graph = CFGGraph(cfg)
            graph.view_functions()
        """
        graph = CFGGraph(self)
        graph.view(simplify=simplify, ssa=ssa)

    def __str__(self):
        line = ("length functions = %d\n" % len(self.functions))
        line += ("length basicblocks = %d\n" % len(self.basicblocks))
        line += ("length instructions = %d\n" % len(self.instructions))
        line += ("length edges = %d\n" % len(self.edges))
        return line

'''
'''--- octopus/arch/evm/disassembler.py ---
import io
import logging
import re

from octopus.engine.disassembler import Disassembler

from octopus.arch.evm.instruction import EvmInstruction
from octopus.arch.evm.evm import EVM

class EvmDisassembler(Disassembler):

    def __init__(self, bytecode=None):
        Disassembler.__init__(self, asm=EVM(), bytecode=bytecode)
        self.loader_code = None
        self.swarm_hash = None
        self.constructor_args = None

    def runtime_code_detector(self):
        '''Check for presence of runtime code
        '''
        result = list(re.finditer('60.{2}604052', self.bytecode))
        if len(result) > 1:
            position = result[1].start()
            logging.info("[+] Runtime code detected")
            self.loader_code = self.bytecode[:position]
            self.bytecode = self.bytecode[position:]

    def swarm_hash_detector(self):
        '''Check for presence of Swarm hash at the end of bytecode
            https://github.com/ethereum/wiki/wiki/Swarm-Hash
        '''
        #swarm_hash_off = self.bytecode.find('a165627a7a72.*0029')
        result = list(re.finditer('a165627a7a7230.*0029', self.bytecode))
        # bzzr == 0x65627a7a72

        if len(result) > 0:
            swarm_hash_off = result[-1].start()
            swarm_hash_end = result[-1].end()
            if swarm_hash_off > 0:
                logging.info("[+] Swarm hash detected in bytecode")
                self.swarm_hash = self.bytecode[swarm_hash_off:swarm_hash_end]
                logging.info("[+] Swarm hash value: 0x%s", self.swarm_hash)

                # there is possibly constructor argument
                # if there is swarm storage
                if swarm_hash_end != len(self.bytecode):
                    self.constructor_args = self.bytecode[swarm_hash_end:]
                    logging.info("[+] Constructor arguments detected in bytecode")
                    logging.info("[+] Constructor arguments removed from bytecode")
                logging.info("[+] Swarm hash removed from bytecode")
                self.bytecode = self.bytecode[:swarm_hash_off]

    def analysis(self):
        self.runtime_code_detector()
        self.swarm_hash_detector()

    def disassemble_opcode(self, bytecode, offset=0):
        """
        TODO
        """

        wallet = io.BytesIO(bytecode)
        opcode = int.from_bytes(wallet.read(1), byteorder='big')

        # default value
        invalid = ('INVALID', 0, 0, 0, 0, 'Unknown opcode')
        name, operand_size, pops, pushes, gas, description = \
            self.asm.table.get(opcode, invalid)
        instruction = EvmInstruction(opcode, name, operand_size, pops, pushes,
                                     gas, description, offset=offset)
        if instruction.has_operand:
            instruction.operand = wallet.read(operand_size)
            if instruction.is_push:
                # directly calculate the operand int representation
                instruction.operand_interpretation = \
                    int.from_bytes(instruction.operand, byteorder='big')

        return instruction

    def disassemble(self, bytecode=None, offset=0, r_format='list',
                    analysis=True):
        '''
        creation code remove if analysis param is set to True (default)
        r_format: ('list' | 'text' | 'reverse')
        '''

        self.bytecode = bytecode if bytecode else self.bytecode

        if analysis:
            self.analysis()

        # reset lists
        self.instructions = list()
        self.reverse_instructions = dict()

        # call generic Disassembler.disassemble method
        return super().disassemble(self.bytecode, offset,
                                   r_format)

'''
'''--- octopus/arch/evm/emulator.py ---
from octopus.core.edge import Edge, EDGE_UNCONDITIONAL, EDGE_CONDITIONAL_TRUE, EDGE_CONDITIONAL_FALSE, EDGE_FALLTHROUGH, EDGE_CALL
from octopus.engine.emulator import EmulatorEngine
from octopus.core.ssa import SSA, SSA_TYPE_FUNCTION, SSA_TYPE_CONSTANT

from octopus.arch.evm.vmstate import EvmVMstate
from octopus.arch.evm.cfg import (enum_func_static,
                                  enum_blocks_static)

from octopus.arch.evm.disassembler import EvmDisassembler
from octopus.arch.evm.ssa import EvmSSASimplifier

import copy

from logging import getLogger
logging = getLogger(__name__)

class EvmEmulatorEngine(EmulatorEngine):

    def __init__(self, bytecode, ssa=True, symbolic_exec=False, max_depth=20):

        self.ssa = ssa
        self.symbolic_exec = symbolic_exec

        # retrive instructions, basicblocks & functions statically
        disasm = EvmDisassembler(bytecode)
        self.instructions = disasm.disassemble()
        self.reverse_instructions = {k: v for k, v in enumerate(self.instructions)}
        self.functions = enum_func_static(self.instructions)
        self.basicblocks = enum_blocks_static(self.instructions)

        self.simplify_ssa = EvmSSASimplifier()

        self.functions_start_instr = [f.start_instr for f in self.functions]
        self.current_function = self.functions[0]
        self.basicblock_per_instr = dict()
        self.current_basicblock = None

        # create dict with:
        # * key = instruction offset
        # * value = basicblock reference
        # easy to get the corresponding basicblock per instr now
        for bb in self.basicblocks:
            for intr in bb.instructions:
                self.basicblock_per_instr[intr.offset] = bb

        # connection between basicblocks
        # will be generate dynamically by the Emulator
        self.edges = list()

        self.states = dict()
        self.states_total = 0
        self.max_depth = max_depth
        self.ssa_counter = 0

        logging.info("=======================================")
        logging.info("#      EVM Emulator Engine")
        logging.info("#      class: %s", self.__class__.__name__)
        logging.info("=======================================")
        for f in self.functions:
            logging.info("[+] Functions detected - %x: %s/%s", f.start_offset, f.prefered_name, f.name)

    def emulate(self, state=EvmVMstate(), depth=0):

        #  create fake stack for tests
        state.symbolic_stack = list(range(1000))

        # get current instruction
        instr = self.reverse_instructions[state.pc]

        # create the first basicblock of this branch
        # print('%d : %s' % (instr.offset, instr.name))
        self.current_basicblock = self.basicblock_per_instr[instr.offset]

        # beginning of a function
        if instr in self.functions_start_instr:

            # cleaning duplicate block in previous function
            self.current_function.basicblocks = list(set(self.current_function.basicblocks))
            # retrive matching function
            self.current_function = next(filter(lambda f: f.start_instr == instr, self.functions))
            # self.ssa_counter = 0
            logging.info("[+] Entering function - %x: ",
                         self.current_function.start_offset,
                         self.current_function.prefered_name)

        # associate function to basicblock
        # TODO: create list of function_name
        self.current_basicblock.function_name = self.current_function.prefered_name
        # associate basicblock to function
        self.current_function.basicblocks.append(self.current_basicblock)

        # halt variable use to catch ending branch
        halt = False
        while not halt:

            # get current instruction
            instr = self.reverse_instructions[state.pc]

            # handle fall-thrown due to JUMPDEST
            if instr.name == 'JUMPDEST':
                # doesn't match new block that start with JUMPDEST
                if self.current_basicblock.start_offset != instr.offset:
                    self.edges.append(Edge(self.current_basicblock.name, 'block_%x' % instr.offset, EDGE_FALLTHROUGH))

            # get current basicblock
            self.current_basicblock = self.basicblock_per_instr[instr.offset]
            self.current_function.basicblocks.append(self.current_basicblock)

            # add this instruction to his functions
            # TODO: verify if it's not useless for ethereum
            self.current_function.instructions.append(instr)

            # Save instruction and state
            state.instr = instr
            self.states[self.states_total] = state
            state = copy.deepcopy(state)
            self.states_total += 1
            state.pc += 1

            # execute single instruction
            halt = self.emulate_one_instruction(instr, state, depth)
            state.instructions_visited.append(instr.offset)
            #state.instructions_visited[instr.offset] = instr.offset

        logging.info("[X] Returning from basicblock %s", self.current_basicblock.name)

        # automatic remove duplicated edges
        self.edges = list(set(self.edges))

    def emulate_one_instruction(self, instr, state, depth):

        halt = False

        #
        #  0s: Stop and Arithmetic Operations
        #
        if instr.name == 'STOP':
            if self.ssa:
                instr.ssa = SSA(method_name=instr.name)
            halt = True
        elif instr.is_arithmetic:
            self.emul_arithmetic_instruction(instr, state)
        #
        #  10s: Comparison & Bitwise Logic Operations
        #
        elif instr.is_comparaison_logic:
            self.emul_comparaison_logic_instruction(instr, state)
        #
        #  20s: SHA3
        #
        elif instr.is_sha3:
            self.emul_sha3_instruction(instr, state)
        #
        #  30s: Environment Information
        #
        elif instr.is_environmental:
            self.ssa_environmental_instruction(instr, state)
        #
        #  40s: Block Information
        #
        elif instr.uses_block_info:
            self.ssa_block_instruction(instr, state)
        #
        #  50s: Stack, Memory, Storage, and Flow Information
        #
        elif instr.uses_stack_block_storage_info:
            halt = self.ssa_stack_memory_storage_flow_instruction(instr, state, depth)
        #
        #  60s & 70s: Push Operations
        #
        elif instr.name.startswith("PUSH"):
            #value = int.from_bytes(instr.operand, byteorder='big')
            instr.ssa = SSA(self.ssa_counter, instr.name,
                            instr.operand_interpretation,
                            instr_type=SSA_TYPE_CONSTANT)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1
        #
        #  80s: Duplication Operations
        #
        elif instr.name.startswith('DUP'):
            # DUPn (eg. DUP1: a b c -> a b c c, DUP3: a b c -> a b c a)
            position = instr.pops  # == XX from DUPXX
            try:
                # SSA STACK
                instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[state.ssa_stack[- position]])
                state.ssa_stack.append(state.ssa_stack[- position])
                self.ssa_counter += 1
                halt = False
            except:
                logging.info('[-] STACK underflow')
                halt = True
        #
        #  90s: Swap Operations
        #
        elif instr.name.startswith('SWAP'):
            # SWAPn (eg. SWAP1: a b c d -> a b d c, SWAP3: a b c d -> d b c a)
            position = instr.pops - 1  # == XX from SWAPXX
            try:
                temp = state.ssa_stack[-position - 1]
                state.ssa_stack[-position - 1] = state.ssa_stack[-1]
                state.ssa_stack[-1] = temp

                instr.ssa = SSA(method_name=instr.name, args=[temp])

                halt = False
            except:
                logging.warning('[-] STACK underflow')
                halt = True
                #raise ValueError('STACK underflow')
        #
        #  a0s: Logging Operations
        #
        elif instr.name.startswith('LOG'):
            # only stack operations emulated
            arg = [state.ssa_stack.pop() for x in range(instr.pops)]
            instr.ssa = SSA(method_name=instr.name, args=arg)
            #state.ssa_stack.append(instr)
        #
        #  f0s: System Operations
        #
        elif instr.is_system:
            halt = self.ssa_system_instruction(instr, state)
            #ssa.append(instr.name)

        # UNKNOWN INSTRUCTION
        else:
            logging.warning('UNKNOWN = ' + instr.name)

        return halt

    def emul_arithmetic_instruction(self, instr, state):

        if instr.name in ['ADD', 'SUB', 'MUL', 'DIV', 'MOD', 'SDIV', 'SMOD', 'EXP', 'SIGNEXTEND']:
            args = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        elif instr.name in ['ADDMOD', 'MULMOD']:
            args = [state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()]

        # SSA emulation
        instr.ssa = SSA(self.ssa_counter,
                        instr.name, args=args)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        # Symbolic Execution emulation
        if self.symbolic_exec:
            result = self.simplify_ssa.symbolic_dispatcher(instr.name, args)
            state.stack.append(result)

    def emul_comparaison_logic_instruction(self, instr, state):

        if instr.name in ['LT', 'GT', 'SLT', 'SGT',
                          'EQ', 'AND', 'OR', 'XOR', 'BYTE']:
            args = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        elif instr.name in ['ISZERO', 'NOT']:
            args = [state.ssa_stack.pop()]

        # SSA emulation
        instr.ssa = SSA(self.ssa_counter,
                        instr.name, args=args)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        # Symbolic Execution emulation
        if self.symbolic_exec:
            result = self.simplify_ssa.symbolic_dispatcher(instr.name, args)
            state.stack.append(result)

    def emul_sha3_instruction(self, instr, state):
        '''Symbolic execution of SHA3 group of opcode'''

        # SSA STACK
        s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
        instr.ssa = SSA(self.ssa_counter, instr.name, args=[s0, s1])
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

    def ssa_environmental_instruction(self, instr, state):

        if instr.name in ['ADDRESS', 'ORIGIN', 'CALLER', 'CALLVALUE', 'CALLDATASIZE', 'CODESIZE', 'RETURNDATASIZE', 'GASPRICE']:
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['BALANCE', 'CALLDATALOAD', 'EXTCODESIZE']:
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['CALLDATACOPY', 'CODECOPY', 'RETURNDATACOPY']:
            op0, op1, op2 = state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name, args=[op0, op1, op2])

        elif instr.name == 'EXTCODECOPY':
            addr = state.ssa_stack.pop()
            start, s2, size = state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[addr, start, s2, size])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_block_instruction(self, instr, state):

        if instr.name == 'BLOCKHASH':
            # SSA STACK
            blocknumber = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[blocknumber])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['COINBASE', 'TIMESTAMP', 'NUMBER', 'DIFFICULTY', 'GASLIMIT']:
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_stack_memory_storage_flow_instruction(self, instr, state, depth):

        halt = False
        op = instr.name

        if op == 'POP':
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name)

        elif op in ['MLOAD', 'SLOAD']:
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif op in ['MSTORE', 'MSTORE8', 'SSTORE']:
            # SSA STACK
            s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[s0, s1])

        elif op == 'JUMP':
            # SSA STACK
            push_instr = state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[push_instr])

            # get instruction with this value as offset
            if push_instr.ssa.is_constant:
                #jump_addr = int.from_bytes(push_instr.operand, byteorder='big')
                jump_addr = push_instr.operand_interpretation
                # get instruction with this value as offset
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
            else:
                # try to resolve the SSA repr
                jump_addr = self.simplify_ssa.resolve_instr_ssa(push_instr)
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
                if not jump_addr:
                    logging.warning('JUMP DYNAMIC')
                    logging.warning('[X] push_instr %x: %s ' % (push_instr.offset, push_instr.name))
                    logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                    list_args = [arg.ssa.format() for arg in push_instr.ssa.args]
                    logging.warning('[X] push_instr.ssa %s' % list_args)
                    return True

            # depth of 1 - prevent looping
            #if (depth < self.max_depth):
            if target.name != "JUMPDEST":
                logging.info('[X] Bad JUMP to 0x%x' % jump_addr)
                return True

            if target.offset not in state.instructions_visited:
                logging.info('[X] follow JUMP branch offset 0x%x' % target.offset)
                new_state = copy.deepcopy(state)
                new_state.pc = self.instructions.index(target)
                #state.pc = self.instructions.index(target)

                # follow the JUMP
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_UNCONDITIONAL))
                self.emulate(new_state, depth=depth + 1)

                halt = True

            else:
                #logging.info('[X] Max depth reached, skipping JUMP 0x%x' % jump_addr)
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_UNCONDITIONAL))
                logging.info('[X] Loop detected, skipping JUMP 0x%x' % jump_addr)
                halt = True

            self.current_basicblock = self.basicblock_per_instr[instr.offset]

        elif op == 'JUMPI':
            # SSA STACK
            push_instr, condition = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[push_instr, condition])

            logging.info('[X] follow JUMPI default branch offset 0x%x' % (instr.offset_end + 1))
            new_state = copy.deepcopy(state)
            self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%(instr.offset_end + 1), EDGE_CONDITIONAL_FALSE))
            self.emulate(new_state, depth=depth + 1)
            self.current_basicblock = self.basicblock_per_instr[instr.offset]

            # get instruction with this value as offset
            if push_instr.ssa.is_constant:
                #jump_addr = int.from_bytes(push_instr.operand, byteorder='big')
                jump_addr = push_instr.operand_interpretation
                # get instruction with this value as offset
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
            else:
                # try to resolve the SSA repr
                jump_addr = self.simplify_ssa.resolve_instr_ssa(push_instr)
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
                if not jump_addr:
                    logging.warning('JUMP DYNAMIC')
                    logging.warning('[X] push_instr %x: %s ' % (push_instr.offset, push_instr.name))
                    logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                    list_args = [arg.ssa.format() for arg in push_instr.ssa.args]
                    logging.warning('[X] push_instr.ssa %s' % list_args)
                    return True

            if target.name != "JUMPDEST":
                logging.info('[X] Bad JUMP to 0x%x' % jump_addr)
                return True

            if target.offset not in state.instructions_visited:
                # condition are True
                logging.info('[X] follow JUMPI branch offset 0x%x' % (target.offset))
                new_state = copy.deepcopy(state)
                new_state.pc = self.instructions.index(target)

                # follow the JUMPI
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_CONDITIONAL_TRUE))
                self.emulate(new_state, depth=depth + 1)

            else:
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_CONDITIONAL_TRUE))
                logging.warning('[X] Loop detected, skipping JUMPI 0x%x' % jump_addr)
                logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                halt = True
            halt = True

        elif op in ['PC', 'MSIZE', 'GAS']:
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif op == 'JUMPDEST':
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name)

        return halt

    def ssa_system_instruction(self, instr, state):

        halt = False

        if instr.name == 'CREATE':
            args = [state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()]
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=args)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ('CALL', 'CALLCODE', 'DELEGATECALL', 'STATICCALL'):

            if instr.name in ('CALL', 'CALLCODE'):
                gas, to, value, meminstart, meminsz, memoutstart, memoutsz = \
                    state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
                args = [gas, to, value, meminstart, meminsz, memoutstart, memoutsz]

            else:
                gas, to, meminstart, meminsz, memoutstart, memoutsz = \
                    state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
                args = [gas, to, meminstart, meminsz, memoutstart, memoutsz]

            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=args)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['RETURN', 'REVERT']:
            offset, length = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[offset, length])
            halt = True

        elif instr.name in ['INVALID', 'SELFDESTRUCT']:
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name)
            halt = True

        return halt

class EvmSSAEngine(EvmEmulatorEngine):

    def __init__(self, bytecode=None, max_depth=20):
        EvmEmulatorEngine.__init__(self, bytecode=bytecode,
                                        ssa=True,
                                        symbolic_exec=False,
                                        max_depth=max_depth)

'''
'''--- octopus/arch/evm/evm.py ---
# based on Manticore project: https://github.com/trailofbits/manticore
# extract from http://gavwood.com/paper.pdf

_table = {
    # opcode:(mnemonic, immediate_operand_size, pops, pushes, gas, description)
    0x00: ('STOP', 0, 0, 0, 0, 'Halts execution.'),
    0x01: ('ADD', 0, 2, 1, 3, 'Addition operation.'),
    0x02: ('MUL', 0, 2, 1, 5, 'Multiplication operation.'),
    0x03: ('SUB', 0, 2, 1, 3, 'Subtraction operation.'),
    0x04: ('DIV', 0, 2, 1, 5, 'Integer division operation.'),
    0x05: ('SDIV', 0, 2, 1, 5, 'Signed integer division operation (truncated).'),
    0x06: ('MOD', 0, 2, 1, 5, 'Modulo remainder operation.'),
    0x07: ('SMOD', 0, 2, 1, 5, 'Signed modulo remainder operation.'),
    0x08: ('ADDMOD', 0, 3, 1, 8, 'Modulo addition operation.'),
    0x09: ('MULMOD', 0, 3, 1, 8, 'Modulo multiplication operation.'),
    0x0a: ('EXP', 0, 2, 1, 10, 'Exponential operation.'),
    0x0b: ('SIGNEXTEND', 0, 2, 1, 5, "Extend length of two's complement signed integer."),
    0x10: ('LT', 0, 2, 1, 3, 'Less-than comparision.'),
    0x11: ('GT', 0, 2, 1, 3, 'Greater-than comparision.'),
    0x12: ('SLT', 0, 2, 1, 3, 'Signed less-than comparision.'),
    0x13: ('SGT', 0, 2, 1, 3, 'Signed greater-than comparision.'),
    0x14: ('EQ', 0, 2, 1, 3, 'Equality comparision.'),
    0x15: ('ISZERO', 0, 1, 1, 3, 'Simple not operator.'),
    0x16: ('AND', 0, 2, 1, 3, 'Bitwise AND operation.'),
    0x17: ('OR', 0, 2, 1, 3, 'Bitwise OR operation.'),
    0x18: ('XOR', 0, 2, 1, 3, 'Bitwise XOR operation.'),
    0x19: ('NOT', 0, 1, 1, 3, 'Bitwise NOT operation.'),
    0x1a: ('BYTE', 0, 2, 1, 3, 'Retrieve single byte from word.'),
    0x20: ('SHA3', 0, 2, 1, 30, 'Compute Keccak-256 hash.'),  # SHA3
    0x30: ('ADDRESS', 0, 0, 1, 2, 'Get address of currently executing account.'),
    0x31: ('BALANCE', 0, 1, 1, 20, 'Get balance of the given account.'),
    0x32: ('ORIGIN', 0, 0, 1, 2, 'Get execution origination address.'),
    0x33: ('CALLER', 0, 0, 1, 2, 'Get caller address.'),
    0x34: ('CALLVALUE', 0, 0, 1, 2, 'Get deposited value by the instruction/transaction responsible for this execution.'),
    0x35: ('CALLDATALOAD', 0, 1, 1, 3, 'Get input data of current environment.'),
    0x36: ('CALLDATASIZE', 0, 0, 1, 2, 'Get size of input data in current environment.'),
    0x37: ('CALLDATACOPY', 0, 3, 0, 3, 'Copy input data in current environment to memory.'),
    0x38: ('CODESIZE', 0, 0, 1, 2, 'Get size of code running in current environment.'),
    0x39: ('CODECOPY', 0, 3, 0, 3, 'Copy code running in current environment to memory.'),
    0x3a: ('GASPRICE', 0, 0, 1, 2, 'Get price of gas in current environment.'),
    0x3b: ('EXTCODESIZE', 0, 1, 1, 20, "Get size of an account's code."),
    0x3c: ('EXTCODECOPY', 0, 4, 0, 20, "Copy an account's code to memory."),
    0x3d: ('RETURNDATASIZE', 0, 0, 1, 2, "get size of return data buffer"),
    0x3e: ('RETURNDATACOPY', 0, 3, 0, 3, "copy return data in current environment to memory"),
    0x40: ('BLOCKHASH', 0, 1, 1, 20, 'Get the hash of one of the 256 most recent complete blocks.'),
    0x41: ('COINBASE', 0, 0, 1, 2, "Get the block's beneficiary address."),
    0x42: ('TIMESTAMP', 0, 0, 1, 2, "Get the block's timestamp."),
    0x43: ('NUMBER', 0, 0, 1, 2, "Get the block's number."),
    0x44: ('DIFFICULTY', 0, 0, 1, 2, "Get the block's difficulty."),
    0x45: ('GASLIMIT', 0, 0, 1, 2, "Get the block's gas limit."),
    0x50: ('POP', 0, 1, 0, 2, 'Remove item from stack.'),
    0x51: ('MLOAD', 0, 1, 1, 3, 'Load word from memory.'),
    0x52: ('MSTORE', 0, 2, 0, 3, 'Save word to memory.'),
    0x53: ('MSTORE8', 0, 2, 0, 3, 'Save byte to memory.'),
    0x54: ('SLOAD', 0, 1, 1, 50, 'Load word from storage.'),
    0x55: ('SSTORE', 0, 2, 0, 0, 'Save word to storage.'),
    0x56: ('JUMP', 0, 1, 0, 8, 'Alter the program counter.'),
    0x57: ('JUMPI', 0, 2, 0, 10, 'Conditionally alter the program counter.'),
    0x58: ('GETPC', 0, 0, 1, 2, 'Get the value of the program counter prior to the increment.'),
    0x59: ('MSIZE', 0, 0, 1, 2, 'Get the size of active memory in bytes.'),
    0x5a: ('GAS', 0, 0, 1, 2, 'Get the amount of available gas, including the corresponding reduction the amount of available gas.'),
    0x5b: ('JUMPDEST', 0, 0, 0, 1, 'Mark a valid destination for jumps.'),
    0x60: ('PUSH1', 1, 0, 1, 0, 'Place 1 byte item on stack.'),
    0x61: ('PUSH2', 2, 0, 1, 0, 'Place 2-byte item on stack.'),
    0x62: ('PUSH3', 3, 0, 1, 0, 'Place 3-byte item on stack.'),
    0x63: ('PUSH4', 4, 0, 1, 0, 'Place 4-byte item on stack.'),
    0x64: ('PUSH5', 5, 0, 1, 0, 'Place 5-byte item on stack.'),
    0x65: ('PUSH6', 6, 0, 1, 0, 'Place 6-byte item on stack.'),
    0x66: ('PUSH7', 7, 0, 1, 0, 'Place 7-byte item on stack.'),
    0x67: ('PUSH8', 8, 0, 1, 0, 'Place 8-byte item on stack.'),
    0x68: ('PUSH9', 9, 0, 1, 0, 'Place 9-byte item on stack.'),
    0x69: ('PUSH10', 10, 0, 1, 0, 'Place 10-byte item on stack.'),
    0x6a: ('PUSH11', 11, 0, 1, 0, 'Place 11-byte item on stack.'),
    0x6b: ('PUSH12', 12, 0, 1, 0, 'Place 12-byte item on stack.'),
    0x6c: ('PUSH13', 13, 0, 1, 0, 'Place 13-byte item on stack.'),
    0x6d: ('PUSH14', 14, 0, 1, 0, 'Place 14-byte item on stack.'),
    0x6e: ('PUSH15', 15, 0, 1, 0, 'Place 15-byte item on stack.'),
    0x6f: ('PUSH16', 16, 0, 1, 0, 'Place 16-byte item on stack.'),
    0x70: ('PUSH17', 17, 0, 1, 0, 'Place 17-byte item on stack.'),
    0x71: ('PUSH18', 18, 0, 1, 0, 'Place 18-byte item on stack.'),
    0x72: ('PUSH19', 19, 0, 1, 0, 'Place 19-byte item on stack.'),
    0x73: ('PUSH20', 20, 0, 1, 0, 'Place 20-byte item on stack.'),
    0x74: ('PUSH21', 21, 0, 1, 0, 'Place 21-byte item on stack.'),
    0x75: ('PUSH22', 22, 0, 1, 0, 'Place 22-byte item on stack.'),
    0x76: ('PUSH23', 23, 0, 1, 0, 'Place 23-byte item on stack.'),
    0x77: ('PUSH24', 24, 0, 1, 0, 'Place 24-byte item on stack.'),
    0x78: ('PUSH25', 25, 0, 1, 0, 'Place 25-byte item on stack.'),
    0x79: ('PUSH26', 26, 0, 1, 0, 'Place 26-byte item on stack.'),
    0x7a: ('PUSH27', 27, 0, 1, 0, 'Place 27-byte item on stack.'),
    0x7b: ('PUSH28', 28, 0, 1, 0, 'Place 28-byte item on stack.'),
    0x7c: ('PUSH29', 29, 0, 1, 0, 'Place 29-byte item on stack.'),
    0x7d: ('PUSH30', 30, 0, 1, 0, 'Place 30-byte item on stack.'),
    0x7e: ('PUSH31', 31, 0, 1, 0, 'Place 31-byte item on stack.'),
    0x7f: ('PUSH32', 32, 0, 1, 0, 'Place 32-byte (full word) item on stack.'),
    0x80: ('DUP1', 0, 1, 2, 3, 'Duplicate 1st stack item.'),
    0x81: ('DUP2', 0, 2, 3, 3, 'Duplicate 2nd stack item.'),
    0x82: ('DUP3', 0, 3, 4, 3, 'Duplicate 3rd stack item.'),
    0x83: ('DUP4', 0, 4, 5, 3, 'Duplicate 4th stack item.'),
    0x84: ('DUP5', 0, 5, 6, 3, 'Duplicate 5th stack item.'),
    0x85: ('DUP6', 0, 6, 7, 3, 'Duplicate 6th stack item.'),
    0x86: ('DUP7', 0, 7, 8, 3, 'Duplicate 7th stack item.'),
    0x87: ('DUP8', 0, 8, 9, 3, 'Duplicate 8th stack item.'),
    0x88: ('DUP9', 0, 9, 10, 3, 'Duplicate 9th stack item.'),
    0x89: ('DUP10', 0, 10, 11, 3, 'Duplicate 10th stack item.'),
    0x8a: ('DUP11', 0, 11, 12, 3, 'Duplicate 11th stack item.'),
    0x8b: ('DUP12', 0, 12, 13, 3, 'Duplicate 12th stack item.'),
    0x8c: ('DUP13', 0, 13, 14, 3, 'Duplicate 13th stack item.'),
    0x8d: ('DUP14', 0, 14, 15, 3, 'Duplicate 14th stack item.'),
    0x8e: ('DUP15', 0, 15, 16, 3, 'Duplicate 15th stack item.'),
    0x8f: ('DUP16', 0, 16, 17, 3, 'Duplicate 16th stack item.'),
    0x90: ('SWAP1', 0, 2, 2, 3, 'Exchange 1st and 2nd stack items.'),
    0x91: ('SWAP2', 0, 3, 3, 3, 'Exchange 1st and 3rd stack items.'),
    0x92: ('SWAP3', 0, 4, 4, 3, 'Exchange 1st and 4th stack items.'),
    0x93: ('SWAP4', 0, 5, 5, 3, 'Exchange 1st and 5th stack items.'),
    0x94: ('SWAP5', 0, 6, 6, 3, 'Exchange 1st and 6th stack items.'),
    0x95: ('SWAP6', 0, 7, 7, 3, 'Exchange 1st and 7th stack items.'),
    0x96: ('SWAP7', 0, 8, 8, 3, 'Exchange 1st and 8th stack items.'),
    0x97: ('SWAP8', 0, 9, 9, 3, 'Exchange 1st and 9th stack items.'),
    0x98: ('SWAP9', 0, 10, 10, 3, 'Exchange 1st and 10th stack items.'),
    0x99: ('SWAP10', 0, 11, 11, 3, 'Exchange 1st and 11th stack items.'),
    0x9a: ('SWAP11', 0, 12, 12, 3, 'Exchange 1st and 12th stack items.'),
    0x9b: ('SWAP12', 0, 13, 13, 3, 'Exchange 1st and 13th stack items.'),
    0x9c: ('SWAP13', 0, 14, 14, 3, 'Exchange 1st and 14th stack items.'),
    0x9d: ('SWAP14', 0, 15, 15, 3, 'Exchange 1st and 15th stack items.'),
    0x9e: ('SWAP15', 0, 16, 16, 3, 'Exchange 1st and 16th stack items.'),
    0x9f: ('SWAP16', 0, 17, 17, 3, 'Exchange 1st and 17th stack items.'),
    0xa0: ('LOG0', 0, 2, 0, 375, 'Append log record with no topics.'),
    0xa1: ('LOG1', 0, 3, 0, 750, 'Append log record with one topic.'),
    0xa2: ('LOG2', 0, 4, 0, 1125, 'Append log record with two topics.'),
    0xa3: ('LOG3', 0, 5, 0, 1500, 'Append log record with three topics.'),
    0xa4: ('LOG4', 0, 6, 0, 1875, 'Append log record with four topics.'),
    0xf0: ('CREATE', 0, 3, 1, 32000, 'Create a new account with associated code.'),
    0xf1: ('CALL', 0, 7, 1, 40, 'Message-call into an account.'),
    0xf2: ('CALLCODE', 0, 7, 1, 40, "Message-call into this account with alternative account's code."),
    0xf3: ('RETURN', 0, 2, 0, 0, 'Halt execution returning output data.'),
    0xf4: ('DELEGATECALL', 0, 6, 1, 40, "like CALLCODE but keeps caller's value and sender"),
    0xfa: ('STATICCALL', 0, 6, 1, 40, 'like CALL but disallow state modifications'),
    0xfb: ('CREATE2', 0, 4, 1, 32000, 'create new account with associated code at address `sha3(sender + salt + sha3(init code)) % 2**160`'),
    0xfd: ('REVERT', 0, 2, 0, 0, 'halt execution, revert state and return output data'),
    0xfe: ('INVALID', 0, 0, 0, 0, 'old ASSERTFAIL - invalid instruction for expressing runtime errors (e.g., division-by-zero)'),
    0xff: ('SELFDESTRUCT', 0, 1, 0, 5000, 'Halt execution and register account for later deletion.')
}

class EVM(object):
    """Bytecode for Ethereum VM."""

    def __init__(self):
        self.table = _table
        self.reverse_table = self._get_reverse_table()

    def _get_reverse_table(self):
        """Build an internal table used in the assembler."""
        reverse_table = {}
        for (opcode, (mnemonic, immediate_operand_size,
                      pops, pushes, gas, description)) in _table.items():
            reverse_table[mnemonic] = opcode, mnemonic, immediate_operand_size, \
                pops, pushes, gas, description
        return reverse_table

'''
'''--- octopus/arch/evm/instruction.py ---
from octopus.core.instruction import Instruction

class EvmInstruction(Instruction):
    """ETH Instruction

    TODO

    """

    def __init__(self, opcode, name,
                 operand_size, pops, pushes, fee,
                 description, operand=None,
                 operand_interpretation=None, offset=0, xref=None):
        """ TODO """
        super().__init__(opcode=opcode, name=name,
                         operand_size=operand_size, pops=pops, pushes=pushes,
                         fee=fee, description=description, operand=operand,
                         operand_interpretation=operand_interpretation,
                         offset=offset, xref=xref)

    @property
    def group(self):
        '''Instruction classification as per the yellow paper'''
        classes = {0: 'Stop and Arithmetic Operations',
                   1: 'Comparison & Bitwise Logic Operations',
                   2: 'SHA3',
                   3: 'Environmental Information',
                   4: 'Block Information',
                   5: 'Stack, Memory, Storage and Flow Operations',
                   6: 'Push Operations',
                   7: 'Push Operations',
                   8: 'Duplication Operations',
                   9: 'Exchange Operations',
                   0xa: 'Logging Operations',
                   0xf: 'System operations'}
        return classes.get(self.opcode >> 4, 'Invalid instruction')

    @property
    def is_terminator(self):
        """ True if the instruction is a basic block terminator """
        return self.is_branch or self.is_halt

    @property
    def is_branch_conditional(self):
        """ Return list if the instruction is a jump """
        return self.semantics in ['JUMPI']

    @property
    def is_branch_unconditional(self):
        """ Return list if the instruction is a jump """
        return self.semantics in ['JUMP']

    @property
    def is_system(self):
        """ True if the instruction is a system operation """
        return self.group == 'System operations'

    @property
    def is_arithmetic(self):
        """ True if the instruction is an arithmetic operation """
        return self.group == 'Stop and Arithmetic Operations'

    @property
    def is_comparaison_logic(self):
        """ True if the instruction is a Comparison & Bitwise Logic Operations """
        return self.group == 'Comparison & Bitwise Logic Operations'

    @property
    def is_sha3(self):
        """ True if the instruction is SHA3"""
        return self.group == 'SHA3'

    @property
    def is_environmental(self):
        """ True if the instruction access enviromental data """
        return self.group == 'Environmental Information'

    @property
    def uses_block_info(self):
        """ True if the instruction access block information """
        return self.group == 'Block Information'

    @property
    def uses_stack_block_storage_info(self):
        """ True if the instruction are in the group Stack, Memory, Storage and Flow Operations """
        return self.group == 'Stack, Memory, Storage and Flow Operations'

    @property
    def is_push(self):
        """ True if the instruction is a push Operations """
        return self.group == 'Push Operations'

    @property
    def have_xref(self):
        """ True if the instruction is a basic block terminator """
        return self.is_branch

    def set_xref(self, v):
        """ TODO """
        self._xref = int.from_bytes(v, byteorder='big')

    @property
    def is_call(self):
        """ Return list if the instruction is a basic block terminator """
        return self.semantics in ('CALL', 'CALLCODE',
                                  'DELEGATECALL', 'STATICCALL')

    @property
    def is_halt(self):
        """ Return list if the instruction is a basic block terminator """
        return self.semantics in ('RETURN', 'STOP', 'INVALID',
                                  'SELFDESTRUCT', 'REVERT')

'''
'''--- octopus/arch/evm/ssa.py ---
from octopus.engine.helper import helper as hlp
from z3 import UDiv, ULT, UGT

from logging import getLogger
logging = getLogger(__name__)

# =======================================
# #            SSA Simplifier           #
# =======================================

class EvmSSASimplifier(object):
    def __init__(self):
        self._dispatch_function = {
            # arithmetic
            'ADD': self.symbolic_add,
            'SUB': self.operate_SUB,
            'MUL': self.operate_MUL,
            'DIV': self.operate_DIV,
            'MOD': self.operate_MOD,
            'SDIV': self.operate_SDIV,
            'SMOD': self.operate_SMOD,
            'ADDMOD': self.operate_ADDMOD,
            'MULMOD': self.operate_MULMOD,
            'EXP': self.operate_EXP,
            # SIGNEXTEND
            # logic
            'LT': self.operate_LT,
            'GT': self.operate_GT,
            'SLT': self.operate_SLT,
            'SGT': self.operate_SGT,
            'EQ': self.operate_EQ,
            'ISZERO': self.operate_ISZERO,
            'AND': self.operate_AND,
            'OR': self.operate_OR,
            'XOR': self.operate_XOR,
            # 'NOT': self.operate_NOT,
            # 'BYTE': self.operate_BYTE,
        }

    def is_all_constant(self, list):
        if [True] * len(list) == [i.ssa.is_constant for i in list]:
            return True
        return False

    def resolve_instr_ssa(self, instr):
        # SSA_TYPE_CONSTANT
        if instr.ssa.is_constant and instr.operand_interpretation:
            return instr.operand_interpretation
        # SSA_TYPE_FUNCTION
        elif instr.ssa.is_function:
            # args are all constants (most commun case)
            if self.is_all_constant(instr.ssa.args):
                values = [i.operand_interpretation for i in instr.ssa.args]
                result = self.symbolic_dispatcher(instr.name, values)
                # logging.warning('.. %x', result)
                return result
            else:
                # TODO: recursive resolve_instr_ir
                logging.warning('args not all constant')
                return None

        else:
            raise Exception('SSA_TYPE Unknown')
        return None

    def symbolic_dispatcher(self, mnemonic, values):

        fn = self._dispatch_function.get(mnemonic, None)
        return fn(*values)

    # arithmetics
    def symbolic_add(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 + s1)

    def operate_SUB(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 - s1)

    def operate_MUL(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 * s1)

    def operate_DIV(self, *values):
        if values[1] == 0:
            return 0
        else:
            return hlp.get_concrete_int(UDiv(values[0] / values[1]))

    def operate_MOD(self, *values):
        return hlp.get_concrete_int(0 if values[1] == 0 else values[0] % values[1])

    def operate_SDIV(self, *values):
        s0, s1 = values[0], values[1]
        sign = -1 if (s0 / s1) < 0 else 1
        computed = sign * (abs(s0) / abs(s1))
        return hlp.get_concrete_int(computed)

    def operate_SMOD(self, *values):
        sign = -1 if values[0] < 0 else 1
        computed = sign * (abs(values[0]) % abs(values[1]))
        return hlp.get_concrete_int(computed)

    def operate_ADDMOD(self, *values):
        s0, s1, s2 = values[0], values[1], values[2]
        return hlp.get_concrete_int((s0 + s1) % s2 if s2 else 0)

    def operate_MULMOD(self, *values):
        s0, s1, s2 = values[0], values[1], values[2]
        return hlp.get_concrete_int((s0 * s1) % s2 if s2 else 0)

    def operate_EXP(self, *values):
        base, exponent = values[0], values[1]
        return hlp.get_concrete_int(pow(base, exponent))

        # logic
    def operate_LT(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(ULT(s0, s1))

    def operate_GT(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(UGT(s0, s1))

    def operate_SLT(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 < s1)

    def operate_SGT(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 > s1)

    def operate_EQ(self, *values):
        return hlp.get_concrete_int(values[0] == values[1])

    def operate_ISZERO(self, *values):
        return hlp.get_concrete_int(values[0] == 0)

    def operate_AND(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 & s1)

    def operate_OR(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 | s1)

    def operate_XOR(self, *values):
        s0 = hlp.convert_to_bitvec(values[0])
        s1 = hlp.convert_to_bitvec(values[1])
        return hlp.get_concrete_int(s0 ^ s1)

    # def operate_NOT(self, *values):
    #    return hlp.get_concrete_int(values[0] & values[1])

    # def operate_BYTE(self, *values):
    #    return

'''
'''--- octopus/arch/evm/vmstate.py ---
from octopus.engine.engine import VMstate

class EvmVMstate(VMstate):

    def __init__(self, gas=1000000):
        self.storage = {}
        self.memory = []

        self.stack = []
        self.ssa_stack = []
        self.symbolic_stack = []

        self.last_returned = []
        self.gas = gas
        self.pc = 0
        self.instr = None

        self.instructions_visited = list()

    def details(self):

        return {'storage': self.storage,
                'memory': self.memory,
                'stack': self.stack,
                'ssa_stack': self.ssa_stack,
                'symbolic_stack': self.symbolic_stack,
                'last_returned': self.last_returned,
                'gas': self.gas,
                'pc': self.pc}

'''
'''--- octopus/arch/wasm/__init__.py ---

'''
'''--- octopus/arch/wasm/analyzer.py ---
from wasm.modtypes import (TypeSection,
                           ImportSection,
                           FunctionSection,
                           TableSection,
                           MemorySection,
                           GlobalSection,
                           ExportSection,
                           StartSection,
                           ElementSection,
                           CodeSection,
                           DataSection)

from octopus.arch.wasm.constant import LANG_TYPE, KIND_TYPE
from octopus.arch.wasm.format import (format_kind_function,
                                      format_kind_table,
                                      format_kind_memory,
                                      format_kind_global)

from octopus.arch.wasm.decode import decode_module

from octopus.core.utils import bytecode_to_bytes
# from wasm.decode import decode_module
import io
import json
import os

from logging import getLogger
logging = getLogger(__name__)

class WasmModuleAnalyzer(object):
    '''Analyze and extract informations from wasm module'''

    def __init__(self, module_bytecode, analysis=True):
        self.module_bytecode = bytecode_to_bytes(module_bytecode)

        self.magic = None
        self.version = None
        self.types = list()
        self.imports_all = list()
        self.imports_func = list()
        self.func_types = list()
        self.tables = list()
        self.memories = list()
        self.globals = list()
        self.exports = list()
        self.start = None
        self.elements = list()
        self.codes = list()
        self.datas = list()
        self.names = list()
        self.customs = list()
        self.func_prototypes = list()
        # self.strings = list() - TODO

        if analysis:
            self.analyze()

    def attributes_reset(self):
        self.magic = None
        self.version = None
        self.types = list()
        self.imports_all = list()
        self.imports_func = list()
        self.func_types = list()
        self.tables = list()
        self.memories = list()
        self.globals = list()
        self.exports = list()
        self.start = None
        self.elements = list()
        self.codes = list()
        self.datas = list()
        self.names = list()
        self.customs = list()
        self.func_prototypes = list()

    def __str__(self):
        return str(self.show())

    def show(self):
        """Return dict with WasmModuleAnalyzer attributes"""
        return {'magic': self.magic,
                'version': self.version,
                'types': self.types,
                'imports_all': self.imports_all,
                'imports_func': self.imports_func,
                'func_types': self.func_types,
                'tables': self.tables,
                'memories': self.memories,
                'globals': self.globals,
                'exports': self.exports,
                'start': self.start,
                'elements': self.elements,
                'length codes': len(self.codes),
                'datas': self.datas,
                'func_prototypes': self.func_prototypes}

    def __get_section(self, section_type):
        mod_iter = iter(decode_module(self.module_bytecode))
        _, _ = next(mod_iter)
        sections = list(mod_iter)

        # iterate over all section
        for cur_sec, cur_sec_data in sections:
            sec = cur_sec_data.get_decoder_meta()['types']['payload']

            if isinstance(sec, section_type):
                return cur_sec_data
        return None

    def __decode_header(self, header, h_data):
        """Decode wasm header
        Return tuple (magic, version) of wasm module header
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#high-level-structure
        """
        magic = \
            h_data.magic.to_bytes(header.magic.byte_size, 'little')
        version = \
            h_data.version.to_bytes(header.version.byte_size, 'little')
        return (magic, version)

    def __decode_type_section(self, type_section):
        """Decode wasm type section
        Return a list of tuple (param_str, return_str)
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#type-section
        """
        type_list = []

        for idx, entry in enumerate(type_section.payload.entries):
            param_str = ''
            return_str = ''

            param_str += ' '.join([LANG_TYPE.get(_x) for _x in entry.param_types])
            if entry.return_type:
                return_str = '%s' % LANG_TYPE.get(entry.return_type)

            type_list.append((param_str, return_str))
        return type_list

    def __decode_import_section(self, import_section):
        """Decode import section to tuple of list
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#import-section
        """
        entries = import_section.payload.entries
        import_list = []
        import_func_list = []

        for idx, entry in enumerate(entries):
            #            for encoding in ('utf-8', 'utf-16-be'):
            #                value = str(v)
            #                try:
            #                    value = v.decode(encoding)
            #                    break
            #                except UnicodeDecodeError:
            #                    value = str(v)
            try:
                module_str = entry.module_str.tobytes().decode('utf-8')
            except UnicodeDecodeError:
                module_str = entry.module_str.tobytes()
            try:
                field_str = entry.field_str.tobytes().decode('utf-8')
            except UnicodeDecodeError:
                field_str = entry.field_str.tobytes()

            logging.debug('%s %s', module_str, field_str)
            kind_type = KIND_TYPE.get(entry.kind)

            if kind_type == 'function':
                f_type = format_kind_function(entry.type.type)
                import_list.append((entry.kind, module_str, field_str, f_type))
                # add also the info into the specific import function list
                import_func_list.append((module_str, field_str, f_type))
            elif kind_type == 'table':
                tabl = format_kind_table(entry.type.element_type,
                                         entry.type.limits.flags,
                                         entry.type.limits.initial,
                                         entry.type.limits.maximum)
                import_list.append((entry.kind, module_str, field_str, tabl))

            elif kind_type == 'memory':
                mem = format_kind_memory(entry.type.limits.flags,
                                         entry.type.limits.initial,
                                         entry.type.limits.maximum)
                import_list.append((entry.kind, module_str, field_str, mem))

            elif kind_type == 'global':
                gbl = format_kind_global(entry.type.content_type,
                                         entry.type.mutability)
                import_list.append((entry.kind, module_str, field_str, gbl))
            else:
                logging.error('unknown %d %s %s', entry.kind,
                              module_str, field_str)
        return (import_list, import_func_list)

    def __decode_function_section(self, function_section):
        """Decode function section
        The function section declares the signatures of all functions in the module
        Return list of indices (int)
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#function-section
        """
        return function_section.payload.types

    def __decode_table_section(self, table_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#table-section
        """
        # on the MVP, table size == 1
        entries = table_section.payload.entries
        table_list = []

        for idx, entry in enumerate(entries):
            element_type = entry.element_type
            flags = entry.limits.flags
            initial = entry.limits.initial
            maximum = entry.limits.maximum

            fmt = format_kind_table(element_type,
                                    flags,
                                    initial,
                                    maximum)
            table_list.append(fmt)
        return table_list

    def __decode_memory_section(self, memory_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#memory-section
        """
        # on the MVP, memory size == 1
        memory_l = list()
        entries = memory_section.payload.entries

        for idx, entry in enumerate(entries):

            flags = entry.limits.flags
            initial = entry.limits.initial
            maximum = entry.limits.maximum

            fmt = format_kind_memory(flags,
                                     initial,
                                     maximum)

            memory_l.append(fmt)
        return memory_l

    def __decode_global_section(self, global_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#global-section
        """
        globals_l = list()
        for entry in global_section.payload.globals:
            fmt = format_kind_global(entry.type.mutability,
                                     entry.type.content_type)
            globals_l.append(fmt)
        return globals_l

    def __decode_export_section(self, export_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#export-section
        """
        entries = export_section.payload.entries
        export_list = []

        for idx, entry in enumerate(entries):
            # field_str == function_name
            try:
                field_str = entry.field_str.tobytes().decode('utf-8')
            except UnicodeDecodeError:
                field_str = entry.field_str.tobytes()
            kind = entry.kind
            index = entry.index

            fmt = {'field_str': field_str,
                   'kind': kind,
                   'index': index}
            export_list.append(fmt)
        return export_list

    def __decode_start_section(self, start_section):
        return start_section.payload.index

    def __decode_element_section(self, element_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#element-section
        """
        entries = element_section.payload.entries
        element_list = []

        for idx, entry in enumerate(entries):

            fmt = {'index': entry.index,
                   'offset': entry.offset,
                   'elems': entry.elems}

            element_list.append(fmt)
        return element_list

    def __decode_code_section(self, code_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#code-section
        """
        bodies = code_section.payload.bodies
        code_list = []

        for idx, entry in enumerate(bodies):
            code_raw = entry.code.tobytes()
            code_list.append(code_raw)
        return code_list

    def __decode_data_section(self, data_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#data-section
        """
        entries = data_section.payload.entries
        data_list = []

        for idx, entry in enumerate(entries):
            data = entry.data.tobytes()

            fmt = {'index': entry.index,
                   'offset': entry.offset,
                   'size': entry.size,
                   'data': data}

            data_list.append(fmt)
        return data_list

    def __decode_name_section(self, name_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section
        """
        payload = name_section.payload.tobytes()
        #print(payload)

        total = 0
        names_list = list()

        f = io.BytesIO(payload)
        f.read(2)  # drop 2 bytes
        total += 2
        count = int.from_bytes(f.read(1), byteorder='little')
        total += 1

        while total < len(payload):
            index = int.from_bytes(f.read(1), byteorder='big')
            total += 1
            name_len = int.from_bytes(f.read(1), byteorder='big')
            total += 1
            name_str = f.read(name_len)
            total += name_len
            names_list.append((index, name_len, name_str))
        f.close()
        return names_list

    def __decode_unknown_section(self, unknown_section):
        """
        .. seealso:: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#high-level-structure
        """
        sec_name = unknown_section.name.tobytes()
        payload = unknown_section.payload.tobytes()
        return (sec_name, payload)

    def get_func_prototypes_ordered(self):
        """create ordered list of functions"""

        func_prototypes = list()

        # get imported functions
        for _, name, type_idx in self.imports_func:
            _param, _return = self.types[type_idx]
            func_prototypes.append((name, _param, _return, 'import'))

        # get all internal functions
        for idx, code in enumerate(self.codes):
            _param, _return = self.types[self.func_types[idx]]
            real_index = len(self.imports_func) + idx
            name = '$func%d' % real_index
            f_type = 'local'

            # if exported function - overwrite name
            for x in self.exports:
                if x.get('index') == real_index and x.get('kind') == 0:
                    name = x.get('field_str')
                    f_type = 'export'

            # TODO: need to test
            if real_index == self.start:
                name = '* ' + name
            func_prototypes.append((name, _param, _return, f_type))
        return func_prototypes

    def analyze(self):
        """analyse the complete module & extract informations """
        # src: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md
        # custom     0   name, .debug_str, ...
        # Type       1   Function signature declarations
        # Import     2   Import declarations
        # Function   3   Function declarations
        # Table      4   Indirect function table and other tables
        # Memory     5   Memory attributes
        # Global     6   Global declarations
        # Export     7   Exports
        # Start      8   Start function declaration
        # Element    9   Elements section
        # Code       10  Function bodies (code)
        # Data       11  Data segments

        # reset attributes
        self.attributes_reset()

        mod_iter = iter(decode_module(self.module_bytecode))
        # decode header version - usefull in the future (multiple versions)
        header, header_data = next(mod_iter)
        self.magic, self.version = self.__decode_header(header, header_data)

        #
        # Wasm sections
        #
        sections = list(mod_iter)

        for cur_sec, cur_sec_data in sections:
            sec = cur_sec_data.get_decoder_meta()['types']['payload']

            if isinstance(sec, TypeSection):
                self.types = self.__decode_type_section(cur_sec_data)
            elif isinstance(sec, ImportSection):
                self.imports_all, self.imports_func = \
                    self.__decode_import_section(cur_sec_data)
            elif isinstance(sec, FunctionSection):
                self.func_types = self.__decode_function_section(cur_sec_data)
            elif isinstance(sec, TableSection):
                self.tables = self.__decode_table_section(cur_sec_data)
            elif isinstance(sec, MemorySection):
                self.memories = self.__decode_memory_section(cur_sec_data)
            elif isinstance(sec, GlobalSection):
                # TODO not analyzed
                self.globals = self.__decode_global_section(cur_sec_data)
            elif isinstance(sec, ExportSection):
                self.exports = self.__decode_export_section(cur_sec_data)
            elif isinstance(sec, StartSection):
                # TODO not analyzed
                self.start = self.__decode_start_section(cur_sec_data)
            elif isinstance(sec, ElementSection):
                self.elements = self.__decode_element_section(cur_sec_data)
            elif isinstance(sec, CodeSection):
                self.codes = self.__decode_code_section(cur_sec_data)
            elif isinstance(sec, DataSection):
                self.datas = self.__decode_data_section(cur_sec_data)
            else:
                # name section
                if cur_sec_data.id == 0 and cur_sec_data.name.tobytes() == b'name':
                    self.names = self.__decode_name_section(cur_sec_data)
                else:
                    # TODO - handle properly .debug_str section
                    self.customs.append(self.__decode_unknown_section(cur_sec_data))

        # create ordered list of functions
        self.func_prototypes = self.get_func_prototypes_ordered()
        return True

    def is_compiled_with_emscripten(self):
        matching_list = self.get_emscripten_calls()
        return True if matching_list else False

    def get_emscripten_calls(self):
        res = [x for x, _, _, _ in self.func_prototypes if is_emscripten_func(x)]
        return res

    # emscripten syscall from:
    # * https://github.com/kripken/emscripten/blob/incoming/system/lib/fetch/asmfs.cpp
    # * http://gauss.ececs.uc.edu/Courses/c4029/code/syscall_32.tbl.html
    def contains_emscripten_syscalls(self):
        EMSCRIPTEN_SYSCALL_JSON = '/signatures/emscripten_syscalls.json'
        path = os.path.dirname(os.path.realpath(__file__)) + EMSCRIPTEN_SYSCALL_JSON

        json_data = open(path).read()
        data = json.loads(json_data)

        func_names = [x for x, _, _, _ in self.func_prototypes]
        match = list()
        for name in func_names:
            try:
                # remove '_' to match '__syscallXX' & '___syscallXX'
                syscall = data[name.replace('_', '')]
                match.append((name, syscall))
            except KeyError:
                pass
        return match

def is_emscripten_func(x):

    # from https://github.com/kripken/emscripten/blob/master/emscripten.py
    EMSCRIPTEN_LIST = [
        # create_basic_funcs
        'abort', 'assert', 'enlargeMemory', 'getTotalMemory',
        'abortOnCannotGrowMemory',
        'abortStackOverflow',
        'abortStackOverflowEmterpreter',
        'segfault', 'alignfault', 'ftfault',
        'SAFE_HEAP_LOAD', 'SAFE_HEAP_LOAD_D',
        'SAFE_HEAP_STORE', 'SAFE_HEAP_STORE_D', 'SAFE_FT_MASK',
        # create_receiving
        '_memcpy', '_memset', 'runPostSets',
        '_emscripten_replace_memory', '__start_module',
        # create_asm_runtime_funcs
        'stackAlloc', 'stackSave',
        'stackRestore', 'establishStackSpace', 'setThrew',
        'setTempRet0', 'getTempRet0',
        'setDynamicTop',
        'emterpret',
        'setAsyncState', 'emtStackSave',
        'emtStackRestore', 'getEmtStackMax', 'setEmtStackMax',
        'setAsync',
        'addOnExit',
        # from emscripten/emcc.py
        '_stbi_load', '_stbi_load_from_memory', '_stbi_image_free',
        '___cxa_demangle',
        '_malloc', '_free',
        'allocate', 'getMemory',
        '___errno_location', '_fflush',
        'FS_createFolder',
        'FS_createPath',
        'FS_createDataFile',
        'FS_createPreloadedFile',
        'FS_createLazyFile',
        'FS_createLink',
        'FS_createDevice',
        'FS_unlink',
        'addRunDependency',
        'removeRunDependency',
        # from emscripten/tools/ctor_evaller.py
        '_sbrk', '___cxa_atexit', '_atexit', 'dumpGlobals',
        # from emscripten/system/lib/pthreads.symbols
        '___assert_fail', '___errno_location', '___lock',
        '___pthread_self', '___pthread_tsd_main',
        '___pthread_tsd_run_dtors', '___pthread_tsd_size',
        '___shm_mapname', '___timedwait', '___unlock',
        '___vm_lock', '___vm_lock_impl', '___vm_unlock',
        '___vm_unlock_impl', '___wait', '__pthread_getcanceltype',
        '__pthread_isduecanceled', '__pthread_msecs_until',
        '____atomic_is_lock_free', '__llvm_atomic_load_add_i32_p0i32',
        '__llvm_memory_barrier', '_accept', '_access',
        '_atexit', '_bind', '_calloc', '_chdir', '_chmod',
        '_chown', '_chroot', '_clearenv', '_clearerr',
        '_clock_gettime', '_close', '_closedir', '_confstr',
        '_connect', '_creat', '_crypt', '_ctermid', '_dprintf',
        '_dup', '_dup2', '_emscripten_asm_const',
        '_emscripten_futex_wait', '_emscripten_futex_wake',
        '_emscripten_get_now', '_emscripten_is_main_runtime_thread',
        '_emscripten_main_thread_process_queued_calls',
        '_emscripten_pthread_attr_settransferredcanvases',
        '_emscripten_pthread_attr_gettransferredcanvases',
        '_emscripten_sync_run_in_main_thread',
        '_emscripten_sync_run_in_main_thread_0',
        '_emscripten_sync_run_in_main_thread_1',
        '_emscripten_sync_run_in_main_thread_2',
        '_emscripten_sync_run_in_main_thread_3',
        '_emscripten_sync_run_in_main_thread_4',
        '_emscripten_sync_run_in_main_thread_5',
        '_emscripten_sync_run_in_main_thread_6',
        '_emscripten_sync_run_in_main_thread_xprintf_varargs',
        '_encrypt', '_fchdir', '_fchmod', '_fchown', '_fclose',
        '_fcntl', '_fdopen', '_feof', '_ferror', '_fflush',
        '_fgetc', '_fgetpos', '_fgets', '_fileno', '_fopen',
        '_fpathconf', '_fprintf', '_fputc', '_fputs', '_fread',
        '_free', '_freopen', '_fscanf', '_fseek', '_fsetpos',
        '_fstat', '_fstatvfs', '_fsync', '_ftell', '_ftruncate',
        '_fwrite', '_getchar', '_getcwd', '_getenv',
        '_gethostname', '_getlogin', '_getlogin_r',
        '_getpeername', '_gets', '_getsockname', '_getsockopt',
        '_gettimeofday', '_ioctl', '_isatty', '_lchmod',
        '_lchown', '_link', '_listen', '_lockf', '_lseek',
        '_lstat', '_malloc', '_mkdir', '_mkdtemp', '_mkfifo',
        '_mknod', '_mkstemp', '_mktemp', '_mmap', '_munmap',
        '_nanosleep', '_open', '_opendir', '_pclose',
        '_perror', '_pipe', '_poll', '_popen', '_posix_fallocate',
        '_pread', '_printf', '_pthread_attr_destroy',
        '_pthread_attr_getdetachstate', '_pthread_attr_getguardsize',
        '_pthread_attr_getinheritsched', '_pthread_attr_getschedparam',
        '_pthread_attr_getschedpolicy', '_pthread_attr_getscope',
        '_pthread_attr_getstack', '_pthread_attr_getstacksize',
        '_pthread_attr_init', '_pthread_attr_setdetachstate',
        '_pthread_attr_setguardsize', '_pthread_attr_setinheritsched',
        '_pthread_attr_setschedparam', '_pthread_attr_setschedpolicy',
        '_pthread_attr_setscope', '_pthread_attr_setstack',
        '_pthread_attr_setstacksize', '_pthread_barrier_destroy',
        '_pthread_barrier_init', '_pthread_barrier_wait',
        '_pthread_barrierattr_destroy',
        '_pthread_barrierattr_getpshared',
        '_pthread_barrierattr_init',
        '_pthread_barrierattr_setpshared',
        '_pthread_cleanup_pop',
        '_pthread_cleanup_push',
        '_pthread_cond_broadcast', '_pthread_cond_destroy',
        '_pthread_cond_init', '_pthread_cond_signal',
        '_pthread_cond_timedwait', '_pthread_cond_wait',
        '_pthread_condattr_destroy', '_pthread_condattr_getclock',
        '_pthread_condattr_getpshared', '_pthread_condattr_init',
        '_pthread_condattr_setclock',
        '_pthread_condattr_setpshared', '_pthread_create',
        '_pthread_equal', '_pthread_getattr_np',
        '_pthread_getspecific', '_pthread_key_create',
        '_pthread_key_delete', '_pthread_mutex_consistent',
        '_pthread_mutex_destroy', '_pthread_mutex_getprioceiling',
        '_pthread_mutex_init', '_pthread_mutex_lock',
        '_pthread_mutex_setprioceiling', '_pthread_mutex_timedlock',
        '_pthread_mutex_trylock', '_pthread_mutex_unlock',
        '_pthread_mutexattr_destroy',
        '_pthread_mutexattr_getprotocol',
        '_pthread_mutexattr_getpshared',
        '_pthread_mutexattr_getrobust',
        '_pthread_mutexattr_gettype', '_pthread_mutexattr_init',
        '_pthread_mutexattr_setprotocol',
        '_pthread_mutexattr_setpshared',
        '_pthread_mutexattr_setrobust',
        '_pthread_mutexattr_settype', '_pthread_once',
        '_pthread_rwlock_destroy', '_pthread_rwlock_init',
        '_pthread_rwlock_rdlock', '_pthread_rwlock_timedrdlock',
        '_pthread_rwlock_timedwrlock',
        '_pthread_rwlock_tryrdlock', '_pthread_rwlock_trywrlock',
        '_pthread_rwlock_unlock', '_pthread_rwlock_wrlock',
        '_pthread_rwlockattr_destroy',
        '_pthread_rwlockattr_getpshared',
        '_pthread_rwlockattr_init',
        '_pthread_rwlockattr_setpshared', '_pthread_self',
        '_pthread_setcancelstate', '_pthread_setcanceltype',
        '_pthread_setspecific', '_pthread_spin_destroy',
        '_pthread_spin_init', '_pthread_spin_lock',
        '_pthread_spin_trylock', '_pthread_spin_unlock',
        '_pthread_testcancel', '_putchar', '_putenv',
        '_puts', '_pwrite', '_read', '_readdir', '_readdir_r',
        '_readlink', '_realpath', '_recv', '_recvfrom',
        '_recvmsg', '_remove', '_rename', '_rewind', '_rewinddir',
        '_rmdir', '_sbrk', '_scanf', '_sched_get_priority_max',
        '_sched_get_priority_min', '_seekdir', '_select',
        '_sem_close', '_sem_destroy', '_sem_getvalue',
        '_sem_init', '_sem_open', '_sem_post', '_sem_timedwait',
        '_sem_trywait', '_sem_unlink', '_sem_wait', '_send',
        '_sendmsg', '_sendto', '_setenv', '_shm_unlink',
        '_shutdown', '_snprintf', '_socket', '_stat', '_statvfs',
        '_symlink', '_sysconf', '_tcgetattr', '_tcsetattr',
        '_telldir', '_tempnam', '_tmpfile', '_tmpnam',
        '_truncate', '_ttyname', '_ttyname_r', '_tzset',
        '_umask', '_ungetc', '_unlink', '_unsetenv', '_usleep',
        '_utime', '_utimes', '_vsnprintf', '_write']

    if x.startswith('_emscripten_'):
        return True
    # function_tables(...)
    elif x.startswith('dynCall_'):
        return True
    # create_basic_funcs(...)
    elif x.startswith('nullFunc_'):
        return True
    elif x.startswith('invoke_'):
        return True
    elif x.startswith('jsCall_'):
        return True
    elif x.startswith('ftCall_'):
        return True
    # syscalls
    elif x.replace('_', '').startswith('syscall'):
        return True
    elif x in EMSCRIPTEN_LIST:
        return True
    else:
        return False

'''
'''--- octopus/arch/wasm/cfg.py ---
# for graph visualisation

from logging import getLogger
from graphviz import Digraph

from octopus.analysis.cfg import CFG
from octopus.analysis.graph import CFGGraph

from octopus.arch.wasm.analyzer import WasmModuleAnalyzer
from octopus.arch.wasm.disassembler import WasmDisassembler
from octopus.arch.wasm.format import (format_bb_name,
                                      format_func_name)
from octopus.arch.wasm.wasm import _groups

from octopus.core.basicblock import BasicBlock
from octopus.core.edge import (Edge,
                               EDGE_UNCONDITIONAL,
                               EDGE_CONDITIONAL_TRUE, EDGE_CONDITIONAL_FALSE,
                               EDGE_FALLTHROUGH, EDGE_CALL)
from octopus.core.function import Function
from octopus.core.utils import bytecode_to_bytes

logging = getLogger(__name__)

DESIGN_IMPORT = {'fillcolor': 'turquoise',
                 'shape': 'box',
                 'style': 'filled'}

DESIGN_EXPORT = {'fillcolor': 'grey',
                 'shape': 'box',
                 'style': 'filled'}

def enum_func(module_bytecode):
    ''' return a list of Function
        see:: octopus.core.function
    '''
    functions = list()
    analyzer = WasmModuleAnalyzer(module_bytecode)

    protos = analyzer.func_prototypes
    import_len = len(analyzer.imports_func)

    for idx, code in enumerate(analyzer.codes):
        # get corresponding function prototype
        name, param_str, return_str, _ = protos[import_len + idx]

        prefered_name = format_func_name(name, param_str, return_str)
        instructions = WasmDisassembler().disassemble(code)
        cur_function = Function(0, instructions[0], name=name,
                                prefered_name=prefered_name)
        cur_function.instructions = instructions

        functions.append(cur_function)
    return functions

def enum_func_name_call_indirect(functions):
    ''' return a list of function name if they used call_indirect
    '''
    func_name = list()

    # iterate over functions
    for func in functions:
        for inst in func.instructions:
            if inst.name == "call_indirect":
                func_name.append(func.name)
    func_name = list(set(func_name))
    return func_name

def enum_func_call_edges(functions, len_imports):
    ''' return a list of tuple with
        (index_func_node_from, index_func_node_to)
    '''
    call_edges = list()

    # iterate over functions
    for index, func in enumerate(functions):
        node_from = len_imports + index
        # iterates over instruction
        for inst in func.instructions:
            # detect if inst is a call instructions
            if inst.name == "call":  #is_call:
                logging.info('%s', inst.operand_interpretation)
                #if inst.name == "call":
                # only get the import_id
                import_id = inst.operand_interpretation.split(' ')[1]
                if import_id.startswith('0x'):
                    import_id = int(import_id, 16)
                else:
                    import_id = int(import_id)
                node_to = int(import_id)
                # The `call_indirect` operator takes a list of function arguments and as the last operand the index into the table.
                #elif inst.name == "call_indirect":
                # the last operand is the index on the table
                #print(inst.operand_interpretation)
                #print(type(inst.insn_byte[1]))
                #node_to = inst.insn_byte[1]
                #node_to = int(inst.operand_interpretation.split(',')[-1].split(' ')[-1])
                call_edges.append((node_from, node_to))

    return call_edges

def enum_blocks_edges(function_id, instructions):

    """
    Return a list of basicblock after
    statically parsing given instructions
    """

    basicblocks = list()
    edges = list()

    branches = []
    xrefs = []

    intent = 0
    blocks_tmp = []
    blocks_list = []

    # we need to do that because jump label are relative to the current block index
    for index, inst in enumerate(instructions[:-1]):

        if inst.is_block_terminator:
            start, name = blocks_tmp.pop()
            if inst.name == 'else':
                end = inst.offset - 1
            else:
                end = inst.offset_end
            blocks_list.append((intent, start, end, name))
            intent -= 1
        if inst.is_block_starter:  # in ['block', 'loop']:
            blocks_tmp.append((inst.offset, inst.name))
            intent += 1
        if inst.is_branch:
            branches.append((intent, inst))

    # add function body end
    blocks_list.append((0, 0, instructions[-1].offset_end, 'func'))
    blocks_list = sorted(blocks_list, key=lambda tup: (tup[1], tup[0]))

    for depth, inst in branches:
        labl = list()
        if inst.name == 'br_table':
            labl = [i for i in inst.insn_byte[2:]]
        else:
            labl.append(int(inst.operand_interpretation.split(' ')[-1]))

        for d2 in labl:
            rep = next(((i, s, e, n) for i, s, e, n in blocks_list if (i == (depth - d2) and s < inst.offset and e > inst.offset_end)), None)

            if rep:
                i, start, end, name = rep
                # if we branch to a 'loop' label
                # we go at the entry of the 'loop' block
                if name == 'loop':
                    value = start
                # if we branch to a 'block' label
                # we go at the end of the "block" block
                elif name == 'block' or name == 'func':
                    value = end
                # we don't know
                else:
                    value = None
                inst.xref.append(value)
                xrefs.append(value)

    # assign xref for "if" branch
    # needed because 'if' don't used label
    for index, inst in enumerate(instructions[:-1]):
        if inst.name == 'if':
            g_block = next(iter([b for b in blocks_list if b[1] == inst.offset]), None)
            jump_target = g_block[2] + 1
            inst.xref.append(jump_target)
            xrefs.append(jump_target)
        elif inst.name == 'else':
            g_block = next(iter([b for b in blocks_list if b[1] == inst.offset]), None)
            jump_target = g_block[2] + 1
            inst.xref.append(jump_target)
            xrefs.append(jump_target)

    # enumerate blocks
    new_block = True

    for index, inst in enumerate(instructions):

        # creation of a block
        if new_block:
            block = BasicBlock(inst.offset,
                               inst,
                               name=format_bb_name(function_id, inst.offset))
            new_block = False
        # add current instruction to the basicblock
        block.instructions.append(inst)

        # next instruction is a jump target
        if index < (len(instructions) - 1) and \
                instructions[index + 1].offset in xrefs:
            new_block = True
        # absolute jump - br
        elif inst.is_branch_unconditional:
            new_block = True
        # conditionnal jump - br_if
        elif inst.is_branch_conditional:
            new_block = True
        # is_block_terminator
        # GRAPHICAL OPTIMIZATION: merge end together
        elif index < (len(instructions) - 1) and \
                instructions[index + 1].name in ['else', 'loop']:  # is_block_terminator
            new_block = True
        # last instruction of the bytecode
        elif inst.offset == instructions[-1].offset:
            new_block = True

        if new_block:
            block.end_offset = inst.offset_end
            block.end_instr = inst
            basicblocks.append(block)
            new_block = True

    # enumerate edges
    for index, block in enumerate(basicblocks):
        # get the last instruction
        inst = block.end_instr
        # unconditional jump - br
        if inst.is_branch_unconditional:
            for ref in inst.xref:
                edges.append(Edge(block.name, format_bb_name(function_id, ref), EDGE_UNCONDITIONAL))
        # conditionnal jump - br_if, if
        elif inst.is_branch_conditional:
            if inst.name == 'if':
                edges.append(Edge(block.name,
                             format_bb_name(function_id, inst.offset_end + 1),
                             EDGE_CONDITIONAL_TRUE))
                if_b = next(iter([b for b in blocks_list if b[1] == inst.offset]), None)
                #else_block = blocks_list[blocks_list.index(if_block) + 1]
                jump_target = if_b[2] + 1
                edges.append(Edge(block.name,
                             format_bb_name(function_id, jump_target),
                             EDGE_CONDITIONAL_FALSE))
            else:
                for ref in inst.xref:
                    if ref and ref != inst.offset_end + 1:
                        # create conditionnal true edges
                        edges.append(Edge(block.name,
                                          format_bb_name(function_id, ref),
                                          EDGE_CONDITIONAL_TRUE))
                # create conditionnal false edge
                edges.append(Edge(block.name,
                             format_bb_name(function_id, inst.offset_end + 1),
                             EDGE_CONDITIONAL_FALSE))
        # instruction that end the flow
        elif [i.name for i in block.instructions if i.is_halt]:
            pass
        elif inst.is_halt:
            pass

        # handle the case when you have if and else following
        elif inst.offset != instructions[-1].offset and \
                block.start_instr.name != 'else' and \
                instructions[instructions.index(inst) + 1].name == 'else':

            else_ins = instructions[instructions.index(inst) + 1]
            else_b = next(iter([b for b in blocks_list if b[1] == else_ins.offset]), None)

            edges.append(Edge(block.name, format_bb_name(function_id, else_b[2] + 1), EDGE_FALLTHROUGH))
        # add the last intruction "end" in the last block
        elif inst.offset != instructions[-1].offset:
            # EDGE_FALLTHROUGH
            edges.append(Edge(block.name, format_bb_name(function_id, inst.offset_end + 1), EDGE_FALLTHROUGH))

    # prevent duplicate edges
    edges = list(set(edges))
    return basicblocks, edges

class WasmCFG(CFG):
    """
    """
    def __init__(self, module_bytecode):
        self.module_bytecode = bytecode_to_bytes(module_bytecode)

        self.functions = list()
        self.basicblocks = list()
        self.edges = list()

        self.analyzer = WasmModuleAnalyzer(self.module_bytecode)
        self.run_static_analysis()

    def run_static_analysis(self):
        self.functions = enum_func(self.module_bytecode)

        for idx, func in enumerate(self.functions):
            func.basicblocks, edges = enum_blocks_edges(idx, func.instructions)
            # all bb name are unique so we can create global bb & edge list
            self.basicblocks += func.basicblocks
            self.edges += edges

    def get_function(self, name=None, prefered_name=None):
        if name:
            return [x for x in self.functions if x.name == name][0]
        elif prefered_name:
            return [x for x in self.functions if x.prefered_name == prefered_name][0]
        else:
            raise Exception('name/prefered_name not found, please check again')

    def get_functions_call_edges(self, format_fname=False):

        nodes = list()
        edges = list()

        if not self.analyzer:
            self.analyzer = WasmModuleAnalyzer(self.module_bytecode)
        if not self.functions:
            self.functions = enum_func(self.module_bytecode)

        # create nodes
        for name, param_str, return_str, _ in self.analyzer.func_prototypes:
            if format_fname:
                nodes.append(format_func_name(name, param_str, return_str))
            else:
                nodes.append(name)

        logging.info('nodes: %s', nodes)

        # create edges
        tmp_edges = enum_func_call_edges(self.functions,
                                         len(self.analyzer.imports_func))

        # tmp_edges = [(node_from, node_to), (...), ...]
        for node_from, node_to in tmp_edges:
            # node_from
            name, param, ret, _ = self.analyzer.func_prototypes[node_from]
            if format_fname:
                from_final = format_func_name(name, param, ret)
            else:
                from_final = name
            # node_to
            name, param, ret, _ = self.analyzer.func_prototypes[node_to]
            to_final = format_func_name(name, param, ret)
            if format_fname:
                to_final = format_func_name(name, param, ret)
            else:
                to_final = name
            edges.append(Edge(from_final, to_final, EDGE_CALL))
        logging.info('edges: %s', edges)

        return (nodes, edges)

    def __str__(self):
        line = ("length functions = %d\n" % len(self.functions))
        line += ("length basicblocks = %d\n" % len(self.basicblocks))
        line += ("length edges = %d\n" % len(self.edges))
        return line

    def visualize(self, function=True, simplify=False, ssa=False):
        """Visualize the cfg
        used CFGGraph
        equivalent to:
            graph = CFGGraph(cfg)
            graph.view_functions()
        """
        graph = CFGGraph(self)
        if function:
            graph.view_functions(simplify=simplify, ssa=ssa)
        else:
            graph.view(simplify=simplify, ssa=ssa)

    def visualize_call_flow(self, filename="wasm_call_graph_octopus.gv",
                            format_fname=False):
        """Visualize the cfg call flow graph
        """
        nodes, edges = self.get_functions_call_edges()
        if format_fname:
            nodes_longname, edges = self.get_functions_call_edges(format_fname=True)

        g = Digraph(filename, filename=filename)
        g.attr(rankdir='LR')

        with g.subgraph(name='global') as c:

            export_list = [p[0] for p in self.analyzer.func_prototypes if p[3] == 'export']
            import_list = [p[0] for p in self.analyzer.func_prototypes if p[3] == 'import']
            call_indirect_list = enum_func_name_call_indirect(self.functions)

            try:
                indirect_target = [self.analyzer.func_prototypes[index][0] for index in self.analyzer.elements[0].get('elems')]
            except IndexError:
                indirect_target = []
            # create all the graph nodes (function name)
            for idx, node in enumerate(nodes):
                # name graph bubble
                node_name = node
                if format_fname:
                    node_name = nodes_longname[idx]

                # default style value
                fillcolor = "white"
                shape = "ellipse"
                style = "filled"

                if node in import_list:
                    logging.debug('import ' + node)
                    fillcolor = DESIGN_IMPORT.get('fillcolor')
                    shape = DESIGN_IMPORT.get('shape')
                    style = DESIGN_IMPORT.get('style')
                    c.node(node_name, fillcolor=fillcolor, shape=shape, style=style)
                elif node in export_list:
                    logging.debug('export ' + node)
                    fillcolor = DESIGN_EXPORT.get('fillcolor')
                    shape = DESIGN_EXPORT.get('shape')
                    style = DESIGN_EXPORT.get('style')
                    c.node(node_name, fillcolor=fillcolor, shape=shape, style=style)

                if node in indirect_target:
                    logging.debug('indirect_target ' + node)
                    shape = "hexagon"

                if node in call_indirect_list:
                    logging.debug('contain call_indirect ' + node)
                    style = "dashed"
                c.node(node_name, fillcolor=fillcolor, shape=shape, style=style)

            # check if multiple same edges
            # in that case, put the number into label
            edges_counter = dict((x, edges.count(x)) for x in set(edges))
            # insert edges on the graph
            for edge, count in edges_counter.items():
                label = None
                if count > 1:
                    label = str(count)
                c.edge(edge.node_from, edge.node_to, label=label)

        g.render(filename, view=True)

    def visualize_instrs_per_funcs(self, show=True, save=True,
                                   out_filename="wasm_func_analytic.png",
                                   fontsize=8):
        """Visualize the instructions repartitions per functions
        """

        import numpy as np
        import matplotlib.pyplot as plt

        final = list()
        datas = list()

        # legend x axis - name functions
        group_names = tuple([func.name for func in self.functions])
        # number of functions
        ind = [x for x, _ in enumerate(self.functions)]

        # list all groups
        all_groups = [v for _, v in _groups.items()]

        # list()
        for func in self.functions:
            data = list()
            group = [i.group for i in func.instructions]
            for g in all_groups:
                data.append(group.count(g))
            datas.append(tuple(data))

        for idx in range(len(all_groups)):
            final.append(tuple([x[idx] for x in datas]))

        # choice color: https://matplotlib.org/users/colormaps.html
        color = iter(plt.cm.gist_rainbow(np.linspace(0, 1, len(all_groups))))
        stack = np.array([0 * len(all_groups)])
        for idx in range(len(all_groups)):
            if idx == 0:
                # first bar
                plt.barh(ind, final[idx], label=all_groups[idx],
                         align='center', color=next(color))
            else:
                plt.barh(ind, final[idx], label=all_groups[idx], left=stack,
                         align='center', color=next(color))

            stack = stack + np.array(final[idx])

        # Rotate x-labels on the x-axis
        plt.yticks(fontsize=fontsize)
        plt.ylim([0, len(self.functions)])
        plt.yticks(ind, group_names)
        plt.ylabel('Functions')
        plt.xlabel('Instructions count')
        plt.legend(loc="lower right")
        plt.title('Instructions count by function and group')

        # save
        if save:
            plt.savefig(out_filename)
        # show
        if show:
            plt.show()

'''
'''--- octopus/arch/wasm/constant.py ---
# https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#language-types
LANG_TYPE = {
    # Opcode, Type constructor
    -0x01: 'i32',
    -0x02: 'i64',
    -0x03: 'f32',
    -0x04: 'f64',
    -0x10: 'anyfunc',
    -0x20: 'func',
    -0x40: 'block_type'
}

KIND_TYPE = {
    0: 'function',
    1: 'table',
    2: 'memory',
    3: 'global',
}

'''
'''--- octopus/arch/wasm/decode.py ---
# The MIT License (MIT)
#
# Copyright (c) 2016 Joel Hner <athre0z@zyantific.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# modified code from https://github.com/athre0z/wasm/blob/master/wasm/modtypes.py
# no need of that if PyPI wasm version 1.2 release

"""Provides functions for decoding WASM modules and bytecode."""
from __future__ import print_function, absolute_import, division, unicode_literals

from collections import namedtuple
from wasm.modtypes import ModuleHeader, Section, SEC_UNK, SEC_NAME, NameSubSection
from wasm.opcodes import OPCODE_MAP
from wasm.compat import byte2int

Instruction = namedtuple('Instruction', 'op imm len')
ModuleFragment = namedtuple('ModuleFragment', 'type data')

def decode_bytecode(bytecode):
    """Decodes raw bytecode, yielding `Instruction`s."""
    bytecode_wnd = memoryview(bytecode)
    while bytecode_wnd:
        opcode_id = byte2int(bytecode_wnd[0])
        opcode = OPCODE_MAP[opcode_id]

        if opcode.imm_struct is not None:
            offs, imm, _ = opcode.imm_struct.from_raw(None, bytecode_wnd[1:])
        else:
            imm = None
            offs = 0

        insn_len = 1 + offs
        yield Instruction(opcode, imm, insn_len)
        bytecode_wnd = bytecode_wnd[insn_len:]

def decode_module(module, decode_name_subsections=False):
    """Decodes raw WASM modules, yielding `ModuleFragment`s."""
    module_wnd = memoryview(module)

    # Read & yield module header.
    hdr = ModuleHeader()
    hdr_len, hdr_data, _ = hdr.from_raw(None, module_wnd)
    yield ModuleFragment(hdr, hdr_data)
    module_wnd = module_wnd[hdr_len:]

    # Read & yield sections.
    while module_wnd:
        sec = Section()
        sec_len, sec_data, _ = sec.from_raw(None, module_wnd)

        # If requested, decode name subsections when encountered.
        if (
            decode_name_subsections and
            sec_data.id == SEC_UNK and
            sec_data.name == SEC_NAME
        ):
            sec_wnd = sec_data.payload
            while sec_wnd:
                subsec = NameSubSection()
                subsec_len, subsec_data, _ = subsec.from_raw(None, sec_wnd)
                yield ModuleFragment(subsec, subsec_data)
                sec_wnd = sec_wnd[subsec_len:]
        else:
            yield ModuleFragment(sec, sec_data)

        # fix bug KeyError
        if sec_data.id == SEC_UNK and sec_data.name:
            sec_len -= sec_data.name_len + 1
        module_wnd = module_wnd[sec_len:]

'''
'''--- octopus/arch/wasm/disassembler.py ---
from octopus.engine.disassembler import Disassembler
from octopus.core.function import Function
from octopus.core.utils import bytecode_to_bytes

from octopus.arch.wasm.instruction import WasmInstruction
from octopus.arch.wasm.wasm import Wasm

from octopus.arch.wasm.decode import decode_module
# from wasm.decode import decode_module
from wasm.modtypes import CodeSection
from wasm.compat import byte2int
from wasm.opcodes import OPCODE_MAP
from wasm.formatter import format_instruction

from collections import namedtuple
inst_namedtuple = namedtuple('Instruction', 'op imm len')

class WasmDisassembler(Disassembler):

    def __init__(self, bytecode=None):
        Disassembler.__init__(self, asm=Wasm(), bytecode=bytecode)

    def disassemble_opcode(self, bytecode=None, offset=0):
        '''
        based on decode_bytecode()
        https://github.com/athre0z/wasm/blob/master/wasm/decode.py

        '''

        bytecode_wnd = memoryview(bytecode)
        opcode_id = byte2int(bytecode_wnd[0])

        # default value
        # opcode:(mnemonic/name, imm_struct, pops, pushes, description)
        invalid = ('INVALID', 0, 0, 0, 'Unknown opcode')
        name, imm_struct, pops, pushes, description = \
            self.asm.table.get(opcode_id, invalid)

        operand_size = 0
        operand = None
        operand_interpretation = None

        if imm_struct is not None:
            operand_size, operand, _ = imm_struct.from_raw(None, bytecode_wnd[1:])
            insn = inst_namedtuple(OPCODE_MAP[opcode_id], operand, 1 + operand_size)
            operand_interpretation = format_instruction(insn)
        insn_byte = bytecode_wnd[:1 + operand_size].tobytes()
        instruction = WasmInstruction(opcode_id, name, imm_struct, operand_size,
                                      insn_byte, pops, pushes, description,
                                      operand_interpretation=operand_interpretation,
                                      offset=offset)
        # print('%d %s' % (offset, str(instruction)))
        return instruction

    def disassemble(self, bytecode=None, offset=0, r_format='list'):
        """Disassemble WASM bytecode

        :param bytecode: bytecode sequence
        :param offset: start offset
        :param r_format: output format ('list'/'text'/'reverse')
        :type bytecode: bytes, str
        :type offset: int
        :type r_format: list, str, dict
        :return: dissassembly result depending of r_format
        :rtype: list, str, dict

        :Example:

        >>> disasm = WasmDisassembler()
        >>>
        >>> disasm.disassemble(r_format='text')
        >>> 'block -1\ni32.const 24\ncall 28\ni32.const 0\nreturn\nend'
        >>>
        >>> disasm.disassemble(r_format='text')
        >>> [<octopus.arch.wasm.instruction.WasmInstruction at 0x7f80243120b8>,
             ...
             <octopus.arch.wasm.instruction.WasmInstruction at 0x7f8024312588>,
             <octopus.arch.wasm.instruction.WasmInstruction at 0x7f80243121d0>]
        >>>
        >>> disasm.disassemble(r_format='reverse')
        >>> {0: <octopus.arch.wasm.instruction.WasmInstruction at 0x7f8024319d68>,
             ...
             4: <octopus.arch.wasm.instruction.WasmInstruction at 0x7f802431fa58>,
             5: <octopus.arch.wasm.instruction.WasmInstruction at 0x7f802431fc18>}
        """

        return super().disassemble(bytecode, offset, r_format)

    def extract_functions_code(self, module_bytecode):
        functions = list()
        mod_iter = iter(decode_module(module_bytecode))
        _, _ = next(mod_iter)
        sections = list(mod_iter)

        # iterate over all section
        #code_data = [cur_sec_data for cur_sec, cur_sec_data in sections if isinstance(cur_sec_data.get_decoder_meta()['types']['payload'], CodeSection)][0]
        for cur_sec, cur_sec_data in sections:
            sec = cur_sec_data.get_decoder_meta()['types']['payload']
            if isinstance(sec, CodeSection):
                code_data = cur_sec_data
                break
        if not code_data:
            raise ValueError('No functions/codes in the module')
        for idx, func in enumerate(code_data.payload.bodies):
            instructions = self.disassemble(func.code.tobytes())
            cur_function = Function(0, instructions[0])
            cur_function.instructions = instructions

            functions.append(cur_function)
        return functions

    def disassemble_module(self, module_bytecode=None, offset=0, r_format='list'):

        bytecode = bytecode_to_bytes(module_bytecode)

        functions = self.extract_functions_code(bytecode[offset:])
        self.instructions = [f.instructions for f in functions]

        # return instructions
        if r_format == 'list':
            return self.instructions
        elif r_format == 'text':
            text = ''
            for index, func in enumerate(functions):
                text += ('func %d\n' % index)
                text += ('\n'.join(map(str, func.instructions)))
                text += ('\n\n')
            return text

'''
'''--- octopus/arch/wasm/emulator.py ---
from octopus.engine.emulator import EmulatorEngine
from octopus.arch.wasm.cfg import WasmCFG
from octopus.arch.wasm.vmstate import WasmVMstate
from octopus.core.ssa import SSA, SSA_TYPE_FUNCTION, SSA_TYPE_CONSTANT

from octopus.arch.wasm.format import (format_func_name,
                                      format_bb_name)

import copy

from logging import getLogger
logging = getLogger(__name__)

# =======================================
# #         WASM Emulator               #
# =======================================

class WasmEmulatorEngine(EmulatorEngine):

    def __init__(self, bytecode):
        raise NotImplementedError

class WasmSSAEmulatorEngine(EmulatorEngine):

    def __init__(self, bytecode):

        # retrive instructions, basicblocks & functions statically
        self.cfg = WasmCFG(bytecode)
        self.ana = self.cfg.analyzer

        self.current_function = None
        self.current_f_instructions = None
        self.reverse_instructions = dict()
        self.current_f_basicblocks = None

        self.basicblock_per_instr = dict()
        self.current_basicblock = None

        # connection between basicblocks
        # will be generate dynamically by the Emulator

        self.states = dict()
        self.states_total = 0
        self.ssa_counter = 0

        logging.warning("Function available: %s" % [x.name for x in self.cfg.functions])

    def emulate_functions(self, list_functions_name=None, state=WasmVMstate(), depth=0):

        if list_functions_name:
            if set(list_functions_name).issubset([x.name for x in self.cfg.functions]):  # function_name not in [x.name for x in self.functions]:
                raise Exception('Some function_name given not in this module - available: %s', self.ana.func_prototypes)
        else:
            list_functions_name = [x.name for x in self.cfg.functions]
        for f in list_functions_name:
            self.emulate_one_function(function_name=f, state=state, depth=depth)

    def emulate_one_function(self, function_name, state=WasmVMstate(), depth=0):

        if function_name not in [x.name for x in self.cfg.functions]:
            raise Exception('function_name not in this module - available: %s', self.ana.func_prototypes)

        self.current_function = self.cfg.get_function(function_name)
        self.current_f_instructions = self.current_function.instructions
        self.reverse_instructions = {k: v for k, v in enumerate(self.current_f_instructions)}
        self.current_f_basicblocks = self.current_function.basicblocks

        # create dict with:
        # * key = instruction offset
        # * value = basicblock reference
        # easy to get the corresponding basicblock per instr now
        for bb in self.current_f_basicblocks:
            for intr in bb.instructions:
                self.basicblock_per_instr[intr.offset] = bb

        # connection between basicblocks
        # will be generate dynamically by the Emulator

        self.states = dict()
        self.states_total = 0
        self.ssa_counter = 0

        logging.warning("[+] current_function detected - %x: %s/%s",
                        self.current_function.start_offset,
                        self.current_function.name,
                        self.current_function.prefered_name)

        # launch emulation
        self.emulate(state=state, depth=depth)

    def emulate(self, state=WasmVMstate(), depth=0):

        #  create fake stack for tests
        state.symbolic_stack = list(range(1000))

        # get current instruction
        instr = self.reverse_instructions[state.pc]

        # create the first basicblock of this branch
        # print('%d : %s' % (instr.offset, instr.name))
        self.current_basicblock = self.basicblock_per_instr[instr.offset]

        # beginning of a function
        #if instr in self.functions_start_instr:
            # retrive matching function
        #    self.current_function = next(filter(lambda f: f.start_instr == instr, self.functions))
            # self.ssa_counter = 0
        logging.warning("[+] Entering function - %x: %s",
                        self.current_function.start_offset,
                        self.current_function.prefered_name)

        # associate function to basicblock
        # TODO: create list of function_name
        self.current_basicblock.function_name = self.current_function.prefered_name
        # associate basicblock to function
        self.current_function.basicblocks.append(self.current_basicblock)

        # halt variable use to catch ending branch
        halt = False
        while not halt:

            # get current instruction
            instr = self.reverse_instructions[state.pc]

            # get current basicblock
            self.current_basicblock = self.basicblock_per_instr[instr.offset]

            # add this instruction to his functions
            # TODO: verify if it's not useless for ethereum
            #self.current_function.instructions.append(instr)

            # Save instruction and state
            state.instr = instr
            self.states[self.states_total] = state
            state = copy.deepcopy(state)
            self.states_total += 1
            state.pc += 1

            # execute single instruction
            halt = self.emulate_one_instruction(instr, state, depth)
            state.instructions_visited.append(instr.offset)
            #state.instructions_visited[instr.offset] = instr.offset

        logging.warning("[X] Returning from basicblock %s", self.current_basicblock.name)

        # automatic remove duplicated edges
        #self.edges = list(set(self.edges))
    '''
    is_control
    is_parametric
    is_variable
    is_memory
    is_constant
    is_logical_i32
    is_logical_i64
    is_logical_f32
    is_logical_f64
    is_arithmetic_i32
    is_bitwise_i32
    is_arithmetic_i64
    is_bitwise_i64
    is_arithmetic_f32
    is_arithmetic_f64
    is_conversion
    '''

    def emulate_one_instruction(self, instr, state, depth):

        halt = False

        logging.debug('--')
        logging.debug('stack %s' % state.ssa_stack)
        logging.debug('instr %s' % instr.name)
        logging.debug('operand %s' % instr.operand)
        logging.debug('xref %s' % instr.xref)

        if instr.is_control:
            halt = self.emul_control_instr(instr, state, depth)

        elif instr.is_parametric:
            halt = self.emul_parametric_instr(instr, state)

        elif instr.is_variable:
            halt = self.emul_variable_instr(instr, state)

        elif instr.is_memory:
            halt = self.emul_memory_instr(instr, state)

        elif instr.is_constant:
            halt = self.emul_constant_instr(instr, state)

        elif instr.is_logical_i32:
            halt = self.emul_logical_i32_instr(instr, state)

        elif instr.is_logical_i64:
            halt = self.emul_logical_i64_instr(instr, state)

        elif instr.is_logical_f32:
            halt = self.emul_logical_f32_instr(instr, state)

        elif instr.is_logical_f64:
            halt = self.emul_logical_f64_instr(instr, state)

        elif instr.is_arithmetic_i32:
            halt = self.emul_arithmetic_i32_instr(instr, state)

        elif instr.is_bitwise_i32:
            halt = self.emul_bitwise_i32_instr(instr, state)

        elif instr.is_arithmetic_i64:
            halt = self.emul_arithmetic_i64_instr(instr, state)

        elif instr.is_bitwise_i64:
            halt = self.emul_bitwise_i64_instr(instr, state)

        elif instr.is_arithmetic_f32:
            halt = self.emul_arithmetic_f32_instr(instr, state)

        elif instr.is_arithmetic_f64:
            halt = self.emul_arithmetic_f64_instr(instr, state)

        elif instr.is_conversion:
            halt = self.emul_conversion_instr(instr, state)

        # UNKNOWN INSTRUCTION
        else:
            logging.warning('UNKNOWN = ' + instr.name)

        return halt

    def emul_control_instr(self, instr, state, depth):
        halt = False
        if instr.name == 'unreachable':
            instr.ssa = SSA(method_name=instr.name)
            halt = True
        elif instr.name in ['nop', 'block', 'loop', 'else']:
            instr.ssa = SSA(method_name=instr.name)
        elif instr.name == 'if':
            arg = [state.ssa_stack.pop()]
            instr.ssa = SSA(method_name=instr.name, args=arg)
            # TODO branch if
            # inst + 1 == true block
            # need to find offset false block using edges or basicblocks list
            if (instr.offset_end + 1) not in state.instructions_visited:
                logging.warning('[X]')
                logging.warning('[X] follow br_if default branch offset 0x%x' % (instr.offset_end + 1))
                new_state = copy.deepcopy(state)

                self.emulate(new_state, depth=depth + 1)
                # after we return from emul - restore current_basicblock
                self.current_basicblock = self.basicblock_per_instr[instr.offset]
                #state.instructions_visited += new_state.instructions_visited

            jump_addr = instr.xref
            # get instruction with this value as offset
            target = next(filter(lambda element: element.offset == jump_addr[0], self.current_f_instructions))

            if target.offset not in state.instructions_visited:
                # condition are True
                logging.warning('[X] follow br_if branch offset 0x%x' % (target.offset))
                new_state = copy.deepcopy(state)
                new_state.pc = self.current_f_instructions.index(target)

                # follow the br_if
                self.emulate(new_state, depth=depth + 1)

            else:
                logging.warning('[X] Loop detected, skipping br_if 0x%x' % jump_addr[0])
                halt = True
            halt = True
            logging.warning('SSA: branch if not yet supported')
        elif instr.name == 'end':
            instr.ssa = SSA(method_name=instr.name)
            # check if it's the last instructions of the function
            if instr.offset == self.current_f_instructions[-1].offset:
                logging.warning("[X] break %s" % instr.name)
                halt = True
        elif instr.name == 'br':
            instr.ssa = SSA(method_name=instr.name)
            jump_addr = instr.xref

            # get instruction with this value as offset
            target = next(filter(lambda element: element.offset == jump_addr[0], self.current_f_instructions))

            if target.offset not in state.instructions_visited:
                # condition are True
                logging.warning('[X] follow br branch offset 0x%x' % (target.offset))
                new_state = copy.deepcopy(state)
                new_state.pc = self.current_f_instructions.index(target)
                # follow the br
                self.emulate(new_state, depth=depth + 1)
            else:
                logging.warning('[X] Loop detected, skipping br 0x%x' % jump_addr[0])
                halt = True
            halt = True

        elif instr.name == 'br_if':
            arg = [state.ssa_stack.pop()]
            instr.ssa = SSA(method_name=instr.name, args=arg)

            #if (instr.offset_end + 1) not in state.instructions_visited:
            logging.warning('[X]')
            logging.warning('[X] follow br_if default branch offset 0x%x' % (instr.offset_end + 1))
            new_state = copy.deepcopy(state)

            self.emulate(new_state, depth=depth + 1)
            # after we return from emul - restore current_basicblock
            self.current_basicblock = self.basicblock_per_instr[instr.offset]
            #state.instructions_visited += new_state.instructions_visited

            jump_addr = instr.xref
            # get instruction with this value as offset
            target = next(filter(lambda element: element.offset == jump_addr[0], self.current_f_instructions))

            if target.offset not in state.instructions_visited:
                # condition are True
                logging.warning('[X] follow br_if branch offset 0x%x' % (target.offset))
                new_state = copy.deepcopy(state)
                new_state.pc = self.current_f_instructions.index(target)

                # follow the br_if
                self.emulate(new_state, depth=depth + 1)

            else:
                logging.warning('[X] Loop detected, skipping br_if 0x%x' % jump_addr[0])
                halt = True
            halt = True
        elif instr.name == 'br_table':
            arg = [state.ssa_stack.pop()]
            instr.ssa = SSA(method_name=instr.name, args=arg)
            # TODO branch br_table
            logging.warning('SSA: branch br_table not yet supported')
        elif instr.name == 'return':
            arg = [state.ssa_stack.pop()]
            instr.ssa = SSA(method_name=instr.name, args=arg)
            halt = True
        elif instr.name == 'call':
            f_offset = int(instr.operand_interpretation.split(' ')[1])
            target_func = self.ana.func_prototypes[f_offset]
            name, param_str, return_str, f_type = target_func
            # format_func_name()
            instr.ssa = SSA(method_name=instr.name + '_to_' + name)
            if param_str:
                num_arg = len(param_str.split(' '))
                #print(hex(state.ssa_stack[-1].offset))
                arg = [state.ssa_stack.pop() for x in range(1, num_arg+1)]
                instr.ssa.args = arg
            if return_str:
                instr.ssa.new_assignement = self.ssa_counter
                state.ssa_stack.append(instr)
                self.ssa_counter += 1
        elif instr.name == 'call_indirect':
            arg = [state.ssa_stack.pop()]
            ''' # issue when table is imported
            # arg is constant
            if arg[0].ssa.instr_type == SSA_TYPE_CONSTANT:
                f_offset = int.from_bytes(instr.operand, 'big')
                target_func = self.ana.func_prototypes[f_offset]

                name, param_str, return_str, f_type = target_func
                # format_func_name()
                instr.ssa = SSA(method_name=instr.name + '_to_' + name)
                if param_str:
                    num_arg = len(param_str.split(' '))
                    print(hex(state.ssa_stack[-1].offset))
                    arg = [state.ssa_stack.pop() for x in range(1, num_arg+1)]
                    instr.ssa.args = arg
                if return_str:
                    instr.ssa.new_assignement = self.ssa_counter
                    state.ssa_stack.append(instr)
                    self.ssa_counter += 1
            else:
            '''
            instr.ssa = SSA(method_name=instr.name, args=arg)
            # test if arg is constant --> do like call
            # else - stay like that
        return halt

    def emul_parametric_instr(self, instr, state):
        if instr.name == 'drop':
            state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name)
        else:  # select
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()]
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1
        return False

    def emul_variable_instr(self, instr, state):
        if instr.name in ['get_local', 'get_global']:
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1
        elif instr.name in ['set_local', 'set_global']:
            state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name)
        elif instr.name == 'tee_local':
            state.ssa_stack.append(state.ssa_stack[-1])
            self.ssa_counter += 1
        return False

    def emul_memory_instr(self, instr, state):
        # load
        if 'load' in instr.name:
            arg = [state.ssa_stack.pop()]
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif 'store' in instr.name:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
            instr.ssa = SSA(method_name=instr.name, args=arg)

        elif instr.name == 'current_memory':
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1
        else:
            instr.ssa = SSA(method_name=instr.name)
        return False

    def emul_constant_instr(self, instr, state):
        op = int.from_bytes(instr.operand, byteorder='big')
        instr.ssa = SSA(self.ssa_counter, instr.name,
                        op,
                        instr_type=SSA_TYPE_CONSTANT)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1
        return False

    def emul_logical_i32_instr(self, instr, state):
        if instr.name == 'i32.eqz':
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_logical_i64_instr(self, instr, state):
        if instr.name == 'i64.eqz':
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_logical_f32_instr(self, instr, state):
        arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_logical_f64_instr(self, instr, state):
        arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_arithmetic_i32_instr(self, instr, state):
        if instr.name in ['i32.clz', 'i32.ctz', 'i32.popcnt']:
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_bitwise_i32_instr(self, instr, state):
        arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_arithmetic_i64_instr(self, instr, state):
        if instr.name in ['i64.clz', 'i64.ctz', 'i64.popcnt']:
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_bitwise_i64_instr(self, instr, state):
        arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_arithmetic_f32_instr(self, instr, state):
        if instr.name in ['f32.abs', 'f32.neg']:
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_arithmetic_f64_instr(self, instr, state):
        if instr.name in ['f64.abs', 'f64.neg']:
            arg = [state.ssa_stack.pop()]
        else:
            arg = [state.ssa_stack.pop(), state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

    def emul_conversion_instr(self, instr, state):
        arg = [state.ssa_stack.pop()]
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=arg)
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

        return False

'''
'''--- octopus/arch/wasm/format.py ---
from octopus.arch.wasm.constant import LANG_TYPE

def format_func_name(name, param_str, return_str):
    result = '{} '.format(return_str) if return_str else ''
    return ('{}{}({})'.format(result, name, param_str))

def format_bb_name(function_id, offset):
    return ('block_%x_%x' % (function_id, offset))

def format_kind_function(f_type):
    return f_type

def format_kind_table(element_type, flags, initial, maximum):
    return {'element_type': LANG_TYPE.get(element_type),
            'limits_flags': flags,
            'limits_initial': initial,
            'limits_maximum': maximum}

def format_kind_memory(flags, initial, maximum):
    return {'limits_flags': flags,
            'limits_initial': initial,
            'limits_maximum': maximum}

def format_kind_global(content_type, mutability):
    return (content_type, mutability)

'''
'''--- octopus/arch/wasm/instruction.py ---
from octopus.core.instruction import Instruction
from octopus.arch.wasm.wasm import _groups

class WasmInstruction(Instruction):
    """Wasm Instruction
    TODO

    """
    def __init__(self, opcode, name, imm_struct, operand_size, insn_byte,
                 pops, pushes, description, operand_interpretation=None, offset=0):
        """ TODO """
        self.opcode = opcode
        self.offset = offset
        self.name = name
        self.description = description
        self.operand_size = operand_size
        if len(insn_byte) > 1:
            self.operand = insn_byte[-operand_size:]  # Immediate operand if any
        else:
            self.operand = None
            # specific interpretation of operand value
        self.operand_interpretation = operand_interpretation
        self.insn_byte = insn_byte
        self.pops = pops
        self.pushes = pushes
        self.imm_struct = imm_struct
        self.xref = list()
        self.ssa = None

    def __eq__(self, other):
        """ Instructions are equal if all features match  """
        return self.opcode == other.opcode and\
            self.name == other.name and\
            self.offset == other.offset and\
            self.insn_byte == other.insn_byte and\
            self.operand_size == other.operand_size and\
            self.pops == other.pops and\
            self.pushes == other.pushes and\
            self.operand_interpretation == other.operand_interpretation and\
            self.description == other.description

    def __str__(self):
        """ String representation of the instruction """
        if self.operand:
            return self.operand_interpretation
        # elif self.operand:
        #    return self.name + str(self.operand)
        else:
            return self.name

    @property
    def group(self):
        """ Instruction classification per group """
        last_class = _groups.get(0)
        for k, v in _groups.items():
            if self.opcode >= k:
                last_class = v
            else:
                return last_class
        return last_class

    @property
    def is_control(self):
        return self.group == 'Control'

    @property
    def is_parametric(self):
        return self.group == 'Parametric'

    @property
    def is_variable(self):
        return self.group == 'Variable'

    @property
    def is_memory(self):
        return self.group == 'Memory'

    @property
    def is_constant(self):
        return self.group == 'Constant'

    @property
    def is_logical_i32(self):
        return self.group == 'Logical_i32'

    @property
    def is_logical_i64(self):
        return self.group == 'Logical_i64'

    @property
    def is_logical_f32(self):
        return self.group == 'Logical_f32'

    @property
    def is_logical_f64(self):
        return self.group == 'Logical_f64'

    @property
    def is_arithmetic_i32(self):
        return self.group == 'Arithmetic_i32'

    @property
    def is_bitwise_i32(self):
        return self.group == 'Bitwise_i32'

    @property
    def is_arithmetic_i64(self):
        return self.group == 'Arithmetic_i64'

    @property
    def is_bitwise_i64(self):
        return self.group == 'Bitwise_i64'

    @property
    def is_arithmetic_f32(self):
        return self.group == 'Arithmetic_f32'

    @property
    def is_arithmetic_f64(self):
        return self.group == 'Arithmetic_f64'

    @property
    def is_conversion(self):
        return self.group == 'Conversion'

    @property
    def is_branch_conditional(self):
        """ Return True if the instruction is a conditional jump """
        return self.name in ['br_if', 'br_table', 'if']

    @property
    def is_branch_unconditional(self):
        """ Return True if the instruction is a unconditional jump """
        return self.name in ['br']

    @property
    def is_call(self):
        """ True if the instruction is a call instruction """
        return self.name in ['call', 'call_indirect']

    @property
    def is_branch(self):
        return self.is_branch_conditional or self.is_branch_unconditional

    @property
    def is_halt(self):
        """ Return True if the instruction is a branch terminator """
        return self.name in ['unreachable', 'return']

    @property
    def is_terminator(self):
        """ True if the instruction is a basic block terminator """
        return self.is_branch or self.is_halt

    @property
    def is_block_starter(self):
        """ Return True if the instruction is a basic block starter """
        return self.name in ['block', 'loop', 'if', 'else']

    @property
    def is_block_terminator(self):
        """ Return True if the instruction is a basic block terminator """
        return self.name in ['else', 'end']

'''
'''--- octopus/arch/wasm/signatures/emscripten_syscalls.json ---
{
    "syscall0": "restart_syscall",
    "syscall1": "exit",
    "syscall2": "fork",
    "syscall3": "read",
    "syscall4": "write",
    "syscall5": "open",
    "syscall6": "close",
    "syscall7": "waitpid",
    "syscall8": "creat",
    "syscall9": "link",
    "syscall10": "unlink",
    "syscall11": "execve",
    "syscall12": "chdir",
    "syscall13": "time",
    "syscall14": "mknod",
    "syscall15": "chmod",
    "syscall16": "lchown",
    "syscall17": "break",
    "syscall18": "oldstat",
    "syscall19": "lseek",
    "syscall20": "getpid",
    "syscall21": "mount",
    "syscall22": "umount",
    "syscall23": "setuid",
    "syscall24": "getuid",
    "syscall25": "stime",
    "syscall26": "ptrace",
    "syscall27": "alarm",
    "syscall28": "oldfstat",
    "syscall29": "pause",
    "syscall30": "utime",
    "syscall31": "stty",
    "syscall32": "gtty",
    "syscall33": "access",
    "syscall34": "nice",
    "syscall35": "ftime",
    "syscall36": "sync",
    "syscall37": "kill",
    "syscall38": "rename",
    "syscall39": "mkdir",
    "syscall40": "rmdir",
    "syscall41": "dup",
    "syscall42": "pipe",
    "syscall43": "times",
    "syscall44": "prof",
    "syscall45": "brk",
    "syscall46": "setgid",
    "syscall47": "getgid",
    "syscall48": "signal",
    "syscall49": "geteuid",
    "syscall50": "getegid",
    "syscall51": "acct",
    "syscall52": "umount2",
    "syscall53": "lock",
    "syscall54": "ioctl",
    "syscall55": "fcntl",
    "syscall56": "mpx",
    "syscall57": "setpgid",
    "syscall58": "ulimit",
    "syscall59": "oldolduname",
    "syscall60": "umask",
    "syscall61": "chroot",
    "syscall62": "ustat",
    "syscall63": "dup2",
    "syscall64": "getppid",
    "syscall65": "getpgrp",
    "syscall66": "setsid",
    "syscall67": "sigaction",
    "syscall68": "sgetmask",
    "syscall69": "ssetmask",
    "syscall70": "setreuid",
    "syscall71": "setregid",
    "syscall72": "sigsuspend",
    "syscall73": "sigpending",
    "syscall74": "sethostname",
    "syscall75": "setrlimit",
    "syscall76": "getrlimit",
    "syscall77": "getrusage",
    "syscall78": "gettimeofday",
    "syscall79": "settimeofday",
    "syscall80": "getgroups",
    "syscall81": "setgroups",
    "syscall82": "select",
    "syscall83": "symlink",
    "syscall84": "oldlstat",
    "syscall85": "readlink",
    "syscall86": "uselib",
    "syscall87": "swapon",
    "syscall88": "reboot",
    "syscall89": "readdir",
    "syscall90": "mmap",
    "syscall91": "munmap",
    "syscall92": "truncate",
    "syscall93": "ftruncate",
    "syscall94": "fchmod",
    "syscall95": "fchown",
    "syscall96": "getpriority",
    "syscall97": "setpriority",
    "syscall98": "profil",
    "syscall99": "statfs",
    "syscall100": "fstatfs",
    "syscall101": "ioperm",
    "syscall102": "socketcall",
    "syscall103": "syslog",
    "syscall104": "setitimer",
    "syscall105": "getitimer",
    "syscall106": "stat",
    "syscall107": "lstat",
    "syscall108": "fstat",
    "syscall109": "olduname",
    "syscall110": "iopl",
    "syscall111": "vhangup",
    "syscall112": "idle",
    "syscall113": "vm86old",
    "syscall114": "wait4",
    "syscall115": "swapoff",
    "syscall116": "sysinfo",
    "syscall117": "ipc",
    "syscall118": "fsync",
    "syscall119": "sigreturn",
    "syscall120": "clone",
    "syscall121": "setdomainname",
    "syscall122": "uname",
    "syscall123": "modify_ldt",
    "syscall124": "adjtimex",
    "syscall125": "mprotect",
    "syscall126": "sigprocmask",
    "syscall127": "create_module",
    "syscall128": "init_module",
    "syscall129": "delete_module",
    "syscall130": "get_kernel_syms",
    "syscall131": "quotactl",
    "syscall132": "getpgid",
    "syscall133": "fchdir",
    "syscall134": "bdflush",
    "syscall135": "sysfs",
    "syscall136": "personality",
    "syscall137": "afs_syscall",
    "syscall138": "setfsuid",
    "syscall139": "setfsgid",
    "syscall140": "_llseek",
    "syscall141": "getdents",
    "syscall142": "_newselect",
    "syscall143": "flock",
    "syscall144": "msync",
    "syscall145": "readv",
    "syscall146": "writev",
    "syscall147": "getsid",
    "syscall148": "fdatasync",
    "syscall149": "_sysctl",
    "syscall150": "mlock",
    "syscall151": "munlock",
    "syscall152": "mlockall",
    "syscall153": "munlockall",
    "syscall154": "sched_setparam",
    "syscall155": "sched_getparam",
    "syscall156": "sched_setscheduler",
    "syscall157": "sched_getscheduler",
    "syscall158": "sched_yield",
    "syscall159": "sched_get_priority_max",
    "syscall160": "sched_get_priority_min",
    "syscall161": "sched_rr_get_interval",
    "syscall162": "nanosleep",
    "syscall163": "mremap",
    "syscall164": "setresuid",
    "syscall165": "getresuid",
    "syscall166": "vm86",
    "syscall167": "query_module",
    "syscall168": "poll",
    "syscall169": "nfsservctl",
    "syscall170": "setresgid",
    "syscall171": "getresgid",
    "syscall172": "prctl",
    "syscall173": "rt_sigreturn",
    "syscall174": "rt_sigaction",
    "syscall175": "rt_sigprocmask",
    "syscall176": "rt_sigpending",
    "syscall177": "rt_sigtimedwait",
    "syscall178": "rt_sigqueueinfo",
    "syscall179": "rt_sigsuspend",
    "syscall180": "pread64",
    "syscall181": "pwrite64",
    "syscall182": "chown",
    "syscall183": "getcwd",
    "syscall184": "capget",
    "syscall185": "capset",
    "syscall186": "sigaltstack",
    "syscall187": "sendfile",
    "syscall188": "getpmsg",
    "syscall189": "putpmsg",
    "syscall190": "vfork",
    "syscall191": "ugetrlimit",
    "syscall192": "mmap2",
    "syscall193": "truncate64",
    "syscall194": "ftruncate64",
    "syscall195": "stat64",
    "syscall196": "lstat64",
    "syscall197": "fstat64",
    "syscall198": "lchown32",
    "syscall199": "getuid32",
    "syscall200": "getgid32",
    "syscall201": "geteuid32",
    "syscall202": "getegid32",
    "syscall203": "setreuid32",
    "syscall204": "setregid32",
    "syscall205": "getgroups32",
    "syscall206": "setgroups32",
    "syscall207": "fchown32",
    "syscall208": "setresuid32",
    "syscall209": "getresuid32",
    "syscall210": "setresgid32",
    "syscall211": "getresgid32",
    "syscall212": "chown32",
    "syscall213": "setuid32",
    "syscall214": "setgid32",
    "syscall215": "setfsuid32",
    "syscall216": "setfsgid32",
    "syscall217": "pivot_root",
    "syscall218": "mincore",
    "syscall219": "madvise",
    "syscall220": "getdents64",
    "syscall221": "fcntl64",
    "syscall224": "gettid",
    "syscall225": "readahead",
    "syscall226": "setxattr",
    "syscall227": "lsetxattr",
    "syscall228": "fsetxattr",
    "syscall229": "getxattr",
    "syscall230": "lgetxattr",
    "syscall231": "fgetxattr",
    "syscall232": "listxattr",
    "syscall233": "llistxattr",
    "syscall234": "flistxattr",
    "syscall235": "removexattr",
    "syscall236": "lremovexattr",
    "syscall237": "fremovexattr",
    "syscall238": "tkill",
    "syscall239": "sendfile64",
    "syscall240": "futex",
    "syscall241": "sched_setaffinity",
    "syscall242": "sched_getaffinity",
    "syscall243": "set_thread_area",
    "syscall244": "get_thread_area",
    "syscall245": "io_setup",
    "syscall246": "io_destroy",
    "syscall247": "io_getevents",
    "syscall248": "io_submit",
    "syscall249": "io_cancel",
    "syscall250": "fadvise64",
    "syscall252": "exit_group",
    "syscall253": "lookup_dcookie",
    "syscall254": "epoll_create",
    "syscall255": "epoll_ctl",
    "syscall256": "epoll_wait",
    "syscall257": "remap_file_pages",
    "syscall258": "set_tid_address",
    "syscall259": "timer_create",
    "syscall260": "timer_settime",
    "syscall261": "timer_gettime",
    "syscall262": "timer_getoverrun",
    "syscall263": "timer_delete",
    "syscall264": "clock_settime",
    "syscall265": "clock_gettime",
    "syscall266": "clock_getres",
    "syscall267": "clock_nanosleep",
    "syscall268": "statfs64",
    "syscall269": "fstatfs64",
    "syscall270": "tgkill",
    "syscall271": "utimes",
    "syscall272": "fadvise64_64",
    "syscall273": "vserver",
    "syscall274": "mbind",
    "syscall275": "get_mempolicy",
    "syscall276": "set_mempolicy",
    "syscall277": "mq_open",
    "syscall278": "mq_unlink",
    "syscall279": "mq_timedsend",
    "syscall280": "mq_timedreceive",
    "syscall281": "mq_notify",
    "syscall282": "mq_getsetattr",
    "syscall283": "kexec_load",
    "syscall284": "waitid",
    "syscall286": "add_key",
    "syscall287": "request_key",
    "syscall288": "keyctl",
    "syscall289": "ioprio_set",
    "syscall290": "ioprio_get",
    "syscall291": "inotify_init",
    "syscall292": "inotify_add_watch",
    "syscall293": "inotify_rm_watch",
    "syscall294": "migrate_pages",
    "syscall295": "openat",
    "syscall296": "mkdirat",
    "syscall297": "mknodat",
    "syscall298": "fchownat",
    "syscall299": "futimesat",
    "syscall300": "fstatat64",
    "syscall301": "unlinkat",
    "syscall302": "renameat",
    "syscall303": "linkat",
    "syscall304": "symlinkat",
    "syscall305": "readlinkat",
    "syscall306": "fchmodat",
    "syscall307": "faccessat",
    "syscall308": "pselect6",
    "syscall309": "ppoll",
    "syscall310": "unshare",
    "syscall311": "set_robust_list",
    "syscall312": "get_robust_list",
    "syscall313": "splice",
    "syscall314": "sync_file_range",
    "syscall315": "tee",
    "syscall316": "vmsplice",
    "syscall317": "move_pages",
    "syscall318": "getcpu",
    "syscall319": "epoll_pwait",
    "syscall320": "utimensat",
    "syscall321": "signalfd",
    "syscall322": "timerfd_create",
    "syscall323": "eventfd",
    "syscall324": "fallocate",
    "syscall325": "timerfd_settime",
    "syscall326": "timerfd_gettime",
    "syscall327": "signalfd4",
    "syscall328": "eventfd2",
    "syscall329": "epoll_create1",
    "syscall330": "dup3",
    "syscall331": "pipe2",
    "syscall332": "inotify_init1",
    "syscall333": "preadv",
    "syscall334": "pwritev",
    "syscall335": "rt_tgsigqueueinfo",
    "syscall336": "perf_event_open",
    "syscall337": "recvmmsg",
    "syscall338": "fanotify_init",
    "syscall339": "fanotify_mark",
    "syscall340": "prlimit64",
    "syscall341": "name_to_handle_at",
    "syscall342": "open_by_handle_at",
    "syscall343": "clock_adjtime",
    "syscall344": "syncfs",
    "syscall345": "sendmmsg",
    "syscall346": "setns",
    "syscall347": "process_vm_readv",
    "syscall348": "process_vm_writev",
    "syscall349": "kcmp",
    "syscall350": "finit_module"
}
'''
'''--- octopus/arch/wasm/vmstate.py ---
from octopus.engine.engine import VMstate

class WasmVMstate(VMstate):

    def __init__(self):

        self.memory = []

        self.stack = []
        self.ssa_stack = []
        self.symbolic_stack = []

        self.last_returned = []
        self.pc = 0
        self.instr = None

        self.instructions_visited = list()
        #self.instructions_visited = dict()

    def details(self):

        return {'memory': self.memory,
                'stack': self.stack,
                'ssa_stack': self.ssa_stack,
                'symbolic_stack': self.symbolic_stack,
                'last_returned': self.last_returned,
                'pc': self.pc}

'''
'''--- octopus/arch/wasm/wasm.py ---
# extract from:
# * https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md
# * https://webassembly.github.io/spec/core/binary/instructions.html
# * https://github.com/athre0z/wasm/blob/master/wasm/opcodes.py

from wasm.immtypes import *

_groups = {0x00: 'Control',
           0x1A: 'Parametric',
           0x20: 'Variable',
           0x28: 'Memory',
           0x41: 'Constant',
           0x45: 'Logical_i32',
           0x50: 'Logical_i64',
           0x5b: 'Logical_f32',
           0x61: 'Logical_f64',
           0x67: 'Arithmetic_i32',
           0x71: 'Bitwise_i32',
           0x79: 'Arithmetic_i64',
           0x83: 'Bitwise_i64',
           0x8b: 'Arithmetic_f32',
           0x99: 'Arithmetic_f64',
           0xa7: 'Conversion'}

_table = {
    # opcode:(mnemonic/name, imm_struct, pops, pushes, description)
    0x00: ('unreachable', None, 0, 0, 'trap immediately'),
    0x01: ('nop', None, 0, 0, 'no operation'),
    0x02: ('block', BlockImm(), 0, 0, 'begin a sequence of expressions'),
    0x03: ('loop', BlockImm(), 0, 0, 'begin a block which can also form control flow loops'),
    0x04: ('if', BlockImm(), 1, 0, 'begin if expression'),
    0x05: ('else', None, 0, 0, 'begin else expression of if'),
    0x0b: ('end', None, 0, 0, 'end a block, loop, or if'),
    0x0c: ('br', BranchImm(), 0, 0, 'break that targets an outer nested block'),
    0x0d: ('br_if', BranchImm(), 1, 0, 'conditional break that targets an outer nested block'),
    0x0e: ('br_table', BranchTableImm(), 1, 0, 'branch table control flow construct'),
    0x0f: ('return', None, 1, 0, 'return zero or one value from this function'),
    0x10: ('call', CallImm(), 0, 0, 'call a function by its index'),#TODO:the actual pops and pushes would be determined dynamically by the signature of the function called
    0x11: ('call_indirect', CallIndirectImm(), 1, 0, 'call a function indirect with an expected signature'),

    0x1a: ('drop', None, 1, 0, 'ignore value'),
    0x1b: ('select', None, 3, 1, 'select one of two values based on condition'),

    0x20: ('get_local', LocalVarXsImm(), 0, 1, 'read a local variable or parameter'),
    0x21: ('set_local', LocalVarXsImm(), 1, 0, 'write a local variable or parameter'),
    0x22: ('tee_local', LocalVarXsImm(), 1, 1, 'write a local variable or parameter and read the same value'),
    0x23: ('get_global', GlobalVarXsImm(), 0, 1, 'read a global variable'),
    0x24: ('set_global', GlobalVarXsImm(), 1, 0, 'write a global variable'),

    0x28: ('i32.load', MemoryImm(), 1, 1, 'load from memory'),
    0x29: ('i64.load', MemoryImm(), 1, 1, 'load from memory'),
    0x2a: ('f32.load', MemoryImm(), 1, 1, 'load from memory'),
    0x2b: ('f64.load', MemoryImm(), 1, 1, 'load from memory'),
    0x2c: ('i32.load8_s', MemoryImm(), 1, 1, 'load from memory'),
    0x2d: ('i32.load8_u', MemoryImm(), 1, 1, 'load from memory'),
    0x2e: ('i32.load16_s', MemoryImm(), 1, 1, 'load from memory'),
    0x2f: ('i32.load16_u', MemoryImm(), 1, 1, 'load from memory'),
    0x30: ('i64.load8_s', MemoryImm(), 1, 1, 'load from memory'),
    0x31: ('i64.load8_u', MemoryImm(), 1, 1, 'load from memory'),
    0x32: ('i64.load16_s', MemoryImm(), 1, 1, 'load from memory'),
    0x33: ('i64.load16_u', MemoryImm(), 1, 1, 'load from memory'),
    0x34: ('i64.load32_s', MemoryImm(), 1, 1, 'load from memory'),
    0x35: ('i64.load32_u', MemoryImm(), 1, 1, 'load from memory'),
    0x36: ('i32.store', MemoryImm(), 2, 0, 'store to memory'),
    0x37: ('i64.store', MemoryImm(), 2, 0, 'store to memory'),
    0x38: ('f32.store', MemoryImm(), 2, 0, 'store to memory'),
    0x39: ('f64.store', MemoryImm(), 2, 0, 'store to memory'),
    0x3a: ('i32.store8', MemoryImm(), 2, 0, 'store to memory'),
    0x3b: ('i32.store16', MemoryImm(), 2, 0, 'store to memory'),
    0x3c: ('i64.store8', MemoryImm(), 2, 0, 'store to memory'),
    0x3d: ('i64.store16', MemoryImm(), 2, 0, 'store to memory'),
    0x3e: ('i64.store32', MemoryImm(), 2, 0, 'store to memory'),
    0x3f: ('current_memory', CurGrowMemImm(), 0, 1, 'query the size of memory'),
    0x40: ('grow_memory', CurGrowMemImm(), 0, 0, 'grow the size of memory'),

    0x41: ('i32.const', I32ConstImm(), 0, 1, 'a constant value interpreted as i32'),
    0x42: ('i64.const', I64ConstImm(), 0, 1, 'a constant value interpreted as i64'),
    0x43: ('f32.const', F32ConstImm(), 0, 1, 'a constant value interpreted as f32'),
    0x44: ('f64.const', F64ConstImm(), 0, 1, 'a constant value interpreted as f64'),

    0x45: ('i32.eqz', None, 1, 1, 'compare equal to zero (return 1 if operand is zero, 0 otherwise)'),
    0x46: ('i32.eq', None, 2, 1, 'sign-agnostic compare equal'),
    0x47: ('i32.ne', None, 2, 1, 'sign-agnostic compare unequal'),
    0x48: ('i32.lt_s', None, 2, 1, 'signed less than'),
    0x49: ('i32.lt_u', None, 2, 1, 'unsigned less than'),
    0x4a: ('i32.gt_s', None, 2, 1, 'signed greater than'),
    0x4b: ('i32.gt_u', None, 2, 1, 'unsigned greater than'),
    0x4c: ('i32.le_s', None, 2, 1, 'signed less than or equal'),
    0x4d: ('i32.le_u', None, 2, 1, 'unsigned less than or equal'),
    0x4e: ('i32.ge_s', None, 2, 1, 'signed greater than or equal'),
    0x4f: ('i32.ge_u', None, 2, 1, 'unsigned greater than or equal'),

    0x50: ('i64.eqz', None, 1, 1, 'compare equal to zero (return 1 if operand is zero, 0 otherwise)'),
    0x51: ('i64.eq', None, 2, 1, 'sign-agnostic compare equal'),
    0x52: ('i64.ne', None, 2, 1, 'sign-agnostic compare unequal'),
    0x53: ('i64.lt_s', None, 2, 1, 'signed less than'),
    0x54: ('i64.lt_u', None, 2, 1, 'unsigned less than'),
    0x55: ('i64.gt_s', None, 2, 1, 'signed greater than'),
    0x56: ('i64.gt_u', None, 2, 1, 'unsigned greater than'),
    0x57: ('i64.le_s', None, 2, 1, 'signed less than or equal'),
    0x58: ('i64.le_u', None, 2, 1, 'unsigned less than or equal'),
    0x59: ('i64.ge_s', None, 2, 1, 'signed greater than or equal'),
    0x5a: ('i64.ge_u', None, 2, 1, 'unsigned greater than or equal'),

    0x5b: ('f32.eq', None, 2, 1, 'compare ordered and equal'),
    0x5c: ('f32.ne', None, 2, 1, 'compare unordered or unequal'),
    0x5d: ('f32.lt', None, 2, 1, 'compare ordered and less than'),
    0x5e: ('f32.gt', None, 2, 1, 'compare ordered and less than or equal'),
    0x5f: ('f32.le', None, 2, 1, 'compare ordered and greater than'),
    0x60: ('f32.ge', None, 2, 1, 'compare ordered and greater than or equal'),

    0x61: ('f64.eq', None, 2, 1, 'compare ordered and equal'),
    0x62: ('f64.ne', None, 2, 1, 'compare unordered or unequal'),
    0x63: ('f64.lt', None, 2, 1, 'compare ordered and less than'),
    0x64: ('f64.gt', None, 2, 1, 'compare ordered and less than or equal'),
    0x65: ('f64.le', None, 2, 1, 'compare ordered and greater than'),
    0x66: ('f64.ge', None, 2, 1, 'compare ordered and greater than or equal'),

    0x67: ('i32.clz', None, 1, 1, 'sign-agnostic count leading zero bits (All zero bits are considered leading if the value is zero)'),
    0x68: ('i32.ctz', None, 1, 1, 'sign-agnostic count trailing zero bits (All zero bits are considered trailing if the value is zero)'),
    0x69: ('i32.popcnt', None, 1, 1, 'sign-agnostic count number of one bits'),
    0x6a: ('i32.add', None, 2, 1, 'sign-agnostic addition'),
    0x6b: ('i32.sub', None, 2, 1, 'sign-agnostic subtraction'),
    0x6c: ('i32.mul', None, 2, 1, 'sign-agnostic multiplication (lower 32-bits)'),
    0x6d: ('i32.div_s', None, 2, 1, 'signed division (result is truncated toward zero)'),
    0x6e: ('i32.div_u', None, 2, 1, 'unsigned division (result is floored)'),
    0x6f: ('i32.rem_s', None, 2, 1, 'signed remainder (result has the sign of the dividend)'),
    0x70: ('i32.rem_u', None, 2, 1, 'unsigned remainder'),

    0x71: ('i32.and', None, 2, 1, 'sign-agnostic bitwise and'),
    0x72: ('i32.or', None, 2, 1, 'sign-agnostic bitwise inclusive or'),
    0x73: ('i32.xor', None, 2, 1, 'sign-agnostic bitwise exclusive or'),
    0x74: ('i32.shl', None, 2, 1, 'sign-agnostic shift left'),
    0x75: ('i32.shr_s', None, 2, 1, 'sign-replicating (arithmetic) shift right'),
    0x76: ('i32.shr_u', None, 2, 1, 'zero-replicating (logical) shift right'),
    0x77: ('i32.rotl', None, 2, 1, 'sign-agnostic rotate left'),
    0x78: ('i32.rotr', None, 2, 1, 'sign-agnostic rotate right'),

    0x79: ('i64.clz', None, 1, 1, 'sign-agnostic count leading zero bits (All zero bits are considered leading if the value is zero)'),
    0x7a: ('i64.ctz', None, 1, 1, 'sign-agnostic count trailing zero bits (All zero bits are considered trailing if the value is zero)'),
    0x7b: ('i64.popcnt', None, 1, 1, 'sign-agnostic count number of one bits'),
    0x7c: ('i64.add', None, 2, 1, 'sign-agnostic addition'),
    0x7d: ('i64.sub', None, 2, 1, 'sign-agnostic subtraction'),
    0x7e: ('i64.mul', None, 2, 1, 'sign-agnostic multiplication (lower 32-bits)'),
    0x7f: ('i64.div_s', None, 2, 1, 'signed division (result is truncated toward zero)'),
    0x80: ('i64.div_u', None, 2, 1, 'unsigned division (result is floored)'),
    0x81: ('i64.rem_s', None, 2, 1, 'signed remainder (result has the sign of the dividend)'),
    0x82: ('i64.rem_u', None, 2, 1, 'unsigned remainder'),

    0x83: ('i64.and', None, 2, 1, 'sign-agnostic bitwise and'),
    0x84: ('i64.or', None, 2, 1, 'sign-agnostic bitwise inclusive or'),
    0x85: ('i64.xor', None, 2, 1, 'sign-agnostic bitwise exclusive or'),
    0x86: ('i64.shl', None, 2, 1, 'sign-agnostic shift left'),
    0x87: ('i64.shr_s', None, 2, 1, 'sign-replicating (arithmetic) shift right'),
    0x88: ('i64.shr_u', None, 2, 1, 'zero-replicating (logical) shift right'),
    0x89: ('i64.rotl', None, 2, 1, 'sign-agnostic rotate left'),
    0x8a: ('i64.rotr', None, 2, 1, 'sign-agnostic rotate right'),

    0x8b: ('f32.abs', None, 1, 1, 'absolute value'),
    0x8c: ('f32.neg', None, 1, 1, 'negation'),
    0x8d: ('f32.ceil', None, 2, 1, 'ceiling operator'),
    0x8e: ('f32.floor', None, 2, 1, 'floor operator'),
    0x8f: ('f32.trunc', None, 2, 1, 'round to nearest integer towards zero'),
    0x90: ('f32.nearest', None, 2, 1, 'round to nearest integer, ties to even'),
    0x91: ('f32.sqrt', None, 2, 1, 'square root'),
    0x92: ('f32.add', None, 2, 1, 'addition'),
    0x93: ('f32.sub', None, 2, 1, 'subtraction'),
    0x94: ('f32.mul', None, 2, 1, 'multiplication'),
    0x95: ('f32.div', None, 2, 1, 'division'),
    0x96: ('f32.min', None, 2, 1, 'minimum (binary operator); if either operand is NaN, returns NaN'),
    0x97: ('f32.max', None, 2, 1, 'maximum (binary operator); if either operand is NaN, returns NaN'),
    0x98: ('f32.copysign', None, 2, 1, 'copysign'),

    0x99: ('f64.abs', None, 1, 1, 'absolute value'),
    0x9a: ('f64.neg', None, 1, 1, 'negation'),
    0x9b: ('f64.ceil', None, 2, 1, 'ceiling operator'),
    0x9c: ('f64.floor', None, 2, 1, 'floor operator'),
    0x9d: ('f64.trunc', None, 2, 1, 'round to nearest integer towards zero'),
    0x9e: ('f64.nearest', None, 2, 1, 'round to nearest integer, ties to even'),
    0x9f: ('f64.sqrt', None, 2, 1, 'square root'),
    0xa0: ('f64.add', None, 2, 1, 'addition'),
    0xa1: ('f64.sub', None, 2, 1, 'subtraction'),
    0xa2: ('f64.mul', None, 2, 1, 'multiplication'),
    0xa3: ('f64.div', None, 2, 1, 'division'),
    0xa4: ('f64.min', None, 2, 1, 'minimum (binary operator); if either operand is NaN, returns NaN'),
    0xa5: ('f64.max', None, 2, 1, 'maximum (binary operator); if either operand is NaN, returns NaN'),
    0xa6: ('f64.copysign', None, 2, 1, 'copysign'),

    0xa7: ('i32.wrap/i64', None, 1, 1, 'wrap a 64-bit integer to a 32-bit integer'),
    0xa8: ('i32.trunc_s/f32', None, 1, 1, 'truncate a 32-bit float to a signed 32-bit integer'),
    0xa9: ('i32.trunc_u/f32', None, 1, 1, 'truncate a 32-bit float to an unsigned 32-bit integer'),
    0xaa: ('i32.trunc_s/f64', None, 1, 1, 'truncate a 64-bit float to a signed 32-bit integer'),
    0xab: ('i32.trunc_u/f64', None, 1, 1, 'truncate a 64-bit float to an unsigned 32-bit integer'),
    0xac: ('i64.extend_s/i32', None, 1, 1, 'extend a signed 32-bit integer to a 64-bit integer'),
    0xad: ('i64.extend_u/i32', None, 1, 1, 'extend an unsigned 32-bit integer to a 64-bit integer'),
    0xae: ('i64.trunc_s/f32', None, 1, 1, 'truncate a 32-bit float to a signed 64-bit integer'),
    0xaf: ('i64.trunc_u/f32', None, 1, 1, 'truncate a 32-bit float to an unsigned 64-bit integer'),
    0xb0: ('i64.trunc_s/f64', None, 1, 1, 'truncate a 64-bit float to a signed 64-bit integer'),
    0xb1: ('i64.trunc_u/f64', None, 1, 1, 'truncate a 64-bit float to an unsigned 64-bit integer'),
    0xb2: ('f32.convert_s/i32', None, 1, 1, 'convert a signed 32-bit integer to a 32-bit float'),
    0xb3: ('f32.convert_u/i32', None, 1, 1, 'convert an unsigned 32-bit integer to a 32-bit float'),
    0xb4: ('f32.convert_s/i64', None, 1, 1, 'convert a signed 64-bit integer to a 32-bit float'),
    0xb5: ('f32.convert_u/i64', None, 1, 1, 'convert an unsigned 64-bit integer to a 32-bit float'),
    0xb6: ('f32.demote/f64', None, 1, 1, 'demote a 64-bit float to a 32-bit float'),
    0xb7: ('f64.convert_s/i32', None, 1, 1, 'convert a signed 32-bit integer to a 64-bit float'),
    0xb8: ('f64.convert_u/i32', None, 1, 1, 'convert an unsigned 32-bit integer to a 64-bit float'),
    0xb9: ('f64.convert_s/i64', None, 1, 1, 'convert a signed 64-bit integer to a 64-bit float'),
    0xba: ('f64.convert_u/i64', None, 1, 1, 'convert an unsigned 64-bit integer to a 64-bit float'),
    0xbb: ('f64.promote/f32', None, 1, 1, 'promote a 32-bit float to a 64-bit float'),
    0xbc: ('i32.reinterpret/f32', None, 1, 1, 'reinterpret the bits of a 32-bit float as a 32-bit integer'),
    0xbd: ('i64.reinterpret/f64', None, 1, 1, 'reinterpret the bits of a 64-bit float as a 64-bit integer'),
    0xbe: ('f32.reinterpret/i32', None, 1, 1, 'reinterpret the bits of a 32-bit integer as a 32-bit float'),
    0xbf: ('f64.reinterpret/i64', None, 1, 1, 'reinterpret the bits of a 64-bit integer as a 64-bit float'),
}

class Wasm(object):
    """Wasm bytecode."""

    def __init__(self):
        self.table = _table
        self.reverse_table = self._get_reverse_table()

    def _get_reverse_table(self):
        """Build an internal table used in the assembler."""
        # opcode:(mnemonic/name, imm_struct, pops, pushes, description)
        reverse_table = {}
        for (opcode, (mnemonic, imm_struct,
                      pops, pushes, description)) in self.table.items():
            reverse_table[mnemonic] = opcode, mnemonic, imm_struct, pops, pushes, description
        return reverse_table

'''
'''--- octopus/core/__init__.py ---

'''
'''--- octopus/core/basicblock.py ---
class BasicBlock(object):
    """
    """
    def __init__(self, start_offset=0x00, start_instr=None,
                 name='block_default_name'):
        self.start_offset = start_offset
        self.start_instr = start_instr
        self.name = name
        self.end_offset = start_offset
        self.end_instr = start_instr
        self.instructions = list()

        self.states = []
        self.function_name = "unknown"

    @property
    def size(self):
        return self.end_offset - self.start_offset

    def __str__(self):
        out = ''
        line = ''
        line = str(self.start_offset) + ': ' + str(self.name) + '\n'
        line += 'start_instr = ' + str(self.start_instr.name) + '\n'
        line += 'size = ' + str(self.size) + '\n'
        line += 'end_offset = ' + str(self.end_offset) + '\n'
        line += 'end_instr = ' + str(self.end_instr.name) + '\n'
        line += 'function_name = ' + str(self.function_name) + '\n'
        out += line + '\n\n'
        return out

    def instructions_details(self, format='hex'):
        out = ''
        line = ''
        for i in self.instructions:
            line = '%x: ' % i.offset
            if i.operand is not None and not i.xref:
                line += '%s' % str(i)
            elif isinstance(i.xref, list) and i.xref:
                line += '%s %s' % (i.name, i.xref)
            elif isinstance(i.xref, int) and i.xref:
                line += '%s %x' % (i.name, i.xref)
            elif i.operand_interpretation:
                line += i.operand_interpretation
            else:
                line += i.name + ' '

            out += line + '\n'
        return out

    def instructions_ssa(self, format='hex'):
        out = ''
        line = ''
        for i in self.instructions:
            line = '%x: ' % i.offset
            if i.ssa:
                line += '' + i.ssa.format()
            else:
                line += '[NO_SSA] ' + i.name
            out += line + '\n'
        return out

'''
'''--- octopus/core/contract.py ---
class Contract(object):

    def __init__(self, name="default_contract_name",
                 address=None, balance=None, bytecode=None,
                 abi=None, source_code=None):
        self.name = name
        self.address = address
        self.balance = balance
        self.bytecode = bytecode
        self.abi = abi
        self.source_code = source_code
        self.info = {}

    def get_online_bytecode(self, explorer):
        raise NotImplementedError

    def get_online_abi(self, explorer):
        raise NotImplementedError

    def get_online_source(self, explorer):
        raise NotImplementedError

    def get_online_info(self, explorer):
        raise NotImplementedError

'''
'''--- octopus/core/edge.py ---
EDGE_UNCONDITIONAL = 'unconditional'
EDGE_CONDITIONAL_TRUE = 'conditional_true'
EDGE_CONDITIONAL_FALSE = 'conditional_false'
EDGE_FALLTHROUGH = 'fallthrough'
EDGE_CALL = 'call'

class Edge:

    def __init__(self, node_from, node_to, edge_type=EDGE_UNCONDITIONAL,
                 condition=None):

        self.node_from = node_from
        self.node_to = node_to
        self.type = edge_type
        self.condition = condition

    def __str__(self):
        return str(self.as_dict())

    def __eq__(self, other):
        return self.node_from == other.node_from and\
            self.node_to == other.node_to and\
            self.type == other.type and\
            self.condition == other.condition

    def __hash__(self):
        return hash(('from', self.node_from,
                     'to', self.node_to,
                     'type', self.type,
                     'condition', self.condition))

    def as_dict(self):
        return {'from': str(self.node_from), 'to': str(self.node_to),
                'type': self.type, 'condition': self.condition}

'''
'''--- octopus/core/function.py ---
class Function(object):

    def __init__(self, start_offset, start_instr=None,
                 name='func_default_name', prefered_name=None):
        # parameters
        self.start_offset = start_offset
        self.start_instr = start_instr
        self.name = name
        self.prefered_name = prefered_name if prefered_name else name
        self.size = 0
        self.end_offset = None
        self.end_instr = None
        self.basicblocks = list()
        self.instructions = list()

    def __str__(self):
        line = ('%x' % self.start_offset) + ': ' + str(self.name) + '\n'
        line += 'prefered_name: %s\n' % self.prefered_name
        line += 'start_offset = %x\n' % self.start_offset
        line += 'start_instr = ' + str(self.start_instr.name) + '\n'
        if self.size:
            line += 'size = ' + str(self.size) + '\n'
        if self.end_offset:
            line += 'end_offset = ' + str(self.end_offset) + '\n'
        if self.end_instr:
            line += 'end_instr = ' + str(self.end_instr.name) + '\n'
        line += 'lenght basicblocks: %s\n' % len(self.basicblocks)
        line += 'lenght instructions: %s\n' % len(self.instructions)
        line += '\n\n'
        return line

'''
'''--- octopus/core/instruction.py ---
class Instruction(object):
    """Instruction """
    def __init__(self, opcode, name,
                 operand_size, pops, pushes, fee,
                 description, operand=None,
                 operand_interpretation=None, offset=0, xref=None):

        self.opcode = opcode
        self.offset = offset
        self.name = name
        self.description = description
        self.operand_size = operand_size
        self.operand = operand  # Immediate operand if any
        # specific interpretation of operand value
        # ex: operand value for JUMP = xref
        self.operand_interpretation = operand_interpretation
        self.pops = pops
        self.pushes = pushes
        self.fee = fee
        self.xref = xref
        self.ssa = None

    def __eq__(self, other):
        """ Instructions are equal if all features match  """
        return self.opcode == other.opcode and\
            self.name == other.name and\
            self.operand == other.operand and\
            self.operand_size == other.operand_size and\
            self.pops == other.pops and\
            self.pushes == other.pushes and\
            self.fee == other.fee and\
            self.offset == other.offset and\
            self.description == other.description

    def __simple_output_format(self, offset=True):
        output = self.name
        if self.has_operand:
            output += ' 0x%x' % int.from_bytes(self.operand,
                                               byteorder='big')

        if offset:
            return "%d %s" % (self._offset, output)
        else:
            return "%s" % output

    #def __repr__(self):
    #    """ Entire representation of the instruction
    #    output = 'Instruction(0x%x, %r, %d, %d, %d, %d, %r, %r, %r)' \
    #        % (self._opcode, self._name, self._operand_size,
    #            self._pops, self._pushes, self._fee,
    #            self._description, self._operand, self._offset)"""
    #    return self.__simple_output_format()

    def __str__(self):
        """ String representation of the instruction """
        return self.__simple_output_format(offset=False)

    @property
    def bytes(self):
        """ Encoded instruction """
        byte = bytearray()
        byte.append(self.opcode)
        if self.operand:
            [byte.append(x) for x in self.operand]
        return "".join(map(chr, byte))

    @property
    def offset_end(self):
        """ Location in the program (optional) """
        return self.offset + self.size - 1

    @property
    def semantics(self):
        """ Canonical semantics """
        return self.name

    @property
    def size(self):
        """ Size of the encoded instruction """
        return self.operand_size + 1

    @property
    def has_operand(self):
        """ True if the instruction uses an immediate operand """
        return self.operand_size > 0

    @property
    def is_branch_conditional(self):
        """ Return list if the instruction is a jump """
        raise NotImplementedError

    @property
    def is_branch_unconditional(self):
        """ Return list if the instruction is a jump """
        raise NotImplementedError

    @property
    def is_branch(self):
        """ True if the instruction is a jump """
        return self.is_branch_conditional or self.is_branch_unconditional

    @property
    def is_halt(self):
        """ Return list if the instruction is a basic block terminator """
        raise NotImplementedError

    @property
    def is_terminator(self):
        """ True if the instruction is a basic block terminator """
        raise NotImplementedError

    @property
    def have_xref(self):
        """ TODO """
        raise NotImplementedError

'''
'''--- octopus/core/ssa.py ---
SSA_TYPE_FUNCTION = "function"
SSA_TYPE_CONSTANT = "constant"

class SSA(object):
    '''TODO'''

    def __init__(self, new_assignement=None, method_name=None, args=None, instr_type=SSA_TYPE_FUNCTION):
        """ TODO """
        self.new_assignement = new_assignement
        self.method_name = method_name
        self.args = args
        self.instr_type = instr_type

    def detail(self):
        out = ''
        out += 'new_assignement = ' + str(self.new_assignement) + '\n'
        out += 'method_name = ' + str(self.method_name) + '\n'
        out += 'args = ' + str(self.args) + '\n'
        out += 'instr_type = ' + str(self.instr_type) + '\n'
        out += '\n\n'
        return out

    def format(self):
        out = ''
        if self.is_constant:
            if self.new_assignement != None:
                out += '%{:02X}'.format(self.new_assignement)
                out += ' = '
            if self.args != None:
                out += '#0x%X' % self.args
            #if self.method_name:
            #    out += ' (%s)' % self.method_name
        elif self.is_function:
            if self.new_assignement != None:
                out += '%{:02X}'.format(self.new_assignement)
                out += ' = '
            if self.method_name:
                out += '%s(' % self.method_name
            if self.args != None:
                out += ', '.join('%{:02X}'.format(arg.ssa.new_assignement) for arg in self.args)
            out += ')'
        else:
            raise Exception('ssa_format no instr_type ')
        return out

    @property
    def is_constant(self):
        """ TODO """
        return self.instr_type == SSA_TYPE_CONSTANT

    @property
    def is_function(self):
        """ TODO """
        return self.instr_type == SSA_TYPE_FUNCTION

'''
'''--- octopus/core/utils.py ---
from binascii import unhexlify

def bytecode_to_bytes(bytecode):
    if str(bytecode).startswith("0x"):
        bytecode = bytecode[2:]

    try:
        # python > 2.7
        bytecode = bytes.fromhex(bytecode)
    except AttributeError:
        # python <= 2.7
        try:
            bytecode = bytecode.decode("hex")
        except TypeError:
            # last chance
            try:
                bytecode = unhexlify(bytecode)
            except:
                pass
    # already bytes or bytearray
    except TypeError:
        pass
    return bytecode

def search_in_list_of_dict(string_to_search, target_list, key_dict):
    return list(filter(lambda elem: str(string_to_search) in str(elem[key_dict]), target_list))

'''
'''--- octopus/engine/__init__.py ---

'''
'''--- octopus/engine/disassembler.py ---
from octopus.core.utils import bytecode_to_bytes

class BytecodeEmptyException(Exception):
    """Exception raised when bytecode is None"""
    pass

class Disassembler(object):
    """ Generic Disassembler class """

    def __init__(self, asm, bytecode=None):
        self.bytecode = bytecode
        self.instructions = list()
        self.reverse_instructions = dict()
        self.asm = asm

    def attributes_reset(self):
        """Reset instructions class attributes """
        self.instructions = list()
        self.reverse_instructions = dict()

    def disassemble_opcode(self, bytecode, offset=0):
        """ Generic method to disassemble one instruction """
        raise NotImplementedError

    def disassemble(self, bytecode=None, offset=0, r_format='list'):
        """Generic method to disassemble bytecode

        :param bytecode: bytecode sequence
        :param offset: start offset
        :param r_format: output format ('list'/'text'/'reverse')
        :type bytecode: bytes, str
        :type offset: int
        :type r_format: list, str, dict
        :return: dissassembly result depending of r_format
        :rtype: list, str, dict
        """
        # reinitialize class variable
        self.attributes_reset()

        self.bytecode = bytecode if bytecode else self.bytecode
        if not self.bytecode:
            raise BytecodeEmptyException()

        self.bytecode = bytecode_to_bytes(self.bytecode)

        while offset < len(self.bytecode):
            instr = self.disassemble_opcode(self.bytecode[offset:], offset)
            offset += instr.size
            self.instructions.append(instr)

        # fill reverse instructions
        self.reverse_instructions = {k: v for k, v in
                                     enumerate(self.instructions)}

        # return instructions
        if r_format == 'list':
            return self.instructions
        elif r_format == 'text':
            return '\n'.join(map(str, self.instructions))
        elif r_format == 'reverse':
            return self.reverse_instructions

    def disassemble_contract(self, contract):
        """ Generic method to disassemble a Contract """

        # reinitialize class variable
        self.attributes_reset()
        # update class bytecode
        self.bytecode = contract.bytecode

        self.disassemble(self.bytecode)

'''
'''--- octopus/engine/emulator.py ---
# =======================================
# #         Emulator                    #
# =======================================

class EmulatorEngine(object):

    def __init__(self, instructions):
        """ TODO """
        raise NotImplementedError

    def emulate(self, state, depth=0):
        """ TODO """
        raise NotImplementedError

    def emulate_one_instruction(self, instr, state, depth):
        """ TODO """
        raise NotImplementedError
'''
'''--- octopus/engine/engine.py ---
class VMstate(object):

    def __init__(self, gas=1000000):
        """ TODO """
        raise NotImplementedError

    def details(self):
        """ TODO """
        raise NotImplementedError

'''
'''--- octopus/engine/explorer.py ---
import requests
from requests.adapters import HTTPAdapter
from requests.exceptions import ConnectionError as RequestsConnectionError

import json

class Explorer(object):
    '''
    Generic JSON-RPC client class
    '''

    def __init__(self, host='localhost', port=8332, tls=False, max_retries=3):
        self.host = host
        self.port = port
        self.tls = tls
        self.session = requests.Session()
        self.session.mount(self.host, HTTPAdapter(max_retries=max_retries))
        self.headers = {'Content-Type': 'application/json'}

        self.scheme = 'https' if self.tls else 'http'

        self.url = '{}://{}:{}'.format(self.scheme, self.host, self.port)

    def call(self, method, params=None, jsonrpc=None, _id=None):

        params = params or []
        jsonrpc = jsonrpc or '2.0'
        data = {
            'jsonrpc': jsonrpc,
            'method': method,
            'params': params,
        }
        if _id is not None:
            data['id'] = _id

        try:
            r = self.session.post(self.url, headers=self.headers, data=json.dumps(data))
        except RequestsConnectionError:
            raise Exception('RPC connection Error')
        if not 200 <= r.status_code < 300:
            raise Exception('RPC connection failure: ' + str(r.status_code) + ' ' + r.reason)
        try:
            response = r.json()
        except ValueError:
            raise Exception('JSON response parsing error: ' + str(r.text))
        try:
            return response['result']
        except KeyError:
            raise Exception('\"result\" field in JSON response error: ' + str(response))

    #######################
    # HIGHT-LEVEL METHODS #
    #######################

    def get_transaction(self, transaction_id, verbosity):
        '''
        return transaction informations

        ex :
            binding of eth_getTransactionByHash() for Ethereum
            binding of getrawtransaction() for Bitcoin
            binding of getrawtransaction() for Neo
        '''
        return NotImplementedError

    def get_block_by_number(self, block_number):
        '''
        return block information using given block number

        ex :
            binding of eth_getBlockByNumber() for Ethereum
            binding of getblockhash() + getblock() for Bitcoin
            binding of getblock() for Neo
        '''
        return NotImplementedError

    def get_block_by_hash(self, block_hash):
        '''
        return block information using given block hash

        ex :
            binding of eth_getBlockByHash() for Ethereum
            binding of getblock() for Bitcoin
            binding of getblock() for Neo
        '''
        return NotImplementedError

    def decode_tx(txid):
        '''
        return dict with important transaction information
        '''
        return NotImplementedError

'''
'''--- octopus/engine/helper.py ---
#from .constants import TT256, TT255

import re
from z3 import *

TT256 = 2 ** 256
TT256M1 = 2 ** 256 - 1
TT255 = 2 ** 255

class helper(object):

    def is_symbolic(value):
        return not isinstance(value, int)

    def is_real(value):
        return isinstance(value, int)

    def isAllReal(*args):
        for i in args:
            if is_symbolic(i):
                return False
        return True

    def safe_decode(hex_encoded_string):

        if (hex_encoded_string.startswith("0x")):
            return bytes.fromhex(hex_encoded_string[2:])
        else:
            return bytes.fromhex(hex_encoded_string)

    def to_signed(i):
        return i if i < TT255 else i - TT256

    def get_trace_line(instr, state):

        stack = str(state.stack[::-1])

        # stack = re.sub("(\d+)",    lambda m: hex(int(m.group(1))), stack)
        stack = re.sub("\n", "", stack)

        return str(instr['address']) + " " + instr['opcode'] + "\tSTACK: " + stack

    def convert_to_bitvec(item):
        # converting boolean expression to bitvector
        if type(item) == BoolRef:
            return If(item, BitVecVal(1, 256), BitVecVal(0, 256))
        elif type(item) == bool:
            if item:
                return BitVecVal(1, 256)
            else:
                return BitVecVal(0, 256)
        elif type(item) == int:
            return BitVecVal(item, 256)
        else:
            return simplify(item)

    def convert_to_concrete_int(item):
        if (type(item) == int):
            return item

        if (type(item) == BitVecNumRef):
            return item.as_long()

        return simplify(item).as_long()

    def get_concrete_int(item):

        if (type(item) == int):
            return item

        if (type(item) == BitVecNumRef):
            return item.as_long()

        return simplify(item).as_long()

    def concrete_int_from_bytes(_bytes, start_index):

        # logging.debug("-- concrete_int_from_bytes: " + str(_bytes[start_index:start_index+32]))
        b = _bytes[start_index:start_index+32]

        val = int.from_bytes(b, byteorder='big')

        return val

    def concrete_int_to_bytes(val):

        # logging.debug("concrete_int_to_bytes " + str(val))

        if (type(val) == int):
            return val.to_bytes(32, byteorder='big')

        return (simplify(val).as_long()).to_bytes(32, byteorder='big')

'''
'''--- octopus/engine/ssa.py ---
# =======================================
# #         SSA Engine                  #
# =======================================

class SSAEngine(object):

    def __init__(self, instructions):
        """ TODO """
        raise NotImplementedError

    def emulate(self, state, depth=0):
        """ TODO """
        raise NotImplementedError

    def emulate_one_instruction(self, instr, state, depth):
        """ TODO """
        raise NotImplementedError

'''
'''--- octopus/engine/symbolic_execution.py ---
# =======================================
# #     Symbolic Execution Engine       #
# =======================================

class SymbolicExecutionEngine(object):

    def __init__(self, bytecode=None, instructions=None, contract=None, modules=None, dynamic_loader=None, max_depth=10):
        """ TODO """
        raise NotImplementedError

    def sym_exec_contract(self, contract):
        """ TODO """
        raise NotImplementedError

    def sym_exec_single_instr(self, instr, context, state, depth, constraints):
        """ TODO """
        raise NotImplementedError

'''
'''--- octopus/octopus_eth_evm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys

from logging import getLogger
logging = getLogger(__name__)

PLATFORM = 'eth-evm'

def error_print(msg):
    print('[X] %s for %s' % (msg, PLATFORM))
    sys.exit()

def main() -> None:
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-r', '--raw',
                        help='hex-encoded bytecode string ("ABcdeF09..." or "0xABcdeF09...")',
                        metavar='BYTECODE')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('r'),
                        help='file containing hex-encoded bytecode string',
                        metavar='BYTECODEFILE')
    inputs.add_argument('-a', '--address',
                        help='pull contract from the blockchain',
                        metavar='CONTRACT_ADDRESS')

    features = parser.add_argument_group('Features')
    features.add_argument('-e', '--explore',
                          action='store_true',
                          help='client to retrieve information from blockchains')
    features.add_argument('-d', '--disassemble',
                          action='store_true',
                          help='print text disassembly ')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG)')
    features.add_argument('-c', '--call',
                          action='store_true',
                          help='generate the call flow graph')
    features.add_argument('-s', '--ssa',
                          action='store_true',
                          help='generate the CFG with SSA representation')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--onlystatic', action='store_true',
                       help='generate the CFG without stack emulation (fastest but less accurate)')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunction', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')
    #graph.add_argument('--visualize',
    #                   help='direcly open the CFG file')
    #graph.add_argument('--format',
    #                   choices=['pdf', 'png', 'dot'],
    #                   default='pdf',
    #                   help='direcly open the CFG file')

    explorer = parser.add_argument_group('Explorer options')
    explorer.add_argument('--code',
                          help='get contract code',
                          metavar='CONTRACT_ADDRESS')
    explorer.add_argument('--tx',
                          help='get transaction information')
    #explorer.add_argument('--txdecode', action='store_true',
    #                      help='return important transaction information')
    explorer.add_argument('--blockid', type=int,
                          help='get block information using given block number',
                          metavar='BLOCK_NUMBER')
    explorer.add_argument('--blockhash',
                          help='get block information using given block hash',
                          metavar='BLOCK_HASH')
    explorer.add_argument('--infura',
                          help='Infura network choice',
                          choices=['mainnet', 'ropsten', 'infuranet', 'kovan', 'rinkeby'],
                          default='mainnet')
    explorer.add_argument('--rpc', help='custom RPC settings',
                          metavar='HOST:PORT')
    explorer.add_argument('--rpctls', action='store_false',
                          help='RPC connection over TLS')

    args = parser.parse_args()

    octo_bytecode = None
    octo_explorer = None
    octo_disasm = None
    octo_cfg = None

    # Explorer
    if args.explore or args.address:
        # user choose some explorer options
        if args.rpc:
            from octopus.platforms.ETH.explorer import EthereumExplorerRPC
            # parsing RPC HOST & PORT
            host, port = args.rpc.split(':')
            octo_explorer = EthereumExplorerRPC(host=host, port=port, tls=args.rpctls)
        else:
            from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
            from octopus.platforms.ETH.explorer import (INFURA_MAINNET,
                                                        INFURA_ROPSTEN,
                                                        INFURA_INFURANET,
                                                        INFURA_KOVAN,
                                                        INFURA_RINKEBY)
            if args.infura == 'mainnet':
                network = INFURA_MAINNET
            if args.infura == 'ropsten':
                network = INFURA_ROPSTEN
            if args.infura == 'infuranet':
                network = INFURA_INFURANET
            if args.infura == 'kovan':
                network = INFURA_KOVAN
            if args.infura == 'rinkeby':
                network = INFURA_RINKEBY

            octo_explorer = EthereumInfuraExplorer(network=network)

        # process explorer related commands
        if args.code:
            print(octo_explorer.eth_getCode(args.code))
        elif args.tx:
            print(octo_explorer.get_transaction(args.tx))
        # elif args.txdecode:
        #    pass
        elif args.blockid:
            print(octo_explorer.get_block_by_number(args.blockid))
        elif args.blockhash:
            print(octo_explorer.get_block_by_hash(args.blockhash))

    # process input code
    if args.raw:
        octo_bytecode = args.raw
    elif args.file:
        octo_bytecode = ''.join([l.strip() for l in args.file if len(l.strip()) > 0])
    elif args.address:
        octo_bytecode = octo_explorer.eth_getCode(args.address)

    # Disassembly
    if args.disassemble:
        from octopus.platforms.ETH.disassembler import EthereumDisassembler

        # TODO add other r_format support
        octo_disasm = EthereumDisassembler()
        print(octo_disasm.disassemble(octo_bytecode, r_format='text'))

    # Control Flow Analysis
    elif args.cfg or args.ssa:
        from octopus.platforms.ETH.cfg import EthereumCFG
        from octopus.analysis.graph import CFGGraph

        if args.onlystatic and not args.ssa:
            octo_cfg = EthereumCFG(octo_bytecode, evm_analysis='static')
        else:
            octo_cfg = EthereumCFG(octo_bytecode)

        octo_graph = CFGGraph(octo_cfg)

        if args.functions or args.onlyfunction:
            octo_graph.view_functions(only_func_name=args.onlyfunction,
                                      simplify=args.simplify,
                                      ssa=args.ssa)
        else:
            octo_graph.view(simplify=args.simplify, ssa=args.ssa)

    # Call Flow Analysis
    elif args.call:
        error_print('Call Flow Analysis not yet supported')
    elif args.ssa:
        # already done
        pass
    elif args.explore:
        # already done
        pass
    else:
        parser.print_help()

if __name__ == '__main__':
    main()

'''
'''--- octopus/platforms/BTC/__init__.py ---

'''
'''--- octopus/platforms/BTC/bech32.py ---
# Copyright (c) 2017 Pieter Wuille
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

"""Reference implementation for Bech32 and segwit addresses.

https://github.com/sipa/bech32/blob/master/ref/python/segwit_addr.py
"""

CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"

def bech32_polymod(values):
    """Internal function that computes the Bech32 checksum."""
    generator = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
    chk = 1
    for value in values:
        top = chk >> 25
        chk = (chk & 0x1ffffff) << 5 ^ value
        for i in range(5):
            chk ^= generator[i] if ((top >> i) & 1) else 0
    return chk

def bech32_hrp_expand(hrp):
    """Expand the HRP into values for checksum computation."""
    return [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]

def bech32_verify_checksum(hrp, data):
    """Verify a checksum given HRP and converted data characters."""
    return bech32_polymod(bech32_hrp_expand(hrp) + data) == 1

def bech32_create_checksum(hrp, data):
    """Compute the checksum values given HRP and data."""
    values = bech32_hrp_expand(hrp) + data
    polymod = bech32_polymod(values + [0, 0, 0, 0, 0, 0]) ^ 1
    return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]

def bech32_encode(hrp, data):
    """Compute a Bech32 string given HRP and data values."""
    combined = data + bech32_create_checksum(hrp, data)
    return hrp + '1' + ''.join([CHARSET[d] for d in combined])

def bech32_decode(bech):
    """Validate a Bech32 string, and determine HRP and data."""
    if ((any(ord(x) < 33 or ord(x) > 126 for x in bech)) or
            (bech.lower() != bech and bech.upper() != bech)):
        return (None, None)
    bech = bech.lower()
    pos = bech.rfind('1')
    if pos < 1 or pos + 7 > len(bech) or len(bech) > 90:
        return (None, None)
    if not all(x in CHARSET for x in bech[pos+1:]):
        return (None, None)
    hrp = bech[:pos]
    data = [CHARSET.find(x) for x in bech[pos+1:]]
    if not bech32_verify_checksum(hrp, data):
        return (None, None)
    return (hrp, data[:-6])

def convertbits(data, frombits, tobits, pad=True):
    """General power-of-2 base conversion."""
    acc = 0
    bits = 0
    ret = []
    maxv = (1 << tobits) - 1
    max_acc = (1 << (frombits + tobits - 1)) - 1
    for value in data:
        if value < 0 or (value >> frombits):
            return None
        acc = ((acc << frombits) | value) & max_acc
        bits += frombits
        while bits >= tobits:
            bits -= tobits
            ret.append((acc >> bits) & maxv)
    if pad:
        if bits:
            ret.append((acc << (tobits - bits)) & maxv)
    elif bits >= frombits or ((acc << (tobits - bits)) & maxv):
        return None
    return ret

def decode(hrp, addr):
    """Decode a segwit address."""
    hrpgot, data = bech32_decode(addr)
    if hrpgot != hrp:
        return (None, None)
    decoded = convertbits(data[1:], 5, 8, False)
    if decoded is None or len(decoded) < 2 or len(decoded) > 40:
        return (None, None)
    if data[0] > 16:
        return (None, None)
    if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:
        return (None, None)
    return (data[0], decoded)

def encode(hrp, witver, witprog):
    """Encode a segwit address."""
    ret = bech32_encode(hrp, [witver] + convertbits(witprog, 8, 5))
    if decode(hrp, ret) == (None, None):
        return None
    return ret
'''
'''--- octopus/platforms/BTC/btcscript.py ---
# based on https://en.bitcoin.it/wiki/Script

pops = 0
pushes = 0
gas = 0

_table = {
    # opcode:(mnemonic, immediate_operand_size, pops, pushes, gas, description)
    # Constants
    0x00: ('OP_FALSE', 0, 0, 1, gas, 'An empty array of bytes is pushed onto the stack.'),
    0x00: ('OP_0', 0, 0, 1, gas, 'An empty array of bytes is pushed onto the stack.'),
    0x01: ('', 0x01, 0, 0x01, gas, '0x01 byte will be push onto the stack'),
    0x02: ('', 0x02, 0, 0x02, gas, '0x02 bytes will be push onto the stack'),
    0x03: ('', 0x03, 0, 0x03, gas, '0x03 bytes will be push onto the stack'),
    0x04: ('', 0x04, 0, 0x04, gas, '0x04 bytes will be push onto the stack'),
    0x05: ('', 0x05, 0, 0x05, gas, '0x05 bytes will be push onto the stack'),
    0x06: ('', 0x06, 0, 0x06, gas, '0x06 bytes will be push onto the stack'),
    0x07: ('', 0x07, 0, 0x07, gas, '0x07 bytes will be push onto the stack'),
    0x08: ('', 0x08, 0, 0x08, gas, '0x08 bytes will be push onto the stack'),
    0x09: ('', 0x09, 0, 0x09, gas, '0x09 bytes will be push onto the stack'),
    0x0A: ('', 0x0A, 0, 0x0A, gas, '0x0A bytes will be push onto the stack'),
    0x0B: ('', 0x0B, 0, 0x0B, gas, '0x0B bytes will be push onto the stack'),
    0x0C: ('', 0x0C, 0, 0x0C, gas, '0x0C bytes will be push onto the stack'),
    0x0D: ('', 0x0D, 0, 0x0D, gas, '0x0D bytes will be push onto the stack'),
    0x0E: ('', 0x0E, 0, 0x0E, gas, '0x0E bytes will be push onto the stack'),
    0x0F: ('', 0x0F, 0, 0x0F, gas, '0x0F bytes will be push onto the stack'),
    0x10: ('', 0x10, 0, 0x10, gas, '0x10 bytes will be push onto the stack'),
    0x11: ('', 0x11, 0, 0x11, gas, '0x11 bytes will be push onto the stack'),
    0x12: ('', 0x12, 0, 0x12, gas, '0x12 bytes will be push onto the stack'),
    0x13: ('', 0x13, 0, 0x13, gas, '0x13 bytes will be push onto the stack'),
    0x14: ('', 0x14, 0, 0x14, gas, '0x14 bytes will be push onto the stack'),
    0x15: ('', 0x15, 0, 0x15, gas, '0x15 bytes will be push onto the stack'),
    0x16: ('', 0x16, 0, 0x16, gas, '0x16 bytes will be push onto the stack'),
    0x17: ('', 0x17, 0, 0x17, gas, '0x17 bytes will be push onto the stack'),
    0x18: ('', 0x18, 0, 0x18, gas, '0x18 bytes will be push onto the stack'),
    0x19: ('', 0x19, 0, 0x19, gas, '0x19 bytes will be push onto the stack'),
    0x1A: ('', 0x1A, 0, 0x1A, gas, '0x1A bytes will be push onto the stack'),
    0x1B: ('', 0x1B, 0, 0x1B, gas, '0x1B bytes will be push onto the stack'),
    0x1C: ('', 0x1C, 0, 0x1C, gas, '0x1C bytes will be push onto the stack'),
    0x1D: ('', 0x1D, 0, 0x1D, gas, '0x1D bytes will be push onto the stack'),
    0x1E: ('', 0x1E, 0, 0x1E, gas, '0x1E bytes will be push onto the stack'),
    0x1F: ('', 0x1F, 0, 0x1F, gas, '0x1F bytes will be push onto the stack'),
    0x20: ('', 0x20, 0, 0x20, gas, '0x20 bytes will be push onto the stack'),
    0x21: ('', 0x21, 0, 0x21, gas, '0x21 bytes will be push onto the stack'),
    0x22: ('', 0x22, 0, 0x22, gas, '0x22 bytes will be push onto the stack'),
    0x23: ('', 0x23, 0, 0x23, gas, '0x23 bytes will be push onto the stack'),
    0x24: ('', 0x24, 0, 0x24, gas, '0x24 bytes will be push onto the stack'),
    0x25: ('', 0x25, 0, 0x25, gas, '0x25 bytes will be push onto the stack'),
    0x26: ('', 0x26, 0, 0x26, gas, '0x26 bytes will be push onto the stack'),
    0x27: ('', 0x27, 0, 0x27, gas, '0x27 bytes will be push onto the stack'),
    0x28: ('', 0x28, 0, 0x28, gas, '0x28 bytes will be push onto the stack'),
    0x29: ('', 0x29, 0, 0x29, gas, '0x29 bytes will be push onto the stack'),
    0x2A: ('', 0x2A, 0, 0x2A, gas, '0x2A bytes will be push onto the stack'),
    0x2B: ('', 0x2B, 0, 0x2B, gas, '0x2B bytes will be push onto the stack'),
    0x2C: ('', 0x2C, 0, 0x2C, gas, '0x2C bytes will be push onto the stack'),
    0x2D: ('', 0x2D, 0, 0x2D, gas, '0x2D bytes will be push onto the stack'),
    0x2E: ('', 0x2E, 0, 0x2E, gas, '0x2E bytes will be push onto the stack'),
    0x2F: ('', 0x2F, 0, 0x2F, gas, '0x2F bytes will be push onto the stack'),
    0x30: ('', 0x30, 0, 0x30, gas, '0x30 bytes will be push onto the stack'),
    0x31: ('', 0x31, 0, 0x31, gas, '0x31 bytes will be push onto the stack'),
    0x32: ('', 0x32, 0, 0x32, gas, '0x32 bytes will be push onto the stack'),
    0x33: ('', 0x33, 0, 0x33, gas, '0x33 bytes will be push onto the stack'),
    0x34: ('', 0x34, 0, 0x34, gas, '0x34 bytes will be push onto the stack'),
    0x35: ('', 0x35, 0, 0x35, gas, '0x35 bytes will be push onto the stack'),
    0x36: ('', 0x36, 0, 0x36, gas, '0x36 bytes will be push onto the stack'),
    0x37: ('', 0x37, 0, 0x37, gas, '0x37 bytes will be push onto the stack'),
    0x38: ('', 0x38, 0, 0x38, gas, '0x38 bytes will be push onto the stack'),
    0x39: ('', 0x39, 0, 0x39, gas, '0x39 bytes will be push onto the stack'),
    0x3A: ('', 0x3A, 0, 0x3A, gas, '0x3A bytes will be push onto the stack'),
    0x3B: ('', 0x3B, 0, 0x3B, gas, '0x3B bytes will be push onto the stack'),
    0x3C: ('', 0x3C, 0, 0x3C, gas, '0x3C bytes will be push onto the stack'),
    0x3D: ('', 0x3D, 0, 0x3D, gas, '0x3D bytes will be push onto the stack'),
    0x3E: ('', 0x3E, 0, 0x3E, gas, '0x3E bytes will be push onto the stack'),
    0x3F: ('', 0x3F, 0, 0x3F, gas, '0x3F bytes will be push onto the stack'),
    0x40: ('', 0x40, 0, 0x40, gas, '0x40 bytes will be push onto the stack'),
    0x41: ('', 0x41, 0, 0x41, gas, '0x41 bytes will be push onto the stack'),
    0x42: ('', 0x42, 0, 0x42, gas, '0x42 bytes will be push onto the stack'),
    0x43: ('', 0x43, 0, 0x43, gas, '0x43 bytes will be push onto the stack'),
    0x44: ('', 0x44, 0, 0x44, gas, '0x44 bytes will be push onto the stack'),
    0x45: ('', 0x45, 0, 0x45, gas, '0x45 bytes will be push onto the stack'),
    0x46: ('', 0x46, 0, 0x46, gas, '0x46 bytes will be push onto the stack'),
    0x47: ('', 0x47, 0, 0x47, gas, '0x47 bytes will be push onto the stack'),
    0x48: ('', 0x48, 0, 0x48, gas, '0x48 bytes will be push onto the stack'),
    0x49: ('', 0x49, 0, 0x49, gas, '0x49 bytes will be push onto the stack'),
    0x4A: ('', 0x4A, 0, 0x4A, gas, '0x4A bytes will be push onto the stack'),
    0x4B: ('', 0x4B, 0, 0x4B, gas, '0x4B datas will be push onto the stack'),
    0x4C: ('OP_PUSHDATA1', 1, 0, 1, gas, 'The next byte contains the number of bytes to be pushed onto the stack.'),
    0x4D: ('OP_PUSHDATA2', 2, 0, 2, gas, 'The next two bytes contain the number of bytes to be pushed onto the stack.'),
    0x4E: ('OP_PUSHDATA4', 4, 0, 4, gas, 'The next four bytes contain the number of bytes to be pushed onto the stack.'),
    0x4F: ('OP_1NEGATE', 0, 0, 1, gas, 'The number -1 is pushed onto the stack.'),
    0x51: ('OP_TRUE', 0, 0, 1, gas, 'The number 1 is pushed onto the stack.'),
    0x51: ('OP_1', 0, 0, 1, gas, 'The number 1 is pushed onto the stack.'),
    0x52: ('OP_2', 0, 0, 1, gas, 'The number 2 is pushed onto the stack.'),
    0x53: ('OP_3', 0, 0, 1, gas, 'The number 3 is pushed onto the stack.'),
    0x54: ('OP_4', 0, 0, 1, gas, 'The number 4 is pushed onto the stack.'),
    0x55: ('OP_5', 0, 0, 1, gas, 'The number 5 is pushed onto the stack.'),
    0x56: ('OP_6', 0, 0, 1, gas, 'The number 6 is pushed onto the stack.'),
    0x57: ('OP_7', 0, 0, 1, gas, 'The number 7 is pushed onto the stack.'),
    0x58: ('OP_8', 0, 0, 1, gas, 'The number 8 is pushed onto the stack.'),
    0x59: ('OP_9', 0, 0, 1, gas, 'The number 9 is pushed onto the stack.'),
    0x5A: ('OP_10', 0, 0, 1, gas, 'The number 10 is pushed onto the stack.'),
    0x5B: ('OP_11', 0, 0, 1, gas, 'The number 11 is pushed onto the stack.'),
    0x5C: ('OP_12', 0, 0, 1, gas, 'The number 12 is pushed onto the stack.'),
    0x5D: ('OP_13', 0, 0, 1, gas, 'The number 13 is pushed onto the stack.'),
    0x5E: ('OP_14', 0, 0, 1, gas, 'The number 14 is pushed onto the stack.'),
    0x5F: ('OP_15', 0, 0, 1, gas, 'The number 15 is pushed onto the stack.'),
    0x60: ('OP_16', 0, 0, 1, gas, 'The number 16 is pushed onto the stack.'),

    # Flow control
    0x61: ('OP_NOP', 0, 0, 0, gas, 'Does nothing.'),
    0x63: ('OP_IF', 0, 1, 0, gas, 'If the top stack value is not False, the statements are executed. The top stack value is removed.'),
    0x64: ('OP_NOTIF', 0, 1, 0, gas, 'If the top stack value is False, the statements are executed. The top stack value is removed.'),
    0x67: ('OP_ELSE', 0, pops, pushes, gas, 'If the preceding OP_IF or OP_NOTIF or OP_ELSE was not executed then these statements are and if the preceding OP_IF or OP_NOTIF or OP_ELSE was executed then these statements are not.'),
    0x68: ('OP_ENDIF', 0, pops, pushes, gas, 'Ends an if/else block. All blocks must end, or the transaction is invalid. An OP_ENDIF without OP_IF earlier is also invalid.'),
    0x69: ('OP_VERIFY', 0, 0, 0, gas, 'Marks transaction as invalid if top stack value is not true. The top stack value is removed.'),
    0x6A: ('OP_RETURN', 0, 0, 1, gas, 'Marks transaction as invalid. A standard way of attaching extra data to transactions is to add a zero-value output with a scriptPubKey consisting of OP_RETURN followed by exactly one pushdata op. Such outputs are provably unspendable, reducing their cost to the network. Currently it is usually considered non-standard (though valid) for a transaction to have more than one OP_RETURN output or an OP_RETURN output with more than one pushdata op.'),

    # Stack
    0x6B: ('OP_TOALTSTACK', 0, 1, 1, gas, 'Puts the input onto the top of the alt stack. Removes it from the main stack.'),
    0x6C: ('OP_FROMALTSTACK', 0, 1, 1, gas, 'Puts the input onto the top of the main stack. Removes it from the alt stack.'),
    0x73: ('OP_IFDUP', 0, 0, 1, gas, 'If the top stack value is not 0, duplicate it.'),
    0x74: ('OP_DEPTH', 0, 0, 1, gas, 'Puts the number of stack items onto the stack.'),
    0x75: ('OP_DROP', 0, 1, 0, gas, 'Removes the top stack item.'),
    0x76: ('OP_DUP', 0, 0, 1, gas, 'Duplicates the top stack item.'),
    0x77: ('OP_NIP', 0, 1, 0, gas, 'Removes the second-to-top stack item.'),
    0x78: ('OP_OVER', 0, 0, 1, gas, 'Copies the second-to-top stack item to the top.'),
    0x79: ('OP_PICK', 0, 0, 1, gas, 'The item n back in the stack is copied to the top.'),
    0x7A: ('OP_ROLL', 0, 0, 0, gas, 'The item n back in the stack is moved to the top.'),
    0x7B: ('OP_ROT', 0, 3, 3, gas, 'The top three items on the stack are rotated to the left.'),
    0x7C: ('OP_SWAP', 0, 2, 2, gas, 'The top two items on the stack are swapped.'),
    0x7D: ('OP_TUCK', 0, 2, 3, gas, 'The item at the top of the stack is copied and inserted before the second-to-top item.'),
    0x6D: ('OP_2DROP', 0, 2, 0, gas, 'Removes the top two stack items.'),
    0x6E: ('OP_2DUP', 0, 2, 4, gas, 'Duplicates the top two stack items.'),
    0x6F: ('OP_3DUP', 0, 3, 6, gas, 'Duplicates the top three stack items.'),
    0x70: ('OP_2OVER', 0, 4, 6, gas, 'Copies the pair of items two spaces back in the stack to the front.'),
    0x71: ('OP_2ROT', 0, 6, 6, gas, 'The fifth and sixth items back are moved to the top of the stack.'),
    0x72: ('OP_2SWAP', 0, 4, 4, gas, 'Swaps the top two pairs of items.'),

    # Splice
    0x7E: ('OP_CAT', 0, 0, 0, gas, 'Concatenates two strings. DISABLED.'),
    0x7F: ('OP_SUBSTR', 0, 0, 0, gas, 'Returns a section of a string. DISABLED.'),
    0x80: ('OP_LEFT', 0, 0, 0, gas, 'Keeps only characters left of the specified point in a string. DISABLED.'),
    0x81: ('OP_RIGHT', 0, 0, 0, gas, 'Keeps only characters right of the specified point in a string. DISABLED.'),
    0x82: ('OP_SIZE', 0, 1, 2, gas, 'Pushes the string length of the top element of the stack (without popping it).'),

    # Bitwise logic
    0x83: ('OP_INVERT', 0, pops, pushes, gas, 'Flips all of the bits in the input. DISABLED.'),
    0x84: ('OP_AND', 0, pops, pushes, gas, 'Boolean and between each bit in the inputs. DISABLED.'),
    0x85: ('OP_OR', 0, pops, pushes, gas, 'Boolean or between each bit in the inputs. DISABLED.'),
    0x86: ('OP_XOR', 0, pops, pushes, gas, 'Boolean exclusive or between each bit in the inputs. DISABLED.'),
    0x87: ('OP_EQUAL', 0, 2, 3, gas, 'Returns 1 if the inputs are exactly equal, 0 otherwise.'),
    0x88: ('OP_EQUALVERIFY', 0, 2, 2, gas, 'Same as OP_EQUAL, but runs OP_VERIFY afterward.'),

    # Arithmetic
    # Note: Arithmetic inputs are limited to signed 32-bit integers, but may overflow their output.
    # If any input value for any of these commands is longer than 4 bytes, the script must abort and fail. If any opcode marked as disabled is present in a script - it must also abort and fail.
    0x8B: ('OP_1ADD', 0, 0, 0, gas, '1 is added to the input.'),
    0x8C: ('OP_1SUB', 0, 0, 0, gas, '1 is subtracted from the input.'),
    0x8D: ('OP_2MUL', 0, 0, 0, gas, 'The input is multiplied by 2. DISABLED.'),
    0x8E: ('OP_2DIV', 0, 0, 0, gas, 'The input is divided by 2. DISABLED.'),
    0x8F: ('OP_NEGATE', 0, 0, 0, gas, 'The sign of the input is flipped.'),
    0x90: ('OP_ABS', 0, 0, 0, gas, 'The input is made positive.'),
    0x91: ('OP_NOT', 0, 0, 0, gas, 'If the input is 0 or 1, it is flipped. Otherwise the output will be 0.'),
    0x92: ('OP_0NOTEQUAL', 0, pops, pushes, gas, 'Returns 0 if the input is 0. 1 otherwise.'),
    0x93: ('OP_ADD', 0, 0, 0, gas, 'a is added to b.'),
    0x94: ('OP_SUB', 0, 0, 0, gas, 'b is subtracted from a.'),
    0x95: ('OP_MUL', 0, 0, 0, gas, 'a is multiplied by b.'),
    0x96: ('OP_DIV', 0, 0, 0, gas, 'a is divided by b. DISABLED.'),
    0x97: ('OP_MOD', 0, 0, 0, gas, 'Returns the remainder after dividing a by b. DISABLED.'),
    0x98: ('OP_LSHIFT', 0, 0, 0, gas, 'Shifts a left b bits, preserving sign. DISABLED.'),
    0x99: ('OP_RSHIFT', 0, 0, 0, gas, 'Shifts a right b bits, preserving sign.DISABLED.'),
    0x9A: ('OP_BOOLAND', 0, 0, 0, gas, 'If both a and b are not 0, the output is 1. Otherwise 0.'),
    0x9B: ('OP_BOOLOR', 0, 0, 0, gas, 'If a or b is not 0, the output is 1. Otherwise 0.'),
    0x9C: ('OP_NUMEQUAL', 0, 0, 0, gas, 'Returns 1 if the numbers are equal, 0 otherwise.'),
    0x9E: ('OP_NUMNOTEQUAL', 0, 0, 0, gas, 'Returns 1 if the numbers are not equal, 0 otherwise.'),
    0x9F: ('OP_LESSTHAN', 0, 0, 0, gas, 'Returns 1 if a is less than b, 0 otherwise.'),
    0xA0: ('OP_GREATERTHAN', 0, 0, 0, gas, 'Returns 1 if a is greater than b, 0 otherwise.'),
    0xA1: ('OP_LESSTHANOREQUAL', 0, 0, 0, gas, 'Returns 1 if a is less than or equal to b, 0 otherwise.'),
    0xA2: ('OP_GREATERTHANOREQUAL', 0, 0, 0, gas, 'Returns 1 if a is greater than or equal to b, 0 otherwise.'),
    0xA3: ('OP_MIN', 0, 0, 0, gas, 'Returns the smaller of a and b.'),
    0xA4: ('OP_MAX', 0, 0, 0, gas, 'Returns the larger of a and b.'),
    0xA5: ('OP_WITHIN', 0, 0, 0, gas, 'Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.'),

    # Crypto
    0xA6: ('OP_RIPEMD160', 0, pops, pushes, gas, 'The input is hashed using RIPEMD-160.'),
    0xA7: ('OP_SHA1', 0, pops, pushes, gas, 'The input is hashed using SHA-1.'),
    0xA8: ('OP_SHA256', 0, pops, pushes, gas, 'The input is hashed using SHA-256.'),
    0xA9: ('OP_HASH160', 0, pops, pushes, gas, 'The input is hashed twice: first with SHA-256 and then with RIPEMD-160.'),
    0xAA: ('OP_HASH256', 0, pops, pushes, gas, 'The input is hashed two times with SHA-256.'),
    0xAA: ('OP_CODESEPARATOR', 0, pops, pushes, gas, 'All of the signature checking words will only match signatures to the data after the most recently-executed OP_CODESEPARATOR.'),
    0xAC: ('OP_CHECKSIG', 0, pops, pushes, gas, 'The entire transaction\'s outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.'),
    0xAD: ('OP_CHECKSIGVERIFY', 0, pops, pushes, gas, 'Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.'),
    0xAE: ('OP_CHECKMULTISIG', 0, pops, pushes, gas, 'Compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, one extra unused value is removed from the stack.'),
    0xAF: ('OP_CHECKMULTISIGVERIFY', 0, pops, pushes, gas, 'Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.'),

    # Locktime
    0xB1: ('OP_CHECKLOCKTIMEVERIFY', 0, pops, pushes, gas, 'Marks transaction as invalid if the top stack item is greater than the transaction\'s nLockTime field, otherwise script evaluation continues as though an OP_NOP was executed. Transaction is also invalid if 1. the stack is empty; or 2. the top stack item is negative; or 3. the top stack item is greater than or equal to 500000000 while the transaction\'s nLockTime field is less than 500000000, or vice versa; or 4. the input\'s nSequence field is equal to 0xffffffff. The precise semantics are described in BIP 0065.'),
    0xB2: ('OP_CHECKSEQUENCEVERIFY', 0, pops, pushes, gas, 'Marks transaction as invalid if the relative lock time of the input (enforced by BIP 0068 with nSequence) is not equal to or longer than the value of the top stack item. The precise semantics are described in BIP 0112.'),

    # Pseudo-words
    # These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.
    0xFA: ('OP_SMALLINTEGER', 0, pops, pushes, gas, 'OP_SMALLINTEGER'),
    0xFD: ('OP_PUBKEYS', 0, pops, pushes, gas, 'OP_PUBKEYS'),
    0xFD: ('OP_PUBKEYHASH', 0, pops, pushes, gas, 'Represents a public key hashed with OP_HASH160.'),
    0xFE: ('OP_PUBKEY', 0, pops, pushes, gas, 'Represents a public key compatible with OP_CHECKSIG.'),
    0xFF: ('OP_INVALIDOPCODE', 0, pops, pushes, gas, 'Matches any opcode that is not yet assigned.'),

    # Reserved words
    0x50: ('OP_RESERVED', 0, pops, pushes, gas, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),
    0x62: ('OP_VER', 0, pops, pushes, gas, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),
    0x65: ('OP_VERIF', 0, pops, pushes, gas, 'Transaction is invalid even when occuring in an unexecuted OP_IF branch'),
    0x66: ('OP_VERNOTIF', 0, pops, pushes, gas, 'Transaction is invalid even when occuring in an unexecuted OP_IF branch'),
    0x89: ('OP_RESERVED1', 0, pops, pushes, gas, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),
    0x8A: ('OP_RESERVED2', 0, pops, pushes, gas, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),
    0xB0: ('OP_NOP1', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB3: ('OP_NOP4', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB4: ('OP_NOP5', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB5: ('OP_NOP6', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB6: ('OP_NOP7', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB7: ('OP_NOP8', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB8: ('OP_NOP9', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
    0xB9: ('OP_NOP10', 0, 0, 0, gas, 'The word is ignored. Does not mark transaction as invalid.'),
}

class BTCScript(object):
    """Bytecode for BTC script."""

    def __init__(self):
        self.table = _table
        self.reverse_table = self._get_reverse_table()

    def _get_reverse_table(self):
        """Build an internal table used in the assembler."""
        reverse_table = {}
        for (opcode, (mnemonic, immediate_operand_size,
                      pops, pushes, gas, description)) in _table.items():
            reverse_table[mnemonic] = opcode, mnemonic, immediate_operand_size, \
                pops, pushes, gas, description

        reverse_table['OP_FALSE'] = 0x00, 'OP_FALSE', 0, 0, 1, gas, 'An empty array of bytes is pushed onto the stack.'
        reverse_table['OP_TRUE'] = 0x51, 'OP_TRUE', 0, 0, 1, gas, 'The number 1 is pushed onto the stack.'

        reverse_table['OP_1'] = 0x51, 0, 0, 1, gas, 'The number 1 is pushed onto the stack.'
        reverse_table['OP_2'] = 0x52, 0, 0, 1, gas, 'The number 2 is pushed onto the stack.'
        reverse_table['OP_3'] = 0x53, 0, 0, 1, gas, 'The number 3 is pushed onto the stack.'
        reverse_table['OP_4'] = 0x54, 0, 0, 1, gas, 'The number 4 is pushed onto the stack.'
        reverse_table['OP_5'] = 0x55, 0, 0, 1, gas, 'The number 5 is pushed onto the stack.'
        reverse_table['OP_6'] = 0x56, 0, 0, 1, gas, 'The number 6 is pushed onto the stack.'
        reverse_table['OP_7'] = 0x57, 0, 0, 1, gas, 'The number 7 is pushed onto the stack.'
        reverse_table['OP_8'] = 0x58, 0, 0, 1, gas, 'The number 8 is pushed onto the stack.'
        reverse_table['OP_9'] = 0x59, 0, 0, 1, gas, 'The number 9 is pushed onto the stack.'
        reverse_table['OP_10'] = 0x5A, 0, 0, 1, gas, 'The number 10 is pushed onto the stack.'
        reverse_table['OP_11'] = 0x5B, 0, 0, 1, gas, 'The number 11 is pushed onto the stack.'
        reverse_table['OP_12'] = 0x5C, 0, 0, 1, gas, 'The number 12 is pushed onto the stack.'
        reverse_table['OP_13'] = 0x5D, 0, 0, 1, gas, 'The number 13 is pushed onto the stack.'
        reverse_table['OP_14'] = 0x5E, 0, 0, 1, gas, 'The number 14 is pushed onto the stack.'
        reverse_table['OP_15'] = 0x5F, 0, 0, 1, gas, 'The number 15 is pushed onto the stack.'
        reverse_table['OP_16'] = 0x60, 0, 0, 1, gas, 'The number 16 is pushed onto the stack.'

        return reverse_table

'''
'''--- octopus/platforms/BTC/disassembler.py ---
import io

from octopus.engine.disassembler import Disassembler

from octopus.platforms.BTC.instruction import BitcoinInstruction
from octopus.platforms.BTC.btcscript import BTCScript

# tested with http://chainquery.com/bitcoin-api/decodescript

class BitcoinDisassembler(Disassembler):

    def __init__(self, bytecode=None):
        Disassembler.__init__(self, bytecode=bytecode, asm=BTCScript())

    def disassemble_opcode(self, bytecode, offset=0):
        '''
        TODO
        '''
        wallet = io.BytesIO(bytecode)
        opcode = int.from_bytes(wallet.read(1), byteorder='big')

        invalid = ('OP_INVALIDOPCODE', 0, 0, 0, 0, 'Matches any opcode that is not yet assigned.')
        name, operand_size, pops, pushes, gas, description = \
            self.asm.table.get(opcode, invalid)
        instruction = BitcoinInstruction(opcode, name, operand_size, pops, pushes,
                                         gas, description, offset=offset)
        if instruction.has_length_operand:
            instruction.operand_size = wallet.read(instruction.operand_size)
            instruction.format_operand_size()
        if instruction.has_operand:
            instruction.operand = wallet.read(instruction.operand_size)
        return instruction

    def disassemble(self, bytecode=None, offset=0, r_format='list'):
        '''
        TODO
        '''

        #self.bytecode = str(bytecode) if bytecode else str(self.bytecode)
        self.instructions = list()
        self.reverse_instructions = dict()

        return super().disassemble(bytecode, offset, r_format)

'''
'''--- octopus/platforms/BTC/explorer.py ---
from octopus.engine.explorer import Explorer
from octopus.platforms.BTC.bech32 import encode as bech32_encode

import binascii

RPC_USER = 'test'
RPC_PASSWORD = 'test'
RPC_HOST = 'localhost'

BITCOIND_DEFAULT_RPC_PORT = 8332

class BitcoinExplorerRPC(Explorer):
    '''
    Bitcoin JSON-RPC client class
    '''

    def __init__(self, host='localhost', port=BITCOIND_DEFAULT_RPC_PORT, tls=False, max_retries=3):
        Explorer.__init__(self, host=host, port=port, tls=tls, max_retries=max_retries)

    def call(self, method, params=None, jsonrpc='2.0', _id=None):
        return super().call(method, params, jsonrpc, _id)

    #######################
    # HIGHT-LEVEL METHODS #
    #######################

    def get_transaction(self, transaction_id, verbosity=1):
        """ Return transaction informations

        .. seealso::
            getrawtransaction()
        """
        return self.getrawtransaction(transaction_id, verbosity)

    def get_block_by_number(self, block_number):
        """ Return block information using given block number

        .. seealso::
            getblockhash() + getblock()
        """
        return self.getblock(self.getblockhash(block_number))

    def get_block_by_hash(self, block_hash):
        """ Return block information using given block hash

        .. seealso::
            getblock()
        """
        return self.getblock(block_hash)

    def decode_tx(self, tx):

        result = {"txid": tx['txid'],
                  "sender": [],
                  "receiver": []
                  }

        for vin in tx['vin']:
            # handle first transaction that's the generated bitcoin from the network

            try:
                coinbase = vin['coinbase']
                result['sender'].append(('mining_reward', 0))
            except KeyError:
                # KeyError appears when vin['coinbase'] doesn't exit
                # following is common transaction between 2 bitcoin wallet

                # search for sender address
                sender_txid = vin['txid']
                sender_num = vin['vout']
                sender_tx = self.getrawtransaction(sender_txid, 1)
                for sender_vout in sender_tx['vout']:
                    if sender_vout['n'] == sender_num:
                        try:
                            result['sender'].append((sender_vout['scriptPubKey']['addresses'][0], sender_vout['value']))
                        except KeyError:
                            # Native segwit outputs (P2WSH and P2WPKH) do not currently have an address
                            # so there are no addresses for these outputs.
                            if sender_vout['scriptPubKey']['type'] in ['witness_v0_keyhash', 'witness_v0_scripthash']:
                                result['sender'].append(('Native_SegWit', sender_vout['value']))
                            elif sender_vout['scriptPubKey']['type'] in ['nonstandard', 'pubkey']:
                                result['sender'].append((sender_vout['scriptPubKey']['type'], sender_vout['value']))
                            else:
                                raise Exception('decoding sender impossible : %s', sender_tx)

        # association between sender, receiver and amount
        for vout in tx['vout']:
            value = vout['value']
            if value != 0.0:
                try:
                    receiver = vout['scriptPubKey']['addresses'][0]
                    btcscript = vout['scriptPubKey']['hex']
                    result['receiver'].append((receiver, value, btcscript))
                except KeyError:
                    # test if Native SegWit outputs
                    if vout['scriptPubKey']['type'] in ['witness_v0_keyhash', 'witness_v0_scripthash']:
                        # Native segwit outputs (P2WSH and P2WPKH) do not currently have an address type
                        # so there are no addresses for these outputs.
                        receiver = 'Native_SegWit'
                        btcscript = vout['scriptPubKey']['hex']
                        result['receiver'].append((receiver, value, btcscript))
                    elif vout['scriptPubKey']['type'] in ['nonstandard', 'pubkey']:
                        receiver = vout['scriptPubKey']['type']
                        btcscript = vout['scriptPubKey']['hex']
                        result['receiver'].append((receiver, value, btcscript))
                    # unknown error
                    else:
                        raise Exception('decoding receiver impossible : %s', tx)

        return result

    ####################
    # JSON-RPC METHODS #
    ####################

    # ressources :
    # * https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list
    # * https://en.bitcoin.it/wiki/Elis-API
    # * http://chainquery.com/bitcoin-api

    def abandontransaction(self, txid):
        '''
        http://chainquery.com/bitcoin-api/abandontransaction

        NOT TESTED

        Mark in-wallet transaction <txid> as abandoned
        This will mark this transaction and all its in-wallet descendants as abandoned which will allow
        for their inputs to be respent.  It can be used to replace "stuck" or evicted transactions.
        It only works on transactions which are not included in a block and are not currently in the mempool.
        It has no effect on transactions which are already conflicted or abandoned.

        Arguments:
        1. "txid"    (string, required) The transaction id

        Result: Null
        '''
        return self.call('abandontransaction', [txid])

    def addmultisigaddress(self, nrequired, keys):
        '''
        http://chainquery.com/bitcoin-api/addmultisigaddress

        NOT TESTED

        Add a nrequired-to-sign multisignature address to the wallet.
        Each key is a Bitcoin address or hex-encoded public key.
        If 'account' is specified (DEPRECATED), assign address to that account.

        Arguments:
        1. nrequired        (numeric, required) The number of required signatures out of the n keys or addresses.
        2. "keys"         (string, required) A json array of bitcoin addresses or hex-encoded public keys
             [
               "address"  (string) bitcoin address or hex-encoded public key
               ...,
             ]
        3. "account"      (string, optional) DEPRECATED. An account to assign the addresses to.

        Result:
        "address"         (string) A bitcoin address associated with the keys.
        '''
        return self.call('addmultisigaddress'[nrequired, keys])

    def addnode(self, node, command):
        '''
        http://chainquery.com/bitcoin-api/addnode

        NOT TESTED

        Attempts to add or remove a node from the addnode list.
        Or try a connection to a node once.

        Arguments:
        1. "node"     (string, required) The node (see getpeerinfo for nodes)
        2. "command"  (string, required) 'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once

        '''
        return self.call('addnode', [node, command])

    def createmultisig(self, nrequired, keys):
        '''
        http://chainquery.com/bitcoin-api/createmultisig

        NOT TESTED

        Creates a multi-signature address with n signature of m keys required.
        It returns a json object with the address and redeemScript.

        Arguments:
        1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.
        2. "keys"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys
             [
               "key"    (string) bitcoin address or hex-encoded public key
               ,...
             ]

        Result:
        {
          "address":"multisigaddress",  (string) The value of the new multisig address.
          "redeemScript":"script"       (string) The string value of the hex-encoded redemption script.
        }
        '''
        return self.call('createmultisig', [nrequired, keys])

    def createrawtransaction(self, inputs, outputs, locktime=0, replaceable=False):
        '''
        http://chainquery.com/bitcoin-api/createrawtransaction

        NOT TESTED

        Create a transaction spending the given inputs and creating new outputs.
        Outputs can be addresses or data.
        Returns hex-encoded raw transaction.
        Note that the transaction's inputs are not signed, and
        it is not stored in the wallet or transmitted to the network.

        Arguments:
        1. "inputs"                (array, required) A json array of json objects
             [
               {
                 "txid":"id",    (string, required) The transaction id
                 "vout":n,         (numeric, required) The output number
                 "sequence":n      (numeric, optional) The sequence number
               }
               ,...
             ]
        2. "outputs"               (object, required) a json object with outputs
            {
              "address": x.xxx,    (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the BTC amount
              "data": "hex"      (string, required) The key is "data", the value is hex encoded data
              ,...
            }
        3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs
        4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.
                                     Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.

        Result:
        "transaction"              (string) hex string of the transaction
        '''
        return self.call('createrawtransaction', [inputs, outputs, locktime, replaceable])

    def decoderawtransaction(self, hexstring):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/decoderawtransaction

        Return a JSON object representing the serialized, hex-encoded transaction.

        Arguments:
        1. "hexstring"      (string, required) The transaction hex string

        Result:
        {
          "txid" : "id",        (string) The transaction id
          "hash" : "id",        (string) The transaction hash (differs from txid for witness transactions)
          "size" : n,             (numeric) The transaction size
          "vsize" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)
          "version" : n,          (numeric) The version
          "locktime" : ttt,       (numeric) The lock time
          "vin" : [               (array of json objects)
             {
               "txid": "id",    (string) The transaction id
               "vout": n,         (numeric) The output number
               "scriptSig": {     (json object) The script
                 "asm": "asm",  (string) asm
                 "hex": "hex"   (string) hex
               },
               "txinwitness": ["hex", ...] (array of string) hex-encoded witness data (if any)
               "sequence": n     (numeric) The script sequence number
             }
             ,...
          ],
          "vout" : [             (array of json objects)
             {
               "value" : x.xxx,            (numeric) The value in BTC
               "n" : n,                    (numeric) index
               "scriptPubKey" : {          (json object)
                 "asm" : "asm",          (string) the asm
                 "hex" : "hex",          (string) the hex
                 "reqSigs" : n,            (numeric) The required sigs
                 "type" : "pubkeyhash",  (string) The type, eg 'pubkeyhash'
                 "addresses" : [           (json array of string)
                   "12tvKAXCxZjSmdNbao16dKXC8tRWfcF5oc"   (string) bitcoin address
                   ,...
                 ]
               }
             }
             ,...
          ],
        }
        '''
        return self.call('decoderawtransaction', [hexstring])

    def decodescript(self, hexstring):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/decodescript

        Decode a hex-encoded script.

        Arguments:
        1. "hexstring"     (string) the hex encoded script

        Result:
        {
          "asm":"asm",   (string) Script public key
          "hex":"hex",   (string) hex encoded public key
          "type":"type", (string) The output type
          "reqSigs": n,    (numeric) The required signatures
          "addresses": [   (json array of string)
             "address"     (string) bitcoin address
             ,...
          ],
          "p2sh","address" (string) address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH).
        }
        '''
        return self.call('decodescript', [hexstring])

    def dumpprivkey(self, address):
        '''
        http://chainquery.com/bitcoin-api/dumpprivkey

        Reveals the private key corresponding to 'address'.
        Then the importprivkey can be used with this output

        Arguments:
        1. "address"   (string, required) The bitcoin address for the private key

        Result:
        "key"                (string) The private key
        '''
        return self.call('dumpprivkey', [address])

    def encryptwallet(self, passphrase):
        '''
        http://chainquery.com/bitcoin-api/encryptwallet

        Parameter #1a passphrase - The passphrase to use for the encrypted wallet. Must be at least one character.
        Resulta notice (with program shutdown on success)

        '''
        return self.call('encryptwallet', [passphrase])

    def estimatefee(self, nblocks):
        '''
        http://chainquery.com/bitcoin-api/estimatefee

        DEPRECATED. Please use estimatesmartfee for more intelligent estimates.
        Estimates the approximate fee per kilobyte needed for a transaction to begin
        confirmation within nblocks blocks. Uses virtual transaction size of transaction
        as defined in BIP 141 (witness data is discounted).

        Arguments:
        1. nblocks     (numeric, required)

        Result:
        n              (numeric) estimated fee-per-kilobyte

        A negative value is returned if not enough transactions and blocks
        have been observed to make an estimate.
        -1 is always returned for nblocks == 1 as it is impossible to calculate
        a fee that is high enough to get reliably included in the next block.
        '''
        return self.call('estimatefee', [nblocks])

    def estimatepriority(self, number):
        '''
        http://chainquery.com/bitcoin-api/estimatepriority

        The estimatepriority RPC estimates the priority that a transaction needs in order to be included within a certain number of blocks as a free high-priority transaction. Transaction priority is relative to a transactions byte size.

        Parameter #1how many blocks the transaction may wait before being included as a free high-priority transaction
        Resultthe priority a transaction needs
        '''
        return self.call('estimatepriority', [number])

    def getaccountaddress(self, account):
        '''
        http://chainquery.com/bitcoin-api/getaccountaddress

        DEPRECATED. Returns the current Bitcoin address for receiving payments to this account.

        Arguments:
        1. "account"       (string, required) The account name for the address. It can also be set to the empty string "" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.

        Result:
        "address"          (string) The account bitcoin address

        '''
        return self.call('getaccountaddress', [account])

    def getaccount(self, address):
        '''
        http://chainquery.com/bitcoin-api/getaccount

        DEPRECATED. Returns the account associated with the given address.

        Arguments:
        1. "address"         (string, required) The bitcoin address for account lookup.

        Result:
        "accountname"        (string) the account address

        '''
        return self.call('getaccount', [address])

    def getaddednodeinfo(self, node):
        '''
        http://chainquery.com/bitcoin-api/getaddednodeinfo

        Returns information about the given added node, or all added nodes
        (note that onetry addnodes are not listed here)

        Arguments:
        1. "node"   (string, optional) If provided, return information about this specific node, otherwise all nodes are returned.

        Result:
        [
          {
            "addednode" : "192.168.0.201",   (string) The node IP address or name (as provided to addnode)
            "connected" : true|false,          (boolean) If connected
            "addresses" : [                    (list of objects) Only when connected = true
               {
                 "address" : "192.168.0.201:8333",  (string) The bitcoin server IP and port we're connected to
                 "connected" : "outbound"           (string) connection, inbound or outbound
               }
             ]
          }
          ,...
        ]

        '''
        return self.call('getaddednodeinfo', [node])

    def getaddressesbyaccount(self, account):
        '''
        http://chainquery.com/bitcoin-api/getaddressesbyaccount

        DEPRECATED. Returns the list of addresses for the given account.

        Arguments:
        1. "account"        (string, required) The account name.

        Result:
        [                     (json array of string)
          "address"         (string) a bitcoin address associated with the given account
          ,...
        ]
        '''
        return self.call('getaddressesbyaccount', [account])

    def getbalance(self, account="*", minconf=1, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/getbalance

        If account is not specified, returns the server's total available balance.
        If account is specified (DEPRECATED), returns the balance in the account.
        Note that the account "" is not the same as leaving the parameter out.
        The server total may be different to the balance in the default "" account.

        Arguments:
        1. "account"         (string, optional) DEPRECATED. The account string may be given as a
                             specific account name to find the balance associated with wallet keys in
                             a named account, or as the empty string ("") to find the balance
                             associated with wallet keys not in any named account, or as "*" to find
                             the balance associated with all wallet keys regardless of account.
                             When this option is specified, it calculates the balance in a different
                             way than when it is not specified, and which can count spends twice when
                             there are conflicting pending transactions (such as those created by
                             the bumpfee command), temporarily resulting in low or even negative
                             balances. In general, account balance calculation is not considered
                             reliable and has resulted in confusing outcomes, so it is recommended to
                             avoid passing this argument.
        2. minconf           (numeric, optional, default=1) Only include transactions confirmed at least this many times.
        3. include_watchonly (bool, optional, default=false) Also include balance in watch-only addresses (see 'importaddress')

        Result:
        amount              (numeric) The total amount in BTC received for this account.

        '''
        return self.call('getbalance', [account, minconf, include_watchonly])

    def getbestblockhash(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getbestblockhash

        Returns the hash of the best (tip) block in the longest blockchain.

        Result:
        "hex"      (string) the block hash hex encoded

        '''
        return self.call('getbestblockhash')

    def getblock(self, blockhash, verbosity=1):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getblock

        If verbosity is 0, returns a string that is serialized, hex-encoded data for block 'hash'.
        If verbosity is 1, returns an Object with information about block <hash>.
        If verbosity is 2, returns an Object with information about block <hash> and information about each transaction. 

        Arguments:
        1. "blockhash"          (string, required) The block hash
        2. verbosity              (numeric, optional, default=1) 0 for hex encoded data, 1 for a json object, and 2 for json object with transaction data

        Result (for verbosity = 0):
        "data"             (string) A string that is serialized, hex-encoded data for block 'hash'.

        Result (for verbosity = 1):
        {
          "hash" : "hash",     (string) the block hash (same as provided)
          "confirmations" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain
          "size" : n,            (numeric) The block size
          "strippedsize" : n,    (numeric) The block size excluding witness data
          "weight" : n           (numeric) The block weight as defined in BIP 141
          "height" : n,          (numeric) The block height or index
          "version" : n,         (numeric) The block version
          "versionHex" : "00000000", (string) The block version formatted in hexadecimal
          "merkleroot" : "xxxx", (string) The merkle root
          "tx" : [               (array of string) The transaction ids
             "transactionid"     (string) The transaction id
             ,...
          ],
          "time" : ttt,          (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)
          "mediantime" : ttt,    (numeric) The median block time in seconds since epoch (Jan 1 1970 GMT)
          "nonce" : n,           (numeric) The nonce
          "bits" : "1d00ffff", (string) The bits
          "difficulty" : x.xxx,  (numeric) The difficulty
          "chainwork" : "xxxx",  (string) Expected number of hashes required to produce the chain up to this block (in hex)
          "previousblockhash" : "hash",  (string) The hash of the previous block
          "nextblockhash" : "hash"       (string) The hash of the next block
        }

        Result (for verbosity = 2):
        {
          ...,                     Same output as verbosity = 1.
          "tx" : [               (array of Objects) The transactions in the format of the getrawtransaction RPC. Different from verbosity = 1 "tx" result.
                 ,...
          ],
          ,...                     Same output as verbosity = 1.
        }
        '''
        return self.call('getblock', [blockhash, verbosity])

    def getblockchaininfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getblockchaininfo

        Returns an object containing various state info regarding blockchain processing.

        Result:
        {
          "chain": "xxxx",        (string) current network name as defined in BIP70 (main, test, regtest)
          "blocks": xxxxxx,         (numeric) the current number of blocks processed in the server
          "headers": xxxxxx,        (numeric) the current number of headers we have validated
          "bestblockhash": "...", (string) the hash of the currently best block
          "difficulty": xxxxxx,     (numeric) the current difficulty
          "mediantime": xxxxxx,     (numeric) median time for the current best block
          "verificationprogress": xxxx, (numeric) estimate of verification progress [0..1]
          "chainwork": "xxxx"     (string) total amount of work in active chain, in hexadecimal
          "pruned": xx,             (boolean) if the blocks are subject to pruning
          "pruneheight": xxxxxx,    (numeric) lowest-height complete block stored
          "softforks": [            (array) status of softforks in progress
             {
                "id": "xxxx",        (string) name of softfork
                "version": xx,         (numeric) block version
                "reject": {            (object) progress toward rejecting pre-softfork blocks
                   "status": xx,       (boolean) true if threshold reached
                },
             }, ...
          ],
          "bip9_softforks": {          (object) status of BIP9 softforks in progress
             "xxxx" : {                (string) name of the softfork
                "status": "xxxx",    (string) one of "defined", "started", "locked_in", "active", "failed"
                "bit": xx,             (numeric) the bit (0-28) in the block version field used to signal this softfork (only for "started" status)
                "startTime": xx,       (numeric) the minimum median time past of a block at which the bit gains its meaning
                "timeout": xx,         (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in
                "since": xx,           (numeric) height of the first block to which the status applies
                "statistics": {        (object) numeric statistics about BIP9 signalling for a softfork (only for "started" status)
                   "period": xx,       (numeric) the length in blocks of the BIP9 signalling period 
                   "threshold": xx,    (numeric) the number of blocks with the version bit set required to activate the feature 
                   "elapsed": xx,      (numeric) the number of blocks elapsed since the beginning of the current period 
                   "count": xx,        (numeric) the number of blocks with the version bit set in the current period 
                   "possible": xx      (boolean) returns false if there are not enough blocks left in this period to pass activation threshold 
                }
             }
          }
        }

        '''
        return self.call('getblockchaininfo')

    def getblockcount(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getblockcount

        Returns the number of blocks in the longest blockchain.

        Result:
        n    (numeric) The current block count

        '''
        return self.call('getblockcount')

    def getblockhash(self, height):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getblockhash

        Returns hash of block in best-block-chain at height provided.

        Arguments:
        1. height         (numeric, required) The height index

        Result:
        "hash"         (string) The block hash

        '''
        return self.call('getblockhash', [height])

    def getblocktemplate(self, template_request=None):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getblocktemplate

        If the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.
        It returns data needed to construct a block to work on.
        For full specification, see BIPs 22, 23, 9, and 145:
            https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki
            https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki
            https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes
            https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki

        Arguments:
        1. template_request         (json object, optional) A json object in the following spec
             {
               "mode":"template"    (string, optional) This must be set to "template", "proposal" (see BIP 23), or omitted
               "capabilities":[     (array, optional) A list of strings
                   "support"          (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'
                   ,...
               ],
               "rules":[            (array, optional) A list of strings
                   "support"          (string) client side supported softfork deployment
                   ,...
               ]
             }

        Result:
        {
          "version" : n,                    (numeric) The preferred block version
          "rules" : [ "rulename", ... ],    (array of strings) specific block rules that are to be enforced
          "vbavailable" : {                 (json object) set of pending, supported versionbit (BIP 9) softfork deployments
              "rulename" : bitnumber          (numeric) identifies the bit number as indicating acceptance and readiness for the named softfork rule
              ,...
          },
          "vbrequired" : n,                 (numeric) bit mask of versionbits the server requires set in submissions
          "previousblockhash" : "xxxx",     (string) The hash of current highest block
          "transactions" : [                (array) contents of non-coinbase transactions that should be included in the next block
              {
                 "data" : "xxxx",             (string) transaction data encoded in hexadecimal (byte-for-byte)
                 "txid" : "xxxx",             (string) transaction id encoded in little-endian hexadecimal
                 "hash" : "xxxx",             (string) hash encoded in little-endian hexadecimal (including witness data)
                 "depends" : [                (array) array of numbers
                     n                          (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is
                     ,...
                 ],
                 "fee": n,                    (numeric) difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one
                 "sigops" : n,                (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero
                 "weight" : n,                (numeric) total transaction weight, as counted for purposes of block limits
                 "required" : true|false      (boolean) if provided and true, this transaction must be in the final block
              }
              ,...
          ],
          "coinbaseaux" : {                 (json object) data that should be included in the coinbase's scriptSig content
              "flags" : "xx"                  (string) key name is to be ignored, and value included in scriptSig
          },
          "coinbasevalue" : n,              (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in Satoshis)
          "coinbasetxn" : { ... },          (json object) information for coinbase transaction
          "target" : "xxxx",                (string) The hash target
          "mintime" : xxx,                  (numeric) The minimum timestamp appropriate for next block time in seconds since epoch (Jan 1 1970 GMT)
          "mutable" : [                     (array of string) list of ways the block template may be changed 
             "value"                          (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'
             ,...
          ],
          "noncerange" : "00000000ffffffff",(string) A range of valid nonces
          "sigoplimit" : n,                 (numeric) limit of sigops in blocks
          "sizelimit" : n,                  (numeric) limit of block size
          "weightlimit" : n,                (numeric) limit of block weight
          "curtime" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)
          "bits" : "xxxxxxxx",              (string) compressed target of next block
          "height" : n                      (numeric) The height of the next block
        }

        '''
        if template_request is None:
            return self.call('getblocktemplate', [template_request])
        else:
            return self.call('getblocktemplate')

    def getchaintips(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getchaintips

        Return information about all known tips in the block tree, including the main chain as well as orphaned branches.

        Result:
        [
          {
            "height": xxxx,         (numeric) height of the chain tip
            "hash": "xxxx",         (string) block hash of the tip
            "branchlen": 0          (numeric) zero for main chain
            "status": "active"      (string) "active" for the main chain
          },
          {
            "height": xxxx,
            "hash": "xxxx",
            "branchlen": 1          (numeric) length of branch connecting the tip to the main chain
            "status": "xxxx"        (string) status of the chain (active, valid-fork, valid-headers, headers-only, invalid)
          }
        ]
        Possible values for status:
        1.  "invalid"               This branch contains at least one invalid block
        2.  "headers-only"          Not all blocks for this branch are available, but the headers are valid
        3.  "valid-headers"         All blocks are available for this branch, but they were never fully validated
        4.  "valid-fork"            This branch is not part of the active chain, but is fully validated
        5.  "active"                This is the tip of the active main chain, which is certainly valid

        '''
        return self.call('getchaintips')

    def getconnectioncount(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getconnectioncount

        Returns the number of connections to other nodes.

        Result:
        n          (numeric) The connection count

        '''
        return self.call('getconnectioncount')

    def getdifficulty(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getdifficulty

        Returns the proof-of-work difficulty as a multiple of the minimum difficulty.

        Result:
        n.nnn       (numeric) the proof-of-work difficulty as a multiple of the minimum difficulty.

        '''
        return self.call('getdifficulty')

    def getgenerate(self):
        '''
        http://chainquery.com/bitcoin-api/getgenerate

        The getgenerate RPC returns true if the node is set to generate blocks using its CPU.

        Parameters: none
        Resultwhether the server is set to generate blocks

        '''
        return self.call('getgenerate')

    def getinfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getinfo

        DEPRECATED. Returns an object containing various state info.

        Result:
        {
          "deprecation-warning": "..." (string) warning that the getinfo command is deprecated and will be removed in 0.16
          "version": xxxxx,           (numeric) the server version
          "protocolversion": xxxxx,   (numeric) the protocol version
          "walletversion": xxxxx,     (numeric) the wallet version
          "balance": xxxxxxx,         (numeric) the total bitcoin balance of the wallet
          "blocks": xxxxxx,           (numeric) the current number of blocks processed in the server
          "timeoffset": xxxxx,        (numeric) the time offset
          "connections": xxxxx,       (numeric) the number of connections
          "proxy": "host:port",       (string, optional) the proxy used by the server
          "difficulty": xxxxxx,       (numeric) the current difficulty
          "testnet": true|false,      (boolean) if the server is using testnet or not
          "keypoololdest": xxxxxx,    (numeric) the timestamp (seconds since Unix epoch) of the oldest pre-generated key in the key pool
          "keypoolsize": xxxx,        (numeric) how many new keys are pre-generated
          "unlocked_until": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked
          "paytxfee": x.xxxx,         (numeric) the transaction fee set in BTC/kB
          "relayfee": x.xxxx,         (numeric) minimum relay fee for transactions in BTC/kB
          "errors": "..."             (string) any error messages
        }

        '''
        return self.call('getinfo')

    def getmempoolinfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getmempoolinfo

        Returns details on the active state of the TX memory pool.

        Result:
        {
          "size": xxxxx,               (numeric) Current tx count
          "bytes": xxxxx,              (numeric) Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted
          "usage": xxxxx,              (numeric) Total memory usage for the mempool
          "maxmempool": xxxxx,         (numeric) Maximum memory usage for the mempool
          "mempoolminfee": xxxxx       (numeric) Minimum feerate (BTC per KB) for tx to be accepted
        }

        '''
        return self.call('getmempoolinfo')

    def getmininginfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getmininginfo

        Returns a json object containing mining-related information.
        Result:
        {
          "blocks": nnn,             (numeric) The current block
          "currentblockweight": nnn, (numeric) The last block weight
          "currentblocktx": nnn,     (numeric) The last block transaction
          "difficulty": xxx.xxxxx    (numeric) The current difficulty
          "errors": "..."            (string) Current errors
          "networkhashps": nnn,      (numeric) The network hashes per second
          "pooledtx": n              (numeric) The size of the mempool
          "chain": "xxxx",           (string) current network name as defined in BIP70 (main, test, regtest)
        }

        '''
        return self.call('getmininginfo')

    def getnettotals(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getnettotals

        Returns information about network traffic, including bytes in, bytes out,
        and current time.

        Result:
        {
          "totalbytesrecv": n,   (numeric) Total bytes received
          "totalbytessent": n,   (numeric) Total bytes sent
          "timemillis": t,       (numeric) Current UNIX time in milliseconds
          "uploadtarget":
          {
            "timeframe": n,                         (numeric) Length of the measuring timeframe in seconds
            "target": n,                            (numeric) Target in bytes
            "target_reached": true|false,           (boolean) True if target is reached
            "serve_historical_blocks": true|false,  (boolean) True if serving historical blocks
            "bytes_left_in_cycle": t,               (numeric) Bytes left in current time cycle
            "time_left_in_cycle": t                 (numeric) Seconds left in current time cycle
          }
        }

        '''
        return self.call('getnettotals')

    def getnetworkhashps(self, nblocks=120, height=-1):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getnetworkhashps

        Returns the estimated network hashes per second based on the last n blocks.
        Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.
        Pass in [height] to estimate the network speed at the time when a certain block was found.

        Arguments:
        1. nblocks     (numeric, optional, default=120) The number of blocks, or -1 for blocks since last difficulty change.
        2. height      (numeric, optional, default=-1) To estimate at the time of the given height.

        Result:
        x             (numeric) Hashes per second estimated

        '''
        return self.call('getnetworkhashps', [nblocks, height])

    def getnetworkinfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getnetworkinfo

        Returns an object containing various state info regarding P2P networking.

        Result:
        {
          "version": xxxxx,                      (numeric) the server version
          "subversion": "/Satoshi:x.x.x/",     (string) the server subversion string
          "protocolversion": xxxxx,              (numeric) the protocol version
          "localservices": "xxxxxxxxxxxxxxxx", (string) the services we offer to the network
          "localrelay": true|false,              (bool) true if transaction relay is requested from peers
          "timeoffset": xxxxx,                   (numeric) the time offset
          "connections": xxxxx,                  (numeric) the number of connections
          "networkactive": true|false,           (bool) whether p2p networking is enabled
          "networks": [                          (array) information per network
          {
            "name": "xxx",                     (string) network (ipv4, ipv6 or onion)
            "limited": true|false,               (boolean) is the network limited using -onlynet?
            "reachable": true|false,             (boolean) is the network reachable?
            "proxy": "host:port"               (string) the proxy that is used for this network, or empty if none
            "proxy_randomize_credentials": true|false,  (string) Whether randomized credentials are used
          }
          ,...
          ],
          "relayfee": x.xxxxxxxx,                (numeric) minimum relay fee for transactions in BTC/kB
          "incrementalfee": x.xxxxxxxx,          (numeric) minimum fee increment for mempool limiting or BIP 125 replacement in BTC/kB
          "localaddresses": [                    (array) list of local addresses
          {
            "address": "xxxx",                 (string) network address
            "port": xxx,                         (numeric) network port
            "score": xxx                         (numeric) relative score
          }
          ,...
          ]
          "warnings": "..."                    (string) any network warnings
        }

        '''
        return self.call('getnetworkinfo')

    def getpeerinfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getpeerinfo

        Returns data about each connected network node as a json array of objects.

        Result:
        [
          {
            "id": n,                   (numeric) Peer index
            "addr":"host:port",      (string) The IP address and port of the peer
            "addrbind":"ip:port",    (string) Bind address of the connection to the peer
            "addrlocal":"ip:port",   (string) Local address as reported by the peer
            "services":"xxxxxxxxxxxxxxxx",   (string) The services offered
            "relaytxes":true|false,    (boolean) Whether peer has asked us to relay transactions to it
            "lastsend": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last send
            "lastrecv": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last receive
            "bytessent": n,            (numeric) The total bytes sent
            "bytesrecv": n,            (numeric) The total bytes received
            "conntime": ttt,           (numeric) The connection time in seconds since epoch (Jan 1 1970 GMT)
            "timeoffset": ttt,         (numeric) The time offset in seconds
            "pingtime": n,             (numeric) ping time (if available)
            "minping": n,              (numeric) minimum observed ping time (if any at all)
            "pingwait": n,             (numeric) ping wait (if non-zero)
            "version": v,              (numeric) The peer version, such as 7001
            "subver": "/Satoshi:0.8.5/",  (string) The string version
            "inbound": true|false,     (boolean) Inbound (true) or Outbound (false)
            "addnode": true|false,     (boolean) Whether connection was due to addnode and is using an addnode slot
            "startingheight": n,       (numeric) The starting height (block) of the peer
            "banscore": n,             (numeric) The ban score
            "synced_headers": n,       (numeric) The last header we have in common with this peer
            "synced_blocks": n,        (numeric) The last block we have in common with this peer
            "inflight": [
               n,                        (numeric) The heights of blocks we're currently asking from this peer
               ...
            ],
            "whitelisted": true|false, (boolean) Whether the peer is whitelisted
            "bytessent_per_msg": {
               "addr": n,              (numeric) The total bytes sent aggregated by message type
               ...
            },
            "bytesrecv_per_msg": {
               "addr": n,              (numeric) The total bytes received aggregated by message type
               ...
            }
          }
          ,...
        ]

        '''
        return self.call('getpeerinfo')

    def getrawmempool(self, verbose=False):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getrawmempool

        Returns all transaction ids in memory pool as a json array of string transaction ids.

        Hint: use getmempoolentry to fetch a specific transaction from the mempool.

        Arguments:
        1. verbose (boolean, optional, default=false) True for a json object, false for array of transaction ids

        Result: (for verbose = false):
        [                     (json array of string)
          "transactionid"     (string) The transaction id
          ,...
        ]

        Result: (for verbose = true):
        {                           (json object)
          "transactionid" : {       (json object)
            "size" : n,             (numeric) virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
            "fee" : n,              (numeric) transaction fee in BTC
            "modifiedfee" : n,      (numeric) transaction fee with fee deltas used for mining priority
            "time" : n,             (numeric) local time transaction entered pool in seconds since 1 Jan 1970 GMT
            "height" : n,           (numeric) block height when transaction entered pool
            "descendantcount" : n,  (numeric) number of in-mempool descendant transactions (including this one)
            "descendantsize" : n,   (numeric) virtual transaction size of in-mempool descendants (including this one)
            "descendantfees" : n,   (numeric) modified fees (see above) of in-mempool descendants (including this one)
            "ancestorcount" : n,    (numeric) number of in-mempool ancestor transactions (including this one)
            "ancestorsize" : n,     (numeric) virtual transaction size of in-mempool ancestors (including this one)
            "ancestorfees" : n,     (numeric) modified fees (see above) of in-mempool ancestors (including this one)
            "depends" : [           (array) unconfirmed transactions used as inputs for this transaction
                "transactionid",    (string) parent transaction id
               ... ]
          }, ...
        }

        '''
        return self.call('getrawmempool', [verbose])

    def getrawtransaction(self, txid, verbose=False):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getrawtransaction

        NOTE: By default this function only works for mempool transactions. If the -txindex option is
        enabled, it also works for blockchain transactions.
        DEPRECATED: for now, it also works for transactions with unspent outputs.

        Return the raw transaction data.

        If verbose is 'true', returns an Object with information about 'txid'.
        If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.

        Arguments:
        1. "txid"      (string, required) The transaction id
        2. verbose       (bool, optional, default=false) If false, return a string, otherwise return a json object

        Result (if verbose is not set or set to false):
        "data"      (string) The serialized, hex-encoded data for 'txid'

        Result (if verbose is set to true):
        {
          "hex" : "data",       (string) The serialized, hex-encoded data for 'txid'
          "txid" : "id",        (string) The transaction id (same as provided)
          "hash" : "id",        (string) The transaction hash (differs from txid for witness transactions)
          "size" : n,             (numeric) The serialized transaction size
          "vsize" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)
          "version" : n,          (numeric) The version
          "locktime" : ttt,       (numeric) The lock time
          "vin" : [               (array of json objects)
             {
               "txid": "id",    (string) The transaction id
               "vout": n,         (numeric)
               "scriptSig": {     (json object) The script
                 "asm": "asm",  (string) asm
                 "hex": "hex"   (string) hex
               },
               "sequence": n      (numeric) The script sequence number
               "txinwitness": ["hex", ...] (array of string) hex-encoded witness data (if any)
             }
             ,...
          ],
          "vout" : [              (array of json objects)
             {
               "value" : x.xxx,            (numeric) The value in BTC
               "n" : n,                    (numeric) index
               "scriptPubKey" : {          (json object)
                 "asm" : "asm",          (string) the asm
                 "hex" : "hex",          (string) the hex
                 "reqSigs" : n,            (numeric) The required sigs
                 "type" : "pubkeyhash",  (string) The type, eg 'pubkeyhash'
                 "addresses" : [           (json array of string)
                   "address"        (string) bitcoin address
                   ,...
                 ]
               }
             }
             ,...
          ],
          "blockhash" : "hash",   (string) the block hash
          "confirmations" : n,      (numeric) The confirmations
          "time" : ttt,             (numeric) The transaction time in seconds since epoch (Jan 1 1970 GMT)
          "blocktime" : ttt         (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)
        }

        '''
        return self.call('getrawtransaction', [txid, verbose])

    def getreceivedbyaccount(self, account, minconf=1):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getreceivedbyaccount

        DEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.

        Arguments:
        1. "account"      (string, required) The selected account, may be the default account using "".
        2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.

        Result:
        amount              (numeric) The total amount in BTC received for this account.

        '''
        return self.call('getreceivedbyaccount', [account, minconf])

    def getreceivedbyaddress(self, address, minconf=1):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getreceivedbyaddress

        Returns the total amount received by the given address in transactions with at least minconf confirmations.

        Arguments:
        1. "address"         (string, required) The bitcoin address for transactions.
        2. minconf             (numeric, optional, default=1) Only include transactions confirmed at least this many times.

        Result:
        amount   (numeric) The total amount in BTC received at this address.

        '''
        return self.call('getreceivedbyaddress', [address, minconf])

    def gettransaction(self, txid, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/gettransaction

        Get detailed information about in-wallet transaction <txid>

        Arguments:
        1. "txid"                  (string, required) The transaction id
        2. "include_watchonly"     (bool, optional, default=false) Whether to include watch-only addresses in balance calculation and details[]

        Result:
        {
          "amount" : x.xxx,        (numeric) The transaction amount in BTC
          "fee": x.xxx,            (numeric) The amount of the fee in BTC. This is negative and only available for the 
                                      'send' category of transactions.
          "confirmations" : n,     (numeric) The number of confirmations
          "blockhash" : "hash",  (string) The block hash
          "blockindex" : xx,       (numeric) The index of the transaction in the block that includes it
          "blocktime" : ttt,       (numeric) The time in seconds since epoch (1 Jan 1970 GMT)
          "txid" : "transactionid",   (string) The transaction id.
          "time" : ttt,            (numeric) The transaction time in seconds since epoch (1 Jan 1970 GMT)
          "timereceived" : ttt,    (numeric) The time received in seconds since epoch (1 Jan 1970 GMT)
          "bip125-replaceable": "yes|no|unknown",  (string) Whether this transaction could be replaced due to BIP125 (replace-by-fee);
                                                           may be unknown for unconfirmed transactions not in the mempool
          "details" : [
            {
              "account" : "accountname",      (string) DEPRECATED. The account name involved in the transaction, can be "" for the default account.
              "address" : "address",          (string) The bitcoin address involved in the transaction
              "category" : "send|receive",    (string) The category, either 'send' or 'receive'
              "amount" : x.xxx,                 (numeric) The amount in BTC
              "label" : "label",              (string) A comment for the address/transaction, if any
              "vout" : n,                       (numeric) the vout value
              "fee": x.xxx,                     (numeric) The amount of the fee in BTC. This is negative and only available for the 
                                                   'send' category of transactions.
              "abandoned": xxx                  (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 
                                                   'send' category of transactions.
            }
            ,...
          ],
          "hex" : "data"         (string) Raw data for transaction
        }

        '''
        return self.call('gettransaction', [txid, include_watchonly])

    def gettxout(self, txid, n, include_mempool=True):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/gettxout

        Returns details about an unspent transaction output.

        Arguments:
        1. "txid"             (string, required) The transaction id
        2. "n"                (numeric, required) vout number
        3. "include_mempool"  (boolean, optional) Whether to include the mempool. Default: true.     Note that an unspent output that is spent in the mempool won't appear.

        Result:
        {
          "bestblock" : "hash",    (string) the block hash
          "confirmations" : n,       (numeric) The number of confirmations
          "value" : x.xxx,           (numeric) The transaction value in BTC
          "scriptPubKey" : {         (json object)
             "asm" : "code",       (string)
             "hex" : "hex",        (string)
             "reqSigs" : n,          (numeric) Number of required signatures
             "type" : "pubkeyhash", (string) The type, eg pubkeyhash
             "addresses" : [          (array of string) array of bitcoin addresses
                "address"     (string) bitcoin address
                ,...
             ]
          },
          "coinbase" : true|false   (boolean) Coinbase or not
        }
        '''
        return self.call('gettxout', [txid, n, include_mempool])

    def gettxoutproof(self, txids, blockhash=None):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/gettxoutproof

        Returns a hex-encoded proof that "txid" was included in a block.

        NOTE: By default this function only works sometimes. This is when there is an
        unspent output in the utxo for this transaction. To make it always work,
        you need to maintain a transaction index, using the -txindex command line option or
        specify the block in which the transaction is included manually (by blockhash).

        Arguments:
        1. "txids"       (string) A json array of txids to filter
            [
              "txid"     (string) A transaction hash
              ,...
            ]
        2. "blockhash"   (string, optional) If specified, looks for txid in the block with this hash

        Result:
        "data"           (string) A string that is a serialized, hex-encoded data for the proof.

        '''
        if blockhash is None:
            return self.call('gettxoutproof', [txids])
        else:
            return self.call('gettxoutproof', [txids, blockhash])

    def getunconfirmedbalance(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getunconfirmedbalance

        Returns the server's total unconfirmed balance
        '''
        return self.call('getunconfirmedbalance')

    def getwalletinfo(self):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/getwalletinfo

        Returns an object containing various wallet state info.

        Result:
        {
          "walletname": xxxxx,             (string) the wallet name
          "walletversion": xxxxx,          (numeric) the wallet version
          "balance": xxxxxxx,              (numeric) the total confirmed balance of the wallet in BTC
          "unconfirmed_balance": xxx,      (numeric) the total unconfirmed balance of the wallet in BTC
          "immature_balance": xxxxxx,      (numeric) the total immature balance of the wallet in BTC
          "txcount": xxxxxxx,              (numeric) the total number of transactions in the wallet
          "keypoololdest": xxxxxx,         (numeric) the timestamp (seconds since Unix epoch) of the oldest pre-generated key in the key pool
          "keypoolsize": xxxx,             (numeric) how many new keys are pre-generated (only counts external keys)
          "keypoolsize_hd_internal": xxxx, (numeric) how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)
          "unlocked_until": ttt,           (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked
          "paytxfee": x.xxxx,              (numeric) the transaction fee configuration, set in BTC/kB
          "hdmasterkeyid": "<hash160>"     (string) the Hash160 of the HD master pubkey
        }

        '''
        return self.call('getwalletinfo')

    def help(self, command=None):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/help

        List all commands, or get help for a specified command.

        Arguments:
        1. "command"     (string, optional) The command to get help on

        Result:
        "text"     (string) The help text

        '''
        if command is None:
            return self.call('help')
        else:
            return self.call('help', [command])

    def keypoolrefill(self, newsize=100):
        '''

        SEEM TO WORK (no RPC error)

        http://chainquery.com/bitcoin-api/keypoolrefill

        Fills the keypool.
        Requires wallet passphrase to be set with walletpassphrase call.

        Arguments
        1. newsize     (numeric, optional, default=100) The new keypool size

        '''
        return self.call('keypoolrefill', [newsize])

    def listaccounts(self, minconf=1, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/listaccounts

        SEEM TO WORK (no RPC error)

        DEPRECATED. Returns Object that has account names as keys, account balances as values.

        Arguments:
        1. minconf             (numeric, optional, default=1) Only include transactions with at least this many confirmations
        2. include_watchonly   (bool, optional, default=false) Include balances in watch-only addresses (see 'importaddress')

        Result:
        {                      (json object where keys are account names, and values are numeric balances
          "account": x.xxx,  (numeric) The property name is the account name, and the value is the total balance for the account.
          ...
        }

        '''
        return self.call('listaccounts', [minconf, include_watchonly])

    def listaddressgroupings(self):
        '''
        http://chainquery.com/bitcoin-api/listaddressgroupings

        SEEM TO WORK (no RPC error)

        Lists groups of addresses which have had their common ownership
        made public by common use as inputs or as the resulting change
        in past transactions

        Result:
        [
          [
            [
              "address",            (string) The bitcoin address
              amount,                 (numeric) The amount in BTC
              "account"             (string, optional) DEPRECATED. The account
            ]
            ,...
          ]
          ,...
        ]
        '''
        return self.call('listaddressgroupings')

    def listlockunspent(self):
        '''
        http://chainquery.com/bitcoin-api/listlockunspent

        SEEM TO WORK (no RPC error)

        Returns list of temporarily unspendable outputs.
        See the lockunspent call to lock and unlock transactions for spending.

        Result:
        [
          {
            "txid" : "transactionid",     (string) The transaction id locked
            "vout" : n                      (numeric) The vout value
          }
          ,...
        ]

        '''
        return self.call('listlockunspent')

    def listreceivedbyaccount(self, minconf=1, include_empty=False, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/listreceivedbyaccount

        SEEM TO WORK (no RPC error)

        DEPRECATED. List balances by account.

        Arguments:
        1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.
        2. include_empty     (bool, optional, default=false) Whether to include accounts that haven't received any payments.
        3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').

        Result:
        [
          {
            "involvesWatchonly" : true,   (bool) Only returned if imported addresses were involved in transaction
            "account" : "accountname",  (string) The account name of the receiving account
            "amount" : x.xxx,             (numeric) The total amount received by addresses with this account
            "confirmations" : n,          (numeric) The number of confirmations of the most recent transaction included
            "label" : "label"           (string) A comment for the address/transaction, if any
          }
          ,...
        ]
        '''
        return self.call('listreceivedbyaccount', [minconf, include_empty, include_watchonly])

    def listreceivedbyaddress(self, minconf=1, include_empty=False, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/listreceivedbyaddress

        SEEM TO WORK (no RPC error)

        List balances by receiving address.

        Arguments:
        1. minconf           (numeric, optional, default=1) The minimum number of confirmations before payments are included.
        2. include_empty     (bool, optional, default=false) Whether to include addresses that haven't received any payments.
        3. include_watchonly (bool, optional, default=false) Whether to include watch-only addresses (see 'importaddress').

        Result:
        [
          {
            "involvesWatchonly" : true,        (bool) Only returned if imported addresses were involved in transaction
            "address" : "receivingaddress",  (string) The receiving address
            "account" : "accountname",       (string) DEPRECATED. The account of the receiving address. The default account is "".
            "amount" : x.xxx,                  (numeric) The total amount in BTC received by the address
            "confirmations" : n,               (numeric) The number of confirmations of the most recent transaction included
            "label" : "label",               (string) A comment for the address/transaction, if any
            "txids": [
               n,                                (numeric) The ids of transactions received with the address 
               ...
            ]
          }
          ,...
        ]
        '''
        return self.call('listreceivedbyaddress', [minconf, include_empty, include_watchonly])

    def listtransactions(self, account="*", count=10, skip=0, include_watchonly=False):
        '''
        http://chainquery.com/bitcoin-api/listtransactions

        SEEM TO WORK (no RPC error)

        Returns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.

        Arguments:
        1. "account"    (string, optional) DEPRECATED. The account name. Should be "*".
        2. count          (numeric, optional, default=10) The number of transactions to return
        3. skip           (numeric, optional, default=0) The number of transactions to skip
        4. include_watchonly (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')

        Result:
        [
          {
            "account":"accountname",       (string) DEPRECATED. The account name associated with the transaction. 
                                                        It will be "" for the default account.
            "address":"address",    (string) The bitcoin address of the transaction. Not present for 
                                                        move transactions (category = move).
            "category":"send|receive|move", (string) The transaction category. 'move' is a local (off blockchain)
                                                        transaction between accounts, and not associated with an address,
                                                        transaction id or block. 'send' and 'receive' transactions are 
                                                        associated with an address, transaction id and block details
            "amount": x.xxx,          (numeric) The amount in BTC. This is negative for the 'send' category, and for the
                                                 'move' category for moves outbound. It is positive for the 'receive' category,
                                                 and for the 'move' category for inbound funds.
            "label": "label",       (string) A comment for the address/transaction, if any
            "vout": n,                (numeric) the vout value
            "fee": x.xxx,             (numeric) The amount of the fee in BTC. This is negative and only available for the 
                                                 'send' category of transactions.
            "confirmations": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and 
                                                 'receive' category of transactions. Negative confirmations indicate the
                                                 transaction conflicts with the block chain
            "trusted": xxx,           (bool) Whether we consider the outputs of this unconfirmed transaction safe to spend.
            "blockhash": "hashvalue", (string) The block hash containing the transaction. Available for 'send' and 'receive'
                                                  category of transactions.
            "blockindex": n,          (numeric) The index of the transaction in the block that includes it. Available for 'send' and 'receive'
                                                  category of transactions.
            "blocktime": xxx,         (numeric) The block time in seconds since epoch (1 Jan 1970 GMT).
            "txid": "transactionid", (string) The transaction id. Available for 'send' and 'receive' category of transactions.
            "time": xxx,              (numeric) The transaction time in seconds since epoch (midnight Jan 1 1970 GMT).
            "timereceived": xxx,      (numeric) The time received in seconds since epoch (midnight Jan 1 1970 GMT). Available 
                                                  for 'send' and 'receive' category of transactions.
            "comment": "...",       (string) If a comment is associated with the transaction.
            "otheraccount": "accountname",  (string) DEPRECATED. For the 'move' category of transactions, the account the funds came 
                                                  from (for receiving funds, positive amounts), or went to (for sending funds,
                                                  negative amounts).
            "bip125-replaceable": "yes|no|unknown",  (string) Whether this transaction could be replaced due to BIP125 (replace-by-fee);
                                                             may be unknown for unconfirmed transactions not in the mempool
            "abandoned": xxx          (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 
                                                 'send' category of transactions.
          }
        ]

        '''
        return self.call('listtransactions', [account, count, skip, include_watchonly])

    def listunspent(self, minconf=1, maxconf=9999999, addresses=[], include_unsafe=True, query_options={}):
        '''
        http://chainquery.com/bitcoin-api/listunspent

        SEEM TO WORK (no RPC error)

        Returns array of unspent transaction outputs
        with between minconf and maxconf (inclusive) confirmations.
        Optionally filter to only include txouts paid to specified addresses.

        Arguments:
        1. minconf          (numeric, optional, default=1) The minimum confirmations to filter
        2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter
        3. "addresses"      (string) A json array of bitcoin addresses to filter
            [
              "address"     (string) bitcoin address
              ,...
            ]
        4. include_unsafe (bool, optional, default=true) Include outputs that are not safe to spend
                          See description of "safe" attribute below.
        5. query_options    (json, optional) JSON with query options
            {
              "minimumAmount"    (numeric or string, default=0) Minimum value of each UTXO in BTC
              "maximumAmount"    (numeric or string, default=unlimited) Maximum value of each UTXO in BTC
              "maximumCount"     (numeric or string, default=unlimited) Maximum number of UTXOs
              "minimumSumAmount" (numeric or string, default=unlimited) Minimum sum value of all UTXOs in BTC
            }

        Result
        [                   (array of json object)
          {
            "txid" : "txid",          (string) the transaction id
            "vout" : n,               (numeric) the vout value
            "address" : "address",    (string) the bitcoin address
            "account" : "account",    (string) DEPRECATED. The associated account, or "" for the default account
            "scriptPubKey" : "key",   (string) the script key
            "amount" : x.xxx,         (numeric) the transaction output amount in BTC
            "confirmations" : n,      (numeric) The number of confirmations
            "redeemScript" : n        (string) The redeemScript if scriptPubKey is P2SH
            "spendable" : xxx,        (bool) Whether we have the private keys to spend this output
            "solvable" : xxx,         (bool) Whether we know how to spend this output, ignoring the lack of keys
            "safe" : xxx              (bool) Whether this output is considered safe to spend. Unconfirmed transactions
                                      from outside keys and unconfirmed replacement transactions are considered unsafe
                                      and are not eligible for spending by fundrawtransaction and sendtoaddress.
          }
          ,...
        ]
        '''
        return self.call('listunspent', [minconf, maxconf, addresses, include_unsafe, query_options])

    def lockunspent(self, unlock, transactions=None):
        '''

        TESTED

        http://chainquery.com/bitcoin-api/lockunspent

        Updates list of temporarily unspendable outputs.
        Temporarily lock (unlock=false) or unlock (unlock=true) specified transaction outputs.
        If no transaction outputs are specified when unlocking then all current locked transaction outputs are unlocked.
        A locked transaction output will not be chosen by automatic coin selection, when spending bitcoins.
        Locks are stored in memory only. Nodes start with zero locked outputs, and the locked output list
        is always cleared (by virtue of process exit) when a node stops or fails.
        Also see the listunspent call

        Arguments:
        1. unlock            (boolean, required) Whether to unlock (true) or lock (false) the specified transactions
        2. "transactions"  (string, optional) A json array of objects. Each object the txid (string) vout (numeric)
             [           (json array of json objects)
               {
                 "txid":"id",    (string) The transaction id
                 "vout": n         (numeric) The output number
               }
               ,...
             ]

        Result:
        true|false    (boolean) Whether the command was successful or not

        '''
        if transactions is None:
            return self.call('lockunspent', [unlock])
        else:
            return self.call('lockunspent', [unlock, transactions])

    def prioritisetransaction(self, txid, fee_delta):
        '''
        http://chainquery.com/bitcoin-api/prioritisetransaction

        NOT TESTED

        Accepts the transaction into mined blocks at a higher (or lower) priority

        Arguments:
        1. "txid"       (string, required) The transaction id.
        2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.
                          DEPRECATED. For forward compatibility use named arguments and omit this parameter.
        3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).
                          The fee is not actually paid, only the algorithm for selecting transactions into a block
                          considers the transaction as it would have paid a higher (or lower) fee.

        Result:
        true              (boolean) Returns true

        '''
        return self.call('prioritisetransaction', [txid, fee_delta])

    def sendfrom(self, fromaccount, toaddress, amount, minconf=1, comment=None, comment_to=None):
        '''
        http://chainquery.com/bitcoin-api/sendfrom

        NOT TESTED

        DEPRECATED (use sendtoaddress). Sent an amount from an account to a bitcoin address.
        Requires wallet passphrase to be set with walletpassphrase call.

        Arguments:
        1. "fromaccount"       (string, required) The name of the account to send funds from. May be the default account using "".
                               Specifying an account does not influence coin selection, but it does associate the newly created
                               transaction with the account, so the account's balance computation and transaction history can reflect
                               the spend.
        2. "toaddress"         (string, required) The bitcoin address to send funds to.
        3. amount                (numeric or string, required) The amount in BTC (transaction fee is added on top).
        4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.
        5. "comment"           (string, optional) A comment used to store what the transaction is for. 
                                             This is not part of the transaction, just kept in your wallet.
        6. "comment_to"        (string, optional) An optional comment to store the name of the person or organization 
                                             to which you're sending the transaction. This is not part of the transaction, 
                                             it is just kept in your wallet.

        Result:
        "txid"                 (string) The transaction id.

        '''
        param = [fromaccount, toaddress, amount]
        if comment is not None:
            param.append(comment)
        if comment_to is not None:
            param.append(comment_to)
        return self.call('sendfrom', param)

    def sendmany(self, fromaccount, amounts, minconf=1, comment=None, subtractfeefrom=None, replaceable=None, conf_target=None, estimate_mode="UNSET"):
        '''
        http://chainquery.com/bitcoin-api/sendmany

        NOT TESTED

        Send multiple times. Amounts are double-precision floating point numbers.
        Requires wallet passphrase to be set with walletpassphrase call.

        Arguments:
        1. "fromaccount"         (string, required) DEPRECATED. The account to send the funds from. Should be "" for the default account
        2. "amounts"             (string, required) A json object with addresses and amounts
            {
              "address":amount   (numeric or string) The bitcoin address is the key, the numeric amount (can be string) in BTC is the value
              ,...
            }
        3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.
        4. "comment"             (string, optional) A comment
        5. subtractfeefrom         (array, optional) A json array with addresses.
                                   The fee will be equally deducted from the amount of each selected address.
                                   Those recipients will receive less bitcoins than you enter in their corresponding amount field.
                                   If no addresses are specified here, the sender pays the fee.
            [
              "address"          (string) Subtract fee from this address
              ,...
            ]
        6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125
        7. conf_target            (numeric, optional) Confirmation target (in blocks)
        8. "estimate_mode"      (string, optional, default=UNSET) The fee estimate mode, must be one of:
               "UNSET"
               "ECONOMICAL"
               "CONSERVATIVE"

        Result:
        "txid"                   (string) The transaction id for the send. Only 1 transaction is created regardless of 
                                            the number of addresses.

        '''
        param = [fromaccount, amounts, minconf]
        if comment is not None:
            param.append(comment)
        if subtractfeefrom is not None:
            param.append(subtractfeefrom)
        if replaceable is not None:
            param.append(replaceable)
        if conf_target is not None:
            param.append(conf_target)
        param.append(estimate_mode)
        return self.call('sendmany', param)

    def sendrawtransaction(self, hexstring, allowhighfees=False):
        '''
        http://chainquery.com/bitcoin-api/sendrawtransaction

        NOT TESTED

        Submits raw transaction (serialized, hex-encoded) to local node and network.

        Also see createrawtransaction and signrawtransaction calls.

        Arguments:
        1. "hexstring"    (string, required) The hex string of the raw transaction)
        2. allowhighfees    (boolean, optional, default=false) Allow high fees

        Result:
        "hex"             (string) The transaction hash in hex

        '''
        return self.call('sendrawtransaction', [hexstring, allowhighfees])

    def sendtoaddress(self, address, amount, comment=None, comment_to=None, subtractfeefromamount=False, replaceable=None, estimate_mode="UNSET"):
        '''
        http://chainquery.com/bitcoin-api/sendtoaddress

        NOT TESTED

        Send an amount to a given address.

        Requires wallet passphrase to be set with walletpassphrase call.
        Arguments:
        1. "address"            (string, required) The bitcoin address to send to.
        2. "amount"             (numeric or string, required) The amount in BTC to send. eg 0.1
        3. "comment"            (string, optional) A comment used to store what the transaction is for. 
                                     This is not part of the transaction, just kept in your wallet.
        4. "comment_to"         (string, optional) A comment to store the name of the person or organization 
                                     to which you're sending the transaction. This is not part of the 
                                     transaction, just kept in your wallet.
        5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.
                                     The recipient will receive less bitcoins than you enter in the amount field.
        6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125
        7. conf_target            (numeric, optional) Confirmation target (in blocks)
        8. "estimate_mode"      (string, optional, default=UNSET) The fee estimate mode, must be one of:
               "UNSET"
               "ECONOMICAL"
               "CONSERVATIVE"

        Result:
        "txid"                  (string) The transaction id.

        '''
        param = [address, amount]
        if comment is not None:
            param.append(comment)
        if comment_to is not None:
            param.append(comment_to)
        param.append(subtractfeefromamount)
        if replaceable is not None:
            param.append(replaceable)
        param.append(estimate_mode)
        return self.call('sendtoaddress', param)

    def settxfee(self, amount):
        '''
        http://chainquery.com/bitcoin-api/settxfee

        SEEM TO WORK (no RPC error)

        Set the transaction fee per kB. Overwrites the paytxfee parameter.

        Arguments:
        1. amount         (numeric or string, required) The transaction fee in BTC/kB

        Result
        true|false        (boolean) Returns true if successful

        '''
        return self.call('settxfee', [amount])

    def signmessage(self, address, message):
        '''
        http://chainquery.com/bitcoin-api/signmessage

        NOT TESTED

        Sign a message with the private key of an address
        Requires wallet passphrase to be set with walletpassphrase call.

        Arguments:
        1. "address"         (string, required) The bitcoin address to use for the private key.
        2. "message"         (string, required) The message to create a signature of.

        Result:
        "signature"          (string) The signature of the message encoded in base 64

        '''
        return self.call('signmessage', [address, message])

    def signrawtransaction(self, hexstring, prevtxs=None, privkeys=None, sighashtype="ALL"):
        '''
        http://chainquery.com/bitcoin-api/signrawtransaction

        NOT TESTED

        Sign inputs for raw transaction (serialized, hex-encoded).
        The second optional argument (may be null) is an array of previous transaction outputs that
        this transaction depends on but may not yet be in the block chain.
        The third optional argument (may be null) is an array of base58-encoded private
        keys that, if given, will be the only keys used to sign the transaction.

        Requires wallet passphrase to be set with walletpassphrase call.

        Arguments:
        1. "hexstring"     (string, required) The transaction hex string
        2. "prevtxs"       (string, optional) An json array of previous dependent transaction outputs
             [               (json array of json objects, or 'null' if none provided)
               {
                 "txid":"id",             (string, required) The transaction id
                 "vout":n,                  (numeric, required) The output number
                 "scriptPubKey": "hex",   (string, required) script key
                 "redeemScript": "hex",   (string, required for P2SH or P2WSH) redeem script
                 "amount": value            (numeric, required) The amount spent
               }
               ,...
            ]
        3. "privkeys"     (string, optional) A json array of base58-encoded private keys for signing
            [                  (json array of strings, or 'null' if none provided)
              "privatekey"   (string) private key in base58-encoding
              ,...
            ]
        4. "sighashtype"     (string, optional, default=ALL) The signature hash type. Must be one of
               "ALL"
               "NONE"
               "SINGLE"
               "ALL|ANYONECANPAY"
               "NONE|ANYONECANPAY"
               "SINGLE|ANYONECANPAY"

        Result:
        {
          "hex" : "value",           (string) The hex-encoded raw transaction with signature(s)
          "complete" : true|false,   (boolean) If the transaction has a complete set of signatures
          "errors" : [                 (json array of objects) Script verification errors (if there are any)
            {
              "txid" : "hash",           (string) The hash of the referenced, previous transaction
              "vout" : n,                (numeric) The index of the output to spent and used as input
              "scriptSig" : "hex",       (string) The hex-encoded signature script
              "sequence" : n,            (numeric) Script sequence number
              "error" : "text"           (string) Verification or signing error related to the input
            }
            ,...
          ]
        }

        '''
        param = [hexstring]
        if prevtxs is not None:
            param.append(prevtxs)
        if privkeys is not None:
            param.append(privkeys)
        param.append(sighashtype)
        return self.call('signrawtransaction', param)

    def submitblock(self, hexdata, dummy=None):
        '''
        http://chainquery.com/bitcoin-api/submitblock

        NOT TESTED

        Attempts to submit new block to network.
        See https://en.bitcoin.it/wiki/BIP_0022 for full specification.

        Arguments
        1. "hexdata"        (string, required) the hex-encoded block data to submit
        2. "dummy"          (optional) dummy value, for compatibility with BIP22. This value is ignored.

        Result: None

        '''
        if dummy is None:
            return self.call('submitblock', [hexdata])
        else:
            return self.call('submitblock', [hexdata, dummy])

    def validateaddress(self, address):
        '''
        http://chainquery.com/bitcoin-api/validateaddress

        TESTED

        Return information about the given bitcoin address.

        Arguments:
        1. "address"     (string, required) The bitcoin address to validate

        Result:
        {
          "isvalid" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.
          "address" : "address", (string) The bitcoin address validated
          "scriptPubKey" : "hex",       (string) The hex encoded scriptPubKey generated by the address
          "ismine" : true|false,        (boolean) If the address is yours or not
          "iswatchonly" : true|false,   (boolean) If the address is watchonly
          "isscript" : true|false,      (boolean) If the key is a script
          "script" : "type"             (string, optional) The output script type. Possible types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash, witness_v0_scripthash
          "hex" : "hex",                (string, optional) The redeemscript for the p2sh address
          "addresses"                   (string, optional) Array of addresses associated with the known redeemscript
            [
              "address"
              ,...
            ]
          "sigsrequired" : xxxxx        (numeric, optional) Number of signatures required to spend multisig output
          "pubkey" : "publickeyhex",    (string) The hex value of the raw public key
          "iscompressed" : true|false,  (boolean) If the address is compressed
          "account" : "account"         (string) DEPRECATED. The account associated with the address, "" is the default account
          "timestamp" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)
          "hdkeypath" : "keypath"       (string, optional) The HD keypath if the key is HD and available
          "hdmasterkeyid" : "<hash160>" (string, optional) The Hash160 of the HD master pubkey
        }

        '''
        return self.call('validateaddress', [address])

    def verifymessage(self, address, signature, message):
        '''
        http://chainquery.com/bitcoin-api/verifymessage

        NOT TESTED

        Verify a signed message

        Arguments:
        1. "address"         (string, required) The bitcoin address to use for the signature.
        2. "signature"       (string, required) The signature provided by the signer in base 64 encoding (see signmessage).
        3. "message"         (string, required) The message that was signed.

        Result:
        true|false   (boolean) If the signature is verified or not.

        '''
        return self.call('verifymessage', [address, signature, message])

    def verifytxoutproof(self, proof):
        '''
        http://chainquery.com/bitcoin-api/verifytxoutproof

        TESTED

        Verifies that a proof points to a transaction in a block, returning the transaction it commits to
        and throwing an RPC error if the block is not in our best chain

        Arguments:
        1. "proof"    (string, required) The hex-encoded proof generated by gettxoutproof

        Result:
        ["txid"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof is invalid

        '''
        return self.call('verifytxoutproof', [proof])

    def walletlock(self):
        '''
        http://chainquery.com/bitcoin-api/walletlock

        NOT TESTED

        Parameters: none
        Resultnull on success

        Removes the wallet encryption key from memory, locking the wallet.
        After calling this method, you will need to call walletpassphrase again
        before being able to call any methods which require the wallet to be unlocked.

        '''
        return self.call('walletlock')

    def walletpassphrase(self, passphrase, timeout):
        '''
        http://chainquery.com/bitcoin-api/walletpassphrase

        NOT TESTED

        Stores the wallet decryption key in memory for 'timeout' seconds.
        This is needed prior to performing transactions related to private keys such as sending bitcoins

        Arguments:
        1. "passphrase"     (string, required) The wallet passphrase
        2. timeout            (numeric, required) The time to keep the decryption key in seconds.

        Note:
        Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock
        time that overrides the old one.

        '''
        return self.call('walletpassphrase', [passphrase, timeout])

    def walletpassphrasechange(self, oldpassphrase, newpassphrase):
        '''
        http://chainquery.com/bitcoin-api/walletpassphrasechange

        NOT TESTED

        Changes the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.

        Arguments:
        1. "oldpassphrase"      (string) The current passphrase
        2. "newpassphrase"      (string) The new passphrase

        '''
        return self.call('walletpassphrasechange', [oldpassphrase, newpassphrase])

class BitcoinBitcoreExplorerRPC(BitcoinExplorerRPC):
    '''
    BitcoinExplorerRPC subclass for bitcored-specific methods

    new RPC calls : https://bitcore.io/guides/bitcoin
    '''

    def __init__(self, host):
        BitcoinExplorerRPC.__init__(self, host=host)

    def getaddresstxids(self):
        raise NotImplementedError

    def getblock(self, blockhash, verbosity=True):
        return self.call('getblock', [blockhash, verbosity])

    def __script_pub_key_to_bech32(self, script):
        # remove OP_0 + len(pubkeyhash)
        pubkeyhash = script[4:]
        if script[2:4] == '14':
            type_tx = 'witness_v0_keyhash'
        elif script[2:4] == '20':
            type_tx = 'witness_v0_scripthash'
        else:
            raise Exception('script = %s', script)

        # bc for mainnet
        # 0x00 for the version = v0
        # pubkeyhash
        # return bech32 address
        return bech32_encode('bc', 0x00,
                             binascii.unhexlify(pubkeyhash)), type_tx

    # case TX_NONSTANDARD: return "nonstandard";
    # case TX_PUBKEY: return "pubkey";
    # case TX_PUBKEYHASH: return "pubkeyhash";
    # case TX_SCRIPTHASH: return "scripthash";
    # case TX_MULTISIG: return "multisig";
    # case TX_NULL_DATA: return "nulldata";
    # case TX_WITNESS_V0_KEYHASH: return "witness_v0_keyhash";
    # case TX_WITNESS_V0_SCRIPTHASH: return "witness_v0_scripthash";
    # case TX_WITNESS_UNKNOWN: return "witness_unknown";

    # decode_tx to use extra fields add by bitcore in new getrawtransaction
    def decode_tx(self, tx):

        result = {"txid": tx['txid'],
                  "sender": [],
                  "receiver": [],
                  "total_value_input": 0.0,
                  "total_value_output": 0.0,
                  "fee": 0.0
                  }

        # get the senders
        for vin in tx['vin']:

            # test for commons transaction first
            # vin['address'] & vin['addr'] are bitcore specific
            if 'address' in vin:
                sender_address = vin['address']
                type_tx = 'standard'
            elif 'addr' in vin:
                sender_address = vin['addr']
                type_tx = 'standard'

            # coinbase transaction
            # only one per block
            # first transaction that's the coinbase mining reward
            elif 'coinbase' in vin:
                result['sender'].append(('mining_reward', 0,
                                         '', 'mining_reward'))
                break

            # SegWit or less classic case
            # need to retrieve complete input transaction
            else:
                sender_tx = self.getrawtransaction(vin['txid'], 1)
                for sender_vout in sender_tx['vout']:
                    if sender_vout['n'] == vin['vout']:
                        script_pub_key = sender_vout['scriptPubKey']
                        script_sig = script_pub_key['hex']
                        # pubkey
                        try:
                            sender_address = script_pub_key['addresses'][0]
                            type_tx = script_pub_key['type']
                            print('sender type_tx: %s' % type_tx)
                        # SegWit
                        except KeyError:
                            sender_address, type_tx = \
                                self.__script_pub_key_to_bech32(script_sig)
                            if sender_address is None:
                                raise Exception('sender bech32 : %s',
                                                script_sig)

            sender_value = vin['value']
            sender_script = vin['scriptSig']['hex']
            result['sender'].append((sender_address, sender_value,
                                     sender_script, type_tx))

        # get the receivers
        for vout in tx['vout']:
            value = vout['value']
            script_pub_key = vout['scriptPubKey']
            btcscript = script_pub_key['hex']

            try:
                receiver = script_pub_key['addresses'][0]
                type_tx = script_pub_key['type']
            # KeyError appears when vin['address'] doesn't exit
            # means we have SegWit transaction
            except KeyError:
                if 'type' in script_pub_key:
                    type_tx = script_pub_key['type']
                    if type_tx == 'nulldata':
                        receiver = 'lost_bitcoin'
                    else:
                        #print('receiver type_tx: %s' % type_tx)
                        receiver, type_tx = \
                            self.__script_pub_key_to_bech32(btcscript)
                        if receiver is None:
                            raise Exception('receiver bech32 : %s', script_sig)

            result['receiver'].append((receiver, value, btcscript, type_tx))

        total_in = sum(v for _, v, _, _ in result['sender'])
        total_out = sum(v for _, v, _, _ in result['receiver'])

        for s, v, _, _ in result['sender']:
            if s == '':
                print('TXID = %s' % tx['txid'])

        for r, v, _, _ in result['receiver']:
            if r == '':
                print('TXID = %s' % tx['txid'])

        result["total_value_input"] = total_in
        result["total_value_output"] = total_out
        result["fee"] = total_in - total_out if total_in - total_out > 0 else 0
        return result

# example address p2wsh
# txid = a388d6f88373aacf2a5c170eeff4adf51f2c6744da26375d5890f42d653a2e6c
# txid2 = 37138d3df8e1d41bf6474ecdc21d53f78ab9907c500172de31bda4048556bd83
# pubkeyhash = 701a8d401c84fb13e6baf169d59684e17abd9fa216c8cc5b9fc63d622ff8c58
# address = bc1qwqdg6squsna38e46795at95yu9atm8azzmyvckulcc7kytlcckxswvvzej

# example address p2wpkh
# txid = fa3c4931c3f31eda18df255d754aa8f36a514f6ef7408d963912c47bb5cc5ec7
# txid2 = 761619410d9f2a7fa69336583a0351dd86caf9ed2cee8765132a93caa44f77de
# pubkeyhash = f2c78dda8d18a90545045942989406bf90966f7f
# address = bc1q7trcmk5drz5s23gyt9pf39qxh7gfvmmlr8kc2n

# can cause crash
# 0fcb06da0fb13e112fe68f3d674dc1366ec2930b4852ad8581b8ef7cc5f25fdf
# a562429d601b5559b9e1d732d7ad7c6071243f9b260af3f480757353841321ed

# first tx SegWit
# txid = f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd
# block_number = 481824

'''
'''--- octopus/platforms/BTC/instruction.py ---
from octopus.core.instruction import Instruction

import struct

class BitcoinInstruction(Instruction):
    """BTC Instruction

    TODO

    """
    def __init__(self, opcode, name,
                 operand_size, pops, pushes, fee,
                 description, operand=None,
                 operand_interpretation=None,
                 offset=0, xref=None):
        """ TODO """
        super().__init__(opcode=opcode, name=name,
                         operand_size=operand_size, pops=pops, pushes=pushes,
                         fee=fee, description=description, operand=operand,
                         operand_interpretation=operand_interpretation,
                         offset=offset, xref=xref)

    # redefinition of this function
    def __str__(self):
        """ String representation of the instruction """
        output = ''
        if self.has_operand:
            if type(self.operand) == int:
                output = self.name + '' + self.operand.hex()
            else:
                if self.operand_size < 5:  # in ['', 'OP_PUSHDATA1', 'OP_PUSHDATA2']:
                    output = '%d' % int.from_bytes(self.operand,
                                                   byteorder='little', signed=True)
                elif self.name == '' or self.has_length_operand:
                    output = self.operand.hex()
                else:
                    output = self.name + ' ' + self.operand.hex()
        else:
            # format to be compliant with result from RPC call
            if (self.opcode >= 0x51 and self.opcode < 0x5A) or self.name == 'OP_0':
                output = self.name[-1]
            elif self.opcode >= 0x5A and self.opcode <= 0x60:
                output = self.name[-2:]
            else:
                output = self.name
        return output

    @property
    def has_length_operand(self):
        return self.name in ['OP_PUSHDATA1', 'OP_PUSHDATA2', 'OP_PUSHDATA4']

    def format_operand_size(self):
        if self.name == 'OP_PUSHDATA1':
            self.operand_size = struct.unpack('<B', self.operand_size)[0]
        elif self.name == 'OP_PUSHDATA2':
            self.operand_size = struct.unpack(b"<H", self.operand_size)[0]
        elif self.name == 'OP_PUSHDATA4':
            self.operand_size = struct.unpack(b"<I", self.operand_size)[0]
        else:
            pass

    def format_length_operand(self, value):
        if self.name == 'OP_PUSHDATA1':
            return value.to_bytes(1, 'little')
        elif self.name == 'OP_PUSHDATA2':
            return value.to_bytes(2, 'little')
        elif self.name == 'OP_PUSHDATA4':
            return value.to_bytes(4, 'little')
        else:
            pass

    # overwrite
    @property
    def bytes(self):
        """ Encoded instruction """
        byte = bytearray()
        byte.append(self.opcode)
        if self.has_length_operand:
            [byte.append(x) for x in self.format_length_operand(len(self.operand))]
        if self.operand:
            [byte.append(x) for x in self.operand]
        return "".join(map(chr, byte))

    # overwrite
    @property
    def size(self):
        """ Size of the encoded instruction """
        if self.has_length_operand:
            return self.operand_size + self.operand_size + 1
        else:
            return self.operand_size + 1

'''
'''--- octopus/platforms/EOS/__init__.py ---

'''
'''--- octopus/platforms/EOS/analyzer.py ---
from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

# Eos smart contract == wasm module
class EosAnalyzer(WasmModuleAnalyzer):
    def __init__(self, module_bytecode, analysis=True):
        WasmModuleAnalyzer.__init__(self,
                                    module_bytecode=module_bytecode,
                                    analysis=analysis)

'''
'''--- octopus/platforms/EOS/cfg.py ---
from octopus.arch.wasm.cfg import WasmCFG

# Eos smart contract == wasm module
class EosCFG(WasmCFG):
    def __init__(self, module_bytecode):
        WasmCFG.__init__(self,
                         module_bytecode=module_bytecode)

    def visualize_instrs_per_funcs(self, show=True, save=True,
                                   out_filename="eos_func_analytic.png",
                                   fontsize=8):
        super().visualize_instrs_per_funcs(show, save, out_filename, fontsize)

'''
'''--- octopus/platforms/EOS/disassembler.py ---
from octopus.arch.wasm.disassembler import WasmDisassembler

# Eos smart contract == wasm module
class EosDisassembler(WasmDisassembler):
    def __init__(self, bytecode=None):
        WasmDisassembler.__init__(self,
                                  bytecode=bytecode)

'''
'''--- octopus/platforms/EOS/emulator.py ---
from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine

# Eos smart contract == wasm module
class EosSSAEmulatorEngine(WasmSSAEmulatorEngine):
    def __init__(self, bytecode=None):
        WasmSSAEmulatorEngine.__init__(self,
                                       bytecode=bytecode)

'''
'''--- octopus/platforms/EOS/explorer.py ---
from octopus.engine.explorer import Explorer
from requests.exceptions import ConnectionError as RequestsConnectionError
import json

EOS_DEFAULT_RPC_PORT = 8888
EOS_WALLET_RPC_PORT = 8889

class EosExplorer(Explorer):
    """
    EOS REST RPC client class

    doc: https://eosio.github.io/eos/group__eosiorpc.html
    cleos source code: https://github.com/EOSIO/eos/blob/master/programs/cleos/main.cpp
    """
    def __init__(self, host='localhost', port=EOS_DEFAULT_RPC_PORT, tls=False, max_retries=3):
        Explorer.__init__(self, host=host, port=port, tls=tls, max_retries=max_retries)

    def call(self, method, params={}, version='v1', api_type='chain'):

        current_url = '{}/{}/{}/{}'.format(self.url, version, api_type, method)

        try:
            r = self.session.post(current_url, headers=self.headers, data=json.dumps(params))
        except RequestsConnectionError:
            raise Exception('RPC connection Error')
        if not 200 <= r.status_code < 300:
            raise Exception('RPC connection failure: ' + str(r.status_code) + ' ' + r.reason + ' ' + r.text)
        try:
            response = r.json()
        except ValueError:
            raise Exception('JSON response parsing error: ' + str(r.text))
        try:
            return response
        except KeyError:
            raise Exception('\"result\" field in JSON response error: ' + str(response))

    ##########################
    #        Chain API       #
    ##########################

    def get_info(self):
        '''Get latest information related to a node

        TESTED
        '''
        return self.call('get_info')

    def get_block(self, block_num_or_id):
        '''Get information related to a block.

        TESTED
        '''
        data = {'block_num_or_id': block_num_or_id}
        return self.call('get_block', data)

    def get_raw_code_and_abi(self, account_name):
        '''Fetch smart contract code.

        TESTED
        '''
        data = {'account_name': account_name}
        return self.call('get_raw_code_and_abi', data)

    def get_account(self, account_name):
        '''Get information related to an account.

        TESTED
        '''
        data = {'account_name': account_name}
        return self.call('get_account', data)

    def get_code(self, account_name):
        '''Fetch smart contract code.

        TESTED
        '''
        data = {'account_name': account_name}
        return self.call('get_code', data)

    def get_table_rows(self, scope, code, table, json=False, lower_bound=None, upper_bound=None, limit=None):
        '''Fetch smart contract data from an account.

        NOT TESTED
        '''
        data = {'scope': scope,
                'code': code,
                'table': table,
                'json': json}
        if lower_bound:
            data['lower_bound'] = lower_bound
        if upper_bound:
            data['upper_bound'] = upper_bound
        if limit:
            data['limit'] = limit
        return self.call('get_table_rows', data)

    def abi_json_to_bin(self, code, action, args):
        '''Serialize json to binary hex. The resulting binary hex is usually used for the data field in push_transaction.

        NOT TESTED
        '''
        data = {'code': code,
                'action': action,
                'args': args}
        print(data)
        return self.call('abi_json_to_bin', data)

    def abi_bin_to_json(self, code, action, binargs):
        '''Serialize back binary hex to json.

        NOT TESTED
        '''
        data = {'code': code,
                'action': action,
                'binargs': binargs}
        return self.call('abi_bin_to_json', data)

    def push_transaction(self, tx_json):
        '''This method expects a transaction in JSON format and will attempt to apply it to the blockchain,

        NOT TESTED
        '''
        return self.call('push_transaction', tx_json)

    def push_transactions(self, list_tx_json):
        '''This method push multiple transactions at once.

        NOT TESTED
        '''
        return self.call('push_transactions', list_tx_json)

    def get_required_keys(self, transaction):
        '''Get required keys to sign a transaction from list of your keys.

        NOT TESTED
        '''
        data = {'transaction': transaction}
        return self.call('get_required_keys', data)

    ##########################
    #       Wallet API       #
    ##########################

    def wallet_create(self, name):
        '''Create a new wallet with the given name

        TESTED
        '''
        return self.call('create', name, api_type='wallet')

    def wallet_open(self, name):
        '''Open an existing wallet of the given name

        TESTED
        '''
        return self.call('open', name, api_type='wallet')

    def wallet_lock(self, name):
        '''Lock a wallet of the given name

        TESTED
        '''
        return self.call('lock', name, api_type='wallet')

    def wallet_lock_all(self):
        '''Lock all wallets

        TESTED
        '''
        return self.call('lock_all', api_type='wallet')

    def wallet_unlock(self, name, password):
        '''Unlock a wallet with the given name and password

        TESTED
        '''
        return self.call('unlock', [name, password], api_type='wallet')

    def wallet_import_key(self, name, priv_key):
        '''Import a private key to the wallet of the given name

        TESTED
        '''
        return self.call('import_key', [name, priv_key], api_type='wallet')

    def wallet_list(self):
        '''List all wallets

        TESTED
        '''
        return self.call('list_wallets', api_type='wallet')

    def wallet_list_keys(self):
        '''List all key pairs across all wallets

        TESTED
        '''
        return self.call('list_keys', api_type='wallet')

    def wallet_get_public_keys(self):
        '''List all public keys across all wallets

        TESTED
        '''
        return self.call('get_public_keys', api_type='wallet')

    def wallet_set_timeout(self, timeout_s):
        '''Set wallet auto lock timeout (in seconds)

        TESTED
        '''
        return self.call('set_timeout', timeout_s, api_type='wallet')

    def wallet_sign_trx(self, tx_json):
        '''Sign transaction given an array of transaction, require public keys, and chain id

        NOT TESTED
        '''
        return self.call('sign_transaction', tx_json)

'''
'''--- octopus/platforms/ETH/__init__.py ---

'''
'''--- octopus/platforms/ETH/cfg.py ---
from octopus.arch.evm.cfg import EvmCFG
from octopus.arch.wasm.cfg import WasmCFG

# Ethereum smart contract == EVM bytecode or WebAssembly
class EthereumCFG(object):
    def __new__(cls, bytecode, arch='evm', evm_analysis='dynamic'):
        if arch == 'evm':
            return EvmCFG(bytecode, analysis=evm_analysis)
        else:  # Wasm
            return WasmCFG(bytecode)

'''
'''--- octopus/platforms/ETH/constants.py ---
# Global Ethereum-specific constant

DEFAULT_GAS_PER_TX = 90000
DEFAULT_GAS_PRICE = 50 * 10**9  # 50 gwei

BLOCK_TAG_EARLIEST = 'earliest'
BLOCK_TAG_LATEST = 'latest'
BLOCK_TAG_PENDING = 'pending'
BLOCK_TAGS = (
    BLOCK_TAG_EARLIEST,
    BLOCK_TAG_LATEST,
    BLOCK_TAG_PENDING,
)

TT256 = 2 ** 256
TT256M1 = 2 ** 256 - 1
TT255 = 2 ** 255

'''
'''--- octopus/platforms/ETH/contract.py ---
from octopus.core.contract import Contract

class ContractAdressEmptyException(Exception):
    """Exception raised when address is None"""
    pass

class EthereumContract(Contract):

    @property
    def _address_defined(self):
        if self.address is None:
            raise ContractAdressEmptyException()
        return True

    def get_online_bytecode(self, explorer):
        if self._address_defined:
            self.bytecode = explorer.eth_getCode(self.address)

    def get_online_abi(self, explorer):
        raise NotImplementedError

    def get_online_source(self, explorer):
        raise NotImplementedError

    def get_online_info(self, explorer):
        # get the balance
        if self._address_defined:
            # self.name
            self.balance = explorer.eth_getBalance(self.address)
            self.bytecode = explorer.eth_getCode(self.address)
            # self.abi
            # self.source_code

'''
'''--- octopus/platforms/ETH/disassembler.py ---
from octopus.arch.evm.disassembler import EvmDisassembler
from octopus.arch.wasm.disassembler import WasmDisassembler

# Etherem smart contract == EVM bytecode
class EthereumDisassembler(object):
    def __new__(cls, bytecode=None, arch='evm'):
        if arch == 'evm':
            return EvmDisassembler(bytecode)
        else:  # Wasm
            return WasmDisassembler(bytecode)

'''
'''--- octopus/platforms/ETH/emulator.py ---
from octopus.arch.evm.emulator import EvmEmulatorEngine
from octopus.arch.wasm.emulator import WasmEmulatorEngine
from octopus.arch.evm.emulator import EvmSSAEngine
from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine

class EthereumEmulatorEngine(object):
    def __new__(cls, bytecode, arch='evm'):
        if arch == 'evm':
            return EvmEmulatorEngine(bytecode)
        else:  # Wasm
            return WasmEmulatorEngine(bytecode)

class EthereumSSAEngine(object):
    def __new__(cls, bytecode, arch='evm', max_depth=20):
        if arch == 'evm':
            return EvmSSAEngine(bytecode, max_depth=max_depth)
        else:  # Wasm
            return WasmSSAEmulatorEngine(bytecode)

'''
'''--- octopus/platforms/ETH/explorer.py ---
import warnings

#from ethereum import utils
#from ethereum.abi import encode_abi, decode_abi

from octopus.platforms.ETH.constants import DEFAULT_GAS_PER_TX, DEFAULT_GAS_PRICE, BLOCK_TAGS, BLOCK_TAG_LATEST
from octopus.platforms.ETH.util import hex_to_dec, clean_hex, validate_block

from octopus.engine.explorer import Explorer
"""
This code is adapted from: ethjsonrpc
https://github.com/ConsenSys/ethjsonrpc
"""

GETH_DEFAULT_RPC_PORT = 8545
ETH_DEFAULT_RPC_PORT = 8545
PARITY_DEFAULT_RPC_PORT = 8545
PYETHAPP_DEFAULT_RPC_PORT = 4000

INFURA_MAINNET = "mainnet.infura.io/"
INFURA_ROPSTEN = "ropsten.infura.io/"
INFURA_INFURANET = "infuranet.infura.io/"
INFURA_KOVAN = "kovan.infura.io/"
INFURA_RINKEBY = "rinkeby.infura.io/"
INFURA_RPC_PORT = 8545

INFURA_APIKEY = "bHuaQhX91nkQBac8Wtgj"

class EthereumExplorerRPC(Explorer):
    """
    Ethereum JSON-RPC client class
    """
    def __init__(self, host='localhost', port=GETH_DEFAULT_RPC_PORT, tls=False, max_retries=3):
        Explorer.__init__(self, host=host, port=port, tls=tls, max_retries=max_retries)

    def call(self, method, params=None, jsonrpc='2.0', _id=1):
        return super().call(method, params, jsonrpc, _id)

    '''
    def _encode_function(self, signature, param_values):

        prefix = utils.big_endian_to_int(utils.sha3(signature)[:4])

        if signature.find('(') == -1:
            raise RuntimeError('Invalid function signature. Missing "(" and/or ")"...')

        if signature.find(')') - signature.find('(') == 1:
            return utils.encode_int(prefix)

        types = signature[signature.find('(') + 1: signature.find(')')].split(',')
        encoded_params = encode_abi(types, param_values)
        return utils.zpad(utils.encode_int(prefix), 4) + encoded_params
    '''

    #######################
    # HIGHT-LEVEL METHODS #
    #######################

    def get_transaction(self, transaction_id, verbosity=None):
        """ Return transaction informations

        .. seealso::
            :method:`eth_getTransactionByHash`
        """
        return self.eth_getTransactionByHash(transaction_id)

    def get_block_by_number(self, block_number):
        """ Return block information using given block number

        .. seealso::
            :method:`eth_getBlockByNumber`
        """
        return self.eth_getBlockByNumber(block_number)

    def get_block_by_hash(self, block_hash):
        """ Return block information using given block hash

        .. seealso::
            :method:`eth_getBlockByHash`
        """
        return self.eth_getBlockByHash(block_hash)

    def decode_tx(self, transaction_id):
        """ Return dict with important information about
            the given transaction
        """
        tx_data = self.eth_getTransactionByHash(transaction_id)
        return tx_data
        #TODO

    ##########################
    # HIGHT-LEVEL METHODS #2 #
    ##########################

    def transfer(self, from_address, to_address, amount):
        """Send wei from one address to another

        TODO

        .. note:: https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendtransaction
        .. seealso:: :method:`eth_sendTransaction`
        """
        return self.eth_sendTransaction(from_address=from_address, to_address=to_address, value=amount)

    def create_contract(self, from_, code, gas, sig=None, args=None):
        """
        Create a contract on the blockchain from compiled EVM code. Returns the
        transaction hash.
        """
        '''
        from_ = from_ or self.eth_coinbase()
        if sig is not None and args is not None:
            types = sig[sig.find('(') + 1: sig.find(')')].split(',')
            encoded_params = encode_abi(types, args)
            code += encoded_params.encode('hex')
        return self.eth_sendTransaction(from_address=from_, gas=gas, data=code)
        '''
        return NotImplementedError()

    def get_contract_address(self, tx):
        """
        Get the address for a contract from the transaction that created it
        """
        receipt = self.eth_getTransactionReceipt(tx)
        return receipt['contractAddress']

    def call_without_transaction(self, address, sig, args, result_types):
        """
        Call a contract function on the RPC server, without sending a
        transaction (useful for reading data)
        """
        '''
        data = self._encode_function(sig, args)
        data_hex = data.encode('hex')
        response = self.eth_call(to_address=address, data=data_hex)
        return decode_abi(result_types, response[2:].decode('hex'))
        '''
        return NotImplementedError()

    def call_with_transaction(self, from_, address, sig, args, gas=None, gas_price=None, value=None):
        """
        Call a contract function by sending a transaction (useful for storing
        data)
        """
        '''
        gas = gas or DEFAULT_GAS_PER_TX
        gas_price = gas_price or DEFAULT_GAS_PRICE
        data = self._encode_function(sig, args)
        data_hex = data.encode('hex')
        return self.eth_sendTransaction(from_address=from_, to_address=address, data=data_hex, gas=gas,
                                        gas_price=gas_price, value=value)
        '''
        return NotImplementedError()

    ####################
    # JSON-RPC METHODS #
    ####################

    # ressources :
    # * https://github.com/ethereum/wiki/wiki/JSON-RPC
    # *
    # *

    def web3_clientVersion(self):
        """ Returns the current client version.

        :return: The current client version
        :rtype: str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.web3_clientVersion()
        'Geth/v1.8.0-unstable-952482d5/linux-amd64/go1.9.2'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#web3_clientversion
        .. todo::
            TESTED
        """

        return self.call('web3_clientVersion')

    def web3_sha3(self, data):
        """ Returns Keccak-256 (not the standardized SHA3-256) of the given data.

        :param data: the data to convert into a SHA3 hash
        :type data: hex string
        :return: The SHA3 result of the given string.
        :rtype: hex string

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.web3_sha3('0x' + b'hello world'.hex())
        '0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#web3_sha3
        .. todo::
            TESTED
        """
        #data = str(data).encode('hex')
        return self.call('web3_sha3', [data])

    def net_version(self):
        """ Returns the current network id.

        :return: The current network id.
            "1": Ethereum Mainnet
            "2": Morden Testnet (deprecated)
            "3": Ropsten Testnet
            "4": Rinkeby Testnet
            "42": Kovan Testnet
        :rtype: str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.net_version()
        '1'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#net_version
        .. todo::
            TESTED
        """
        return self.call('net_version')

    def net_listening(self):
        """ Returns true if client is actively listening for network connections.

        :return: The current network id.
            true when listening otherwise false.
        :rtype: Boolean

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.net_listening()
        True

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#net_listening
        .. todo::
            TESTED
        """
        return self.call('net_listening')

    def net_peerCount(self):
        """ Returns number of peers currently connected to the client.

        :return: integer of the number of connected peers.
        :rtype: int

        :Example:
        >>> explorer = EthereumExplorerRPC()
        >>> explorer.net_peerCount()
        25

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#net_peercount
        .. todo::
            TESTED
        """
        return hex_to_dec(self.call('net_peerCount'))

    def eth_protocolVersion(self):
        """ Returns the current ethereum protocol version.

        :return: The current ethereum protocol version
        :rtype: hex str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_protocolVersion()
        '0x3f'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_protocolversion
        .. todo::
            TESTED
        """
        return self.call('eth_protocolVersion')

    def eth_syncing(self):
        """ Returns an object with data about the sync status or false.

        :return: An object with sync status data or FALSE, when not syncing
            startingBlock: QUANTITY - The block at which the import started (will only be reset, after the sync reached his head)
            currentBlock: QUANTITY - The current block, same as eth_blockNumber
            highestBlock: QUANTITY - The estimated highest block
        :rtype: Boolean or object

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_syncing()
        False

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_syncing
        .. todo::
            TESTED
        """
        return self.call('eth_syncing')

    def eth_coinbase(self):
        """ Returns the client coinbase address.

        :return: 20 bytes - the current coinbase address.
        :rtype: hex str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_coinbase()
        '0x407d73d8a49eeb85d32cf465507dd71d507100c1'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_coinbase
        .. todo::
            TESTED
        """
        return self.call('eth_coinbase')

    def eth_mining(self):
        """ Returns true if client is actively mining new blocks.

        :return:  returns true of the client is mining, otherwise false
        :rtype: Boolean

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_mining()
        False

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_mining
        .. todo::
            TESTED
        """
        return self.call('eth_mining')

    def eth_hashrate(self):
        """ Returns the number of hashes per second that the node is mining with.

        :return: number of hashes per second.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_hashrate()
        0

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_hashrate
        .. todo::
            TESTED
        """

        return hex_to_dec(self.call('eth_hashrate'))

    def eth_gasPrice(self):
        """ Returns the current price per gas in wei.

        :return: integer of the current gas price in wei.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_gasPrice()
        4000000000

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gasprice
        .. todo::
            TESTED
        """
        return hex_to_dec(self.call('eth_gasPrice'))

    def eth_accounts(self):
        """ Returns a list of addresses owned by client.

        :return: 20 Bytes - addresses owned by the client.
        :rtype: list

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_accounts()
        ["0x407d73d8a49eeb85d32cf465507dd71d507100c1"]

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_accounts
        .. todo::
            TESTED
        """
        return self.call('eth_accounts')

    def eth_blockNumber(self):
        """ Returns the number of most recent block.

        :return: integer of the current block number the client is on.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_blockNumber()
        5100196

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_blocknumber
        .. todo::
            TESTED
        """
        return hex_to_dec(self.call('eth_blockNumber'))

    def eth_getBalance(self, address=None, block=BLOCK_TAG_LATEST):
        """ Returns the balance of the account of given address.

        :param address: 20 Bytes - address to check for balance.
        :type address: str
        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return:  integer of the current balance in wei.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getBalance("0x956b6B7454884b734B29A8115F045a95179ea00C")
        17410594678300000000

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getbalance
        .. todo::
            TESTED

        """
        address = address or self.eth_coinbase()
        block = validate_block(block)
        v = hex_to_dec(self.call('eth_getBalance', [address, block]))
        return (v if v else 0)

    def eth_getStorageAt(self, address=None, position=0, block=BLOCK_TAG_LATEST):
        """ Returns the value from a storage position at a given address.

        :param address: 20 Bytes - address to check for balance.
        :type address: str
        :param address: (optionnal) integer of the position in the storage. default is 0
        :type address: int
        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return:  the value at this storage position.
        :rtype: str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getStorageAt("0x295a70b2de5e3953354a6a8344e616ed314d7251", 0, "latest")
        '0x0000000000000000000000000000000000000000000000000000000000000000'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return self.call('eth_getStorageAt', [address, hex(position), block])

    def eth_getTransactionCount(self, address, block=BLOCK_TAG_LATEST):
        """ Returns the number of transactions sent from an address.

        :param address: 20 Bytes - address.
        :type address: str
        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return: integer of the number of transactions send from this address.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getTransactionCount("0x956b6B7454884b734B29A8115F045a95179ea00C")
        12891

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactioncount
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return hex_to_dec(self.call('eth_getTransactionCount', [address, block]))

    def eth_getBlockTransactionCountByHash(self, block_hash):
        """ Returns the number of transactions in a block from a block matching the given block hash.

        :param block_hash:  32 Bytes - hash of a block
        :type block_hash: str
        :return: integer of the number of transactions in this block.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getBlockTransactionCountByHash('0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b')
        69

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getblocktransactioncountbyhash
        .. todo::
            TESTED
        """
        return hex_to_dec(self.call('eth_getBlockTransactionCountByHash', [block_hash]))

    def eth_getBlockTransactionCountByNumber(self, block=BLOCK_TAG_LATEST):
        """ Returns the number of transactions in a block matching the given block number.

        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return:  integer of the number of transactions in this block.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getBlockTransactionCountByNumber(5100196)
        69

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getblocktransactioncountbynumber
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return hex_to_dec(self.call('eth_getBlockTransactionCountByNumber', [block]))

    def eth_getUncleCountByBlockHash(self, block_hash):
        """ Returns the number of transactions in a block matching the given block number.

        :param block_hash: 32 Bytes - hash of a block
        :type block_hash: str
        :return: integer of the number of uncles in this block.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getUncleCountByBlockHash('0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b')
        0

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getunclecountbyblockhash
        .. todo::
            TESTED
        """
        return hex_to_dec(self.call('eth_getUncleCountByBlockHash', [block_hash]))

    def eth_getUncleCountByBlockNumber(self, block=BLOCK_TAG_LATEST):
        """ Returns the number of uncles in a block from a block matching the given block number.

        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return: integer of the number of uncles in this block.
        :rtype: int

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getUncleCountByBlockNumber(5100196)
        0

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getunclecountbyblocknumber
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return hex_to_dec(self.call('eth_getUncleCountByBlockNumber', [block]))

    def eth_getCode(self, address, default_block=BLOCK_TAG_LATEST):
        """ Returns code at a given address.

        :param address: 20 Bytes - address.
        :type address: str
        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :return: the code from the given address.
        :rtype: hex str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getCode("0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413")
        '0x6060604052361561020e5760e060020a6000350463013cf08b[...]62f93160ef3e563'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getcode
        .. todo::
            TESTED
        """
        default_block = validate_block(default_block)
        return self.call('eth_getCode', [address, default_block])

    def eth_sign(self, address, data):
        """ The sign method calculates an Ethereum specific signature with: sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))).

        By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.
        This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.

        :param address: 20 Bytes - address.
        :type address: str
        :param data: N Bytes - message to sign
        :type data: hex str
        :return: Signature
        :rtype: hex str

        .. note::
            the address to sign with must be unlocked.
        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
        .. todo::
            NOT TESTED
        """
        return self.call('eth_sign', [address, data])

    def eth_sendTransaction(self, to_address=None, from_address=None, gas=None, gas_price=None, value=None, data=None,
                            nonce=None):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendtransaction

        NEEDS TESTING
        """
        params = {}
        params['from'] = from_address or self.eth_coinbase()
        if to_address is not None:
            params['to'] = to_address
        if gas is not None:
            params['gas'] = hex(gas)
        if gas_price is not None:
            params['gasPrice'] = clean_hex(gas_price)
        if value is not None:
            params['value'] = clean_hex(value)
        if data is not None:
            params['data'] = data
        if nonce is not None:
            params['nonce'] = hex(nonce)
        return self.call('eth_sendTransaction', [params])

    def eth_sendRawTransaction(self, data):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendrawtransaction

        NEEDS TESTING
        """
        return self.call('eth_sendRawTransaction', [data])

    def eth_call(self, to_address, from_address=None, gas=None, gas_price=None, value=None, data=None,
                 default_block=BLOCK_TAG_LATEST):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call

        NEEDS TESTING
        """
        default_block = validate_block(default_block)
        obj = {}
        obj['to'] = to_address
        if from_address is not None:
            obj['from'] = from_address
        if gas is not None:
            obj['gas'] = hex(gas)
        if gas_price is not None:
            obj['gasPrice'] = clean_hex(gas_price)
        if value is not None:
            obj['value'] = value
        if data is not None:
            obj['data'] = data
        return self.call('eth_call', [obj, default_block])

    def eth_estimateGas(self, to_address=None, from_address=None, gas=None, gas_price=None, value=None, data=None,
                        default_block=BLOCK_TAG_LATEST):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_estimategas

        NEEDS TESTING
        """
        if isinstance(default_block, basestring):
            if default_block not in BLOCK_TAGS:
                raise ValueError
        obj = {}
        if to_address is not None:
            obj['to'] = to_address
        if from_address is not None:
            obj['from'] = from_address
        if gas is not None:
            obj['gas'] = hex(gas)
        if gas_price is not None:
            obj['gasPrice'] = clean_hex(gas_price)
        if value is not None:
            obj['value'] = value
        if data is not None:
            obj['data'] = data
        return hex_to_dec(self.call('eth_estimateGas', [obj, default_block]))

    def eth_getBlockByHash(self, block_hash, tx_objects=True):
        """ Returns information about a block by hash.

        :param block_hash: 32 Bytes - Hash of a block.
        :type block_hash: str
        :param tx_objects: (optionnal) If true it returns the full transaction objects, if false only the hashes of the transactions.
        :type tx_objects: Boolean
        :return: A block object, or null when no block was found
        :rtype: dict

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getBlockByHash('0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b')
        {'difficulty': '0xaa41aea7beb9e',
         'extraData': '0x6e616e6f706f6f6c2e6f7267',
         'gasLimit': '0x7a121d',
         'gasUsed': '0x614398',
         'hash': '0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b',
         'logsBloom': '0x000001052440040410040000008006000020000002a11000308045410029410802804801080040c00880000002010c0201804010100900b0000001000240000010800040080044910000010c0000204a041140220008000040000040808800404020802226400018144000400484880012000408000401400000211000c000e2040000209000040080c00000c000890080001090008000001000000102000100002400082240104010400000420080041004050a1080c0042000000000080ac000000802020400001009088021040230000000249208020621000022001820180500200000820002600004888840810420200080100400080000ac0004100000',
         'miner': '0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5',
         'mixHash': '0xa79e0692e7056ea2af26a78a1ed42ac7f3049eb322041c073e5d5a08f6c7e053',
         'nonce': '0x6677371ca8459875',
         'number': '0x4dd2a4',
         [...]
         'totalDifficulty': '0x8b344e12294352eee8',
         'transactions': [{
            [...]
         'value': '0x0'}],
        'transactionsRoot': '0x184cd24c9f45c66ff3846c48fb63e24094aa5909cabfd38211c1d8209128cbc0',
        'uncles': []}

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getblockbyhash
        .. todo::
            TESTED
        """
        return self.call('eth_getBlockByHash', [block_hash, tx_objects])

    def eth_getBlockByNumber(self, block=BLOCK_TAG_LATEST, tx_objects=True):
        """ Returns information about a block by hash.

        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :param tx_objects: (optionnal) If true it returns the full transaction objects, if false only the hashes of the transactions.
        :type tx_objects: Boolean
        :return: A block object, or null when no block was found
        :rtype: dict

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getBlockByNumber(5100196)
        {'difficulty': '0xaa41aea7beb9e',
         'extraData': '0x6e616e6f706f6f6c2e6f7267',
         'gasLimit': '0x7a121d',
         'gasUsed': '0x614398',
         'hash': '0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b',
         'logsBloom': '0x000001052440040410040000008006000020000002a11000308045410029410802804801080040c00880000002010c0201804010100900b0000001000240000010800040080044910000010c0000204a041140220008000040000040808800404020802226400018144000400484880012000408000401400000211000c000e2040000209000040080c00000c000890080001090008000001000000102000100002400082240104010400000420080041004050a1080c0042000000000080ac000000802020400001009088021040230000000249208020621000022001820180500200000820002600004888840810420200080100400080000ac0004100000',
         'miner': '0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5',
         'mixHash': '0xa79e0692e7056ea2af26a78a1ed42ac7f3049eb322041c073e5d5a08f6c7e053',
         'nonce': '0x6677371ca8459875',
         'number': '0x4dd2a4',
         [...]
         'totalDifficulty': '0x8b344e12294352eee8',
         'transactions': [{
            [...]
         'value': '0x0'}],
        'transactionsRoot': '0x184cd24c9f45c66ff3846c48fb63e24094aa5909cabfd38211c1d8209128cbc0',
        'uncles': []}

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getblockbynumber
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return self.call('eth_getBlockByNumber', [block, tx_objects])

    def eth_getTransactionByHash(self, tx_hash):
        """ Returns the information about a transaction requested by transaction hash.

        :param tx_hash:  32 Bytes - hash of a transaction
        :type tx_hash: str
        :return: A transaction object, or null when no transaction was found
        :rtype: dict

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getTransactionByHash('0x345303843c2f3041d12f0c5e6075fd294c2e2ca8cd9b4a9addca3f8caf4380ff')
        {'blockHash': '0xaedd5193cb2b2d9de4c371404277468c7e30eb96f8f9990bd964ca535d88ebc4',
         'blockNumber': '0x4dd3b0',
         'from': '0xc5ff88c3e2902c56c0278fa0e7062d4b5c7e9358',
         'gas': '0x5208',
         'gasPrice': '0xbebc200',
         'hash': '0x345303843c2f3041d12f0c5e6075fd294c2e2ca8cd9b4a9addca3f8caf4380ff',
         'input': '0x',
         'nonce': '0x1',
         'r': '0x5b43f56b69bc78571de39b1b1fc33905a4af588a2ce59f31c54bc54391a255b8',
         's': '0x359e7889447314fb8d9a7e526852471c7bccee006f47222499f9353074107910',
         'to': '0xf954bbabe7bf9a2a4c98dceb293bf437e3863a4e',
         'transactionIndex': '0x66',
         'v': '0x25',
         'value': '0x3202c66793000'}

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionbyhash
        .. todo::
            TESTED
        """
        return self.call('eth_getTransactionByHash', [tx_hash])

    def eth_getTransactionByBlockHashAndIndex(self, block_hash, index=0):
        """ Returns information about a transaction by block hash and transaction index position.

        :param tx_hash:  32 Bytes - hash of a transaction
        :type tx_hash: str
        :param index: (optionnal) integer of the transaction index position.
        :type index: int
        :return: A transaction object, or null when no transaction was found
        :rtype: dict

        .. seealso::
            :method:`eth_getTransactionByHash`
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionbyblockhashandindex
        .. todo::
            NOT TESTED
        """
        return self.call('eth_getTransactionByBlockHashAndIndex', [block_hash, hex(index)])

    def eth_getTransactionByBlockNumberAndIndex(self, block=BLOCK_TAG_LATEST, index=0):
        """ Returns information about a transaction by block number and transaction index position.

        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :param index: (optionnal) integer of the transaction index position.
        :type index: int
        :return: A transaction object, or null when no transaction was found
        :rtype: dict

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getTransactionByBlockNumberAndIndex(5100196, 1)
        {'blockHash': '0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b',
         'blockNumber': '0x4dd2a4',
         'from': '0xb01cb49fe0d6d6e47edf3a072d15dfe73155331c',
         'gas': '0x5208',
         'gasPrice': '0xe33e22200',
         'hash': '0xf02ffa405bae96e62a9e36fbd781362ca378ec62353d5e2bd0585868d3deaf61',
         'input': '0x',
         'nonce': '0x1908f',
         'r': '0xcad900a5060ba9bb646a7f6965f98e945d71a19b3e30ff53d03b9797c6153d07',
         's': '0x53b11a48758fc383df878a9b5468c83b033f5036b124b16dbb0a5167aee7fc4f',
         'to': '0x26cd018553871f2e887986bc24c68a0ce622bb8f',
         'transactionIndex': '0x1',
         'v': '0x25',
         'value': '0x1bc16d674ec80000'}

        .. seealso::
            :method:`eth_getTransactionByHash`
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionbyblocknumberandindex
        .. todo::
            TESTED
        """
        block = validate_block(block)
        return self.call('eth_getTransactionByBlockNumberAndIndex', [block, hex(index)])

    def eth_getTransactionReceipt(self, tx_hash):
        """ Returns the receipt of a transaction by transaction hash.

        :param tx_hash: 32 Bytes - hash of a transaction
        :type tx_hash: str
        :return: A transaction receipt object, or null when no receipt was found
        :rtype: dict

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_getTransactionReceipt('0xf02ffa405bae96e62a9e36fbd781362ca378ec62353d5e2bd0585868d3deaf61')
        {'blockHash': '0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b',
         'blockNumber': '0x4dd2a4',
         'contractAddress': None,
         'cumulativeGasUsed': '0xe2d7',
         'from': '0xb01cb49fe0d6d6e47edf3a072d15dfe73155331c',
         'gasUsed': '0x5208',
         'logs': [],
         'logsBloom': '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
         'status': '0x1',
         'to': '0x26cd018553871f2e887986bc24c68a0ce622bb8f',
         'transactionHash': '0xf02ffa405bae96e62a9e36fbd781362ca378ec62353d5e2bd0585868d3deaf61',
         'transactionIndex': '0x1'}

        .. note::
            That the receipt is not available for pending transactions.
        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt
        .. todo::
            TESTED

        """
        return self.call('eth_getTransactionReceipt', [tx_hash])

    def eth_getUncleByBlockHashAndIndex(self, block_hash, index=0):
        """ Returns information about a uncle of a block by hash and uncle index position.

        :param tx_hash:  32 Bytes - hash of a transaction
        :type tx_hash: str
        :param index: (optionnal)  the uncle's index position.
        :type index: int
        :return: A block object, or null when no block was found
        :rtype: dict

        .. note::
            An uncle doesn't contain individual transactions.
        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getunclebyblockhashandindex
        .. todo::
            NOT TESTED
        """
        return self.call('eth_getUncleByBlockHashAndIndex', [block_hash, hex(index)])

    def eth_getUncleByBlockNumberAndIndex(self, block=BLOCK_TAG_LATEST, index=0):
        """ Returns information about a uncle of a block by number and uncle index position.

        :param block: (optionnal) integer block number, or the string "latest", "earliest" or "pending"
        :type block: int or str
        :param index: (optionnal) the uncle's index position.
        :type index: int
        :return: A block object, or null when no block was found
        :rtype: dict

        .. note::
            An uncle doesn't contain individual transactions.
        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getunclebyblocknumberandindex
        .. todo::
            NOT TESTED
        """
        block = validate_block(block)
        return self.call('eth_getUncleByBlockNumberAndIndex', [block, hex(index)])

    def eth_getCompilers(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getcompilers

        NOT WORKING
        """
        return self.call('eth_getCompilers')

    def eth_compileSolidity(self, code):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_compilesolidity

        NOT WORKING
        """
        return self.call('eth_compileSolidity', [code])

    def eth_compileLLL(self, code):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_compilelll

        N/A
        """
        return self.call('eth_compileLLL', [code])

    def eth_compileSerpent(self, code):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_compileserpent

        N/A
        """
        return self.call('eth_compileSerpent', [code])

    def eth_newFilter(self, from_block=BLOCK_TAG_LATEST, to_block=BLOCK_TAG_LATEST, address=None, topics=None):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newfilter

        NEEDS TESTING
        """
        _filter = {
            'fromBlock': from_block,
            'toBlock': to_block,
            'address': address,
            'topics': topics,
        }
        return self.call('eth_newFilter', [_filter])

    def eth_newBlockFilter(self):
        """ Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call eth_getFilterChanges.

        :return: A filter id.
        :rtype: hex str

        :Example:

        >>> explorer = EthereumExplorerRPC()
        >>> explorer.eth_newBlockFilter()
        '0x1d21d3c44b9a1501d4358a44bdb6da1d'

        .. seealso::
            https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newblockfilter
        .. todo::
            TESTED
        """
        return self.call('eth_newBlockFilter')

    def eth_newPendingTransactionFilter(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newpendingtransactionfilter

        TESTED
        """
        return hex_to_dec(self.call('eth_newPendingTransactionFilter'))

    def eth_uninstallFilter(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_uninstallfilter

        NEEDS TESTING
        """
        return self.call('eth_uninstallFilter', [filter_id])

    def eth_getFilterChanges(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterchanges

        NEEDS TESTING
        """
        return self.call('eth_getFilterChanges', [filter_id])

    def eth_getFilterLogs(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getfilterlogs

        NEEDS TESTING
        """
        return self.call('eth_getFilterLogs', [filter_id])

    def eth_getLogs(self, filter_object):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs

        NEEDS TESTING
        """
        return self.call('eth_getLogs', [filter_object])

    def eth_getWork(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getwork

        TESTED
        """
        return self.call('eth_getWork')

    def eth_submitWork(self, nonce, header, mix_digest):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_submitwork

        NEEDS TESTING
        """
        return self.call('eth_submitWork', [nonce, header, mix_digest])

    def eth_submitHashrate(self, hash_rate, client_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_submithashrate

        TESTED
        """
        return self.call('eth_submitHashrate', [hex(hash_rate), client_id])

    def db_putString(self, db_name, key, value):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#db_putstring

        TESTED
        """
        warnings.warn('deprecated', DeprecationWarning)
        return self.call('db_putString', [db_name, key, value])

    def db_getString(self, db_name, key):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#db_getstring

        TESTED
        """
        warnings.warn('deprecated', DeprecationWarning)
        return self.call('db_getString', [db_name, key])

    def db_putHex(self, db_name, key, value):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#db_puthex

        TESTED
        """
        if not value.startswith('0x'):
            value = '0x{}'.format(value)
        warnings.warn('deprecated', DeprecationWarning)
        return self.call('db_putHex', [db_name, key, value])

    def db_getHex(self, db_name, key):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#db_gethex

        TESTED
        """
        warnings.warn('deprecated', DeprecationWarning)
        return self.call('db_getHex', [db_name, key])

    def shh_version(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_version

        N/A
        """
        return self.call('shh_version')

    def shh_post(self, topics, payload, priority, ttl, from_=None, to=None):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_post

        NEEDS TESTING
        """
        whisper_object = {
            'from': from_,
            'to': to,
            'topics': topics,
            'payload': payload,
            'priority': hex(priority),
            'ttl': hex(ttl),
        }
        return self.call('shh_post', [whisper_object])

    def shh_newIdentity(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_newidentity

        N/A
        """
        return self.call('shh_newIdentity')

    def shh_hasIdentity(self, address):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_hasidentity

        NEEDS TESTING
        """
        return self.call('shh_hasIdentity', [address])

    def shh_newGroup(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_newgroup

        N/A
        """
        return self.call('shh_newGroup')

    def shh_addToGroup(self):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_addtogroup

        NEEDS TESTING
        """
        return self.call('shh_addToGroup')

    def shh_newFilter(self, to, topics):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_newfilter

        NEEDS TESTING
        """
        _filter = {
            'to': to,
            'topics': topics,
        }
        return self.call('shh_newFilter', [_filter])

    def shh_uninstallFilter(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_uninstallfilter

        NEEDS TESTING
        """
        return self.call('shh_uninstallFilter', [filter_id])

    def shh_getFilterChanges(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_getfilterchanges

        NEEDS TESTING
        """
        return self.call('shh_getFilterChanges', [filter_id])

    def shh_getMessages(self, filter_id):
        """
        https://github.com/ethereum/wiki/wiki/JSON-RPC#shh_getmessages

        NEEDS TESTING
        """
        return self.call('shh_getMessages', [filter_id])

class EthereumInfuraExplorer(EthereumExplorerRPC):
    """
    EthereumExplorer subclass for using Infura
    """

    def __init__(self, key=INFURA_APIKEY, network=INFURA_MAINNET):
        EthereumExplorerRPC.__init__(self, host=network + key,
                                     port=INFURA_RPC_PORT, tls=True)

class EthereumParityExplorer(EthereumExplorerRPC):
    """
    EthereumExplorer subclass for Parity-specific methods
    """

    def __init__(self, host='localhost', port=PARITY_DEFAULT_RPC_PORT, tls=False):
        EthereumExplorerRPC.__init__(self, host=host, port=port, tls=tls)

    def trace_filter(self, from_block=None, to_block=None, from_addresses=None, to_addresses=None):
        """
        https://github.com/ethcore/parity/wiki/JSONRPC-trace-module#trace_filter

        TESTED
        """
        params = {}
        if from_block is not None:
            from_block = validate_block(from_block)
            params['fromBlock'] = from_block
        if to_block is not None:
            to_block = validate_block(to_block)
            params['toBlock'] = to_block
        if from_addresses is not None:
            if not isinstance(from_addresses, list):
                from_addresses = [from_addresses]
            params['fromAddress'] = from_addresses
        if to_addresses is not None:
            if not isinstance(to_addresses, list):
                to_addresses = [to_addresses]
            params['toAddress'] = to_addresses
        return self.call('trace_filter', [params])

    def trace_get(self, tx_hash, positions):
        """
        https://wiki.parity.io/JSONRPC
        https://github.com/ethcore/parity/wiki/JSONRPC-trace-module#trace_get

        NEEDS TESTING
        """
        if not isinstance(positions, list):
            positions = [positions]
        return self.call('trace_get', [tx_hash, positions])

    def trace_transaction(self, tx_hash):
        """
        https://wiki.parity.io/JSONRPC
        https://github.com/ethcore/parity/wiki/JSONRPC-trace-module#trace_transaction

        NEEDS TESTING
        """
        return self.call('trace_transaction', [tx_hash])

    def trace_block(self, block=BLOCK_TAG_LATEST):
        """
        https://wiki.parity.io/JSONRPC
        https://github.com/ethcore/parity/wiki/JSONRPC-trace-module#trace_block

        NEEDS TESTING
        """
        block = validate_block(block)
        return self.call('trace_block', [block])

'''
'''--- octopus/platforms/ETH/save_ssa.py ---
from octopus.api.edge import Edge, EDGE_UNCONDITIONAL, EDGE_CONDITIONAL_TRUE, EDGE_CONDITIONAL_FALSE, EDGE_FALLTHROUGH, EDGE_CALL
from octopus.api.engine import SSAEngine
from octopus.api.optimizer import SSAOptimizer
from octopus.api.ssa import SSA, SSA_TYPE_FUNCTION, SSA_TYPE_CONSTANT

from octopus.platforms.ETH.vmstate import EthereumVMstate
from octopus.platforms.ETH.cfg import EthereumCFG

from octopus.platforms.ETH.disassembler import EthereumDisassembler
from octopus.platforms.ETH.emulator import EthereumEmulatorEngine

import copy
import logging
logging.basicConfig(level=logging.WARN)

class EthereumSSAEngine(EthereumEmulatorEngine):

    def __init__(self, bytecode=None, max_depth=20):
        EthereumEmulatorEngine.__init__(self, bytecode=bytecode, ssa=True, symbolic_exec=False, max_depth=20)
        if not bytecode and not instructions:
            raise Exception("No bytecode/instructions provided")
        if instructions:
            self.instructions = instructions
        else:
            # disassemble bytecode to instructions
            disasm = EthereumDisassembler(bytecode)
            self.instructions = disasm.disassemble()
        self.ssaoptimizer = SSAOptimizer()

        self.reverse_instructions = {k: v for k, v in enumerate(self.instructions)}

        # retrive basicblocks & functions statically
        self.cfg = EthereumCFG(instructions=self.instructions, analysis='static')
        self.functions = self.cfg.functions
        self.basicblocks = self.cfg.basicblocks

        self.functions_start_instr = [f.start_instr for f in self.functions]
        self.current_function = self.functions[0]
        self.basicblock_per_instr = dict()
        self.current_basicblock = None

        # create dict with:
        # * key = instruction offset
        # * value = basicblock reference
        # easy to get the corresponding basicblock per instr now
        for bb in self.basicblocks:
            for intr in bb.instructions:
                self.basicblock_per_instr[intr.offset] = bb

        # connection between basicblocks
        self.edges = list()

        self.states = dict()
        self.states_total = 0
        self.max_depth = max_depth
        self.ssa_counter = 0

        logging.info("=======================================")
        logging.info("#         Ethereum SSA Engine         #")
        logging.info("=======================================")
        logging.info("[+] Functions detected : %s", [f.prefered_name for f in self.functions])

    def emulate(self, state=EthereumVMstate(), depth=0):

        #  create fake stack for test
        state.symbolic_stack = list(range(1000))

        # get current instruction
        instr = self.reverse_instructions[state.pc]

        # create the first basicblock of this branch
        # print('%d : %s' % (instr.offset, instr.name))
        self.current_basicblock = self.basicblock_per_instr[instr.offset]

        # beginning of a function
        if instr in self.functions_start_instr:
            # retrive matching function
            self.current_function = next(filter(lambda f: f.start_instr == instr, self.functions))
            self.ssa_counter = 0
            logging.info("[+] Entering function:" + self.current_function.prefered_name + ' at ' + str(hex(self.current_function.start_offset)))

        # associate function to basicblock
        self.current_basicblock.function_name = self.current_function.prefered_name
        # associate basicblock to function
        self.current_function.basicblocks.append(self.current_basicblock)

        # halt variable use to catch end branch
        halt = False
        while not halt:

            # get current instruction
            instr = self.reverse_instructions[state.pc]

            # handle fall-thrown due to JUMPDEST
            if instr.name == 'JUMPDEST':
                # doesn't match new block that start with JUMPDEST
                if self.current_basicblock.start_offset != instr.offset:
                    self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%instr.offset, EDGE_FALLTHROUGH))

            # get current basicblock
            self.current_basicblock = self.basicblock_per_instr[instr.offset]

            # add this instruction to his functions
            self.current_function.instructions.append(instr)

            # Save instruction and state
            state.instr = instr
            self.states[self.states_total] = state
            state = copy.deepcopy(state)
            self.states_total += 1
            state.pc += 1

            # execute single instruction
            halt = self.emulate_one_instruction(instr, state, depth)
            state.instructions_visited.append(instr.offset)

        logging.info("[X] Returning from basicblock %s" % self.current_basicblock.name)

        # automatic remove doublon edges
        self.edges = list(set(self.edges))

    def emulate_one_instruction(self, instr, state, depth):

        halt = False

        #
        #  0s: Stop and Arithmetic Operations
        #
        if instr.name == 'STOP':
            instr.ssa = SSA(method_name=instr.name)
            halt = True
        elif instr.is_arithmetic:
            self.ssa_arithmetic_instruction(instr, state)
        #
        #  10s: Comparison & Bitwise Logic Operations
        #
        elif instr.is_comparaison_logic:
            self.ssa_comparaison_logic_instruction(instr, state)
        #
        #  20s: SHA3
        #
        elif instr.is_sha3:
            self.ssa_sha3_instruction(instr, state)
        #
        #  30s: Environment Information
        #
        elif instr.is_environmental:
            self.ssa_environmental_instruction(instr, state)
        #
        #  40s: Block Information
        #
        elif instr.uses_block_info:
            self.ssa_block_instruction(instr, state)
        #
        #  50s: Stack, Memory, Storage, and Flow Information
        #
        elif instr.uses_stack_block_storage_info:
            halt = self.ssa_stack_memory_storage_flow_instruction(instr, state, depth)
        #
        #  60s & 70s: Push Operations
        #
        elif instr.name.startswith("PUSH"):
            #value = int.from_bytes(instr.operand, byteorder='big')
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name,
                            args=instr.operand_interpretation,
                            instr_type=SSA_TYPE_CONSTANT)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1
        #
        #  80s: Duplication Operations
        #
        elif instr.name.startswith('DUP'):
            # DUPn (eg. DUP1: a b c -> a b c c, DUP3: a b c -> a b c a)
            position = instr.pops  # == XX from DUPXX
            try:
                # SSA STACK
                instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[state.ssa_stack[- position]])
                state.ssa_stack.append(state.ssa_stack[- position])
                self.ssa_counter += 1
                halt = False
            except:
                logging.info('[-] STACK underflow')
                halt = True
        #
        #  90s: Swap Operations
        #
        elif instr.name.startswith('SWAP'):
            # SWAPn (eg. SWAP1: a b c d -> a b d c, SWAP3: a b c d -> d b c a)
            position = instr.pops - 1  # == XX from SWAPXX
            try:
                temp = state.ssa_stack[-position - 1]
                state.ssa_stack[-position - 1] = state.ssa_stack[-1]
                state.ssa_stack[-1] = temp

                instr.ssa = SSA(method_name=instr.name, args=[temp])

                halt = False
            except:
                logging.warning('[-] STACK underflow')
                halt = True
                #raise ValueError('STACK underflow')
        #
        #  a0s: Logging Operations
        #
        elif instr.name.startswith('LOG'):
            # only stack operations emulated
            arg = [state.ssa_stack.pop() for x in range(instr.pops)]
            instr.ssa = SSA(method_name=instr.name, args=arg)
            #state.ssa_stack.append(instr)
        #
        #  f0s: System Operations
        #
        elif instr.is_system:
            halt = self.ssa_system_instruction(instr, state)
            #ssa.append(instr.name)

        # UNKNOWN INSTRUCTION
        else:
            logging.warning('UNKNOWN = ' + instr.name)

        return halt

    def ssa_arithmetic_instruction(self, instr, state):

        if instr.name in ['ADD', 'SUB', 'MUL', 'DIV', 'MOD', 'SDIV', 'SMOD', 'EXP', 'SIGNEXTEND']:
            # SSA STACK
            s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter,
                            method_name=instr.name, args=[s0, s1])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['ADDMOD', 'MULMOD']:
            # SSA STACK
            s0, s1, s2 = state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter,
                            method_name=instr.name, args=[s0, s1, s2])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_comparaison_logic_instruction(self, instr, state):

        if instr.name in ['LT', 'GT', 'SLT', 'SGT', 'EQ', 'AND', 'OR', 'XOR', 'BYTE']:
            # SSA STACK
            s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0, s1])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['ISZERO', 'NOT']:
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_sha3_instruction(self, instr, state):
        '''Symbolic execution of SHA3 group of opcode'''

        # SSA STACK
        s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
        instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0, s1])
        state.ssa_stack.append(instr)
        self.ssa_counter += 1

    def ssa_environmental_instruction(self, instr, state):

        if instr.name in ['ADDRESS', 'ORIGIN', 'CALLER', 'CALLVALUE', 'CALLDATASIZE', 'CODESIZE', 'RETURNDATASIZE', 'GASPRICE']:
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['BALANCE', 'CALLDATALOAD', 'EXTCODESIZE']:
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['CALLDATACOPY', 'CODECOPY', 'RETURNDATACOPY']:
            op0, op1, op2 = state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name, args=[op0, op1, op2])

        elif instr.name == 'EXTCODECOPY':
            addr = state.ssa_stack.pop()
            start, s2, size = state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[addr, start, s2, size])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_block_instruction(self, instr, state):

        if instr.name == 'BLOCKHASH':
            # SSA STACK
            blocknumber = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[blocknumber])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['COINBASE', 'TIMESTAMP', 'NUMBER', 'DIFFICULTY', 'GASLIMIT']:
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

    def ssa_stack_memory_storage_flow_instruction(self, instr, state, depth):

        halt = False
        op = instr.name

        if op == 'POP':
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name)

        elif op in ['MLOAD', 'SLOAD']:
            # SSA STACK
            s0 = state.ssa_stack.pop()
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=[s0])
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif op in ['MSTORE', 'MSTORE8', 'SSTORE']:
            # SSA STACK
            s0, s1 = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[s0, s1])

        elif op == 'JUMP':
            # SSA STACK
            push_instr = state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[push_instr])

            # get instruction with this value as offset
            if push_instr.ssa.is_constant:
                #jump_addr = int.from_bytes(push_instr.operand, byteorder='big')
                jump_addr = push_instr.operand_interpretation
                # get instruction with this value as offset
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
            else:
                # try to resolve the SSA repr
                jump_addr = self.ssaoptimizer.resolve_instr_ssa(push_instr)
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
                if not jump_addr:
                    logging.warning('JUMP DYNAMIC TODO')
                    logging.warning('[X] push_instr %x: %s ' % (push_instr.offset, push_instr.name))
                    logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                    list_args = [arg.ssa.format() for arg in push_instr.ssa.args]
                    logging.warning('[X] push_instr.ssa %s' % list_args)
                    return True

            # depth of 1 - prevent looping
            #if (depth < self.max_depth):
            if target.name != "JUMPDEST":
                logging.info('[X] Bad JUMP to 0x%x' % jump_addr)
                return True

            if target.offset not in state.instructions_visited:
                logging.info('[X] follow JUMP branch offset 0x%x' % target.offset)
                new_state = copy.deepcopy(state)
                new_state.pc = self.instructions.index(target)

                # follow the JUMP
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_UNCONDITIONAL))
                self.emulate(new_state, depth=depth + 1)

                halt = True

            else:
                #logging.info('[X] Max depth reached, skipping JUMP 0x%x' % jump_addr)
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_UNCONDITIONAL))
                logging.info('[X] Loop detected, skipping JUMP 0x%x' % jump_addr)
                halt = True

            self.current_basicblock = self.basicblock_per_instr[instr.offset]

        elif op == 'JUMPI':
            # SSA STACK
            push_instr, condition = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[push_instr, condition])

            logging.info('[X] follow JUMPI default branch offset 0x%x' % (instr.offset_end + 1))
            new_state = copy.deepcopy(state)
            self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%(instr.offset_end + 1), EDGE_CONDITIONAL_FALSE))
            self.emulate(new_state, depth=depth + 1)
            self.current_basicblock = self.basicblock_per_instr[instr.offset]

            # get instruction with this value as offset
            if push_instr.ssa.is_constant:
                #jump_addr = int.from_bytes(push_instr.operand, byteorder='big')
                jump_addr = push_instr.operand_interpretation
                # get instruction with this value as offset
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
            else:
                # try to resolve the SSA repr
                jump_addr = self.ssaoptimizer.resolve_instr_ssa(push_instr)
                target = next(filter(lambda element: element.offset == jump_addr, self.instructions))
                if not jump_addr:
                    logging.warning('JUMP DYNAMIC TODO')
                    logging.warning('[X] push_instr %x: %s ' % (push_instr.offset, push_instr.name))
                    logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                    list_args = [arg.ssa.format() for arg in push_instr.ssa.args]
                    logging.warning('[X] push_instr.ssa %s' % list_args)
                    return True

            if target.name != "JUMPDEST":
                logging.info('[X] Bad JUMP to 0x%x' % jump_addr)
                return True

            if target.offset not in state.instructions_visited:
                # condition are True
                logging.info('[X] follow JUMPI branch offset 0x%x' % (target.offset))
                new_state = copy.deepcopy(state)
                new_state.pc = self.instructions.index(target)

                # follow the JUMPI
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_CONDITIONAL_TRUE))
                self.emulate(new_state, depth=depth + 1)

            else:
                self.edges.append(Edge(self.current_basicblock.name, 'block_%x'%target.offset, EDGE_CONDITIONAL_TRUE))
                logging.warning('[X] Loop detected, skipping JUMP 0x%x' % jump_addr)
                logging.warning('[X] push_instr.ssa %s' % push_instr.ssa.format())
                halt = True
            halt = True

        elif op in ['PC', 'MSIZE', 'GAS']:
            # SSA STACK
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif op == 'JUMPDEST':
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name)

        return halt

    def ssa_system_instruction(self, instr, state):

        halt = False

        if instr.name == 'CREATE':
            args = [state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()]
            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=args)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ('CALL', 'CALLCODE', 'DELEGATECALL', 'STATICCALL'):

            if instr.name in ('CALL', 'CALLCODE'):
                gas, to, value, meminstart, meminsz, memoutstart, memoutsz = \
                    state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
                args = [gas, to, value, meminstart, meminsz, memoutstart, memoutsz]

            else:
                gas, to, meminstart, meminsz, memoutstart, memoutsz = \
                    state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop(), state.ssa_stack.pop()
                args = [gas, to, meminstart, meminsz, memoutstart, memoutsz]

            instr.ssa = SSA(new_assignement=self.ssa_counter, method_name=instr.name, args=args)
            state.ssa_stack.append(instr)
            self.ssa_counter += 1

        elif instr.name in ['RETURN', 'REVERT']:
            offset, length = state.ssa_stack.pop(), state.ssa_stack.pop()
            instr.ssa = SSA(method_name=instr.name, args=[offset, length])
            halt = True

        elif instr.name in ['INVALID', 'SELFDESTRUCT']:
            # SSA STACK
            instr.ssa = SSA(method_name=instr.name)
            halt = True

        return halt

'''
'''--- octopus/platforms/ETH/util.py ---
from octopus.platforms.ETH.constants import BLOCK_TAGS

def hex_to_dec(x):
    '''
    Convert hex to decimal
    '''
    try:
        return int(x, 16)
    except:
        return None

def clean_hex(d):
    '''
    Convert decimal to hex and remove the "L" suffix that is appended to large
    numbers
    '''
    try:
        return hex(d).rstrip('L')
    except:
        return None

def validate_block(block):
    '''
    Test if the block tag is valid
    '''
    if isinstance(block, str):
        if block not in BLOCK_TAGS:
            raise ValueError('invalid block tag')
    if isinstance(block, int):
        block = hex(block)
    return block

def wei_to_ether(wei):
    '''
    Convert wei to ether
    '''
    return 1.0 * wei / 10**18

def ether_to_wei(ether):
    '''
    Convert ether to wei
    '''
    return ether * 10**18

'''
'''--- octopus/platforms/NEO/__init__.py ---

'''
'''--- octopus/platforms/NEO/avm.py ---
# extract from https://github.com/neo-project/neo-vm

pops = 0
pushes = 0

# fee doc - http://docs.neo.org/en-us/sc/systemfees.html
default = 0.001

_table = {
    # opcode:(mnemonic, immediate_operand_size, pops, pushes, gas, description)
    0x00: ('PUSH0', 0, 0, 1, 0, 'An empty array of bytes is pushed onto the stack.'),
    0x01: ('PUSHBYTES1', 0x01, 0, 0x01, 0, '0x01 byte will be push onto the stack'),
    0x02: ('PUSHBYTES2', 0x02, 0, 0x02, 0, '0x02 bytes will be push onto the stack'),
    0x03: ('PUSHBYTES3', 0x03, 0, 0x03, 0, '0x03 bytes will be push onto the stack'),
    0x04: ('PUSHBYTES4', 0x04, 0, 0x04, 0, '0x04 bytes will be push onto the stack'),
    0x05: ('PUSHBYTES5', 0x05, 0, 0x05, 0, '0x05 bytes will be push onto the stack'),
    0x06: ('PUSHBYTES6', 0x06, 0, 0x06, 0, '0x06 bytes will be push onto the stack'),
    0x07: ('PUSHBYTES7', 0x07, 0, 0x07, 0, '0x07 bytes will be push onto the stack'),
    0x08: ('PUSHBYTES8', 0x08, 0, 0x08, 0, '0x08 bytes will be push onto the stack'),
    0x09: ('PUSHBYTES9', 0x09, 0, 0x09, 0, '0x09 bytes will be push onto the stack'),
    0x0A: ('PUSHBYTES10', 0x0A, 0, 0x0A, 0, '0x0A bytes will be push onto the stack'),
    0x0B: ('PUSHBYTES11', 0x0B, 0, 0x0B, 0, '0x0B bytes will be push onto the stack'),
    0x0C: ('PUSHBYTES12', 0x0C, 0, 0x0C, 0, '0x0C bytes will be push onto the stack'),
    0x0D: ('PUSHBYTES13', 0x0D, 0, 0x0D, 0, '0x0D bytes will be push onto the stack'),
    0x0E: ('PUSHBYTES14', 0x0E, 0, 0x0E, 0, '0x0E bytes will be push onto the stack'),
    0x0F: ('PUSHBYTES15', 0x0F, 0, 0x0F, 0, '0x0F bytes will be push onto the stack'),
    0x10: ('PUSHBYTES16', 0x10, 0, 0x10, 0, '0x10 bytes will be push onto the stack'),
    0x11: ('PUSHBYTES17', 0x11, 0, 0x11, 0, '0x11 bytes will be push onto the stack'),
    0x12: ('PUSHBYTES18', 0x12, 0, 0x12, 0, '0x12 bytes will be push onto the stack'),
    0x13: ('PUSHBYTES19', 0x13, 0, 0x13, 0, '0x13 bytes will be push onto the stack'),
    0x14: ('PUSHBYTES20', 0x14, 0, 0x14, 0, '0x14 bytes will be push onto the stack'),
    0x15: ('PUSHBYTES21', 0x15, 0, 0x15, 0, '0x15 bytes will be push onto the stack'),
    0x16: ('PUSHBYTES22', 0x16, 0, 0x16, 0, '0x16 bytes will be push onto the stack'),
    0x17: ('PUSHBYTES23', 0x17, 0, 0x17, 0, '0x17 bytes will be push onto the stack'),
    0x18: ('PUSHBYTES24', 0x18, 0, 0x18, 0, '0x18 bytes will be push onto the stack'),
    0x19: ('PUSHBYTES25', 0x19, 0, 0x19, 0, '0x19 bytes will be push onto the stack'),
    0x1A: ('PUSHBYTES26', 0x1A, 0, 0x1A, 0, '0x1A bytes will be push onto the stack'),
    0x1B: ('PUSHBYTES27', 0x1B, 0, 0x1B, 0, '0x1B bytes will be push onto the stack'),
    0x1C: ('PUSHBYTES28', 0x1C, 0, 0x1C, 0, '0x1C bytes will be push onto the stack'),
    0x1D: ('PUSHBYTES29', 0x1D, 0, 0x1D, 0, '0x1D bytes will be push onto the stack'),
    0x1E: ('PUSHBYTES30', 0x1E, 0, 0x1E, 0, '0x1E bytes will be push onto the stack'),
    0x1F: ('PUSHBYTES31', 0x1F, 0, 0x1F, 0, '0x1F bytes will be push onto the stack'),
    0x20: ('PUSHBYTES32', 0x20, 0, 0x20, 0, '0x20 bytes will be push onto the stack'),
    0x21: ('PUSHBYTES33', 0x21, 0, 0x21, 0, '0x21 bytes will be push onto the stack'),
    0x22: ('PUSHBYTES34', 0x22, 0, 0x22, 0, '0x22 bytes will be push onto the stack'),
    0x23: ('PUSHBYTES35', 0x23, 0, 0x23, 0, '0x23 bytes will be push onto the stack'),
    0x24: ('PUSHBYTES36', 0x24, 0, 0x24, 0, '0x24 bytes will be push onto the stack'),
    0x25: ('PUSHBYTES37', 0x25, 0, 0x25, 0, '0x25 bytes will be push onto the stack'),
    0x26: ('PUSHBYTES38', 0x26, 0, 0x26, 0, '0x26 bytes will be push onto the stack'),
    0x27: ('PUSHBYTES39', 0x27, 0, 0x27, 0, '0x27 bytes will be push onto the stack'),
    0x28: ('PUSHBYTES40', 0x28, 0, 0x28, 0, '0x28 bytes will be push onto the stack'),
    0x29: ('PUSHBYTES41', 0x29, 0, 0x29, 0, '0x29 bytes will be push onto the stack'),
    0x2A: ('PUSHBYTES42', 0x2A, 0, 0x2A, 0, '0x2A bytes will be push onto the stack'),
    0x2B: ('PUSHBYTES43', 0x2B, 0, 0x2B, 0, '0x2B bytes will be push onto the stack'),
    0x2C: ('PUSHBYTES44', 0x2C, 0, 0x2C, 0, '0x2C bytes will be push onto the stack'),
    0x2D: ('PUSHBYTES45', 0x2D, 0, 0x2D, 0, '0x2D bytes will be push onto the stack'),
    0x2E: ('PUSHBYTES46', 0x2E, 0, 0x2E, 0, '0x2E bytes will be push onto the stack'),
    0x2F: ('PUSHBYTES47', 0x2F, 0, 0x2F, 0, '0x2F bytes will be push onto the stack'),
    0x30: ('PUSHBYTES48', 0x30, 0, 0x30, 0, '0x30 bytes will be push onto the stack'),
    0x31: ('PUSHBYTES49', 0x31, 0, 0x31, 0, '0x31 bytes will be push onto the stack'),
    0x32: ('PUSHBYTES50', 0x32, 0, 0x32, 0, '0x32 bytes will be push onto the stack'),
    0x33: ('PUSHBYTES51', 0x33, 0, 0x33, 0, '0x33 bytes will be push onto the stack'),
    0x34: ('PUSHBYTES52', 0x34, 0, 0x34, 0, '0x34 bytes will be push onto the stack'),
    0x35: ('PUSHBYTES53', 0x35, 0, 0x35, 0, '0x35 bytes will be push onto the stack'),
    0x36: ('PUSHBYTES54', 0x36, 0, 0x36, 0, '0x36 bytes will be push onto the stack'),
    0x37: ('PUSHBYTES55', 0x37, 0, 0x37, 0, '0x37 bytes will be push onto the stack'),
    0x38: ('PUSHBYTES56', 0x38, 0, 0x38, 0, '0x38 bytes will be push onto the stack'),
    0x39: ('PUSHBYTES57', 0x39, 0, 0x39, 0, '0x39 bytes will be push onto the stack'),
    0x3A: ('PUSHBYTES58', 0x3A, 0, 0x3A, 0, '0x3A bytes will be push onto the stack'),
    0x3B: ('PUSHBYTES59', 0x3B, 0, 0x3B, 0, '0x3B bytes will be push onto the stack'),
    0x3C: ('PUSHBYTES60', 0x3C, 0, 0x3C, 0, '0x3C bytes will be push onto the stack'),
    0x3D: ('PUSHBYTES61', 0x3D, 0, 0x3D, 0, '0x3D bytes will be push onto the stack'),
    0x3E: ('PUSHBYTES62', 0x3E, 0, 0x3E, 0, '0x3E bytes will be push onto the stack'),
    0x3F: ('PUSHBYTES63', 0x3F, 0, 0x3F, 0, '0x3F bytes will be push onto the stack'),
    0x40: ('PUSHBYTES64', 0x40, 0, 0x40, 0, '0x40 bytes will be push onto the stack'),
    0x41: ('PUSHBYTES65', 0x41, 0, 0x41, 0, '0x41 bytes will be push onto the stack'),
    0x42: ('PUSHBYTES66', 0x42, 0, 0x42, 0, '0x42 bytes will be push onto the stack'),
    0x43: ('PUSHBYTES67', 0x43, 0, 0x43, 0, '0x43 bytes will be push onto the stack'),
    0x44: ('PUSHBYTES68', 0x44, 0, 0x44, 0, '0x44 bytes will be push onto the stack'),
    0x45: ('PUSHBYTES69', 0x45, 0, 0x45, 0, '0x45 bytes will be push onto the stack'),
    0x46: ('PUSHBYTES70', 0x46, 0, 0x46, 0, '0x46 bytes will be push onto the stack'),
    0x47: ('PUSHBYTES71', 0x47, 0, 0x47, 0, '0x47 bytes will be push onto the stack'),
    0x48: ('PUSHBYTES72', 0x48, 0, 0x48, 0, '0x48 bytes will be push onto the stack'),
    0x49: ('PUSHBYTES73', 0x49, 0, 0x49, 0, '0x49 bytes will be push onto the stack'),
    0x4A: ('PUSHBYTES74', 0x4A, 0, 0x4A, 0, '0x4A bytes will be push onto the stack'),
    0x4B: ('PUSHBYTES75', 0x4B, 0, 0x4B, 0, '0x4B datas will be push onto the stack'),
    0x4C: ('PUSHDATA1', 1, 0, 1, 0, 'The next byte contains the number of bytes to be pushed onto the stack.'),
    0x4D: ('PUSHDATA2', 2, 0, 2, 0, 'The next two bytes contain the number of bytes to be pushed onto the stack.'),
    0x4E: ('PUSHDATA4', 4, 0, 4, 0, 'The next four bytes contain the number of bytes to be pushed onto the stack.'),
    0x4F: ('PUSHM1', 0, 0, 1, 0, 'The number -1 is pushed onto the stack.'),
    0x51: ('PUSH1', 0, 0, 1, 0, 'The number 1 is pushed onto the stack.'),
    0x52: ('PUSH2', 0, 0, 1, 0, 'The number 2 is pushed onto the stack.'),
    0x53: ('PUSH3', 0, 0, 1, 0, 'The number 3 is pushed onto the stack.'),
    0x54: ('PUSH4', 0, 0, 1, 0, 'The number 4 is pushed onto the stack.'),
    0x55: ('PUSH5', 0, 0, 1, 0, 'The number 5 is pushed onto the stack.'),
    0x56: ('PUSH6', 0, 0, 1, 0, 'The number 6 is pushed onto the stack.'),
    0x57: ('PUSH7', 0, 0, 1, 0, 'The number 7 is pushed onto the stack.'),
    0x58: ('PUSH8', 0, 0, 1, 0, 'The number 8 is pushed onto the stack.'),
    0x59: ('PUSH9', 0, 0, 1, 0, 'The number 9 is pushed onto the stack.'),
    0x5A: ('PUSH10', 0, 0, 1, 0, 'The number 10 is pushed onto the stack.'),
    0x5B: ('PUSH11', 0, 0, 1, 0, 'The number 11 is pushed onto the stack.'),
    0x5C: ('PUSH12', 0, 0, 1, 0, 'The number 12 is pushed onto the stack.'),
    0x5D: ('PUSH13', 0, 0, 1, 0, 'The number 13 is pushed onto the stack.'),
    0x5E: ('PUSH14', 0, 0, 1, 0, 'The number 14 is pushed onto the stack.'),
    0x5F: ('PUSH15', 0, 0, 1, 0, 'The number 15 is pushed onto the stack.'),
    0x60: ('PUSH16', 0, 0, 1, 0, 'The number 16 is pushed onto the stack.'),

    # Flow control
    0x61: ('NOP', 0, 0, 0, 0, 'Does nothing.'),
    0x62: ('JMP', 2, 0, 0, default, 'JUMP'),
    0x63: ('JMPIF', 2, 1, 0, default, 'CONDITIONNAL JUMP'),
    0x64: ('JMPIFNOT', 2, 1, 0, default, 'NEGATIVE CONDITIONNAL JUMP'),
    0x65: ('CALL', 2, 0, pushes, default, 'CALL FUNCTION'),
    0x66: ('RET', 0, 0, 0, default, 'RET FUNCTION'),
    0x67: ('APPCALL', 20, pops, pushes, 0.01, 'APPCALL'),
    0x68: ('SYSCALL', 1, pops, pushes, default, 'SYSCALL'),
    0x69: ('TAILCALL', 20, pops, pushes, 0.01, 'TAILCALL'),

    # Stack
    0x6A: ('DUPFROMALTSTACK', 0, 0, 1, default, ''),
    0x6B: ('TOALTSTACK', 0, 1, 1, default, 'Puts the input onto the top of the alt stack. Removes it from the main stack.'),
    0x6C: ('FROMALTSTACK', 0, 1, 1, default, 'Puts the input onto the top of the main stack. Removes it from the alt stack.'),
    0x6D: ('XDROP', 0, pops, pushes, default, ''),
    0x72: ('XSWAP', 0, 1, 0, default, ''),
    0x73: ('XTUCK', 0, 1, 1, default, ''),
    0x74: ('DEPTH', 0, 0, 1, default, 'Puts the number of stack items onto the stack.'),
    0x75: ('DROP', 0, 1, 0, default, 'Removes the top stack item.'),
    0x76: ('DUP', 0, 0, 1, default, 'Duplicates the top stack item.'),
    0x77: ('NIP', 0, 2, 1, default, 'Removes the second-to-top stack item.'),
    0x78: ('OVER', 0, 1, 2, default, 'Copies the second-to-top stack item to the top.'),
    0x79: ('PICK', 0, 1, 1, default, 'The item n back in the stack is copied to the top.'),
    0x7A: ('ROLL', 0, pops, pushes, default, 'The item n back in the stack is moved to the top.'),
    0x7B: ('ROT', 0, 3, 3, default, 'The top three items on the stack are rotated to the left.'),
    0x7C: ('SWAP', 0, 2, 2, default, 'The top two items on the stack are swapped.'),
    0x7D: ('TUCK', 0, 2, 3, default, 'The item at the top of the stack is copied and inserted before the second-to-top item.'),

    # Splice
    0x7E: ('CAT', 0, 2, 1, default, 'Concatenates two strings.'),
    0x7F: ('SUBSTR', 0, 3, 1, default, 'Returns a section of a string.'),
    0x80: ('LEFT', 0, 2, 1, default, 'Keeps only characters left of the specified point in a string.'),
    0x81: ('RIGHT', 0, 2, 1, default, 'Keeps only characters right of the specified point in a string.'),
    0x82: ('SIZE', 0, 1, 1, default, 'Returns the length of the input string.'),

    # Bitwise logic
    0x83: ('INVERT', 0, 1, 1, default, 'Flips all of the bits in the input.'),
    0x84: ('AND', 0, 2, 1, default, 'Boolean and between each bit in the inputs.'),
    0x85: ('OR', 0, 2, 1, default, 'Boolean or between each bit in the inputs.'),
    0x86: ('XOR', 0, 2, 1, default, 'Boolean exclusive or between each bit in the inputs.'),
    0x87: ('EQUAL', 0, 2, 1, default, 'Returns 1 if the inputs are exactly equal, 0 otherwise.'),
    0x88: ('OP_EQUALVERIFY', 0, pops, pushes, default, 'Same as OP_EQUAL, but runs OP_VERIFY afterward.'),
    0x89: ('OP_RESERVED1', 0, pops, pushes, default, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),
    0x8A: ('OP_RESERVED2', 0, pops, pushes, default, 'Transaction is invalid unless occuring in an unexecuted OP_IF branch'),

    # Arithmetic
    # Note: Arithmetic inputs are limited to signed 32-bit integers, but may overflow their output.
    0x8B: ('INC', 0, 1, 1, default, '1 is added to the input.'),
    0x8C: ('DEC', 0, 1, 1, default, '1 is subtracted from the input.'),
    0x8D: ('SIGN', 0, 1, 1, default, ''),
    0x8F: ('NEGATE', 0, 1, 1, default, 'The sign of the input is flipped.'),
    0x90: ('ABS', 0, 1, 1, default, 'The input is made positive.'),
    0x91: ('NOT', 0, 1, 1, default, 'If the input is 0 or 1, it is flipped. Otherwise the output will be 0.'),
    0x92: ('NZ', 0, 1, 1, default, 'Returns 0 if the input is 0. 1 otherwise.'),
    0x93: ('ADD', 0, pops, pushes, default, 'a is added to b.'),
    0x94: ('SUB', 0, pops, pushes, default, 'b is subtracted from a.'),
    0x95: ('MUL', 0, pops, pushes, default, 'a is multiplied by b.'),
    0x96: ('DIV', 0, pops, pushes, default, 'a is divided by b.'),
    0x97: ('MOD', 0, pops, pushes, default, 'Returns the remainder after dividing a by b.'),
    0x98: ('SHL', 0, pops, pushes, default, 'Shifts a left b bits, preserving sign.'),
    0x99: ('SHR', 0, pops, pushes, default, 'Shifts a right b bits, preserving sign.'),
    0x9A: ('BOOLAND', 0, pops, pushes, default, 'If both a and b are not 0, the output is 1. Otherwise 0.'),
    0x9B: ('BOOLOR', 0, pops, pushes, default, 'If a or b is not 0, the output is 1. Otherwise 0.'),
    0x9C: ('NUMEQUAL', 0, pops, pushes, default, 'Returns 1 if the numbers are equal, 0 otherwise.'),
    0x9E: ('NUMNOTEQUAL', 0, pops, pushes, default, 'Returns 1 if the numbers are not equal, 0 otherwise.'),
    0x9F: ('LT', 0, pops, pushes, default, 'Returns 1 if a is less than b, 0 otherwise.'),
    0xA0: ('GT', 0, pops, pushes, default, 'Returns 1 if a is greater than b, 0 otherwise.'),
    0xA1: ('LTE', 0, pops, pushes, default, 'Returns 1 if a is less than or equal to b, 0 otherwise.'),
    0xA2: ('GTE', 0, pops, pushes, default, 'Returns 1 if a is greater than or equal to b, 0 otherwise.'),
    0xA3: ('MIN', 0, pops, pushes, default, 'Returns the smaller of a and b.'),
    0xA4: ('MAX', 0, pops, pushes, default, 'Returns the larger of a and b.'),
    0xA5: ('WITHIN', 0, pops, pushes, default, 'Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.'),

    # Crypto
    #0xA6: ('RIPEMD160', 0, pops, pushes, default, 'The input is hashed using RIPEMD-160.'),
    0xA7: ('SHA1', 0, pops, pushes, 0.01, 'The input is hashed using SHA-1.'),
    0xA8: ('SHA256', 0, pops, pushes, 0.01, 'The input is hashed using SHA-256.'),
    0xA9: ('HASH160', 0, pops, pushes, 0.02, ''),
    0xAA: ('HASH256', 0, pops, pushes, 0.02, ''),
    0xAC: ('CHECKSIG', 0, pops, pushes, 0.1, ''),
    0xAD: ('VERIFY', 0, pops, pushes, 0.1, ''),
    0xAE: ('CHECKMULTISIG', 0, pops, pushes, 0.1, ''),

    # Array
    0xC0: ('ARRAYSIZE', 0, pops, pushes, default, ''),
    0xC1: ('PACK', 0, pops, pushes, default, ''),
    0xC2: ('UNPACK', 0, pops, pushes, default, ''),
    0xC3: ('PICKITEM', 0, pops, pushes, default, ''),
    0xC4: ('SETITEM', 0, pops, pushes, default, ''),
    0xC5: ('NEWARRAY', 0, pops, pushes, default, 'Used as reference type'),
    0xC6: ('NEWSTRUCT', 0, pops, pushes, default, 'Used as reference value '),
    0xC7: ('NEWMAP', 0, pops, pushes, default, ''),
    0xC8: ('APPEND', 0, pops, pushes, default, ''),
    0xC9: ('REVERSE', 0, pops, pushes, default, ''),
    0xCA: ('REMOVE', 0, pops, pushes, default, ''),
    0xCB: ('HASKEY', 0, pops, pushes, default, ''),
    0xCC: ('KEYS', 0, pops, pushes, default, ''),
    0xCD: ('VALUES', 0, pops, pushes, default, ''),

    # Exceptions
    0xF0: ('THROW', 0, 0, 0, default, ''),
    0xF1: ('THROWIFNOT', 0, 1, 0, default, '')
}

class Avm(object):
    """Bytecode for NEO VM."""

    def __init__(self):
        self.table = _table
        self.reverse_table = self._get_reverse_table()

    def _get_reverse_table(self):
        """Build an internal table used in the assembler."""
        reverse_table = {}
        for (opcode, (mnemonic, immediate_operand_size,
                      pops, pushes, gas, description)) in self.table.items():
            reverse_table[mnemonic] = opcode, mnemonic, immediate_operand_size, \
                pops, pushes, gas, description
        return reverse_table

'''
'''--- octopus/platforms/NEO/cfg.py ---
from octopus.core.function import Function
from octopus.core.basicblock import BasicBlock
from octopus.core.edge import Edge
from octopus.core.edge import (EDGE_UNCONDITIONAL,
                               EDGE_CONDITIONAL_TRUE,
                               EDGE_CONDITIONAL_FALSE,
                               EDGE_FALLTHROUGH)

from octopus.analysis.cfg import CFG

from octopus.platforms.NEO.disassembler import NeoDisassembler

from logging import getLogger
logging = getLogger(__name__)

def enum_func_static(instructions):

    functions = list()

    # first function of NeoContract is *usually* the Main function
    function = Function(instructions[0].offset, start_instr=instructions[0], name='Main')

    # parse the instructions and create Function object
    new_func = False
    for inst in instructions:
        if new_func:
            name = 'func_%x' % inst.offset
            function = Function(inst.offset, start_instr=inst, name=name)
            new_func = False

        # associate current instruction to the function
        # Worked because instruction between
        # function.start_offset and function.end_offset
        # are on the same function on Neo
        # i.e linear disassembly
        function.instructions.append(inst)

        # terminator instruction or last one
        if inst.is_halt or inst == instructions[-1]:
            function.size = inst.offset_end - function.start_offset
            function.end_offset = inst.offset_end
            function.end_instr = inst

            functions.append(function)
            new_func = True

    return functions

def xref_of_instr(instr):
    """ Return xref for branch instruction """
    return int.from_bytes(instr.operand, byteorder='little', signed=True) + instr.offset_end - 2

def enumerate_xref(instructions):
    # list cross reference to Instruction and return list of xref
    xrefs = []

    for inst in instructions:
        if inst.is_branch_unconditional:
            xrefs.append(xref_of_instr(inst))
        elif inst.is_branch_conditional:
            xrefs.append(xref_of_instr(inst))
            xrefs.append(inst.offset_end + 1)
        elif inst.is_halt and inst != instructions[-1]:
            xrefs.append(inst.offset_end + 1)
    xrefs = list(set(xrefs))
    return xrefs

def assign_blocks_to_func(basicblocks, functions):

    for func in functions:
        for bb in basicblocks:
            if bb.start_offset in range(func.start_offset, func.end_offset):
                func.basicblocks.append(bb)
    return functions

def enum_blocks_edges(instructions):

    """
    Return a list of basicblock after
    statically parsing given instructions
    """

    basicblocks = list()
    edges = list()
    xrefs = enumerate_xref(instructions)
    # create the first block
    new_block = True

    for inst in instructions:
        if new_block:
            block = BasicBlock(start_offset=inst.offset,
                               start_instr=inst,
                               name='block_%x' % inst.offset)
            new_block = False

        # add current instruction to the basicblock
        block.instructions.append(inst)

        # next instruction in xrefs list
        if (inst.offset_end + 1) in xrefs:
            # absolute JUMP
            if inst.is_branch_unconditional:
                edges.append(Edge(block.name, 'block_%x' % xref_of_instr(inst),
                                  EDGE_UNCONDITIONAL))
            # conditionnal JUMPI / JUMPIF / ...
            elif inst.is_branch_conditional:
                edges.append(Edge(block.name, 'block_%x' % xref_of_instr(inst),
                                  EDGE_CONDITIONAL_TRUE))
                edges.append(Edge(block.name, 'block_%x' % (inst.offset_end + 1),
                                  EDGE_CONDITIONAL_FALSE))
            # Halt instruction : RETURN, STOP, RET, ...
            elif inst.is_halt:
                pass
            # just falls to the next instruction
            else:
                edges.append(Edge(block.name, 'block_%x' % (inst.offset_end + 1),
                                  EDGE_FALLTHROUGH))

            block.end_offset = inst.offset_end
            block.end_instr = inst
            basicblocks.append(block)
            new_block = True

    # add the last block
    basicblocks.append(block)
    edges = list(set(edges))

    return (basicblocks, edges)

class NeoCFG(CFG):

    def __init__(self, bytecode=None, instructions=None, static_analysis=True):
        """ TODO """

        if not bytecode and not instructions:
            raise Exception("No bytecode/instructions provided")
        if instructions:
            self.instructions = instructions
        else:
            # disassemble bytecode to instructions
            disasm = NeoDisassembler(bytecode)
            self.instructions = disasm.disassemble()
        self.static_analysis = static_analysis

        self.basicblocks = list()
        self.functions = list()
        self.edges = list()

        if self.static_analysis:
            self.run_static_analysis()

    def run_static_analysis(self):
        self.functions = enum_func_static(self.instructions)
        self.basicblocks, self.edges = enum_blocks_edges(self.instructions)
        self.functions = assign_blocks_to_func(self.basicblocks, self.functions)

    def __str__(self):
        line = ("length functions = %d\n" % len(self.functions))
        line += ("length basicblocks = %d\n" % len(self.basicblocks))
        line += ("length instructions = %d\n" % len(self.instructions))
        line += ("length edges = %d\n" % len(self.edges))
        return line

'''
'''--- octopus/platforms/NEO/disassembler.py ---
import io

from octopus.engine.disassembler import Disassembler

from octopus.platforms.NEO.instruction import NeoInstruction
from octopus.platforms.NEO.avm import Avm

class NeoDisassembler(Disassembler):

    def __init__(self, bytecode=None):
        Disassembler.__init__(self, bytecode=bytecode, asm=Avm())

    def disassemble_opcode(self, bytecode, offset=0):
        '''
        TODO
        '''

        wallet = io.BytesIO(bytecode)
        opcode = int.from_bytes(wallet.read(1), byteorder='big')

        invalid = ('INVALID', 0, 0, 0, 0, 'Unknown opcode')
        name, operand_size, pops, pushes, gas, description = \
            self.asm.table.get(opcode, invalid)
        instruction = NeoInstruction(opcode, name, operand_size, pops, pushes,
                                     gas, description, offset=offset)
        if instruction.has_length_operand:
            instruction.operand_size = int.from_bytes(wallet.read(1), byteorder='big')
        if instruction.has_operand:
            instruction.operand = wallet.read(instruction.operand_size)
        return instruction

    def disassemble(self, bytecode=None, offset=0, r_format='list'):
        '''
        TODO
        '''
        self.bytecode = str(bytecode) if bytecode else str(self.bytecode)

        self.instructions = list()
        self.reverse_instructions = dict()

        return super().disassemble(bytecode, offset, r_format)

'''
'''--- octopus/platforms/NEO/explorer.py ---
from octopus.engine.explorer import Explorer

# Inspired by https://github.com/ellmetha/neojsonrpc

NEO_HOST = 'seed2.neo.org'

MAINNET_HTTP_RPC_PORT = 10332
MAINNET_HTTPS_RPC_PORT = 10331
TESTNET_HTTP_RPC_PORT = 20332
TESTNET_HTTPS_RPC_PORT = 20331

class NeoExplorerRPC(Explorer):
    '''
    Neo JSON-RPC client class
    '''

    def __init__(self, host=NEO_HOST, port=MAINNET_HTTP_RPC_PORT, tls=False, max_retries=3):
        Explorer.__init__(self, host=host, port=port, tls=tls, max_retries=max_retries)

        # Initializes an "ID counter" that'll be used to forge each request to the JSON-RPC
        # endpoint. The "id" parameter is "required" in order to help clients sort responses out.
        # In the case of the current client, we'll just ensure that this value gets incremented
        # after each request made to the JSON-RPC endpoint.
        self._id_counter = 0

    def call(self, method, params=None, jsonrpc='2.0', _id=None):

        # Determines which 'id' value to use and increment the counter associated with the current
        # client instance if applicable.
        rid = _id or self._id_counter
        if _id is None:
            self._id_counter += 1

        return super().call(method, params, jsonrpc, rid)

    #######################
    # HIGHT-LEVEL METHODS #
    #######################

    def get_transaction(self, transaction_id, verbosity=True):
        """ Return transaction informations

        .. seealso::
            :method:`getrawtransaction`
        """
        return self.getrawtransaction(transaction_id, verbosity)

    def get_block_by_number(self, block_number):
        """ Return block information using given block number

        .. seealso::
            :method:`getblock`
        """
        return self.getblock(block_number)

    def get_block_by_hash(self, block_hash):
        """ Return block information using given block hash

        .. seealso::
            :method:`getblock`
        """
        return self.getblock(block_hash)

    ####################
    # JSON-RPC METHODS #
    ####################

    # ressources :
    # http://docs.neo.org/en-us/node/api.html
    # https://neotracker.io/

    def dumpprivkey(self, address):
        """ Returns the private key of the standard address.

        :param address: a 34-bit length address (eg. AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz)
        :type address: str
        :return: Returns the private key of the standard address.
        :rtype: str

        .. note::
            You need to open the wallet in the NEO-CLI node before you execute this command.
        .. seealso::
            http://docs.neo.org/en-us/node/api/dumpprivkey.html
        .. todo::
            SEEM TO WORK
        """
        return self.call('dumpprivkey', [address])

    def getaccountstate(self, address):
        """ Returns the account state information associated with a specific address.

        :param address: a 34-bit length address (eg. AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz)
        :type address: str
        :return: dictionary containing the account state information
        :rtype: dict

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getaccountstate("AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz")
        {'balances': [{'asset': '0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
            'value': '60'},
        {'asset': '0x602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
            'value': '0.29359449'}],
        'frozen': False,
        'script_hash': '0xb6be270ca7cf0affe93de076fc3ace8662027f61',
        'version': 0,
        'votes': []}

        .. seealso::
            http://docs.neo.org/en-us/node/api/getaccountstate.html
        .. todo::
            TESTED

        """
        return self.call('getaccountstate', [address])

    def getapplicationlog(self, txid):
        """ Returns the contract log based on the specified txid.

        :param txid: Transaction ID
        :type txid: str
        :return: dictionary containing the contract logs
        :rtype: dict

        .. note::
            You need to run the command dotnet neo-cli.dll --log to enable logging before invoking this method. The complete contract logs are stored under the ApplicationLogs directory.
        .. seealso::
            http://docs.neo.org/en-us/node/api/getapplicationlog.html
        .. todo::
            NOT TESTED
        """
        return self.call('getapplicationlog', [txid])

    def getassetstate(self, asset_id):
        """ Returns the asset information associated with a specific asset ID.

        :param asset_id:
            an asset identifier (the transaction ID of the RegistTransaction when the asset is
            registered)
        :type asset_id: str
        :return: dictionary containing the asset state information
        :rtype: dict

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getassetstate("c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b")
        {'admin': 'Abf2qMs1pzQb8kYk9RuxtUb9jtRKJVuBJt',
         'amount': '100000000',
         'available': '100000000',
         'expiration': 4000000,
         'frozen': False,
         'id': '0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
         'issuer': 'Abf2qMs1pzQb8kYk9RuxtUb9jtRKJVuBJt',
         'name': [{'lang': 'zh-CN', 'name': ''},
         {'lang': 'en', 'name': 'AntShare'}],
         'owner': '00',
         'precision': 0,
         'type': 'GoverningToken',
         'version': 0}

        .. seealso::
            http://docs.neo.org/en-us/node/api/getassetstate.html
        .. todo::
            TESTED
        """
        return self.call('getassetstate', [asset_id])

    def getbalance(self, asset_id):
        """ Returns the balance of the corresponding asset in the wallet, based on the specified asset number.

        :param asset_id:
            an asset identifier (the transaction ID of the RegistTransaction when the asset is
            registered)
        :type asset_id: str
        :return: dictionary containing the actual balance and the exact amount of the asset in the wallet
        :rtype: dict

        .. note::
            You need to open the wallet in the NEO-CLI node before you execute this command.
        .. seealso::
            http://docs.neo.org/en-us/node/api/getbalance.html
        .. todo::
            NOT TESTED
        """
        return self.call('getbalance', [asset_id])

    def getbestblockhash(self):
        """ Returns the hash of the tallest block in the main chain.
        :return: hash of the tallest block in the chain
        :rtype: str

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getbestblockhash()
        '0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b'

        .. seealso::
            http://docs.neo.org/en-us/node/api/getbestblockhash.html
        .. todo::
            TESTED
        """
        return self.call('getbestblockhash')

    def getblock(self, block_id, verbose=True):
        """ Returns the block information associated with a specific hash value or block index.

        :param block_hash: a block hash value or a block index (block height)
        :param verbose:
            a boolean indicating whether the detailed block information should be returned in JSON
            format (otherwise the block information is returned as an hexadecimal string by the
            JSON-RPC endpoint)
        :type block_hash: str or int
        :type verbose: bool
        :return:
            dictionary containing the block information (or an hexadecimal string if verbose is set
            to False)
        :rtype: dict or str

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getblock(1917115)
        {'confirmations': 1,
         'hash': '0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b',
         'index': 1917115,
         .....
        >>> explorer.getblock('0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b')
        {'confirmations': 1,
         'hash': '0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b',
         'index': 1917115,

        .. seealso::
            http://docs.neo.org/en-us/node/api/getblock.html
            http://docs.neo.org/en-us/node/api/getblock2.html
        .. todo::
            TESTED
        """
        return self.call('getblock', [block_id, int(verbose)])

    def getblockcount(self):
        """ Returns the number of blocks in the chain.
        :return: number of blocks in the chain
        :rtype: int

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getblockcount()
        1917116

        .. seealso::
            http://docs.neo.org/en-us/node/api/getblockcount.html
        .. todo::
            TESTED
        """
        return self.call('getblockcount')

    def getblockhash(self, block_index):
        """ Returns the hash value associated with a specific block index.
        :param block_index: a block index (block height)
        :type block_index: int
        :return: hash of the block associated with the considered index
        :rtype: str

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getblockhash(1917115)
        '0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b'

        .. seealso::
            http://docs.neo.org/en-us/node/api/getblockhash.html
        .. todo::
            TESTED
        """
        return self.call('getblockhash', [block_index])

    def getblocksysfee(self, block_index):
        """ Returns the system fees associated with a specific block index.
        :param block_index: a block index (block height)
        :type block_index: int
        :return: system fees of the block, expressed in NeoGas units
        :rtype: str

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getblocksysfee(1917115)
        '206594'

        .. seealso::
            http://docs.neo.org/en-us/node/api/getblocksysfee.html
        .. todo::
            TESTED
        """
        return self.call('getblocksysfee', [block_index])

    def getconnectioncount(self):
        """ Returns the current number of connections for the considered node.
        :return: number of connections for the node
        :rtype: int

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getconnectioncount()
        57

        .. seealso::
            http://docs.neo.org/en-us/node/api/getconnectioncount.html
        .. todo::
            TESTED
        """
        return self.call('getconnectioncount')

    def getcontractstate(self, script_hash):
        """ Returns the contract information associated with a specific script hash.
        :param script_hash: contract script hash
        :type script_hash: str
        :return: dictionary containing the contract information
        :rtype: dict

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getcontractstate("d3cce84d0800172d09c88ccad61130611bd047a4")
        {'author': 'Erik Zhang',
         'code_version': '2.0',
         'description': 'Lock 2.0',
         'email': 'erik@neo.org',
         'hash': '0xd3cce84d0800172d09c88ccad61130611bd047a4',
         'name': 'Lock',
         'parameters': ['Integer', 'PublicKey', 'Signature'],
         'returntype': 'Boolean',
         'script': '56c56b6c766b00527ac46c766b51527ac46c766b52527ac4616168184e656f2e426c6f636b636861696e2e4765744865696768746168184e656f2e426c6f636b636861696e2e4765744865616465726c766b53527ac46c766b00c36c766b53c36168174e656f2e4865616465722e47657454696d657374616d70a06c766b54527ac46c766b54c3640e00006c766b55527ac4621a006c766b51c36c766b52c3617cac6c766b55527ac46203006c766b55c3616c7566',
         'storage': False,
         'version': 0}

        .. seealso::
            http://docs.neo.org/en-us/node/api/getcontractstate.html
        .. todo::
            TESTED
        """
        return self.call('getcontractstate', [script_hash])

    def getnewaddress(self):
        """ Creates a new address and return it.
        :return: the newly created address.
        :rtype: str

        .. note::
            You need to open the wallet in the NEO-CLI node before you execute this command.
        .. seealso::
            http://docs.neo.org/en-us/node/api/getnewaddress.html
        .. todo::
            NOT TESTED
        """
        return self.call('getnewaddress')

    def getrawmempool(self):
        """ Returns a list of unconfirmed transactions in memory associated with the node.
        :return: list of unconfirmed transaction hashes
        :rtype: list

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.getrawmempool()
        ['0xb7ed3825dfb23db0198df1d00b7250a867b1b7457b0f5ec9c0f9393ad1939729',
         '0x4393c79340eb9e11fe6a179984b6989195044c79b92dee16a8a1090189b8ef4d',
         '0xa705e48ab47817409028d89bf5727399333cdefe60d879ac5b70df38f3096436',
         ...

        .. seealso::
            http://docs.neo.org/en-us/node/api/getrawmempool.html
        .. todo::
            TESTED
        """
        return self.call('getrawmempool')

    def getrawtransaction(self, tx_hash, verbose=True):
        """ Returns detailed information associated with a specific transaction hash.

        :param tx_hash: transaction hash
        :param verbose:
            a boolean indicating whether the detailed transaction information should be returned in
            JSON format (otherwise the transaction information is returned as an hexadecimal string
            by the JSON-RPC endpoint)
        :type tx_hash: str
        :type verbose: bool
        :return:
            dictionary containing the transaction information (or an hexadecimal string if verbose
            is set to False)
        :rtype: dict or str

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> tx_id = "f4250dab094c38d8265acc15c366dc508d2e14bf5699e12d9df26577ed74d657"
        >>> explorer.getrawtransaction(tx_id, False)
        '80000001195876cb34364dc38b730077156c6bc3a7fc570044a66fbfeeea56f71327e8ab000[...]dac'
        >>> explorer.getrawtransaction(tx_id)
        {'attributes': [],
         'blockhash': '0x9c814276156d33f5dbd4e1bd4e279bb4da4ca73ea7b7f9f0833231854648a72c',
         'blocktime': 1496719422,
         'confirmations': 925250,
         'net_fee': '0',
         'scripts': [{'invocation': '40915467ecd359684b2dc358024ca750609591aa731a0b309c7fb3cab5cd0836ad3992aa0a24da431f43b68883ea5651d548feb6bd3c8e16376e6e426f91f84c58',
           'verification': '2103322f35c7819267e721335948d385fae5be66e7ba8c748ac15467dcca0693692dac'}],
         'size': 262,
         'sys_fee': '0',
         'txid': '0xf4250dab094c38d8265acc15c366dc508d2e14bf5699e12d9df26577ed74d657',
         'type': 'ContractTransaction',
         'version': 0,
         'vin': [{'txid': '0xabe82713f756eaeebf6fa6440057fca7c36b6c157700738bc34d3634cb765819',
           'vout': 0}],
         'vout': [{'address': 'AHCNSDkh2Xs66SzmyKGdoDKY752uyeXDrt',
           'asset': '0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
           'n': 0,
           'value': '2950'},
          {'address': 'ALDCagdWUVV4wYoEzCcJ4dtHqtWhsNEEaR',
           'asset': '0xc56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
           'n': 1,
           'value': '4050'}]}

        .. seealso::
            http://docs.neo.org/en-us/node/api/getrawtransaction.html
        .. todo::
            TESTED
        """
        return self.call('getrawtransaction', [tx_hash, int(verbose)])

    def getstorage(self, script_hash, hexkey):
        """ Returns the value stored in the storage of a contract script hash for a given key.

        :param script_hash: contract script hash
        :param hexkey: key to look up in the storage (in hex string)
        :type script_hash: str
        :type key: str
        :return: the stored value (in hex string)
        :rtype: str

        .. seealso::
            http://docs.neo.org/en-us/node/api/getstorage.html
        .. todo::
            SEEM TO WORK
        """
        return self.call('getstorage', [script_hash, hexkey])

    def gettxout(self, tx_hash, index):
        """ Returns the transaction output information corresponding to a hash and index.

        :param tx_hash: transaction hash
        :param index:
            index of the transaction output to be obtained in the transaction (starts from 0)
        :type tx_hash: str
        :type index: int
        :return: dictionary containing the transaction output
            If the transaction output is already spent, the result value will be null.
        :rtype: dict

        .. seealso::
            http://docs.neo.org/en-us/node/api/gettxout.html
        .. todo::
            SEEM TO WORK
        """
        return self.call('gettxout', [tx_hash, index])

    def getpeers(self):
        """ Returns a list of nodes that the node is currently connected/disconnected from.
        :return: dictionary containing the nodes the current node is connected/disconnected from
        :rtype: dict

        .. seealso::
            http://docs.neo.org/en-us/node/api/getpeers.html
        .. todo::
            NOT TESTED
        """
        return self.call('getpeers', [])

    def getversion(self):
        """ Returns version information about the current node.
        :return: dictionary containing version information about the current node
        :rtype: dict

        .. seealso::
            http://docs.neo.org/en-us/node/api/getversion.html
        .. todo::
            NOT TESTED
        """
        return self.call('getversion')

    def invoke(self, script_hash, params):
        """ Invokes a contract with given parameters and returns the result.
        It should be noted that the name of the function invoked in the contract should be part of
        paramaters.

        :param script_hash: contract script hash
        :param params: list of parameters to be passed in to the smart contract
        :type script_hash: str
        :type params: list
        :return: result of the invocation
        :rtype: dictionary

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.invoke("dc675afc61a7c0f7b3d2682bf6e1d8ed865a0e5f",
            [{"type": "String","value": "name"},{"type":"Boolean","value": False}])
        {'gas_consumed': '0.01',
         'stack': [{'type': 'ByteArray', 'value': ''},
          {'type': 'ByteArray', 'value': '6e616d65'}],
         'state': 'FAULT, BREAK'}

        .. note::
            This method is to test your VM script as if they were ran on the blockchain at that point in time. This RPC call does not affect the blockchain in any way.
        .. seealso::
            http://docs.neo.org/en-us/node/api/invoke.html
        .. todo::
            SEEM TO WORK
        """
        return self.call('invoke', [script_hash, params])

    def invokefunction(self, script_hash, operation, params):
        """ Invokes a contract's function with given parameters and returns the result.

        :param script_hash: contract script hash
        :param operation: name of the operation to invoke
        :param params: list of paramaters to be passed in to the smart contract
        :type script_hash: str
        :type operation: str
        :type params: list
        :return: result of the invocation
        :rtype: dictionary

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> script_hash = "ecc6b20d3ccac1ee9ef109af5a7cdb85706b1df9"
        >>> explorer.invokefunction(script_hash, "balanceOf", [{"type": "Hash160", "value": "bfc469dd56932409677278f6b7422f3e1f34481d"}])
        {'gas_consumed': '0.338',
         'stack': [{'type': 'ByteArray', 'value': '00ab510d'}],
         'state': 'HALT, BREAK'}

        .. note::
            This method is to test your VM script as if they were ran on the blockchain at that point in time. This RPC call does not affect the blockchain in any way.
        .. seealso::
            http://docs.neo.org/en-us/node/api/invokefunction.html
        .. todo::
            TESTED
        """
        return self.call('invokefunction', [script_hash, operation, params])

    def invokescript(self, script):
        """ Invokes a script on the VM and returns the result.
        :param script: script runnable by the VM
        :type script: str
        :return: result of the invocation
        :rtype: dictionary

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.invokescript("00046e616d656711c4d1f4fba619f2628870d36e3a9773e874705b")
        {'gas_consumed': '0.01',
         'stack': [{'type': 'ByteArray', 'value': ''},
          {'type': 'ByteArray', 'value': '6e616d65'}],
         'state': 'FAULT, BREAK'}

        .. note::
            This method is to test your VM script as if they were ran on the blockchain at that point in time. This RPC call does not affect the blockchain in any way.
        .. seealso::
            http://docs.neo.org/en-us/node/api/invokescript.html
        .. todo::
            TESTED
        """
        return self.call('invokescript', [script])

    def listaddress(self):
        """ Lists all the addresses in the current wallet.
        :return: dictionary containing addresses in the wallet and indicates whether it is a watch only address.
        :rtype: dict

        .. note::
            You need to open the wallet in the NEO-CLI node before invoking this method.
        .. seealso::
            http://docs.neo.org/en-us/node/api/listaddress.html
        .. todo::
            NOT TESTED
        """
        return self.call('listaddress')

    def sendrawtransaction(self, hextx):
        """ Broadcasts a transaction over the NEO network and returns the result.
        :param hextx: hexadecimal string that has been serialized
        :type hextx: str
        :return: result of the transaction
        :rtype: bool

        .. seealso::
            http://docs.neo.org/en-us/node/api/sendrawtransaction.html
        .. todo::
            NOT TESTED
        """
        return self.call('sendrawtransaction', [hextx])

    def sendtoaddress(self, asset_id, address, value, fee=0):
        """ Transfers to the specified address.

        :param asset_id:
            an asset identifier (the transaction ID of the RegistTransaction when the asset is
            registered)
        :type asset_id: str
        :param address: a 34-bit length address (eg. AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz)
        :type address: str
        :param value: amount to transfer
        :type value: int
        :param fee: Fee, default value is 0 (optional parameter)
        :type fee: int
        :return:
            dictionary containing the asset state information
            If the signature is incomplete, it will return the transaction to be signed.
            If the balance is insufficient, it will return an error message.
        :rtype: dict or str

        .. note::
            You need to open the wallet in the Neo-CLI node before you execute this command.
        .. seealso::
            http://docs.neo.org/en-us/node/api/sendtoaddress.html
        .. todo::
            NOT TESTED
        """
        return self.call('sendtoaddress', [asset_id, address, value, fee])

    def sendmany(self, outputs_array, fee=0, change_address=None):
        """ Bulk transfer order, and you can specify a change address.

        :param outputs_array: Array, the data structure of each element in the array is as follows:
            {"asset": <asset>,"value": <value>,"address": <address>}
            :param asset:
                an asset identifier (the transaction ID of the RegistTransaction when the asset is
                registered)
            :type asset: str
            :param value: Transfer amount
            :type value: int
            :param address: a 34-bit length destination address (eg. AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz)
            :type address: str
        :type outputs_array: list
        :param fee: Handling fee, optional parameter, default is 0.
        :type fee: int
        :param change_address: Change address, optional parameter, default is the first standard address in the wallet.
        :type change_address: str
        :return:
            Returns the transaction details as above to indicate that the transaction was sent successfully or the transaction failed.
            If the JSON format is incorrect, a Parse error is returned.
            If the signature is incomplete, a pending transaction is returned.
            If the balance is insufficient, an error message is returned.
        :rtype: dict or str

        .. note::
            You need to open the wallet in the Neo-CLI node before you execute this command.
        .. seealso::
            http://docs.neo.org/en-us/node/api/sendmany.html
        .. todo::
            NOT TESTED
        """
        return self.call('sendmany')

    def submitblock(self, hex_string):
        """ Submit new blocks

        No documentation about this RPC methods (but described as API)

        .. note::
            Needs to be a consensus node
        .. seealso::
            https://github.com/neo-project/docs/blob/master/en-us/node/api.md
        .. todo::
            NOT TESTED
        """
        return self.call('submitblock', [hex_string])

    def validateaddress(self, address):
        """ Validates if the considered string is a valid NEO address.

        :param address: string containing a potential NEO address
        :type address: str
        :return: dictionary containing the result of the verification
        :rtype: dictionary

        :Example:

        >>> explorer = NeoExplorerRPC()
        >>> explorer.validateaddress("AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz")
        {'address': 'AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz', 'isvalid': True}

        .. seealso::
            http://docs.neo.org/en-us/node/api/validateaddress.html

        """
        return self.call('validateaddress', [address])

'''
'''--- octopus/platforms/NEO/instruction.py ---
from octopus.core.instruction import Instruction

class NeoInstruction(Instruction):
    """NEO Instruction

    TODO

    """
    def __init__(self, opcode, name,
                 operand_size, pops, pushes, fee,
                 description, operand=None,
                 operand_interpretation=None, offset=0, xref=None):
        """ TODO """
        super().__init__(opcode=opcode, name=name,
                         operand_size=operand_size, pops=pops, pushes=pushes,
                         fee=fee, description=description, operand=operand,
                         operand_interpretation=operand_interpretation,
                         offset=offset)

    @property
    def has_length_operand(self):
        """ True if the instruction uses an immediate operand to define the lenght of operand """
        return self.name in ['SYSCALL']

    # overwrite this function to take care of has_length_operand
    @property
    def size(self):
        """ Size of the encoded instruction """
        if self.has_length_operand:
            # add size of lengh operand
            return self.operand_size + 2
        return self.operand_size + 1

    @property
    def group(self):
        """ Instruction classification per group """
        classes = {0x00: 'Constant',
                   0x61: 'Flow control',
                   0x6A: 'Stack',
                   0x7E: 'Splice',
                   0x83: 'Bitwise logic',
                   0x8B: 'Arithmetic',
                   0xA6: 'Crypto',
                   0xC0: 'Array',
                   0xF0: 'Exceptions'}

        last_class = classes.get(0)
        for k, v in classes.items():
            if self.opcode >= k:
                last_class = v
            else:
                return last_class
        return last_class

    @property
    def is_constant(self):
        return self.group == 'Constant'

    @property
    def is_flow_control(self):
        return self.group == 'Flow control'

    @property
    def is_stack(self):
        return self.group == 'Stack'

    @property
    def is_splice(self):
        return self.group == 'Splice'

    @property
    def is_bitwise_logic(self):
        return self.group == 'Bitwise logic'

    @property
    def is_arithmetic(self):
        return self.group == 'Arithmetic'

    @property
    def is_crypto(self):
        return self.group == 'Crypto'

    @property
    def is_array(self):
        return self.group == 'Array'

    @property
    def is_exceptions(self):
        return self.group == 'Exceptions'

    @property
    def is_branch_conditional(self):
        """ Return list if the instruction is a jump """
        return self.name in ['JMPIF', 'JMPIFNOT']

    @property
    def is_branch_unconditional(self):
        """ Return list if the instruction is a jump """
        return self.name in ['JMP']

    @property
    def is_branch(self):
        """ True if the instruction is a jump """
        return self.is_branch_conditional or self.is_branch_unconditional

    @property
    def is_halt(self):
        """ Return list if the instruction is a basic block terminator """
        return (self.name in ['RET'] or self.is_exceptions)

    @property
    def is_terminator(self):
        """ True if the instruction is a basic block terminator """
        return self.is_branch or self.is_halt

    @property
    def have_xref(self):
        """ True if the instruction operand is a reference to an other instruction """
        return self.is_branch or (self.name in ['CALL'])

'''
'''--- octopus/platforms/__init__.py ---

'''
'''--- octopus/tests/BTC/__init__.py ---

'''
'''--- octopus/tests/BTC/test_disassembler.py ---
from octopus.platforms.BTC.disassembler import BitcoinDisassembler
import unittest

class BtcDisassemblerTestCase(unittest.TestCase):

    def testDisassembleHex(self):
        def test(bytecode_hex, result):
            disasm = BitcoinDisassembler(bytecode_hex).disassemble(r_format='text')
            self.assertEqual(disasm, result)

        def testNumberInstructions(bytecode_hex, len_result):
            disasm = BitcoinDisassembler(bytecode_hex).disassemble()
            self.assertEqual(len(disasm), len_result)

        # good test case : https://ivy-lang.org/bitcoin

        # https://en.bitcoin.it/wiki/Transaction#Pay-to-PubkeyHash
        # classic scriptPubKey
        bytecode_hex = "76a9149ba386253ea698158b6d34802bb9b550f5ce36dd88ac"
        result = 'OP_DUP\nOP_HASH160\n9ba386253ea698158b6d34802bb9b550f5ce36dd\nOP_EQUALVERIFY\nOP_CHECKSIG'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 5)

        # LockWithMultisig
        bytecode_hex = "007b7b522102f3ce98f0f47f9b91156b15cc43dd0956dfb1b94f2cacd95856ee1473a8c0ad6a2103399e680b0dc1f53c0d4641ef5f4c1267b69125b5076e1230f6ff1f4a1c4286eb21021cc83c35ab6cf47f6aa473449218e49dfa6e33ec2f0eb9e4e1ff709848ebe66453ae"
        result = '0\nOP_ROT\nOP_ROT\n2\n02f3ce98f0f47f9b91156b15cc43dd0956dfb1b94f2cacd95856ee1473a8c0ad6a\n03399e680b0dc1f53c0d4641ef5f4c1267b69125b5076e1230f6ff1f4a1c4286eb\n021cc83c35ab6cf47f6aa473449218e49dfa6e33ec2f0eb9e4e1ff709848ebe664\n3\nOP_CHECKMULTISIG'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 9)

        # LockWithPublicKeyHash
        bytecode_hex = "76a82096b3fe1f4ec8fd076379267f72443bed81cc49c18a2913f7e1f0727f6f9f4fbf88ac"
        result = 'OP_DUP\nOP_SHA256\n96b3fe1f4ec8fd076379267f72443bed81cc49c18a2913f7e1f0727f6f9f4fbf\nOP_EQUALVERIFY\nOP_CHECKSIG'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 5)

        # RevealPreImage
        bytecode_hex = 'a820c0c89d16be9b625834782a90411ebb259040775ee921651979d15fed5da0c26987'
        result = 'OP_SHA256\nc0c89d16be9b625834782a90411ebb259040775ee921651979d15fed5da0c269\nOP_EQUAL'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 3)

        # RevealCollision
        bytecode_hex = '6e879169a77ca787'
        result = 'OP_2DUP\nOP_EQUAL\nOP_NOT\nOP_VERIFY\nOP_SHA1\nOP_SWAP\nOP_SHA1\nOP_EQUAL'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 8)

        # RevealFixedPoint
        bytecode_hex = '76a887'
        result = 'OP_DUP\nOP_SHA256\nOP_EQUAL'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 3)

        bytecode_hex = '00b17521020cd5ac6e63926130ebff8b7063fa2cc26f597d6babed4adac23bff79e2178cceac'
        result = '0\nOP_CHECKLOCKTIMEVERIFY\nOP_DROP\n020cd5ac6e63926130ebff8b7063fa2cc26f597d6babed4adac23bff79e2178cce\nOP_CHECKSIG'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 5)

        # LockDelay
        bytecode_hex = '210361256041a4496060fd78bc5a3584622166210a6aa190513393541a47ccf8a67bad012ab27551'
        result = '0361256041a4496060fd78bc5a3584622166210a6aa190513393541a47ccf8a67b\nOP_CHECKSIGVERIFY\n42\nOP_CHECKSEQUENCEVERIFY\nOP_DROP\n1'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 6)

        # TransferWithTimeout
        bytecode_hex = '2102e5707a829f684e9c9263872ecd30c0027ca1a558b22f08f2aafc33f7b2eabdc27c630145b17567ad2103edb42eb19ef3badb27a5f7d13843dd8a58de5c0f6b9d9f1ffbeca59e9d35b85b68ac'
        result = '02e5707a829f684e9c9263872ecd30c0027ca1a558b22f08f2aafc33f7b2eabdc2\nOP_SWAP\nOP_IF\n69\nOP_CHECKLOCKTIMEVERIFY\nOP_DROP\nOP_ELSE\nOP_CHECKSIGVERIFY\n03edb42eb19ef3badb27a5f7d13843dd8a58de5c0f6b9d9f1ffbeca59e9d35b85b\nOP_ENDIF\nOP_CHECKSIG'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 11)

        # EscrowWithDelay
        bytecode_hex = '2103d32df19c6a163f2c0b3f047756e9fc4765c41897f59d5029ea624d839d6391b27c63ad0350c300b27551670072522102930524687b853a7bb80b5f24748e4b926869d629eca69e6e2d7758417e3249b02102d4e2e6a73d19d7eb52df220a826db2b825282d3ac700d75222813094a7583afc567a53ae68'
        result = '03d32df19c6a163f2c0b3f047756e9fc4765c41897f59d5029ea624d839d6391b2\nOP_SWAP\nOP_IF\nOP_CHECKSIGVERIFY\n50000\nOP_CHECKSEQUENCEVERIFY\nOP_DROP\n1\nOP_ELSE\n0\nOP_2SWAP\n2\n02930524687b853a7bb80b5f24748e4b926869d629eca69e6e2d7758417e3249b0\n02d4e2e6a73d19d7eb52df220a826db2b825282d3ac700d75222813094a7583afc\n6\nOP_ROLL\n3\nOP_CHECKMULTISIG\nOP_ENDIF'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 19)

        bytecode_hex = '6a4c50010002ca6efb0fe92dfa51e3393db37e0f4b79bda0634256a0158264dc2da9c5eda6262340d1510b03723e77839290a59735eb9f1dbb167caf1803887b3b92bbe824d800000000000000000000000000'
        result = 'OP_RETURN\n010002ca6efb0fe92dfa51e3393db37e0f4b79bda0634256a0158264dc2da9c5eda6262340d1510b03723e77839290a59735eb9f1dbb167caf1803887b3b92bbe824d800000000000000000000000000'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 2)

        # decimal value display and not hex as usual
        bytecode_hex = '6a03666666'
        result = 'OP_RETURN\n6710886'
        test(bytecode_hex, result)
        testNumberInstructions(bytecode_hex, 2)

        # FAIL but don't now why
        '''
        txid = '0415e0adb2ebb67fc48e53825eb8b86b3e32a45d863adae97b15de6dc4255cba'
        bytecode_hex = '6a03e29891'
        result = 'OP_RETURN -7235358'
        result_expected = 'OP_RETURN -1153250'
        test(bytecode_hex, result_expected)
        testNumberInstructions(bytecode_hex, 2)

        txid = '853eebe9937654e19956753d6f4f8c6ae5e4744b2e391756ce02bc5e638e108d'
        bytecode_hex = '6a52534b424c4f434b3a5841945ab918147d4e33f7e90dbebb68dd7dd1c9da273ca082cd66721943b9ff'
        result = 'OP_RETURN 2 3 424c4f434b3a5841945ab918147d4e33f7e90dbebb68dd7dd1c9da273ca082cd66721943b9ff'
        result_expected = 'OP_RETURN 2 3 [error]'
        test(bytecode_hex, result_expected)
        testNumberInstructions(bytecode_hex, 4)
        '''

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(BtcDisassemblerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)
'''
'''--- octopus/tests/BTC/test_explorer.py ---
from octopus.platforms.BTC.explorer import BitcoinExplorerRPC
from octopus.platforms.BTC.explorer import RPC_USER, RPC_PASSWORD, RPC_HOST

import unittest

class BitcoinExplorerTestCase(unittest.TestCase):

    explorer = BitcoinExplorerRPC(host=('%s:%s@%s' % (RPC_USER, RPC_PASSWORD, RPC_HOST)))

    blockhash = '00000000000000000024fb37364cbf81fd49cc2d51c09c75c35433c3a1945d04'
    txid = '1b5bfc2681d40c872126919ccb1752de4cca42dcfc594899f2ef11db4b05bb39'
    tx_raw = '0200000001686b654b40737f0daa1532f64e525dc925e60d075403d38cfb12ac9097764015040000006a473044022009ec3f26984906a813faae05d968ec06bf1c68883e09a00b6333126ea87d96b302201cf1d2b9165442aa178fdf772a3909c3d2ba69e454eb8660fa35df8645e3bcb60121022f2caec3ad2f3b174d048a0d46f4f6e8ba4e9d02f6bdbba64ac6817f7ac6c131ffffffff02060d0700000000001976a91407c5acae3abc91735a1471e275e33abbffada89088ac00581300000000001976a91432f2e30111e1dc45f415430ef082cb64225c538a88ac00000000'
    wallet_address = '15wDxrRCn7YiCXdvqjcih6G8svrmq5AQSS'
    script_hex = "76a82096b3fe1f4ec8fd076379267f72443bed81cc49c18a2913f7e1f0727f6f9f4fbf88ac"
    script_asm = 'OP_DUP OP_SHA256 96b3fe1f4ec8fd076379267f72443bed81cc49c18a2913f7e1f0727f6f9f4fbf OP_EQUALVERIFY OP_CHECKSIG'

    def testRPCCommand(self):

        #######################
        # HIGHT-LEVEL METHODS #
        #######################

        self.assertEqual(self.explorer.get_transaction(self.txid, 0), self.tx_raw)
        self.assertEqual(len(self.explorer.get_block_by_hash(self.blockhash)), 18)
        self.assertEqual(len(self.explorer.get_block_by_number(500000)), 18)

        ####################
        # JSON-RPC METHODS #
        ####################

        self.assertEqual(self.explorer.decoderawtransaction(self.tx_raw)['txid'], self.txid)
        self.assertEqual(self.explorer.decodescript(self.script_hex)['asm'], self.script_asm)
        self.assertEqual(len(self.explorer.getbestblockhash()), len(self.blockhash))
        self.assertEqual(len(self.explorer.getblock(self.blockhash)), 18)
        self.assertEqual(len(self.explorer.getblockchaininfo()), 11)
        self.assertEqual(type(self.explorer.getblockcount()), int)
        self.assertEqual(self.explorer.getblockhash(500000), self.blockhash)
        # self.assertEqual(len(self.explorer.getchaintips()), 2)
        self.assertEqual(type(self.explorer.getconnectioncount()), int)
        self.assertEqual(type(self.explorer.getdifficulty()), float)
        self.assertEqual(len(self.explorer.getinfo()), 16)
        self.assertEqual(len(self.explorer.getmempoolinfo()), 5)
        self.assertEqual(len(self.explorer.getmininginfo()), 8)
        self.assertEqual(len(self.explorer.getnettotals()), 4)
        self.assertEqual(type(self.explorer.getnetworkhashps()), float)
        self.assertEqual(len(self.explorer.getnetworkinfo()), 13)
        self.assertEqual(len(self.explorer.getpeerinfo()), 8)
        self.assertEqual(type(self.explorer.getrawmempool()), list)
        self.assertEqual(self.explorer.getrawtransaction(self.txid), self.tx_raw)
        self.assertEqual(type(self.explorer.getreceivedbyaccount('')), float)
        self.assertEqual(type(self.explorer.getreceivedbyaddress(self.wallet_address)), float)
        self.assertEqual(len(self.explorer.gettxout(self.txid, 0)), 5)
        self.assertEqual(len(self.explorer.gettxoutproof([self.txid])), 818)
        self.assertEqual(type(self.explorer.getunconfirmedbalance()), float)
        self.assertEqual(len(self.explorer.getwalletinfo()), 9)
        self.assertEqual(type(self.explorer.help()), str)
        self.assertEqual(len(self.explorer.validateaddress(self.wallet_address)), 6)
        self.assertEqual(self.explorer.verifytxoutproof(self.explorer.gettxoutproof([self.txid])), [self.txid])

        # Not tested
        '''
        self.explorer.abandontransaction()
        self.explorer.addmultisigaddress()
        self.explorer.addnode()
        self.explorer.createmultisig()
        self.explorer.createrawtransaction()
        self.explorer.dumpprivkey()
        self.explorer.encryptwallet()
        self.explorer.estimatefee()
        self.explorer.estimatepriority()
        self.explorer.getaccountaddress()
        self.explorer.getaccount()
        self.explorer.getaddednodeinfo()
        self.explorer.getaddressesbyaccount()
        self.explorer.getbalance()
        self.explorer.gettransaction()
        self.explorer.keypoolrefill()
        self.explorer.listaccounts()
        self.explorer.listaddressgroupings()
        self.explorer.listlockunspent()
        self.explorer.listreceivedbyaccount()
        self.explorer.listreceivedbyaddress()
        self.explorer.listtransactions()
        self.explorer.listunspent()
        self.explorer.lockunspent()
        self.explorer.prioritisetransaction()
        self.explorer.sendfrom()
        self.explorer.sendmany()
        self.explorer.sendrawtransaction()
        self.explorer.sendtoaddress()
        self.explorer.settxfee()
        self.explorer.signmessage()
        self.explorer.signrawtransaction()
        self.explorer.submitblock()

        self.explorer.verifymessage()
        self.explorer.walletlock()
        self.explorer.walletpassphrase()
        self.explorer.walletpassphrasechange()
        '''

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(BitcoinExplorerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/EOS/__init__.py ---

'''
'''--- octopus/tests/EOS/test_callgraph.py ---
import unittest

from octopus.platforms.EOS.cfg import EosCFG
from octopus.analysis.graph import CallGraph

class EosCallGraphTestCase(unittest.TestCase):

    def testCallGraph(self):
        def callgraph(bytecode, result_nodes, length_edges, fname=False):
            cfg = EosCFG(bytecode)
            nodes, edges = cfg.get_functions_call_edges(fname)
            # visualize
            # graph = CallGraph(nodes, edges)
            # graph.view()
            self.assertEqual(nodes, result_nodes)
            self.assertEqual(len(edges), length_edges)

        # Helloworld
        bytecode_hex = "0061736d0100000001110460017f0060017e0060000060027e7e00021b0203656e76067072696e746e000103656e76067072696e7473000003030202030404017000000503010001071903066d656d6f7279020004696e69740002056170706c7900030a20020600411010010b17004120100120001000413010012001100041c00010010b0b3f050041040b04504000000041100b0d496e697420576f726c64210a000041200b0e48656c6c6f20576f726c643a20000041300b032d3e000041c0000b020a000029046e616d6504067072696e746e0100067072696e7473010004696e697400056170706c790201300131"
        r_nodes = ['printn(i64)', 'prints(i32)', 'init()', 'apply(i64 i64)']
        r_nodes2 = ['printn', 'prints', 'init', 'apply']
        len_edges = 6
        callgraph(bytecode_hex, r_nodes2, len_edges)
        callgraph(bytecode_hex, r_nodes, len_edges, fname=True)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(EosCallGraphTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/EOS/test_disassembler.py ---
import unittest

from octopus.platforms.EOS.disassembler import EosDisassembler

class EosDisassemblerTestCase(unittest.TestCase):

    def testDisassemble(self):
        def disassemble(bytecode, result):
            disasm = len(EosDisassembler(bytecode).disassemble())
            self.assertEqual(disasm, result)

        def disasmOne(bytecode, result):
            disasm = str(EosDisassembler(bytecode).disassemble_opcode(bytecode))
            self.assertEqual(disasm, result)

        def disasm(bytecode, result):
            text = EosDisassembler(bytecode).disassemble(r_format='text')
            self.assertEqual(text, result)

        def disasmModule(bytecode, result_func, result_insn):
            funcs = EosDisassembler().disassemble_module(bytecode)
            self.assertEqual(len(funcs), result_func)
            self.assertEqual(sum([len(i) for i in funcs]), result_insn)

        # Simple
        bytecode = bytearray([2, 127, 65, 24, 16, 28, 65, 0, 15, 11])
        result = 'block -1\ni32.const 24\ncall 28\ni32.const 0\nreturn\nend'

        disassemble(bytecode, 6)
        disasmOne(b'\x02\x7f', 'block -1')
        disasm(bytecode, result)

        # Helloworld
        bytecode_hex = "0061736d0100000001110460017f0060017e0060000060027e7e00021b0203656e76067072696e746e000103656e76067072696e7473000003030202030404017000000503010001071903066d656d6f7279020004696e69740002056170706c7900030a20020600411010010b17004120100120001000413010012001100041c00010010b0b3f050041040b04504000000041100b0d496e697420576f726c64210a000041200b0e48656c6c6f20576f726c643a20000041300b032d3e000041c0000b020a000029046e616d6504067072696e746e0100067072696e7473010004696e697400056170706c790201300131"
        disasmModule(bytecode_hex, 2, 14)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(EosDisassemblerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/ETH/__init__.py ---

'''
'''--- octopus/tests/ETH/test_cfg.py ---
import unittest

from octopus.analysis.graph import CFGGraph
from octopus.platforms.ETH.cfg import EthereumCFG

class EthereumCfgTestCase(unittest.TestCase):

    # bytecode_hex = "60606040526004361061006d576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680631b0ca26a146100725780635fd8c71014610087578063c0e317fb1461009c578063c6dd98e9146100a6578063f8b2cb4f146100bb575b600080fd5b341561007d57600080fd5b610085610108565b005b341561009257600080fd5b61009a6101cd565b005b6100a461028c565b005b34156100b157600080fd5b6100b96102da565b005b34156100c657600080fd5b6100f2600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190505061039e565b6040518082815260200191505060405180910390f35b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff168160405160006040518083038185876187965a03f19250505015156101ca57600080fd5b50565b3373ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205460405160006040518083038185876187965a03f192505050151561024657600080fd5b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550565b346000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550565b3373ffffffffffffffffffffffffffffffffffffffff166108fc6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549081150290604051600060405180830381858888f19350505050151561035857600080fd5b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490509190505600a165627a7a723058206c96ec820703e283140b2d7ca433b45ae2c81843758e0758913918dce06d26630029"
    bytecode_hex = "60606040526000357c0100000000000000000000000000000000000000000000000000000000900480635fd8c7101461004f578063c0e317fb1461005e578063f8b2cb4f1461006d5761004d565b005b61005c6004805050610099565b005b61006b600480505061013e565b005b610083600480803590602001909190505061017d565b6040518082815260200191505060405180910390f35b3373ffffffffffffffffffffffffffffffffffffffff16611111600060005060003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054604051809050600060405180830381858888f19350505050151561010657610002565b6000600060005060003373ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819055505b565b34600060005060003373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828282505401925050819055505b565b6000600060005060008373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505490506101b6565b91905056"
    cfg = EthereumCFG(bytecode_hex)

    number_func = 4
    number_instr = 231
    number_basicblock = 19
    edges = 18

    # visualization
    #graph = CFGGraph(cfg)
    #graph.view()

    def testInstructions(self):

        self.assertEqual(len(self.cfg.instructions), self.number_instr)

    def testEnumerateFunctions(self):

        self.assertEqual(len(self.cfg.functions), self.number_func)

    def testEnumerateBasicBlocks(self):

        self.assertEqual(len(self.cfg.basicblocks), self.number_basicblock)

    def testEdges(self):

        self.assertEqual(len(self.cfg.edges), self.edges)

class EthereumCfgTestCaseSimple(EthereumCfgTestCase):
    # simplecontract
    bytecode_hex = "6060604052341561000f57600080fd5b60d38061001d6000396000f3006060604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c14606e575b600080fd5b3415605857600080fd5b606c60048080359060200190919050506094565b005b3415607857600080fd5b607e609e565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820e1f98c821c12eea52047d7324b034ddccc41eaa7365d369b34580ab73c71a8940029"
    cfg = EthereumCFG(bytecode_hex)

    # result
    number_instr = 104
    number_func = 3
    number_basicblock = 15
    edges = 14

    # visualization
    # graph = CFGGraph(cfg)
    # graph.view()
    # graph.view_functions(simplify=True)

class EthereumSymbolicExecutionTestCaseMedium(EthereumCfgTestCase):

    bytecode_hex = "606060405260008080556001819055600a60025561012c60035560048190556109db90819061002d90396000f3606060405236156100b95760e060020a600035046309dfdc7181146100dd578063253459e31461011c5780634229616d1461013d57806357d4021b1461017857806367f809e9146101b7578063686f2c90146101ce5780636fbaaa1e146101fa5780638a5fb3ca1461022e5780639dbc4f9b14610260578063a26dbf26146102ed578063a6f9dae1146102f5578063b402295014610328578063ced9267014610366578063d11f13df1461039e578063fae14192146103ab575b6103d66103d86000670de0b6b3a76400003410156104755760018054340190555b50565b6040805160208181018352600080835283519054610100820190945260ca8082526103da94670de0b6b3a7640000900493926107d29083013990509091565b600154670de0b6b3a764000090045b60408051918252519081900360200190f35b6103d6600435600554600090600160a060020a039081163390911614156105955760015481148061016e5750606482115b1561055a57610002565b61012b6000670de0b6b3a7640000600660005060046000505481548110156100025792526002919091026000805160206109bb83398151915201540490565b6103d660058054600160a060020a03191633179055565b6103d65b600554600160a060020a039081163390911614156103d857600154600014156104ef57610002565b6103da6040805160208181018352600082528251600354610140820190945261011f808252909161089c9083013990509091565b6103da604080516020818101835260008252825160025460c082019094526084808252909161074e9083013990509091565b61044f600435600654600090819083116102e85760068054849081101561000257508054818352600285027ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0154600160a060020a03169350670de0b6b3a764000091908590811015610002575050600284026000805160206109bb83398151915201540490505b915091565b60065461012b565b6103d6600435600554600160a060020a039081163390911614156100da5760058054600160a060020a0319168217905550565b6103d6600435600554600160a060020a039081163390911614156100da57600154670de0b6b3a76400009190910290811115610519576105196101d2565b6103d6600435600554600160a060020a039081163390911614156100da5761012c8111806103945750607881105b1561059957610002565b600654600454900361012b565b6103d660043560055433600160a060020a03908116911614156100da57600a81111561059e57610002565b005b565b60405180838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600f02600301f150905090810190601f1680156104405780820380516001836020036101000a031916815260200191505b50935050505060405180910390f35b6040518083600160a060020a031681526020018281526020019250505060405180910390f35b506002546802b5e3af16b1880000341061048e57600290045b6100da816000600660005080548060010182818154818355818115116105a3576002028160020283600052602060002091820191016105a391905b80821115610607578054600160a060020a031916815560006001919091019081556104c9565b600154600554604051600160a060020a03919091169160009182818181858883f150505060015550565b6001546000141561052957610002565b600554604051600160a060020a039190911690600090839082818181858883f1505060018054919091039055505050565b506001546005546040516064909204830291600160a060020a039190911690600090839082818181858883f150506001805491909103905550505b5050565b600355565b600255565b50505091909060005260206000209060020201600050604080518082019091523380825260035460643491909102046020929092018290528254600160a060020a0319161782556001919091015550600654600a141561060b5760c860035561061c565b5090565b6006546019141561061c5760966003555b6000805460648481033490810282900490920190925560018054918502929092040190555b600454600680549091908110156100025760009182526002027ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0190506001015460005411156105955760045460068054909190811015610002576002026000805160206109bb8339815191520154600454825491935090811015610002576002027ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0154604051600160a060020a03919091169150600090839082818181858883f19350505050506006600050600460005054815481101561000257600091825281546002919091026000805160206109bb8339815191520154900390556004805460010190556106415653686f776e20696e202520666f726d2e204665652069732068616c766564283530252920666f7220616d6f756e747320657175616c206f722067726561746572207468616e203530206574686572732e2028466565206d6179206368616e67652c206275742069732063617070656420746f2061206d6178696d756d206f662031302529416c6c2062616c616e63652076616c75657320617265206d6561737572656420696e204574686572732c206e6f746520746861742064756520746f206e6f20646563696d616c20706c6163696e672c2074686573652076616c7565732073686f7720757020617320696e746567657273206f6e6c792c2077697468696e2074686520636f6e747261637420697473656c6620796f752077696c6c206765742074686520657861637420646563696d616c2076616c756520796f752061726520737570706f73656420746f54686973206d756c7469706c696572206170706c69657320746f20796f7520617320736f6f6e206173207472616e73616374696f6e2069732072656365697665642c206d6179206265206c6f776572656420746f2068617374656e207061796f757473206f7220696e63726561736564206966207061796f75747320617265206661737420656e6f7567682e2044756520746f206e6f20666c6f6174206f7220646563696d616c732c206d756c7469706c696572206973207831303020666f722061206672616374696f6e616c206d756c7469706c69657220652e672e203235302069732061637475616c6c79206120322e3578206d756c7469706c6965722e20436170706564206174203378206d617820616e6420312e3278206d696e2ef652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40"
    cfg = EthereumCFG(bytecode_hex)

    # result
    number_instr = 1353
    number_func = 15
    number_basicblock = 99
    edges = 122

    # visualization
    # graph = CFGGraph(cfg)
    # graph.view()
    # graph.view_functions(simplify=True)

'''
class EthereumSymbolicExecutionTestCaseBig(EthereumCfgTestCase):

    # Ponzicoin
    bytecode_hex = "60606040526509184e72a000600355650246139ca800600455620186a060055573506a24fbcb8eda2ec7d757c943723cfb32a0682e600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550341561007f57600080fd5b62030d40600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555062030d40600260008282540192505081905550610f56806101096000396000f3006060604052600436106100db576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100e0578063095ea7b31461016e57806318160ddd146101c857806323b872dd146101f15780632e1a7d4d1461026a578063313ce567146102a55780634b750334146102d45780634d853ee5146102fd57806370a08231146103525780638620410b1461039f57806395d89b41146103c8578063a9059cbb14610456578063b60d4288146104b0578063dd62ed3e146104d2578063eac037b21461053e575b600080fd5b34156100eb57600080fd5b6100f3610567565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610133578082015181840152602081019050610118565b50505050905090810190601f1680156101605780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561017957600080fd5b6101ae600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919050506105a0565b604051808215151515815260200191505060405180910390f35b34156101d357600080fd5b6101db610692565b6040518082815260200191505060405180910390f35b34156101fc57600080fd5b610250600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610698565b604051808215151515815260200191505060405180910390f35b341561027557600080fd5b61028b600480803590602001909190505061098e565b604051808215151515815260200191505060405180910390f35b34156102b057600080fd5b6102b8610a8f565b604051808260ff1660ff16815260200191505060405180910390f35b34156102df57600080fd5b6102e7610a94565b6040518082815260200191505060405180910390f35b341561030857600080fd5b610310610a9a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561035d57600080fd5b610389600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610ac0565b6040518082815260200191505060405180910390f35b34156103aa57600080fd5b6103b2610b08565b6040518082815260200191505060405180910390f35b34156103d357600080fd5b6103db610b0e565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561041b578082015181840152602081019050610400565b50505050905090810190601f1680156104485780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561046157600080fd5b610496600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610b47565b604051808215151515815260200191505060405180910390f35b6104b8610d2a565b604051808215151515815260200191505060405180910390f35b34156104dd57600080fd5b610528600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610e9d565b6040518082815260200191505060405180910390f35b341561054957600080fd5b610551610f24565b6040518082815260200191505060405180910390f35b6040805190810160405280600981526020017f506f6e7a69436f696e000000000000000000000000000000000000000000000081525081565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60025481565b6000816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410158015610764575081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410155b80156107ed57506000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401115b1561098257816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050610987565b600090505b9392505050565b600080826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515610a845760045483029050826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550826002600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610a7b57600080fd5b60019150610a89565b600091505b50919050565b600381565b60045481565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60035481565b6040805190810160405280600381526020017f534543000000000000000000000000000000000000000000000000000000000081525081565b6000816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410158015610c1457506000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401115b15610d1f57816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050610d24565b600090505b92915050565b600080600060035434811515610d3c57fe5b049150600554821115610d4f5760055491505b60035482029050816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167f9cb9c14f7bc76e3a89b796b091850526236115352a198b1e472f00e91376bbcb836040518082815260200191505060405180910390a281600260008282540192505081905550816005600082825403925050819055506000600554111515610e4957620186a0600581905550600260036000828254029250508190555060026004600082825402925050819055505b80341115610e94573373ffffffffffffffffffffffffffffffffffffffff166108fc8234039081150290604051600060405180830381858888f193505050501515610e9357600080fd5b5b60019250505090565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600554815600a165627a7a7230582016a9e20718c283abcd114dd550f5242bddfb719468e5296c821d3caa1924e68d0029"
    cfg = EthereumCFG(bytecode_hex)

    # result
    number_instr = 1894
    number_func = 16
    number_basicblock = 128
    edges = 140

    # visualization
    # graph = CFGGraph(cfg)
    # graph.view_ssa()
    # graph.view_functions(simplify=True)
'''
if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(EthereumCfgTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/ETH/test_disassembler.py ---
import unittest

from octopus.platforms.ETH.disassembler import EthereumDisassembler

class EthereumDisassemblerTestCase(unittest.TestCase):

    def testDisassemble(self):
        def disassemble(bytecode_hex, result):
            disasm = len(EthereumDisassembler(bytecode_hex).disassemble())
            self.assertEqual(disasm, result)

        def disasmOne(bytecode, result):
            disasm = str(EthereumDisassembler(bytecode).disassemble_opcode(bytecode))
            self.assertEqual(disasm, result)

        def disasm(bytecode_hex, result):
            disasm = EthereumDisassembler(bytecode_hex).disassemble(r_format='text')
            self.assertEqual(disasm, result)

        def analysis(bytecode_hex):
            disasm = EthereumDisassembler(bytecode_hex)
            disasm.analysis()
            self.assertIsNotNone(disasm.bytecode)
            self.assertIsNotNone(disasm.swarm_hash)
            self.assertIsNotNone(disasm.constructor_args)

        # Basic
        # bytecode = b'\x60\x60\x60\x40\x52\x60\x02\x61\x01\x00'
        bytecode_hex = "0x60606040526002610100"
        result = 'PUSH1 0x60\nPUSH1 0x40\nMSTORE\nPUSH1 0x2\nPUSH2 0x100'

        disasmOne(b'\x60\x42', 'PUSH1 0x42')
        disasm(bytecode_hex, result)
        disassemble(bytecode_hex, 5)

        # Medium
        bytecode_hex = "60606040526000357c0100000000000000000000000000000000000000000000000000000000900480635fd8c7101461004f578063c0e317fb1461005e578063f8b2cb4f1461006d5761004d565b005b61005c6004805050610099565b005b61006b600480505061013e565b005b610083600480803590602001909190505061017d565b6040518082815260200191505060405180910390f35b3373ffffffffffffffffffffffffffffffffffffffff16611111600060005060003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054604051809050600060405180830381858888f19350505050151561010657610002565b6000600060005060003373ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819055505b565b34600060005060003373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828282505401925050819055505b565b6000600060005060008373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505490506101b6565b91905056"
        disassemble(bytecode_hex, 231)

        # Test with Bzzr hash
        bytecode_hex = "6060604052600436106053576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680635b34b966146058578063a87d942c14606a578063f5c5ad83146090575b600080fd5b3415606257600080fd5b606860a2565b005b3415607457600080fd5b607a60b4565b6040518082815260200191505060405180910390f35b3415609a57600080fd5b60a060bd565b005b60016000808282540192505081905550565b60008054905090565b600160008082825403925050819055505600a165627a7a72305820c0194d1dc371e7ac13c63726f951efc2bae97c6bedc18f225e5444010a20e0ea0029"
        disassemble(bytecode_hex, 134)

        # Medium 2
        bytecode_hex = "60606040526004361061006d576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680631b0ca26a146100725780635fd8c71014610087578063c0e317fb1461009c578063c6dd98e9146100a6578063f8b2cb4f146100bb575b600080fd5b341561007d57600080fd5b610085610108565b005b341561009257600080fd5b61009a6101cd565b005b6100a461028c565b005b34156100b157600080fd5b6100b96102da565b005b34156100c657600080fd5b6100f2600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190505061039e565b6040518082815260200191505060405180910390f35b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff168160405160006040518083038185876187965a03f19250505015156101ca57600080fd5b50565b3373ffffffffffffffffffffffffffffffffffffffff166000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205460405160006040518083038185876187965a03f192505050151561024657600080fd5b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550565b346000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550565b3373ffffffffffffffffffffffffffffffffffffffff166108fc6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549081150290604051600060405180830381858888f19350505050151561035857600080fd5b60008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490509190505600a165627a7a723058206c96ec820703e283140b2d7ca433b45ae2c81843758e0758913918dce06d26630029"
        disassemble(bytecode_hex, 430)

        # Ponzicoin
        bytecode_hex = "60606040526509184e72a000600355650246139ca800600455620186a060055573506a24fbcb8eda2ec7d757c943723cfb32a0682e600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550341561007f57600080fd5b62030d40600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555062030d40600260008282540192505081905550610f56806101096000396000f3006060604052600436106100db576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100e0578063095ea7b31461016e57806318160ddd146101c857806323b872dd146101f15780632e1a7d4d1461026a578063313ce567146102a55780634b750334146102d45780634d853ee5146102fd57806370a08231146103525780638620410b1461039f57806395d89b41146103c8578063a9059cbb14610456578063b60d4288146104b0578063dd62ed3e146104d2578063eac037b21461053e575b600080fd5b34156100eb57600080fd5b6100f3610567565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610133578082015181840152602081019050610118565b50505050905090810190601f1680156101605780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561017957600080fd5b6101ae600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919050506105a0565b604051808215151515815260200191505060405180910390f35b34156101d357600080fd5b6101db610692565b6040518082815260200191505060405180910390f35b34156101fc57600080fd5b610250600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610698565b604051808215151515815260200191505060405180910390f35b341561027557600080fd5b61028b600480803590602001909190505061098e565b604051808215151515815260200191505060405180910390f35b34156102b057600080fd5b6102b8610a8f565b604051808260ff1660ff16815260200191505060405180910390f35b34156102df57600080fd5b6102e7610a94565b6040518082815260200191505060405180910390f35b341561030857600080fd5b610310610a9a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561035d57600080fd5b610389600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610ac0565b6040518082815260200191505060405180910390f35b34156103aa57600080fd5b6103b2610b08565b6040518082815260200191505060405180910390f35b34156103d357600080fd5b6103db610b0e565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561041b578082015181840152602081019050610400565b50505050905090810190601f1680156104485780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561046157600080fd5b610496600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610b47565b604051808215151515815260200191505060405180910390f35b6104b8610d2a565b604051808215151515815260200191505060405180910390f35b34156104dd57600080fd5b610528600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610e9d565b6040518082815260200191505060405180910390f35b341561054957600080fd5b610551610f24565b6040518082815260200191505060405180910390f35b6040805190810160405280600981526020017f506f6e7a69436f696e000000000000000000000000000000000000000000000081525081565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60025481565b6000816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410158015610764575081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410155b80156107ed57506000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401115b1561098257816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550816000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050610987565b600090505b9392505050565b600080826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515610a845760045483029050826000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550826002600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610a7b57600080fd5b60019150610a89565b600091505b50919050565b600381565b60045481565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60035481565b6040805190810160405280600381526020017f534543000000000000000000000000000000000000000000000000000000000081525081565b6000816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410158015610c1457506000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401115b15610d1f57816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a360019050610d24565b600090505b92915050565b600080600060035434811515610d3c57fe5b049150600554821115610d4f5760055491505b60035482029050816000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167f9cb9c14f7bc76e3a89b796b091850526236115352a198b1e472f00e91376bbcb836040518082815260200191505060405180910390a281600260008282540192505081905550816005600082825403925050819055506000600554111515610e4957620186a0600581905550600260036000828254029250508190555060026004600082825402925050819055505b80341115610e94573373ffffffffffffffffffffffffffffffffffffffff166108fc8234039081150290604051600060405180830381858888f193505050501515610e9357600080fd5b5b60019250505090565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600554815600a165627a7a7230582016a9e20718c283abcd114dd550f5242bddfb719468e5296c821d3caa1924e68d0029"
        disassemble(bytecode_hex, 1894)

        # detect swarm hash + constructor args
        bytecode_hex = "0x608060405234801561001057600080fd5b50604051610e30380380610e308339810180604052810190808051906020019092919080518201929190602001805190602001909291908051820192919050505083600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508360008190555082600390805190602001906100b29291906100ee565b5081600460006101000a81548160ff021916908360ff16021790555080600590805190602001906100e49291906100ee565b5050505050610193565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061012f57805160ff191683800117855561015d565b8280016001018555821561015d579182015b8281111561015c578251825591602001919060010190610141565b5b50905061016a919061016e565b5090565b61019091905b8082111561018c576000816000905550600101610174565b5090565b90565b610c8e806101a26000396000f3006080604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b4578063095ea7b31461014457806318160ddd146101a957806323b872dd146101d457806327e235e314610259578063313ce567146102b05780635c658165146102e157806370a082311461035857806395d89b41146103af578063a9059cbb1461043f578063dd62ed3e146104a4575b600080fd5b3480156100c057600080fd5b506100c961051b565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101095780820151818401526020810190506100ee565b50505050905090810190601f1680156101365780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561015057600080fd5b5061018f600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506105b9565b604051808215151515815260200191505060405180910390f35b3480156101b557600080fd5b506101be6106ab565b6040518082815260200191505060405180910390f35b3480156101e057600080fd5b5061023f600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506106b1565b604051808215151515815260200191505060405180910390f35b34801561026557600080fd5b5061029a600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061094b565b6040518082815260200191505060405180910390f35b3480156102bc57600080fd5b506102c5610963565b604051808260ff1660ff16815260200191505060405180910390f35b3480156102ed57600080fd5b50610342600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610976565b6040518082815260200191505060405180910390f35b34801561036457600080fd5b50610399600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061099b565b6040518082815260200191505060405180910390f35b3480156103bb57600080fd5b506103c46109e4565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156104045780820151818401526020810190506103e9565b50505050905090810190601f1680156104315780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561044b57600080fd5b5061048a600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610a82565b604051808215151515815260200191505060405180910390f35b3480156104b057600080fd5b50610505600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610bdb565b6040518082815260200191505060405180910390f35b60038054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105b15780601f10610586576101008083540402835291602001916105b1565b820191906000526020600020905b81548152906001019060200180831161059457829003601f168201915b505050505081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60005481565b600080600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905082600160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101580156107825750828110155b151561078d57600080fd5b82600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254019250508190555082600160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8110156108da5782600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040518082815260200191505060405180910390a360019150509392505050565b60016020528060005260406000206000915090505481565b600460009054906101000a900460ff1681565b6002602052816000526040600020602052806000526040600020600091509150505481565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60058054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610a7a5780601f10610a4f57610100808354040283529160200191610a7a565b820191906000526020600020905b815481529060010190602001808311610a5d57829003601f168201915b505050505081565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610ad257600080fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a36001905092915050565b6000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050929150505600a165627a7a723058204ffe616f66a499e097aad3dfc7e2dc50fb967d4245e35fda7ff6e0edd8a43cd300290000000000000000000000000000000000000000000000000000000030479e800000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000008546865546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012474243e585a8e79083e59586e4b89ae993be0000000000000000000000000000"
        analysis(bytecode_hex)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(EthereumDisassemblerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/ETH/test_explorer.py ---
from octopus.platforms.ETH.explorer import EthereumInfuraExplorer

import unittest

class EthereumExplorerTestCase(unittest.TestCase):

    # please only used this key for octopus - Infura registration is FREE
    explorer = EthereumInfuraExplorer("bHuaQhX91nkQBac8Wtgj")

    '''TODO'''
    block_number = 5100196
    block_hash = '0x98a548cbd0cd385f46c9bf28c16bc36dc6ec27207617e236f527716e617ae91b'
    contract_address = '0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413'
    address = "0x956b6B7454884b734B29A8115F045a95179ea00C"
    tx_hash = '0x345303843c2f3041d12f0c5e6075fd294c2e2ca8cd9b4a9addca3f8caf4380ff'

    def testRPCCommand(self):

        #######################
        # HIGHT-LEVEL METHODS #
        #######################

        self.assertEqual(self.explorer.get_transaction(self.tx_hash), self.explorer.eth_getTransactionByHash(self.tx_hash))
        self.assertEqual(len(self.explorer.get_block_by_hash(self.block_hash)), 20)
        self.assertEqual(len(self.explorer.get_block_by_number(self.block_number)), 20)

        ####################
        # JSON-RPC METHODS #
        ####################

        self.assertEqual(type(self.explorer.web3_clientVersion()), str)
        self.assertEqual(type(self.explorer.web3_sha3('0x' + b'hello world'.hex())), str)
        self.assertEqual(type(self.explorer.net_version()), str)
        self.assertEqual(type(self.explorer.net_listening()), bool)
        self.assertEqual(type(self.explorer.net_peerCount()), int)
        self.assertEqual(type(self.explorer.eth_protocolVersion()), str)
        self.assertEqual(type(self.explorer.eth_syncing()), bool)
        self.assertEqual(type(self.explorer.eth_mining()), bool)
        self.assertEqual(type(self.explorer.eth_hashrate()), int)
        self.assertEqual(type(self.explorer.eth_gasPrice()), int)
        self.assertEqual(type(self.explorer.eth_accounts()), list)
        self.assertEqual(type(self.explorer.eth_blockNumber()), int)
        self.assertEqual(type(self.explorer.eth_getBalance(self.address)), int)
        self.assertEqual(type(self.explorer.eth_getStorageAt("0x295a70b2de5e3953354a6a8344e616ed314d7251", 0, "latest")), str)
        self.assertEqual(type(self.explorer.eth_getTransactionCount(self.address)), int)

        self.assertEqual(self.explorer.eth_getBlockTransactionCountByHash(self.block_hash), 69)
        self.assertEqual(self.explorer.eth_getBlockTransactionCountByNumber(self.block_number), 69)
        self.assertEqual(self.explorer.eth_getUncleCountByBlockHash(self.block_hash), 0)
        self.assertEqual(self.explorer.eth_getUncleCountByBlockNumber(self.block_number), 0)

        self.assertEqual(len(self.explorer.eth_getCode(self.contract_address)), 21678)
        self.assertEqual(len(self.explorer.eth_getBlockByHash(self.block_hash)), 20)
        self.assertEqual(len(self.explorer.eth_getBlockByNumber(self.block_number)), 20)

        self.assertEqual(len(self.explorer.eth_getTransactionByHash(self.tx_hash)), 14)
        self.assertEqual(len(self.explorer.eth_getTransactionByBlockNumberAndIndex(self.block_number, 1)), 14)

        self.assertEqual(len(self.explorer.eth_getTransactionReceipt('0xf02ffa405bae96e62a9e36fbd781362ca378ec62353d5e2bd0585868d3deaf61')), 12)
        # self.assertEqual(type(self.explorer.eth_newBlockFilter()), str)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(EthereumExplorerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/NEO/__init__.py ---

'''
'''--- octopus/tests/NEO/test_cfg.py ---

from octopus.analysis.graph import Graph, CFGGraph
from octopus.platforms.NEO.disassembler import NeoDisassembler
from octopus.platforms.NEO.cfg import NeoCFG
from octopus.platforms.NEO.cfg import (enum_blocks_edges,
                                       enum_func_static,
                                       assign_blocks_to_func)

import unittest

class NeoCfgTestCase(unittest.TestCase):

    # lock contract
    bytecode_hex = "56c56b6c766b00527ac46c766b51527ac46c766b52527ac4616168184e656f2e426c6f636b636861696e2e4765744865696768746168184e656f2e426c6f636b636861696e2e4765744865616465726c766b53527ac46c766b00c36c766b53c36168174e656f2e4865616465722e47657454696d657374616d70a06c766b54527ac46c766b54c3640e00006c766b55527ac4621a006c766b51c36c766b52c3617cac6c766b55527ac46203006c766b55c3616c7566"
    disasm = NeoDisassembler(bytecode_hex)
    instructions = disasm.disassemble()

    cfg = NeoCFG(bytecode_hex)

    # visualization
    # graph = CFGGraph(cfg)
    # graph.view()

    number_func = 1
    number_inst = 101
    number_basicblock = 4

    def testReverseInstructions(self):

        self.assertEqual(len(self.cfg.instructions), self.number_inst)

    def testEnumerateFunctions(self):

        self.assertEqual(len(self.cfg.functions), self.number_func)

    def testEnumerateBasicBlocks(self):

        self.assertEqual(self.number_basicblock, len(self.cfg.basicblocks))

    def testAssignBasicBlocksFunctions(self):
        # verify if every basicblock have been assign to a function
        all_bb = [func.basicblocks for func in self.cfg.functions]
        all_bb = sum(all_bb, [])
        self.assertEqual(len(all_bb), self.number_basicblock)
        self.assertEqual(len(all_bb), len(self.cfg.basicblocks))

class NeoCfgTestCaseMedium(NeoCfgTestCase):

    bytecode_hex = "0x5fc56b6c766b00527ac46c766b51527ac4610b4f7065726174696f6e3a206c766b00c37e61680f4e656f2e52756e74696d652e4c6f67616c766b00c30a43616c63756c61746f72876c766b52527ac46c766b52c3648300616c766b51c300c352c576006c766b51c351c3c476516c766b51c352c3c4617c6729e30f18a594e03b49bd70b4f62603cb5b4769476c766b53527ac452c576001143616c63756c61746f7220526573756c74c476516c766b53c3c46168124e656f2e52756e74696d652e4e6f74696679616c766b00c36c766b54527ac46254036c766b00c307426f6f6c65616e876c766b55527ac46c766b55c3646100616c766b51c300c36c766b56527ac452c576001a4f7065726174696f6e3a20426f6f6c65616e2056616c75653a20c476516c766b56c3c46168124e656f2e52756e74696d652e4e6f74696679616c766b51c300c36c766b54527ac462d9026c766b00c307496e7465676572876c766b57527ac46c766b57c3649100611470726f63657373696e6720496e74656765723a206c766b51c300c37e61680f4e656f2e52756e74696d652e4c6f67616c766b51c300c36c766b58527ac452c576001a4f7065726174696f6e3a20496e74656765722056616c75653a20c476516c766b58c3c46168124e656f2e52756e74696d652e4e6f74696679616c766b51c300c36c766b54527ac4622e026c766b00c309427974654172726179876316006c766b00c3095369676e617475726587620400516c766b59527ac46c766b59c3646800610b70726f63657373696e67206c766b00c37e61680f4e656f2e52756e74696d652e4c6f676152c576006c766b00c3c476516c766b51c300c361653302c46168124e656f2e52756e74696d652e4e6f74696679616c766b51c300c36c766b54527ac46293016c766b00c30748617368313630876327006c766b00c30748617368323536876316006c766b00c3095075626c69634b657987620400516c766b5a527ac46c766b5ac3643f006152c576006c766b00c3c476516c766b51c300c3c46168124e656f2e52756e74696d652e4e6f74696679616c766b51c300c36c766b54527ac46212016c766b00c3054172726179876c766b5b527ac46c766b5bc364bd00616c766b51c300c36c766b5c527ac452c576006c766b00c3c476516c766b5cc3c0c46168124e656f2e52756e74696d652e4e6f7469667961006c766b5d527ac4624f006153c576000a4172726179204974656dc476516c766b5dc3c476526c766b5cc36c766b5dc3c3c46168124e656f2e52756e74696d652e4e6f7469667961616c766b5dc351936c766b5d527ac46c766b5dc36c766b5cc3c09f6c766b5e527ac46c766b5ec3639cff6c766b5cc3c06c766b54527ac4623d0015556e68616e646c6564206f7065726174696f6e3a206c766b00c37e61680f4e656f2e52756e74696d652e4c6f6761006c766b54527ac46203006c766b54c3616c756652c56b6c766b00527ac46c766b51527ac453c56b6c766b00527ac4616c766b00c36c766b51527ac46c766b51c36c766b52527ac46203006c766b52c3616c756653c56b6c766b00527ac461516c766b00c36a527a527ac46c766b51c36c766b52527ac46203006c766b52c3616c756655c56b6c766b00527ac461006c766b51527ac4006c766b52527ac4622c00616c766b51c36c766b00c36c766b52c3517f7e6c766b51527ac4616c766b52c351936c766b52527ac46c766b52c36c766b00c3c09f6c766b53527ac46c766b53c363bfff6c766b51c36c766b54527ac46203006c766b54c3616c7566"

    disasm = NeoDisassembler(bytecode_hex)
    instructions = disasm.disassemble()
    cfg = NeoCFG(bytecode_hex)

    # graph = CFGGraph(cfg)
    # graph.view_functions()

    number_func = 4
    number_inst = 825
    number_basicblock = 33

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(NeoCfgTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)
    suite = unittest.TestLoader().loadTestsFromTestCase(NeoCfgTestCaseMedium)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/NEO/test_disassembler.py ---
import unittest

from octopus.platforms.NEO.disassembler import NeoDisassembler

class NeoDisassemblerTestCase(unittest.TestCase):

    def testDisassemble(self):

        def disassemble(bytecode_hex, result):
            disasm = len(NeoDisassembler(bytecode_hex).disassemble())
            self.assertEqual(disasm, result)

        def disasmOne(bytecode, result):
            disasm = str(NeoDisassembler(bytecode).disassemble_opcode(bytecode))
            self.assertEqual(disasm, result)

        def disasm(bytecode, result):
            disasm = NeoDisassembler(bytecode_hex).disassemble(r_format='text')
            self.assertEqual(disasm, result)

        bytecode = b'Q\xc5kaah\x16Neo.Storage.GetContext\x06secret\x0bHello WorldaRrh\x0fNeo.Storage.Putaah\x16Neo.Storage.GetContext\x06secreta|h\x0fNeo.Storage.Getlvk\x00Rz\xc4b\x03\x00lvk\x00\xc3aluf'
        bytecode_hex = "0x51c56b616168164e656f2e53746f726167652e476574436f6e74657874067365637265740b48656c6c6f20576f726c64615272680f4e656f2e53746f726167652e507574616168164e656f2e53746f726167652e476574436f6e7465787406736563726574617c680f4e656f2e53746f726167652e4765746c766b00527ac46203006c766b00c3616c7566"
        result = 'PUSH1\nNEWARRAY\nTOALTSTACK\nNOP\nNOP\nSYSCALL 0x4e656f2e53746f726167652e476574436f6e74657874\nPUSHBYTES6 0x736563726574\nPUSHBYTES11 0x48656c6c6f20576f726c64\nNOP\nPUSH2\nXSWAP\nSYSCALL 0x4e656f2e53746f726167652e507574\nNOP\nNOP\nSYSCALL 0x4e656f2e53746f726167652e476574436f6e74657874\nPUSHBYTES6 0x736563726574\nNOP\nSWAP\nSYSCALL 0x4e656f2e53746f726167652e476574\nFROMALTSTACK\nDUP\nTOALTSTACK\nPUSH0\nPUSH2\nROLL\nSETITEM\nJMP 0x300\nFROMALTSTACK\nDUP\nTOALTSTACK\nPUSH0\nPICKITEM\nNOP\nFROMALTSTACK\nDROP\nRET'

        bytecode_one_instr = b'h\x16Neo.Storage.GetContext'
        result_one_instr = 'SYSCALL 0x4e656f2e53746f726167652e476574436f6e74657874'

        disasmOne(bytecode_one_instr, result_one_instr)
        disasm(bytecode, result)
        disassemble(bytecode_hex, 36)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(NeoDisassembler)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/NEO/test_explorer.py ---
from octopus.platforms.NEO.explorer import NeoExplorerRPC

import unittest

class NeoExplorerTestCase(unittest.TestCase):

    explorer = NeoExplorerRPC()

    wallet_address = "AJBENSwajTzQtwyJFkiJSv7MAaaMc7DsRz"
    asset_id = "c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b"
    block_hash = "0x881da7e14680cd4a020aa503dc602a92a411ad3184b6b14789074c775fbe5b7b"
    block_number = 1917115
    contract_hash = "d3cce84d0800172d09c88ccad61130611bd047a4"
    tx_id = 'f4250dab094c38d8265acc15c366dc508d2e14bf5699e12d9df26577ed74d657'
    contract_hash2 = "ecc6b20d3ccac1ee9ef109af5a7cdb85706b1df9"

    def testRPCCommand(self):

        #######################
        # HIGHT-LEVEL METHODS #
        #######################

        self.assertEqual(len(self.explorer.get_transaction(self.tx_id, False)), 524)
        self.assertEqual(self.explorer.get_block_by_hash(self.block_hash)['index'], self.block_number)
        self.assertEqual(self.explorer.get_block_by_number(self.block_number)['hash'], self.block_hash)

        ####################
        # JSON-RPC METHODS #
        ####################

        self.assertEqual(len(self.explorer.getaccountstate(self.wallet_address)), 5)
        self.assertEqual(len(self.explorer.getassetstate(self.asset_id)), 12)
        self.assertEqual(len(self.explorer.getbestblockhash()), 66)
        self.assertEqual(self.explorer.getblock(self.block_hash)['index'], self.block_number)
        self.assertEqual(self.explorer.getblock(self.block_number)['hash'], self.block_hash)
        self.assertEqual(type(self.explorer.getblockcount()), int)
        self.assertEqual(self.explorer.getblockhash(self.block_number), self.block_hash)
        self.assertEqual(self.explorer.getblocksysfee(self.block_number), '206594')
        self.assertEqual(type(self.explorer.getconnectioncount()), int)
        self.assertEqual(len(self.explorer.getcontractstate(self.contract_hash)), 11)
        self.assertEqual(type(self.explorer.getrawmempool()), list)
        self.assertEqual(len(self.explorer.getrawtransaction(self.tx_id, False)), 524)
        self.assertEqual(type(self.explorer.invoke(self.contract_hash, [{"type": "String","value": "name"}])), dict)
        self.assertEqual(type(self.explorer.invokefunction(self.contract_hash2, "balanceOf", [{"type": "Hash160", "value": "bfc469dd56932409677278f6b7422f3e1f34481d"}])), dict)
        self.assertEqual(type(self.explorer.invokescript("00046e616d656711c4d1f4fba619f2628870d36e3a9773e874705b")), dict)
        self.assertEqual(self.explorer.validateaddress(self.wallet_address)['isvalid'], True)

        # Not tested
        '''
        dumpprivkey
        getapplicationlog
        getbalance
        getnewaddress
        getstorage
        gettxout
        getpeers
        getversion
        listaddress
        sendrawtransaction
        sendtoaddress
        sendmany
        '''

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(NeoExplorerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/WASM/__init__.py ---

'''
'''--- octopus/tests/WASM/test_cfg.py ---
import unittest
import os

from octopus.arch.wasm.cfg import WasmCFG

EXAMPLE_PATH = "/../../../examples/wasm/samples/"

class WasmCFGraphTestCase(unittest.TestCase):

    def testCallGraph(self):
        def callgraph(bytecode, result_nodes, length_edges, fname=False):
            cfg = WasmCFG(bytecode)
            nodes, edges = cfg.get_functions_call_edges(fname)
            # visualize
            # cfg.visualize_call_flow()
            self.assertEqual(nodes, result_nodes)
            self.assertEqual(len(edges), length_edges)

        def controlflowgraph(bytecode, len_func, len_blocks, len_edges):
            cfg = WasmCFG(bytecode)
            functions = cfg.functions
            basicblocks = cfg.basicblocks
            edges = cfg.edges
            # visualize
            # cfg.visualize_call_flow()
            self.assertEqual(len(functions), len_func)
            self.assertEqual(len(basicblocks), len_blocks)
            self.assertEqual(len(edges), len_edges)

        def read_file(file_name):
            with open(file_name, 'rb') as f:
                module_bytecode = f.read()
            return module_bytecode

        path = os.path.dirname(os.path.realpath(__file__)) + EXAMPLE_PATH
        # Helloworld
        module_bytecode = read_file(path + "helloworld.wasm")
        r_nodes = ['print(i32)', 'main()']
        r_nodes2 = ['print', 'main']
        callgraph(module_bytecode, r_nodes, 1, fname=True)
        callgraph(module_bytecode, r_nodes2, 1, fname=False)
        controlflowgraph(module_bytecode, 1, 1, 0)

        # fibonacci
        module_bytecode = read_file(path + "fib.wasm")
        r_nodes = ['i32 fib(i32)']
        r_nodes2 = ['fib']
        len_call_edges = 2
        callgraph(module_bytecode, r_nodes, len_call_edges, fname=True)
        callgraph(module_bytecode, r_nodes2, len_call_edges, fname=False)
        controlflowgraph(module_bytecode, 1, 3, 2)

        # fibonacci 2 with if-else
        module_bytecode = read_file(path + "fibc.wasm")
        r_nodes = ['i32 _fib(i32)', 'runPostSets()', '__post_instantiate()']
        r_nodes2 = ['_fib', 'runPostSets', '__post_instantiate']
        len_call_edges = 2
        callgraph(module_bytecode, r_nodes, len_call_edges, fname=True)
        callgraph(module_bytecode, r_nodes2, len_call_edges, fname=False)
        controlflowgraph(module_bytecode, 3, 10, 9)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(WasmCFGraphTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/WASM/test_disassembler.py ---
import unittest
import os

from octopus.arch.wasm.disassembler import WasmDisassembler

EXAMPLE_PATH = "/../../../examples/wasm/samples/"

class WasmDisassemblerTestCase(unittest.TestCase):

    def testDisassemble(self):
        def disassemble(bytecode, result):
            disasm = len(WasmDisassembler(bytecode).disassemble())
            self.assertEqual(disasm, result)

        def disasmOne(bytecode, result):
            disasm = str(WasmDisassembler(bytecode).disassemble_opcode(bytecode))
            self.assertEqual(disasm, result)

        def disasm(bytecode, result):
            text = WasmDisassembler(bytecode).disassemble(r_format='text')
            self.assertEqual(text, result)

        def disasmModule(bytecode, result_func, result_insn):
            funcs = WasmDisassembler().disassemble_module(bytecode)
            self.assertEqual(len(funcs), result_func)
            self.assertEqual(sum([len(i) for i in funcs]), result_insn)

        def read_file(file_name):
            with open(file_name, 'rb') as f:
                module_bytecode = f.read()
            return module_bytecode

        # Simple
        bytecode = bytearray([2, 127, 65, 24, 16, 28, 65, 0, 15, 11])
        result = 'block -1\ni32.const 24\ncall 28\ni32.const 0\nreturn\nend'

        disassemble(bytecode, 6)
        disasmOne(b'\x02\x7f', 'block -1')
        disasm(bytecode, result)

        # Helloworld
        bytecode_hex = "0061736d0100000001110460017f0060017e0060000060027e7e00021b0203656e76067072696e746e000103656e76067072696e7473000003030202030404017000000503010001071903066d656d6f7279020004696e69740002056170706c7900030a20020600411010010b17004120100120001000413010012001100041c00010010b0b3f050041040b04504000000041100b0d496e697420576f726c64210a000041200b0e48656c6c6f20576f726c643a20000041300b032d3e000041c0000b020a000029046e616d6504067072696e746e0100067072696e7473010004696e697400056170706c790201300131"
        disasmModule(bytecode_hex, 2, 14)

        path = os.path.dirname(os.path.realpath(__file__)) + EXAMPLE_PATH

        # Helloworld - 2
        module_bytecode = read_file(path + "helloworld.wasm")
        disasmModule(module_bytecode, 1, 3)

        # fibonacci
        module_bytecode = read_file(path + "fib.wasm")
        disasmModule(module_bytecode, 1, 20)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(WasmDisassemblerTestCase)
    unittest.TextTestRunner(verbosity=2).run(suite)

'''
'''--- octopus/tests/__init__.py ---

'''
'''--- octopus/tests/btc_run_tests.sh ---
echo '[*] BTC Disassembler [*]'
python3 -m unittest BTC/test_disassembler.py
'''
'''--- octopus/tests/eos_run_tests.sh ---
echo '[*] EOS Disassembler [*]'
python3 -m unittest EOS/test_disassembler.py
echo '[*] EOS CallGraph analysis [*]'
python3 -m unittest EOS/test_callgraph.py
'''
'''--- octopus/tests/eth_run_tests.sh ---
# echo '[*] ETH Explorer [*]'
# python3 -m unittest octopus/tests/ETH/test_explorer.py
echo '[*] ETH Disassembler [*]'
python3 -m unittest ETH/test_disassembler.py
echo '[*] ETH ControlFlowGraph analysis [*]'
python3 -m unittest ETH/test_cfg.py
'''
'''--- octopus/tests/neo_run_tests.sh ---
echo '[*] NEO Disassembler [*]'
python3 -m unittest NEO/test_disassembler.py
echo '[*] NEO ControlFlowGraph analysis [*]'
python3 -m unittest NEO/test_cfg.py
'''
'''--- octopus/tests/wasm_run_tests.sh ---
echo '[*] WebAssembly Disassembler [*]'
python3 -m unittest WASM/test_disassembler.py
echo '[*] WebAssembly ControlFlowGraph & CallGraph analysis [*]'
python3 -m unittest WASM/test_cfg.py
'''
'''--- octopus_eth_evm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys

from logging import getLogger
logging = getLogger(__name__)

PLATFORM = 'eth-evm'

def error_print(msg):
    print('[X] %s for %s' % (msg, PLATFORM))
    sys.exit()

def main() -> None:
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-r', '--raw',
                        help='hex-encoded bytecode string ("ABcdeF09..." or "0xABcdeF09...")',
                        metavar='BYTECODE')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('r'),
                        help='file containing hex-encoded bytecode string',
                        metavar='BYTECODEFILE')
    inputs.add_argument('-a', '--address',
                        help='pull contract from the blockchain',
                        metavar='CONTRACT_ADDRESS')

    features = parser.add_argument_group('Features')
    features.add_argument('-e', '--explore',
                          action='store_true',
                          help='client to retrieve information from blockchains')
    features.add_argument('-d', '--disassemble',
                          action='store_true',
                          help='print text disassembly ')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG)')
    features.add_argument('-c', '--call',
                          action='store_true',
                          help='generate the call flow graph')
    features.add_argument('-s', '--ssa',
                          action='store_true',
                          help='generate the CFG with SSA representation')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--onlystatic', action='store_true',
                       help='generate the CFG without stack emulation (fastest but less accurate)')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunction', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')
    #graph.add_argument('--visualize',
    #                   help='direcly open the CFG file')
    #graph.add_argument('--format',
    #                   choices=['pdf', 'png', 'dot'],
    #                   default='pdf',
    #                   help='direcly open the CFG file')

    explorer = parser.add_argument_group('Explorer options')
    explorer.add_argument('--code',
                          help='get contract code',
                          metavar='CONTRACT_ADDRESS')
    explorer.add_argument('--tx',
                          help='get transaction information')
    #explorer.add_argument('--txdecode', action='store_true',
    #                      help='return important transaction information')
    explorer.add_argument('--blockid', type=int,
                          help='get block information using given block number',
                          metavar='BLOCK_NUMBER')
    explorer.add_argument('--blockhash',
                          help='get block information using given block hash',
                          metavar='BLOCK_HASH')
    explorer.add_argument('--infura',
                          help='Infura network choice',
                          choices=['mainnet', 'ropsten', 'infuranet', 'kovan', 'rinkeby'],
                          default='mainnet')
    explorer.add_argument('--rpc', help='custom RPC settings',
                          metavar='HOST:PORT')
    explorer.add_argument('--rpctls', action='store_false',
                          help='RPC connection over TLS')

    args = parser.parse_args()

    octo_bytecode = None
    octo_explorer = None
    octo_disasm = None
    octo_cfg = None

    # Explorer
    if args.explore or args.address:
        # user choose some explorer options
        if args.rpc:
            from octopus.platforms.ETH.explorer import EthereumExplorerRPC
            # parsing RPC HOST & PORT
            host, port = args.rpc.split(':')
            octo_explorer = EthereumExplorerRPC(host=host, port=port, tls=args.rpctls)
        else:
            from octopus.platforms.ETH.explorer import EthereumInfuraExplorer
            from octopus.platforms.ETH.explorer import (INFURA_MAINNET,
                                                        INFURA_ROPSTEN,
                                                        INFURA_INFURANET,
                                                        INFURA_KOVAN,
                                                        INFURA_RINKEBY)
            if args.infura == 'mainnet':
                network = INFURA_MAINNET
            if args.infura == 'ropsten':
                network = INFURA_ROPSTEN
            if args.infura == 'infuranet':
                network = INFURA_INFURANET
            if args.infura == 'kovan':
                network = INFURA_KOVAN
            if args.infura == 'rinkeby':
                network = INFURA_RINKEBY

            octo_explorer = EthereumInfuraExplorer(network=network)

        # process explorer related commands
        if args.code:
            print(octo_explorer.eth_getCode(args.code))
        elif args.tx:
            print(octo_explorer.get_transaction(args.tx))
        # elif args.txdecode:
        #    pass
        elif args.blockid:
            print(octo_explorer.get_block_by_number(args.blockid))
        elif args.blockhash:
            print(octo_explorer.get_block_by_hash(args.blockhash))

    # process input code
    if args.raw:
        octo_bytecode = args.raw
    elif args.file:
        octo_bytecode = ''.join([l.strip() for l in args.file if len(l.strip()) > 0])
    elif args.address:
        octo_bytecode = octo_explorer.eth_getCode(args.address)

    # Disassembly
    if args.disassemble:
        from octopus.platforms.ETH.disassembler import EthereumDisassembler

        # TODO add other r_format support
        octo_disasm = EthereumDisassembler()
        print(octo_disasm.disassemble(octo_bytecode, r_format='text'))

    # Control Flow Analysis
    if args.cfg or args.ssa:
        from octopus.platforms.ETH.cfg import EthereumCFG
        from octopus.analysis.graph import CFGGraph

        if args.onlystatic and not args.ssa:
            octo_cfg = EthereumCFG(octo_bytecode, evm_analysis='static')
        else:
            octo_cfg = EthereumCFG(octo_bytecode)

        octo_graph = CFGGraph(octo_cfg)

        if args.functions or args.onlyfunction:
            octo_graph.view_functions(only_func_name=args.onlyfunction,
                                      simplify=args.simplify,
                                      ssa=args.ssa)
        else:
            octo_graph.view(simplify=args.simplify, ssa=args.ssa)

    # Call Flow Analysis
    if args.call:
        error_print('Call Flow Analysis not yet supported')

    if not args.disassemble and not args.ssa \
            and not args.cfg and not args.call\
            and not args.explore:
        parser.print_help()

if __name__ == '__main__':
    main()

'''
'''--- octopus_wasm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys

from logging import getLogger
logging = getLogger(__name__)

PLATFORM = 'wasm'

def error_print(msg):
    print('[X] %s for %s' % (msg, PLATFORM))
    sys.exit()

def main() -> None:
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-r', '--raw',
                        help='hex-encoded bytecode string ("ABcdeF09..." or "0xABcdeF09...")',
                        metavar='BYTECODE')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('rb'),
                        help='binary file (.wasm)',
                        metavar='WASMMODULE')

    features = parser.add_argument_group('Features')
    features.add_argument('-d', '--disassemble',
                          action='store_true',
                          help='print text disassembly ')
    features.add_argument('-z', '--analyzer',
                          action='store_true',
                          help='print module information')
    features.add_argument('-y', '--analytic',
                          action='store_true',
                          help='print Functions instructions analytics')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG)')
    features.add_argument('-c', '--call',
                          action='store_true',
                          help='generate the call flow graph')
    features.add_argument('-s', '--ssa',
                          action='store_true',
                          help='generate the CFG with SSA representation')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunc', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')
    #graph.add_argument('--visualize',
    #                   help='direcly open the CFG file')
    #graph.add_argument('--format',
    #                   choices=['pdf', 'png', 'dot'],
    #                   default='pdf',
    #                   help='direcly open the CFG file')

    args = parser.parse_args()

    octo_bytecode = None
    octo_analyzer = None
    octo_disasm = None
    octo_cfg = None

    # process input code
    if args.raw:
        octo_bytecode = args.raw
    elif args.file:
        octo_bytecode = args.file.read()

    # Disassembly
    if args.disassemble:
        from octopus.arch.wasm.disassembler import WasmDisassembler

        # TODO add other r_format support
        octo_disasm = WasmDisassembler()
        print(octo_disasm.disassemble_module(octo_bytecode, r_format='text'))

    if args.analyzer:
        from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

        octo_analyzer = WasmModuleAnalyzer(octo_bytecode)
        print(octo_analyzer)

    # Control Flow Analysis & Call flow Analysis
    if args.cfg or args.call or args.analytic:
        from octopus.arch.wasm.cfg import WasmCFG
        from octopus.analysis.graph import CFGGraph

        octo_cfg = WasmCFG(octo_bytecode)

        if args.call:
            octo_cfg.visualize_call_flow()
        if args.analytic:
            octo_cfg.visualize_instrs_per_funcs()

        if args.cfg:
            octo_graph = CFGGraph(octo_cfg)
            if args.functions or args.onlyfunc:
                octo_graph.view_functions(only_func_name=args.onlyfunc,
                                          simplify=args.simplify,
                                          ssa=args.ssa)
            else:
                octo_graph.view(simplify=args.simplify, ssa=args.ssa)

    if args.ssa:
        from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine

        emul = WasmSSAEmulatorEngine(octo_bytecode)
        # run the emulator for SSA
        if args.onlyfunc:
            emul.emulate_functions(args.onlyfunc)
        # try to emulate main by default
        else:
            emul.emulate_functions()

        # visualization of the cfg with SSA
        emul.cfg.visualize(ssa=True)

    if not args.disassemble and not args.ssa \
            and not args.cfg and not args.call\
            and not args.analyzer and not args.analytic:
        parser.print_help()

if __name__ == '__main__':
    main()

'''
'''--- requirements.txt ---
# Explorer
requests>=2.18.4

# CFG graphical view
graphviz>=0.8.3

# bytecode analytics
matplotlib>=2.2.2
numpy>=1.15.0

# ETH
# ethereum>=2.3.0
z3-solver>=4.5

# WASM / EOS
wasm>=1.1

'''
'''--- run_explorer_tests.sh ---
echo '[*] ETH Explorer [*]'
python3 -m unittest octopus/tests/ETH/test_explorer.py

echo '[*] NEO Explorer [*]'
python3 -m unittest octopus/tests/NEO/test_explorer.py
'''
'''--- run_tests.sh ---
echo '[*] BTC Disassembler [*]'
python3 -m unittest octopus/tests/BTC/test_disassembler.py

echo '[*] NEO Disassembler [*]'
python3 -m unittest octopus/tests/NEO/test_disassembler.py
echo '[*] NEO ControlFlowGraph analysis [*]'
python3 -m unittest octopus/tests/NEO/test_cfg.py

# echo '[*] ETH Explorer [*]'
# python3 -m unittest octopus/tests/ETH/test_explorer.py
echo '[*] ETH Disassembler [*]'
python3 -m unittest octopus/tests/ETH/test_disassembler.py
echo '[*] ETH ControlFlowGraph analysis [*]'
python3 -m unittest octopus/tests/ETH/test_cfg.py

echo '[*] EOS Disassembler [*]'
python3 -m unittest octopus/tests/EOS/test_disassembler.py
echo '[*] EOS CallGraph analysis [*]'
python3 -m unittest octopus/tests/EOS/test_callgraph.py

echo '[*] WebAssembly Disassembler [*]'
python3 -m unittest octopus/tests/WASM/test_disassembler.py
echo '[*] WebAssembly ControlFlowGraph & CallGraph analysis [*]'
python3 -m unittest octopus/tests/WASM/test_cfg.py
'''
'''--- setup.py ---
from setuptools import setup, find_packages

with open("README.md", "r") as fh:
    long_description = fh.read()

setup(
    name="octopus",
    version="0.3.3",
    author="QuoScient",
    license='MIT',
    description="Security analysis framework for WebAssembly module (wasm) and Blockchain Smart Contract (BTC/ETH/EOS/NEO).",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/quoscient/octopus",
    keywords='disassembler security webassembly ethereum eos neo',
    packages=find_packages(),
    classifiers=(
        'Development Status :: 3 - Alpha',

        'Intended Audience :: Science/Research',
        'Topic :: Software Development :: Disassemblers',

        'License :: OSI Approved :: MIT License',

        'Programming Language :: Python :: 3.5',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
    ),

    install_requires=[
        'z3-solver>=4.5',
        'requests>=2.18.4',
        'graphviz>=0.8.3',
        'wasm>=1.1'
    ],

    python_requires='>=3.5',

    package_data={
        'octopus.arch.evm': ['*.json'],
        'octopus.arch.wasm.signatures': ['*.json']
    },

    entry_points={
        'console_scripts': [
            'octopus_eth_evm = octopus.octopus_eth_evm:main',
            'octopus_wasm = octopus.octopus_wasm:main',
        ],

    },
)

'''