*GitHub Repository "near/borsh-js"*

'''--- .build_scripts/prepare-package-json.js ---
const fs = require('fs');
const path = require('path');

const buildDir = './lib';
function createEsmModulePackageJson() {
    fs.readdir(buildDir, function (err, dirs) {
        if (err) {
            throw err;
        }
        dirs.forEach(function (dir) {
            if (dir === 'esm') {
                var packageJsonFile = path.join(buildDir, dir, '/package.json');
                if (!fs.existsSync(packageJsonFile)) {
                    fs.writeFile(
                        packageJsonFile,
                        new Uint8Array(Buffer.from('{"type": "module"}')),
                        function (err) {
                            if (err) {
                                throw err;
                            }
                        }
                    );
                }
            }
        });
    });
}

createEsmModulePackageJson();

'''
'''--- .eslintrc.yml ---
env:
  es6: true
  node: true
extends:
  - 'eslint:recommended'
parserOptions:
  ecmaVersion: 2018
rules:
  indent:
    - error
    - 4
  linebreak-style:
    - error
    - unix
  quotes:
    - error
    - single
  semi:
    - error
    - always
  no-console: 0

'''
'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/borsh.yml ---
name: Borsh Tests
on: [push]
jobs:
    unit-tests:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v2
            - uses: actions/setup-node@v2
              with:
                  node-version: '14'
            - run: yarn
            - run: yarn test
    build:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v2
            - uses: actions/setup-node@v2
              with:
                  node-version: '14'
            - run: yarn
            - run: yarn build
    eslint:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v2
            - uses: actions/setup-node@v2
              with:
                  node-version: '14'
            - run: yarn
            - run: yarn lint

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12

before_script:
  - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/master/install.sh | sudo bash"

script:
  - fossa init
  - fossa analyze --server-scan
  - fossa test

'''
'''--- LICENSE-MIT.txt ---
Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

'''
'''--- README.md ---
# Borsh JS

[![Project license](https://img.shields.io/badge/license-Apache2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Project license](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Discord](https://img.shields.io/discord/490367152054992913?label=discord)](https://discord.gg/Vyp7ETM)
[![Travis status](https://travis-ci.com/near/borsh.svg?branch=master)](https://travis-ci.com/near/borsh-js)
[![NPM version](https://img.shields.io/npm/v/borsh.svg?style=flat-square)](https://npmjs.com/borsh)
[![Size on NPM](https://img.shields.io/bundlephobia/minzip/borsh.svg?style=flat-square)](https://npmjs.com/borsh)

**Borsh JS** is an implementation of the [Borsh] binary serialization format for
JavaScript and TypeScript projects.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is meant to be used in security-critical projects as it prioritizes consistency,
safety, speed, and comes with a strict specification.

> [!TIP]
> We strongly recommend to use `borsh-js` alongside the amazing project [Borsher](https://github.com/nameskyteam/borsher), which we plan to merge in borsh.

## Examples

### (De)serializing a Value
```javascript
import * as borsh from 'borsh';

const encodedU16 = borsh.serialize('u16', 2);
const decodedU16 = borsh.deserialize('u16', encodedU16);

const encodedStr = borsh.serialize('string', 'testing');
const decodedStr = borsh.deserialize('string', encodedStr);
```

### (De)serializing an Object
```javascript
import * as borsh from 'borsh';

const value = {x: 255, y: BigInt(20), z: '123', arr: [1, 2, 3]};
const schema = { struct: { x: 'u8', y: 'u64', 'z': 'string', 'arr': { array: { type: 'u8' }}}};

const encoded = borsh.serialize(schema, value);
const decoded = borsh.deserialize(schema, encoded);
```

## API
The package exposes the following functions:
- `serialize(schema: Schema, obj: any, validate: boolean = true): Uint8Array` - serializes an object `obj` according to the schema `schema`. Setting `validate` to false will skip the validation of the `schema`.
- `deserialize(schema: Schema, buffer: Uint8Array, validate: boolean = true): any` - deserializes an object according to the schema `schema` from the buffer `buffer`. Setting `validate` to false will skip the validation of the `schema`.

## Schemas
Schemas are used to describe the structure of the data being serialized or deserialized. They are used to
validate the data and to determine the order of the fields in the serialized data.

> You can find examples of valid in the [test](./borsh-ts/test/utils.test.js) folder.

> [!TIP]
> We strongly recommend to use `borsh-js` alongside the amazing project [Borsher](https://github.com/nameskyteam/borsher), which we plan to merge in borsh.

### Basic Types
Basic types are described by a string. The following types are supported:
- `u8`, `u16`, `u32`, `u64`, `u128` - unsigned integers of 8, 16, 32, 64, and 128 bits respectively.
- `i8`, `i16`, `i32`, `i64`, `i128` - signed integers of 8, 16, 32, 64, and 128 bits respectively.
- `f32`, `f64` - IEEE 754 floating point numbers of 32 and 64 bits respectively.
- `bool` - boolean value.
- `string` - UTF-8 string.

### Arrays, Options, Maps, Sets, Enums, and Structs
More complex objects are described by a JSON object. The following types are supported:
- `{ array: { type: Schema, len?: number } }` - an array of objects of the same type. The type of the array elements is described by the `type` field. If the field `len` is present, the array is fixed-size and the length of the array is `len`. Otherwise, the array is dynamic-sized and the length of the array is serialized before the elements.
- `{ option: Schema }` - an optional object. The type of the object is described by the `type` field.
- `{ map: { key: Schema, value: Schema }}` - a map. The type of the keys and values are described by the `key` and `value` fields respectively.
- `{ set: Schema }` - a set. The type of the elements is described by the `type` field.
- `{ enum: [ { struct: { className1: structSchema1 } }, { struct: { className2: structSchema2 } }, ... ] }` - an enum. The variants of the enum are described by the `className1`, `className2`, etc. fields. The variants are structs.
- `{ struct: { field1: Schema1, field2: Schema2, ... } }` - a struct. The fields of the struct are described by the `field1`, `field2`, etc. fields.

### Type Mappings

| Javascript       | Borsh                             |
|------------------|-----------------------------------|
| `number`         | `u8` `u16` `u32` `i8` `i16` `i32` |
| `bigint`         | `u64` `u128` `i64` `i128`         |
| `number`         | `f32` `f64`                       |
| `number`         | `f32` `f64`                       |
| `boolean`        | `bool`                            |
| `string`         | UTF-8 string                      |
| `type[]`         | fixed-size byte array             |
| `type[]`         | dynamic sized array               |
| `object`         | enum                              |
| `Map`            | HashMap                           |
| `Set`            | HashSet                           |
| `null` or `type` | Option                            |

---

## Contributing

Install dependencies:
```bash
yarn install
```

Continuously build with:
```bash
yarn dev
```

Run tests:
```bash
yarn test
```

Run linter
```bash
yarn lint
```
## Publish

Prepare `dist` version by running:
```bash
yarn build
```

When publishing to npm use [np](https://github.com/sindresorhus/np).

# License
This repository is distributed under the terms of both the MIT license and the Apache License (Version 2.0).
See [LICENSE-MIT](LICENSE-MIT.txt) and [LICENSE-APACHE](LICENSE-APACHE) for details.

[Borsh]:          https://borsh.io

'''
'''--- borsh-ts/.eslintrc.yml ---
env:
  es6: true
  node: true
extends:
  - 'eslint:recommended'
  - 'plugin:@typescript-eslint/eslint-recommended'
  - 'plugin:@typescript-eslint/recommended'
parser: '@typescript-eslint/parser'
rules:
  no-inner-declarations: 1
  '@typescript-eslint/no-explicit-any': 1
  '@typescript-eslint/ban-types': 1
  '@typescript-eslint/explicit-function-return-type': 1

parserOptions:
  ecmaVersion: 2018
  sourceType: module
'''
'''--- borsh-ts/buffer.ts ---
import { IntegerType } from './types.js';

export class EncodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;

    constructor() {
        this.offset = 0;
        this.buffer_size = 256;
        this.buffer = new ArrayBuffer(this.buffer_size);
        this.view = new DataView(this.buffer);
    }

    resize_if_necessary(needed_space: number): void {
        if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);

            const new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));

            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
        }
    }

    get_used_buffer(): Uint8Array {
        return new Uint8Array(this.buffer).slice(0, this.offset);
    }

    store_value(value: number, type: IntegerType): void {
        const bSize = type.substring(1);
        const size = parseInt(bSize) / 8;
        this.resize_if_necessary(size);

        const toCall = type[0] === 'f'? `setFloat${bSize}`: type[0] === 'i'? `setInt${bSize}` : `setUint${bSize}`;
        this.view[toCall](this.offset, value, true);
        this.offset += size;
    }

    store_bytes(from: Uint8Array): void {
        this.resize_if_necessary(from.length);
        new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
        this.offset += from.length;
    }
}

export class DecodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;

    constructor(buf: Uint8Array) {
        this.offset = 0;
        this.buffer_size = buf.length;
        this.buffer = new ArrayBuffer(buf.length);
        new Uint8Array(this.buffer).set(buf);
        this.view = new DataView(this.buffer);
    }

    assert_enough_buffer(size: number): void {
        if (this.offset + size > this.buffer.byteLength) {
            throw new Error('Error in schema, the buffer is smaller than expected');
        }
    }

    consume_value(type: IntegerType): number {
        const bSize = type.substring(1);
        const size = parseInt(bSize) / 8;
        this.assert_enough_buffer(size);

        const toCall = type[0] === 'f'? `getFloat${bSize}`: type[0] === 'i'? `getInt${bSize}` : `getUint${bSize}`;
        const ret = this.view[toCall](this.offset, true);

        this.offset += size;
        return ret;
    }

    consume_bytes(size: number): ArrayBuffer {
        this.assert_enough_buffer(size);
        const ret = this.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return ret;
    }
}
'''
'''--- borsh-ts/deserialize.ts ---
import { ArrayType, DecodeTypes, MapType, IntegerType, OptionType, Schema, SetType, StructType, integers, EnumType } from './types.js';
import { DecodeBuffer } from './buffer.js';

export class BorshDeserializer {
    buffer: DecodeBuffer;

    constructor(bufferArray: Uint8Array) {
        this.buffer = new DecodeBuffer(bufferArray);
    }

    decode(schema: Schema): DecodeTypes {
        return this.decode_value(schema);
    }

    decode_value(schema: Schema): DecodeTypes {
        if (typeof schema === 'string') {
            if (integers.includes(schema)) return this.decode_integer(schema);
            if (schema === 'string') return this.decode_string();
            if (schema === 'bool') return this.decode_boolean();
        }

        if (typeof schema === 'object') {
            if ('option' in schema) return this.decode_option(schema as OptionType);
            if ('enum' in schema) return this.decode_enum(schema as EnumType);
            if ('array' in schema) return this.decode_array(schema as ArrayType);
            if ('set' in schema) return this.decode_set(schema as SetType);
            if ('map' in schema) return this.decode_map(schema as MapType);
            if ('struct' in schema) return this.decode_struct(schema as StructType);
        }

        throw new Error(`Unsupported type: ${schema}`);
    }

    decode_integer(schema: IntegerType): number | bigint {
        const size: number = parseInt(schema.substring(1));

        if (size <= 32 || schema == 'f64') {
            return this.buffer.consume_value(schema);
        }
        return this.decode_bigint(size, schema.startsWith('i'));
    }

    decode_bigint(size: number, signed = false): bigint {
        const buffer_len = size / 8;
        const buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
        const bits = buffer.reduceRight((r, x) => r + x.toString(16).padStart(2, '0'), '');

        if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt(`0x${bits}`));
        }
        return BigInt(`0x${bits}`);
    }

    decode_string(): string {
        const len: number = this.decode_integer('u32') as number;
        const buffer = new Uint8Array(this.buffer.consume_bytes(len));

        // decode utf-8 string without using TextDecoder
        // first get all bytes to single byte code points
        const codePoints = [];
        for (let i = 0; i < len; ++i) {
            const byte = buffer[i];
            if (byte < 0x80) {
                codePoints.push(byte);
            } else if (byte < 0xE0) {
                codePoints.push(((byte & 0x1F) << 6) | (buffer[++i] & 0x3F));
            } else if (byte < 0xF0) {
                codePoints.push(((byte & 0x0F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F));
            } else {
                const codePoint = ((byte & 0x07) << 18) | ((buffer[++i] & 0x3F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F);
                codePoints.push(codePoint);
            }
        }

        // then decode code points to utf-8
        return String.fromCodePoint(...codePoints);
    }

    decode_boolean(): boolean {
        return this.buffer.consume_value('u8') > 0;
    }

    decode_option(schema: OptionType): DecodeTypes {
        const option = this.buffer.consume_value('u8');
        if (option === 1) {
            return this.decode_value(schema.option);
        }
        if (option !== 0) {
            throw new Error(`Invalid option ${option}`);
        }
        return null;
    }

    decode_enum(schema: EnumType): DecodeTypes {
        const valueIndex = this.buffer.consume_value('u8');

        if (valueIndex > schema.enum.length) {
            throw new Error(`Enum option ${valueIndex} is not available`);
        }

        const struct = schema.enum[valueIndex].struct;
        const key = Object.keys(struct)[0];
        return { [key]: this.decode_value(struct[key]) };
    }

    decode_array(schema: ArrayType): Array<DecodeTypes> {
        const result = [];
        const len = schema.array.len ? schema.array.len : this.decode_integer('u32') as number;

        for (let i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
        }

        return result;
    }

    decode_set(schema: SetType): Set<DecodeTypes> {
        const len = this.decode_integer('u32') as number;
        const result = new Set<DecodeTypes>();
        for (let i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
        }
        return result;
    }

    decode_map(schema: MapType): Map<DecodeTypes, DecodeTypes> {
        const len = this.decode_integer('u32') as number;
        const result = new Map();
        for (let i = 0; i < len; ++i) {
            const key = this.decode_value(schema.map.key);
            const value = this.decode_value(schema.map.value);
            result.set(key, value);
        }
        return result;
    }

    decode_struct(schema: StructType): object {
        const result = {};
        for (const key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
        }
        return result;
    }
}
'''
'''--- borsh-ts/index.ts ---
import { Schema, DecodeTypes } from './types.js';
import { BorshSerializer } from './serialize.js';
import { BorshDeserializer } from './deserialize.js';
import * as utils from './utils.js';

export { Schema } from './types';

export function serialize(schema: Schema, value: unknown, validate = true): Uint8Array {
    if (validate) utils.validate_schema(schema);
    const serializer = new BorshSerializer(validate);
    return serializer.encode(value, schema);
}

export function deserialize(schema: Schema, buffer: Uint8Array, validate = true): DecodeTypes {
    if (validate) utils.validate_schema(schema);
    const deserializer = new BorshDeserializer(buffer);
    return deserializer.decode(schema);
}
'''
'''--- borsh-ts/serialize.ts ---
import { ArrayType, MapType, IntegerType, OptionType, Schema, SetType, StructType, integers, EnumType } from './types.js';
import { EncodeBuffer } from './buffer.js';
import * as utils from './utils.js';

export class BorshSerializer {
    encoded: EncodeBuffer;
    fieldPath: string[];
    checkTypes: boolean;

    constructor(checkTypes) {
        this.encoded = new EncodeBuffer();
        this.fieldPath = ['value'];
        this.checkTypes = checkTypes;
    }

    encode(value: unknown, schema: Schema): Uint8Array {
        this.encode_value(value, schema);
        return this.encoded.get_used_buffer();
    }

    encode_value(value: unknown, schema: Schema): void {
        if (typeof schema === 'string') {
            if (integers.includes(schema)) return this.encode_integer(value, schema);
            if (schema === 'string') return this.encode_string(value);
            if (schema === 'bool') return this.encode_boolean(value);
        }

        if (typeof schema === 'object') {
            if ('option' in schema) return this.encode_option(value, schema as OptionType);
            if ('enum' in schema) return this.encode_enum(value, schema as EnumType);
            if ('array' in schema) return this.encode_array(value, schema as ArrayType);
            if ('set' in schema) return this.encode_set(value, schema as SetType);
            if ('map' in schema) return this.encode_map(value, schema as MapType);
            if ('struct' in schema) return this.encode_struct(value, schema as StructType);
        }
    }

    encode_integer(value: unknown, schema: IntegerType): void {
        const size: number = parseInt(schema.substring(1));

        if (size <= 32 || schema == 'f64') {
            this.checkTypes && utils.expect_type(value, 'number', this.fieldPath);
            this.encoded.store_value(value as number, schema);
        } else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value as string), size);
        }
    }

    encode_bigint(value: bigint, size: number): void {
        const buffer_len = size / 8;
        const buffer = new Uint8Array(buffer_len);

        for (let i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(0xff));
            value = value >> BigInt(8);
        }

        this.encoded.store_bytes(new Uint8Array(buffer));
    }

    encode_string(value: unknown): void {
        this.checkTypes && utils.expect_type(value, 'string', this.fieldPath);
        const _value = value as string;

        // encode to utf8 bytes without using TextEncoder
        const utf8Bytes: number[] = [];
        for (let i = 0; i < _value.length; i++) {
            let charCode = _value.charCodeAt(i);

            if (charCode < 0x80) {
                utf8Bytes.push(charCode);
            } else if (charCode < 0x800) {
                utf8Bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));
            } else if (charCode < 0xd800 || charCode >= 0xe000) {
                utf8Bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            } else {
                i++;
                charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (_value.charCodeAt(i) & 0x3ff));
                utf8Bytes.push(
                    0xf0 | (charCode >> 18),
                    0x80 | ((charCode >> 12) & 0x3f),
                    0x80 | ((charCode >> 6) & 0x3f),
                    0x80 | (charCode & 0x3f),
                );
            }
        }

        // 4 bytes for length + string bytes
        this.encoded.store_value(utf8Bytes.length, 'u32');
        this.encoded.store_bytes(new Uint8Array(utf8Bytes));
    }

    encode_boolean(value: unknown): void {
        this.checkTypes && utils.expect_type(value, 'boolean', this.fieldPath);
        this.encoded.store_value(value as boolean ? 1 : 0, 'u8');
    }

    encode_option(value: unknown, schema: OptionType): void {
        if (value === null || value === undefined) {
            this.encoded.store_value(0, 'u8');
        } else {
            this.encoded.store_value(1, 'u8');
            this.encode_value(value, schema.option);
        }
    }

    encode_enum(value: unknown, schema: EnumType): void {
        this.checkTypes && utils.expect_enum(value, this.fieldPath);

        const valueKey = Object.keys(value)[0];

        for (let i = 0; i < schema.enum.length; i++) {
            const valueSchema = schema.enum[i] as StructType;

            if (valueKey === Object.keys(valueSchema.struct)[0]) {
                this.encoded.store_value(i, 'u8');
                return this.encode_struct(value, valueSchema as StructType);
            }
        }
        throw new Error(`Enum key (${valueKey}) not found in enum schema: ${JSON.stringify(schema)} at ${this.fieldPath.join('.')}`);
    }

    encode_array(value: unknown, schema: ArrayType): void {
        if (utils.isArrayLike(value)) return this.encode_arraylike(value as ArrayLike<unknown>, schema);
        if (value instanceof ArrayBuffer) return this.encode_buffer(value, schema);
        throw new Error(`Expected Array-like not ${typeof (value)}(${value}) at ${this.fieldPath.join('.')}`);
    }

    encode_arraylike(value: ArrayLike<unknown>, schema: ArrayType): void {
        if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
        } else {
            // 4 bytes for length
            this.encoded.store_value(value.length, 'u32');
        }

        // array values
        for (let i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
        }
    }

    encode_buffer(value: ArrayBuffer, schema: ArrayType): void {
        if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
        } else {
            // 4 bytes for length
            this.encoded.store_value(value.byteLength, 'u32');
        }

        // array values
        this.encoded.store_bytes(new Uint8Array(value));
    }

    encode_set(value: unknown, schema: SetType): void {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);

        const isSet = value instanceof Set;
        const values = isSet ? Array.from(value.values()) : Object.values(value);

        // 4 bytes for length
        this.encoded.store_value(values.length, 'u32');

        // set values
        for (const value of values) {
            this.encode_value(value, schema.set);
        }
    }

    encode_map(value: unknown, schema: MapType): void {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);

        const isMap = value instanceof Map;
        const keys = isMap ? Array.from(value.keys()) : Object.keys(value);

        // 4 bytes for length
        this.encoded.store_value(keys.length, 'u32');

        // store key/values
        for (const key of keys) {
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
        }
    }

    encode_struct(value: unknown, schema: StructType): void {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);

        for (const key of Object.keys(schema.struct)) {
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
        }
    }
}
'''
'''--- borsh-ts/test/(de)serialize.test.js ---
const borsh = require('../../lib/cjs/index');
const testStructures = require('./structures');
const BN = require('bn.js');

function check_encode(value, schema, expected) {
    const encoded = borsh.serialize(schema, value);
    expect(encoded).toEqual(Uint8Array.from(expected));
}

function check_decode(expected, schema, encoded) {
    const decoded = borsh.deserialize(schema, encoded);
    // console.log(decoded, expected); // visual inspection
    if (expected instanceof BN) return expect(BigInt(expected) === decoded).toBe(true);
    if (schema === 'f32') return expect(decoded).toBeCloseTo(expected);
    expect(decoded).toEqual(expected);
}

function check_roundtrip(value, schema, encoded) {
    check_encode(value, schema, encoded);
    check_decode(value, schema, encoded);
}

test('serialize integers', async () => {
    check_roundtrip(100, 'u8', [100]);
    check_roundtrip(258, 'u16', [2, 1]);
    check_roundtrip(102, 'u32', [102, 0, 0, 0]);
    check_roundtrip(new BN(103), 'u64', [103, 0, 0, 0, 0, 0, 0, 0]);
    check_roundtrip(104n, 'u128', [104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    check_roundtrip(-100, 'i8', [156]);
    check_roundtrip(-258, 'i16', [254, 254]);
    check_roundtrip(-102, 'i32', [154, 255, 255, 255]);
    check_roundtrip(new BN(-103n), 'i64', [153, 255, 255, 255, 255, 255, 255, 255]);
    check_roundtrip(-104n, 'i128', [152, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);
});

test('serialize booleans', async () => {
    check_roundtrip(true, 'bool', [1]);
    check_roundtrip(false, 'bool', [0]);
});

test('serialize strings', async () => {
    check_roundtrip('h"i', 'string', [3, 0, 0, 0, 104, 34, 105]);
    check_roundtrip('ChÃ©vere', 'string', [8, 0, 0, 0, 67, 104, 195, 169, 118, 101, 114, 101]);
    check_roundtrip('!Ç¬Ð‡Ð‰ÙŠà ºðŸ‘àª àµ§à¿„áˆ’á˜»á á¬…á¡à »', 'string', [43, 0, 0, 0, 33, 199, 172, 208, 135, 208, 137, 217, 138, 224, 160, 186, 240, 159, 145, 141, 224, 170, 160, 224, 181, 167, 224, 191, 132, 225, 136, 146, 225, 152, 187, 225, 143, 160, 225, 172, 133, 225, 161, 157, 224, 160, 187]);
    check_roundtrip('Ã³Ã±@â€¡ØØ« æ¼¢à ¶â­ðŸ”’ô€€€', 'string', [30, 0, 0, 0, 195, 179, 195, 177, 64, 226, 128, 161, 216, 143, 216, 171, 32, 230, 188, 162, 224, 160, 182, 226, 173, 144, 240, 159, 148, 146, 244, 128, 128, 128]);
    check_roundtrip('f Â© bar ðŒ† baz â˜ƒ qux', 'string', [25, 0, 0, 0, 102, 32, 194, 169, 32, 98, 97, 114, 32, 240, 157, 140, 134, 32, 98, 97, 122, 32, 226, 152, 131, 32, 113, 117, 120]);
});

test('serialize floats', async () => {
    check_roundtrip(7.23, 'f64', [236, 81, 184, 30, 133, 235, 28, 64]);
    check_roundtrip(7.23, 'f32', [41, 92, 231, 64]);
    check_roundtrip(10e2, 'f32', [0, 0, 122, 68]);
    check_roundtrip(10e2, 'f64', [0, 0, 0, 0, 0, 64, 143, 64]);
});

test('serialize arrays', async () => {
    check_roundtrip([true, false], { array: { type: 'bool' } }, [2, 0, 0, 0, 1, 0]);
    check_roundtrip([true, false], { array: { type: 'bool', len: 2 } }, [1, 0]);
    check_encode(new ArrayBuffer(2), { array: { type: 'u8' } }, [2, 0, 0, 0, 0, 0]);

    const buffer = new ArrayBuffer(2);
    new Uint8Array(buffer).set([1, 2]);
    check_encode(buffer, { array: { type: 'u8', len: 2 } }, [1, 2]);
});

test('serialize options', async () => {
    check_roundtrip(null, { option: 'u8' }, [0]);
    check_roundtrip(1, { option: 'u32' }, [1, 1, 0, 0, 0]);
});

test('serialize maps', async () => {
    check_roundtrip(new Map(), { map: { key: 'u8', value: 'u8' } }, [0, 0, 0, 0]);

    const map = new Map();
    map.set('testing', 1);
    check_roundtrip(map, { map: { key: 'string', value: 'u32' } }, [1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 1, 0, 0, 0]);

    check_encode({ 'a': 1, 'b': 2 }, { map: { key: 'string', value: 'u8' } }, [2, 0, 0, 0, 1, 0, 0, 0, 97, 1, 1, 0, 0, 0, 98, 2]);
});

test('serialize sets', async () => {
    check_roundtrip(new Set(), { set: 'u8' }, [0, 0, 0, 0]);
    check_roundtrip(new Set([1, 2]), { set: 'u8' }, [2, 0, 0, 0, 1, 2]);
});

test('serialize struct', async () => {
    check_roundtrip(testStructures.Numbers, testStructures.schemaNumbers, testStructures.encodedNumbers);
    check_roundtrip(testStructures.Options, testStructures.schemaOptions, testStructures.encodedOptions);
    check_roundtrip(testStructures.Nested, testStructures.schemaNested, testStructures.encodedNested);
    check_roundtrip(testStructures.Mixture, testStructures.schemaMixture, testStructures.encodedMixture);
    check_roundtrip(testStructures.BigStruct, testStructures.schemaBigStruct, testStructures.encodedBigStruct);
});

test('serialize enums', async () => {
    const MyEnumNumbers = { numbers: testStructures.Numbers };
    const MyEnumMixture = { mixture: testStructures.Mixture };

    const enumSchema = {
        enum: [{ struct: { numbers: testStructures.schemaNumbers } }, { struct: { mixture: testStructures.schemaMixture } }]
    };

    check_roundtrip(MyEnumNumbers, enumSchema, [0].concat(testStructures.encodedNumbers));
    check_roundtrip(MyEnumMixture, enumSchema, [1].concat(testStructures.encodedMixture));
});

test('(de)serialize follows the schema order', async () => {
    const schema = {
        struct: { a: 'u8', b: 'u8' }
    };

    const object = { b: 2, a: 1 };
    const encoded = [1, 2];

    check_encode(object, schema, encoded);
    check_decode({ a: 1, b: 2 }, schema, encoded);
});

test('errors on invalid values', async () => {
    const schema_array = { array: { type: 'u16' } };

    expect(() => check_encode(['a'], schema_array, [])).toThrow('Expected number not string(a) at value');
    expect(() => check_encode(3, 'string', [])).toThrow('Expected string not number(3) at value');
    expect(() => check_encode({ 'a': 1, 'b': '2' }, { struct: { a: 'u8', b: 'u8' } }, [])).toThrow('Expected number not string(2) at value.b');
    expect(() => check_encode({ 'a': { 'b': { 'c': 3 } } }, { struct: { a: { struct: { b: { struct: { c: 'string' } } } } } }, [])).toThrow('Expected string not number(3) at value.a.b.c');
});
'''
'''--- borsh-ts/test/.eslintrc.yml ---
extends: '../../.eslintrc.yml'
env:
  es6: true
  jest: true
  es2020: true
rules:
  no-inner-declarations: 1
  '@typescript-eslint/no-explicit-any': 1
  '@typescript-eslint/explicit-function-return-type': 0
  '@typescript-eslint/no-var-requires': 0

'''
'''--- borsh-ts/test/structures.js ---
// Complex number structure
const Numbers = {
    u8: 1,
    u16: 2,
    u32: 3,
    u64: 4n,
    u128: 5n,
    i8: -1,
    i16: -2,
    i32: -3,
    i64: -4n,
    f32: 6.0,
    f64: 7.1,
};

const schemaNumbers = {
    struct: {
        u8: 'u8', u16: 'u16', u32: 'u32', u64: 'u64', u128: 'u128', i8: 'i8',
        i16: 'i16', i32: 'i32', i64: 'i64', f32: 'f32', f64: 'f64'
    }
};

const encodedNumbers = [
    1, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 255, 254, 255, 253, 255, 255, 255, 252, 255, 255, 255,
    255, 255, 255, 255, 0, 0, 192, 64, 102, 102, 102, 102, 102, 102, 28, 64
];

// Options
const Options = {
    u32: 2,
    option: null,
    u8: 1,
};

const schemaOptions = {
    struct: {
        u32: { option: 'u32' }, option: { option: 'string' }, u8: { option: 'u8' }
    }
};

const encodedOptions = [1, 2, 0, 0, 0, 0, 1, 1];

// Nested structure
const Nested = {
    a: { sa: { n: 1 } },
    b: 2,
    c: 3,
};

const schemaNested = {
    struct: { a: { struct: { sa: { struct: { n: 'u8' } } } }, b: 'u16', c: 'u32' } 
};

const encodedNested = [1, 2, 0, 3, 0, 0, 0];

// Complex mixture of types
const Mixture = {
    foo: 321,
    bar: 123,
    u64Val: BigInt('4294967297'),
    i64Val: -64n,
    flag: true,
    baz: 'testing',
    uint8array: [240, 241],
    arr: [['testing'], ['testing']],
    u32Arr: [21, 11],
    i32Arr: [],
    u128Val: 128n,
    uint8arrays: [[240, 241], [240, 241]],
    u64Arr: [BigInt('10000000000'), 100000000000n],
};

const schemaMixture = {
    struct: {
        foo: 'u32',
        bar: 'i32',
        u64Val: 'u64',
        i64Val: 'i64',
        flag: 'bool',
        baz: 'string',
        uint8array: { array: { type: 'u8', len: 2 } },
        arr: { array: { type: { array: { type: 'string' } } } },
        u32Arr: { array: { type: 'u32' } },
        i32Arr: { array: { type: 'i32' } },
        u128Val: 'u128',
        uint8arrays: { array: { type: { array: { type: 'u8', len: 2 } } } },
        u64Arr: { array: { type: 'u64' } },
    }
};

const encodedMixture = [
    //      i32,          u32,                 u64val,
    65, 1, 0, 0, 123, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
    //                              i64val, B,
    192, 255, 255, 255, 255, 255, 255, 255, 1,
    //                                     string,  u8array,        
    7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 240, 241,
    // Array<Array<string>>
    2, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116,
    105, 110, 103, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103,
    //                            u32Arr,     i32Arr,
    2, 0, 0, 0, 21, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0,
    //                                          u128,
    128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    //           Array<Uint8Array>,
    2, 0, 0, 0, 240, 241, 240, 241,
    //                                                            u64Arr   
    2, 0, 0, 0, 0, 228, 11, 84, 2, 0, 0, 0, 0, 232, 118, 72, 23, 0, 0, 0
];

// A structure of big nums
const BigStruct = {
    u64: BigInt('18446744073709551615'),
    u128: BigInt('340282366920938463463374607431768211455'),
    arr: [...Array(254).keys()],
};

const schemaBigStruct = {
    struct: {
        u64: 'u64',
        u128: 'u128',
        arr: { array: { type: 'u8', len: 254 } }
    }
};

const encodedBigStruct = Array(24).fill(255).concat([...Array(254).keys()]);

// export module
module.exports = {
    Numbers, schemaNumbers, encodedNumbers, Options, schemaOptions,
    encodedOptions, Nested, schemaNested, encodedNested, Mixture,
    schemaMixture, encodedMixture, BigStruct, schemaBigStruct,
    encodedBigStruct
};
'''
'''--- borsh-ts/test/utils.test.js ---
const utils = require('../../lib/cjs/utils');

test('accept valid schemes', async () => {
    const array = { array: { type: 'u8' } };
    const arrayFixed = { array: { type: 'u8', len: 2 } };
    const set = { set: 'u8' };
    const map = { map: { key: 'u8', value: 'u8' } };
    const option = { option: 'u8' };
    const struct = { struct: { u8: 'u8' } };
    const enumeration = { enum: [{ struct: { irrational: 'f32' } }, { struct: { rational: { struct: { num: 'u8', den: 'u8' } } } }] };

    const valid = [
        array, arrayFixed, set, map, option, enumeration, struct,
        'u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32',
        'i64', 'i128', 'bool', 'string', 'f32', 'f64'
    ];

    for (const schema of valid) {
        expect(() => utils.validate_schema(schema)).not.toThrow();
    }
});

test('rejects invalid schemes', async () => {
    const array = { array: 'u8' };
    const arrayFixed = { array: { len: 2 } };
    const set = { set: { type: 'u8' } };
    const map = { map: { value: 'u8' } };
    const option = { option: null };
    const struct = { struct: arrayFixed };
    const enumeration = { enum: [ { struct: { num: 'u8', den: 'u8' } } ] };
    const noStruct = { u8: 'u8' };

    expect(() => utils.validate_schema(array)).toThrow('Invalid schema: "u8" expected { type, len? }');
    expect(() => utils.validate_schema(arrayFixed)).toThrow('Invalid schema: {"len":2} expected { type, len? }');
    expect(() => utils.validate_schema(set)).toThrow('Invalid schema: {"type":"u8"} expected option, enum, array, set, map, struct or u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, string');
    expect(() => utils.validate_schema(map)).toThrow('Invalid schema: {"value":"u8"} expected { key, value }');
    expect(() => utils.validate_schema(option)).toThrow('Invalid schema: null expected option, enum, array, set, map, struct or u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, string');
    expect(() => utils.validate_schema(enumeration)).toThrow('The "struct" in each enum must have a single key');
    expect(() => utils.validate_schema(struct)).toThrow('Invalid schema: {"len":2} expected option, enum, array, set, map, struct or u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, string');
    expect(() => utils.validate_schema(noStruct)).toThrow('Invalid schema: {"u8":"u8"} expected option, enum, array, set, map, struct or u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, string');
    expect(() => utils.validate_schema('u7')).toThrow('Invalid schema: "u7" expected option, enum, array, set, map, struct or u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, string');
    expect(() => utils.validate_schema(Array)).toThrow();
    expect(() => utils.validate_schema(Map)).toThrow();
});

'''
'''--- borsh-ts/types.ts ---
export const integers = ['u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32', 'i64', 'i128', 'f32', 'f64'];

export type IntegerType = typeof integers[number];
export type BoolType = 'bool';
export type StringType = 'string';

export type OptionType = { option: Schema };
export type ArrayType = { array: { type: Schema, len?: number } };
export type EnumType = { enum: Array<StructType> };
export type SetType = { set: Schema };
export type MapType = { map: { key: Schema, value: Schema } };
export type StructType = { struct: { [key: string]: Schema } };
export type Schema = IntegerType | BoolType | StringType | OptionType | ArrayType | EnumType | SetType | MapType | StructType;

// returned
export type DecodeTypes = number | bigint | string | boolean | Array<DecodeTypes> | EnumType | ArrayBuffer | Map<DecodeTypes, DecodeTypes> | Set<DecodeTypes> | object | null;

'''
'''--- borsh-ts/utils.ts ---
import { Schema, StructType, integers } from './types.js';

export function isArrayLike(value: unknown): boolean {
    // source: https://stackoverflow.com/questions/24048547/checking-if-an-object-is-array-like
    return (
        Array.isArray(value) ||
        (!!value &&
            typeof value === 'object' &&
            'length' in value &&
            typeof (value.length) === 'number' &&
            (value.length === 0 ||
                (value.length > 0 &&
                    (value.length - 1) in value)
            )
        )
    );
}

export function expect_type(value: unknown, type: string, fieldPath: string[]): void {
    if (typeof (value) !== type) {
        throw new Error(`Expected ${type} not ${typeof (value)}(${value}) at ${fieldPath.join('.')}`);
    }
}

export function expect_bigint(value: unknown, fieldPath: string[]): void {
    const basicType = ['number', 'string', 'bigint', 'boolean'].includes(typeof(value));
    const strObject = typeof (value) === 'object' && value !== null && 'toString' in value;
    if (!basicType && !strObject) {
        throw new Error(`Expected bigint, number, boolean or string not ${typeof (value)}(${value}) at ${fieldPath.join('.')}`);
    }
}

export function expect_same_size(length: number, expected: number, fieldPath: string[]): void {
    if (length !== expected) {
        throw new Error(`Array length ${length} does not match schema length ${expected} at ${fieldPath.join('.')}`);
    }
}

export function expect_enum(value: unknown, fieldPath: string[]): void {
    if(typeof (value) !== 'object' || value === null ) {
        throw new Error(`Expected object not ${typeof (value)}(${value}) at ${fieldPath.join('.')}`);
    }
}

// Validate Schema
const VALID_STRING_TYPES = integers.concat(['bool', 'string']);
const VALID_OBJECT_KEYS = ['option', 'enum', 'array', 'set', 'map', 'struct'];

export class ErrorSchema extends Error {
    constructor(schema: Schema, expected: string) {
        const message = `Invalid schema: ${JSON.stringify(schema)} expected ${expected}`;
        super(message);
    }
}

export function validate_schema(schema: Schema): void {
    if (typeof (schema) === 'string' && VALID_STRING_TYPES.includes(schema)) {
        return;
    }

    if (schema && typeof (schema) === 'object') {
        const keys = Object.keys(schema);

        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
            const key = keys[0];

            if (key === 'option') return validate_schema(schema[key]);
            if (key === 'enum') return validate_enum_schema(schema[key]);
            if (key === 'array') return validate_array_schema(schema[key]);
            if (key === 'set') return validate_schema(schema[key]);
            if (key === 'map') return validate_map_schema(schema[key]);
            if (key === 'struct') return validate_struct_schema(schema[key]);
        }
    }
    throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(', ') + ' or ' + VALID_STRING_TYPES.join(', '));
}

function validate_enum_schema(schema:  Array<StructType>): void {
    if (!Array.isArray(schema)) throw new ErrorSchema(schema, 'Array');

    for (const sch of schema) {
        if (typeof sch !== 'object' || !('struct' in sch)) {
            throw new Error('Missing "struct" key in enum schema');
        }

        if (typeof sch.struct !== 'object' || Object.keys(sch.struct).length !== 1) {
            throw new Error('The "struct" in each enum must have a single key');
        }

        validate_schema({struct: sch.struct});
    }
}

function validate_array_schema(schema: { type: Schema, len?: number }): void {
    if (typeof schema !== 'object') throw new ErrorSchema(schema, '{ type, len? }');

    if (schema.len && typeof schema.len !== 'number') {
        throw new Error(`Invalid schema: ${schema}`);
    }

    if ('type' in schema) return validate_schema(schema.type);

    throw new ErrorSchema(schema, '{ type, len? }');
}

function validate_map_schema(schema: { key: Schema, value: Schema }): void {
    if (typeof schema === 'object' && 'key' in schema && 'value' in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
    } else {
        throw new ErrorSchema(schema, '{ key, value }');
    }
}

function validate_struct_schema(schema: { [key: string]: Schema }): void {
    if (typeof schema !== 'object') throw new ErrorSchema(schema, 'object');

    for (const key in schema) {
        validate_schema(schema[key]);
    }
}
'''
'''--- examples/cjs/index.js ---
const borsh = require('borsh-js');

const encodedU16 = borsh.serialize('u16', 2);
const decodedU16 = borsh.deserialize('u16', encodedU16);
console.log(decodedU16);

const encodedStr = borsh.serialize('string', 'testing');
const decodedStr = borsh.deserialize('string', encodedStr);
console.log(decodedStr);

'''
'''--- examples/cjs/package.json ---
{
  "name": "cjs-example",
  "private": true,
  "version": "2.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "borsh-js": "file:../../"
  }
}
'''
'''--- examples/cjs/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2015" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    "module": "commonjs" /* Specify what module code is generated. */,
    "outDir": "./build" /* Specify an output folder for all emitted files. */,
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,
    "strict": true /* Enable all strict type-checking options. */,
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}
'''
'''--- examples/esm/index.js ---
import * as borsh from 'borsh-js';

const encodedU16 = borsh.serialize('u16', 2);
const decodedU16 = borsh.deserialize('u16', encodedU16);
console.log(decodedU16);

const encodedStr = borsh.serialize('u64', '100000000000000000');
const decodedStr = borsh.deserialize('u64', encodedStr);
console.log(decodedStr);
'''
'''--- examples/esm/package.json ---
{
  "name": "esm-example",
  "private": true,
  "version": "2.0.0",
  "description": "",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "borsh-js": "file:../../"
  }
}
'''
'''--- examples/esm/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2015" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    "module": "esnext" /* Specify what module code is generated. */,
    "outDir": "./build" /* Specify an output folder for all emitted files. */,
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,
    "strict": true /* Enable all strict type-checking options. */,
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}
'''
'''--- lib/cjs/buffer.d.ts ---
import { IntegerType } from './types.js';
export declare class EncodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor();
    resize_if_necessary(needed_space: number): void;
    get_used_buffer(): Uint8Array;
    store_value(value: number, type: IntegerType): void;
    store_bytes(from: Uint8Array): void;
}
export declare class DecodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor(buf: Uint8Array);
    assert_enough_buffer(size: number): void;
    consume_value(type: IntegerType): number;
    consume_bytes(size: number): ArrayBuffer;
}

'''
'''--- lib/cjs/buffer.js ---
"use strict";
exports.__esModule = true;
exports.DecodeBuffer = exports.EncodeBuffer = void 0;
var EncodeBuffer = /** @class */ (function () {
    function EncodeBuffer() {
        this.offset = 0;
        this.buffer_size = 256;
        this.buffer = new ArrayBuffer(this.buffer_size);
        this.view = new DataView(this.buffer);
    }
    EncodeBuffer.prototype.resize_if_necessary = function (needed_space) {
        if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
            var new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
        }
    };
    EncodeBuffer.prototype.get_used_buffer = function () {
        return new Uint8Array(this.buffer).slice(0, this.offset);
    };
    EncodeBuffer.prototype.store_value = function (value, type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.resize_if_necessary(size);
        var toCall = type[0] === 'f' ? "setFloat".concat(bSize) : type[0] === 'i' ? "setInt".concat(bSize) : "setUint".concat(bSize);
        this.view[toCall](this.offset, value, true);
        this.offset += size;
    };
    EncodeBuffer.prototype.store_bytes = function (from) {
        this.resize_if_necessary(from.length);
        new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
        this.offset += from.length;
    };
    return EncodeBuffer;
}());
exports.EncodeBuffer = EncodeBuffer;
var DecodeBuffer = /** @class */ (function () {
    function DecodeBuffer(buf) {
        this.offset = 0;
        this.buffer_size = buf.length;
        this.buffer = new ArrayBuffer(buf.length);
        new Uint8Array(this.buffer).set(buf);
        this.view = new DataView(this.buffer);
    }
    DecodeBuffer.prototype.assert_enough_buffer = function (size) {
        if (this.offset + size > this.buffer.byteLength) {
            throw new Error('Error in schema, the buffer is smaller than expected');
        }
    };
    DecodeBuffer.prototype.consume_value = function (type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.assert_enough_buffer(size);
        var toCall = type[0] === 'f' ? "getFloat".concat(bSize) : type[0] === 'i' ? "getInt".concat(bSize) : "getUint".concat(bSize);
        var ret = this.view[toCall](this.offset, true);
        this.offset += size;
        return ret;
    };
    DecodeBuffer.prototype.consume_bytes = function (size) {
        this.assert_enough_buffer(size);
        var ret = this.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return ret;
    };
    return DecodeBuffer;
}());
exports.DecodeBuffer = DecodeBuffer;

'''
'''--- lib/cjs/deserialize.d.ts ---
import { ArrayType, DecodeTypes, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { DecodeBuffer } from './buffer.js';
export declare class BorshDeserializer {
    buffer: DecodeBuffer;
    constructor(bufferArray: Uint8Array);
    decode(schema: Schema): DecodeTypes;
    decode_value(schema: Schema): DecodeTypes;
    decode_integer(schema: IntegerType): number | bigint;
    decode_bigint(size: number, signed?: boolean): bigint;
    decode_string(): string;
    decode_boolean(): boolean;
    decode_option(schema: OptionType): DecodeTypes;
    decode_enum(schema: EnumType): DecodeTypes;
    decode_array(schema: ArrayType): Array<DecodeTypes>;
    decode_set(schema: SetType): Set<DecodeTypes>;
    decode_map(schema: MapType): Map<DecodeTypes, DecodeTypes>;
    decode_struct(schema: StructType): object;
}

'''
'''--- lib/cjs/deserialize.js ---
"use strict";
exports.__esModule = true;
exports.BorshDeserializer = void 0;
var types_js_1 = require("./types.js");
var buffer_js_1 = require("./buffer.js");
var BorshDeserializer = /** @class */ (function () {
    function BorshDeserializer(bufferArray) {
        this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
    }
    BorshDeserializer.prototype.decode = function (schema) {
        return this.decode_value(schema);
    };
    BorshDeserializer.prototype.decode_value = function (schema) {
        if (typeof schema === 'string') {
            if (types_js_1.integers.includes(schema))
                return this.decode_integer(schema);
            if (schema === 'string')
                return this.decode_string();
            if (schema === 'bool')
                return this.decode_boolean();
        }
        if (typeof schema === 'object') {
            if ('option' in schema)
                return this.decode_option(schema);
            if ('enum' in schema)
                return this.decode_enum(schema);
            if ('array' in schema)
                return this.decode_array(schema);
            if ('set' in schema)
                return this.decode_set(schema);
            if ('map' in schema)
                return this.decode_map(schema);
            if ('struct' in schema)
                return this.decode_struct(schema);
        }
        throw new Error("Unsupported type: ".concat(schema));
    };
    BorshDeserializer.prototype.decode_integer = function (schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == 'f64') {
            return this.buffer.consume_value(schema);
        }
        return this.decode_bigint(size, schema.startsWith('i'));
    };
    BorshDeserializer.prototype.decode_bigint = function (size, signed) {
        if (signed === void 0) { signed = false; }
        var buffer_len = size / 8;
        var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
        var bits = buffer.reduceRight(function (r, x) { return r + x.toString(16).padStart(2, '0'); }, '');
        if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt("0x".concat(bits)));
        }
        return BigInt("0x".concat(bits));
    };
    BorshDeserializer.prototype.decode_string = function () {
        var len = this.decode_integer('u32');
        var buffer = new Uint8Array(this.buffer.consume_bytes(len));
        // decode utf-8 string without using TextDecoder
        // first get all bytes to single byte code points
        var codePoints = [];
        for (var i = 0; i < len; ++i) {
            var byte = buffer[i];
            if (byte < 0x80) {
                codePoints.push(byte);
            }
            else if (byte < 0xE0) {
                codePoints.push(((byte & 0x1F) << 6) | (buffer[++i] & 0x3F));
            }
            else if (byte < 0xF0) {
                codePoints.push(((byte & 0x0F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F));
            }
            else {
                var codePoint = ((byte & 0x07) << 18) | ((buffer[++i] & 0x3F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F);
                codePoints.push(codePoint);
            }
        }
        // then decode code points to utf-8
        return String.fromCodePoint.apply(String, codePoints);
    };
    BorshDeserializer.prototype.decode_boolean = function () {
        return this.buffer.consume_value('u8') > 0;
    };
    BorshDeserializer.prototype.decode_option = function (schema) {
        var option = this.buffer.consume_value('u8');
        if (option === 1) {
            return this.decode_value(schema.option);
        }
        if (option !== 0) {
            throw new Error("Invalid option ".concat(option));
        }
        return null;
    };
    BorshDeserializer.prototype.decode_enum = function (schema) {
        var _a;
        var valueIndex = this.buffer.consume_value('u8');
        if (valueIndex > schema["enum"].length) {
            throw new Error("Enum option ".concat(valueIndex, " is not available"));
        }
        var struct = schema["enum"][valueIndex].struct;
        var key = Object.keys(struct)[0];
        return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
    };
    BorshDeserializer.prototype.decode_array = function (schema) {
        var result = [];
        var len = schema.array.len ? schema.array.len : this.decode_integer('u32');
        for (var i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
        }
        return result;
    };
    BorshDeserializer.prototype.decode_set = function (schema) {
        var len = this.decode_integer('u32');
        var result = new Set();
        for (var i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
        }
        return result;
    };
    BorshDeserializer.prototype.decode_map = function (schema) {
        var len = this.decode_integer('u32');
        var result = new Map();
        for (var i = 0; i < len; ++i) {
            var key = this.decode_value(schema.map.key);
            var value = this.decode_value(schema.map.value);
            result.set(key, value);
        }
        return result;
    };
    BorshDeserializer.prototype.decode_struct = function (schema) {
        var result = {};
        for (var key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
        }
        return result;
    };
    return BorshDeserializer;
}());
exports.BorshDeserializer = BorshDeserializer;

'''
'''--- lib/cjs/index.d.ts ---
import { Schema, DecodeTypes } from './types.js';
export { Schema } from './types';
export declare function serialize(schema: Schema, value: unknown, validate?: boolean): Uint8Array;
export declare function deserialize(schema: Schema, buffer: Uint8Array, validate?: boolean): DecodeTypes;

'''
'''--- lib/cjs/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
exports.__esModule = true;
exports.deserialize = exports.serialize = void 0;
var serialize_js_1 = require("./serialize.js");
var deserialize_js_1 = require("./deserialize.js");
var utils = __importStar(require("./utils.js"));
function serialize(schema, value, validate) {
    if (validate === void 0) { validate = true; }
    if (validate)
        utils.validate_schema(schema);
    var serializer = new serialize_js_1.BorshSerializer(validate);
    return serializer.encode(value, schema);
}
exports.serialize = serialize;
function deserialize(schema, buffer, validate) {
    if (validate === void 0) { validate = true; }
    if (validate)
        utils.validate_schema(schema);
    var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
    return deserializer.decode(schema);
}
exports.deserialize = deserialize;

'''
'''--- lib/cjs/serialize.d.ts ---
import { ArrayType, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { EncodeBuffer } from './buffer.js';
export declare class BorshSerializer {
    encoded: EncodeBuffer;
    fieldPath: string[];
    checkTypes: boolean;
    constructor(checkTypes: any);
    encode(value: unknown, schema: Schema): Uint8Array;
    encode_value(value: unknown, schema: Schema): void;
    encode_integer(value: unknown, schema: IntegerType): void;
    encode_bigint(value: bigint, size: number): void;
    encode_string(value: unknown): void;
    encode_boolean(value: unknown): void;
    encode_option(value: unknown, schema: OptionType): void;
    encode_enum(value: unknown, schema: EnumType): void;
    encode_array(value: unknown, schema: ArrayType): void;
    encode_arraylike(value: ArrayLike<unknown>, schema: ArrayType): void;
    encode_buffer(value: ArrayBuffer, schema: ArrayType): void;
    encode_set(value: unknown, schema: SetType): void;
    encode_map(value: unknown, schema: MapType): void;
    encode_struct(value: unknown, schema: StructType): void;
}

'''
'''--- lib/cjs/serialize.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
exports.__esModule = true;
exports.BorshSerializer = void 0;
var types_js_1 = require("./types.js");
var buffer_js_1 = require("./buffer.js");
var utils = __importStar(require("./utils.js"));
var BorshSerializer = /** @class */ (function () {
    function BorshSerializer(checkTypes) {
        this.encoded = new buffer_js_1.EncodeBuffer();
        this.fieldPath = ['value'];
        this.checkTypes = checkTypes;
    }
    BorshSerializer.prototype.encode = function (value, schema) {
        this.encode_value(value, schema);
        return this.encoded.get_used_buffer();
    };
    BorshSerializer.prototype.encode_value = function (value, schema) {
        if (typeof schema === 'string') {
            if (types_js_1.integers.includes(schema))
                return this.encode_integer(value, schema);
            if (schema === 'string')
                return this.encode_string(value);
            if (schema === 'bool')
                return this.encode_boolean(value);
        }
        if (typeof schema === 'object') {
            if ('option' in schema)
                return this.encode_option(value, schema);
            if ('enum' in schema)
                return this.encode_enum(value, schema);
            if ('array' in schema)
                return this.encode_array(value, schema);
            if ('set' in schema)
                return this.encode_set(value, schema);
            if ('map' in schema)
                return this.encode_map(value, schema);
            if ('struct' in schema)
                return this.encode_struct(value, schema);
        }
    };
    BorshSerializer.prototype.encode_integer = function (value, schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == 'f64') {
            this.checkTypes && utils.expect_type(value, 'number', this.fieldPath);
            this.encoded.store_value(value, schema);
        }
        else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value), size);
        }
    };
    BorshSerializer.prototype.encode_bigint = function (value, size) {
        var buffer_len = size / 8;
        var buffer = new Uint8Array(buffer_len);
        for (var i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(0xff));
            value = value >> BigInt(8);
        }
        this.encoded.store_bytes(new Uint8Array(buffer));
    };
    BorshSerializer.prototype.encode_string = function (value) {
        this.checkTypes && utils.expect_type(value, 'string', this.fieldPath);
        var _value = value;
        // encode to utf8 bytes without using TextEncoder
        var utf8Bytes = [];
        for (var i = 0; i < _value.length; i++) {
            var charCode = _value.charCodeAt(i);
            if (charCode < 0x80) {
                utf8Bytes.push(charCode);
            }
            else if (charCode < 0x800) {
                utf8Bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));
            }
            else if (charCode < 0xd800 || charCode >= 0xe000) {
                utf8Bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
            else {
                i++;
                charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (_value.charCodeAt(i) & 0x3ff));
                utf8Bytes.push(0xf0 | (charCode >> 18), 0x80 | ((charCode >> 12) & 0x3f), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
        }
        // 4 bytes for length + string bytes
        this.encoded.store_value(utf8Bytes.length, 'u32');
        this.encoded.store_bytes(new Uint8Array(utf8Bytes));
    };
    BorshSerializer.prototype.encode_boolean = function (value) {
        this.checkTypes && utils.expect_type(value, 'boolean', this.fieldPath);
        this.encoded.store_value(value ? 1 : 0, 'u8');
    };
    BorshSerializer.prototype.encode_option = function (value, schema) {
        if (value === null || value === undefined) {
            this.encoded.store_value(0, 'u8');
        }
        else {
            this.encoded.store_value(1, 'u8');
            this.encode_value(value, schema.option);
        }
    };
    BorshSerializer.prototype.encode_enum = function (value, schema) {
        this.checkTypes && utils.expect_enum(value, this.fieldPath);
        var valueKey = Object.keys(value)[0];
        for (var i = 0; i < schema["enum"].length; i++) {
            var valueSchema = schema["enum"][i];
            if (valueKey === Object.keys(valueSchema.struct)[0]) {
                this.encoded.store_value(i, 'u8');
                return this.encode_struct(value, valueSchema);
            }
        }
        throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join('.')));
    };
    BorshSerializer.prototype.encode_array = function (value, schema) {
        if (utils.isArrayLike(value))
            return this.encode_arraylike(value, schema);
        if (value instanceof ArrayBuffer)
            return this.encode_buffer(value, schema);
        throw new Error("Expected Array-like not ".concat(typeof (value), "(").concat(value, ") at ").concat(this.fieldPath.join('.')));
    };
    BorshSerializer.prototype.encode_arraylike = function (value, schema) {
        if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
        }
        else {
            // 4 bytes for length
            this.encoded.store_value(value.length, 'u32');
        }
        // array values
        for (var i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
        }
    };
    BorshSerializer.prototype.encode_buffer = function (value, schema) {
        if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
        }
        else {
            // 4 bytes for length
            this.encoded.store_value(value.byteLength, 'u32');
        }
        // array values
        this.encoded.store_bytes(new Uint8Array(value));
    };
    BorshSerializer.prototype.encode_set = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        var isSet = value instanceof Set;
        var values = isSet ? Array.from(value.values()) : Object.values(value);
        // 4 bytes for length
        this.encoded.store_value(values.length, 'u32');
        // set values
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value_1 = values_1[_i];
            this.encode_value(value_1, schema.set);
        }
    };
    BorshSerializer.prototype.encode_map = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        var isMap = value instanceof Map;
        var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
        // 4 bytes for length
        this.encoded.store_value(keys.length, 'u32');
        // store key/values
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
        }
    };
    BorshSerializer.prototype.encode_struct = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
            var key = _a[_i];
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
        }
    };
    return BorshSerializer;
}());
exports.BorshSerializer = BorshSerializer;

'''
'''--- lib/cjs/types.d.ts ---
export declare const integers: string[];
export type IntegerType = typeof integers[number];
export type BoolType = 'bool';
export type StringType = 'string';
export type OptionType = {
    option: Schema;
};
export type ArrayType = {
    array: {
        type: Schema;
        len?: number;
    };
};
export type EnumType = {
    enum: Array<StructType>;
};
export type SetType = {
    set: Schema;
};
export type MapType = {
    map: {
        key: Schema;
        value: Schema;
    };
};
export type StructType = {
    struct: {
        [key: string]: Schema;
    };
};
export type Schema = IntegerType | BoolType | StringType | OptionType | ArrayType | EnumType | SetType | MapType | StructType;
export type DecodeTypes = number | bigint | string | boolean | Array<DecodeTypes> | EnumType | ArrayBuffer | Map<DecodeTypes, DecodeTypes> | Set<DecodeTypes> | object | null;

'''
'''--- lib/cjs/types.js ---
"use strict";
exports.__esModule = true;
exports.integers = void 0;
exports.integers = ['u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32', 'i64', 'i128', 'f32', 'f64'];

'''
'''--- lib/cjs/utils.d.ts ---
import { Schema } from './types.js';
export declare function isArrayLike(value: unknown): boolean;
export declare function expect_type(value: unknown, type: string, fieldPath: string[]): void;
export declare function expect_bigint(value: unknown, fieldPath: string[]): void;
export declare function expect_same_size(length: number, expected: number, fieldPath: string[]): void;
export declare function expect_enum(value: unknown, fieldPath: string[]): void;
export declare class ErrorSchema extends Error {
    constructor(schema: Schema, expected: string);
}
export declare function validate_schema(schema: Schema): void;

'''
'''--- lib/cjs/utils.js ---
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.validate_schema = exports.ErrorSchema = exports.expect_enum = exports.expect_same_size = exports.expect_bigint = exports.expect_type = exports.isArrayLike = void 0;
var types_js_1 = require("./types.js");
function isArrayLike(value) {
    // source: https://stackoverflow.com/questions/24048547/checking-if-an-object-is-array-like
    return (Array.isArray(value) ||
        (!!value &&
            typeof value === 'object' &&
            'length' in value &&
            typeof (value.length) === 'number' &&
            (value.length === 0 ||
                (value.length > 0 &&
                    (value.length - 1) in value))));
}
exports.isArrayLike = isArrayLike;
function expect_type(value, type, fieldPath) {
    if (typeof (value) !== type) {
        throw new Error("Expected ".concat(type, " not ").concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
exports.expect_type = expect_type;
function expect_bigint(value, fieldPath) {
    var basicType = ['number', 'string', 'bigint', 'boolean'].includes(typeof (value));
    var strObject = typeof (value) === 'object' && value !== null && 'toString' in value;
    if (!basicType && !strObject) {
        throw new Error("Expected bigint, number, boolean or string not ".concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
exports.expect_bigint = expect_bigint;
function expect_same_size(length, expected, fieldPath) {
    if (length !== expected) {
        throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join('.')));
    }
}
exports.expect_same_size = expect_same_size;
function expect_enum(value, fieldPath) {
    if (typeof (value) !== 'object' || value === null) {
        throw new Error("Expected object not ".concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
exports.expect_enum = expect_enum;
// Validate Schema
var VALID_STRING_TYPES = types_js_1.integers.concat(['bool', 'string']);
var VALID_OBJECT_KEYS = ['option', 'enum', 'array', 'set', 'map', 'struct'];
var ErrorSchema = /** @class */ (function (_super) {
    __extends(ErrorSchema, _super);
    function ErrorSchema(schema, expected) {
        var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
        return _super.call(this, message) || this;
    }
    return ErrorSchema;
}(Error));
exports.ErrorSchema = ErrorSchema;
function validate_schema(schema) {
    if (typeof (schema) === 'string' && VALID_STRING_TYPES.includes(schema)) {
        return;
    }
    if (schema && typeof (schema) === 'object') {
        var keys = Object.keys(schema);
        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
            var key = keys[0];
            if (key === 'option')
                return validate_schema(schema[key]);
            if (key === 'enum')
                return validate_enum_schema(schema[key]);
            if (key === 'array')
                return validate_array_schema(schema[key]);
            if (key === 'set')
                return validate_schema(schema[key]);
            if (key === 'map')
                return validate_map_schema(schema[key]);
            if (key === 'struct')
                return validate_struct_schema(schema[key]);
        }
    }
    throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(', ') + ' or ' + VALID_STRING_TYPES.join(', '));
}
exports.validate_schema = validate_schema;
function validate_enum_schema(schema) {
    if (!Array.isArray(schema))
        throw new ErrorSchema(schema, 'Array');
    for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
        var sch = schema_1[_i];
        if (typeof sch !== 'object' || !('struct' in sch)) {
            throw new Error('Missing "struct" key in enum schema');
        }
        if (typeof sch.struct !== 'object' || Object.keys(sch.struct).length !== 1) {
            throw new Error('The "struct" in each enum must have a single key');
        }
        validate_schema({ struct: sch.struct });
    }
}
function validate_array_schema(schema) {
    if (typeof schema !== 'object')
        throw new ErrorSchema(schema, '{ type, len? }');
    if (schema.len && typeof schema.len !== 'number') {
        throw new Error("Invalid schema: ".concat(schema));
    }
    if ('type' in schema)
        return validate_schema(schema.type);
    throw new ErrorSchema(schema, '{ type, len? }');
}
function validate_map_schema(schema) {
    if (typeof schema === 'object' && 'key' in schema && 'value' in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
    }
    else {
        throw new ErrorSchema(schema, '{ key, value }');
    }
}
function validate_struct_schema(schema) {
    if (typeof schema !== 'object')
        throw new ErrorSchema(schema, 'object');
    for (var key in schema) {
        validate_schema(schema[key]);
    }
}

'''
'''--- lib/esm/buffer.d.ts ---
import { IntegerType } from './types.js';
export declare class EncodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor();
    resize_if_necessary(needed_space: number): void;
    get_used_buffer(): Uint8Array;
    store_value(value: number, type: IntegerType): void;
    store_bytes(from: Uint8Array): void;
}
export declare class DecodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor(buf: Uint8Array);
    assert_enough_buffer(size: number): void;
    consume_value(type: IntegerType): number;
    consume_bytes(size: number): ArrayBuffer;
}

'''
'''--- lib/esm/buffer.js ---
var EncodeBuffer = /** @class */ (function () {
    function EncodeBuffer() {
        this.offset = 0;
        this.buffer_size = 256;
        this.buffer = new ArrayBuffer(this.buffer_size);
        this.view = new DataView(this.buffer);
    }
    EncodeBuffer.prototype.resize_if_necessary = function (needed_space) {
        if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
            var new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
        }
    };
    EncodeBuffer.prototype.get_used_buffer = function () {
        return new Uint8Array(this.buffer).slice(0, this.offset);
    };
    EncodeBuffer.prototype.store_value = function (value, type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.resize_if_necessary(size);
        var toCall = type[0] === 'f' ? "setFloat".concat(bSize) : type[0] === 'i' ? "setInt".concat(bSize) : "setUint".concat(bSize);
        this.view[toCall](this.offset, value, true);
        this.offset += size;
    };
    EncodeBuffer.prototype.store_bytes = function (from) {
        this.resize_if_necessary(from.length);
        new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
        this.offset += from.length;
    };
    return EncodeBuffer;
}());
export { EncodeBuffer };
var DecodeBuffer = /** @class */ (function () {
    function DecodeBuffer(buf) {
        this.offset = 0;
        this.buffer_size = buf.length;
        this.buffer = new ArrayBuffer(buf.length);
        new Uint8Array(this.buffer).set(buf);
        this.view = new DataView(this.buffer);
    }
    DecodeBuffer.prototype.assert_enough_buffer = function (size) {
        if (this.offset + size > this.buffer.byteLength) {
            throw new Error('Error in schema, the buffer is smaller than expected');
        }
    };
    DecodeBuffer.prototype.consume_value = function (type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.assert_enough_buffer(size);
        var toCall = type[0] === 'f' ? "getFloat".concat(bSize) : type[0] === 'i' ? "getInt".concat(bSize) : "getUint".concat(bSize);
        var ret = this.view[toCall](this.offset, true);
        this.offset += size;
        return ret;
    };
    DecodeBuffer.prototype.consume_bytes = function (size) {
        this.assert_enough_buffer(size);
        var ret = this.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return ret;
    };
    return DecodeBuffer;
}());
export { DecodeBuffer };

'''
'''--- lib/esm/deserialize.d.ts ---
import { ArrayType, DecodeTypes, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { DecodeBuffer } from './buffer.js';
export declare class BorshDeserializer {
    buffer: DecodeBuffer;
    constructor(bufferArray: Uint8Array);
    decode(schema: Schema): DecodeTypes;
    decode_value(schema: Schema): DecodeTypes;
    decode_integer(schema: IntegerType): number | bigint;
    decode_bigint(size: number, signed?: boolean): bigint;
    decode_string(): string;
    decode_boolean(): boolean;
    decode_option(schema: OptionType): DecodeTypes;
    decode_enum(schema: EnumType): DecodeTypes;
    decode_array(schema: ArrayType): Array<DecodeTypes>;
    decode_set(schema: SetType): Set<DecodeTypes>;
    decode_map(schema: MapType): Map<DecodeTypes, DecodeTypes>;
    decode_struct(schema: StructType): object;
}

'''
'''--- lib/esm/deserialize.js ---
import { integers } from './types.js';
import { DecodeBuffer } from './buffer.js';
var BorshDeserializer = /** @class */ (function () {
    function BorshDeserializer(bufferArray) {
        this.buffer = new DecodeBuffer(bufferArray);
    }
    BorshDeserializer.prototype.decode = function (schema) {
        return this.decode_value(schema);
    };
    BorshDeserializer.prototype.decode_value = function (schema) {
        if (typeof schema === 'string') {
            if (integers.includes(schema))
                return this.decode_integer(schema);
            if (schema === 'string')
                return this.decode_string();
            if (schema === 'bool')
                return this.decode_boolean();
        }
        if (typeof schema === 'object') {
            if ('option' in schema)
                return this.decode_option(schema);
            if ('enum' in schema)
                return this.decode_enum(schema);
            if ('array' in schema)
                return this.decode_array(schema);
            if ('set' in schema)
                return this.decode_set(schema);
            if ('map' in schema)
                return this.decode_map(schema);
            if ('struct' in schema)
                return this.decode_struct(schema);
        }
        throw new Error("Unsupported type: ".concat(schema));
    };
    BorshDeserializer.prototype.decode_integer = function (schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == 'f64') {
            return this.buffer.consume_value(schema);
        }
        return this.decode_bigint(size, schema.startsWith('i'));
    };
    BorshDeserializer.prototype.decode_bigint = function (size, signed) {
        if (signed === void 0) { signed = false; }
        var buffer_len = size / 8;
        var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
        var bits = buffer.reduceRight(function (r, x) { return r + x.toString(16).padStart(2, '0'); }, '');
        if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt("0x".concat(bits)));
        }
        return BigInt("0x".concat(bits));
    };
    BorshDeserializer.prototype.decode_string = function () {
        var len = this.decode_integer('u32');
        var buffer = new Uint8Array(this.buffer.consume_bytes(len));
        // decode utf-8 string without using TextDecoder
        // first get all bytes to single byte code points
        var codePoints = [];
        for (var i = 0; i < len; ++i) {
            var byte = buffer[i];
            if (byte < 0x80) {
                codePoints.push(byte);
            }
            else if (byte < 0xE0) {
                codePoints.push(((byte & 0x1F) << 6) | (buffer[++i] & 0x3F));
            }
            else if (byte < 0xF0) {
                codePoints.push(((byte & 0x0F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F));
            }
            else {
                var codePoint = ((byte & 0x07) << 18) | ((buffer[++i] & 0x3F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F);
                codePoints.push(codePoint);
            }
        }
        // then decode code points to utf-8
        return String.fromCodePoint.apply(String, codePoints);
    };
    BorshDeserializer.prototype.decode_boolean = function () {
        return this.buffer.consume_value('u8') > 0;
    };
    BorshDeserializer.prototype.decode_option = function (schema) {
        var option = this.buffer.consume_value('u8');
        if (option === 1) {
            return this.decode_value(schema.option);
        }
        if (option !== 0) {
            throw new Error("Invalid option ".concat(option));
        }
        return null;
    };
    BorshDeserializer.prototype.decode_enum = function (schema) {
        var _a;
        var valueIndex = this.buffer.consume_value('u8');
        if (valueIndex > schema["enum"].length) {
            throw new Error("Enum option ".concat(valueIndex, " is not available"));
        }
        var struct = schema["enum"][valueIndex].struct;
        var key = Object.keys(struct)[0];
        return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
    };
    BorshDeserializer.prototype.decode_array = function (schema) {
        var result = [];
        var len = schema.array.len ? schema.array.len : this.decode_integer('u32');
        for (var i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
        }
        return result;
    };
    BorshDeserializer.prototype.decode_set = function (schema) {
        var len = this.decode_integer('u32');
        var result = new Set();
        for (var i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
        }
        return result;
    };
    BorshDeserializer.prototype.decode_map = function (schema) {
        var len = this.decode_integer('u32');
        var result = new Map();
        for (var i = 0; i < len; ++i) {
            var key = this.decode_value(schema.map.key);
            var value = this.decode_value(schema.map.value);
            result.set(key, value);
        }
        return result;
    };
    BorshDeserializer.prototype.decode_struct = function (schema) {
        var result = {};
        for (var key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
        }
        return result;
    };
    return BorshDeserializer;
}());
export { BorshDeserializer };

'''
'''--- lib/esm/index.d.ts ---
import { Schema, DecodeTypes } from './types.js';
export { Schema } from './types';
export declare function serialize(schema: Schema, value: unknown, validate?: boolean): Uint8Array;
export declare function deserialize(schema: Schema, buffer: Uint8Array, validate?: boolean): DecodeTypes;

'''
'''--- lib/esm/index.js ---
import { BorshSerializer } from './serialize.js';
import { BorshDeserializer } from './deserialize.js';
import * as utils from './utils.js';
export function serialize(schema, value, validate) {
    if (validate === void 0) { validate = true; }
    if (validate)
        utils.validate_schema(schema);
    var serializer = new BorshSerializer(validate);
    return serializer.encode(value, schema);
}
export function deserialize(schema, buffer, validate) {
    if (validate === void 0) { validate = true; }
    if (validate)
        utils.validate_schema(schema);
    var deserializer = new BorshDeserializer(buffer);
    return deserializer.decode(schema);
}

'''
'''--- lib/esm/package.json ---
{"type": "module"}
'''
'''--- lib/esm/serialize.d.ts ---
import { ArrayType, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { EncodeBuffer } from './buffer.js';
export declare class BorshSerializer {
    encoded: EncodeBuffer;
    fieldPath: string[];
    checkTypes: boolean;
    constructor(checkTypes: any);
    encode(value: unknown, schema: Schema): Uint8Array;
    encode_value(value: unknown, schema: Schema): void;
    encode_integer(value: unknown, schema: IntegerType): void;
    encode_bigint(value: bigint, size: number): void;
    encode_string(value: unknown): void;
    encode_boolean(value: unknown): void;
    encode_option(value: unknown, schema: OptionType): void;
    encode_enum(value: unknown, schema: EnumType): void;
    encode_array(value: unknown, schema: ArrayType): void;
    encode_arraylike(value: ArrayLike<unknown>, schema: ArrayType): void;
    encode_buffer(value: ArrayBuffer, schema: ArrayType): void;
    encode_set(value: unknown, schema: SetType): void;
    encode_map(value: unknown, schema: MapType): void;
    encode_struct(value: unknown, schema: StructType): void;
}

'''
'''--- lib/esm/serialize.js ---
import { integers } from './types.js';
import { EncodeBuffer } from './buffer.js';
import * as utils from './utils.js';
var BorshSerializer = /** @class */ (function () {
    function BorshSerializer(checkTypes) {
        this.encoded = new EncodeBuffer();
        this.fieldPath = ['value'];
        this.checkTypes = checkTypes;
    }
    BorshSerializer.prototype.encode = function (value, schema) {
        this.encode_value(value, schema);
        return this.encoded.get_used_buffer();
    };
    BorshSerializer.prototype.encode_value = function (value, schema) {
        if (typeof schema === 'string') {
            if (integers.includes(schema))
                return this.encode_integer(value, schema);
            if (schema === 'string')
                return this.encode_string(value);
            if (schema === 'bool')
                return this.encode_boolean(value);
        }
        if (typeof schema === 'object') {
            if ('option' in schema)
                return this.encode_option(value, schema);
            if ('enum' in schema)
                return this.encode_enum(value, schema);
            if ('array' in schema)
                return this.encode_array(value, schema);
            if ('set' in schema)
                return this.encode_set(value, schema);
            if ('map' in schema)
                return this.encode_map(value, schema);
            if ('struct' in schema)
                return this.encode_struct(value, schema);
        }
    };
    BorshSerializer.prototype.encode_integer = function (value, schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == 'f64') {
            this.checkTypes && utils.expect_type(value, 'number', this.fieldPath);
            this.encoded.store_value(value, schema);
        }
        else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value), size);
        }
    };
    BorshSerializer.prototype.encode_bigint = function (value, size) {
        var buffer_len = size / 8;
        var buffer = new Uint8Array(buffer_len);
        for (var i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(0xff));
            value = value >> BigInt(8);
        }
        this.encoded.store_bytes(new Uint8Array(buffer));
    };
    BorshSerializer.prototype.encode_string = function (value) {
        this.checkTypes && utils.expect_type(value, 'string', this.fieldPath);
        var _value = value;
        // encode to utf8 bytes without using TextEncoder
        var utf8Bytes = [];
        for (var i = 0; i < _value.length; i++) {
            var charCode = _value.charCodeAt(i);
            if (charCode < 0x80) {
                utf8Bytes.push(charCode);
            }
            else if (charCode < 0x800) {
                utf8Bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));
            }
            else if (charCode < 0xd800 || charCode >= 0xe000) {
                utf8Bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
            else {
                i++;
                charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (_value.charCodeAt(i) & 0x3ff));
                utf8Bytes.push(0xf0 | (charCode >> 18), 0x80 | ((charCode >> 12) & 0x3f), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
        }
        // 4 bytes for length + string bytes
        this.encoded.store_value(utf8Bytes.length, 'u32');
        this.encoded.store_bytes(new Uint8Array(utf8Bytes));
    };
    BorshSerializer.prototype.encode_boolean = function (value) {
        this.checkTypes && utils.expect_type(value, 'boolean', this.fieldPath);
        this.encoded.store_value(value ? 1 : 0, 'u8');
    };
    BorshSerializer.prototype.encode_option = function (value, schema) {
        if (value === null || value === undefined) {
            this.encoded.store_value(0, 'u8');
        }
        else {
            this.encoded.store_value(1, 'u8');
            this.encode_value(value, schema.option);
        }
    };
    BorshSerializer.prototype.encode_enum = function (value, schema) {
        this.checkTypes && utils.expect_enum(value, this.fieldPath);
        var valueKey = Object.keys(value)[0];
        for (var i = 0; i < schema["enum"].length; i++) {
            var valueSchema = schema["enum"][i];
            if (valueKey === Object.keys(valueSchema.struct)[0]) {
                this.encoded.store_value(i, 'u8');
                return this.encode_struct(value, valueSchema);
            }
        }
        throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join('.')));
    };
    BorshSerializer.prototype.encode_array = function (value, schema) {
        if (utils.isArrayLike(value))
            return this.encode_arraylike(value, schema);
        if (value instanceof ArrayBuffer)
            return this.encode_buffer(value, schema);
        throw new Error("Expected Array-like not ".concat(typeof (value), "(").concat(value, ") at ").concat(this.fieldPath.join('.')));
    };
    BorshSerializer.prototype.encode_arraylike = function (value, schema) {
        if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
        }
        else {
            // 4 bytes for length
            this.encoded.store_value(value.length, 'u32');
        }
        // array values
        for (var i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
        }
    };
    BorshSerializer.prototype.encode_buffer = function (value, schema) {
        if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
        }
        else {
            // 4 bytes for length
            this.encoded.store_value(value.byteLength, 'u32');
        }
        // array values
        this.encoded.store_bytes(new Uint8Array(value));
    };
    BorshSerializer.prototype.encode_set = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        var isSet = value instanceof Set;
        var values = isSet ? Array.from(value.values()) : Object.values(value);
        // 4 bytes for length
        this.encoded.store_value(values.length, 'u32');
        // set values
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value_1 = values_1[_i];
            this.encode_value(value_1, schema.set);
        }
    };
    BorshSerializer.prototype.encode_map = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        var isMap = value instanceof Map;
        var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
        // 4 bytes for length
        this.encoded.store_value(keys.length, 'u32');
        // store key/values
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
        }
    };
    BorshSerializer.prototype.encode_struct = function (value, schema) {
        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);
        for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
            var key = _a[_i];
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
        }
    };
    return BorshSerializer;
}());
export { BorshSerializer };

'''
'''--- lib/esm/types.d.ts ---
export declare const integers: string[];
export type IntegerType = typeof integers[number];
export type BoolType = 'bool';
export type StringType = 'string';
export type OptionType = {
    option: Schema;
};
export type ArrayType = {
    array: {
        type: Schema;
        len?: number;
    };
};
export type EnumType = {
    enum: Array<StructType>;
};
export type SetType = {
    set: Schema;
};
export type MapType = {
    map: {
        key: Schema;
        value: Schema;
    };
};
export type StructType = {
    struct: {
        [key: string]: Schema;
    };
};
export type Schema = IntegerType | BoolType | StringType | OptionType | ArrayType | EnumType | SetType | MapType | StructType;
export type DecodeTypes = number | bigint | string | boolean | Array<DecodeTypes> | EnumType | ArrayBuffer | Map<DecodeTypes, DecodeTypes> | Set<DecodeTypes> | object | null;

'''
'''--- lib/esm/types.js ---
export var integers = ['u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32', 'i64', 'i128', 'f32', 'f64'];

'''
'''--- lib/esm/utils.d.ts ---
import { Schema } from './types.js';
export declare function isArrayLike(value: unknown): boolean;
export declare function expect_type(value: unknown, type: string, fieldPath: string[]): void;
export declare function expect_bigint(value: unknown, fieldPath: string[]): void;
export declare function expect_same_size(length: number, expected: number, fieldPath: string[]): void;
export declare function expect_enum(value: unknown, fieldPath: string[]): void;
export declare class ErrorSchema extends Error {
    constructor(schema: Schema, expected: string);
}
export declare function validate_schema(schema: Schema): void;

'''
'''--- lib/esm/utils.js ---
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { integers } from './types.js';
export function isArrayLike(value) {
    // source: https://stackoverflow.com/questions/24048547/checking-if-an-object-is-array-like
    return (Array.isArray(value) ||
        (!!value &&
            typeof value === 'object' &&
            'length' in value &&
            typeof (value.length) === 'number' &&
            (value.length === 0 ||
                (value.length > 0 &&
                    (value.length - 1) in value))));
}
export function expect_type(value, type, fieldPath) {
    if (typeof (value) !== type) {
        throw new Error("Expected ".concat(type, " not ").concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
export function expect_bigint(value, fieldPath) {
    var basicType = ['number', 'string', 'bigint', 'boolean'].includes(typeof (value));
    var strObject = typeof (value) === 'object' && value !== null && 'toString' in value;
    if (!basicType && !strObject) {
        throw new Error("Expected bigint, number, boolean or string not ".concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
export function expect_same_size(length, expected, fieldPath) {
    if (length !== expected) {
        throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join('.')));
    }
}
export function expect_enum(value, fieldPath) {
    if (typeof (value) !== 'object' || value === null) {
        throw new Error("Expected object not ".concat(typeof (value), "(").concat(value, ") at ").concat(fieldPath.join('.')));
    }
}
// Validate Schema
var VALID_STRING_TYPES = integers.concat(['bool', 'string']);
var VALID_OBJECT_KEYS = ['option', 'enum', 'array', 'set', 'map', 'struct'];
var ErrorSchema = /** @class */ (function (_super) {
    __extends(ErrorSchema, _super);
    function ErrorSchema(schema, expected) {
        var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
        return _super.call(this, message) || this;
    }
    return ErrorSchema;
}(Error));
export { ErrorSchema };
export function validate_schema(schema) {
    if (typeof (schema) === 'string' && VALID_STRING_TYPES.includes(schema)) {
        return;
    }
    if (schema && typeof (schema) === 'object') {
        var keys = Object.keys(schema);
        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
            var key = keys[0];
            if (key === 'option')
                return validate_schema(schema[key]);
            if (key === 'enum')
                return validate_enum_schema(schema[key]);
            if (key === 'array')
                return validate_array_schema(schema[key]);
            if (key === 'set')
                return validate_schema(schema[key]);
            if (key === 'map')
                return validate_map_schema(schema[key]);
            if (key === 'struct')
                return validate_struct_schema(schema[key]);
        }
    }
    throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(', ') + ' or ' + VALID_STRING_TYPES.join(', '));
}
function validate_enum_schema(schema) {
    if (!Array.isArray(schema))
        throw new ErrorSchema(schema, 'Array');
    for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
        var sch = schema_1[_i];
        if (typeof sch !== 'object' || !('struct' in sch)) {
            throw new Error('Missing "struct" key in enum schema');
        }
        if (typeof sch.struct !== 'object' || Object.keys(sch.struct).length !== 1) {
            throw new Error('The "struct" in each enum must have a single key');
        }
        validate_schema({ struct: sch.struct });
    }
}
function validate_array_schema(schema) {
    if (typeof schema !== 'object')
        throw new ErrorSchema(schema, '{ type, len? }');
    if (schema.len && typeof schema.len !== 'number') {
        throw new Error("Invalid schema: ".concat(schema));
    }
    if ('type' in schema)
        return validate_schema(schema.type);
    throw new ErrorSchema(schema, '{ type, len? }');
}
function validate_map_schema(schema) {
    if (typeof schema === 'object' && 'key' in schema && 'value' in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
    }
    else {
        throw new ErrorSchema(schema, '{ key, value }');
    }
}
function validate_struct_schema(schema) {
    if (typeof schema !== 'object')
        throw new ErrorSchema(schema, 'object');
    for (var key in schema) {
        validate_schema(schema[key]);
    }
}

'''
'''--- lib/types/buffer.d.ts ---
import { IntegerType } from './types.js';
export declare class EncodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor();
    resize_if_necessary(needed_space: number): void;
    get_used_buffer(): Uint8Array;
    store_value(value: number, type: IntegerType): void;
    store_bytes(from: Uint8Array): void;
}
export declare class DecodeBuffer {
    offset: number;
    buffer_size: number;
    buffer: ArrayBuffer;
    view: DataView;
    constructor(buf: Uint8Array);
    assert_enough_buffer(size: number): void;
    consume_value(type: IntegerType): number;
    consume_bytes(size: number): ArrayBuffer;
}

'''
'''--- lib/types/deserialize.d.ts ---
import { ArrayType, DecodeTypes, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { DecodeBuffer } from './buffer.js';
export declare class BorshDeserializer {
    buffer: DecodeBuffer;
    constructor(bufferArray: Uint8Array);
    decode(schema: Schema): DecodeTypes;
    decode_value(schema: Schema): DecodeTypes;
    decode_integer(schema: IntegerType): number | bigint;
    decode_bigint(size: number, signed?: boolean): bigint;
    decode_string(): string;
    decode_boolean(): boolean;
    decode_option(schema: OptionType): DecodeTypes;
    decode_enum(schema: EnumType): DecodeTypes;
    decode_array(schema: ArrayType): Array<DecodeTypes>;
    decode_set(schema: SetType): Set<DecodeTypes>;
    decode_map(schema: MapType): Map<DecodeTypes, DecodeTypes>;
    decode_struct(schema: StructType): object;
}

'''
'''--- lib/types/index.d.ts ---
import { Schema, DecodeTypes } from './types.js';
export { Schema } from './types';
export declare function serialize(schema: Schema, value: unknown, validate?: boolean): Uint8Array;
export declare function deserialize(schema: Schema, buffer: Uint8Array, validate?: boolean): DecodeTypes;

'''
'''--- lib/types/serialize.d.ts ---
import { ArrayType, MapType, IntegerType, OptionType, Schema, SetType, StructType, EnumType } from './types.js';
import { EncodeBuffer } from './buffer.js';
export declare class BorshSerializer {
    encoded: EncodeBuffer;
    fieldPath: string[];
    checkTypes: boolean;
    constructor(checkTypes: any);
    encode(value: unknown, schema: Schema): Uint8Array;
    encode_value(value: unknown, schema: Schema): void;
    encode_integer(value: unknown, schema: IntegerType): void;
    encode_bigint(value: bigint, size: number): void;
    encode_string(value: unknown): void;
    encode_boolean(value: unknown): void;
    encode_option(value: unknown, schema: OptionType): void;
    encode_enum(value: unknown, schema: EnumType): void;
    encode_array(value: unknown, schema: ArrayType): void;
    encode_arraylike(value: ArrayLike<unknown>, schema: ArrayType): void;
    encode_buffer(value: ArrayBuffer, schema: ArrayType): void;
    encode_set(value: unknown, schema: SetType): void;
    encode_map(value: unknown, schema: MapType): void;
    encode_struct(value: unknown, schema: StructType): void;
}

'''
'''--- lib/types/types.d.ts ---
export declare const integers: string[];
export type IntegerType = typeof integers[number];
export type BoolType = 'bool';
export type StringType = 'string';
export type OptionType = {
    option: Schema;
};
export type ArrayType = {
    array: {
        type: Schema;
        len?: number;
    };
};
export type EnumType = {
    enum: Array<StructType>;
};
export type SetType = {
    set: Schema;
};
export type MapType = {
    map: {
        key: Schema;
        value: Schema;
    };
};
export type StructType = {
    struct: {
        [key: string]: Schema;
    };
};
export type Schema = IntegerType | BoolType | StringType | OptionType | ArrayType | EnumType | SetType | MapType | StructType;
export type DecodeTypes = number | bigint | string | boolean | Array<DecodeTypes> | EnumType | ArrayBuffer | Map<DecodeTypes, DecodeTypes> | Set<DecodeTypes> | object | null;

'''
'''--- lib/types/utils.d.ts ---
import { Schema } from './types.js';
export declare function isArrayLike(value: unknown): boolean;
export declare function expect_type(value: unknown, type: string, fieldPath: string[]): void;
export declare function expect_bigint(value: unknown, fieldPath: string[]): void;
export declare function expect_same_size(length: number, expected: number, fieldPath: string[]): void;
export declare function expect_enum(value: unknown, fieldPath: string[]): void;
export declare class ErrorSchema extends Error {
    constructor(schema: Schema, expected: string);
}
export declare function validate_schema(schema: Schema): void;

'''
'''--- package.json ---
{
  "name": "borsh",
  "version": "2.0.0",
  "description": "Binary Object Representation Serializer for Hashing",
  "main": "./lib/cjs/index.js",
  "module": "./lib/esm/index.js",
  "types": "./lib/types/index.d.ts",
  "files": [
    "lib",
    "LICENSE-APACHE",
    "LICENSE-MIT.txt"
  ],
  "scripts": {
    "test": "jest test --runInBand",
    "pretest": "yarn build",
    "lint": "eslint borsh-ts/**/*.ts",
    "fix": "eslint borsh-ts/**/*.ts --fix",
    "compile": "tsc -b ./tsconfig.cjs.json ./tsconfig.esm.json ./tsconfig.types.json",
    "build:clean": "rm -rf ./lib",
    "build": "npm run build:clean && npm run compile && node .build_scripts/prepare-package-json.js"
  },
  "exports": {
    ".": {
      "types": "./lib/types/index.d.ts",
      "require": "./lib/cjs/index.js",
      "import": "./lib/esm/index.js",
      "default": "./lib/esm/index.js"
    }
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/near/borsh-js.git"
  },
  "keywords": [
    "serializer",
    "binary",
    "serializer",
    "deserializer",
    "consistency",
    "deterministic"
  ],
  "author": "Near Inc",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/near/borsh-js/issues"
  },
  "homepage": "https://github.com/near/borsh-js#readme",
  "devDependencies": {
    "@types/babel__core": "^7.1.2",
    "@types/babel__template": "^7.0.2",
    "@types/node": "^12.7.3",
    "@typescript-eslint/eslint-plugin": "^5.28.0",
    "@typescript-eslint/parser": "^5.28.0",
    "eslint": "^8.17.0",
    "jest": "^26.0.1",
    "typescript": "^4",
    "bn.js": "^5.2.0"
  }
}

'''
'''--- tsconfig.cjs.json ---
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./lib/cjs",
    "module": "commonjs"
  }
}
'''
'''--- tsconfig.esm.json ---
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./lib/esm",
    "module": "esnext"
  }
}
'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "esModuleInterop": true,
    "moduleResolution": "node",
    "declaration": true,
    "preserveSymlinks": true,
    "preserveWatchOutput": true,
    "pretty": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "noImplicitReturns": true,
    "experimentalDecorators": true,
    "noUnusedLocals": true
  },
  "files": ["./borsh-ts/index.ts"]
}

'''
'''--- tsconfig.types.json ---
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./lib/types",
    "declaration": true,
    "emitDeclarationOnly": true
  }
}

'''