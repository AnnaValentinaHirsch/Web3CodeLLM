*GitHub Repository "miguelangelomendes/BuyThem"*

'''--- README.md ---
# BuyThem

#### â—ï¸Alert
When first opening the webapp it might take a long time as the dev machines go to sleep.

[Staging](https://buythem.onrender.com)

## Description

A dApp built on the NEAR Protocol and IPFS with Nuxt.js
Where anyone can buy and sell their images (not NFTs).

Contract in `contract/src/lib.rs` provides methods to get items, purchases and own items, to create and purchase items.

## How it works
### Sell
- Create an Item with:
  - Description
  - Price
  - Image
- The image is first encrypted before being uploaded to IPFS. Saved into the contract state afterwards.
- The contract charges a 10% fee on each purchase.
- The creator receives 90% of each purchase.
### Buy
By default any item that hasnâ€™t been bought by the current user is displayed as locked.
- Click unlock
- Approve the transaction (funds will be transferred)
- Item content is unlocked

## Setup locally
Make sure do you have `rust` and `yarn` installed

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

You also need an [infura](https://infura.io/) account.
#### Contract
Navigate to contract folder and execute `build.sh` script with `-cd` as arguments to *compile* and *deploy*
```
cd contract
./build -cd
```
Copy the contract name like dev-xxxxxx-xxxx

To test
```
cargo test -- --nocapture
```
### Frontend
Navigate to client-web create `.env` file with:
```
NODE_ENV=testnet
## ENCRYPTION
ENCRYPTION_KEY=ohmysecretkey
ENCRYPTION_IV=ohmysecretiv
## IPFS - Infura
PROJECT_ID=XXXXXXXXXXXXXXXXXXX
PROJECT_SECRET=XXXXXXXXXXXXXXX
```
open ``config.js`` and past the contract name, save and execute `yarn` to install the dependencies and `yarn dev` to run it

'''
'''--- client-web/.eslintrc.js ---
module.exports = {
  root: true,
  env: {
    browser: true,
    node: true
  },
  extends: [
    '@nuxtjs/eslint-config-typescript',
    'plugin:nuxt/recommended'
  ],
  plugins: [
  ],
  // add your custom rules here
  rules: {}
}

'''
'''--- client-web/README.md ---
# dashboard

## Build Setup

```bash
# install dependencies
$ yarn install

# serve with hot reload at localhost:3000
$ yarn dev

# build for production and launch server
$ yarn build
$ yarn start

# generate static project
$ yarn generate
```

For detailed explanation on how things work, check out [Nuxt.js docs](https://nuxtjs.org).

'''
'''--- client-web/api/cryptography.js ---
import { createCipheriv, createDecipheriv, scryptSync } from 'crypto';
import fs from 'fs';
const ipfsClient = require('ipfs-http-client')

//const bodyParser = require('body-parser')
const express = require("express");
var bodyParser = require('body-parser')
const app = express();
app.use(express.json());
const multer = require("multer");
const upload = multer({
  limits: { fieldSize: 25 * 1024 * 1024 }
});
const https = require('https');

const projectId = "25pSJkP92Q52fozRftdh9eA7Y6f";
const projectSecret = "d8010b44bf9f8a13028b4031580b416c";
const auth =
  'Basic ' + Buffer.from(projectId + ':' + projectSecret).toString('base64');

async function uploadToIPFS(string) {
  const client = ipfsClient.create({
    host: 'ipfs.infura.io',
    port: 5001,
    protocol: 'https',
    headers: {
      authorization: auth,
    },
  });

  return await client.add(string)
}

// Defining algorithm
const algorithm = 'aes-256-ctr';

// Defining key
const key = Buffer.from(scryptSync("jmWq!l@lj$WbXLVn&0cB!6Ck4INe$#Iy", 'salt', 32))

// Defining iv
const iv = Buffer.from("kt%3E@gg2c01P9ut")

function encrypt(input) {

  const cipher = createCipheriv(algorithm, key, iv);
  const encrypted = Buffer.concat([cipher.update(input), cipher.final()]);
  return encrypted.toString('hex');
}

function decrypt(input) {
  const decipher = createDecipheriv(algorithm, key, iv);
  const decrpyted = Buffer.concat([
    decipher.update(Buffer.from(input, 'hex')),
    decipher.final(),
  ]);
  return decrpyted.toString();
}

function fileToDataUrl(file) {
  if (file && file.buffer && file.mimetype) {
    return `data:${file.mimetype};base64,${file.buffer.toString('base64')}`
  }
}

app.post('/encrypt', upload.single("file"), async (req, res) => {
  try {
    const encrypted = encrypt(fileToDataUrl(req.file))
    const uploaded = await uploadToIPFS(encrypted)
    res.send(uploaded.cid.toString())
  } catch (error) {
    console.error("Error encrypt", error)
    throw error
  }
})

// app.use(bodyParser.json({ limit: "50mb" }))
// app.use(bodyParser.urlencoded({ limit: "50mb", extended: true, parameterLimit: 50000 }));
app.post('/decrypt', upload.single("data"), (req, res) => {
  try {
    // res.send("cenas")
    const decrypted = decrypt(req.body.data)
    res.send(decrypted)
  } catch (error) {
    console.error("Error decrypt", error)
    throw error
  }
})

module.exports = {
  path: '/cryptography',
  handler: app
}
'''
'''--- client-web/api/storage.js ---
import { createCipheriv, createDecipheriv, scryptSync } from 'crypto';
const ipfsClient = require('ipfs-http-client')
const express = require("express");
const app = express();
const multer = require("multer");
const upload = multer({
  limits: { fieldSize: 25 * 1024 * 1024 }
});
app.use(express.json());

const auth =
  'Basic ' + Buffer.from(process.env.PROJECT_ID.toString() + ':' + process.env.PROJECT_SECRET.toString()).toString('base64');

const algorithm = 'aes-256-ctr';
const key = Buffer.from(scryptSync(process.env.ENCRYPTION_KEY.toString(), 'salt', 32))
const iv = Buffer.from(process.env.ENCRYPTION_IV.toString());

function encrypt(input) {

  const cipher = createCipheriv(algorithm, key, iv);
  const encrypted = Buffer.concat([cipher.update(input), cipher.final()]);
  return encrypted.toString('hex');
}

function decrypt(input) {
  const decipher = createDecipheriv(algorithm, key, iv);
  const decrpyted = Buffer.concat([
    decipher.update(Buffer.from(input, 'hex')),
    decipher.final(),
  ]);
  return decrpyted.toString();
}

function fileToDataUrl(file) {
  if (file && file.buffer && file.mimetype) {
    return `data:${file.mimetype};base64,${file.buffer.toString('base64')}`
  }
}

async function uploadToIPFS(string) {
  const client = ipfsClient.create({
    host: 'ipfs.infura.io',
    port: 5001,
    protocol: 'https',
    headers: {
      authorization: auth,
    },
  });
  return await client.add(string)
}

app.post('/upload', upload.single("file"), async (req, res) => {
  try {
    const encrypted = encrypt(fileToDataUrl(req.file))
    const uploaded = await uploadToIPFS(encrypted)
    res.send(uploaded.cid.toString())
  } catch (error) {
    console.error("Error encrypt", error)
    throw error
  }
})

app.post('/get', upload.single("data"), async (req, res) => {
  try {
    const cid = req.body.data
    const client = ipfsClient.create({
      host: 'ipfs.infura.io',
      port: 5001,
      protocol: 'https',
      headers: {
        authorization: auth,
      },
    });
    const chunks = [];
    for await (const chunk of client.cat(cid)) {
      chunks.push(chunk);
    }
    // Convert Uint8Array to base64 string
    let chunkStringBase64 = "";
    chunks.forEach((chunk) => {
      chunkStringBase64 += new TextDecoder().decode(chunk);
    });
    const decrypted = decrypt(chunkStringBase64)
    res.send(decrypted)
  } catch (error) {
    console.error("Error decrypt", error)
    throw error
  }
})

module.exports = {
  path: '/storage',
  handler: app
}
'''
'''--- client-web/assets/README.md ---
# ASSETS

**This directory is not required, you can delete it if you don't want to use it.**

This directory contains your un-compiled assets such as LESS, SASS, or JavaScript.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/assets#webpacked).

'''
'''--- client-web/assets/css/tailwind.css ---
/* purgecss start ignore */
@import 'tailwindcss/base';
@import 'tailwindcss/components';
/* purgecss end ignore */
@import 'tailwindcss/utilities';

@font-face {
  font-family: 'Rubik';
  font-weight: 400;
  src: url('../fonts/Rubik-VariableFont_wght.ttf');
}

@layer base {
  :root{
    --color-primary: 13,13,43;
    --color-primary-hover: 113,113,143;
    --color-on-primary: 255,255,255;
    --color-on-primary-hover: 222, 222, 222;

    --color-accent: 54, 113, 233;
    --color-accent-hover: 74, 133, 253;

    --color-success:101,187,148;
    --color-warning:255,152,0;
    --color-danger:215, 50, 50;

    --color-surface: 255, 255, 255;
    --color-surface-secondary: 250, 251, 255;
    --color-on-surface: 0,0,0;

    --color-background: 248, 249, 251;
    --color-background-secondary: 43,7,110;
    
    --color-paragraph: 0, 0, 0;
    --color-paragraph-variant: 50, 50, 50;
  }

  .dark{
    --color-primary: 255,255,255;
    --color-primary-hover: 200,200,200;
    --color-on-primary: 0,0,0;
    --color-on-primary-hover: 20, 20, 20;

    --color-accent: 54, 113, 233;
    --color-accent-hover: 74, 133, 253;

    --color-success:101,187,148;
    --color-warning:255,152,0;
    --color-danger:212, 88, 91;

    --color-surface: 50, 50, 50;
    --color-on-surface: 255,255,255;

    --color-background: 0, 0, 0;
    --color-background-secondary: 250, 251, 255;
    
    --color-paragraph: 255, 255, 255;
    --color-paragraph-variant: 255, 255, 255;
  }
}

@layer utilities {
  .font-thin {
      font-variation-settings: 'wght' 100;
  }
  .font-extralight {
      font-variation-settings: 'wght' 200;
  }
  .font-light {
      font-variation-settings: 'wght' 300;
  }
  .font-normal {
      font-variation-settings: 'wght' 400;
  }
  .font-medium {
      font-variation-settings: 'wght' 500;
  }
  .font-semibold {
      font-variation-settings: 'wght' 600;
  }
  .font-bold {
      font-variation-settings: 'wght' 700;
  }
  .font-extrabold {
      font-variation-settings: 'wght' 800;
  }
  .font-black {
      font-variation-settings: 'wght' 900;
  }
}

/* purgecss start ignore */
.page-enter-active, .page-leave-active {
  transition: opacity .3s;
  transition-timing-function: ease-in-out;
}
.page-enter, .page-leave-to {
  opacity: 0;
}
/* Hide scrollbar for Chrome, Safari and Opera */
.no-scrollbar::-webkit-scrollbar {
  display: none;
}
/* Hide scrollbar for IE, Edge and Firefox */
.no-scrollbar {
  -ms-overflow-style: none;/* IE and Edge */
  scrollbar-width: none;/* Firefox */
}

/************
*           *
*  Custom   *
*           *
************/
html,
body{
   @apply bg-background text-paragraph;
}
.page-x-offset{
  @apply px-4 2xl:px-0
}

.clickable{
  @apply transition;
  @apply ease-in-out;
  @apply duration-500;
  @apply cursor-pointer;
}
.label{
  @apply text-sm;
  @apply font-semibold capitalize tracking-wide;
}
.input{
@apply rounded;
@apply bg-surface;
@apply text-on-surface;
@apply px-4 py-2;
}
.input:focus,input:focus,select:focus,button:focus,.clickable:focus{
  @apply outline-none;
}
.backdrop-blur {
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

.template-toast {
  @apply justify-end items-end space-y-4;
  z-index: -1!important;
}
.template-toast > div {
 @apply max-w-max;
}
.template-toast .w-0 {
  @apply min-w-max w-full;
}
.template-toast .flex.items-start {
  @apply space-x-2;
}

.template-toast .text-green-300,
.template-toast .text-green-400 {
  @apply text-success;
}
.template-toast .border-green-200{
  @apply border-success;
}

.template-toast .text-red-300,
.template-toast .text-red-400 {
  @apply text-danger;
}
.template-toast .border-red-200{
  @apply border-danger;
}

.template-toast .text-yellow-300,
.template-toast .text-yellow-400 {
  @apply text-warning;
}
.template-toast .border-yellow-200{
  @apply border-warning;
}

'''
'''--- client-web/jest.config.js ---
module.exports = {
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '^~/(.*)$': '<rootDir>/$1',
    '^vue$': 'vue/dist/vue.common.js'
  },
  moduleFileExtensions: [
    'ts',
    'js',
    'vue',
    'json'
  ],
  transform: {
    '^.+\\.ts$': 'ts-jest',
    '^.+\\.js$': 'babel-jest',
    '.*\\.(vue)$': 'vue-jest'
  },
  collectCoverage: true,
  collectCoverageFrom: [
    '<rootDir>/components/**/*.vue',
    '<rootDir>/pages/**/*.vue'
  ]
}

'''
'''--- client-web/lang/en_US.js ---
export default {
	language: "english",
	wip: "Work in progress",
	menu: {
		home: "Home",
		purchases: "Purchases",
		profile: "Profile",
	},
	error: "Error",
	errors: {
		404: "Page not found",
		500: "Internal server error",
		geral: "Something went wrong",
		return_home: "Return to home",
	},
	footer: {
		copyright: "by Miguel Mendes | miguelmendes.near | Powered by NEAR and IPFS",
	}
}
'''
'''--- client-web/middleware/README.md ---
# MIDDLEWARE

**This directory is not required, you can delete it if you don't want to use it.**

This directory contains your application middleware.
Middleware let you define custom functions that can be run before rendering either a page or a group of pages.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/routing#middleware).

'''
'''--- client-web/near/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || "miguelmendes.testnet"

function getConfig(env) {
  if (typeof CONTRACT_NAME === 'undefined') {
    throw Error('CONTRACT_NAME not defined')
  }
  switch (env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}
export default getConfig;
'''
'''--- client-web/near/interface.js ---
import * as nearAPI from 'near-api-js';
import getConfig from './config'
import Big from "big.js";

const nearConfig = getConfig(process.env.NODE_ENV || 'testnet')
let contract = null
let currentUser = null
let walletConnection = null

// Taken from: https://github.com/near-examples/rust-status-message/blob/master/frontend/index.js#L8-L41
// Ref: https://github.com/near/near-api-js/blob/master/examples/quick-reference.md
export async function initContract() {
  const near = await nearAPI.connect({ keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore(), ...nearConfig });

  walletConnection = new nearAPI.WalletConnection(near);
  if (walletConnection.getAccountId()) {
    const accountState = await walletConnection.account().state()
    currentUser = { accountId: walletConnection.getAccountId(), balance: nearAPI.utils.format.formatNearAmount(accountState.amount.toString()) };
  }

  contract = new nearAPI.Contract(walletConnection.account(), nearConfig.contractName, {
    viewMethods: ["get_items", "get_purchased_items", "get_own_items"],
    changeMethods: ["create_item", "purchase_item"],
    sender: walletConnection.getAccountId()
  });

  return { contract, currentUser, nearConfig, walletConnection };
}

export async function logout() {
  const signOut = async () => {
    return await walletConnection.signOut();
  };

  await signOut()
  window.location.replace(window.location.origin + window.location.pathname)
}

export async function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  const signIn = async () => {
    return await walletConnection.requestSignIn(nearConfig.contractName, "BuyThem")
  };

  return await signIn()
}
export async function getUserId() {
  if (walletConnection) {

    const userId = async () => {
      return await walletConnection.getAccountId()
    };

    return await userId()
  }
  return null
}

/**
 * 
 * Custom Methods
 * 
 */

export async function getItems() {
  if (!contract) {
    throw Error('Contract not initialized')
  }
  const items = await contract.get_items({ account_id: currentUser.accountId })
  return items.map(item => {
    item.price = nearAPI.utils.format.formatNearAmount(item.price);
    return item
  })
}

export async function getOwnItems() {
  if (!contract) {
    throw Error('Contract not initialized')
  }
  if (!currentUser) {
    throw Error('User not logged in')
  }
  try {
    const items = await contract.get_own_items({ account_id: currentUser.accountId.toString() })
    return items
  } catch (error) {
    console.log("error", error)
  }

}
export async function getPruchases() {
  if (!contract) {
    throw Error('Contract not initialized')
  }
  if (!currentUser) {
    throw Error('User not logged in')
  }
  const items = await contract.get_purchased_items({ account_id: currentUser.accountId })
  return items
}

const BOATLOAD_OF_GAS = Big(3).times(10 ** 13).toFixed();
export async function createItem(item) {
  if (!contract) {
    throw Error('Contract not initialized')
  }
  const createdItem = await contract.create_item(
    {
      // Transform Near amount to Yocto
      price: nearAPI.utils.format.parseNearAmount(item.price.toString()),
      description: item.description,
      uri: item.uri
    }, BOATLOAD_OF_GAS
  )
  return createdItem
}
export async function buyItem(id, price) {
  if (!contract) {
    throw Error('Contract not initialized')
  }
  // Transform Near amount to Yocto
  const amount = nearAPI.utils.format.parseNearAmount(price.toString());
  const item = await contract.purchase_item(
    {
      id: id
    }, BOATLOAD_OF_GAS, amount)
  return item
}
'''
'''--- client-web/nuxt.config.js ---
export default {
  head: {
    title: 'BuyThem',
    titleTemplate: 'BuyThem - %s',
    meta: [
      { charset: 'utf-8' },
      {
        name: 'viewport',
        content: 'width=device-width, initial-scale=1'
      },
  
      {
        hid: 'og:type',
        property: 'og:type',
        content: 'website'
      },
      {
        hid: 'og:title',
        property: 'og:title',
        content: 'BuyThem'
      },
      {
        hid: 'og:description',
        property: 'og:description',
        content:
        'A place where you can buy and sell photos.'
      },
     
      // default
      {
        hid: 'title',
        name: 'title',
        content:
          'BuyThem'
      },
      
   
      {
        hid: 'description',
        name: 'description',
        content:
        'A place where you can buy and sell photos.'
      },

      // Twitter
      // Test on: https://cards-dev.twitter.com/validator
      {
        hid: 'twitter:card',
        name: 'twitter:card',
        content: 'summary'
      },
      
          {
        hid: 'twitter:title',
        name: 'twitter:title',
        content: 'BuyThem'
      },
      {
        hid: 'twitter:description',
        name: 'twitter:description',
        content:
          'A place where you can buy and sell photos.'
      },

    ],
    // canonical
    link: [
     
      { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
    ],
  },
  // Global CSS (https://go.nuxtjs.dev/config-css)
  css: [
    '~/assets/css/tailwind.css'
  ],

  /*
  ** Customize the progress-bar color
  */
  loading: {
    color: '#32C3A1',
    height: '8px'
  },
  loadingIndicator: {
    name: 'circle',
    color: '#3B8070',
    background: 'white'
  },

  serverMiddleware: [
    // '~/server-middleware/logger',
    { path: '/cryptography', handler: '~/api/cryptography.js' },
    { path: '/storage', handler: '~/api/storage.js' },
  ],
  // Plugins to run before rendering page (https://go.nuxtjs.dev/config-plugins)
  plugins: [
    { src: '~/plugins/axios.js' },
    { src: '~/plugins/nuxt-client-init.js', mode: 'client' },
  ],

  // Auto import components (https://go.nuxtjs.dev/config-components)
  components: [
    {
      path: '~/components/',
    },
    {
      path: '~/components/Icons',
    },
  ],

  // Modules for dev and build (recommended) (https://go.nuxtjs.dev/config-modules)
  buildModules: [
    // https://go.nuxtjs.dev/tailwindcss
    '@nuxtjs/tailwindcss',
    '@nuxt/postcss8',
  ],

  // Modules (https://go.nuxtjs.dev/config-modules)
  modules: [
    // https://i18n.nuxtjs.org/setup
    'nuxt-i18n',
    // https://github.com/nuxt-community/dayjs-module
    '@nuxtjs/dayjs',
    // https://go.nuxtjs.dev/axios
    '@nuxtjs/axios',
  ],
  i18n: {
    locales: [
      {
        code: 'en',
        name: 'English',
        iso: 'en-US',
        file: 'en_US.js'
      },
    ],
    lazy: true,
    langDir: '~/lang/',
    defaultLocale: 'en',
    strategy: 'no_prefix',
    detectBrowserLanguage: {
      useCookie: true,
      cookieKey: 'locale',
      onlyOnRoot: true,  // recommended
    },
    vueI18n: {
      fallbackLocale: 'en',
    },
  },

  // Build Configuration (https://go.nuxtjs.dev/config-build)
  build: {
    postcss: {
      plugins: {
        tailwindcss: {},
        autoprefixer: {},
      },
    },
    babel: {
      plugins: [
        ['@babel/plugin-proposal-private-methods', { loose: true }],
        ['@babel/plugin-proposal-private-property-in-object', { loose: true }]
      ]
    },
  }
}

'''
'''--- client-web/package.json ---
{
  "name": "client-web",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "nuxt",
    "build": "nuxt build",
    "start": "nuxt start",
    "generate": "nuxt-ts generate",
    "lint:js": "eslint --ext .js,.vue --ignore-path .gitignore .",
    "lint": "yarn lint:js",
    "test": "jest"
  },
  "dependencies": {
    "@nuxt/postcss8": "^1.1.3",
    "@nuxt/typescript-runtime": "^2.0.0",
    "@nuxtjs/axios": "^5.12.2",
    "@nuxtjs/dayjs": "^1.4.0",
    "autoprefixer": "^10.4.2",
    "big.js": "^6.1.1",
    "core-js": "^3.6.5",
    "crypto-js": "^4.1.1",
    "dotenv": "^16.0.0",
    "express": "^4.17.1",
    "ipfs-core": "^0.14.1",
    "ipfs-http-client": "^56.0.1",
    "multer": "^1.4.4",
    "near-api-js": "^0.44.2",
    "near-wallet-selector": "^1.0.2",
    "nuxt": "^2.15.7",
    "nuxt-i18n": "^6.28.0",
    "tailwindcss": "^3.0.16"
  },
  "devDependencies": {
    "@nuxt/types": "^2.14.6",
    "@nuxt/typescript-build": "^2.0.3",
    "@nuxtjs/eslint-config": "^3.1.0",
    "@nuxtjs/eslint-config-typescript": "^3.0.0",
    "@nuxtjs/eslint-module": "^3.0.2",
    "@nuxtjs/tailwindcss": "^4.2.1",
    "@vue/test-utils": "^1.1.0",
    "babel-core": "7.0.0-bridge.0",
    "babel-eslint": "^10.1.0",
    "babel-jest": "^26.5.0",
    "eslint": "^7.19.0",
    "eslint-plugin-nuxt": "^1.0.0",
    "jest": "^26.5.0",
    "postcss": "^8.4.5",
    "ts-jest": "^26.4.1",
    "vue-jest": "^3.0.4"
  }
}

'''
'''--- client-web/pages/README.md ---
# PAGES

This directory contains your Application Views and Routes.
The framework reads all the `*.vue` files inside this directory and creates the router of your application.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/routing).

'''
'''--- client-web/plugins/README.md ---
# PLUGINS

**This directory is not required, you can delete it if you don't want to use it.**

This directory contains Javascript plugins that you want to run before mounting the root Vue.js application.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/plugins).

'''
'''--- client-web/plugins/axios.js ---
export default ({ $axios, error }) => {
	$axios.onError((err) => {
		if (err.response.status === 500) {
			error({
				statusCode: err.response.status,
				message: err.response.statusText
			})
		}
	})
}
'''
'''--- client-web/plugins/nuxt-client-init.js ---
export default async context => {
  await context.store.dispatch('nuxtClientInit', context)
}
'''
'''--- client-web/static/README.md ---
# STATIC

**This directory is not required, you can delete it if you don't want to use it.**

This directory contains your static files.
Each file inside this directory is mapped to `/`.
Thus you'd want to delete this README.md before deploying to production.

Example: `/static/robots.txt` is mapped as `/robots.txt`.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/assets#static).

'''
'''--- client-web/store/README.md ---
# STORE

**This directory is not required, you can delete it if you don't want to use it.**

This directory contains your Vuex Store files.
Vuex Store option is implemented in the Nuxt.js framework.

Creating a file in this directory automatically activates the option in the framework.

More information about the usage of this directory in [the documentation](https://nuxtjs.org/guide/vuex-store).

'''
'''--- client-web/store/index.js ---
export default {
  actions: {
    // Required for nuxt/auth module
    nuxtServerInit({ commit, dispatch }) {
      // dispatch('near/init')
    },
    async nuxtClientInit({ commit, dispatch }) {
      // Run once on client side init
      dispatch('near/init')
    },
  }
}

'''
'''--- client-web/store/items.js ---
import * as near from '../near/interface'

export const state = () => ({
	list: [],
	own: [],
	detail: null,
})

export const mutations = {
	SET_LIST(state, newList) {
		state.list = newList ? newList : []
	},
	SET_OWN(state, newList) {
		state.own = newList ? newList : []
	},
	ADD_OR_UPDATE_ITEM_ON_LIST(state, newItem) {
		if (newItem) {
			const index = state.list.findIndex(item => item.id === newItem.id)
			if (index >= 0) {
				if (state.list[index].media) {
					newItem.media = state.list[index].media
				}
				state.list.splice(index, 1, newItem);
			} else {
				state.list.push(newItem)
			}
		}
	},
	SET_DETAIL(state, newDetail) {
		state.detail = newDetail ? newDetail : null
	},
}

export const actions = {
	async list({ commit }) {
		try {
			const result = await near.getItems()
			if (this.state.items.list.length === 0) {
				commit('SET_LIST', result)
			} else {
				if (result) {
					result.forEach(item => {
						commit('ADD_OR_UPDATE_ITEM_ON_LIST', item)
					})
				}
			}
			return result
		} catch (error) {
			console.error("Items list error", error)
			throw error
		}
	},
	async own({ commit, dispatch }) {
		try {
			const result = await near.getOwnItems()
			if (result ) {
				result.forEach(item => {
					commit('ADD_OR_UPDATE_ITEM_ON_LIST', item)
				})

				dispatch("setOwn")
			}
			return result
		} catch (error) {
			console.error("Items Own list error", error)
			throw error
		}
	},
	async setOwn({ commit }, id) {
		try {
			const user_id = await near.getUserId()
			commit('SET_OWN', this.state.items.list.filter(item => item.owner_account_id === user_id))
		} catch (error) {
			console.error("Items setOwn error", error)
			throw error
		}
	},
	async create({ commit, dispatch }, item) {
		try {
			const result = await near.createItem(item)
			commit('ADD_OR_UPDATE_ITEM_ON_LIST', result)
			dispatch("setOwn")
			return item
		} catch (error) {
			console.error("Profiles create error", error)
			throw error
		}
	},
	async updateMedia({ commit }, params) {
		try {
			const item = this.state.items.list.find(item => item.id === params.id)
			if (item) {
				item.media = params.media
				commit('ADD_OR_UPDATE_ITEM_ON_LIST', item)
				commit('purchases/ADD_TO_LIST', item, { root: true })
			}
			return item
		} catch (error) {
			console.error("Update media error", error)
			throw error
		}
	},
	async updateByUri({ commit }, params) {
		try {
			const item = this.state.items.list.find(item => item.uri === params.uri)
			if (item) {
				item.media = params.media
				commit('ADD_OR_UPDATE_ITEM_ON_LIST', item)
			}
			return item
		} catch (error) {
			console.error("Update by uri error", error)
			throw error
		}
	},

}
'''
'''--- client-web/store/navigation.js ---
export const state = () => ({
	top: [],
})

export const mutations = {
	setTop(state, newMenu) {
		state.top = newMenu
	},
}
export const actions = {
	getTop({ commit }) {
		const menuTop =
			[
				{
					to: "/",
					title: "home",
					name:"index",
				},
				{
					to: "/purchases",
					title: "purchases",
					name:"purchases",
				},
				{
					to: "/profile/me",
					title: "profile",
					name:"profile-me",
				},
			]
		commit('setTop', menuTop)
	},
}
'''
'''--- client-web/store/near.js ---
import * as near from '../near/interface'

function initialState() {
  return {
    is_loading: true,
    is_session_loading: false,
    contract: null,
    nearConfig: null,
    user: null,
    is_logged_in: false,
  }
}

export const state = () => (initialState())

export const mutations = {
  SET_LOADING(state, isUpdating) {
    state.is_loading = isUpdating
  },
  SET_SESSION_LOADING(state, isUpdating) {
    state.is_loading = isUpdating
  },
  SET_CONTRACT(state, contract) {
    state.contract = contract
  },
  SET_USER(state, user) {
    state.user = user
  },
  SET_CONFIG(state, nearConfig) {
    state.nearConfig = nearConfig
  },
  SET_IS_LOGGED_IN(state, isSingnedIn) {
    state.is_logged_in = isSingnedIn
  },
}

export const actions = {
  async init({ commit }) {
    try {
      commit('SET_LOADING', true)
      const { contract, currentUser, nearConfig, walletConnection } = await near.initContract()
      console.log("currentUser", currentUser)
      commit('SET_CONTRACT', contract)
      commit('SET_USER', currentUser)
      commit('SET_CONFIG', nearConfig)
      commit('SET_IS_LOGGED_IN', walletConnection.isSignedIn())

      commit('SET_LOADING', false)
    } catch (err) {
      console.log('Contract init error: ', err)
      commit('SET_LOADING', false)
      return null
    }
  },
  async login({ commit }) {
    try {
      const result = await near.login()
      commit('SET_IS_LOGGED_IN', walletConnection.isSingnedIn())
      return result
    } catch (err) {
      console.log('Contract init error: ', err)
      commit('SET_SESSION_LOADING', false)
      return null
    }
  },
  async logout({ commit }) {
    try {
      commit('SET_SESSION_LOADING', true)
      const result = await near.logout()
      commit('SET_IS_LOGGED_IN', false)
      commit('SET_SESSION_LOADING', false)
    } catch (err) {
      console.log('Contract init error: ', err)
      commit('SET_SESSION_LOADING', false)
      return null
    }
  },
  async create({ commit, dispatch }, item) {
    try {
      commit('SET_LOADING', true)
      const result = await near.createItem(item)
      commit('SET_LOADING', false)
      return result
    } catch (err) {
      console.log('Contract init error: ', err)
      commit('SET_LOADING', false)
      return null
    }
  }
}
'''
'''--- client-web/store/purchases.js ---
import * as near from '../near/interface'

export const state = () => ({
	list: [],
	detail: null,
})

export const mutations = {
	SET_LIST(state, newList) {
		state.list = newList ? newList : []
	},
	ADD_TO_LIST(state, newItem) {
		if (newItem) {
			const index = state.list.findIndex(item => item.id === newItem.id)
			if (index >= 0) {
				if (state.list[index].media) {
					newItem.media = state.list[index].media
				}
				state.list.splice(index, 1, newItem);
			} else {
				state.list.push(newItem)
			}
		}
	},
	SET_DETAIL(state, newDetail) {
		state.detail = newDetail ? newDetail : null
	},
}

export const actions = {
	async list({ commit }) {
		try {
			const result = await near.getPruchases()
			if (this.state.items.list.length === 0) {
				commit('SET_LIST', result)
			} else {
				if (result) {
					result.forEach(item => {
						commit('ADD_TO_LIST', item)
					})
				}
			}
			commit('SET_LIST', result)
			return result
		} catch (error) {
			console.error("Purchases list error", error)
			throw error
		}
	},
	async buyItem({ commit }, item) {
		try {
			const result = await near.buyItem(item.id, item.price.toString())
			commit('ADD_TO_LIST', result)
			commit('items/ADD_OR_UPDATE_ITEM_ON_LIST', result, { root: true })
			return result
		} catch (error) {
			console.error("buyItem error", error)
			throw error
		}
	},
}
'''
'''--- client-web/store/storage.js ---
import axios from 'axios';

function initialState() {
  return {
  }
}

export const state = () => (initialState())

export const mutations = {
}

export const actions = {
  async upload({ commit }, file) {
    try {
      const bodyFormData = new FormData();
      bodyFormData.append("file", file, file.name)
      const result = await axios.post('/storage/upload', bodyFormData)
      return result.data
    } catch (error) {
      console.error("Error encrypt", error)
      throw error

    }
  },
  async get({ commit }, uri) {
    try {
      const bodyFormData = new FormData();
      bodyFormData.append("data", uri)
      const result = await axios.post('/storage/get', bodyFormData);
      return result.data
    } catch (error) {
      console.error("Error get", error)
      throw error

    }
  },

}
'''
'''--- client-web/tailwind.config.js ---
/*
** TailwindCSS Configuration File
**
** Docs: https://tailwindcss.com/docs/configuration
** Default: https://github.com/tailwindcss/tailwindcss/blob/master/stubs/defaultConfig.stub.js
*/
function withOpacity(themeVariable) {
  return ({ opacityVariable, opacityValue }) => {
    if (opacityValue !== undefined) {
      return `rgba(var(${themeVariable}), ${opacityValue})`
    }
    if (opacityVariable !== undefined) {
      return `rgba(var(${themeVariable}), var(${opacityVariable}, 1))`
    }
    return `rgb(var(${themeVariable}))`
  }
}

module.exports = {
  content: ['./src/**/*.html' /* ... */],
  theme: {
    fontSize: {
      'xxs': '0.60rem',
      'xs': '.75rem',
      'sm': '.875rem',
      'tiny': '.875rem',
      'base': '1rem',
      'lg': '1.125rem',
      'xl': '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem',
      '4xl': '2.25rem',
      '5xl': '3rem',
      '6xl': '4rem',
      '7xl': '5rem',
    },
    fontFamily: {
      'rubik': ['Rubik'],
      'sans': ['Rubik', '-apple-system', 'BlinkMacSystemFont'],
    },
    extend: {
      screens: {
        '3xl': '1900px',
      },
      colors: {
        primary: withOpacity('--color-primary'),
        'primary-hover': withOpacity('--color-primary-hover'),
        'on-primary': withOpacity('--color-on-primary'),
        'on-primary-hover': withOpacity('--color-on-primary-hover'),

        accent: withOpacity('--color-accent'),
        'accent-hover': withOpacity('--color-accent-hover'),

        success: withOpacity('--color-success'),
        warning: withOpacity('--color-warning'),
        danger: withOpacity('--color-danger'),
        'danger-hover': withOpacity('--color-danger-hover'),

        'surface': withOpacity('--color-surface'),
        'surface-secondary': withOpacity('--color-surface-secondary'),
        'on-surface': withOpacity('--color-on-surface'),

        background: withOpacity('--color-background'),
        'background-secondary': withOpacity('--color-background-secondary'),

        paragraph: withOpacity('--color-paragraph'),
        'paragraph-variant': withOpacity('--color-paragraph-variant'),
      },
      transitionDuration: {
        '0': '0ms',
        '1500': '1500ms',
        '2000': '2000ms',
      },
      boxShadow: {
        'sm-diffused': '0 1px 2px 0px rgba(0, 0, 0, 0.03), 0 10px 10px -5px rgba(0, 0, 0, 0.02)',
        'md-diffused': '0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 10px 10px -5px rgba(0, 0, 0, 0.02)',
        'lg-diffused': '0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 10px 10px -5px rgba(0, 0, 0, 0.02)',
        'xl-diffused': '0 20px 25px -5px rgba(0, 0, 0, 0.05), 0 10px 10px -5px rgba(0, 0, 0, 0.02)',
      },
    },
  },
  plugins: [],
}

'''
'''--- client-web/test/Logo.spec.js ---
import { mount } from '@vue/test-utils'
import Logo from '@/components/Logo.vue'

describe('Logo', () => {
  test('is a Vue instance', () => {
    const wrapper = mount(Logo)
    expect(wrapper.vm).toBeTruthy()
  })
})

'''
'''--- client-web/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "ESNext",
    "moduleResolution": "Node",
    "lib": [
      "ESNext",
      "ESNext.AsyncIterable",
      "DOM"
    ],
    "esModuleInterop": true,
    "allowJs": true,
    "sourceMap": true,
    "strict": true,
    "noEmit": true,
    "experimentalDecorators": true,
    "baseUrl": ".",
    "paths": {
      "~/*": [
        "./*"
      ],
      "@/*": [
        "./*"
      ]
    },
    "types": [
      "@types/node",
      "@nuxt/types",
    ]
  },
  "exclude": [
    "node_modules",
    ".nuxt",
    "dist"
  ]
}

'''
'''--- contract/Cargo.toml ---
[package]
name = "buythem"
version = "0.1.0"
edition = "2021"
authors = ["Miguel Mendes <miguelangello13@gmail.com>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
#near-sdk = "4.0.0-pre.5"
near-sdk = "4.0.0-pre.2"
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = true
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

IS_COMPILE=false
IS_RESET_PROFILE=false
IS_DEPLOY=false
IS_COMPILE_DEPLOY=false

for var in "$@"
do
  case $var in
    -h|--help)
     echo "Utility script to help you compile, reset profile and deploy contracts on the NEAR blockchain"
     echo "Available options:"
     echo "| "
     echo "| --help | -h: Show this help message."
     echo "| "
     echo "| --compile | -c: Compile the contracts for release with: RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release"
     echo "| "
     echo "| --reset | -r: Resets the dev account id by deleting the .neardev folder, you must deploy to generate a new profile/account."
     echo "| "
     echo "| --deploy | -d: Deploys the contracts to the NEAR network with: near dev-deploy --wasmFile ./out/main.wasm"
     echo "| "
     echo " "
     echo "For more information please check the docs: https://docs.near.org/docs/develop/basics/getting-started"
     echo " "
     echo "Author:"
     echo "| Joaquim Ley <joaquimley@gmail.com> joaquimley.near | Jan 2022"
     echo "| Based on 'NEAR examples' build script available on GitHub: https://github.com/near-examples/NFT/blob/master/build.sh"
     echo " "
     echo "Issues: "
     ;;
     
    -cd)
      IS_COMPILE_DEPLOY=true
      ;;
    -d|--deploy)
      IS_DEPLOY=true
      ;;
    -r|--reset) 
      IS_RESET_PROFILE=true
      ;;
    -c|--compile)
      IS_COMPILE=true
      ;;
  esac
done

if $IS_COMPILE ; then
    echo "Compiling for release... ðŸ¤–"
    RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
    mkdir -p ./out
    cp target/wasm32-unknown-unknown/release/*.wasm ./out/main.wasm
    echo "---------------------------------------------------------"
    echo "Compile success! â­ Artifact exported to: ./out/main.wasm"
fi

if $IS_RESET_PROFILE; then
    echo "Reseting the neardev profile"
    rm -rf ./neardev
    echo "---------------------------------------------------------"
    echo ".neardev folder deleted ðŸ—‘, compile to generate a new dev-account"
fi

if $IS_DEPLOY; then
    echo "Deploying contract... â›“ï¸"
    near dev-deploy --wasmFile ./out/main.wasm
    echo "---------------------------------------------------------"
    echo "Contract deployed with success âœ…" 

    echo "---------------------------------------------------------"
    echo "Load the new contract account id with:"
    echo "> source ./neardev/dev-account.env"
fi
if $IS_COMPILE_DEPLOY; then
echo "Compiling for release... ðŸ¤–"
    RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
    mkdir -p ./out
    cp target/wasm32-unknown-unknown/release/*.wasm ./out/main.wasm
    echo "---------------------------------------------------------"
    echo "Compile success! â­ Artifact exported to: ./out/main.wasm"
    echo "Deploying contract... â›“ï¸"
    near dev-deploy --wasmFile ./out/main.wasm
    echo "---------------------------------------------------------"
    echo "Contract deployed with success âœ…" 

    echo "---------------------------------------------------------"
    echo "Load the new contract account id with:"
    echo "> source ./neardev/dev-account.env"
fi
'''
'''--- contract/src/item.rs ---
// To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{env, AccountId, PanicOnDefault};
use serde::Serialize;

// #[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Clone, PanicOnDefault, Serialize)]
pub struct Item {
    id: u64,
    price: U128,
    uri: Option<String>,
    owner_account_id: AccountId,
    description: Option<String>,
}

// not marked with #[near_bindgen] because it is not intended to be used by external code
impl Item {
    pub fn new(id: u64, price: U128, uri: String, description: Option<String>) -> Self {
        if uri.is_empty() {
            panic!("uri cannot be empty");
        }

        if price.0 == 0 {
            panic!("price must be positive");
        }

        Item {
            id,
            price,
            uri: uri.into(),
            owner_account_id: env::signer_account_id(),
            description,
        }
    }

    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn price(&self) -> U128 {
        self.price
    }

    pub fn owner_account_id(&self) -> &AccountId {
        &self.owner_account_id
    }

    pub fn get_own(&self, account_id: &AccountId) -> Option<Self> {
        if account_id == &self.owner_account_id {
            Some(self.clone())
        } else {
            None
        }
    }

    pub fn get_mapped(&self, account_id: &AccountId, purchases: Option<Vec<u64>>) -> Self {
        let account_id_clone = account_id.clone();
        Item {
            id: self.id.clone(),
            uri: if account_id_clone == self.owner_account_id
                || purchases.unwrap_or_default().contains(&self.id)
            {
                self.uri.clone()
            } else {
                None
            },
            price: self.price.clone(),
            description: self.description.clone(),
            owner_account_id: self.owner_account_id.clone(),
        }
    }
}

/**
 *
 * TESTS
 *
 */

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, AccountId};

    // Set up the testing context and unit test environment
    fn owner_account_id() -> AccountId {
        return AccountId::new_unchecked("alice.testnet".to_string());
    }

    fn get_context(signer: &AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();

        builder.signer_account_id(signer.clone());
        builder
    }

    fn init_item() -> Item {
        Item::new(
            1,
            U128::from(100),
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            Some("This is a description".to_string()),
        )
    }

    #[test]
    #[should_panic]
    fn test_create_with_price_0() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let _item = Item::new(
            1,
            U128::from(0),
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            Some("This is a description".to_string()),
        );
        // Should panic - price cannot be 0
    }

    #[test]
    #[should_panic]
    fn test_create_with_empty_uri() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let _item = Item::new(
            1,
            U128::from(10),
            "".to_string(),
            Some("This is a description".to_string()),
        );
        // Should panic - uri cannot be empty
    }

    #[test]
    fn test_init_item() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        // Set up item object and call the new method
        let item = Item::new(
            1,
            U128::from(100),
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            Some("This is a description".to_string()),
        );
        assert_eq!(item.id, 1, "Item id should be 1");
        assert_eq!(item.price, U128::from(100), "Item price should be 100");
        assert_eq!(
            item.uri,
            Some("QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string()),
            "Item uri should be QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW"
        );
        assert_eq!(
            item.description,
            Some("This is a description".to_string()),
            "Item price should be 100"
        );
        assert_eq!(
            item.owner_account_id,
            owner_account_id(),
            "Item owner should be alice"
        );
    }

    #[test]
    fn test_get_id() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        // Set up item object and call the new method
        let item = init_item();
        assert_eq!(item.id(), 1, "Item id should be 1");
    }

    #[test]
    fn test_get_price() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let item = init_item();

        assert_eq!(item.price(), U128::from(100), "Item price should be 100");
    }

    #[test]
    fn test_get_owner_account_id() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let item = init_item();

        assert_eq!(
            item.owner_account_id(),
            &owner_account_id(),
            "Item owner should be {}",
            owner_account_id()
        );
    }

    #[test]
    fn test_get_own_some() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let item = init_item();
        let own_item = item.get_own(&owner_account_id());
        assert!(own_item.is_some(), "Should have some");
    }

    #[test]
    fn test_get_own_none() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        let item = init_item();

        let john = AccountId::new_unchecked("john.testnet".to_string());
        let own_item = item.get_own(&john);
        assert!(own_item.is_none(), "Should have none");
    }

    #[test]
    fn test_get_mapped_item_beeing_owner() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());

        // Set up item object and call the new method
        let item = init_item();
        let mapped_item = item.get_mapped(&owner_account_id(), None);
        assert_eq!(
            mapped_item.uri, item.uri,
            "Item uri should be QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW"
        );
    }

    #[test]
    fn test_get_mapped_item_already_purchased() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());
        let item = init_item();

        // Acting as john now
        let john = AccountId::new_unchecked("john.testnet".to_string());
        let mapped_item = item.get_mapped(&john, Some(vec![item.id]));
        assert_eq!(
            mapped_item.uri, item.uri,
            "Item uri should be QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW"
        );
    }

    #[test]
    fn test_get_mapped_item_not_purchased() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id());
        testing_env!(context.build());
        let item = init_item();

        // Acting as john now
        let john = AccountId::new_unchecked("john.testnet".to_string());
        let mapped_item = item.get_mapped(&john, None);
        assert!(mapped_item.uri.is_none(), "Item uri should be none");
    }
}

'''
'''--- contract/src/lib.rs ---
use crate::item::Item;
use core::panic;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Promise};
use std::convert::TryFrom;
use std::vec;

mod item;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    album: Vec<Item>,
    purchases: LookupMap<AccountId, Vec<u64>>,
}
impl Default for Contract {
    fn default() -> Self {
        Self {
            album: vec![],
            purchases: LookupMap::new(b"p".to_vec()),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_items(&self, account_id: &AccountId) -> Vec<Item> {
        let items = &self.album;
        items
            .iter()
            .map(|item| {
                item.get_mapped(
                    &account_id,
                    Some(self.purchases.get(&account_id).unwrap_or_default()),
                )
            })
            .collect()
    }

    pub fn get_purchased_items(&self, account_id: AccountId) -> Vec<Item> {
        let purchases = self.purchases.get(&account_id).unwrap_or_default();
        let items = &self.album;
        items
            .iter()
            .filter(|item| purchases.contains(&item.id()))
            .cloned()
            .collect()
    }

    pub fn get_own_items(&self, account_id: AccountId) -> Vec<Item> {
        let items = &self.album;
        items
            .iter()
            .filter(|item| item.get_own(&account_id).is_some())
            .cloned()
            .collect()
    }

    #[payable]
    pub fn purchase_item(&mut self, id: u64) -> Item {
        let items = self.album.clone();
        let account_id = env::signer_account_id().clone();
        let item = items
            .iter()
            .find(|item| item.id() == id)
            .expect("Item not found");
        if &account_id == item.owner_account_id() {
            panic!("You own this item");
        }
        let purchases = self.get_purchases(&account_id).unwrap_or_default();
        if purchases.contains(&item.id()) {
            panic!("You already purchased this item");
        }
        let price = item.price();
        let payment = near_sdk::env::attached_deposit();
        if payment >= price.0 {
            let amount_to_send = payment - (payment / 10) as u128;
            self.transfer_funds(&item.owner_account_id(), amount_to_send);
            self.add_to_purchases(&account_id, id);
            //Return item
            item.get_mapped(&account_id, Some(vec![id]))
        } else {
            panic!("Not enough funds {} to pay {}", payment, price.0);
        }
    }

    pub fn create_item(&mut self, price: U128, uri: String, description: Option<String>) -> Item {
        let id = u64::try_from(self.album.len() + 1).unwrap();
        let item = Item::new(id, price, uri, description);

        self.album.push(item.clone());
        // Return created item
        item
    }

    #[private]
    pub fn add_to_purchases(&mut self, account_id: &AccountId, item_id: u64) -> Vec<u64> {
        let mut purchases = self.get_purchases(&account_id).unwrap_or_default();
        purchases.push(item_id);
        self.purchases.insert(&account_id, &purchases);
        self.get_purchases(account_id).unwrap_or_default()
    }

    #[private]
    pub fn transfer_funds(&mut self, account_id: &AccountId, amount: u128) -> Promise {
        Promise::new(account_id.clone()).transfer(amount)
    }

    #[private]
    pub fn get_purchases(&self, account_id: &AccountId) -> Option<Vec<u64>> {
        self.purchases.get(account_id)
    }
}

/**
 *
 * TESTS
 *
 */

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{test_utils::VMContextBuilder, testing_env, AccountId, Gas};

    fn contract_deployer() -> AccountId {
        return AccountId::new_unchecked("contract_deployer.testnet".to_string());
    }

    fn owner_account_id() -> AccountId {
        return AccountId::new_unchecked("alice.testnet".to_string());
    }

    fn buyer_account_id() -> AccountId {
        return AccountId::new_unchecked("john.testnet".to_string());
    }

    // Set mockup context
    fn get_context(signer: &AccountId, deposit: Option<u128>) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.current_account_id(contract_deployer());
        builder.signer_account_id(signer.clone());
        builder.account_balance(100);
        builder.attached_deposit(deposit.unwrap_or(0));
        builder.prepaid_gas(Gas(30_000_000_000_000));
        builder
    }

    #[test]
    fn test_add_item_to_album_upon_create() {
        let item_price = U128(100);
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id(), None);
        testing_env!(context.build());

        let mut contract = Contract::default();
        let _item = contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        assert!(contract.album.len() == 1, "Item created");
    }

    #[test]
    fn test_get_items() {
        let context = get_context(&owner_account_id(), None);
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item_price = U128(10);
        let number_of_items = 5;
        for _ in 0..number_of_items {
            let _item = &contract.create_item(
                item_price,
                "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
                None,
            );
        }
        let items = contract.get_items(&owner_account_id());
        assert_eq!(
            items.len(),
            number_of_items,
            "Not all items have been added"
        );
    }
    // PURCHASES
    #[test]
    #[should_panic]
    fn test_purchase_item_no_deposit() {
        let item_price = U128(100);
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id(), Some(item_price.0));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let _item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );

        // Acting as john now buyer_account_id
        let context = get_context(&buyer_account_id(), None);
        testing_env!(context.build());
        let _purchased_item = &contract.purchase_item(1);
        // Should panic - Not enough funds {deposit} to pay {item.price}
    }

    #[test]
    #[should_panic]
    fn test_purchase_onwed_item() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id(), Some(10));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item = &contract.create_item(
            U128(10),
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        contract.purchase_item(item.id());
        // Should panic - You own this item
    }

    #[test]
    #[should_panic]
    fn test_purchase_non_item() {
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id(), None);
        let mut contract = Contract::default();
        let item_price = U128(100);
        let _item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        testing_env!(context.build());
        // Acting as john now buyer_account_id
        let context = get_context(&buyer_account_id(), Some(item_price.0));
        testing_env!(context.build());

        contract.purchase_item(999);
        // Should panic - Item not found
    }

    #[test]
    #[should_panic]
    fn test_purchase_item_twice() {
        let item_price = U128(10);
        let context = get_context(&owner_account_id(), Some(item_price.0));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        let context = get_context(&buyer_account_id(), Some(item_price.0));
        testing_env!(context.build());
        contract.purchase_item(item.id());
        let _purchased_item = contract.purchase_item(item.id());
        // Should panic - You can't purchase the same item twice
    }

    #[test]
    fn test_purchase_item_added_to_purchases() {
        let item_price = U128(10);
        // Acting as alice now owner_account_id
        let context = get_context(&owner_account_id(), Some(item_price.0));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        // Acting as john now buyer_account_id
        let context = get_context(&buyer_account_id(), Some(item_price.0));
        testing_env!(context.build());
        let _purchased_item = contract.purchase_item(item.id());
        assert!(
            contract
                .get_purchases(&buyer_account_id())
                .unwrap_or_default()
                .contains(&item.id()),
            "Purchased item not added to purchases"
        );
    }

    #[test]
    fn test_purchase_item() {
        let item_price = U128(10);
        let context = get_context(&owner_account_id(), Some(item_price.0));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        let context = get_context(&buyer_account_id(), Some(item_price.0));
        testing_env!(context.build());
        let _purchased_item = contract.purchase_item(item.id());
        assert!(
            contract
                .get_purchases(&buyer_account_id())
                .unwrap_or_default()
                .contains(&item.id()),
            "Item not added to purchases"
        );
    }

    #[test]
    fn test_add_purchased_item() {
        let item_price = U128(10);
        let context = get_context(&owner_account_id(), Some(item_price.0));
        testing_env!(context.build());

        let mut contract = Contract::default();
        let item = &contract.create_item(
            item_price,
            "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
            None,
        );
        contract.add_to_purchases(&owner_account_id(), item.id());

        assert!(
            contract
                .get_purchases(&owner_account_id())
                .unwrap_or_default()
                .len()
                == 1,
            "Item not added to purchases"
        );
    }

    // #[test]
    // fn test_receive_payment_on_purchase() {
    //     // Acting as alice now owner_account_id
    //     let context = get_context(&owner_account_id(), Some(U128(100).0));
    //     testing_env!(context.build());

    //     let item_price = U128(100);
    //     let mut contract = Contract::default();
    //     let item = &contract.create_item(
    //         item_price,
    //         "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
    //         None,
    //     );
    //     log!("item price: {}", item_price.0);
    //     // Acting as john now buyer_account_id
    //     let context = get_context(&buyer_account_id(), Some(U128(1000).0));
    //     testing_env!(context.build());

    //     let initial_balance = env::account_balance();
    //     log!("initial_balance: {}", initial_balance);

    //     let _purchased_item = contract.purchase_item(item.id());

    //     let balance_after_purchase = env::account_balance();
    //     log!("balance after purchase: {}", balance_after_purchase);

    //     assert!(
    //         initial_balance - balance_after_purchase == item_price.0,
    //         "Initial balance {} - Balance after purchase {} must be equal to item price: {}",
    //         initial_balance,
    //         balance_after_purchase,
    //         item_price.0
    //     );
    // }

    // #[test]
    // fn test_transfer_payment_to_owner_on_purchase() {
    //     let item_price = U128(100);
    //     // Acting as alice now owner_account_id
    //     let context = get_context(&owner_account_id(), Some(item_price.0));
    //     testing_env!(context.build());

    //     let mut contract = Contract::default();
    //     let initial_balance = env::account_balance();
    //     let item = &contract.create_item(
    //         item_price,
    //         "QmTxeBMGxE8hkkMEMjpwjd3Yv5jA1mcF3GUpRW5v8cgvxW".to_string(),
    //         None,
    //     );
    //     // Acting as john now buyer_account_id
    //     let context = get_context(&buyer_account_id(), Some(item_price.0));
    //     testing_env!(context.build());
    //     log!("signer id: {}", env::signer_account_id());
    //     log!("initial_balance: {}", env::account_balance());
    //     let _purchased_item = contract.purchase_item(item.id());
    //     log!("after_balance: {}", env::account_balance());
    //     // Acting as alice now owner_account_id
    //     let context = get_context(&owner_account_id(), Some(item_price.0));
    //     testing_env!(context.build());
    //     let balance_after = env::account_balance();
    //     let final_balance = balance_after - initial_balance;
    //     let price_less_percentage = item_price.0 - item_price.0 / 10 as u128;
    //     log!("signer id: {}", env::signer_account_id());
    //     log!("initial_balance: {}", initial_balance);
    //     log!("balance_after: {}", balance_after);
    //     log!("final_balance: {}", final_balance);
    //     log!("price_less_percentage: {}", price_less_percentage);
    //     log!("item_price.0: {}", item_price.0);

    //     assert!(
    //         final_balance == price_less_percentage,
    //         "Purchased item returned"
    //     );
    // }
}

'''