*GitHub Repository "KulaPad/KuLaSmartContract"*

'''--- ido/Cargo.toml ---
[package]
name = "kulapad-ido"
version = "0.0.1"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib","rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ido/TESTING.md ---
# IDO Contract Testing

## Deploy contract
```
near deploy --wasmFile res/kulapad_ido.wasm --accountId ido.testnet --initFunction new --initArgs '{"owner_id": "ido-kulapad.testnet", "staking_contract_id": "token-kulapad.testnet", "test_mode_enabled": true}'

```

### Result
```

```

## Create sample Projects (for testing only)
```
near call dev-1651056695904-82084500074801 create_sample_projects --accountId ido-kulapad.testnet
```

### Result
```
Scheduling a call: dev-1651056695904-82084500074801.create_sample_projects()
Doing account.functionCall()
Transaction Id BK3jCEXAJ2j8XvTKa3Z3x5LPeTsXUbDec86QWKfu56m7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/BK3jCEXAJ2j8XvTKa3Z3x5LPeTsXUbDec86QWKfu56m7
''
```

## Create a new Project
```
near call dev-1651056695904-82084500074801 create_project '{"project": {
"owner_id": "owner_titan.testnet",
"whitelist_start_date": 1640995200000000000,
"whitelist_end_date": 1641250800000000000,
"sale_start_date": 1641254400000000000,
"sale_end_date": 1641340800000000000,
"token_contract_id": "titan.testnet",
"token_raised_amount": "1000000000000000",
"token_sale_rate_numberator": 1,
"token_sale_rate_denominator": 100,
"fund_contract_id": "usn.testnet",
"whitelist_type": "None",
"sale_type": {
	"Shared": {
		"min_allocation_per_user": 5000000000,
		"max_allocation_per_user": 10000000000
	}
},
"distribution_type": "Unlocked"
}}' --accountId ido-kulapad.testnet
```

### Result
```
Scheduling a call: dev-1651056695904-82084500074801.create_project({"project": {
"owner_id": "owner_titan.testnet",
"whitelist_start_date": 1640995200000000000,
"whitelist_end_date": 1641250800000000000,
"sale_start_date": 1641254400000000000,
"sale_end_date": 1641340800000000000,
"token_contract_id": "titan.testnet",
"token_raised_amount": "1000000000000000",
"token_sale_rate_numberator": 1,
"token_sale_rate_denominator": 100,
"fund_contract_id": "usn.testnet",
"whitelist_type": "None",
"sale_type": {
    "Shared": {
        "min_allocation_per_user": 5000000000,
        "max_allocation_per_user": 5000000000
    }
},
"distribution_type": "Unlocked"
}})
Doing account.functionCall()
Retrying request to broadcast_tx_commit as it has timed out [
  'EwAAAGlkby1rdWxhcGFkLnRlc3RuZXQAdC8UmrdUSHsndkCrjoDJHAG62JhFEO2pFjA1L7YoR+SfwqdfyEwAACAAAABkZXYtMTY1MTA1NjY5NTkwNC04MjA4NDUwMDA3NDgwMWexmEbAzCr310fIdzJ1D1etHkJF9iH99n1/IUy4wNqIAQAAAAIOAAAAY3JlYXRlX3Byb2plY3QVAgAAeyJwcm9qZWN0Ijp7Im93bmVyX2lkIjoib3duZXJfdGl0YW4udGVzdG5ldCIsIndoaXRlbGlzdF9zdGFydF9kYXRlIjoxNjQwOTk1MjAwMDAwMDAwMDAwLCJ3aGl0ZWxpc3RfZW5kX2RhdGUiOjE2NDEyNTA4MDAwMDAwMDAwMDAsInNhbGVfc3RhcnRfZGF0ZSI6MTY0MTI1NDQwMDAwMDAwMDAwMCwic2FsZV9lbmRfZGF0ZSI6MTY0MTM0MDgwMDAwMDAwMDAwMCwidG9rZW5fY29udHJhY3RfaWQiOiJ0aXRhbi50ZXN0bmV0IiwidG9rZW5fcmFpc2VkX2Ftb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAiLCJ0b2tlbl9zYWxlX3JhdGVfbnVtYmVyYXRvciI6MSwidG9rZW5fc2FsZV9yYXRlX2Rlbm9taW5hdG9yIjoxMDAsImZ1bmRfY29udHJhY3RfaWQiOiJ1c24udGVzdG5ldCIsIndoaXRlbGlzdF90eXBlIjoiTm9uZSIsInNhbGVfdHlwZSI6eyJTaGFyZWQiOnsibWluX2FsbG9jYXRpb25fcGVyX3VzZXIiOjUwMDAwMDAwMDAsIm1heF9hbGxvY2F0aW9uX3Blcl91c2VyIjo1MDAwMDAwMDAwfX0sImRpc3RyaWJ1dGlvbl90eXBlIjoiVW5sb2NrZWQifX0A4FfrSBsAAAAAAAAAAAAAAAAAAAAAAAAA8rS00kgxM6DfWCgS8YT2bdF1mSFjzSZnH68sc4Rr2NXNsbPEKALqv6vjtXFB/WsbrFIAWLDCzCZio59EhAKJAg=='
]
Transaction Id 8GGyxFVTEiYyrHcpv8S87FytD1jEE4LnhfazzD3RV4aE
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8GGyxFVTEiYyrHcpv8S87FytD1jEE4LnhfazzD3RV4aE
2
```

## Get a Project
```
near view dev-1651056695904-82084500074801 get_project '{"project_id": 1}'
```

### Result
```
View call: dev-1651056695904-82084500074801.get_project({"project_id": 1})
{
  id: 1,
  whitelist_start_date: 1640995200000000000,
  whitelist_end_date: 1641250800000000000,
  sale_start_date: 1641254400000000000,
  sale_end_date: 1641340800000000000,
  token_contract_id: 'titan.testnet',
  token_raised_amount: '1000000000000000',
  token_sale_rate: 10,
  fund_contract_id: 'usn.testnet',
  total_fund_committed: '0',
  hard_cap: '10000000000000000',
  whitelist_accounts: 0,
  status: 'Preparation',
  whitelist_type: 'None',
  sale_type: {
    Shared: {
      min_allocation_per_user: 5000000000,
      max_allocation_per_user: 10000000000
    }
  },
  distribution_type: 'Unlocked'
}
```

## Get Project Account Info
```
near call dev-1651056695904-82084500074801 get_project_account_info '{"project_id": 1}' --accountId dev-1651056695904-82084500074801
```

### Result
```
Scheduling a call: dev-1651056695904-82084500074801.get_project_account_info({"project_id": 1})
Doing account.functionCall()
Transaction Id 3xogsUEpj2CNRXtfQU8nWpQM8J8rkqX4y7ZVCA3b7Nem
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/3xogsUEpj2CNRXtfQU8nWpQM8J8rkqX4y7ZVCA3b7Nem
{
  project_id: 1,
  account_id: 'dev-1651056695904-82084500074801',
  is_whitelist: false,
  sale_data: null,
  distribution_data: null
}
```
'''
'''--- ido/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/kulapad_ido.wasm ../res

read -p "Press any key to continue..."
'''
'''--- ido/deploy.sh ---
cd ..
# near deploy --wasmFile res/kulapad_ido.wasm --accountId v4-ido-kulapad.testnet --initFunction new --initArgs '{"owner_id": "v4-ido-kulapad.testnet", "staking_contract_id": "token-kulapad.testnet", "test_mode_enabled": true}'

near deploy --wasmFile res/kulapad_ido.wasm --accountId v4-ido-kulapad.testnet

read -p "Press any key to continue..."
'''
'''--- ido/dev-deploy.sh ---
cd ..

near dev-deploy --wasmFile res/kulapad_ido.wasm --initFunction new --initArgs '{"owner_id": "ido-kulapad.testnet", "staking_contract_id": "token-kulapad.testnet", "test_mode_enabled": true}'

read -p "Press any key to continue..."
'''
'''--- ido/migrate.sh ---
cd ..

near deploy --wasmFile res/kulapad_ido.wasm --accountId ido-kulapad.testnet --initFunction migrate --initArgs '{"owner_id": "ido-kulapad.testnet"}'

read -p "Press any key to continue..."
'''
'''--- ido/src/ft_contract.rs ---
use near_sdk::Gas;

use crate::*;

pub const FT_TRANSFER_GAS: Gas = 10_000_000_000_000;
pub const TRANSFER_CALLBACK_GAS: Gas = 10_000_000_000_000;

pub const DEPOSIT_ONE_YOCTOR: Balance = 1;

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[ext_contract(ext_self)]
pub trait ExtStakingContract {
    fn ft_transfer_callback(&mut self, project_id: ProjectId, account_id: AccountId, claim_amount: U128);
}

// Firstly, user must call ft_transfer_call function from ft contract.
// Ft contract will send ft_on_transfer function to ido_contract
// This function will get msg from ft_transfer_call, handle it for getting deposit_amount, and do commit sale
// Example of msg will be: "project_id":1
pub trait IDOContractResolver{
    fn ft_on_transfer(&mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String
        )-> PromiseOrValue<U128>;
}

#[near_bindgen]
impl IDOContract {
    /// User can claim their bought unlocked token after sales.
    #[payable]
    pub fn claim(&mut self, project_id: ProjectId) -> Promise {
        let account_id: AccountId = env::predecessor_account_id();
        let project = self.internal_get_project_or_panic(project_id);
        assert!(project.is_in_distribution_period(), "The project isn't in distribution period.");

        assert_one_yocto();
        let claim_amount = self.internal_claim(project_id, &account_id);

        // TODO: Update the claimed amount in the project_account before starting to transfer token to user.
        // If the cross-call transaction failed, it's need to roll back the data that was updated.
        
        // handle transfer withdraw
        ext_ft_contract::ft_transfer(
            account_id.clone(), 
            U128(claim_amount), 
            Some(format!("Claim the amount of {} on contract {} from IDO Contract", claim_amount, project.token_contract_id)), 
            &project.token_contract_id, 
            DEPOSIT_ONE_YOCTOR, 
            FT_TRANSFER_GAS
        ).then(
            ext_self::ft_transfer_callback(
                project_id,
                account_id.clone(),
                U128(claim_amount),
                &env::current_account_id(),
                NO_DEPOSIT, 
                TRANSFER_CALLBACK_GAS
            )
        )
    }

    #[private]
    pub fn ft_transfer_callback(&mut self, project_id: ProjectId, account_id: AccountId, claim_amount: U128) -> U128 {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_value) => {
                let mut project_account_unordered_map = self.internal_get_accounts_by_project_or_panic(project_id);
                let mut project_account_1 = self.internal_get_account_by_project_or_panic(project_id,&account_id);
                let mut project_account_2 = self.internal_get_account_by_project_or_panic(project_id,&account_id);
                let account_distribution = project_account_1.distribution_data;
                if let Some(mut account_distribution) = account_distribution{
                    account_distribution.claimed_amount += claim_amount.0;
                    project_account_1.distribution_data = Some(account_distribution);
                    project_account_unordered_map.insert(&account_id,&project_account_1);
                    self.accounts_by_project.insert(&project_id,&project_account_unordered_map);
                } else {
                    let mut account_sale = project_account_2.sale_data.unwrap();
                    account_sale.committed_amount = 0;
                    project_account_2.sale_data = Some(account_sale);
                    project_account_unordered_map.insert(&account_id,&project_account_2);
                    self.accounts_by_project.insert(&project_id,&project_account_unordered_map);
                }
                
                U128::from(0)
            },
            PromiseResult::Failed => env::panic(b"ERR_CALL_FAILED"),
        }
    }

    pub(crate) fn internal_claim(&mut self, project_id: ProjectId, account_id: &AccountId) -> Balance{
        // Get deposit token amount and project_ft_contract_id
        let project_account = self.internal_get_account_by_project_or_panic(project_id,&account_id);
        let sale_data = project_account.sale_data.unwrap();
        let distribution_data = project_account.distribution_data;
        // Calculate token to transfer for user
        let claim_amount = if let Some(distribution_data) = distribution_data {
            distribution_data.unlocked_amount - distribution_data.claimed_amount
        } else {
            sale_data.committed_amount
        };
        
        claim_amount 
    }

    pub fn ft_on_transfer(&mut self,sender_id: AccountId,amount: U128,msg: String)-> PromiseOrValue<U128>{
        let args: Vec<&str> = msg.split(":").collect();
        if args.len() >= 1 {
            match args[0] {
                "project_id" => {
                    let project_id : ProjectId = args[1].trim().parse::<u64>().unwrap();
                    let project = self.internal_get_project_or_panic(project_id);
                    let fund_contract_id = env::predecessor_account_id();
                    if project.fund_contract_id == fund_contract_id{ 
                        env::log(format!("Ft on transfer success: project_id={},sender_id={},amount={},fund_contract_id={}", project_id, sender_id, amount.0,env::predecessor_account_id()).as_bytes());
                        let committed = self.internal_commit(project_id, &sender_id, amount.0);
                        return PromiseOrValue::Value(U128(amount.0 - committed));
                    } else {
                        env::log(b"Transfer Error: fund_contract_id not match. Transfer back deposited token to signer");
                        return PromiseOrValue::Value(amount);
                    }
                },
                _ => {
                    env::log(b"Transfer Error: Unknown message sent");
                    return PromiseOrValue::Value(amount);
                }
            }
        }
         
        
        PromiseOrValue::Value(U128(0))
    }
}
'''
'''--- ido/src/lib.rs ---
use near_sdk::{init, env, near_bindgen, ext_contract};
use near_sdk::{PanicOnDefault, Timestamp, Balance, AccountId, CryptoHash, Promise, PromiseOrValue, PromiseResult, EpochHeight};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet, LookupMap};
use near_sdk::env::signer_account_id;
use near_sdk::json_types::{U128, U64};
use std::collections::HashMap;

pub type ProjectId = u64;
pub type AllocationNumber = u32;
pub type TicketNumber = u64;
pub type TicketId = u64;
pub type ProjectAccountUnorderedMap = UnorderedMap<AccountId, ProjectAccount>;
pub type TicketAndAccountLookupMap = LookupMap<TicketId, AccountId>;
pub type ProjectIdUnorderedSet = UnorderedSet<ProjectId>;

use crate::modules::project::*;
use crate::modules::account::*;
use crate::utils::*;
use crate::staking_contract::*;
use crate::ft_contract::*;
use crate::modules::tier::{Tier, TierConfig, TierConfigsType, UserTierJson};

pub mod modules;
mod utils;
mod tests;
pub mod staking_contract;
mod ft_contract;

pub const DEFAULT_PAGE_SIZE: u64 = 100;
pub const TOKEN_DECIMAL: u8 = 8;

pub const GAS_FUNCTION_CALL: u64 = 5_000_000_000_000;
pub const GAS_FUNCTION_CALL_UPDATE_STAKING_TIER: u64 = 50_000_000_000_000;
pub const GAS_FUNCTION_CALL_GET_USER_POINT: u64 = 50_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum StorageKey {
    FundingTokenIdKey,
    ProjectKey,
    AccountsByProjectKey,
    AccountsByProjectInnerKey(ProjectId),
    TicketsByProjectKey,
    TicketsByProjectInnerKey(ProjectId),
    ProjectsByAccountKey,
    ProjectsByAccountInnerKey {
        account_id_hash: CryptoHash
    },
    TierKey,
    TierTicketInnerKey (String),
    TierAllocationInnerKey (String),
    TierConfigsKey,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// the config for each user Tier
    pub tier_configs: TierConfigsType,
}

impl Config {
    fn new_default_config() -> Self {
        Self {
            tier_configs: TierConfig::get_default_tier_configs(),
        }
    }

    fn new(
        tier_configs: TierConfigsType,
    ) -> Self {
        Self {
            tier_configs,
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new_default_config()
    }
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct IDOContract{
    /// The owner of this contract.
    pub owner_id: AccountId,

    /// The account id of staking contract. It used for cross-contract call
    pub staking_contract_id: AccountId,

    /// The list of token id that allows to buy an IDO project.
    pub funding_ft_token_ids: UnorderedSet<AccountId>,

    /// Stores the list of projects that belongs to this IDO contract.
    pub projects: UnorderedMap<ProjectId, Project>,

    /// Stores the list of accounts for each project.
    /// Each account contains the Sale and Distribution data.
    pub accounts_by_project: LookupMap<ProjectId, ProjectAccountUnorderedMap>,

    /// Stores the list of tickets that belongs to each project.
    /// Ex: Project 1: Tickets [{Id: L1, Account Id: account1.testnet }, {Id: S2, Account Id: account2.testnet }, ...]
    /// The user tickets were stored here during re-calculate
    pub tickets_by_project: LookupMap<ProjectId, TicketAndAccountLookupMap>,

    /// The list of projects that that account has registered whitelist.
    pub projects_by_account: LookupMap<AccountId, ProjectIdUnorderedSet>,

    /// The information of tiers that helps to identify the number of tickets to allocation to a specific user when they joined to a project
    //pub tiers: UnorderedMap<Tier, TierInfo>,

    pub test_mode_enabled: bool,

    pub config: Config,
}

#[near_bindgen]
impl IDOContract {
    #[init]
    pub fn new_with_default_config(owner_id: AccountId, staking_contract_id: AccountId, funding_ft_token_ids: Option<Vec<AccountId>>, test_mode_enabled: Option<bool>) -> Self {
        Self::new(owner_id, staking_contract_id, funding_ft_token_ids, test_mode_enabled, None)
    }

    #[init]
    pub fn new(owner_id: AccountId, staking_contract_id: AccountId, funding_ft_token_ids: Option<Vec<AccountId>>, test_mode_enabled: Option<bool>, config: Option<Config>) -> Self {
        env::log(format!("Creating contract...").as_bytes());
        let mut contract = Self {
            owner_id,
            staking_contract_id,
            funding_ft_token_ids: UnorderedSet::new(get_storage_key(StorageKey::FundingTokenIdKey)),
            projects: UnorderedMap::new(get_storage_key(StorageKey::ProjectKey)),
            accounts_by_project: LookupMap::new(get_storage_key(StorageKey::AccountsByProjectKey)),
            tickets_by_project: LookupMap::new(get_storage_key(StorageKey::TicketsByProjectKey)),
            projects_by_account: LookupMap::new(get_storage_key(StorageKey::ProjectsByAccountKey)),
            test_mode_enabled: test_mode_enabled.unwrap_or(true),
            config: config.unwrap_or(Config::default()),
        };

        if let Some(funding_ft_token_ids) = funding_ft_token_ids {
            for i in 0..funding_ft_token_ids.len() {
                contract.funding_ft_token_ids.insert(&funding_ft_token_ids[i]);
            }
        }

        contract
    }

    // Owner functions

    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn set_owner_id(&mut self, owner_id: AccountId) {
        assert_eq!(env::signer_account_id(), self.owner_id, "Just owner can do this action.");

        self.owner_id = owner_id;
    }

    // Project call functions

    pub fn create_project(&mut self, project: ProjectInput) -> ProjectId{
        self.internal_create_project(Project::from(project))
    }

    pub fn change_project_status(&mut self, project_id: ProjectId) {
        self.internal_change_project_status(project_id);
    }

    // Project view functions

    pub fn get_projects(&self, status: Option<ProjectStatus>, from_index: Option<u64>, limit: Option<u64>) -> Vec<ProjectJson>{
        self.projects
        .iter()
        .filter(|(_, project)| match &status { None => true, Some(s) => &project.status == s })
        .skip(from_index.unwrap_or(0) as usize)
        .take(limit.unwrap_or(DEFAULT_PAGE_SIZE) as usize)
        .map(|(project_id, project)| self.internal_get_project(project_id, Some(project)).unwrap())
        .collect()
    }

    pub fn get_project(&self, project_id: ProjectId) -> Option<ProjectJson> {
        let project = self.projects.get(&project_id);

        self.internal_get_project(project_id, project)
    }

    pub fn get_project_account_info(&self, project_id: ProjectId, account_id: AccountId) -> ProjectAccountJson {
        self.internal_get_project_account_info(project_id, account_id)
    }

    // Project Whitelist

    /// Register an account for a project's whitelist
    /// User can only register the whitelist on the whitelist period of the project
    pub fn register_whitelist(&mut self, project_id: ProjectId) {
        let account_id = env::signer_account_id();
        self.internal_register_whitelist(account_id,project_id);
    }

    /// Check an account wherever registered for a project or not
    pub fn is_whitelist(&self, project_id: ProjectId, account_id: AccountId) -> bool {
        self.assert_project_exist(project_id);

        let projects_in_account = self.projects_by_account.get(&account_id);

        if let Some(projects_in_account) = projects_in_account {
            if projects_in_account.contains(&project_id){
                return true;
            }
        }

        false
    }

    // Project Sale

    pub fn update_staking_tickets(&mut self, project_id: ProjectId) -> PromiseOrValue<bool> {
        let account_id = env::signer_account_id();

        // Verify project & account before calling to staking smart contrct
        let project = self.projects.get(&project_id);
        if let Some(project) = project {
            project.assert_whitelist_period();

            // Start processing
            return self.internal_update_staking_tickets(project_id, account_id);
        }

        panic_project_not_exist();
        PromiseOrValue::Value(false)
    }

    pub fn close_project_whitelist(&mut self, project_id: ProjectId) {
        println!("close_project_whitelist - inside");
        // Get project
        let mut project = self.internal_get_project_or_panic(project_id);
        let current_time = get_current_time();

        println!("close_project_whitelist - get_current_time");
        // Validate & update status to Sale ->
        assert!(project.status == ProjectStatus::Whitelist && project.whitelist_end_date <= current_time, "{}", format!("The project's status ({:?}) is not correct or the whitelist period (End: {} - Current: {}) is not end.", project.status, project.whitelist_end_date, current_time));

        // TODO

        println!("close_project_whitelist - end of for");

        project.status = ProjectStatus::Sales;
        self.projects.insert(&project_id, &project);
    }
    #[payable]
    pub fn commit(&mut self, project_id: ProjectId){
        let project = self.internal_get_project_or_panic(project_id);
        let deposit_amount = env::attached_deposit();
        let account_id = env::signer_account_id();
        if project.fund_contract_id == ""{
            let committed = self.internal_commit(project_id, &account_id, deposit_amount);
            Promise::new(account_id).transfer(deposit_amount - committed);
        } else {
            Promise::new(account_id).transfer(deposit_amount);
            env::log(b"Incorrect fund_contract_id");
        }   
    }
    /// get UserTierJson: tier, point, ticket, alloc
    pub fn get_user_tier_info(&self) -> UserTierJson {
        let user: AccountId = env::predecessor_account_id();
        UserTierJson::default()
    }
}

'''
'''--- ido/src/modules.rs ---
use crate::*;

pub mod testing;
pub mod project;
pub mod account;
pub mod tier;
'''
'''--- ido/src/modules/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug)]
pub struct LotteryAccountSaleData {
    /// The number of eligible ticket. Ex: 10
    pub eligible_tickets: TicketNumber,
    /// The number of ticket that user commits to join. Ex 1 -> 10
    pub deposit_tickets: TicketNumber,
    /// When user deposit fund to get the deposit ticket, the list of ticket would be generated based on the deposit order of the user.
    pub ticket_ids: Vec<TicketNumber>,
    /// The list of win tickets
    pub win_ticket_ids: Vec<TicketNumber>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
pub enum AccountSaleData {
    Shared,
    Lottery(LotteryAccountSaleData),
}

impl Default for AccountSaleData {
    fn default() -> Self {
        AccountSaleData::Shared
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Default)]
pub struct AccountSale {
    pub committed_amount: Balance,
    pub sale_data: AccountSaleData,
}

#[derive(Serialize, Deserialize, PartialEq,Debug)]
pub struct AccountSaleJson {
    pub committed_amount: U128,
    // This property is used for AccountSaleData::Lottery only.
    pub lottery_sale_data: Option<LotteryAccountSaleData>,
}

impl AccountSaleJson {
    pub fn from(account_sale: AccountSale) -> Self {
        Self {
            committed_amount: U128::from(account_sale.committed_amount),
            lottery_sale_data: match account_sale.sale_data {
                AccountSaleData::Shared => None,
                AccountSaleData::Lottery(data) => Some(data),
            },
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Default)]
pub struct AccountDistribution {
    pub unlocked_amount: Balance,
    pub locked_amount: Balance,
    pub claimed_amount: Balance,
}

#[derive(Serialize, Deserialize,Debug)]
pub struct AccountDistributionJson {
    pub unlocked_amount: U128,
    pub locked_amount: U128,
    pub claimed_amount: U128,
}

impl AccountDistributionJson {
    fn from(account_distribution: AccountDistribution) -> Self {
        Self {
            unlocked_amount: U128::from(account_distribution.unlocked_amount),
            locked_amount: U128::from(account_distribution.locked_amount),
            claimed_amount: U128::from(account_distribution.claimed_amount),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Default)]
pub struct ProjectAccount {
    pub sale_data: Option<AccountSale>,
    pub distribution_data: Option<AccountDistribution>,
}

#[derive(Serialize, Deserialize, Default,Debug)]
pub struct ProjectAccountJson {
    pub project_id: ProjectId,
    pub account_id: AccountId,
    pub is_whitelist: bool,
    pub sale_data: Option<AccountSaleJson>,
    pub distribution_data: Option<AccountDistributionJson>,
}

impl IDOContract {
    pub(crate) fn internal_get_project_account_info(&self, project_id: ProjectId, account_id: AccountId) -> ProjectAccountJson {
        let mut account_json = ProjectAccountJson {
            project_id,
            account_id: account_id.clone(),
            is_whitelist: false,
            sale_data: None,
            distribution_data: None,
        };
        
        // Get project by id
        let project = self.internal_get_project_or_panic(project_id);

        if project.status == ProjectStatus::Preparation {
            return account_json;
        }

        // If the user account doesn't exist in the project that means the user has not registered yet.
        let account = self.internal_get_account_by_project(project_id, &account_id);
        if account.is_none() {
            return account_json;
        }

        if let Some(account) = account {
            account_json.is_whitelist = true;
            
            if let Some(sale_data) = account.sale_data {
                account_json.sale_data = Some(AccountSaleJson::from(sale_data));
            }

            if let Some(distribution_data) = account.distribution_data {
                account_json.distribution_data = Some(AccountDistributionJson::from(distribution_data));
            }
        }

        account_json
    }
}
'''
'''--- ido/src/modules/project.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug, PartialEq, Clone)]
pub enum ProjectStatus {
    Preparation,
    Whitelist,
    Sales,
    Distribution,
}

impl Default for ProjectStatus {
    fn default() -> Self { ProjectStatus::Preparation }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug)]
pub enum WhitelistType {
    None,
    XToken(Balance),
    Ticket
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug)]
pub enum SaleType {
    Shared {
        min_allocation_per_user: Balance,
        max_allocation_per_user: Balance,
    },
    Lottery {
        allocation_per_ticket: Balance,
        total_tickets: TicketNumber,
        win_ticket_ids: Option<Vec<TicketNumber>>,
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug)]
pub enum DistributionType {
    Unlocked,
    Vested
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
pub struct Rate {
    numberator: u64,
    denominator: u64,
}

impl Rate {
    pub(crate) fn new(numberator: u64, denominator: u64) -> Self {
        Self {
            numberator,
            denominator,
        }
    }

    pub(crate) fn multiply(&self, amount: u128) -> u128 {
        amount * self.numberator as u128 / self.denominator as u128
    }

    pub(crate) fn devided_by(&self, amount: u128) -> u128 {
        amount * self.denominator as u128 / self.numberator as u128
    }

    pub(crate) fn get_rate(&self) -> f64 {
        self.numberator as f64 / self.denominator as f64
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
pub struct Project {
    pub owner_id: AccountId,

    pub whitelist_start_date: Timestamp,
    pub whitelist_end_date: Timestamp,
    pub sale_start_date: Timestamp,
    pub sale_end_date: Timestamp,

    /// your.near
    pub token_contract_id: AccountId,
    /// The amount of tokens to be sold in this campaign like: 30.000.000 TOKEN
    pub token_raised_amount: Balance,
    /// The price of a token like: 0.01 (NEAR) / 1 TOKEN => numberator: 1, denominator: 100
    pub token_sale_rate: Rate,

    /// None
    pub fund_contract_id: AccountId,
    /// The total fund that users deposited to buy token
    pub total_fund_committed: Balance,

    pub status: ProjectStatus,
    pub whitelist_type: WhitelistType,
    pub sale_type: SaleType,
    pub distribution_type: DistributionType,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ProjectInput {
    pub owner_id: AccountId,

    pub whitelist_start_date: Timestamp,
    pub whitelist_end_date: Timestamp,
    pub sale_start_date: Timestamp,
    pub sale_end_date: Timestamp,

    pub token_contract_id: AccountId,
    pub token_raised_amount: U128,
    pub token_sale_rate_numberator: u64,
    pub token_sale_rate_denominator: u64,

    pub fund_contract_id: AccountId,
    
    pub whitelist_type: WhitelistType,
    pub sale_type: SaleType,
    pub distribution_type: DistributionType,
}

#[derive(Serialize, Deserialize,Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProjectJson {
    pub id: ProjectId,
    pub whitelist_start_date: Timestamp,
    pub whitelist_end_date: Timestamp,
    pub sale_start_date: Timestamp,
    pub sale_end_date: Timestamp,

    pub token_contract_id: AccountId,
    pub token_raised_amount: U128,
    pub token_sale_rate: f64,

    pub fund_contract_id: AccountId,
    pub total_fund_committed: U128,
    pub hard_cap: U128,
    pub whitelist_accounts: u64,

    pub status: ProjectStatus,
    pub whitelist_type: WhitelistType,
    pub sale_type: SaleType,
    pub distribution_type: DistributionType,
}

// Project functions
impl Project {
    pub fn from(project: ProjectInput) -> Project {
        Self {
            owner_id: project.owner_id.clone(),
            whitelist_start_date: project.whitelist_start_date,
            whitelist_end_date: project.whitelist_end_date,
            sale_start_date: project.sale_start_date,
            sale_end_date: project.sale_end_date,
            token_contract_id: project.token_contract_id.clone(),
            token_raised_amount: project.token_raised_amount.0,
            token_sale_rate: Rate {
                numberator: project.token_sale_rate_numberator,
                denominator: project.token_sale_rate_denominator,
            },
            fund_contract_id: project.fund_contract_id.clone(),
            total_fund_committed: 0,
            status: ProjectStatus::Preparation,
            whitelist_type: project.whitelist_type,
            sale_type: project.sale_type,
            distribution_type: project.distribution_type,
        }
    }

    pub(crate) fn assert_whitelist_period(&self) {
        assert!(self.is_in_whitelist_period(), "Project isn't in whitelist period.");
    }

    pub(crate) fn assert_sale_period(&self) {
        assert!(self.is_in_sale_period(), "Project isn't in sale period.");
    }
    
    pub(crate) fn is_in_whitelist_period(&self) -> bool {
        let current_time = get_current_time();
        self.status == ProjectStatus::Whitelist && self.whitelist_start_date <= current_time && current_time <= self.whitelist_end_date
    }

    pub(crate) fn is_in_sale_period(&self) -> bool {
        let current_time = get_current_time();
        self.status == ProjectStatus::Sales && self.sale_start_date <= current_time && current_time <= self.sale_end_date
    }

    pub(crate) fn is_in_distribution_period(&self) -> bool {
        let current_time = get_current_time();
        self.status == ProjectStatus::Distribution && self.sale_end_date <= current_time
    }

    pub(crate) fn get_hard_cap(&self) -> Balance {
        self.token_sale_rate.multiply(self.token_raised_amount)
    }
}

// Internal functions
impl IDOContract {
    // Assert & Get or panic functions
    pub(crate) fn assert_project_exist(&self, project_id: ProjectId) {
        assert!(self.internal_has_project(project_id), "Project does not exist.");
    }

    // Projects

    pub(crate) fn internal_get_project_or_panic(&self, project_id: ProjectId) -> Project {
        self.projects.get(&project_id).expect("Project does not exist.")
    }

    // Accounts by Project

    pub(crate) fn internal_get_accounts_by_project_or_panic(&self, project_id: ProjectId) -> ProjectAccountUnorderedMap {
        self.accounts_by_project.get(&project_id).expect("Project account tickets do not exist.")
    }

    pub(crate) fn internal_get_account_by_project_or_panic(&self, project_id: ProjectId, account_id: &AccountId) -> ProjectAccount {
        self.internal_get_accounts_by_project_or_panic(project_id).get(&account_id).expect("The account doesn't belong to the project.")
    }

    pub(crate) fn internal_get_account_by_project(&self, project_id: ProjectId, account_id: &AccountId) -> Option<ProjectAccount> {
        self.internal_get_accounts_by_project_or_panic(project_id).get(&account_id)
    }
  
    // Projects by Account
  
    pub(crate) fn internal_get_projects_by_account_or_default(&self, account_id: &AccountId)
        -> ProjectIdUnorderedSet {
            self.projects_by_account
                .get(&account_id)
                .unwrap_or_else(|| {
                    UnorderedSet::new(
                        get_storage_key(StorageKey::ProjectsByAccountInnerKey{
                            account_id_hash: hash_account_id(&account_id)
                        })
                    )
                })
    }

    // Tickets by Project

    pub(crate) fn internal_get_tickets_by_project_or_panic(&self, project_id: ProjectId) -> TicketAndAccountLookupMap {
        self.tickets_by_project.get(&project_id).expect("Project tickets do not exist.")
    }

    // Create and modify project

    pub(crate) fn internal_create_project(&mut self, project: Project) -> ProjectId{
        // Get next Id
        let project_id = self.projects.len() + 1;

        // Insert the project
        self.projects.insert(&project_id, &project);

        // Insert this project to related variables, this should be done by each status
        self.accounts_by_project.insert(&project_id, &UnorderedMap::new(get_storage_key(StorageKey::AccountsByProjectInnerKey(project_id)))); 
        self.tickets_by_project.insert(&project_id, &LookupMap::new(get_storage_key(StorageKey::TicketsByProjectInnerKey(project_id)))); 
        
        project_id
    }

    pub(crate) fn internal_change_project_status(&mut self, project_id: ProjectId) {
        let mut project = self.internal_get_project_or_panic(project_id);
        let current_time = get_current_time();
        match project.status {
            ProjectStatus::Preparation => {
                assert!(project.whitelist_start_date <= current_time && current_time <= project.whitelist_end_date, "Cannot change project's status to Whitelist");
                project.status = ProjectStatus::Whitelist;
            },
            ProjectStatus::Whitelist => {
                assert!(project.whitelist_end_date <= current_time,
                        "{}", format!("The whitelist period (End: {} - Current: {}) is not end.",
                        project.whitelist_end_date, current_time));
                project.status = ProjectStatus::Sales;
            }
            ProjectStatus::Sales => {
                assert!(project.sale_end_date < current_time, "Cannot change project's status to Distribution.");
                project.status = ProjectStatus::Distribution;
                self.internal_distribute_token_to_users(project_id);
            }
            _ => panic!("Unable to change project status.")
        }

        // Update project
        self.projects.insert(&project_id, &project);
    }

    // Project Json

    pub(crate) fn internal_get_project(&self, project_id: ProjectId, project: Option<Project>) -> Option<ProjectJson> {
        if let Some(project) = project {
            let whitelist_accounts = self.internal_get_accounts_by_project_or_panic(project_id).len();

            Some(ProjectJson {
                id: project_id,
                
                whitelist_start_date: project.whitelist_start_date,
                whitelist_end_date: project.whitelist_end_date,
                sale_start_date: project.sale_start_date,
                sale_end_date: project.sale_end_date,
                
                token_contract_id: project.token_contract_id.clone(),
                token_raised_amount: U128(project.token_raised_amount),
                token_sale_rate: project.token_sale_rate.get_rate(),
                
                fund_contract_id: project.fund_contract_id.clone(),
                total_fund_committed: U128::from(project.total_fund_committed),
                hard_cap: U128::from(project.get_hard_cap()),
                whitelist_accounts: whitelist_accounts,

                status: project.status,
                whitelist_type: project.whitelist_type,
                sale_type: project.sale_type,
                distribution_type: project.distribution_type,
            })
        } else {
            None
        }
    }

    pub(crate) fn internal_has_project(&self, project_id: ProjectId) -> bool{
        self.projects.get(&project_id).is_some()
    }
    
    // Project Whitelist
    // If project has no whitelist type or the whitelist type is ticket, 
    // user can register whitelist without any requires.
    // If project's whitelist type is fixed Xtoken, 
    // need to check user has enough xtoken or not.
    
    pub(crate) fn internal_add_account(&mut self, account_id: &AccountId, project_id: ProjectId){

        let mut projects_by_account = self.internal_get_projects_by_account_or_default(account_id);

        assert!(!projects_by_account.contains(&project_id),"Already register whitelist this project");
        projects_by_account.insert(&project_id);

        self.projects_by_account.insert(account_id, &projects_by_account);

        // Insert into accounts_by_project -> Use unwrap because of making sure that it has been inserted when project created.
        let mut accounts_in_project = self.accounts_by_project.get(&project_id).unwrap();
        accounts_in_project.insert(account_id, &ProjectAccount::default());
        self.accounts_by_project.insert(&project_id, &accounts_in_project);
    }
    
    pub fn internal_register_whitelist(&mut self, account_id: AccountId,project_id: ProjectId) {
        let project = self.internal_get_project_or_panic(project_id);                       
        assert_eq!(project.status, ProjectStatus::Whitelist,"Project isn't on whitelist");
        assert!(project.is_in_whitelist_period(), "Project isn't on whitelist time");
        

        match project.whitelist_type {
            WhitelistType::None | WhitelistType::Ticket  =>{ 
                self.internal_add_account(&account_id, project_id);
            },
            WhitelistType::XToken(xtoken) => {
                self.internal_register_whitelist_fixed_xtoken_project(project_id, account_id, xtoken);
            },
        };
    }

    // Project Sale
    pub(crate) fn internal_commit(&mut self, project_id: ProjectId, account_id: &AccountId, amount: Balance) -> Balance{
        
        let project = self.internal_get_project_or_panic(project_id);                         
                
        assert!(self.is_whitelist(project_id,account_id.to_string()),"Account does not register whitelisting this project");
        project.assert_sale_period();
                  
        match project.sale_type {
            SaleType::Shared { 
                min_allocation_per_user, 
                max_allocation_per_user
            } => {
                    self.internal_commit_shared_project(min_allocation_per_user, 
                                                                    max_allocation_per_user,
                                                                    project_id,
                                                                    account_id,
                                                                    amount)
                },
            SaleType::Lottery { 
                allocation_per_ticket, 
                total_tickets, 
                win_ticket_ids } => {
                    self.internal_commit_lottery_project(allocation_per_ticket,
                                                            total_tickets,
                                                            win_ticket_ids,
                                                            project_id,
                                                            account_id,
                                                            amount,
                                                            )
                }
        }
    }
    
    pub(crate) fn internal_commit_shared_project(&mut self,
        min_allocation: u128, 
        max_allocation: u128,
        project_id: ProjectId, 
        account_id: &AccountId, 
        deposit: u128)-> Balance {
            // Update Project struct
            let mut project_account_unordered_map = self.internal_get_accounts_by_project_or_panic(project_id);
            let mut project_account = self.internal_get_account_by_project_or_panic(project_id,&account_id);
            let mut project = self.internal_get_project_or_panic(project_id);
            let mut account_sale = project_account.sale_data.unwrap_or(
                AccountSale{
                    committed_amount: 0,
                    sale_data: AccountSaleData::Shared
                }
            );
                    
            assert!( (account_sale.committed_amount + deposit) >= min_allocation 
                && (account_sale.committed_amount + deposit) <= max_allocation,
                "Total deposit amount must be between min_allocation and max_allocation");
    
            account_sale = AccountSale{
                committed_amount: account_sale.committed_amount + deposit,
                sale_data: AccountSaleData::Shared
            };
                    
            // Update Project account
            project_account.sale_data = Some(account_sale);
    
            // Update Project total_fund_committed
            project.total_fund_committed += deposit;
    
            // Insert new value into accounts_by_project
            project_account_unordered_map.insert(&account_id,&project_account);
            self.accounts_by_project.insert(&project_id,&project_account_unordered_map);
            self.projects.insert(&project_id, &project);
                    
            deposit              
    }
    
    
    pub(crate) fn internal_commit_lottery_project(&mut self,
        allocation_per_ticket: u128,
        total_tickets: u64,
        project_ticket_win_ids: Option<Vec<u64>>,
        project_id: ProjectId, 
        account_id: &AccountId,
        deposit: u128,
    ) -> Balance{
            let mut tickets_by_project = self.internal_get_tickets_by_project_or_panic(project_id);
            let mut project_account_unordered_map = self.internal_get_accounts_by_project_or_panic(project_id);
            let mut project_account = self.internal_get_account_by_project_or_panic(project_id,&account_id);
            let mut project = self.internal_get_project_or_panic(project_id);
            let account_sale = project_account.sale_data.unwrap_or( AccountSale{
                committed_amount: 0,
                sale_data: AccountSaleData::Lottery(
                    LotteryAccountSaleData{
                        eligible_tickets: 0,
                        deposit_tickets: 0,
                        ticket_ids: vec![],
                        win_ticket_ids: vec![]
                    })
            });
                    
            match account_sale.sale_data{ 
                AccountSaleData::Lottery(
                    LotteryAccountSaleData{
                        eligible_tickets,
                        deposit_tickets,
                        ticket_ids,
                        win_ticket_ids
                    }) => {
                        let tickets_num = (deposit / allocation_per_ticket) as u128;
                        let mut ticket_ids = ticket_ids.clone();
                        assert!(tickets_num>0, "Must deposit at least {} for exchange a ticket",allocation_per_ticket);
                        assert!((tickets_num as u64 + deposit_tickets)<=eligible_tickets,"Eligible tickets not enough");
    
                        for i in total_tickets..(total_tickets+ tickets_num as u64) {
                            ticket_ids.push(i);
                            tickets_by_project.insert(&i,&account_id);
                        }
    
                        let lottery_account_sale_data = AccountSaleData::Lottery(
                            LotteryAccountSaleData{
                                eligible_tickets: eligible_tickets,
                                deposit_tickets: (deposit_tickets + tickets_num as u64),
                                ticket_ids: ticket_ids,
                                win_ticket_ids: win_ticket_ids
                            }  
                        );
    
                        let account_sale = AccountSale{
                            committed_amount: account_sale.committed_amount + (tickets_num*allocation_per_ticket),
                            sale_data: lottery_account_sale_data
                        };
                                
                        // Update Project account sale_data
                        project_account.sale_data = Some(account_sale);
                        // Update Project total_fund_committed
                        project.total_fund_committed += tickets_num*allocation_per_ticket;
                        // Update project total_tickets
                        project.sale_type = SaleType::Lottery { 
                            allocation_per_ticket: allocation_per_ticket, 
                            total_tickets: total_tickets + tickets_num as u64, 
                            win_ticket_ids: project_ticket_win_ids
                        };
    
                        // Insert new value into accounts_by_project and tickets_by_project
                        project_account_unordered_map.insert(&account_id,&project_account);
                        self.accounts_by_project.insert(&project_id,&project_account_unordered_map);
                        self.tickets_by_project.insert(&project_id,&tickets_by_project);
                        self.projects.insert(&project_id, &project);
    
                        (tickets_num * allocation_per_ticket) as u128
                    }
                        
                _ => panic!("Invalid sale_data")
            }
    }

    // Project Distribution
    pub(crate) fn internal_distribute_token_to_users(&mut self, project_id: ProjectId) {
        // Get project account token sales
        let project = self.internal_get_project_or_panic(project_id);
        let project_sale_type = &project.sale_type;
        //  Traverse all account_id in ProjectAccountUnorderedMap
        let accounts_by_project_1 = self.internal_get_accounts_by_project_or_panic(project_id);
        let mut accounts_by_project_2 = self.internal_get_accounts_by_project_or_panic(project_id);
        match project_sale_type {
            SaleType::Shared { 
                min_allocation_per_user: _,
                max_allocation_per_user: _ 
            } => {             
                for (account_id, project_account) in accounts_by_project_1.iter(){
                    
                    let account_sale = project_account.sale_data.unwrap_or(
                        AccountSale{
                        committed_amount: 0,
                        sale_data: AccountSaleData::Shared
                    });   
                        
                    if account_sale.committed_amount != 0 {
                        //  Create AccountDistribution data for all account
                        let account_distribution = AccountDistribution {
                            unlocked_amount: (account_sale.committed_amount / project.total_fund_committed) * project.token_raised_amount,
                            locked_amount: 0,
                            claimed_amount: 0
                        };
                        let new_project_account = ProjectAccount {
                            sale_data: Some(account_sale),
                            distribution_data: Some(account_distribution)
                        };
                        accounts_by_project_2.insert(&account_id, &new_project_account);
                    }
                }
            },

            SaleType::Lottery { 
                allocation_per_ticket, 
                total_tickets, 
                win_ticket_ids
            } =>{
                let tickets_by_project = self.internal_get_tickets_by_project_or_panic(project_id);
                // TODO: Random win_ticket and save to win_ticket_ids
                // Blocktimestamp of near is nanoseconds so 4 last numbers of timestamp will be randomly
                // Ex: if the 4 last numbers is 1234. We do 123 * 234 * 1234 = 35516988. 
                // So we have 35, 51, 69, 88 is 4 numbers of last 2digit in user ticket.
                // Check through all user ticket by tickets_by_project.
                // Ex: If total tickets is 12055. 
                //     But there're only 1_000_000(token_raised_amount) / 1_000 (allocation_per_ticket) = 1000 win tickets
                // 
                for (account_id, project_account) in accounts_by_project_1.iter(){
                    //  Create AccountDistribution data for all account
                    let account_sale = project_account.sale_data.unwrap_or(
                        AccountSale{
                        committed_amount: 0,
                        sale_data: AccountSaleData::Lottery(
                            LotteryAccountSaleData{
                                eligible_tickets: 0,
                                deposit_tickets: 0,
                                ticket_ids: vec![],
                                win_ticket_ids: vec![]
                            })
                    });

                    if account_sale.committed_amount != 0 {
                        //  TODO: Create AccountDistribution data for all account
                    }
                }

                self.projects.insert(&project_id, &project);
            }
        }
        
        //  Insert into accounts_by_project
        self.accounts_by_project.insert(&project_id, &accounts_by_project_2);
    }

}
'''
'''--- ido/src/modules/testing.rs ---
use crate::*;

#[near_bindgen]
impl IDOContract{

    pub fn create_sample_projects(&mut self) {
        self.assert_test_mode_and_owner();
        
        self.create_project(Self::internal_new_project_1());
        self.create_project(Self::internal_new_project_2());
        self.create_project(Self::internal_new_project_3());
        self.create_project(Self::internal_new_project_4());
        self.create_project(Self::internal_new_project_5());
    }

    pub fn create_sample_project(&mut self, project_no: u8) {
        self.assert_test_mode_and_owner();

        let project: ProjectInput = match project_no {
            1 => Self::internal_new_project_1(),
            _ => panic!("No project no: {}", project_no)
        };

        self.create_project(project);
    }

    pub fn update_project_whitelist_date(&mut self, project_id: ProjectId, new_whitelist_start_date: Option<U64>, new_whitelist_end_date: Option<U64>) {
        self.assert_test_mode_and_owner();

        let mut project = self.projects.get(&project_id).expect("No project found");

        let a_half_of_whitelist_period = (project.whitelist_end_date - project.whitelist_start_date) / 2;
        let current_time = env::block_timestamp();

        println!("update_project_whitelist_date: current_time: {}, a_half_of_period: {}", current_time, a_half_of_whitelist_period);

        project.whitelist_start_date = new_whitelist_start_date.unwrap_or(U64(current_time - a_half_of_whitelist_period)).0;
        project.whitelist_end_date = new_whitelist_end_date.unwrap_or(U64(current_time + a_half_of_whitelist_period)).0;

        self.projects.insert(&project_id, &project);

    }

    pub fn update_project_sales_date(&mut self, project_id: ProjectId) {
        self.assert_test_mode_and_owner();

        let mut project = self.projects.get(&project_id).expect("No project found");

        let a_half_of_sales_period = (project.sale_end_date - project.sale_start_date) / 2;
        let current_time = env::block_timestamp();
        let time_to_change: i128 = current_time as i128 - project.sale_start_date as i128 - a_half_of_sales_period as i128;

        println!("Current time: {}", current_time);
        println!("Sales start: {}", project.sale_start_date);
        println!("Period: {}", a_half_of_sales_period);
        println!("To be change: {}", time_to_change);
        
        project.whitelist_start_date = (project.whitelist_start_date as i128 + time_to_change) as u64;
        project.whitelist_end_date = (project.whitelist_end_date as i128 + time_to_change) as u64;
        project.sale_start_date = (project.sale_start_date as i128 + time_to_change) as u64;
        project.sale_end_date = (project.sale_end_date as i128 + time_to_change) as u64;

        self.projects.insert(&project_id, &project);
    }

    pub fn update_project_sales_date_to_end(&mut self, project_id: ProjectId) {
        self.assert_test_mode_and_owner();

        let mut project = self.projects.get(&project_id).expect("No project found");
        let current_timestamp = get_current_time();
        if project.sale_end_date <= current_timestamp {
            env::log("The sales end time is correct. No need to update.".as_bytes());
        }

        let time_period_after_sales_end = project.sale_end_date - current_timestamp + 1000;

        println!("Sales end date: {}, Current time: {}, Period: {}", project.sale_end_date, current_timestamp, time_period_after_sales_end);
        println!("Whitelist start date: {}", project.whitelist_start_date);
        println!("Whitelist end date: {}", project.whitelist_end_date);
        println!("Sales start date: {}", project.sale_start_date);
        println!("Sales end date: {}", project.sale_end_date);
        
        project.whitelist_start_date -= time_period_after_sales_end;
        project.whitelist_end_date -= time_period_after_sales_end;
        project.sale_start_date -= time_period_after_sales_end;
        project.sale_end_date -= time_period_after_sales_end;

        println!("After change:"); 
        println!("Whitelist start date: {}", project.whitelist_start_date);
        println!("Whitelist end date: {}", project.whitelist_end_date);
        println!("Sales start date: {}", project.sale_start_date);
        println!("Sales end date: {}", project.sale_end_date);
        println!("Current time: {}", current_timestamp);

        self.projects.insert(&project_id, &project);
    }

    pub fn update_project_status(&mut self, project_id: ProjectId, new_status: ProjectStatus) {
        self.assert_test_mode_and_owner();

        let mut project = self.projects.get(&project_id).expect("No project found");
        project.status = new_status;

        self.projects.insert(&project_id, &project);
    }
}
'''
'''--- ido/src/modules/tier.rs ---
use crate::*;

pub type TierConfigsType = HashMap<Tier, TierConfig>;

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    PartialEq,
    Debug,
    Clone,
    Eq,
    Hash,
    PartialOrd,
    Copy,
)]
#[serde(crate = "near_sdk::serde")]
pub enum Tier {
    Tier0,
    Tier1,
    Tier2,
    Tier3,
    Tier4,
}

impl Default for Tier {
    fn default() -> Self {
        Tier::Tier0
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct TierConfig {
    pub min_point: Balance,
    pub ticket: TicketNumber,
    pub allocation: AllocationNumber,
}

impl TierConfig {
    pub fn new(min_point: Balance, ticket: TicketNumber, allocation: AllocationNumber) -> Self {
        Self {
            min_point,
            ticket,
            allocation,
        }
    }

    pub fn get_default_tier_configs() -> TierConfigsType {
        TierConfig::get_default_tier_configs_multiple(TOKEN_DECIMAL)
    }

    pub fn get_default_tier_configs_multiple(digits: u8) -> TierConfigsType {
        let mut cfg = TierConfigsType::new();
        let multiple = u128::pow(10, digits as u32);

        cfg.insert(Tier::Tier0, TierConfig::new(0, 0, 0));
        cfg.insert(Tier::Tier1, TierConfig::new(100 * multiple, 1, 0));
        cfg.insert(Tier::Tier2, TierConfig::new(1_000 * multiple, 12, 0));
        cfg.insert(Tier::Tier3, TierConfig::new(5_000 * multiple, 100, 0));
        cfg.insert(Tier::Tier4, TierConfig::new(10_000 * multiple, 100, 1));

        cfg
    }
}

/// This is derivative data so plz do not store it in the storage
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct UserTierJson {
    // tier and point: Please see the staking tier on the staking contract
    tier: Tier,
    point: U128,
    ticket: u64,
    allocation: u64,
}

impl Default for UserTierJson {
    fn default() -> Self {
        Self {
            tier: Tier::default(),
            point: U128(0),
            ticket: 0,
            allocation: 0,
        }
    }
}

'''
'''--- ido/src/staking_contract.rs ---
use crate::*;

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountJson {
    pub account_id: AccountId,
    pub locked_balance: U128,
    pub locked_days: u32,
    pub unlocked_timestamp: Timestamp,
    pub staked_balance: U128,
    pub unstaked_balance: U128,
    pub reward: U128,
    pub can_withdraw: bool,
    pub start_unstake_timestamp: Timestamp,
    pub unstake_available_epoch: EpochHeight,
    pub current_epoch: EpochHeight,
    pub tier: Tier,
    pub point: U128,
}

#[ext_contract(ext_staking_contract)]
pub trait StakingContract {
    fn get_account_info(&self, account_id: AccountId) -> AccountJson;
}

#[ext_contract(ext_self)]
pub trait IDOContractResolver {
    fn resolve_get_account_info_for_updating_tickets(&mut self, project_id: ProjectId, account_id: AccountId) -> Option<AccountJson>;
    fn resolve_get_account_info_for_register_whitelist(&self, account_id: AccountId, project_id: ProjectId, xtoken: u128) -> bool;
}

#[near_bindgen]
impl IDOContract {
    pub(crate) fn internal_update_staking_tickets(&self, project_id: ProjectId, account_id: AccountId) -> PromiseOrValue<bool> {
        env::log(format!("update_staking_tickets(account_id: '{}')", account_id).as_bytes());

        ext_staking_contract::get_account_info(
            account_id.clone(),
            &self.staking_contract_id,
            NO_DEPOSIT,
            GAS_FUNCTION_CALL
        )
        .then(ext_self::resolve_get_account_info_for_updating_tickets(
            project_id,
            account_id,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FUNCTION_CALL_UPDATE_STAKING_TIER
        )).into()
    }

    #[private]
    pub fn resolve_get_account_info_for_updating_tickets(&mut self, project_id: ProjectId, account_id: AccountId) -> bool {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );

        // handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => false,
            PromiseResult::Successful(result) => {
                let account_info = near_sdk::serde_json::from_slice::<AccountJson>(&result).unwrap();
                
                env::log(format!("Prepared gas: {}, Used gas: {}", env::prepaid_gas(), env::used_gas()).as_bytes());

                let result = self.process_update_staking_tickets(project_id, account_id, account_info);

                env::log(format!("Prepared gas: {}, Used gas: {}", env::prepaid_gas(), env::used_gas()).as_bytes());

                result
            },
        }
    }

    pub(crate) fn process_update_staking_tickets(&mut self, project_id: ProjectId, account_id: AccountId, staking_account_info: AccountJson) -> bool {
        env::log(format!("process_update_staking_tickets(project_id: {}, account_id: {}, staking_info: {:#?})", project_id, account_id, staking_account_info).as_bytes());

        // Verify staking_info.account_id vs account_id 
        assert_eq!(account_id.clone(), staking_account_info.account_id, "The staking account is not equal to current account id.");

        let project = self.internal_get_project_or_panic(project_id);

        // Project's status must be whitelist & current time is between whitelist_start_date and whitelist_end_date
        project.assert_whitelist_period();
        
        // TODO: Generate tickets
        
        // Update project
        self.projects.insert(&project_id, &project);

        true
    }
}

#[near_bindgen]
impl IDOContract{
    pub(crate) fn internal_register_whitelist_fixed_xtoken_project(&self, project_id: ProjectId, account_id: AccountId, xtoken: u128)-> PromiseOrValue<bool>{
        env::log(format!("register_fixed_xtoken_project(account_id: '{}', project_id: '{}')", account_id, project_id).as_bytes());
        ext_staking_contract::get_account_info(
            account_id.clone(),
            &self.staking_contract_id,
            NO_DEPOSIT, 
            GAS_FUNCTION_CALL
        ).then (
            ext_self::resolve_get_account_info_for_register_whitelist(
                account_id, 
                project_id, 
                xtoken,
                &env::current_account_id(), 
                NO_DEPOSIT, 
                GAS_FUNCTION_CALL_GET_USER_POINT
            )
        ).into()
    }

    pub fn resolve_get_account_info_for_register_whitelist(&mut self, account_id: AccountId, project_id: ProjectId, xtoken: u128) -> bool{
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );

        match env::promise_result(0){
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed =>false,
            PromiseResult::Successful(result) => {
                let account_json = near_sdk::serde_json::from_slice::<AccountJson>(&result).unwrap();
                let registered = self.proccess_register_whitelist(account_id, project_id,account_json.point, xtoken);
                env::log(format!("Prepared gas: {}, Used gas: {}",env::prepaid_gas(),env::used_gas()).as_bytes());

                registered
            }   
        }
    }

    pub (crate) fn proccess_register_whitelist(&mut self, account_id: AccountId, project_id: ProjectId, point: U128, xtoken: u128) -> bool{
        env::log(format!("proccess_register_whitelist(account_id: {}, project_id: {}, point: {})", account_id, project_id,point.0).as_bytes());
        assert!(point.0 >= xtoken,"User don't have enough XToken");
        self.internal_add_account(&account_id, project_id);

        true
    }
}

'''
'''--- ido/src/tests.rs ---
pub mod test_utils;
pub mod test_emulator;
pub mod project_internal;

#[cfg(test)]
pub mod test_account;
pub mod test_project;

#[cfg(test)]
pub mod test_whitelist;

#[cfg(test)]
pub mod test_buytoken;

pub mod test_full_flow;

pub mod test_staking_tier;
'''
'''--- ido/src/tests/project_internal.rs ---
use crate::*;

#[near_bindgen]
impl IDOContract{

    pub(crate) fn internal_new_project_1()-> ProjectInput{
        ProjectInput{
            owner_id: "alevoro.near".to_string(),
            whitelist_start_date: 1651172401000000000,
            whitelist_end_date: 1651604401000000000,
            sale_start_date: 1651604401000000000,
            sale_end_date: 1652068717000000000,
            token_contract_id: "contract.alevoro.near".to_string(),
            token_raised_amount: U128(1000000000000000),
            token_sale_rate_numberator: 10u64,
            token_sale_rate_denominator: 1u64,
            fund_contract_id: "ft_contract".to_string(),
            whitelist_type: WhitelistType::None,
            sale_type : SaleType::Shared{
                min_allocation_per_user: 10,
                max_allocation_per_user: 200
            },
            distribution_type: DistributionType::Unlocked,

        }
    }

    pub(crate) fn internal_new_project_2()-> ProjectInput{
        ProjectInput{
            owner_id: "ref_finance.near".to_string(),
            whitelist_start_date: 1651172401000000000,
            whitelist_end_date: 1651604401000000000,
            sale_start_date: 1651604401000000000,
            sale_end_date: 1652068717000000000,
            token_contract_id: "contract.ref_finance.near".to_string(),
            token_raised_amount: U128(1000000000000000),
            token_sale_rate_numberator: 10u64,
            token_sale_rate_denominator: 1u64,
            fund_contract_id: "ft_contract".to_string(),
            whitelist_type: WhitelistType::Ticket,
            sale_type : SaleType::Lottery{
                allocation_per_ticket : 10,
                total_tickets: 0,
                win_ticket_ids: None,
            },
            distribution_type: DistributionType::Unlocked,

        }
    }

    pub(crate) fn internal_new_project_3()-> ProjectInput{
        ProjectInput{
            owner_id: "near_dao.near".to_string(),
            whitelist_start_date: 1651172401000000000,
            whitelist_end_date: 1651604401000000000,
            sale_start_date: 1651604401000000000,
            sale_end_date: 1652068717000000000,
            token_contract_id: "contract.near_dao.near".to_string(),
            token_raised_amount: U128(1000000000000000),
            token_sale_rate_numberator: 10u64,
            token_sale_rate_denominator: 1u64,
            fund_contract_id: "ft_contract".to_string(),
            whitelist_type: WhitelistType::XToken(100),
            sale_type : SaleType::Shared{
                min_allocation_per_user: 10,
                max_allocation_per_user: 200
            },
            distribution_type: DistributionType::Unlocked,

        }
    }

    pub(crate) fn internal_new_project_4()-> ProjectInput{
        ProjectInput{
            owner_id: "owner_titan.testnet".to_string(),
            whitelist_start_date: 1640995200000000000,
            whitelist_end_date: 1641250800000000000,
            sale_start_date: 1641254400000000000,
            sale_end_date: 1641340800000000000,
            token_contract_id: "titan.testnet".to_string(),
            fund_contract_id: "usn.testnet".to_string(),
            token_raised_amount: U128(1000000000000000),
            token_sale_rate_numberator: 10u64,
            token_sale_rate_denominator: 1u64,
            whitelist_type: WhitelistType::None,
            sale_type: SaleType::Shared {
                min_allocation_per_user: 5000000000,
                max_allocation_per_user: 10000000000,
            },
            distribution_type: DistributionType::Unlocked,
        }
    }

    pub(crate) fn internal_new_project_5()-> ProjectInput{
        ProjectInput{
            owner_id: "cryptocubes.near".to_string(),
            whitelist_start_date: 1651172401000000000,
            whitelist_end_date: 1651604401000000000,
            sale_start_date: 1651604401000000000,
            sale_end_date: 1652068717000000000,
            token_contract_id: "contract.cryptocubes.near".to_string(),
            token_raised_amount: U128(1000000000000000),
            token_sale_rate_numberator: 10u64,
            token_sale_rate_denominator: 1u64,
            fund_contract_id: "".to_string(),
            whitelist_type: WhitelistType::Ticket,
            sale_type : SaleType::Shared{
                min_allocation_per_user: 20_000_000_000_000_000_000_000_000,
                max_allocation_per_user: 100_000_000_000_000_000_000_000_000
            },
            distribution_type: DistributionType::Unlocked,

        }
    }
}
    
    

    // pub(crate) fn internal_new_project_5()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "flux_protocol.near".to_string(),
    //         name: "Flux".to_string(),
    //         logo_url: "https://cryptorobin.com/wp-content/uploads/2021/05/featured-image-flux.jpg".to_string(),
    //         description: "The trustless data layer for web3".to_string(),
    //         introduction:"Oracle connect to Near Protocol".to_string(),
    //         categories: vec!["Oracle".to_string()],
    //         whitelist_start_date: 1647835201000000000,
    //         whitelist_end_date: 1648094401000000000,
    //         sale_start_date: 1648094401000000000,
    //         sale_end_date: 1648353601000000000,
    //         token_contract_id: "contract.flux_protocol.near".to_string(),
    //         token_symbol:"FLX".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         total_fund_received: 0,
    //         sale_type: SaleType::FullUnlocked,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Distribution,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

    // pub(crate) fn internal_new_project_6()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "oin_finance.near".to_string(),
    //         name: "Oin Finance 6".to_string(),
    //         logo_url: "https://d235dzzkn2ryki.cloudfront.net/oin-finance_large.png".to_string(),
    //         description: "A robust turnkey stablecoin issuance platform built for the multi-chain universe.".to_string(),
    //         introduction:"Near's Stablecoin".to_string(),
    //         categories: vec!["Stablecoin".to_string(),"DeFi".to_string()],
    //         whitelist_start_date: 1646353602000000000,
    //         whitelist_end_date: 1646412802000000000,
    //         sale_start_date: 1646467201000000000,
    //         sale_end_date: 1647244801000000000,
    //         token_contract_id: "contract.oin_finance.near".to_string(),
    //         token_symbol:"OIN".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         total_fund_received: 0,
    //         sale_type: SaleType::Vested,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Sales,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

    // pub(crate) fn internal_new_project_7()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "paras.near".to_string(),
    //         name: "Project 7".to_string(),
    //         logo_url: "https://paras-media.s3-ap-southeast-1.amazonaws.com/paras-v2-twitter-card-large.png".to_string(),
    //         description: "See NFT digital card collectibles and creations from paras.near.".to_string(),
    //         introduction:"NFT Marketplace.".to_string(),
    //         categories: vec!["NFT".to_string()],
    //         whitelist_start_date: 1646131204000000000,
    //         whitelist_end_date: 1646390404000000000,
    //         sale_start_date: 1646531204000000000,
    //         sale_end_date: 1647374401000000000,
    //         token_contract_id: "contract.paras.near".to_string(),
    //         token_symbol:"PARAS".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         total_fund_received: 0,
    //         sale_type: SaleType::Vested,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Sales,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

    // pub(crate) fn internal_new_project_8()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "aurigami.near".to_string(),
    //         name: "Aurigami".to_string(),
    //         logo_url: "https://pbs.twimg.com/profile_images/1487610929646739459/EbB5N8IN.jpg".to_string(),
    //         description: "Noncustodial lending and borrowing haven on Aurora".to_string(),
    //         introduction:"Near lending&borrowing platform".to_string(),
    //         categories: vec!["Lending".to_string(),"DeFi".to_string()],
    //         whitelist_start_date: 1646510401000000000,
    //         whitelist_end_date: 1647360592000000000,
    //         sale_start_date: 1647374401000000000,
    //         sale_end_date: 1647633601000000000,
    //         token_contract_id: "contract.aurigami.near".to_string(),
    //         token_symbol:"AURI".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         sale_type: SaleType::Vested,
    //         total_fund_received: 0,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Whitelist,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

    // pub(crate) fn internal_new_project_9()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "reality_chain.near".to_string(),
    //         name: "Reality Chain".to_string(),
    //         logo_url: "https://pbs.twimg.com/media/FMsQe8CXIAsAUFK?format=jpg&name=large".to_string(),
    //         description: "Create your Metaverse with Reality Chain".to_string(),
    //         introduction:"Multi-chain, multi-engine, Metaverse-as-a-Service.".to_string(),
    //         categories: vec!["GameFi".to_string(),"Metaverse".to_string()],
    //         whitelist_start_date: 1646510401000000000,
    //         whitelist_end_date: 1647360592000000000,
    //         sale_start_date: 1647374401000000000,
    //         sale_end_date: 1647633601000000000,
    //         token_contract_id: "contract.reality_chain.near".to_string(),
    //         token_symbol:"REAL".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         sale_type: SaleType::Vested,
    //         total_fund_received: 0,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Whitelist,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

    // pub(crate) fn internal_new_project_10()-> ProjectInfo{
    //     ProjectInfo{
    //         owner_id: "aurora.near".to_string(),
    //         name: "Aurora".to_string(),
    //         logo_url: "https://near.org/wp-content/uploads/2021/05/aurora_fb.png".to_string(),
    //         description: "A product that helps Ethereum users and dApps to easily move to the NEAR blockchain. ".to_string(),
    //         introduction:"Near&Ethereum bridge".to_string(),
    //         categories: vec![],
    //         whitelist_start_date: 1647374401000000000,
    //         whitelist_end_date: 1647892801000000000,
    //         sale_start_date: 1649826001000000000,
    //         sale_end_date: 1650085201000000000,
    //         token_contract_id: "contract.aurora.near".to_string(),
    //         token_symbol:"AURORA".to_string(),
    //         token_decimal: 8,
    //         token_amount_per_sale_slot: 100,
    //         token_raised_amount: 400_000,
    //         token_sale_rate: Rate::new(1u64, 100u64),
    //         fund_contract_id: None,
    //         fund_symbol: "Near".to_string(),
    //         sale_type: SaleType::Vested,
    //         total_fund_received: 0,
    //         configuration: ProjectConfiguration{ 
    //             max_staking_tickets_per_user: 500, 
    //             max_win_tickets_per_user: 250, 
    //         },
    //         status:ProjectStatus::Preparation,
    //         total_allocations: 0,
    //         total_staking_tickets: 0,
    //         total_social_tickets: 0,
    //         total_referral_tickets: 0,
    //     }
    // }

'''
'''--- ido/src/tests/test_account.rs ---
use crate::tests::test_utils::*;
use crate::tests::test_emulator::*;
use crate::tests::test_project::*;

// Test get_project_account_info

#[test]
#[should_panic(expected = "Project does not exist.")]
fn test_get_project_account_info_project_not_exist() { // - Project doesn't exist
    let emulator = Emulator::default();

    emulator.contract.get_project_account_info(1, bob());
}

#[test]
fn test_get_project_account_info_project_exists_account_not() { // - Project existed, account doesn't exist
    let mut emulator = Emulator::default();
    let owner = emulator.contract.get_owner_id();

    emulator.update_context(owner.clone(), owner.clone(), 0);
    let project = get_project_1();
    emulator.contract.create_project(project);

    emulator.update_context(bob(), bob(), 0);

    let project = emulator.contract.get_project_account_info(1, bob());

    assert_eq!(1, project.project_id);
    assert_eq!(bob(), project.account_id);
    assert_eq!(false, project.is_whitelist);
    assert!(project.sale_data.is_none());
    assert!(project.distribution_data.is_none());
}

// TODO: Will do when implementing these statuses
// - Project existed with prepration status
// - Project existed with whitelist status
// - Project existed with sale status
// - Project existed with distribution status
'''
'''--- ido/src/tests/test_buytoken.rs ---
use crate::tests::test_emulator::*;
use crate::modules::account::*;
use near_sdk::json_types::U128;
use crate::modules::project::ProjectStatus;

#[test]
fn test_buy_token_by_near() {
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.create_sample_projects();

    emulator.update_context("alice".to_string(), "bob".to_string(), 0);
    emulator.contract.internal_change_project_status(5);
    emulator.contract.register_whitelist(5);
    let is_whitelist = emulator.contract.is_whitelist(5,"bob".to_string());
    assert!(is_whitelist);
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.update_project_status(5, ProjectStatus::Sales);
    

    emulator.update_context("alice".to_string(), "bob".to_string(), 25_000_000_000_000_000_000_000_000);
    emulator.set_block_timestamp(1651804401000000000);
    
    let default_share_project_account_sale = AccountSale{
        committed_amount: 25_000_000_000_000_000_000_000_000,
        sale_data: AccountSaleData::Shared
    };
    let default_share_project_account_sale_json = AccountSaleJson::from(default_share_project_account_sale);

    emulator.contract.commit(5);
   
    let share_project_account_sale_json = emulator.contract.internal_get_project_account_info(5,"bob".to_string()).sale_data.unwrap();
    assert_eq!(default_share_project_account_sale_json.committed_amount,
                share_project_account_sale_json.committed_amount,
                "Committed amount project 5 not match");
}

#[test]
fn test_commit_shared_project_by_ft_token() {
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.create_sample_projects();

    emulator.update_context("alice".to_string(), "bob".to_string(), 0);
    emulator.contract.internal_change_project_status(1);
    emulator.contract.register_whitelist(1); 

    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.update_project_status(1, ProjectStatus::Sales);
    

    emulator.update_context("alice".to_string(), "bob".to_string(), 20_000_000_000_000);
    emulator.set_block_timestamp(1651804401000000000);
    
    let default_share_project_account_sale = AccountSale{
        committed_amount: 25,
        sale_data: AccountSaleData::Shared
    };
    
    let default_share_project_account_sale_json = AccountSaleJson::from(default_share_project_account_sale);
    emulator.contract.internal_commit(1, &"bob".to_string(), 25);
   
    let share_project_account_sale_json = emulator.contract.internal_get_project_account_info(1,"bob".to_string()).sale_data.unwrap();
    assert_eq!(default_share_project_account_sale_json.committed_amount,
                share_project_account_sale_json.committed_amount,
                "Committed amount project 1 not match");
}

#[test]
fn test_commit_lottery_project_by_ft_token(){
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.create_sample_projects();

    emulator.update_context("alice".to_string(), "bob".to_string(), 0);
    emulator.contract.internal_change_project_status(2);
    emulator.contract.register_whitelist(2);

    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.update_project_status(2, ProjectStatus::Sales);
    emulator.update_account_sale_ticket("bob".to_string(), 2, 6);

    emulator.update_context("alice".to_string(), "bob".to_string(), 20_000_000_000_000);
    emulator.set_block_timestamp(1651804401000000000);

    let mut default_lottery_project_account_sale = AccountSale{
        committed_amount: 20,
        sale_data: AccountSaleData::Lottery(
            LotteryAccountSaleData{
                eligible_tickets: 6,
                deposit_tickets: 2,
                ticket_ids: vec![0,1],
                win_ticket_ids: vec![]
            }
        )
    };

    let mut default_lottery_project_account_sale_json = AccountSaleJson::from(default_lottery_project_account_sale);
    emulator.contract.internal_commit(2, &"bob".to_string(), 25);
    let mut lottery_project_account_sale_json = emulator.contract.internal_get_project_account_info(2,"bob".to_string()).sale_data.unwrap();

    assert_eq!(default_lottery_project_account_sale_json.committed_amount,
        lottery_project_account_sale_json.committed_amount,
        "Committed amount project 2 phase 1 not match ");
    assert_eq!(default_lottery_project_account_sale_json.lottery_sale_data.unwrap(),
            lottery_project_account_sale_json.lottery_sale_data.unwrap(),
            "Lottery sale data not match ");

    emulator.update_context("alice".to_string(), "bob".to_string(), 20_000_000_000_000);
    emulator.set_block_timestamp(1651804401000000000);
    emulator.contract.internal_commit(2, &"bob".to_string(), 30);

    default_lottery_project_account_sale = AccountSale{
        committed_amount:50,
        sale_data: AccountSaleData::Lottery(
            LotteryAccountSaleData{
                eligible_tickets: 6,
                deposit_tickets: 5,
                ticket_ids: vec![0,1,2,3,4],
                win_ticket_ids: vec![]
            }
        )
    };
    default_lottery_project_account_sale_json = AccountSaleJson::from(default_lottery_project_account_sale);
    lottery_project_account_sale_json = emulator.contract.internal_get_project_account_info(2,"bob".to_string()).sale_data.unwrap();
    assert_eq!(default_lottery_project_account_sale_json.committed_amount,
        lottery_project_account_sale_json.committed_amount,
        "Committed amount project 2 phase 2 not match ");
    assert_eq!(default_lottery_project_account_sale_json.lottery_sale_data.unwrap(),
        lottery_project_account_sale_json.lottery_sale_data.unwrap(),
        "Lottery sale data not match ");

}
'''
'''--- ido/src/tests/test_emulator.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext, testing_env};
use near_sdk::{Balance, BlockHeight, EpochHeight};

use crate::*;
use crate::tests::test_utils::*;

pub struct Emulator {
    pub contract: IDOContract,
    pub context: VMContext,
}

impl Emulator {
    pub fn new(owner: String) -> Self {
        let context = VMContextBuilder::new()
            .current_account_id(owner.clone())
            .finish();

        testing_env!(context.clone());

        let contract = IDOContract::new(owner, ft_token_id(), None, None, None);

        Emulator {
            contract,
            context,
        }
    }

    pub fn default() -> Self {
        Emulator::new(owner().clone())
    }

    pub fn update_context(&mut self, predecessor_account_id: String,signer_account_id:String, deposit: Balance) {
        self.context = VMContextBuilder::new()
            .current_account_id(staking())
            .predecessor_account_id(predecessor_account_id)
            .signer_account_id(signer_account_id)
            .attached_deposit(deposit)
            .finish();
        testing_env!(self.context.clone());
        println!(
            "Print something here"
        );
    }

    pub fn set_block_timestamp(&mut self, timestamp: Timestamp) {
        self.context.block_timestamp = timestamp;

        println!("block_timestamp: {}", timestamp);

        testing_env!(self.context.clone());
    }

    /// Keep the remaining properties the same.
    pub fn set_account_id_and_desposit(&mut self, predecessor_account_id: String, signer_account_id:String, deposit: Balance) {
        self.context.predecessor_account_id = predecessor_account_id.clone();
        self.context.signer_account_id = signer_account_id.clone();
        self.context.attached_deposit = deposit;
        
        println!("predecessor_account_id: {}, signer_account_id: {}, attached_deposit: {}", predecessor_account_id, signer_account_id, deposit);

        testing_env!(self.context.clone());
    }

    pub fn update_account_sale_ticket(&mut self, account_id: AccountId, project_id: ProjectId, ticket_nums: u64){
        self.contract.assert_test_mode_and_owner();
        let mut project_account_unordered_map = self.contract.internal_get_accounts_by_project_or_panic(project_id);
        let account_sale = AccountSale{
            committed_amount: 0,
            sale_data: AccountSaleData::Lottery(
                LotteryAccountSaleData{
                    eligible_tickets: ticket_nums,
                    deposit_tickets: 0,
                    ticket_ids: vec![],
                    win_ticket_ids: vec![]
                }
            )
        };

        let project_account = ProjectAccount{
            sale_data: Some(account_sale),
            distribution_data: None
        };

        project_account_unordered_map.insert(&account_id, &project_account);
        self.contract.accounts_by_project.insert(&project_id,&project_account_unordered_map);   
    }
}

'''
'''--- ido/src/tests/test_full_flow.rs ---
use crate::tests::test_utils::*;
use crate::tests::test_emulator::*;
use crate::tests::test_project::*;
use crate::tests::test_staking_tier::*;

use crate::*;

use near_sdk::{env, AccountId, Timestamp};
use near_sdk::json_types::{U128, U64};

#[test]
fn test_happy_case() {
    let mut emulator = Emulator::default();

    // Whitelist start date:    2022-01-01 07:00:00 - 1640995200000000000
    // Whitelist end date:      2022-01-04 06:00:00 - 1641250800000000000
    // Sales start date:        2022-01-04 07:00:00 - 1641254400000000000
    // Sales end date:          2022-01-05 07:00:00 - 1641340800000000000
    // Status:                  Preparation
    let whitelist_start_date = 1640995200000000000;
    let whitelist_end_date = 1641250800000000000;
    let sale_start_date = 1641254400000000000;
    let sale_end_date = 1641340800000000000;
    let status = ProjectStatus::Preparation;

    let valid_whitelist_time = increase_timestamp(&whitelist_start_date, 1, 0, 0, 0);
    let before_whitelist_time = decrease_timestamp(&whitelist_start_date, 1, 0, 0, 0);
    let out_of_whitelist_time = increase_timestamp(&whitelist_end_date, 0, 0, 10, 0);
    let valid_sales_time = increase_timestamp(&sale_start_date, 0, 0, 10, 0);

    let mut project = get_project_1();
    project.whitelist_start_date = whitelist_start_date;
    project.whitelist_end_date = whitelist_end_date;
    project.sale_start_date = sale_start_date;
    project.sale_end_date = sale_end_date;

    env::log(format!("Before create a project").as_bytes());

    // Create a new project with status of Preparation
    let project_id = emulator.contract.create_project(project);

    let created_project = emulator.contract.get_project(project_id);
    if let Some(created_project) = created_project {
        assert_eq!(project_id, created_project.id);
        assert_eq!(whitelist_start_date, created_project.whitelist_start_date);
        assert_eq!(whitelist_end_date, created_project.whitelist_end_date);
        assert_eq!(sale_start_date, created_project.sale_start_date);
        assert_eq!(sale_end_date, created_project.sale_end_date);
        assert_eq!(status, created_project.status);
    } else {
        panic!("Cannot get project after created.");
    }
    
    // Change project's status to Whitelist
    emulator.set_block_timestamp(before_whitelist_time);
    assert_eq!(before_whitelist_time, emulator.context.block_timestamp);

    emulator.set_account_id_and_desposit(owner(), owner(), 0);
    emulator.contract.update_project_whitelist_date(project_id, None, None);

    emulator.contract.change_project_status(project_id);

    let created_project = emulator.contract.get_project(project_id).unwrap();
    assert_eq!(ProjectStatus::Whitelist, created_project.status);

    // User A registers whitelist
    emulator.set_account_id_and_desposit(account_a(), account_a(), 0);
    emulator.contract.register_whitelist(project_id);
    println!("User A registers whitelist - {}", account_a());
    assert!(emulator.contract.is_whitelist(project_id, account_a().to_string()));

    let projects_in_account = emulator.contract.projects_by_account.get(&account_a()).unwrap();
    let accounts_and_tickets_in_project = emulator.contract.accounts_by_project.get(&project_id).unwrap();

    assert!(projects_in_account.contains(&project_id));
    assert_eq!(1, accounts_and_tickets_in_project.len() as u32);

    let project = emulator.contract.get_project(project_id).unwrap();
    assert_eq!(1, project.whitelist_accounts);

    // User B registers whitelist

    // User C do not register whitelist
    let account_c = alice();
    emulator.set_account_id_and_desposit(account_c.clone(), account_c.clone(), 0);
    println!("User C registers whitelist - {}", account_c);
    assert!(!emulator.contract.is_whitelist(project_id, account_c.to_string()));

    // User A stakes & locks Tier1 for 31 days => Cross contract call

    // User A updated staking tier => Cross contract call
    let locked_amount: u128 = 200_00000000;
    let locked_days: u32 = 10;
    let locked_timestamp: Timestamp = increase_timestamp(&whitelist_start_date, locked_days, 0, 0, 0);
    let expected_staking_tier = Tier::Tier1;
    let expected_staking_tickets: TicketNumber = 1;
    let expected_allocations: TicketNumber = 0;

    let account_json = get_account_json(&account_a(), locked_amount, locked_days, locked_timestamp);

    emulator.contract.process_update_staking_tickets(project_id, account_a(), account_json);

    // Validate stored data
    let project = emulator.contract.projects.get(&project_id).unwrap();
    println!("Staking tier -> Total tickets");
    
    
    let account_tickets = emulator.contract.accounts_by_project.get(&project_id).unwrap();
    let tickets = account_tickets.get(&account_a()).unwrap();

    println!("Staking tier -> Account Staking Tickets");
    

    println!("Staking tier -> Account Staking Tickets - Allocations");

    // Validate response data
    emulator.set_account_id_and_desposit(account_a(), account_a(), 0);
    println!("Get project account info for Account A - {}", account_a());

    // Return data
    // ProjectAccountInfoJson {
    //     account_id: "bob",
    //     project_id: 1,
    //     project_status: Whitelist,
    //     whitelist_info: Some(
    //         ProjectWhitelistInfo {
    //             tier: Tier1,
    //             no_of_staking_tickets: 1,
    //             no_of_social_tickets: 0,
    //             no_of_referral_tickets: 0,
    //             no_of_allocations: 0,
    //         },
    //     ),
    //     sale_info: None,
    // }

    // Close whitelist
    emulator.set_account_id_and_desposit(owner(), owner(), 0);
    emulator.contract.update_project_sales_date(project_id);

    println!("update_project_sales_date");

    emulator.contract.close_project_whitelist(project_id);

    println!("close_project_whitelist");

    let project = emulator.contract.projects.get(&project_id).unwrap();
    assert_eq!(ProjectStatus::Sales, project.status);

    // User A deposit fund
    
    
    //assert!(false);
}

#[test]
fn test_project_ticket() {
    let mut emulator = Emulator::default();
    let project = get_project_1();
    let project_id = emulator.contract.create_project(project);

    println!("Start testing...");

    //assert!(false);
}

#[test]
fn test_rate() {
    let mut emulator = Emulator::default();
    let rate = Rate::new(1, 100);

    assert_eq!(1000, rate.multiply(100000));
    assert_eq!(100000, rate.devided_by(1000));
}
'''
'''--- ido/src/tests/test_project.rs ---
use crate::tests::test_utils::*;
use crate::tests::test_emulator::*;
use crate::modules::project::*;
use crate::*;

pub(crate) fn get_project_1() -> ProjectInput {
    ProjectInput {
        owner_id: "your.testnet".to_string(),
        whitelist_start_date: 1,
        whitelist_end_date: 2,
        sale_start_date: 3,
        sale_end_date: 5,
        token_contract_id: "your.testnet".to_string(),
        fund_contract_id: "usdc.testnet".to_string(),
        token_raised_amount: U128(40000),
        token_sale_rate_numberator: 10u64,
        token_sale_rate_denominator: 1u64,
        whitelist_type: WhitelistType::None,
        sale_type: SaleType::Shared {
            min_allocation_per_user: 50,
            max_allocation_per_user: 100,
        },
        distribution_type: DistributionType::Unlocked,
    }
}

#[test]
fn test_create_and_get_project() {
    let mut emulator = Emulator::default();

    let project = get_project_1();
    emulator.contract.create_project(get_project_1());
    let projects = emulator.contract.get_projects(None, None, None); 

    assert_eq!(1, projects.len(), "The number of projects in the contract is not correct!");

    let json_project = &projects[0];

    assert_eq!(1, json_project.id, "The created project id must equal to 1.");

    let new_projects = emulator.contract.get_projects(Some(ProjectStatus::Preparation), None, None); 
    let approved_projects = emulator.contract.get_projects(Some(ProjectStatus::Whitelist), None, None); 

    assert_eq!(1, new_projects.len(), "The number of NEW projects in the contract is not correct!");
    assert_eq!(0, approved_projects.len(), "The number of Whitelist projects in the contract is not correct!");
}

#[test]
fn test_create_sample_projects() {
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.create_sample_projects();

    // let projects = emulator.contract.get_projects(None, None, None); 

    // assert_eq!(10, projects.len(), "The number of projects in the contract is not correct!");
}

#[test]
fn test_update_project_sales_date_to_end() {
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);
    emulator.contract.create_sample_projects();

    let whitelist_start_date = 1640995200000000000;
    let whitelist_end_date = 1641250800000000000;
    let sale_start_date = 1641254400000000000;
    let sale_end_date = 1641340800000000000;
    let status = ProjectStatus::Preparation;

    let mut project = get_project_1();
    project.whitelist_start_date = whitelist_start_date;
    project.whitelist_end_date = whitelist_end_date;
    project.sale_start_date = sale_start_date;
    project.sale_end_date = sale_end_date;

    let project_id = emulator.contract.create_project(project);
    let project = emulator.contract.internal_get_project_or_panic(project_id);

    // Preparation
    assert_eq!(ProjectStatus::Preparation, project.status);

    // Whitelist
    let before_whitelist_time = decrease_timestamp(&whitelist_start_date, 1, 0, 0, 0);
    emulator.set_block_timestamp(before_whitelist_time);
    emulator.set_account_id_and_desposit(owner(), owner(), 0);
    emulator.contract.update_project_whitelist_date(project_id, None, None);

    println!("Project's status: {:?}, Current Time: {}, Whitelist Start Time: {}", project.status, before_whitelist_time, whitelist_start_date);
    emulator.contract.change_project_status(project_id);
    
    let project = emulator.contract.internal_get_project_or_panic(project_id);
    assert_eq!(ProjectStatus::Whitelist, project.status);

    // Sales
    emulator.contract.update_project_sales_date(project_id);
    emulator.contract.change_project_status(project_id);

    let project = emulator.contract.internal_get_project_or_panic(project_id);
    assert_eq!(ProjectStatus::Sales, project.status);

    // Distribution
    emulator.contract.update_project_sales_date_to_end(project_id);
    emulator.contract.change_project_status(project_id);

    let project = emulator.contract.internal_get_project_or_panic(project_id);
    assert_eq!(ProjectStatus::Distribution, project.status);
}
'''
'''--- ido/src/tests/test_staking.rs ---
use crate::tests::test_utils::*;
use crate::tests::test_emulator::*;

#[test]
fn test_staking() {
    let emulator = Emulator::default();
}
'''
'''--- ido/src/tests/test_staking_tier.rs ---
use crate::tests::test_utils::*;
use crate::tests::test_emulator::*;
use crate::tests::test_project::*;

use crate::*;

pub(crate) fn get_sample_account_json(account_id: &AccountId) -> AccountJson {
    get_account_json(&account_id, 500_00000000, 30, 1647879472091741700)
}

pub(crate) fn get_account_json(account_id: &AccountId, locked_balance: u128, locked_days: u32, locked_timestamp: Timestamp) -> AccountJson {
    AccountJson {
        account_id: account_id.clone(),
        locked_balance: U128::from(locked_balance),
        locked_days: locked_days,
        unlocked_timestamp: locked_timestamp,
        staked_balance: U128::from(locked_balance),
        unstaked_balance: U128::from(0),
        reward: U128::from(0),
        can_withdraw: true,
        start_unstake_timestamp: 0,
        unstake_available_epoch: 0,
        current_epoch: 980,
        tier: Tier::Tier1,
        point: U128(500)
    }
}

'''
'''--- ido/src/tests/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight, Timestamp};

const STAKING_TOKEN_ID: &str = "token-kulapad.testnet";
const UNIX_TIME_ONE_SECOND_IN_NANOSECONDS: Timestamp = 1_000_000_000;
const SECONDS_A_MINUTE: u8 = 60;
const MINUTES_AN_HOUR: u8 = 60;
const HOURS_A_DAY: u8 = 24;

fn get_timestamp(days: u32, hours: u8, minutes: u8, seconds: u8) -> Timestamp {
    let mut timestamp: Timestamp = 0;
    timestamp = days as u64 * HOURS_A_DAY as u64 + hours as u64;
    timestamp = timestamp * MINUTES_AN_HOUR as u64 + minutes as u64;
    timestamp = timestamp * SECONDS_A_MINUTE as u64 + seconds as u64;
    timestamp * UNIX_TIME_ONE_SECOND_IN_NANOSECONDS
}

pub fn increase_timestamp(timestamp: &Timestamp, days: u32, hours: u8, minutes: u8, seconds: u8) -> Timestamp {
    timestamp + get_timestamp(days, hours, minutes, seconds)
}

pub fn decrease_timestamp(timestamp: &Timestamp, days: u32, hours: u8, minutes: u8, seconds: u8) -> Timestamp {
    timestamp - get_timestamp(days, hours, minutes, seconds)
}

#[test]
fn test_timestamp() {
    // 2022-02-22 22:22:22 - 1645543342000000000
    // 2022-01-31 21:21:21 - 1643638881000000000
    let timestamp_1: Timestamp = 1645543342_000000000; // 2022-02-22 22:22:22
    let timestamp_2: Timestamp = 1643638881_000000000; // 2022-01-31 21:21:21
    let timestamp_3: Timestamp = 1645543403_000000000; // 2022-02-22 22:23:23

    // increase t1 1s to t3
    assert_eq!(increase_timestamp(&timestamp_1, 0, 0, 0, 61), timestamp_3);
    assert_eq!(increase_timestamp(&timestamp_1, 0, 0, 1, 1), timestamp_3);
    assert_eq!(timestamp_1, increase_timestamp(&timestamp_2, 22, 1, 1, 1));
    assert_eq!(timestamp_2, decrease_timestamp(&timestamp_1, 22, 1, 1, 1));
}

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}

pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn account_a() -> AccountId {
    "account-a.tesnet".to_string()
}

pub fn account_b() -> AccountId {
    "account-b.tesnet".to_string()
}

pub fn account_c() -> AccountId {
    "account-c.tesnet".to_string()
}

pub fn ft_token_id() -> AccountId {
    STAKING_TOKEN_ID.to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                // Current time: 29/4/2022 - 9h33'
                block_timestamp: 1651199572000000000,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }

    pub fn block_timestamp(mut self, timestamp: Timestamp) -> Self {
        self.context.block_timestamp = timestamp;
        self
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
        None
    )));
}

'''
'''--- ido/src/tests/test_whitelist.rs ---
use crate::tests::test_emulator::*;
use crate::tests::test_utils::*;

#[test]
fn test_register_whitelist() {
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);

    emulator.contract.create_sample_projects();
    emulator.contract.internal_change_project_status(1);
    emulator.contract.internal_change_project_status(2);
    emulator.update_context("alice".to_string(), "bob".to_string(), 0);
    emulator.contract.register_whitelist(1);
    emulator.contract.register_whitelist(2);
    assert_eq!(emulator.contract.projects_by_account.get(&"bob".to_string()).unwrap().len(),2);
}

#[test]
fn test_is_whitelist(){
    let mut emulator = Emulator::default();
    emulator.update_context("alice".to_string(), "owner".to_string(), 0);

    emulator.contract.create_sample_projects();
    emulator.contract.internal_change_project_status(1);
    emulator.contract.internal_change_project_status(2);
    emulator.update_context("alice".to_string(), "bob".to_string(), 0);
    emulator.contract.register_whitelist(1);
    assert!(emulator.contract.is_whitelist(1,"bob".to_string()));
    assert!(!emulator.contract.is_whitelist(1,"alice".to_string()));
}
'''
'''--- ido/src/utils.rs ---
use crate::*;

pub(crate) const ERROR_1: &str = "";

pub(crate) const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;

pub(crate) fn get_storage_key(key: StorageKey) -> Vec<u8> {
    key.try_to_vec().unwrap()
}

pub(crate) fn get_token_raised_amount(human_amount: u64, token_decimal: u8) -> Balance {
    human_amount as u128 * u128::pow(10, token_decimal as u32) 
}

pub(crate) fn get_token_sale_rate(system_amount: u128, numberator: u64, denominator: u64) -> Balance {
    system_amount * numberator as u128 / denominator as u128
}

pub(crate) fn get_token_raised_human_amount(amount: u128, token_decimal: u8) -> u128 {
    amount / u128::pow(10, token_decimal as u32) 
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash{
    let mut hash = CryptoHash::default();
    // Hash account ID ri return chinh no
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));

    hash
}

pub(crate) fn get_current_time() -> Timestamp {
    env::block_timestamp()
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1,
    "Require attached deposit of exactly 1 yoctoNear");
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1,
    "Require attached deposit of at least 1 yoctoNear")
}

pub(crate) fn panic_project_not_exist() {
    panic!("Project does not exist.");
}

impl IDOContract{
    // Assert functions
    pub(crate) fn assert_test_mode(&self) {
        assert_eq!(self.test_mode_enabled, true, "Test mode required to execute this function.");
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(self.owner_id, env::signer_account_id(), "You are not the owner of this contract.");
    }

    pub(crate) fn assert_test_mode_and_owner(&self) {
        self.assert_test_mode();
        self.assert_owner();
    }
}

#[near_bindgen]
impl IDOContract {
    pub fn get_current_block_timestamp()-> U64 {
        U64(env::block_timestamp())
    }
}
'''
'''--- ido/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- ido/tests/sim_test/ido_test.rs ---
mod whitelist_test;
mod commit_sale_test;
'''
'''--- ido/tests/sim_test/ido_test/commit_sale_test.rs ---
use crate::utils::{init,print_result};
use kulapad_ido::modules::account::{ProjectAccountJson,AccountSale, AccountSaleData, AccountSaleJson};
use kulapad_ido::modules::project::{ProjectJson};
use near_sdk::serde_json::json;
use near_sdk::serde::{Serialize,Deserialize};
use near_sdk::json_types::{U64,U128};
use near_sdk_sim::{DEFAULT_GAS, to_yocto};
use near_sdk_sim::UserAccount;

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Message{
    pub project_id: u64
}

pub fn init_whitelisting_project()-> (UserAccount, UserAccount, UserAccount,UserAccount, UserAccount, UserAccount){
    let (root,alice,ido,ft_contract,staking_contract,ido_contract) = init();
    root.call(
        ido_contract.account_id(),
        "change_project_status",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    root.call(
        ido_contract.account_id(),
        "change_project_status",
        &json!({
            "project_id" : 2
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    alice.call(
        ido_contract.account_id(),
        "register_whitelist",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    let mut is_whitelisted : bool = root.view(
        ido_contract.account_id(),
        "is_whitelist",
        &json!({
            "project_id" : 1,
            "account_id" : alice.account_id()
        }).to_string().as_bytes(),
    ).unwrap_json();
    
    assert!(is_whitelisted,"Not join whitelist project 1 after register");

    alice.call(
        ido_contract.account_id(),
        "register_whitelist",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    is_whitelisted = root.view(
        ido_contract.account_id(),
        "is_whitelist",
        &json!({
            "project_id" : 1,
            "account_id" : alice.account_id()
        }).to_string().as_bytes(),
    ).unwrap_json();
    
    assert!(is_whitelisted,"Not join whitelist project 2 after register");

    let current_time : U64 = root.call(
        ido_contract.account_id(),
        "get_current_block_timestamp",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,0
    ).unwrap_json();
    println!("Current time: {}", current_time.0);

    ido.call(
        ido_contract.account_id(),
        "update_project_sales_date",
        &json!({
            "project_id": 1
        }).to_string().as_bytes(),
        DEFAULT_GAS, 0
    );

    root.call(
        ido_contract.account_id(),
        "change_project_status",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    let mut project_json : ProjectJson = root.view(
        ido_contract.account_id(),
        "get_project",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("{:?}\n",project_json);
    

    ido.call(
        ido_contract.account_id(),
        "update_project_sales_date",
        &json!({
            "project_id": 2
        }).to_string().as_bytes(),
        DEFAULT_GAS, 0
    );
    
    root.call(
        ido_contract.account_id(),
        "change_project_status",
        &json!({
            "project_id" : 2
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    project_json = root.view(
        ido_contract.account_id(),
        "get_project",
        &json!({
            "project_id" : 2
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("{:?}\n",project_json);

    (root,alice,ido,ft_contract,staking_contract,ido_contract)
}

#[test]
pub fn test_commit_sale_share_project(){
    let (root,alice,ido,ft_contract,staking_contract,ido_contract) = init_whitelisting_project();

    let default_share_project_account_sale = AccountSale{
        committed_amount: 100,
        sale_data: AccountSaleData::Shared
    };
    let default_share_project_account_sale_json = AccountSaleJson::from(default_share_project_account_sale);

    let outcome = alice.call(
        ft_contract.account_id(),
        "ft_transfer_call",
        &json!({
            "receiver_id" : ido_contract.account_id(),
            "amount" : U128(100),
            "msg": "project_id:1"
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        1
    );

    
    print_result(&outcome);
    outcome.assert_success();

    let project_account_json :ProjectAccountJson = root.view(
        ido_contract.account_id(),
        "get_project_account_info",
        &json!({
            "project_id" : 1,
            "account_id" : alice.account_id(),
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("{:?}",project_account_json);

    let share_project_account_sale_json = project_account_json.sale_data.unwrap();
    assert_eq!(default_share_project_account_sale_json.committed_amount,
        share_project_account_sale_json.committed_amount,
        "Committed amount project 1 not match");

    let project_json : ProjectJson = root.view(
        ido_contract.account_id(),
        "get_project",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes()
    ).unwrap_json();
    assert_eq!(project_json.total_fund_committed,U128(100),"Total fund committed not match");
}
'''
'''--- ido/tests/sim_test/ido_test/whitelist_test.rs ---
use crate::utils::init;
use near_sdk::serde_json::json;
use near_sdk::json_types::{U64, U128};
use near_sdk_sim::{DEFAULT_GAS, to_yocto};
use kulapad_ido::modules::project::{ProjectJson,ProjectStatus,WhitelistType};
use kulapad_ido::modules::account::ProjectAccountJson;
use kulapad_ido::staking_contract::AccountJson;

#[test]
pub fn test_join_whitelist(){
    let (root,alice,ido,_,_,ido_contract) = init();
    
    ido.call(
        ido_contract.account_id(),
        "update_project_whitelist_date",
        &json!({
            "project_id" : 1,
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    ido.call(
        ido_contract.account_id(),
        "update_project_status",
        &json!({
            "project_id" : 1,
            "new_status": ProjectStatus::Whitelist
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    let project_json : ProjectJson = root.view(
        ido_contract.account_id(),
        "get_project",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("{:?}",project_json);
    assert_eq!(project_json.whitelist_type,WhitelistType::None,"Project 1 WhitelistType not match");

    let current_time : U64 = root.call(
        ido_contract.account_id(),
        "get_current_block_timestamp",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    ).unwrap_json();
    println!("Current time: {}",current_time.0);

    let mut is_whitelisted : bool = root.view(
        ido_contract.account_id(),
        "is_whitelist",
        &json!({
            "project_id" : 1,
            "account_id": alice.account_id()
        }).to_string().as_bytes()
    ).unwrap_json();

    
    assert_eq!(is_whitelisted,false, "Joined whitelist when not call");

    alice.call(
        ido_contract.account_id(),
        "register_whitelist",
        &json!({
            "project_id" : 1
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    let project_account_json :ProjectAccountJson = root.view(
        ido_contract.account_id(),
        "get_project_account_info",
        &json!({
            "project_id" : 1,
            "account_id" : alice.account_id(),
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("{:?}",project_account_json);

    is_whitelisted = root.view(
        ido_contract.account_id(),
        "is_whitelist",
        &json!({
            "project_id" : 1,
            "account_id": alice.account_id()
        }).to_string().as_bytes()
    ).unwrap_json();

    assert!(is_whitelisted, "Not join whitelist after register");

} 

#[test]
pub fn test_resolve_get_account_point_for_register_whitelist(){
    let (root,alice,ido,ft_contract,staking_contract,ido_contract) = init();

    // Storage deposit
    alice.call(
        staking_contract.account_id(), 
        "storage_deposit", 
        &json!({}).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    // Deposit token
    alice.call(
        ft_contract.account_id(), 
        "ft_transfer_call", 
        &json!({
            "receiver_id": staking_contract.account_id(),
            "amount": U128(1_000_000_000_000_000_000_000_000), //1000
            "msg": ""
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        1
    );

    // Lock token
    alice.call(
        staking_contract.account_id(),
        "lock",
        &json!({
            "amount" : U128(1_000_000_000_000_000_000),
            "locked_days": 100 as u32
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    let account_json : AccountJson = root.view(
        staking_contract.account_id(),
        "get_account_info",
        &json!({
            "account_id" : alice.account_id()
        }).to_string().as_bytes(),
    ).unwrap_json();
    println!("AccountJson: {:?}",account_json);

    let project : ProjectJson = root.view(
        ido_contract.account_id(),
        "get_project",
        &json!({
            "project_id" : 3
        }).to_string().as_bytes(),
    ).unwrap_json();

    if let WhitelistType::XToken(xtoken) = project.whitelist_type{
        assert!(account_json.point.0 >= xtoken,"Not enough XToken point");

        ido.call(
            ido_contract.account_id(),
            "update_project_whitelist_date",
            &json!({
                "project_id" : 3,
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        );
    
        ido.call(
            ido_contract.account_id(),
            "update_project_status",
            &json!({
                "project_id" : 3,
                "new_status": ProjectStatus::Whitelist
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        );

        // Register Whitelist
        alice.call(
            ido_contract.account_id(),
            "register_whitelist",
            &json!({
                "project_id" : 3
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        );

        let mut is_whitelisted : bool = root.view(
            ido_contract.account_id(),
            "is_whitelist",
            &json!({
                "project_id" : 2,
                "account_id" : alice.account_id()
            }).to_string().as_bytes(),
        ).unwrap_json();
        
        assert_eq!(is_whitelisted,false, "Joined whitelist when not call");

        is_whitelisted = root.view(
            ido_contract.account_id(),
            "is_whitelist",
            &json!({
                "project_id" : 3,
                "account_id" : alice.account_id()
            }).to_string().as_bytes(),
        ).unwrap_json();

        assert!(is_whitelisted,"Not join whitelist after register")
    } else{
        panic!("Whitelist type is not require xtokens");
    };

    

    
}
'''
'''--- ido/tests/sim_test/main.rs ---

mod staking_test;
mod ido_test;
mod utils;
'''
'''--- ido/tests/sim_test/staking_test.rs ---
use crate::utils::{init};
use kulapad_ido::staking_contract::AccountJson;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{DEFAULT_GAS, to_yocto};
use near_sdk_sim::transaction::ExecutionStatus;

const ALICE_DEPOSIT_AMOUNT: U128 = U128(10_000_000_000_000_000_000_000_000_000);

#[test]
pub fn test_deposit_and_stake(){
    let (root,alice,_,ft_contract,staking_contract,_) = init();
    // Storage deposit
    alice.call(
        staking_contract.account_id(), 
        "storage_deposit", 
        &json!({}).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    // Deposit token
    alice.call(
        ft_contract.account_id(), 
        "ft_transfer_call", 
        &json!({
            "receiver_id": staking_contract.account_id(),
            "amount": ALICE_DEPOSIT_AMOUNT,
            "msg": ""
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        1
    );

    let account_json: AccountJson = root.view(
        staking_contract.account_id(), 
        "get_account_info", 
        &json!({
            "account_id": alice.account_id()
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(account_json.account_id, alice.account_id());
    assert_eq!(account_json.staked_balance, U128(10_000_000_000_000_000_000_000_000_000));
    assert!(account_json.reward.0 > 0);
    assert_eq!(account_json.unstaked_balance.0, 0);
}

#[test]
pub fn test_deposit_and_stake_without_storage() {
    let (_, alice,_, ft_contract, staking_contract,_) = init();

    // Storage deposit
    // alice.call(
    //     staking_contract.account_id(), 
    //     "storage_deposit", 
    //     &json!({}).to_string().as_bytes(), 
    //     DEFAULT_GAS,
    //     to_yocto("0.01") 
    // );

    // Deposit token
    let outcome = alice.call(
        ft_contract.account_id(), 
        "ft_transfer_call", 
        &json!({
            "receiver_id": staking_contract.account_id(),
            "amount": ALICE_DEPOSIT_AMOUNT,
            "msg": ""
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        1
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("ERR_NOT_FOUND_ACCOUNT"));
    } else {
        unreachable!()
    }
}

'''
'''--- ido/tests/sim_test/utils.rs ---
use near_sdk::{serde_json::json, json_types::{U64,U128, ValidAccountId}};
use near_sdk_sim::{init_simulator, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT, to_yocto, ExecutionResult};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    IDO_WASM_FILE => "../res/kulapad_ido.wasm",
    STAKING_WASM_FILE => "../res/kulapad_staking.wasm",
    TOKEN_WASM_FILE => "../res/kulapad_token.wasm"
}

const STAKING_CONTRACT_ID: &str = "staking_contract";
const FT_CONTRACT_ID: &str = "ft_contract";
const IDO_CONTRACT_ID: &str = "ido_contract";
const FT_TOTAL_SUPPLY: U128 = U128(100_000_000_000_000_000_000_000_000_000);
const FT_STAKING_CONTRACT_BALANCE: U128 = U128(50_000_000_000_000_000_000_000_000_000);

pub fn init() -> (UserAccount, UserAccount, UserAccount,UserAccount, UserAccount, UserAccount) {
    let mut genesis = near_sdk_sim::runtime::GenesisConfig::default(); 
    genesis.genesis_time = 1651199572000000000;
    let root = init_simulator(Some(genesis));
    
    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    let ido = root.create_user("ido".to_string(),to_yocto("100"));

    let valid_alice : ValidAccountId = "alice".try_into().unwrap();
    let ft_contract = root.deploy_and_init(
        &TOKEN_WASM_FILE,
        FT_CONTRACT_ID.to_string(),
        "new_default_meta",
        &json!({
            "owner_id" : valid_alice,
            "total_supply" : U128(100_000_000_000_000_000_000_000_000_000),
        }).to_string().as_bytes(),
        STORAGE_AMOUNT, 
        DEFAULT_GAS
    );

    let staking_contract = root.deploy_and_init(
        &STAKING_WASM_FILE,
        STAKING_CONTRACT_ID.to_string(),
        "new_default_config",
        &json!({
            "owner_id": alice.account_id(),
            "ft_contract_id" : FT_CONTRACT_ID.to_string()
        }).to_string().as_bytes(),
        STORAGE_AMOUNT, 
        DEFAULT_GAS
    );

    let ido_contract = root.deploy_and_init(
        &IDO_WASM_FILE,
        IDO_CONTRACT_ID.to_string(),
        "new",
        &json!({
            "owner_id" : ido.account_id(),
            "staking_contract_id" : staking_contract.account_id()
        }).to_string().as_bytes(),
        STORAGE_AMOUNT, 
        DEFAULT_GAS
    );
    
    ido.call(
        ido_contract.account_id(),
        "create_sample_projects",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    );

    // storage deposit
    root.call(
        ft_contract.account_id(), 
        "storage_deposit", 
        &json!({
            "account_id": staking_contract.account_id()
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        to_yocto("0.1")
    );

    root.call(
        ft_contract.account_id(), 
        "storage_deposit", 
        &json!({
            "account_id": ido_contract.account_id()
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        to_yocto("0.1")
    );

    // Transfer 50% total supply to staking contract
    alice.call(
        ft_contract.account_id(), 
        "ft_transfer", 
        &json!({
            "receiver_id": staking_contract.account_id(),
            "amount": FT_STAKING_CONTRACT_BALANCE
        }).to_string().as_bytes(), 
        DEFAULT_GAS, 
        1
    );

    (root,alice,ido,ft_contract,staking_contract,ido_contract)
}

pub fn print_result(result: &ExecutionResult) {
    println!("{:?}", result);
    println!("{:?}", result.promise_results());

    for receipt_result in result.get_receipt_results() {
        if let Some(receipt_result) = receipt_result {
            print_result(&receipt_result);
        }
    }
}

#[test]
pub fn init_contract_test(){
    let (root,_,_,ft_contract,_,ido_contract) = init();
    let current_time : U64 = root.call(
        ido_contract.account_id(),
        "get_current_block_timestamp",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    ).unwrap_json();

    assert!(current_time.0 > 1651199597000000000,"Current time not match");
    println!("Current time: {}", current_time.0);
    // test deploy ft_contract
    let total_supply: U128 = root.view(
        ft_contract.account_id(), 
        "ft_total_supply",
        &json!({}).to_string().as_bytes()
    ).unwrap_json();

    println!("Total supply: {:?}", total_supply);
    assert_eq!(FT_TOTAL_SUPPLY, total_supply, "Total supply must equal {:?}", FT_TOTAL_SUPPLY);
}
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1651056695904-82084500074801
'''
'''--- staking-pool/Cargo.toml ---
[package]
name = "staking-contract"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"
near-contract-standards = "3.1.1"
<<<<<<< HEAD
=======

>>>>>>> 8690f32f4a5840544fd9547c92a37852721fe0eb
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- staking-pool/README.md ---
# Staking KULA-FT Contract 

## Roadmap

- [ ] 

'''
'''--- staking-pool/TESTING.md ---
# Staking KULA-FT Contract 

## Information
- FT contract id: ``` token-kulapad.testnet ```
- Staking contract id: ``` staking.kulapad-contract.testnet ```
- Staking contract owner id: ``` kulapad-contract.testnet ```
- User account id: ``` alice.kulapad-contract.testnet ```

<hr>

## Deployment

### Deploy & initialize contract
```
near deploy --wasmFile .\res\kulapad_staking.wasm --accountId staking.kulapad-contract.testnet --initFunction new_default_config --initArgs '{""owner_id"": ""kulapad-contract.testnet"", ""ft_contract_id"": ""token-kulapad.testnet""}'
```

Result
```
Transaction Id FvGQ5vs7yKNYUidAPqPCxcbkoyuyjRjEn1fM182Mdq18
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/FvGQ5vs7yKNYUidAPqPCxcbkoyuyjRjEn1fM182Mdq18
Done deploying and initializing staking.kulapad-contract.testnet
```
<hr>
## Owner

### Set tier config
```
near call staking.kulapad-contract.testnet set_tier_config '{""tier"": ""Tier1"", ""config"": {""min_point"": 10000000000}}' --accountId kulapad-contract.testnet
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.set_tier_config({"tier": "Tier1", "config": {"min_point": 10000000000}})
Doing account.functionCall()
Transaction Id 73STFqyrJPCcP2YAZoUvVHnMW8mKSV7UNEpxACr8o1mZ
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/73STFqyrJPCcP2YAZoUvVHnMW8mKSV7UNEpxACr8o1mZ
''
```

### Reset log
```
near call staking.kulapad-contract.testnet reset_lock '{""account_id"": ""alice.kulapad-contract.testnet""}' --accountId kulapad-contract.testnet
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.reset_lock({"account_id": "alice.kulapad-contract.testnet"})
Doing account.functionCall()
Transaction Id 41FNpMXbXnQuzzHGpqkhgGpWaj3WhJB5boqbGGbgKfWm
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/41FNpMXbXnQuzzHGpqkhgGpWaj3WhJB5boqbGGbgKfWm
''
```
<hr>
## Storage management
### Deposit storage fee to ```FT token``` for ```Staking contract```
```
near call token-kulapad.testnet storage_deposit --accountId staking.kulapad-contract.testnet --deposit 0.0125
```

Result
```
Scheduling a call: token-kulapad.testnet.storage_deposit() with attached 0.0125 NEAR
Doing account.functionCall()
Transaction Id Aj2n4BidZXduvmR613nXKMH12RJejh9NuJs6cyY1wtgu
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/Aj2n4BidZXduvmR613nXKMH12RJejh9NuJs6cyY1wtgu
{ total: '1250000000000000000000', available: '0' }
```

### Deposit storage fee to ```FT token``` for ```Alice```
```
near call token-kulapad.testnet storage_deposit --accountId alice.kulapad-contract.testnet --deposit 0.0125
```

### Get storage balance of ```Alice``` from ```FT token```
```
near view token-kulapad.testnet storage_balance_of '{""account_id"": ""alice.kulapad-contract.testnet""}'
```

Result
```
View call: token-kulapad.testnet.storage_balance_of({"account_id": "alice.kulapad-contract.testnet"})
{ total: '1250000000000000000000', available: '0' }
```

### Deposit storage fee to ```Staking contract``` for ```Alice```
```
near call staking.kulapad-contract.testnet storage_deposit --accountId alice.kulapad-contract.testnet --deposit 0.0125
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.storage_deposit() with attached 0.0125 NEAR
Doing account.functionCall()
Transaction Id BUaYP6V8j2ct3hvPzsHu6PwvmVkJ7Dt7mQ9DCMkhuXLC
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/BUaYP6V8j2ct3hvPzsHu6PwvmVkJ7Dt7mQ9DCMkhuXLC
''
```

### Get storage balance of ```Alice``` from ```Staking contract```
```
near view staking.kulapad-contract.testnet storage_balance_of '{""account_id"": ""alice.kulapad-contract.testnet""}'
```

Result
```
View call: staking.kulapad-contract.testnet.storage_balance_of({"account_id": "alice.kulapad-contract.testnet"})
'1'
```
<hr>
## FT contract
### Claim token from ```FT contract```

```
near call token-kulapad.testnet claim_testnet_token --accountId alice.kulapad-contract.testnet
```

Result
```
Scheduling a call: token-kulapad.testnet.claim_testnet_token()
Doing account.functionCall()
Receipt: 813CZtSr8GTuUt227BDE5bKe6W25jAJhS7f69FuJ4dLs
        Log [token-kulapad.testnet]: Transfer 20000000000 from token-kulapad.testnet to alice.kulapad-contract.testnet
Transaction Id Bw6F8aSuWu6LQ36sJmkxfsGYrUbyBiSTinU4ddXzkVDh
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/Bw6F8aSuWu6LQ36sJmkxfsGYrUbyBiSTinU4ddXzkVDh
''
```
<hr>
## Account info
### Get account info
```
near view staking.kulapad-contract.testnet get_account_info '{""account_id"": ""alice.kulapad-contract.testnet""}'
```

Result
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '0',
  unlocked_timestamp: 0,
  staked_balance: '0',
  unstaked_balance: '0',
  reward: '0',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1091,
  tier: 'Tier0',
  point: '0'
}
```
<hr>
## Staking
### Stake by calling to ```FT contract```
```
near call token-kulapad.testnet ft_transfer_call '{"receiver_id": "staking.kulapad-contract.testnet", "amount": "10000000000", "msg": ""}' --accountId alice.kulapad-contract.testnet --depositYocto 1 --gas 50000000000000
```

Result
```
Scheduling a call: token-kulapad.testnet.ft_transfer_call({"receiver_id": "staking.kulapad-contract.testnet", "amount": "10000000000", "msg": ""}) with attached 0.000000000000000000000001 NEAR
Doing account.functionCall()
Receipts: 5QYJvq36NH1vPg4CDYtTkKTkfYQWS3aWPcVp1u6dvH8X, CaHrgdzAKnBdX48Vs7G7kz7ssNXF4tTo2u45BGXX4fDE, 4HSH8rZPWJhGwNwxXAs7TRW4pHoHbJc1tbeFcfaKUTSo
        Log [token-kulapad.testnet]: Transfer 10000000000 from alice.kulapad-contract.testnet to staking.kulapad-contract.testnet
Transaction Id t13XdD9e5mZHnNj2fUvgFmvH5jisSt34Etn38qziQUB
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/t13XdD9e5mZHnNj2fUvgFmvH5jisSt34Etn38qziQUB
'10000000000'
```

Result for ```Account Info```
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '0',
  unlocked_timestamp: 0,
  staked_balance: '10000000000',
  unstaked_balance: '0',
  reward: '6649',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1091,
  tier: 'Tier0',
  point: '0'
}
```

## Staking & lock by calling to ```FT contract```
```
near call token-kulapad.testnet ft_transfer_call '{""receiver_id"": ""staking.kulapad-contract.testnet"", ""amount"": ""1000000000"", ""msg"": ""lock:360""}' --accountId alice.kulapad-contract.testnet --depositYocto 1 --gas 50000000000000
```

Result
```
Scheduling a call: token-kulapad.testnet.ft_transfer_call({"receiver_id": "staking.kulapad-contract.testnet", "amount": "1000000000", "msg": "lock:360"}) with attached 0.000000000000000000000001 NEAR
Doing account.functionCall()
Receipts: DAHVwWJTaRSAQYinwtjrhiQvVrb5i5xwyvRKvy5vUcRe, 6A5wN1UhUANRW65mKCNEe2haSLsXJzwUqY7LUsnwGWrd, 9wvx4b8kxhA4pMxLFVz1dnmkAQDciWVC87LaW3h3aXL6
        Log [token-kulapad.testnet]: Transfer 1000000000 from alice.kulapad-contract.testnet to staking.kulapad-contract.testnet
Receipt: BYdTCKymjfoh7msRPnamS73ADY8aAjXCYGMkmrTn2j15
        Log [token-kulapad.testnet]: Lock amount of 1000000000 KULA for account alice.kulapad-contract.testnet in 360 day(s).
Transaction Id Emj1hTQFTrvkpG5USXf9geRL2Xpdp1xvZ8FqkC8E1VGD
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/Emj1hTQFTrvkpG5USXf9geRL2Xpdp1xvZ8FqkC8E1VGD
'1000000000'
```

Result for ```Account Info```
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '1000000000',
  unlocked_timestamp: 4697781694644183000,
  staked_balance: '11000000000',
  unstaked_balance: '0',
  reward: '20655',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1091,
  tier: 'Tier0',
  point: '1000000000'
}
```

## Lock (```if locked_balanced = 0```)
```
near call staking.kulapad-contract.testnet lock '{""amount"": ""5000000000"", ""locked_days"": 36}' --accountId alice.kulapad-contract.testnet
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.lock({"amount": "5000000000", "locked_days": 36})
Doing account.functionCall()
Transaction Id HnMvtNdknW5wahxAiQ4exUhXnPBqnaFjEDtUHWMfzj2Z
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/HnMvtNdknW5wahxAiQ4exUhXnPBqnaFjEDtUHWMfzj2Z
''
```

Result for ```Account Info```
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '5000000000',
  unlocked_timestamp: 1655240612985729000,
  staked_balance: '11000000000',
  unstaked_balance: '0',
  reward: '981129',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1092,
  tier: 'Tier0',
  point: '500000000'
}
```

## Extend locked time
```
near call staking.kulapad-contract.testnet lock '{""amount"": ""0"", ""locked_days"": 1}' --accountId alice.kulapad-contract.testnet
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.lock({"amount": "0", "locked_days": 1})
Doing account.functionCall()
Transaction Id 9rEd6ejByQH2NjoDVv2RjfZrq9MSoUpD1EHGPnW2ZEZB
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/9rEd6ejByQH2NjoDVv2RjfZrq9MSoUpD1EHGPnW2ZEZB
''
```

Result for ```Account Info```
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '5000000000',
  locked_days: 37,
  unlocked_timestamp: 1655325212985729000,
  staked_balance: '11000000000',
  unstaked_balance: '0',
  reward: '1131429',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1092,
  tier: 'Tier0',
  point: '513888888'
}
```

## Increase locked amount
```
near call staking.kulapad-contract.testnet lock '{""amount"": ""5000000000"", ""locked_days"": 0}' --accountId alice.kulapad-contract.testnet
```

Result
```
Scheduling a call: staking.kulapad-contract.testnet.lock({"amount": "5000000000", "locked_days": 0})
Doing account.functionCall()
Transaction Id 6X2cBpaVBmSuYCkwfcTAKSCNrMmF5Qs4BdJqodjVw1xT
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/6X2cBpaVBmSuYCkwfcTAKSCNrMmF5Qs4BdJqodjVw1xT
''
```

Result for ```Account Info```
```
View call: staking.kulapad-contract.testnet.get_account_info({"account_id": "alice.kulapad-contract.testnet"})
{
  account_id: 'alice.kulapad-contract.testnet',
  locked_balance: '6000000000',
  unlocked_timestamp: 4697781694644183000,
  staked_balance: '11000000000',
  unstaked_balance: '0',
  reward: '383075',
  can_withdraw: true,
  start_unstake_timestamp: 0,
  unstake_available_epoch: 0,
  current_epoch: 1091,
  tier: 'Tier4',
  point: '5999992042'
}
```
'''
'''--- staking-pool/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/*.wasm ../res/kulapad_staking.wasm

cp target/wasm32-unknown-unknown/release/*.wasm res/kulapad_staking.wasm

read -p "Press any key to continue..."
'''
'''--- staking-pool/near_call.sh ---
MY_ACCOUNT="'$MY_ACCOUNT'"

near call staking-kulapad.testnet new_default_config '{"owner_id": "staking-kulapad.testnet","ft_contract_id": "token-kulapad.testnet"}' --accountId staking-kulapad.testnet

near view staking-kulapad.testnet get_account_reward '{"account_id": "'$MY_ACCOUNT'"}' --accountId $MY_ACCOUNT

near call staking-kulapad.testnet storage_deposit '{"account_id": "'$MY_ACCOUNT'"}' --accountId $MY_ACCOUNT --depositYocto 1770000000000000000000

near call token-kulapad.testnet ft_transfer_call '{"receiver_id": "staking-kulapad.testnet", "amount": "10000000000", "msg": ""}' --accountId $MY_ACCOUNT

near call staking-kulapad.testnet storage_deposit --accountId staking-kulapad.testnet --deposit 0.0125

near call staking-kulapad.testnet storage_balance_of '{"account_id": "'$MY_ACCOUNT'"}' --accountId $MY_ACCOUNT

near call token-kulapad.testnet storage_deposit --accountId staking-kulapad.testnet --deposit 0.0125

near deploy --accountId staking-kulapad.testnet --wasmFile res/kulapad-staking.wasm

near call token-kulapad.testnet ft_transfer_call '{"receiver_id": "staking-kulapad.testnet", "amount": "1000000000", "msg": "Stake KULA"}' --accountId $MY_ACCOUNT --depositYocto 1 --gas 50000000000000

near call staking-kulapad.testnet get_account_info '{"account_id": "'$MY_ACCOUNT'"}' --accountId $MY_ACCOUNT
near call staking-kulapad.testnet get_total_pending_reward --accountId staking-kulapad.testnet
near call staking-kulapad.testnet lock '{"amount": "500000000", "locked_time": 864000000000000}' --accountId   $MY_ACCOUNT

near call staking-kulapad.testnet unlock '{"amount": "500000000", "locked_time": 864000000000000}' --accountId   $MY_ACCOUNT

'''
'''--- staking-pool/near_call_dev.sh ---
near call dev-1646718348240-77300820554298 new_default_config '{"owner_id": "dev-1646718348240-77300820554298","ft_contract_id": "token-kulapad.testnet"}' --accountId dev-1646718348240-77300820554298

near call dev-1646718348240-77300820554298 new_default_config '{"owner_id": "dev-1646718348240-77300820554298","ft_contract_id": "token-kulapad.testnet"}' --accountId dev-1646718348240-77300820554298

near view dev-1646718348240-77300820554298 get_account_reward '{"account_id": "hoangtheanh.testnet"}' --accountId hoangtheanh.testnet

near call dev-1646718348240-77300820554298 storage_deposit '{"account_id": "hoangtheanh.testnet"}' --accountId hoangtheanh.testnet --depositYocto 1770000000000000000000

near call token-kulapad.testnet ft_transfer_call '{"receiver_id": "dev-1646718348240-77300820554298", "amount": "10000000000", "msg": ""}' --accountId hoangtheanh.testnet

near call dev-1646718348240-77300820554298 storage_deposit --accountId staking-kulapad.testnet --deposit 0.0125

near call dev-1646718348240-77300820554298 storage_balance_of '{"account_id": "hoangtheanh.testnet"}' --accountId hoangtheanh.testnet

near call token-kulapad.testnet storage_deposit --accountId dev-1646718348240-77300820554298 --deposit 0.0125

near deploy --accountId dev-1646718348240-77300820554298 --wasmFile res/kulapad-staking.wasm

near call token-kulapad.testnet ft_transfer_call '{"receiver_id": "dev-1646718348240-77300820554298", "amount": "1000000000", "msg": "2222221231232"}' --accountId hoangtheanh.testnet --depositYocto 1 --gas 50000000000000

near call dev-1646718348240-77300820554298 get_account_info '{"account_id": "hoangtheanh.testnet"}' --accountId hoangtheanh.testnet
near call dev-1646718348240-77300820554298 get_total_pending_reward --accountId dev-1646718348240-77300820554298
near call dev-1646718348240-77300820554298 lock '{"amount": "500000000", "locked_time": 864000000000000}' --accountId   hoangtheanh.testnet

near call dev-1646718348240-77300820554298 unlock '{"amount": "500000000", "locked_time": 864000000000000}' --accountId   hoangtheanh.testnet

'''
'''--- staking-pool/neardev/dev-account.env ---
CONTRACT_NAME=dev-1646718348240-77300820554298
'''
'''--- staking-pool/src/core_impl.rs ---
use near_sdk::Gas;

use crate::*;

pub const FT_TRANSFER_GAS: Gas = 10_000_000_000_000;
pub const WITHDRAW_CALLBACK_GAS: Gas = 10_000_000_000_000;
pub const HARVEST_CALLBACK_GAS: Gas = 10_000_000_000_000;

pub trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[ext_contract(ext_self)]
pub trait ExtStakingContract {
    fn ft_transfer_callback(&mut self, amount: U128, account_id: AccountId);
    fn ft_withdraw_callback(&mut self, account_id: AccountId, old_account: Account);
}

#[near_bindgen]
impl FungibleTokenReceiver for StakingContract {
    /**
     * Handle use transfer token to staking contract
     * 1. validate data
     * 2. handle stake
     */
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        let upgradable_account: Option<UpgradableAccount> = self.accounts.get(&sender_id);
        assert!(upgradable_account.is_some(), "ERR_NOT_FOUND_ACCOUNT");
        assert!(!self.paused, "ERR_CONTRACT_PAUSED");
        assert_eq!(self.ft_contract_id, env::predecessor_account_id(), "ERR_NOT_VALID_FT_CONTRACT");

        env::log(format!("ft_on_transfer(sender_id: {}, amount: {}, msg: {})", sender_id, amount.0, msg).as_bytes());
        println!("ft_on_transfer(sender_id: {}, amount: {}, msg: {})", sender_id, amount.0, msg);

        // Staking
        self.internal_deposit_and_stake(sender_id.clone(), amount.0);

        // Locking
        let args: Vec<&str> = msg.split(":").collect();
        if args.len() >= 1 {
            match args[0] {
                "lock" => {
                    let locked_days: DayType = args[1].trim().parse().unwrap();
                    self.internal_lock(sender_id.clone(), amount.0, locked_days);
                    env::log(format!("Lock amount of {} KULA for account {} in {} day(s).", amount.0, sender_id, locked_days).as_bytes());
                },
                _ => {}
            }
        }

        // return amount not used
        PromiseOrValue::Value(U128(0))
    }
}

#[near_bindgen]
impl StakingContract {

    #[payable]
    pub fn unstake(&mut self, amount: U128) {
        assert_one_yocto();
        let account_id: AccountId = env::predecessor_account_id();

        self.internal_unstake(account_id, amount.0);
    }
    
    pub fn lock(&mut self, amount: U128, locked_days: DayType) {
        let account_id: AccountId = env::predecessor_account_id();

        self.internal_lock(account_id, amount.0, locked_days);
    }

    pub fn unlock(&mut self) {
        let account_id: AccountId = env::predecessor_account_id();

        self.internal_unlock(account_id);
    }

    #[payable]
    pub fn withdraw(&mut self) -> Promise {
        assert_one_yocto();
        let account_id: AccountId = env::predecessor_account_id();
        let old_account: Account = self.internal_withdraw(account_id.clone());

        // handle transfer withdraw
        ext_ft_contract::ft_transfer(
            account_id.clone(), 
            U128(old_account.unstaked_balance), 
            Some(String::from("Staking contract withdraw")), 
            &self.ft_contract_id, 
            DEPOSIT_ONE_YOCTOR, 
            FT_TRANSFER_GAS
        ).then(
            ext_self::ft_withdraw_callback(
                account_id.clone(), 
                old_account, 
                &env::current_account_id(), 
                NO_DEPOSIT, 
                WITHDRAW_CALLBACK_GAS
            )
        )
    }

    #[payable]
    pub fn harvest(&mut self) -> Promise {
        assert_one_yocto();
        let account_id: AccountId = env::predecessor_account_id();
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let account: Account = Account::from(upgradable_account);

        let new_reward: Balance = self.internal_calculate_account_reward(&account);
        let current_reward: Balance = account.pre_reward + new_reward;
        assert!(current_reward > 0, "ERR_REWARD_EQUAL_ZERO");

        // Cross contract call
        ext_ft_contract::ft_transfer(
            account_id.clone(), 
            U128(current_reward), 
            Some("Staking contract harvest".to_string()), 
            &self.ft_contract_id, 
            DEPOSIT_ONE_YOCTOR, 
            FT_TRANSFER_GAS
        ).then(
            ext_self::ft_transfer_callback(
                U128(current_reward),
                account_id.clone(),
                &env::current_account_id(), 
                NO_DEPOSIT, 
                HARVEST_CALLBACK_GAS
            )
        )
    }

    #[private]
    pub fn ft_transfer_callback(&mut self, amount: U128, account_id: AccountId) -> U128 {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_value) => {
                let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
                let mut account: Account = Account::from(upgradable_account);

                // update account data
                account.pre_reward = 0;
                account.last_block_balance_change = env::block_index();

                self.accounts.insert(&account_id, &UpgradableAccount::from(account));
                self.total_paid_reward_balance += amount.0;

                amount
            },
            PromiseResult::Failed => env::panic(b"ERR_CALL_FAILED"),
        }
    }

    #[private]
    pub fn ft_withdraw_callback(&mut self, account_id: AccountId, old_account: Account) -> U128 {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_value) => {
                U128(old_account.unstaked_balance)
            },
            PromiseResult::Failed => {
                // Handle rollback data
                self.accounts.insert(&account_id, &UpgradableAccount::from(old_account));
                U128(0)
            },
        }
    }
}
'''
'''--- staking-pool/src/enumeration.rs ---
use crate::*;

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolInfo {
    pub total_stake_balance: U128,
    pub total_reward: U128,
    pub total_stakers: U128,
    pub is_paused: bool
}

#[near_bindgen]
impl StakingContract {
    /**
     * Get current reward by account_id
     */
    pub fn get_account_reward(&self, account_id: AccountId) -> Balance {
        if !self.accounts.contains_key(&account_id) {
            return 0;
        }
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let account: Account = Account::from(upgradable_account);
        let new_reward = self.internal_calculate_account_reward(&account);

        account.pre_reward + new_reward
    }

    pub fn get_account_info(&self, account_id: AccountId) -> Option<AccountJson> {
        // TODO: Luat: .unwrap() is dangerous and need to be handle
        // TODO: Handle the case user have not staked any token
        if !self.accounts.contains_key(&account_id) {
            return None;
        }
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let account: Account = Account::from(upgradable_account);
        let new_reward = self.internal_calculate_account_reward(&account);
        let tier = self.internal_get_tier(account.point);

        Some(AccountJson {
            account_id: account_id,
            locked_balance: U128(account.locked_balance),
            locked_days: account.locked_days,
            unlocked_timestamp: account.get_unlocked_timestamp(),
            staked_balance: U128(account.staked_balance),
            unstaked_balance: U128(account.unstaked_balance),
            reward: U128(account.pre_reward + new_reward),
            can_withdraw: account.unstake_available_epoch_height <= env::epoch_height(),
            start_unstake_timestamp: account.unstake_start_timestamp,
            unstake_available_epoch: account.unstake_available_epoch_height,
            current_epoch: env::epoch_height(),
            tier,
            point: U128(account.point),
        })
    }

    pub fn get_pool_info(&self) -> PoolInfo {
        PoolInfo {
            total_stake_balance: U128(self.total_stake_balance),
            total_reward: U128(self.pre_reward + self.internal_calculate_global_reward()),
            total_stakers: U128(self.total_staker),
            is_paused: self.paused
        }
    }
}

'''
'''--- staking-pool/src/internal.rs ---
use crate::*;

impl StakingContract {

    /**
     * User deposit FT token and stake
     * Handle use transfer token to staking contract
     * 1. validate data
     * 2. handle stake
     */
    pub(crate) fn internal_deposit_and_stake(&mut self, account_id: AccountId, amount: Balance) {

        let upgradable_account: Option<UpgradableAccount> = self.accounts.get(&account_id);
        assert!(upgradable_account.is_some(), "ERR_NOT_FOUND_ACCOUNT");
        assert!(!self.paused, "ERR_CONTRACT_PAUSED");
        assert_eq!(self.ft_contract_id, env::predecessor_account_id(), "ERR_NOT_VALID_FT_CONTRACT");

        // Check account exists
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(upgradable_account);

        if account.staked_balance == 0 {
            self.total_staker += 1;
        }

        // if exist account, update balance and update pre data
        let new_reward: Balance = self.internal_calculate_account_reward(&account);

        // update account data
        account.pre_stake_balance = account.staked_balance;
        account.pre_reward += new_reward;
        account.staked_balance += amount;
        account.last_block_balance_change = env::block_index();
        self.accounts.insert(&account_id, &UpgradableAccount::from(account));

        // Update contract data
        let new_contract_reward: Balance = self.internal_calculate_global_reward();
        self.total_stake_balance += amount;
        self.pre_reward += new_contract_reward;
        self.last_block_balance_change = env::block_index();

    }

    /// User lock token
    pub(crate) fn internal_lock(&mut self, account_id: AccountId, amount: Balance, locked_days: DayType) {

        // Check account exists
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(upgradable_account);
        let current_block_timestamp = env::block_timestamp();

        // Calculate xPoint
        account.calculate_point(
            amount, 
            locked_days, 
            self.config.min_locking_days, 
            self.config.max_locking_days, 
            current_block_timestamp
        );

        self.accounts.insert(&account_id, &UpgradableAccount::from(account));
    }

     // User lock token
     pub(crate) fn internal_unlock(&mut self, account_id: AccountId) {

        // Check account exists
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let mut account = Account::from(upgradable_account);

        if env::signer_account_id() != self.owner_id {
            assert!(account.get_unlocked_timestamp() <= env::block_timestamp(), "ERR_UNLOCK_TIMESTAMP_UNAVAILABLE");
        }

        // update account data
        account.locked_balance = 0;
        account.locked_timestamp = 0;
        account.locked_days = 0;
        account.point = 0;

        self.accounts.insert(&account_id, &UpgradableAccount::from(account));
    }

    pub(crate) fn internal_unstake(&mut self, account_id: AccountId, amount: Balance) {
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();

        let mut account = Account::from(upgradable_account);

        assert!(amount <= account.staked_balance - account.locked_balance, "ERR_AMOUNT_MUST_LESS_THAN_BALANCE");

        // if exist account, update balance and update pre data
        let new_reward: Balance = self.internal_calculate_account_reward(&account);

        // update account data
        account.pre_stake_balance = account.staked_balance;
        account.pre_reward += new_reward;
        account.staked_balance -= amount;
        account.last_block_balance_change = env::block_index();
        account.unstake_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        account.unstaked_balance += amount;
        account.unstake_start_timestamp = env::block_timestamp();

        if account.staked_balance == 0 {
            self.total_staker -= 1;
        }

        // update new account data
        self.accounts.insert(&account_id, &UpgradableAccount::from(account));

        // update contract data
        let new_contract_reward: Balance = self.internal_calculate_global_reward();
        self.total_stake_balance -= amount;
        self.pre_reward += new_contract_reward;
        self.last_block_balance_change = env::block_index();
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: AccountId) -> Account {
        let upgradable_account: UpgradableAccount = self.accounts.get(&account_id).unwrap();
        let account: Account = Account::from(upgradable_account);

        assert!(account.unstaked_balance > 0, "ERR_UNSTAKE_BALANCE_IS_ZERO");
        assert!(account.unstake_available_epoch_height <= env::epoch_height(), "ERR_DISABLE_WITHDRAW");

        let new_account: Account = Account {
            locked_balance: account.locked_balance,
            locked_timestamp: account.locked_timestamp,
            locked_days: account.locked_days,
            pre_reward: account.pre_reward,
            staked_balance: account.staked_balance,
            pre_stake_balance: account.pre_stake_balance,
            last_block_balance_change: account.last_block_balance_change,
            unstaked_balance: 0,
            unstake_start_timestamp: 0,
            unstake_available_epoch_height: 0,
            point: account.point,
        };

        self.accounts.insert(&account_id, &UpgradableAccount::from(new_account));

        account
    }

    pub(crate) fn internal_calculate_account_reward(&self, account: &Account) -> Balance {
        let lasted_block = if self.paused {
            self.paused_in_block
        } else {
            env::block_index()
        };
        let diff_block = lasted_block - account.last_block_balance_change;
        let reward: Balance = (account.staked_balance * self.config.reward_numerator as u128 * diff_block as u128) / (self.config.reward_denumerator as u128);
        reward
    }

    pub(crate) fn internal_calculate_global_reward(&self) -> Balance {
        let lasted_block = if self.paused {
            self.paused_in_block
        } else {
            env::block_index()
        };
        let diff_block = lasted_block - self.last_block_balance_change;
        let reward: Balance = (self.total_stake_balance * self.config.reward_numerator as u128 * diff_block as u128) / (self.config.reward_denumerator as u128);
        reward
    }

    pub(crate) fn internal_create_account(&mut self, account: AccountId) {
        let new_account = Account {
            locked_balance: 0,
            locked_timestamp: 0,
            locked_days: 0,
            staked_balance: 0,
            pre_stake_balance: 0,
            pre_reward: 0,
            last_block_balance_change: env::block_index(),
            unstaked_balance: 0,
            unstake_available_epoch_height: 0,
            unstake_start_timestamp: 0,
            point: 0,
        };

        let upgrade_account = UpgradableAccount::from(new_account);

        self.accounts.insert(&account, &upgrade_account);
    }
}

'''
'''--- staking-pool/src/lib.rs ---
mod core_impl;
mod enumeration;
mod internal;
mod modules;
mod util;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap};
use near_sdk::json_types::{U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BlockHeight, BorshStorageKey, EpochHeight,
    PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
};
use std::collections::HashMap;

pub use crate::enumeration::PoolInfo;
pub use crate::modules::account::{Account, AccountJson, UpgradableAccount};
use crate::modules::tier::{Tier, TierConfig, TierConfigsType};
use crate::util::*;

pub type DayType = u32;

pub const NO_DEPOSIT: Balance = 0;
pub const DEPOSIT_ONE_YOCTOR: Balance = 1;
pub const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 1;
pub const ONE_DAY_IN_NANOSECOND: u64 = 84600_000_000_000;
pub const POINT_100_PERCENT_IN_NANOSECOND: u64 = ONE_DAY_IN_NANOSECOND * 360;
pub const DEFAULT_TOKEN_DECIMAL: u8 = 8;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    // Percent reward per 1 block
    pub reward_numerator: u64,
    pub reward_denumerator: u64,
    pub total_apr: u64,

    // The config for each user Tier
    pub tier_configs: TierConfigsType,
    pub min_locking_days: DayType,
    pub max_locking_days: DayType,
}

impl Config {
    fn new_default_config() -> Self {
        // By default APR 15%
        Self {
            reward_numerator: 715,
            reward_denumerator: 100000000000,
            total_apr: 15,
            tier_configs: TierConfig::get_default_tier_configs(),
            min_locking_days: 1,
            max_locking_days: 360,
        }
    }

    fn new(
        reward_numerator: u64,
        reward_denumerator: u64,
        total_apr: u64,
        tier_configs: TierConfigsType,
        min_locking_days: DayType,
        max_locking_days: DayType,
    ) -> Self {
        Self {
            reward_numerator,
            reward_denumerator,
            total_apr,
            tier_configs,
            min_locking_days,
            max_locking_days
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new_default_config()
    }
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    AccountKey,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[near_bindgen]
pub struct StakingContract {
    pub owner_id: AccountId, // Owner of contract
    pub ft_contract_id: AccountId,
    pub config: Config,               // Config reward and apr for contract
    pub total_stake_balance: Balance, // Total token balance lock in contract
    pub total_paid_reward_balance: Balance,
    pub total_staker: Balance, // TODO: integer
    pub pre_reward: Balance,   // Pre reward before change total balance
    pub last_block_balance_change: BlockHeight,
    pub accounts: LookupMap<AccountId, UpgradableAccount>, // List staking user
    pub paused: bool,                                      // Pause staking pool with limit reward,
    pub paused_in_block: BlockHeight,
}

#[near_bindgen]
impl StakingContract {
    #[init]
    pub fn new_default_config(owner_id: AccountId, ft_contract_id: AccountId) -> Self {
        Self::new(owner_id, ft_contract_id, Config::default())
    }

    #[init]
    pub fn new(owner_id: AccountId, ft_contract_id: AccountId, config: Config) -> Self {
        StakingContract {
            owner_id,
            ft_contract_id,
            config,
            total_stake_balance: 0,
            total_paid_reward_balance: 0,
            total_staker: 0,
            pre_reward: 0,
            last_block_balance_change: env::block_index(),
            accounts: LookupMap::new(StorageKey::AccountKey),
            paused: false,
            paused_in_block: 0,
        }
    }

    pub fn get_total_pending_reward(&self) -> U128 {
        self.assert_owner();
        U128(self.pre_reward + self.internal_calculate_global_reward())
    }

    pub fn is_paused(&self) -> bool {
        self.paused
    }

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        assert_at_least_one_yocto();
        let account = account_id.unwrap_or_else(|| env::predecessor_account_id());

        let account_stake: Option<UpgradableAccount> = self.accounts.get(&account);
        if account_stake.is_some() {
            refund_deposit(0);
        } else {
            let before_storage_usage = env::storage_usage();
            self.internal_create_account(account.clone());
            let after_storage_usage = env::storage_usage();

            refund_deposit(after_storage_usage - before_storage_usage);
        }
    }

    // View func get storage balance, return 0 if account need deposit to interact
    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        let account: Option<UpgradableAccount> = self.accounts.get(&account_id);
        if account.is_some() {
            U128(1)
        } else {
            U128(0)
        }
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Only contract owner can be access."
        );
    }

    // Owner

    /// create or update tier min point config
    pub fn set_tier_config(&mut self, tier: Tier, config: TierConfig) {
        self.assert_owner();
        self.config.tier_configs.insert(tier, config);
    }

    pub fn reset_lock(&mut self, account_id: AccountId) {
        self.assert_owner();
        self.internal_unlock(account_id);
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .is_view(is_view);

        builder
    }

    #[test]
    fn init_default_contract_test() {
        let context = get_context(false);
        testing_env!(context.build());

        let contract: StakingContract =
            StakingContract::new_default_config(accounts(1).to_string(), "ft_contract".to_string());

        assert_eq!(
            contract.owner_id,
            accounts(1).to_string(),
            "Contract owner should be equal {}",
            accounts(1).to_string()
        );
        assert_eq!(
            contract.ft_contract_id,
            "ft_contract".to_string(),
            "FT contract id should be init data"
        );
        assert_eq!(
            contract.config.reward_numerator,
            Config::default().reward_numerator,
            "Config must be equal default"
        );
        assert_eq!(contract.paused, false);
    }

    #[test]
    fn init_contract_test() {
        let context = get_context(false);
        testing_env!(context.build());

        let contract: StakingContract = StakingContract::new(
            accounts(1).to_string(),
            "ft_contract".to_string(),
            Config {
                reward_numerator: 1500,
                reward_denumerator: 10000000,
                total_apr: 15,
                tier_configs: TierConfig::get_default_tier_configs(),
                min_locking_days: 1,
                max_locking_days: 360,
            },
        );

        assert_eq!(
            contract.owner_id,
            accounts(1).to_string(),
            "Contract owner should be equal {}",
            accounts(1).to_string()
        );
        assert_eq!(
            contract.ft_contract_id,
            "ft_contract".to_string(),
            "FT contract id should be init data"
        );
        assert_eq!(
            contract.config.reward_numerator, 1500,
            "Config must be equal default"
        );
        assert_eq!(contract.config.reward_denumerator, 10000000);
        assert_eq!(contract.paused, false);
    }

    #[test]
    fn test_internal_get_tier() {
        let context = get_context(false);
        testing_env!(context.build());

        let multiplier = 10u128.pow(DEFAULT_TOKEN_DECIMAL as u32);
        let contract = StakingContract::new_default_config(accounts(1).to_string(), accounts(1).to_string());

        // Tier0
        assert_eq!(Tier::Tier0, contract.internal_get_tier(0));
        assert_eq!(Tier::Tier0, contract.internal_get_tier(1 * multiplier));
        assert_eq!(Tier::Tier0, contract.internal_get_tier(100 * multiplier - 1));

        // Tier1
        assert_eq!(Tier::Tier1, contract.internal_get_tier(100 * multiplier));
        assert_eq!(Tier::Tier1, contract.internal_get_tier(100 * multiplier + 1));
        assert_eq!(Tier::Tier1, contract.internal_get_tier(1_000 * multiplier - 1));

        // Tier2
        assert_eq!(Tier::Tier2, contract.internal_get_tier(1_000 * multiplier));
        assert_eq!(Tier::Tier2, contract.internal_get_tier(1_000 * multiplier + 1));
        assert_eq!(Tier::Tier2, contract.internal_get_tier(5_000 * multiplier - 1));

        // Tier3
        assert_eq!(Tier::Tier3, contract.internal_get_tier(5_000 * multiplier));
        assert_eq!(Tier::Tier3, contract.internal_get_tier(5_000 * multiplier + 1));
        assert_eq!(Tier::Tier3, contract.internal_get_tier(10_000 * multiplier - 1));

        // Tier4
        assert_eq!(Tier::Tier4, contract.internal_get_tier(10_000 * multiplier));
        assert_eq!(Tier::Tier4, contract.internal_get_tier(10_000 * multiplier + 1));
    }

    #[test]
    fn deposit_and_stake_test() {
        let mut context = get_context(false);
        context.block_index(0);
        testing_env!(context.build());

        let mut contract: StakingContract =
            StakingContract::new_default_config(accounts(1).to_string(), accounts(1).to_string());
        contract.internal_create_account(env::predecessor_account_id());

        // Deposit and stake function call from FT contract
        context.predecessor_account_id(accounts(1));
        testing_env!(context.build());
        contract.internal_deposit_and_stake(accounts(0).to_string(), 10_000_000_000_000);

        context.block_index(10);
        context.predecessor_account_id(accounts(0));
        testing_env!(context.build());

        // Test deposit balance and
        let upgradable_account = contract.accounts.get(&accounts(0).to_string()).unwrap();
        let account: Account = Account::from(upgradable_account);

        assert_eq!(account.staked_balance, 10_000_000_000_000);
        assert_eq!(account.pre_reward, 0);
        assert_eq!(account.pre_stake_balance, 0);
        assert!(contract.internal_calculate_account_reward(&account) > 0);

        // test contract balance
        assert_eq!(contract.total_stake_balance, account.staked_balance);
        assert_eq!(contract.total_staker, 1);
        assert_eq!(contract.pre_reward, 0);
        assert_eq!(contract.last_block_balance_change, 0);

        // Test update stake balance of account
        // Deposit and stake function call from FT contract
        context.predecessor_account_id(accounts(1));
        testing_env!(context.build());
        contract.internal_deposit_and_stake(accounts(0).to_string(), 20_000_000_000_000);

        context.block_index(20);
        context.predecessor_account_id(accounts(0));
        testing_env!(context.build());

        // Test deposit balance and
        let upgradable_account_2 = contract.accounts.get(&accounts(0).to_string()).unwrap();
        let account_update: Account = Account::from(upgradable_account_2);

        assert_eq!(account_update.staked_balance, 30_000_000_000_000);
        assert!(account_update.pre_reward > 0);
        assert_eq!(account_update.pre_stake_balance, 10_000_000_000_000);
        assert_eq!(account_update.last_block_balance_change, 10);
        assert!(contract.internal_calculate_account_reward(&account_update) > 0);

        // test contract balance
        assert_eq!(contract.total_stake_balance, account_update.staked_balance);
        assert_eq!(contract.total_staker, 1);
        assert!(contract.pre_reward > 0);
        assert_eq!(contract.last_block_balance_change, 10);
    }

    #[test]
    fn unstake_test() {
        let mut context = get_context(false);
        context.block_index(0);
        testing_env!(context.build());

        let mut contract: StakingContract =
            StakingContract::new_default_config(accounts(1).to_string(), accounts(1).to_string());
        contract.internal_create_account(env::predecessor_account_id());

        // Deposit and stake function call from FT contract
        context.predecessor_account_id(accounts(1));
        testing_env!(context.build());
        contract.internal_deposit_and_stake(accounts(0).to_string(), 30_000_000_000_000);

        context.block_index(10);
        context.epoch_height(10);
        context.predecessor_account_id(accounts(0));
        testing_env!(context.build());

        contract.internal_unstake(accounts(0).to_string(), 10_000_000_000_000);

        // Test deposit balance and
        let upgradable_account = contract.accounts.get(&accounts(0).to_string()).unwrap();
        let account: Account = Account::from(upgradable_account);

        assert_eq!(account.staked_balance, 20_000_000_000_000);
        assert_eq!(account.unstaked_balance, 10_000_000_000_000);
        assert_eq!(account.last_block_balance_change, 10);
        assert_eq!(account.unstake_available_epoch_height, 11);
    }

    #[test]
    fn withdraw_test() {}

    #[test]
    fn update_tier_point_cfg_test() {}

    #[test]
    fn get_user_point_test() {}

    #[test]
    fn get_user_tier_test() {}
}
'''
'''--- staking-pool/src/modules.rs ---
pub mod account;
pub mod tier;

'''
'''--- staking-pool/src/modules/account.rs ---
use near_sdk::Timestamp;

use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub enum UpgradableAccount {
    Default(Account),
    Current(Account),
}

impl From<UpgradableAccount> for Account {
    fn from(account: UpgradableAccount) -> Self {
        match account {
            UpgradableAccount::Default(account) => account,
            UpgradableAccount::Current(account) => account,
        }
    }
}

impl From<Account> for UpgradableAccount {
    fn from(account: Account) -> Self {
        UpgradableAccount::Current(account)
    }
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub locked_balance: Balance,
    pub locked_timestamp: Timestamp,
    pub locked_days: DayType,
    pub staked_balance: Balance,
    pub pre_stake_balance: Balance,
    pub pre_reward: Balance,
    pub last_block_balance_change: BlockHeight,
    pub unstaked_balance: Balance,
    pub unstake_start_timestamp: Timestamp,
    pub unstake_available_epoch_height: EpochHeight,
    pub point: Balance,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountJson {
    pub account_id: AccountId,
    pub locked_balance: U128,
    pub locked_days: DayType,
    pub unlocked_timestamp: Timestamp,
    pub staked_balance: U128,
    pub unstaked_balance: U128,
    pub reward: U128,
    pub can_withdraw: bool,
    pub start_unstake_timestamp: Timestamp,
    pub unstake_available_epoch: EpochHeight,
    pub current_epoch: EpochHeight,
    pub tier: Tier,
    pub point: U128,
}

impl Account {
    pub fn get_available_unlocked_amount(&self) -> Balance {
        self.staked_balance - self.locked_balance
    }

    pub fn get_unlocked_timestamp(&self) -> Timestamp {
        self.locked_timestamp + self.locked_days as u64 * ONE_DAY_IN_NANOSECOND
    }

    pub fn get_remaining_locked_days(&self, current_timestamp: Timestamp) -> DayType {
        if self.get_unlocked_timestamp() <= current_timestamp {
            return 0;
        }

        let remaining_nanoseconds = self.get_unlocked_timestamp() - current_timestamp;

        (remaining_nanoseconds / ONE_DAY_IN_NANOSECOND) as DayType
    }

    pub fn calculate_point(
        &mut self,
        amount: Balance,
        locked_days: DayType,
        min_locking_days: DayType,
        max_locking_days: DayType,
        current_block_timestamp: Timestamp,
    ) {
        // Is the first lock? Required amount > 0 and locked_time >= 1 day in nanosecond
        if self.locked_balance == 0 {
            assert!(amount > 0, "ERR_AMOUNT_MUST_GREATER_THAN_ZERO");
            assert!(
                amount <= self.get_available_unlocked_amount(),
                "ERR_AMOUNT_MUST_LESS_THAN_BALANCE"
            );
            assert!(
                locked_days >= min_locking_days && locked_days <= max_locking_days,
                "ERR_LOCKED_DAYS_MUST_BETWEEN_MIN_AND_MAX"
            );

            self.point = Self::get_point(amount, Self::get_nanoseconds_from_days(locked_days));
            self.locked_balance = amount;
            self.locked_timestamp = current_block_timestamp;
            self.locked_days = locked_days;
        } else if amount > 0 {
            // Is increasing locked amount?
            assert!(
                locked_days == 0,
                "ERR_INCREASING_LOCKED_AMOUNT_THEN_DAYS_MUST_BE_ZERO"
            );
            assert!(
                amount <= self.get_available_unlocked_amount(),
                "ERR_AMOUNT_MUST_LESS_THAN_BALANCE"
            );
            assert!(
                self.get_unlocked_timestamp() > current_block_timestamp,
                "ERR_LOCK_TIME_EXPIRED"
            );

            self.point += Self::get_point(
                amount,
                self.get_unlocked_timestamp() - current_block_timestamp,
            );
            self.locked_balance += amount;
        } else if locked_days > 0 {
            // Is extending locked days?
            assert!(
                amount == 0,
                "ERR_EXTENDING_LOCKED_TIME_THEN_AMOUNT_MUST_BE_ZERO"
            );

            // The locked time is end but user has not unlocked token. -> Extend locked days & keep current point.
            if self.get_unlocked_timestamp() < current_block_timestamp {
                assert!(
                    locked_days >= min_locking_days && locked_days <= max_locking_days,
                    "ERR_LOCKED_DAYS_MUST_BETWEEN_MIN_AND_MAX"
                );

                self.point += Self::get_point(
                    self.locked_balance,
                    Self::get_nanoseconds_from_days(locked_days),
                );
                // When locked time is end, locked_days should be restarted.
                self.locked_days = locked_days;
            } else {
                // The locked time is on-going.
                let max_locking_days =
                    max_locking_days - self.get_remaining_locked_days(current_block_timestamp);
                assert!(
                    locked_days >= min_locking_days && locked_days <= max_locking_days,
                    "ERR_LOCKED_DAYS_MUST_BETWEEN_MIN_AND_MAX"
                );

                self.point += Self::get_point(
                    self.locked_balance,
                    Self::get_nanoseconds_from_days(locked_days),
                );
                // When locked time is on-going, locked_days should be accumulated.
                self.locked_days += locked_days;
            }
        } else {
            panic!("ERR_MUST_BE_SPECIFIC_TIME_OR_AMOUNT");
        }
    }

    /// The locked_time should be 1 day = 8460000000000000 nanoseconds
    pub fn get_point(amount: Balance, locked_time: Timestamp) -> Balance {
        let one_year_in_nanosecond: u64 = POINT_100_PERCENT_IN_NANOSECOND;
        amount * locked_time as u128 / one_year_in_nanosecond as u128
    }

    pub fn get_nanoseconds_from_days(days: DayType) -> Timestamp {
        days as u64 * ONE_DAY_IN_NANOSECOND
    }
}

#[cfg(all(test))]
mod tests {
    use super::*;
    const TOKEN_DECIMAL: u128 = DEFAULT_TOKEN_DECIMAL as u128;
    const MIN_LOCKING_DAYS: DayType = 1;
    const MAX_LOCKING_DAYS: DayType = 360;

    fn get_account(
        staked_balance: Balance,
        locked_balance: Balance,
        locked_days: DayType,
        locked_timestamp: Timestamp,
        point: Balance,
    ) -> Account {
        Account {
            locked_balance,
            locked_timestamp,
            locked_days,
            staked_balance,
            pre_stake_balance: 0,
            pre_reward: 0,
            last_block_balance_change: 0,
            unstaked_balance: 0,
            unstake_start_timestamp: 0,
            unstake_available_epoch_height: 0,
            point,
        }
    }

    fn get_balance_with_decimal(balance: Balance) -> Balance {
        balance * Balance::pow(10, TOKEN_DECIMAL as u32)
    }

    #[test]
    fn test_get_remaining_locked_days() {
        // Current timestamp: 1652151705_000_000_000 - 2022-05-10 3:01:45 (GMT)
        let current_block_timestamp: Timestamp = 1652151705_000_000_000;

        // Staked: 100, locked: 100, locked days: 36, locked timestamp: 16 days ago (remaining: 20 days), point: 10
        let current_staked_amount = get_balance_with_decimal(200);
        let current_locked_amount = get_balance_with_decimal(100);
        let current_locked_days = 36;
        let current_locked_timestamp = current_block_timestamp - ONE_DAY_IN_NANOSECOND * 16;
        let current_point = get_balance_with_decimal(10);

        let account = get_account(
            current_staked_amount,
            current_locked_amount,
            current_locked_days,
            current_locked_timestamp,
            current_point,
        );

        println!(
            "{:?}, unlocked_timestamp: {}, current_timestamp: {}",
            account,
            account.get_unlocked_timestamp(),
            current_block_timestamp
        );
        assert_eq!(
            20,
            account.get_remaining_locked_days(current_block_timestamp)
        );
    }

    #[test]
    #[should_panic(expected = "ERR_AMOUNT_MUST_GREATER_THAN_ZERO")]
    fn test_account_calculate_point_error_1() {
        let mut account = get_account(0, 0, 0, 0, 0);
        account.calculate_point(0, 0, 0, 0, 0);
    }

    fn test_account_calculate_point(
        current_block_timestamp: Timestamp,
        current_staked_amount: Balance,
        current_locked_amount: Balance,
        current_locked_days: DayType,
        current_locked_timestamp: Timestamp,
        current_point: Balance,
        locked_amount: Balance,
        locked_days: DayType,
        expected_locked_amount: Balance,
        expected_locked_days: DayType,
        expected_locked_timestamp: Timestamp,
        expected_point: Balance,
    ) {
        let mut account = get_account(
            current_staked_amount,
            current_locked_amount,
            current_locked_days,
            current_locked_timestamp,
            current_point,
        );

        account.calculate_point(
            locked_amount,
            locked_days,
            MIN_LOCKING_DAYS,
            MAX_LOCKING_DAYS,
            current_block_timestamp,
        );

        // Asserts locked_balance, locked_days, locked_timestamp, point
        assert_eq!(
            expected_locked_amount, account.locked_balance,
            "locked_amount"
        );
        assert_eq!(expected_locked_days, account.locked_days, "locked_days");
        assert_eq!(
            expected_locked_timestamp, account.locked_timestamp,
            "locked_timestamp"
        );
        assert_eq!(expected_point, account.point, "point");
    }

    #[test]
    fn test_account_calculate_point_for_lock() {
        // Current timestamp: 1652151705_000_000_000 - 2022-05-10 3:01:45 (GMT)
        let current_block_timestamp: Timestamp = 1652151705_000_000_000;

        // Staked: 100, locked: 0, locked days: 0, locked timestamp: , point: 0
        let current_staked_amount = get_balance_with_decimal(100);
        let current_locked_amount = get_balance_with_decimal(0);
        let current_locked_days = 0;
        let current_locked_timestamp = 0;
        let current_point = get_balance_with_decimal(0);

        // Lock 100 TOKEN for 36 days
        // * Amount: 100_00_000_000
        // * Locked days: 36 days
        // * Min locked days: 1 day
        // * Max locked days: 360 days
        let locked_amount = get_balance_with_decimal(100);
        let locked_days = 36;

        // Expected result
        let expected_locked_amount = locked_amount;
        let expected_locked_days = locked_days;
        let expected_locked_timestamp = current_block_timestamp;
        let expected_point = get_balance_with_decimal(10);

        test_account_calculate_point(
            current_block_timestamp,
            current_staked_amount,
            current_locked_amount,
            current_locked_days,
            current_locked_timestamp,
            current_point,
            locked_amount,
            locked_days,
            expected_locked_amount,
            expected_locked_days,
            expected_locked_timestamp,
            expected_point,
        );
    }

    #[test]
    fn test_account_calculate_point_for_extending_locked_time() {
        // Current timestamp: 1652151705_000_000_000 - 2022-05-10 3:01:45 (GMT)
        let current_block_timestamp: u64 = 1652151705_000_000_000;

        // Staked: 100, locked: 100, locked days: 36, locked timestamp: 16 days ago (remaining: 20 days), point: 10
        let current_staked_amount = get_balance_with_decimal(100);
        let current_locked_amount = get_balance_with_decimal(100);
        let current_locked_days = 36;
        let current_locked_timestamp = current_block_timestamp - ONE_DAY_IN_NANOSECOND * 16;
        let current_point = get_balance_with_decimal(10);

        // Extend locked time for 100 TOKEN for 36 days
        // * Amount: 0
        // * Locked days: 36 days (more)
        // * Min locked days: 1 day
        // * Max locked days: 360 days
        let locked_amount = get_balance_with_decimal(0);
        let locked_days = 36;

        // Expected result
        let expected_locked_amount = current_locked_amount;
        let expected_locked_days = current_locked_days + locked_days;
        let expected_locked_timestamp = current_locked_timestamp;
        let expected_point = current_point + get_balance_with_decimal(10);

        test_account_calculate_point(
            current_block_timestamp,
            current_staked_amount,
            current_locked_amount,
            current_locked_days,
            current_locked_timestamp,
            current_point,
            locked_amount,
            locked_days,
            expected_locked_amount,
            expected_locked_days,
            expected_locked_timestamp,
            expected_point,
        );
    }

    #[test]
    fn test_account_calculate_point_for_increasing_locked_amount() {
        // Current timestamp: 1652151705_000_000_000 - 2022-05-10 3:01:45 (GMT)
        let current_block_timestamp: u64 = 1652151705_000_000_000;

        // Staked: 100, locked: 100, locked days: 36, locked timestamp: 16 days ago (remaining: 20 days), point: 10
        let current_staked_amount = get_balance_with_decimal(200);
        let current_locked_amount = get_balance_with_decimal(100);
        let current_locked_days = 36;
        let current_locked_timestamp = current_block_timestamp - ONE_DAY_IN_NANOSECOND * 16;
        let current_point = get_balance_with_decimal(10);

        // Increase locked amount for 100 TOKEN more
        // * Amount: 100
        // * Locked days: remaining
        // * Min locked days: 1 day
        // * Max locked days: 360 days
        let locked_amount = get_balance_with_decimal(100);
        let locked_days = 0;

        // Expected result
        let expected_locked_amount = current_locked_amount + locked_amount;
        let expected_locked_days = current_locked_days;
        let expected_locked_timestamp = current_locked_timestamp;
        let expected_point = current_point + get_balance_with_decimal(100) * 20 / 360;

        test_account_calculate_point(
            current_block_timestamp,
            current_staked_amount,
            current_locked_amount,
            current_locked_days,
            current_locked_timestamp,
            current_point,
            locked_amount,
            locked_days,
            expected_locked_amount,
            expected_locked_days,
            expected_locked_timestamp,
            expected_point,
        );
    }
}

'''
'''--- staking-pool/src/modules/tier.rs ---
use crate::*;

pub type TierConfigsType = HashMap<Tier, TierConfig>;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Debug, Clone, Eq, Hash, PartialOrd, Copy)]
#[serde(crate = "near_sdk::serde")]
pub enum Tier {
    Tier0,
    Tier1,
    Tier2,
    Tier3,
    Tier4,
}

impl Default for Tier {
    fn default() -> Self {
        Tier::Tier0
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct TierConfig {
    pub min_point: Balance,
}

impl TierConfig {
    pub fn new(min_point: Balance) -> Self {
        Self { min_point }
    }

    pub fn get_default_tier_configs() -> TierConfigsType {
        TierConfig::get_default_tier_configs_multiple(DEFAULT_TOKEN_DECIMAL)
    }

    pub fn get_default_tier_configs_multiple(digits: u8) -> TierConfigsType{
        let mut cfg = TierConfigsType::new();
        let multiple = u128::pow(10, digits as u32);

        cfg.insert(Tier::Tier0, TierConfig::new(0));
        cfg.insert(Tier::Tier1, TierConfig::new(100 * multiple));
        cfg.insert(Tier::Tier2, TierConfig::new(1_000 * multiple));
        cfg.insert(Tier::Tier3, TierConfig::new(5_000 * multiple));
        cfg.insert(Tier::Tier4, TierConfig::new(10_000 * multiple));

        cfg
    }
}

impl StakingContract {
    pub(crate) fn internal_get_tier(&self, point: Balance) -> Tier {
        let mut configs = self.config.tier_configs.iter().map(|a| (*a.0, *a.1)).collect::<Vec<(Tier, TierConfig)>>();
        // Sort the list descending by min point
        configs.sort_by(|a, b| b.1.min_point.cmp(&a.1.min_point));

        for (tier, config) in configs {
            if point >= config.min_point {
                return tier;
            }
        }
        
        Tier::Tier0
    }
}
'''
'''--- staking-pool/src/util.rs ---
use crate::*;

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1,
    "Require attached deposit of exactly 1 yoctoNear");
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1,
    "Require attached deposit of at least 1 yoctoNear")
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNear to cover storage", required_cost
    );

    let refund = attached_deposit - required_cost;

    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
'''
'''--- staking-pool/tests/simulation-tests/main.rs ---
use near_sdk::{serde_json::json, json_types::U128};
use near_sdk_sim::{to_yocto};
use near_sdk_sim::transaction::ExecutionStatus;
use crate::utils::{init, storage_deposit, ft_transfer_call, get_account_info, print_result, 
    FT_TOTAL_SUPPY, FT_STAKING_CONTRACT_BALANCE, ALICE_DEPOSIT_BALANCE, 
};

mod utils;

#[test]
fn init_contract_test() {
    let (root, ft_contract, staking_contract, alice) = init();

    // test deploy ft_contract
    let total_suppy: String = root.view(
        ft_contract.account_id(), 
        "ft_total_supply",
        &json!({}).to_string().as_bytes()
    ).unwrap_json();

    println!("Total supply: {}", total_suppy);
    assert_eq!(FT_TOTAL_SUPPY, total_suppy, "Total supply must equal {}", FT_TOTAL_SUPPY);

    // test alice balance
    let alice_balance: String = root.view(
        ft_contract.account_id(), 
        "ft_balance_of", 
        &json!({
            "account_id": alice.account_id()
        }).to_string().as_bytes()
    ).unwrap_json();

    println!("Alice balance: {}", alice_balance);
    assert_eq!(FT_STAKING_CONTRACT_BALANCE, alice_balance, "Alice balance must equal {}", FT_STAKING_CONTRACT_BALANCE);

    // test staking contract balance
    let staking_balance: String = root.view(
        ft_contract.account_id(), 
        "ft_balance_of", 
        &json!({
            "account_id": staking_contract.account_id()
        }).to_string().as_bytes()
    ).unwrap_json();

    println!("Staking contract balance: {}", staking_balance);
    assert_eq!(FT_STAKING_CONTRACT_BALANCE, staking_balance, "Staking contract balance must equal {}", FT_STAKING_CONTRACT_BALANCE);
}

#[test]
fn deposit_and_stake_test() {
    let (_, ft_contract, staking_contract, alice) = init();

    // staking contract storage deposit
    storage_deposit(&staking_contract, &alice, to_yocto("0.01"));

    ft_transfer_call(&ft_contract, &staking_contract, &alice, ALICE_DEPOSIT_BALANCE, "");

    let account_json = get_account_info(&staking_contract, &alice);

    assert_eq!(account_json.account_id, alice.account_id());
    assert_eq!(account_json.staked_balance, U128(100000000000));
    assert!(account_json.reward.0 > 0);
    assert_eq!(account_json.unstaked_balance.0, 0);
}

#[test]
fn deposit_and_stake_and_lock_test() {
    let (_, ft_contract, staking_contract, alice) = init();

    // staking contract storage deposit
    storage_deposit(&staking_contract, &alice, to_yocto("0.01"));

    let outcome = ft_transfer_call(&ft_contract, &staking_contract, &alice, ALICE_DEPOSIT_BALANCE, "lock:36");

    print_result(&outcome);

    outcome.assert_success();

    let account_json = get_account_info(&staking_contract, &alice);

    assert_eq!(account_json.account_id, alice.account_id());
    assert_eq!(account_json.staked_balance, U128(100_000_000_000));
    assert_eq!(account_json.locked_balance, U128(100_000_000_000));
    assert_eq!(account_json.locked_days, 36);
    assert_eq!(account_json.point, U128(10_000_000_000));
    assert!(account_json.reward.0 > 0);
    assert_eq!(account_json.unstaked_balance.0, 0);
}

#[test]
fn deposit_and_stake_error_storage_test() {
    let (_, ft_contract, staking_contract, alice) = init();

    // Deposit without storage deposit
    let outcome = ft_transfer_call(&ft_contract, &staking_contract, &alice, ALICE_DEPOSIT_BALANCE, "");

    // Have one error
    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Error: {}", error.to_string());
        assert!(error.to_string().contains("ERR_NOT_FOUND_ACCOUNT"));
    } else {
        unreachable!();
    }
}
'''
'''--- staking-pool/tests/simulation-tests/utils.rs ---
use near_sdk::{Balance, serde_json::json};
use near_sdk::json_types::{U128};
use near_sdk_sim::{init_simulator, to_yocto, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT, ExecutionResult};
use staking_contract::AccountJson;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FT_METADATA_SPEC,
};
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FT_CONTRACT_WASM_FILE => "../res/kulapad_token.wasm",
    STAKING_CONTRACT_WASM_FILE => "../res/kulapad_staking.wasm"
}

const FT_CONTRACT_ID: &str = "ft_contract";
const STAKING_CONTRACT_ID: &str = "staking_contract";
pub const FT_TOTAL_SUPPY: &str = "100000000000000000";
pub const FT_STAKING_CONTRACT_BALANCE: &str = "50000000000000000";
pub const ALICE_DEPOSIT_BALANCE: Balance = 100_000_000_000;

pub fn init() -> (UserAccount, UserAccount, UserAccount, UserAccount) {
    let root = init_simulator(None);

    let alice = root.create_user("alice".to_string(), to_yocto("100"));

    let ft_token_metadata = FungibleTokenMetadata {
        spec: FT_METADATA_SPEC.to_string(),
        name: "KULA fungible token".to_string(),
        symbol: "KULA".to_string(),
        icon: None,
        reference: None,
        reference_hash: None,
        decimals: 8,
    };

    // Deploy and init 1B Token
    let ft_contract = root.deploy_and_init(
        &FT_CONTRACT_WASM_FILE,
        FT_CONTRACT_ID.to_string(),
        "new",
        &json!({
            "owner_id": alice.account_id(),
            "total_supply": FT_TOTAL_SUPPY,
            "metadata": ft_token_metadata,
        })
        .to_string()
        .as_bytes(),
        STORAGE_AMOUNT,
        DEFAULT_GAS,
    );

    // Deploy and init staking contract
    let staking_contract = root.deploy_and_init(
        &STAKING_CONTRACT_WASM_FILE,
        STAKING_CONTRACT_ID.to_string(),
        "new_default_config",
        &json!({
            "owner_id": alice.account_id(),
            "ft_contract_id": ft_contract.account_id()
        })
        .to_string()
        .as_bytes(),
        STORAGE_AMOUNT,
        DEFAULT_GAS,
    );

    // storage deposit
    root.call(
        ft_contract.account_id(),
        "storage_deposit",
        &json!({
            "account_id": staking_contract.account_id()
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        to_yocto("0.01"),
    );

    // Transfer 50% total supply to staking contract
    alice.call(
        ft_contract.account_id(),
        "ft_transfer",
        &json!({
            "receiver_id": staking_contract.account_id(),
            "amount": FT_STAKING_CONTRACT_BALANCE
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );

    (root, ft_contract, staking_contract, alice)
}

pub fn storage_deposit(
    contract: &UserAccount,
    account: &UserAccount,
    amount: Balance,
) -> ExecutionResult {
    account.call(
        contract.account_id(),
        "storage_deposit",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        amount,
    )
}

pub fn ft_transfer_call(
    ft_contract: &UserAccount,
    receiver_contract: &UserAccount,
    account: &UserAccount,
    amount: Balance,
    msg: &str,
) -> ExecutionResult {
    account.call(
        ft_contract.account_id(),
        "ft_transfer_call",
        &json!({
            "receiver_id": receiver_contract.account_id(),
            "amount": U128(amount),
            "msg": msg
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    )
}

pub fn get_account_info(staking_contract: &UserAccount, account: &UserAccount) -> AccountJson {
    let account_json: AccountJson = staking_contract
        .view(
            staking_contract.account_id(),
            "get_account_info",
            &json!({
                "account_id": account.account_id()
            })
            .to_string()
            .as_bytes(),
        )
        .unwrap_json();
    account_json
}

pub fn print_result(result: &ExecutionResult) {
    println!("{:?}", result);
    println!("{:?}", result.promise_results());

    for receipt_result in result.get_receipt_results() {
        if let Some(receipt_result) = receipt_result {
            print_result(&receipt_result);
        }
    }
}
'''
'''--- token-factory/Cargo.toml ---
[package]
name = "kulapad_token"
version = "0.1.0"
authors = ["Duy Thien <duythien0912@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- token-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/kulapad_token.wasm ../res 

cp target/wasm32-unknown-unknown/release/kulapad_token.wasm ../staking-pool/res 

read -p "Press any key to continue..."
'''
'''--- token-factory/deploy.sh ---
export file=../res/kulapad_token.wasm

near dev-deploy --wasmFile $file

read -p "Press any key to continue..."
'''
'''--- token-factory/mint.sh ---
source neardev/dev-account.env

# near call $CONTRACT_NAME storage_deposit '' --accountId $CONTRACT_NAME --amount 0.0125
# near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'", "total_supply": "10000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "KulaPad Token", "symbol": "KULA", "decimals": 8 }}' --accountId $CONTRACT_NAME

# [claim_testnet_token]
# near call $CONTRACT_NAME storage_deposit --accountId astral.testnet --deposit 0.0125
# near call $CONTRACT_NAME claim_testnet_token '' --accountId astral.testnet

'''
'''--- token-factory/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='500' height='500' style='shape-rendering:geometricPrecision;text-rendering:geometricPrecision;image-rendering:optimizeQuality;fill-rule:evenodd;clip-rule:evenodd'%3E%3Cpath style='opacity:1' d='M0 0h500v500H0V0Z'/%3E%3Cpath style='opacity:1' fill='%23fede2a' d='M156 84v8a401 401 0 0 0 1 40 71 71 0 0 0 9-11 71 71 0 0 0 8-12 391 391 0 0 0 22-31 7 7 0 0 1 4-3 342 342 0 0 1 37 0 4 4 0 0 1 3 3 22 22 0 0 1-3 5 36 36 0 0 0-6 8 252 252 0 0 0-26 33 4140 4140 0 0 0 45 96 4 4 0 0 1-2 2 840 840 0 0 1-41 1 9 9 0 0 1-7-3 76899 76899 0 0 1-14-33l-5-12a112 112 0 0 1-5-11l-2-1a165 165 0 0 0-17 19 382 382 0 0 0-2 38 4 4 0 0 1-1 2 164 164 0 0 1-25 1h-9l-9-2V77l2-2a420 420 0 0 1 41 0 11 11 0 0 1 2 9Z'/%3E%3Cpath style='opacity:1' fill='%23fddd2a' d='M308 84v89c1 8 4 14 12 18a11 11 0 0 0 7 2c12 1 20-4 24-15a2721 2721 0 0 0 2-101l2-2a289 289 0 0 1 34 0l1 2-1 104c-3 18-13 31-29 38a120 120 0 0 1-54 4 72 72 0 0 1-21-7 57 57 0 0 1-22-43V77l2-2h42a20 20 0 0 1 1 9Z'/%3E%3Cpath style='opacity:1' fill='%237e6e15' d='M156 84c6-2 9 1 9 8h-9v-8Z'/%3E%3Cpath style='opacity:1' fill='%237d6d15' d='m237 83 11 2c1 2 0 4-1 6l-2 2-14-2a36 36 0 0 1 6-8Z'/%3E%3Cpath style='opacity:1' fill='%237f6f15' d='M308 84c7-2 10 1 9 8h-9v-8Z'/%3E%3Cpath style='opacity:1' fill='%23a6911c' d='M156 92h9c-1 9 0 19 1 29a71 71 0 0 1-9 11 401 401 0 0 1-1-40Z'/%3E%3Cpath style='opacity:1' fill='%234d430c' d='M165 92c3-1 6 0 8 2l1 15a71 71 0 0 1-8 12c-1-10-2-20-1-29Z'/%3E%3Cpath style='opacity:1' fill='%23a48f1b' d='m231 91 14 2a1388 1388 0 0 1-29 35 12 12 0 0 0-2 5 4140 4140 0 0 0 45 96 4 4 0 0 1-2 2 840 840 0 0 1-41 1c-6-1-9-4-9-9l41-1a4 4 0 0 0 2-2 4140 4140 0 0 1-45-96 252 252 0 0 1 26-33Z'/%3E%3Cpath style='opacity:1' fill='%234c420c' d='m247 91 9 2a5 5 0 0 1 0 5 1069 1069 0 0 0-34 43 11581 11581 0 0 0 44 92v6a334 334 0 0 1-44 0 12 12 0 0 1-6-7l41-1a4 4 0 0 0 2-2 4140 4140 0 0 1-45-96 12 12 0 0 1 2-5 1388 1388 0 0 0 29-35l2-2Z'/%3E%3Cpath style='opacity:1' fill='%23a7921c' d='M308 92h9v90a32 32 0 0 0 3 9c-8-4-11-10-12-18V92Z'/%3E%3Cpath style='opacity:1' fill='%234e440d' d='M317 92c3-1 6 0 8 2a5230 5230 0 0 0 2 99l-7-2a32 32 0 0 1-3-9V92Z'/%3E%3Cpath style='opacity:1' fill='%23a6911c' d='m390 77 1 7v8h8v90c-1 22-11 37-30 46a115 115 0 0 1-62 2 99 99 0 0 1-12-5 32 32 0 0 1-10-9 72 72 0 0 0 21 7c18 3 36 1 54-4 16-7 26-20 29-38l1-104Z'/%3E%3Cpath style='opacity:1' fill='%23766813' d='M391 84c6-2 9 1 9 8a2026 2026 0 0 1-1 90V92h-8v-8Z'/%3E%3Cpath style='opacity:1' fill='%234c420c' d='M400 92a15 15 0 0 1 7 1 1667 1667 0 0 1 0 100c-2 25-16 40-40 46a110 110 0 0 1-54-2 38 38 0 0 1-18-12 99 99 0 0 0 12 5c20 5 41 4 62-2 19-9 29-24 30-46a2026 2026 0 0 0 1-90Z'/%3E%3Cpath style='opacity:1' fill='%23a6911b' d='M181 175a4 4 0 0 0-4 2l-12 16a724 724 0 0 1-1 37 4 4 0 0 1-2 1l-33 1v-9l25-1a4 4 0 0 0 1-2 382 382 0 0 1 2-38 165 165 0 0 1 17-19l2 1a112 112 0 0 0 5 11Z'/%3E%3Cpath style='opacity:1' fill='%234c420c' d='m181 175 5 12a78 78 0 0 0-12 14l-1 36-1 1a216 216 0 0 1-41 1 9 9 0 0 1-2-7l33-1a4 4 0 0 0 2-1 724 724 0 0 0 1-37l12-16a4 4 0 0 1 4-2Z'/%3E%3Cpath style='opacity:1' fill='%23807015' d='M120 223h9v9c-8 1-11-2-9-9Z'/%3E%3Cpath style='opacity:1' fill='%23fcdc2a' d='M158 256v108l9 1h58l2 10-1 22-1 1-96 1h-9c-4 0-7-1-9-3V249l3-3h42l2 10Z'/%3E%3Cpath style='opacity:1' fill='%23fddd2a' d='M344 256a5628 5628 0 0 1 48 138l-1 4-34 1h-6l-6-1a59 59 0 0 1-3-10 71 71 0 0 1-3-9 56 56 0 0 0-4-10 552 552 0 0 0-47 0 339 339 0 0 0-11 28 9 9 0 0 1-2 1 113 113 0 0 1-15 1h-15a7 7 0 0 1-7-2c0-5 1-9 3-13a10865 10865 0 0 1 48-135l3-3h45c4 2 6 5 7 10Z'/%3E%3Cpath style='opacity:1' fill='%237d6d15' d='M158 256c7-2 10 1 9 9h-9v-9Z'/%3E%3Cpath style='opacity:1' fill='%23a7911c' d='M158 265h9v100l-9-1v-99Z'/%3E%3Cpath style='opacity:1' fill='%234d430d' d='M167 265c3-1 6 0 8 2l1 98h-9V265Z'/%3E%3Cpath style='opacity:1' fill='%23a38e1b' d='M344 256a12 12 0 0 1 9 9 8548 8548 0 0 1 48 139l-1 4-39 1h-1a43 43 0 0 0-3-10l34-1 1-4a5628 5628 0 0 0-48-138Z'/%3E%3Cpath style='opacity:1' fill='%234c420c' d='M353 265c4 1 7 3 8 8a6951 6951 0 0 1 49 140l-1 4a484 484 0 0 1-44 0 11 11 0 0 1-4-8l39-1 1-4a8548 8548 0 0 0-48-139Z'/%3E%3Cpath style='opacity:1' fill='%23a7921c' d='M318 310a129 129 0 0 0-9 24h15-27a308 308 0 0 1 13-39c0-2 1-2 2 0a134 134 0 0 0 6 15Z'/%3E%3Cpath style='opacity:1' fill='%234f450d' d='M318 310a285 285 0 0 0 6 18 9 9 0 0 0-3 6h-12a129 129 0 0 1 9-24Z'/%3E%3Cpath style='opacity:1' fill='%23131003' d='M324 328v6h-3a9 9 0 0 1 3-6Z'/%3E%3Cpath style='opacity:1' fill='%23a7921c' d='M339 379h-42a703 703 0 0 0-11 28 148 148 0 0 1-29 2 43 43 0 0 0 3-10 113 113 0 0 0 15-1 9 9 0 0 0 2-1 339 339 0 0 1 11-28 552 552 0 0 1 47 0 56 56 0 0 1 4 10Z'/%3E%3Cpath style='opacity:1' fill='%237c6c15' d='M228 375c6-1 9 2 8 9h-8v-9Z'/%3E%3Cpath style='opacity:1' fill='%234e440d' d='M339 379a71 71 0 0 0 3 9h-36a778 778 0 0 1-12 29h-36c-3-3-3-5-1-8l29-2a703 703 0 0 1 11-28h42Z'/%3E%3Cpath style='opacity:1' fill='%23a5901b' d='M227 375h1v9h8l-1 23-1 1-104 1h-1v-10l96-1 1-1 1-22Z'/%3E%3Cpath style='opacity:1' fill='%234d430d' d='M236 384h5a31 31 0 0 0-3 13 7 7 0 0 0 7 2 145 145 0 0 1-1 17l-1 1H132a11 11 0 0 1-2-8l104-1 1-1 1-23Z'/%3E%3Cpath style='opacity:1' fill='%23796a14' d='M120 399h9v10c-8 0-11-3-9-10Z'/%3E%3Cpath style='opacity:1' fill='%237d6e15' d='M248 399h12a43 43 0 0 1-3 10c-9 1-12-2-9-10Z'/%3E%3Cpath style='opacity:1' fill='%237c6c15' d='M351 399h6a43 43 0 0 1 3 10l-6-1a151 151 0 0 1-3-9Z'/%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }

    // Claim testnet tokens
    pub fn claim_testnet_token(&mut self) {
        let sender_id = env::current_account_id();
        let receiver_id = env::signer_account_id();
        assert_ne!(
            sender_id, receiver_id,
            "Sender and receiver should be different"
        );

        // Check if receiver end with ".testnet"
        if !receiver_id.ends_with(".testnet") {
            env::panic(b"Receiver should be testnet account");
        }

        let transfer_amount: Balance = 20000000000;
        self.token
            .internal_transfer(&sender_id, &receiver_id, transfer_amount.into(), None);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- token-factory/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''