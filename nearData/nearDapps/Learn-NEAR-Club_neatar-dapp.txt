*GitHub Repository "Learn-NEAR-Club/neatar-dapp"*

'''--- .cargo/audit.toml ---
[advisories]
ignore = [
  "RUSTSEC-2020-0159",
  "RUSTSEC-2020-0071",
  "RUSTSEC-2021-0110",
  "RUSTSEC-2021-0089",
  "RUSTSEC-2020-0077",
]
# warn for categories of informational advisories
informational_warnings = [
    "unmaintained",
    "unsound",
]

[target]
arch = "wasm32"

'''
'''--- .cargo/config.toml ---
[build]
rustflags = ["-C", "link-arg=-s"]

'''
'''--- .docker/builder/builder.sh ---
#!/usr/bin/env bash

set -o errexit

ROOT_PATH=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd ../../ && pwd )

echo "Building the docker image"
docker build \
  --network host \
  --tag builder \
  "$ROOT_PATH/.docker/builder"

echo "Building the contract"
docker run \
  --network host \
  --volume "$ROOT_PATH:/code" \
  --env HOST_OWNER="$(id -u):$(id -g)" \
  --workdir /code \
  --rm builder \
  "${@:-src/contract/build.sh}"

'''
'''--- .github/workflows/contract.yml ---
name: contract

on:
  push:
    paths:
      - '.cargo/**'
      - 'src/contract/**'
      - '!src/contract/**/*.ts'
      - '!src/contract/**/*.js'
      - 'Cargo.lock'
      - 'Cargo.toml'
      - 'toolchain.toml'
      - '.github/workflows/contract.yml'
    branches:
      - main
  pull_request:
    paths:
      - '.cargo/**'
      - 'src/contract/**'
      - '!src/contract/**/*.ts'
      - '!src/contract/**/*.js'
      - 'Cargo.lock'
      - 'Cargo.toml'
      - 'toolchain.toml'
      - '.github/workflows/contract.yml'
    branches:
      - main

jobs:

  qa:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/cache@v2
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
      - uses: actions-rs/toolchain@v1
        with:
          target: wasm32-unknown-unknown
          toolchain: stable
          components: rustfmt, clippy
          profile: minimal
          override: true
      - run: make qa

  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

'''
'''--- Cargo.toml ---
[workspace]
members = [
  "src/contract/neatar",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/3123272
overflow-checks = true

'''
'''--- package.json ---
{
  "name": "neatar",
  "description": "The Web3 avatar like as Gravatar",
  "version": "1.0.0-alpha.0",
  "repository": "https://github.com/neatar/dapp",
  "license": "UNLICENSED",
  "browserslist": [
    "defaults",
    "Firefox ESR",
    "not IE 11"
  ],
  "scripts": {
    "postinstall": "yarn --silent build-asset",
    "build-asset": "pwa-asset-generator src/web/asset/logo.svg src/web/asset/icon --favicon --favicon --type png --padding 0 --background transparent --opaque false --log false",
    "build-web": "parcel build src/web/index.html --public-url ./ --out-dir build/web",
    "deploy-web": "yarn --silent build-web && gh-pages --repo git@github.com:neatar/neatar.github.io.git --dist build/web",
    "start": "parcel src/web/index.html --open"
  },
  "devDependencies": {
    "@4ire-labs/near-sdk": "1.0.0-beta.8",
    "env-cmd": "^10.1.0",
    "gh-pages": "^3.2.3",
    "near-api-js": "^0.42.0",
    "parcel-bundler": "^1.12.5",
    "pwa-asset-generator": "^4.3.6",
    "ts-node": "^10.2.1",
    "typescript": "<4.4.0"
  }
}

'''
'''--- readme.md ---
<div align="center">
  <h1><code>neatar</code></h1>
  <img src="https://raw.githubusercontent.com/neatar/dapp/main/src/web/asset/logo.svg" alt="neatar logo" />
  <p>
    <strong>The Web3 avatar like as Gravatar</strong>
  </p>
  <p>
    <a href="https://neatar.github.io/">neatar.github.io</a>
  </p>
</div>

# Docs API

See an example of integration for a third-party service: https://replit.com/@neatar/demo#index.html

## Getting avatar

```http request
POST https://rest.nearapi.org/view
Content-Type: application/json

{
  "contract": "alpha.neatar.testnet",
  "method": "avatar_of",
  "params": {
    "account_id": "ilyar.testnet"
  },
  "rpc_node": "https://rpc.testnet.near.org"
}
```

**Via curl**

```shell
curl https://rest.nearapi.org/view -H 'content-type: application/json' \
--data-raw '{
  "contract": "alpha.neatar.testnet",
  "method": "avatar_of",
  "params": {
    "account_id": "ilyar.testnet"
  },
  "rpc_node": "https://rpc.testnet.near.org"
}'
```

**Example response:**

```text
data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMSAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiMwMDAiIHN0cm9rZT0iIzAwMCIvPjwvc3ZnPg0=
```

'''
'''--- src/contract/build.sh ---
#!/usr/bin/env bash

set -o errexit

ROOT_PATH=$(cd "$( dirname "${BASH_SOURCE[0]}" )" && cd ../../ && pwd)

# cargo install wasm-snip wasm-gc
# apt-get install -y binaryen wabt
# https://github.com/near/near-sdk-rs/tree/master/minifier
minify() {
  if [ "$(command -v wasm-snip wasm-gc wasm-strip wasm-opt | wc -l)" != 4 ]; then
    echo "Minifying skipped"
    return
  fi
  filePath="${1}"
  fileSize=$(stat -c "%s" "${filePath}")
  fileName=$(basename -- "${filePath}")
  dirPath=$(dirname -- "${filePath}")
  tmpPath="${dirPath}/temp-${fileName}"
  outFileName="${fileName%.*}.${fileName##*.}"
  outPath="${dirPath}/${outFileName}"
  wasm-snip \
    --snip-rust-fmt-code \
    --snip-rust-panicking-code \
    --pattern core::num::flt2dec::.* \
    --pattern core::fmt::float::.* \
    --output "${tmpPath}" \
    "${filePath}"
  wasm-gc "${tmpPath}"
  wasm-strip "${tmpPath}"
  wasm-opt -Oz "${tmpPath}" --output "${outPath}"
  rm "${tmpPath}"
  outSize=$(stat -c "%s" "${outPath}")
  echo "Minifying ${fileName} ${fileSize} bytes -> ${outSize} bytes, see ${outFileName}"
}

build() {
  package="${1}"
  out="${2:-build/contract}"
  cargo build --package "${package}" --target wasm32-unknown-unknown --release
  mkdir -p "${out}"
  path="${out}/${package}.wasm"
  cp target/wasm32-unknown-unknown/release/*.wasm "${out}/"
  echo "${path}"
  minify "${path}"
  printf "size: %s\n" "$(stat -c "%s" "${path}")"
  printf "hash: %s\n" "$(sha256sum "${path}" | cut -d' ' -f1)"
}

cd "$ROOT_PATH"
build neatar

# FIXME setup not root user in docker
HOST_OWNER=${HOST_OWNER:-"$(id -u):$(id -g)"}
chown "$HOST_OWNER" -R "$ROOT_PATH"

'''
'''--- src/contract/neatar/Cargo.toml ---
[package]
name = "neatar"
homepage = "https://neatar.github.io/"
description = "The Web3 avatar"
version = "1.0.0-alpha.0"
edition = "2018"
license = "UNLICENSED"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]
path = "neatar.rs"
test = true
doctest = false
bench = false
doc = false

[dependencies]
lazy_static = "1.4.0"
lazy-static-include = "3.1.1"
near-sdk = "4.0.0-pre.4"
near-contract-standards = "4.0.0-pre.4"
cid = "0.7.0"
hex = "0.4.3"
palette = "0.6.0"
svg = "0.10.0"
anyhow = "1.0.42"
base64 = "0.13.0"
blake2-rfc = "0.2.18"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"

'''
'''--- src/contract/neatar/identicon.rs ---
use anyhow::anyhow;
use blake2_rfc::blake2b::blake2b;
use palette::{FromColor, FromComponent, Hsl, RgbHue, Srgb};
use svg::node::element;
use svg::Document;

const HALF_SVG: i32 = 32;
pub const FOREGROUND_COLOR: [u8; 4] = [238, 238, 238, 255];

pub fn make(into_id: &[u8]) -> String {
    svg_from_vec(into_id, HALF_SVG)
        .to_string()
        .replace("\n", "")
}

/// Function to choose the coloring scheme based on value d.
/// Note that d is calculated as remainder of division by total sum of frequencies,
/// so it can not exceed the total sum of frequencies
fn choose_scheme(schemes: Vec<SchemeElement>, d: u32) -> anyhow::Result<SchemeElement> {
    let mut sum = 0;
    let mut found_scheme = None;
    for x in schemes.into_iter() {
        sum += x.freq as u32;
        if d < sum {
            found_scheme = Some(x);
            break;
        }
    }
    match found_scheme {
        Some(x) => Ok(x),
        None => Err(anyhow!("not accessible")),
    }
}

/// Struct to store default coloring schemes
struct SchemeElement {
    freq: u8,
    colors: [usize; 19],
}

/// Function to set default coloring schemes, taken as is from js code
fn default_schemes() -> Vec<SchemeElement> {
    vec![
        SchemeElement {
            // "target"
            freq: 1,
            colors: [
                0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 1,
            ],
        },
        SchemeElement {
            // "cube",
            freq: 20,
            colors: [0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 5],
        },
        SchemeElement {
            // "quazar",
            freq: 16,
            colors: [1, 2, 3, 1, 2, 4, 5, 5, 4, 1, 2, 3, 1, 2, 4, 5, 5, 4, 0],
        },
        SchemeElement {
            // "flower",
            freq: 32,
            colors: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3],
        },
        SchemeElement {
            // "cyclic",
            freq: 32,
            colors: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6],
        },
        SchemeElement {
            // "vmirror",
            freq: 128,
            colors: [0, 1, 2, 3, 4, 5, 3, 4, 2, 0, 1, 6, 7, 8, 9, 7, 8, 6, 10],
        },
        SchemeElement {
            // "hmirror",
            freq: 128,
            colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 6, 7, 5, 3, 4, 2, 11],
        },
    ]
}

/// Struct to store information about circle center position
/// For 19-circle icons circle positions are set as defaults
struct CirclePosition {
    x_center: i32,
    y_center: i32,
}

/// Helper function to transform RGBA [u8; 4] color needed for png into
/// hex string color needed for svg
fn rgba_to_hex(rgba_color: [u8; 4]) -> String {
    format!(
        "#{}",
        hex::encode(vec![rgba_color[0], rgba_color[1], rgba_color[2]])
    )
}

/// Function to set default positions of small circles in 19-circle icon
/// a is center_to_center distance
fn position_circle_set(a: i32) -> Vec<CirclePosition> {
    let b = ((a as f64) * 3f64.sqrt() / 2.0).round() as i32;
    vec![
        // CirclePosition {
        //     x_center: 0,
        //     y_center: -2 * a,
        // },
        // CirclePosition {
        //     x_center: 0,
        //     y_center: -a,
        // },
        // CirclePosition {
        //     x_center: -b,
        //     y_center: -3 * a / 2,
        // },
        CirclePosition {
            x_center: -2 * b,
            y_center: -a,
        },
        CirclePosition {
            x_center: -b,
            y_center: -a / 2,
        },
        CirclePosition {
            x_center: -2 * b,
            y_center: 0,
        },
        CirclePosition {
            x_center: -2 * b,
            y_center: a,
        },
        CirclePosition {
            x_center: -b,
            y_center: a / 2,
        },
        // CirclePosition {
        //     x_center: -b,
        //     y_center: 3 * a / 2,
        // },
        // CirclePosition {
        //     x_center: 0,
        //     y_center: 2 * a,
        // },
        // CirclePosition {
        //     x_center: 0,
        //     y_center: a,
        // },
        // CirclePosition {
        //     x_center: b,
        //     y_center: 3 * a / 2,
        // },
        CirclePosition {
            x_center: 2 * b,
            y_center: a,
        },
        CirclePosition {
            x_center: b,
            y_center: a / 2,
        },
        CirclePosition {
            x_center: 2 * b,
            y_center: 0,
        },
        CirclePosition {
            x_center: 2 * b,
            y_center: -a,
        },
        CirclePosition {
            x_center: b,
            y_center: -a / 2,
        },
        // CirclePosition {
        //     x_center: b,
        //     y_center: -3 * a / 2,
        // },
        CirclePosition {
            x_center: 0,
            y_center: 0,
        },
    ]
}

pub fn svg_from_vec(into_id: &[u8], halfsize: i32) -> Document {
    let mut document = Document::new().set(
        "viewBox",
        (-halfsize, -halfsize, 2 * halfsize, 2 * halfsize),
    );
    let colors = get_colors_from_vec(into_id);
    let data = calculate_svg_data(halfsize, colors);
    for x in data.into_iter() {
        document = document.add(x);
    }
    document
}

/// Function to calculate svg file contents (using element::Circle from svg crate)
pub fn calculate_svg_data(big_radius: i32, colors: Vec<[u8; 4]>) -> Vec<element::Circle> {
    let mut out: Vec<element::Circle> = Vec::with_capacity(20);
    out.push(
        element::Circle::new()
            .set("cx", 0)
            .set("cy", 0)
            .set("r", big_radius)
            .set("fill", rgba_to_hex(FOREGROUND_COLOR))
            .set("stroke", "none"),
    );
    let small_radius = big_radius / 32 * 5;
    let center_to_center = big_radius / 8 * 3;
    let positions = position_circle_set(center_to_center);
    for (i, position) in positions.iter().enumerate() {
        out.push(
            element::Circle::new()
                .set("cx", position.x_center)
                .set("cy", position.y_center)
                .set("r", small_radius)
                .set("fill", rgba_to_hex(colors[i]))
                .set("stroke", "none"),
        );
    }
    out
}

/// Function to get colors from u8 vector
pub fn get_colors_from_vec(into_id: &[u8]) -> Vec<[u8; 4]> {
    let into_zero = [0u8; 32].to_vec();
    let zero = blake2b(64, &[], &into_zero).as_bytes().to_vec();

    let id_prep = blake2b(64, &[], into_id).as_bytes().to_vec();

    let mut id: Vec<u8> = Vec::new();
    for (i, x) in id_prep.iter().enumerate() {
        let new = x.wrapping_sub(zero[i]);
        id.push(new);
    }

    // Since `id[29]` is u8, `sat` could range from 30 to 109, i.e. it always fits into u8.
    // Transformation of id[29] into u16 is to avoid overflow in multiplication (wrapping could be used, but is more bulky).
    // TODO For color calculation `sat` is used as saturation in percents
    // (this is taken as is from js code).
    // However, this way `sat_component` could have values above 1.00.
    // Palette crate does not check at this moment that `sat_component` is not overflowing 1.00, and produces
    // some kind of resulting color.
    // Need to find out what should have happened if the sat values are above 100.
    let sat = (((id[29] as u16 * 70 / 256 + 26) % 80) + 30) as u8;
    let sat_component: f64 = (sat as f64) / 100.0;

    // calculating palette: set of 32 RGBA colors to be used is drawing
    // only id vector is used for this calculation
    let mut my_palette: Vec<[u8; 4]> = Vec::new();
    for (i, x) in id.iter().enumerate() {
        let b = x.wrapping_add((i as u8 % 28).wrapping_mul(58));
        let new = match b {
            0 => [4, 4, 4, 255],
            255 => FOREGROUND_COLOR, // transparent
            _ => {
                // HSL color hue in degrees
                // calculated as integer, same as in js code
                // transformation to u16 is done to avoid overflow
                let h = (b as u16 % 64 * 360) / 64;
                // recalculated into RgbHue, to be used as HSL hue component
                let h_component = RgbHue::from_degrees(h as f64);

                // HSL lightness in percents
                let l: u8 = match b / 64 {
                    0 => 53,
                    1 => 15,
                    2 => 35,
                    _ => 75,
                };
                // recalculated in HSL lightness component (component range is 0.00 to 1.00)
                let l_component: f64 = (l as f64) / 100.0;

                // defining HSL color
                let color_hsl = Hsl::new(h_component, sat_component, l_component);

                // transforming HSL color into RGB color, possibly lossy, TODO check if too lossy
                let color_srgb = Srgb::from_color(color_hsl);

                // getting red, green, blue components, transforming them in 0..255 range of u8
                let red = u8::from_component(color_srgb.red);
                let green = u8::from_component(color_srgb.green);
                let blue = u8::from_component(color_srgb.blue);

                // finalize color to add to palette, not transparent
                [red, green, blue, 255]
            }
        };
        my_palette.push(new);
    }

    // loading default coloring schemes
    let schemes = default_schemes();

    // `total` is the sum of frequencies for all scheme elements in coloring schemes,
    // in current setting is always 357
    let mut total = 0;
    for x in schemes.iter() {
        total += x.freq as u32;
    }

    // `d` is used to determine the coloring scheme to be used.
    // Transformation into u32 is used to avoid overflow.
    let d = (id[30] as u32 + (id[31] as u32) * 256) % total;

    // determining the coloring scheme to be used
    let my_scheme = choose_scheme(schemes, d).expect("should always work: d is calculated as remainder of division by total sum of frequencies, so it can not exceed the total sum of frequencies");

    // calculating rotation for the coloring scheme
    let rot = (id[28] % 6) * 3;

    // picking colors from palette using coloring scheme with rotation applied
    let mut my_colors: Vec<[u8; 4]> = Vec::with_capacity(19);
    for i in 0..19 {
        let num_color = {
            if i < 18 {
                (i + rot) % 18
            } else {
                18
            }
        } as usize;
        let num_palette = my_scheme.colors[num_color];
        let color = my_palette[num_palette];
        my_colors.push(color);
    }

    my_colors
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit {
    use crate::identicon::make;

    #[test]
    fn test_make() {
        let actual = make(&[1]);
        assert_eq!("<svg viewBox=\"-32 -32 64 64\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"0\" cy=\"0\" fill=\"#eeeeee\" r=\"32\" stroke=\"none\"/><circle cx=\"-20\" cy=\"-12\" fill=\"#d4aabf\" r=\"5\" stroke=\"none\"/><circle cx=\"-10\" cy=\"-6\" fill=\"#d4caaa\" r=\"5\" stroke=\"none\"/><circle cx=\"-20\" cy=\"0\" fill=\"#3d3c77\" r=\"5\" stroke=\"none\"/><circle cx=\"-20\" cy=\"12\" fill=\"#77623c\" r=\"5\" stroke=\"none\"/><circle cx=\"-10\" cy=\"6\" fill=\"#af7560\" r=\"5\" stroke=\"none\"/><circle cx=\"20\" cy=\"12\" fill=\"#3d3c77\" r=\"5\" stroke=\"none\"/><circle cx=\"10\" cy=\"6\" fill=\"#d4aabf\" r=\"5\" stroke=\"none\"/><circle cx=\"20\" cy=\"0\" fill=\"#d4caaa\" r=\"5\" stroke=\"none\"/><circle cx=\"20\" cy=\"-12\" fill=\"#3d3c77\" r=\"5\" stroke=\"none\"/><circle cx=\"10\" cy=\"-6\" fill=\"#77623c\" r=\"5\" stroke=\"none\"/><circle cx=\"0\" cy=\"0\" fill=\"#af7560\" r=\"5\" stroke=\"none\"/></svg>", actual);
    }
}

'''
'''--- src/contract/neatar/neatar.js ---
import {Contract} from 'near-api-js'

const AVATAR_CREATE_STORAGE_COST = '50000000000000000000000' // 0.05 NEAR
const AVATAR_CREATE_PREPAID_GAS = '300000000000000' // 300 TGas

export class Neatar {
  /**
   * @type {Contract}
   */
  contract

  constructor(account, contractId) {
    this.contract = new Contract(account, contractId, {
      viewMethods: [
        'avatar_of',
        'avatar_exist',
        'nft_tokens_for_owner',
        'nft_metadata',
      ],
      changeMethods: [
        'new',
        'avatar_create',
        'avatar_create_for',
        'avatar_burn_for',
        'avatar_burn',
        'ft_burn',
      ],
    })
  }

  /**
   * @param {string} account_id
   * @returns {Promise<string>}
   */
  avatar_of(account_id) {
    return this.contract.avatar_of({account_id})
  }

  /**
   * @returns {Promise<string>}
   */
  avatar_create() {
    return this.contract.avatar_create({}, AVATAR_CREATE_PREPAID_GAS, AVATAR_CREATE_STORAGE_COST)
  }

  /**
   * @param {string} account_id
   * @returns {Promise<string>}
   */
  avatar_create_for(account_id) {
    return this.contract.avatar_create_for({account_id})
  }

  /**
   * @returns {Promise<void>}
   */
  avatar_burn() {
    return this.contract.avatar_burn({}, AVATAR_CREATE_PREPAID_GAS)
  }

  /**
   * @returns {Promise<Object>}
   */
  nft_metadata() {
    return this.contract.nft_metadata()
  }

  /**
   * @param {string} account_id
   * @returns {Promise<bolean>}
   */
  avatar_exist(account_id) {
    return this.contract.avatar_exist({account_id})
  }

  /**
   * @param {string} account_id
   * @param {string} from_index
   * @param {number} limit
   * @returns {Promise<Object[]>}
   */
  nft_tokens_for_owner(account_id, from_index = "0", limit = 50) {
    return this.contract.nft_tokens_for_owner({
      account_id,
      from_index,
      limit,
    })
  }
}

'''
'''--- src/contract/neatar/neatar.rs ---
use cid::multihash::{Code, MultihashDigest};
use cid::Cid;
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::Base64VecU8;
use near_sdk::log;
use near_sdk::require;
use near_sdk::serde_json::json;
use near_sdk::Balance;
use near_sdk::Gas;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

mod identicon;

const PKG_NAME: &str = env!("CARGO_PKG_NAME");
lazy_static_include::lazy_static_include_str! {
    LOGO => "../../web/asset/logo.svg",
}

fn new_nft_metadata() -> NFTContractMetadata {
    let metadata = NFTContractMetadata {
        spec: NFT_METADATA_SPEC.to_string(),
        name: PKG_NAME.to_uppercase(),
        symbol: PKG_NAME.to_uppercase(),
        icon: Some(format!(
            "data:image/{}",
            pack_data_image(LOGO.to_string(), None)
        )),
        base_uri: Some("data:image".to_string()),
        reference: None,
        reference_hash: None,
    };
    metadata.assert_valid();
    metadata
}

fn pack_data_image(data: String, media_type: Option<String>) -> String {
    format!(
        "{};base64,{}",
        media_type.unwrap_or_else(|| "svg+xml".to_string()),
        base64::encode(data)
    )
}

fn default_token() -> Token {
    new_token(LOGO.to_string(), None)
}

fn new_token(svg: String, owner_id: Option<AccountId>) -> Token {
    let hash = Code::Sha2_256.digest(svg.as_bytes());
    let token_id = Cid::new_v1(RAW, hash).to_string();
    let owner_id = owner_id.unwrap_or_else(env::current_account_id);
    Token {
        token_id: token_id.clone(),
        owner_id,
        metadata: Some(new_token_metadata(svg, token_id)),
        approved_account_ids: None,
    }
}

fn new_token_metadata(svg: String, token_id: String) -> TokenMetadata {
    let title = Some(format!(
        "#{}",
        if token_id.len() > 6 {
            format!(
                "{}...{}",
                &token_id[0..3],
                &token_id[token_id.len() - 4..token_id.len() - 1]
            )
        } else {
            token_id
        },
    ));
    let media = pack_data_image(svg.clone(), None);
    let media_hash = Base64VecU8(env::sha256(svg.as_bytes()));
    TokenMetadata {
        title,
        description: None,
        media: Some(media),
        media_hash: Some(media_hash),
        copies: Some(1),
        issued_at: Some(env::block_timestamp().to_string()),
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    }
}

// Prepaid gas for making a single simple call.
const SINGLE_CALL_GAS: Gas = Gas(200000000000000);
const ONE_YOCTO: Balance = 1;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Neatar {
    token: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const RAW: u64 = 0x55;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Neatar {
    #[private]
    #[init]
    pub fn init() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self::new()
    }

    fn new() -> Self {
        let owner_id = env::current_account_id();
        Self {
            token: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&new_nft_metadata())),
        }
    }

    #[private]
    pub fn update_name(&mut self) {
        self.metadata = LazyOption::new(StorageKey::Metadata, Some(&new_nft_metadata()))
    }

    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let current: Neatar = env::state_read().expect("State doesn't exist");
        let mut next = Neatar::new();
        next.token = current.token;
        next.metadata = current.metadata;
        next
    }

    fn current_token(&self, account_id: AccountId) -> Token {
        let list = self.token.nft_tokens_for_owner(account_id, None, None);
        list.last().cloned().unwrap_or_else(default_token)
    }

    pub fn ft_burn(&mut self, token_id: TokenId) {
        let initial_storage_usage = env::storage_usage();
        let owner_id = self
            .token
            .owner_by_id
            .get(&token_id)
            .expect("Not found token");
        require!(owner_id == env::predecessor_account_id(), "Only owner");
        match self
            .token
            .tokens_per_owner
            .as_mut()
            .and_then(|per_owner| per_owner.remove(&owner_id))
        {
            None => {}
            Some(mut set) => set.clear(),
        };
        self.token
            .approvals_by_id
            .as_mut()
            .and_then(|by_id| by_id.remove(&token_id));
        self.token
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.remove(&token_id));
        self.token.owner_by_id.remove(&token_id);
        // make refund for storage free
        let storage_free = initial_storage_usage
            .checked_sub(env::storage_usage())
            .unwrap_or_default();
        log!("storage free: {}", storage_free);
        let refund = env::storage_byte_cost() * Balance::from(storage_free);
        if refund > 1 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }

    pub fn avatar_of(&self, account_id: AccountId) -> String {
        let token = self.current_token(account_id);
        let media = token.metadata.unwrap().media.unwrap();
        format!("data:image/{}", media)
    }

    #[payable]
    pub fn avatar_create(&mut self) -> String {
        let owner_id = env::signer_account_id();
        self.avatar_create_for(owner_id)
    }

    pub fn avatar_burn(&mut self) {
        self.ft_burn(self.current_token(env::predecessor_account_id()).token_id)
    }

    #[private]
    pub fn avatar_burn_for(&mut self, owner_id: AccountId) {
        // TODO
    }

    #[payable]
    #[private]
    pub fn avatar_create_for(&mut self, owner_id: AccountId) -> String {
        let initial_storage_usage = env::storage_usage();
        let hash: &[u8] =
            &env::sha256(format!("{}-{}", owner_id, env::block_timestamp()).as_bytes());
        let svg = identicon::make(hash);
        let contract_id = env::current_account_id();
        let token = new_token(svg, None);
        let token_id = token.token_id;
        let metadata = token.metadata.unwrap();
        let media = metadata.media.clone().unwrap_or_default();
        self.token
            .internal_mint(token_id.clone(), contract_id.clone(), Some(metadata));
        env::promise_create(
            contract_id,
            "nft_transfer",
            json!({
                "token_id": token_id,
                "receiver_id": owner_id,
            })
            .to_string()
            .as_bytes(),
            ONE_YOCTO,
            SINGLE_CALL_GAS,
        );
        let storage_usage = env::storage_usage()
            .checked_sub(initial_storage_usage)
            .unwrap_or_default();
        log!("storage usage: {}", storage_usage);
        media
    }
}

near_contract_standards::impl_non_fungible_token_core!(Neatar, token);
near_contract_standards::impl_non_fungible_token_approval!(Neatar, token);
near_contract_standards::impl_non_fungible_token_enumeration!(Neatar, token);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Neatar {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    const MINT_STORAGE_COST: u128 = 25900000000000000000000;
    // 0.0259

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Neatar::new();
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Neatar::default();
    }

    #[test]
    fn test_avatar_create() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .signer_account_id(accounts(0))
            .build());

        let avatar = contract.avatar_create();
        assert_eq!(1071, avatar.len());

        let token = contract
            .nft_tokens_for_owner(accounts(0), None, None)
            .first()
            .cloned()
            .unwrap();
        assert_eq!(token.owner_id, accounts(0));
        let metadata = token.metadata.unwrap();
        assert_eq!(1071, metadata.media.clone().unwrap().len());
        assert_eq!(10, metadata.title.unwrap().len());
        assert_eq!(token.approved_account_ids.unwrap().len(), 0);
    }

    #[test]
    fn test_avatar_burn() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .signer_account_id(accounts(0))
            .build());

        contract.avatar_create();
        assert_eq!(1082, contract.avatar_of(accounts(0)).len());
        contract.avatar_burn();
        assert_eq!(614, contract.avatar_of(accounts(0)).len());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        contract.avatar_create();
        let token_id = contract
            .nft_tokens_for_owner(accounts(0), None, None)
            .first()
            .cloned()
            .unwrap()
            .token_id;

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1));
            assert_eq!(token.metadata.unwrap().media.unwrap().len(), 1071);
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        contract.avatar_create();
        let token = contract
            .nft_tokens_for_owner(accounts(0), None, None)
            .first()
            .cloned()
            .unwrap();
        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token.token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token.token_id, accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        contract.avatar_create();
        let token = contract
            .nft_tokens_for_owner(accounts(0), None, None)
            .first()
            .cloned()
            .unwrap();
        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token.token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token.token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token.token_id, accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Neatar::new();

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        contract.avatar_create();
        let token = contract
            .nft_tokens_for_owner(accounts(0), None, None)
            .first()
            .cloned()
            .unwrap();
        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token.token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token.token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token.token_id, accounts(1), Some(1)));
    }
}

'''
'''--- src/web/asset/logo.svg ---
<svg width="120" height="120"
     viewBox="0 0 120 120"
     xmlns="http://www.w3.org/2000/svg">
  <g fill="#000" stroke="#000">
    <rect x="50" y="10" width="20" height="20"/>
    <rect x="10" y="30" width="100" height="20"/>
    <rect x="10" y="50" width="40" height="30"/>
    <rect x="70" y="50" width="40" height="30"/>
    <rect x="30" y="80" width="20" height="20"/>
    <rect x="70" y="80" width="20" height="20"/>
  </g>
</svg>
'''
'''--- src/web/config.js ---
export function config(env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: 'alpha.neatar.near',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: 'alpha.neatar.testnet',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: 'alpha.neatar.betanet',
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
        explorerUrl: 'https://explorer.betanet.near.org',
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        contractName: 'alpha.neatar.local',
        walletUrl: 'http://localhost:4000/wallet',
        helperUrl: 'http://localhost:3000',
      }
    default:
      throw Error(`Unconfigured environment '${env}'`)
  }
}

'''
'''--- src/web/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NEATAR</title>
  <meta name="description" content="NEATAR â€” The Web3 avatar like as Gravatar">
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.6.3/dist/css/foundation.min.css"
        integrity="sha256-ogmFxjqiTMnZhxCqVmcqTvjfe1Y/ec4WaRj/aQPvn+I=" crossorigin="anonymous">
  <link rel="stylesheet" href="stylesheet.css">
  <meta name="theme-color" content="#1976d2">
  <link rel="icon" type="image/png" sizes="196x196" href="asset/icon/favicon-196.png">
  <link rel="apple-touch-icon" href="asset/icon/apple-icon-180.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2048-2732.png"
        media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2732-2048.png"
        media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1668-2388.png"
        media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2388-1668.png"
        media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1536-2048.png"
        media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2048-1536.png"
        media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1668-2224.png"
        media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2224-1668.png"
        media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1620-2160.png"
        media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2160-1620.png"
        media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1284-2778.png"
        media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2778-1284.png"
        media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1170-2532.png"
        media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2532-1170.png"
        media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1125-2436.png"
        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2436-1125.png"
        media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1242-2688.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2688-1242.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-828-1792.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1792-828.png"
        media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1242-2208.png"
        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-2208-1242.png"
        media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-750-1334.png"
        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1334-750.png"
        media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-640-1136.png"
        media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
  <link rel="apple-touch-startup-image" href="asset/icon/apple-splash-1136-640.png"
        media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
</head>
<body>
<div data-behavior="signed-in-flow" class="panel" style="display: none">
  <div class="grid-container">
    <div class="grid-x grid-padding-x">
      <div class="large-12 cell align-center">
        <h1 class="panel__title">NEATAR</h1>
        <span class="panel__description" style="display: block">The Web3 avatar like as Gravatar</span>
        <img width="255" alt="NEATAR" src="./asset/logo.svg">
      </div>
    </div>
    <div class="grid-x grid-padding-x">
      <div class="large-12 cell align-center">
        <button data-behavior="login"  class="button">Connect</button>
      </div>
    </div>
  </div>
</div>
<div data-behavior="signed-out-flow" class="panel panel_signed" style="display: none">
  <div class="grid-container">
    <div class="grid-x grid-padding-x">
      <div class="large-1 small-2 cell">
        <img alt="NEATAR" width="40" src="./asset/logo.svg">
      </div>
      <div class="large-2 small-2 cell">
        <h1 class="panel__title">NEATAR</h1>
      </div>
      <div class="large-7 small-7 cell">
        <span class="panel__account" data-behavior="account-id"></span>
      </div>
      <div class="large-2 cell text-right">
        <button data-behavior="logout" class="button">Log Out</button>
      </div>
    </div>
  </div>
  <div class="grid-container">
    <div class="grid-x grid-padding-x">
      <div class="large-5 cell align-center">
      </div>
      <div class="large-7 cell align-center">
        <button data-behavior="action-create" class="button success" style="display: none">
          <span>create new</span>
        </button>
        <button data-behavior="action-burn" class="button alert" style="display: none">
          <span>burn</span>
        </button>
      </div>
    </div>
  </div>
  <div class="grid-container">
    <div class="grid-x grid-padding-x">
      <div class="large-12 cell">
        <img data-behavior="avatar" class="avatar thumbnail" alt="avatar" src="" >
      </div>
    </div>
  </div>
</div>
<script src="index.js"></script>
</body>
</html>

'''
'''--- src/web/index.js ---
import 'regenerator-runtime/runtime'
import {
  initContract,
  login,
  logout,
  isSignedIn,
  accountId,
  contract,
} from './wallet'

function behavior(name, fn) {
  document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn)
}
const onclick = (fn) => (elem) => {
  elem.onclick = fn
}
const show = () => (elem) => {
  elem.style.display = 'block'
}
const hide = () => (elem) => {
  elem.style.display  = 'none'
}
const innerText = (text) => (elem) => {
  elem.innerText = text
}
const disabled = (status) => (elem) => {
  elem.disabled = status
}
const addClass = (name) => (elem) => {
  elem.classList.add(name);
}

behavior('login', onclick(login))
behavior('logout', onclick(logout))
behavior('action-burn', onclick(() => {
  behavior('action-burn', disabled(true))
  contract().avatar_burn().then(() => {
    behavior('action-burn', disabled(true))
    updateAvatar()
  }).catch(reason => {
    console.error(reason)
  })
}))
behavior('action-create', onclick(() => {
  behavior('action-create', disabled(true))
  contract().avatar_create().then(() => {
    behavior('action-create', disabled(true))
    updateAvatar()
  }).catch(reason => {
    console.error(reason)
  })
}))
behavior('logout', elem => {
  elem.onclick = logout
})

function signedInFlow() {
  behavior('signed-in-flow', show())
}

function signedOutFlow() {
  behavior('signed-out-flow', show())
  behavior('account-id', innerText(accountId()))
  return updateAvatar()
}

async function updateAvatar() {
  const avatar = await contract().avatar_of(accountId())
  behavior('avatar',elem => {
    elem.src = avatar
  })
  if ((await contract().avatar_exist(accountId()))) {
    behavior('action-burn', show())
    behavior('action-create', hide())
  } else {
    behavior('action-burn', hide())
    behavior('action-create', show())
    behavior('avatar', addClass('avatar_default'))
  }
}

initContract()
  .then(() => isSignedIn() ? signedOutFlow() : signedInFlow())
  .catch(console.error)

'''
'''--- src/web/stylesheet.css ---
body {
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
}

.panel {
  text-align: center;
  display: block;
}

.panel_signed {
  padding-top: 20px;
}

.panel__title {
  font-size: 2rem;
  font-weight: bold;
}

.panel__account {
  font-size: 1.5rem;
  line-height: 2.8rem;
}

.panel__description {
  font-size: 1.5rem;
}

.avatar {
  width: 50%;
}

[data-behavior^=action] {
  text-transform: uppercase;
}

.avatar_default {
  filter: grayscale(1);
}

'''
'''--- src/web/wallet.js ---
import {connect, keyStores, WalletConnection} from 'near-api-js'
import {config} from './config'
import {Neatar} from '../contract/neatar/neatar'

const nearConfig = config('testnet')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR
  const near = await connect(Object.assign({
    deps: {
      keyStore: new keyStores.BrowserLocalStorageKeyStore(),
    },
  }, nearConfig))
  // Initializing Wallet based Account
  window.walletConnection = new WalletConnection(near, nearConfig.networkId)
  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()
  // Initializing our contract APIs by contract name and configuration
  window.contract = new Neatar(window.walletConnection.account(), nearConfig.contractName)
}

/**
 * @returns {Neatar}
 */
export function contract() {
  return window.contract
}

export function logout() {
  window.walletConnection.signOut()
  window.location.replace(window.location.origin + window.location.pathname) // reload page
}

export function login() {
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

export function isSignedIn() {
  return window.walletConnection.isSignedIn()
}

export function accountId() {
  return window.accountId
}

'''
'''--- toolchain.toml ---
[toolchain]
channel = "stable-2021-07-29"
components = [
    "rust-src",
    "clippy",
    "rustfmt",
]
targets = [
    "wasm32-unknown-unknown",
]
profile = "minimal"

'''