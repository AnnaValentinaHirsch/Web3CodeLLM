*GitHub Repository "Peersyst/ckb-wallet-sdk"*

'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
Peersyst.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

'''
'''--- CONTRIBUTING.md ---
# Contributing

When contributing to this repository, please first discuss the change you wish to make via issue,
email, or any other method with the owners of this repository before making a change. 

Please note we have a code of conduct, please follow it in all your interactions with the project.

## Pull Request Process

1. Ensure any install or build dependencies are removed before the end of the layer when doing a 
   build.
2. Update the README.md with details of changes to the interface, this includes new environment 
   variables, exposed ports, useful file locations and container parameters.
3. Increase the version numbers in any examples files and the README.md to the new version that this
   Pull Request would represent. The versioning scheme we use is [SemVer](http://semver.org/).
4. You may merge the Pull Request in once you have the sign-off of two other developers, or if you 
   do not have permission to do that, you may request the second reviewer to merge it for you.

## Code of Conduct

### Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of experience,
nationality, personal appearance, race, religion, or sexual identity and
orientation.

### Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

### Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

### Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at dev@peersyst.com . All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

### Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/

'''
'''--- README.md ---
# What is Ckb Wallet SDK?

Ckb Wallet SDK is a software development kit in TypeScript for Ckb specially focused in wallets. This means that the functionalities are thought to be used for a specific wallet. Nonetheless, there is no problem in creating multiple wallets of multiple networks using this sdk.

For each wallet you will be able to easily find all transactions, get your addresses, sign and create ckb transactions as well as interact with the DAO and get ckb, tokens (NRC20 and NRC721) and DAO balances.

{% hint style="info" %}
Ckb wallet sdk is an ongoing project. There will be new versions and functionalities as we keep evolving.
{% endhint %}

{% hint style="info" %}
Our sdk is free to use and also to collaborate! We will review and accept new functionalities. Do not hesitate in collaborating if you did not find your functionality in the docs.
{% endhint %}

'''
'''--- SUMMARY.md ---
# Table of contents

* [What is Ckb Wallet SDK?](README.md)

## Getting Started <a href="#docs/getting-started" id="docs/getting-started"></a>

* [Installation](docs/getting-started/installation.md)
* [Launch your nervos local node](docs/getting-started/launch-your-nervos-local-node.md)
* [Instantiate a connection service](docs/getting-started/instantiate-a-connection-service.md)
* [Instantiate your wallet service](docs/getting-started/instantiate-your-wallet-service.md)
* [Next steps](docs/getting-started/next-steps.md)

## Examples <a href="#docs/examples" id="docs/examples"></a>

* [Introduction](docs/examples/introduction.md)
* [How to run them](docs/examples/how-to-run-them.md)
* [Examples code](docs/examples/examples-code/README.md)
  * [Create wallet](docs/examples/examples-code/create-wallet.md)
  * [Import wallet error](docs/examples/examples-code/import-wallet-error.md)
  * [Import wallet](docs/examples/examples-code/import-wallet.md)
  * [Wallet balance](docs/examples/examples-code/wallet-balance.md)
  * [Get transactions](docs/examples/examples-code/get-transactions.md)
  * [Send transaction](docs/examples/examples-code/send-transaction.md)
  * [Get DAO Statistics](docs/examples/examples-code/get-dao-statistics.md)
  * [Get DAO unlockable amounts](docs/examples/examples-code/get-dao-unlockable-amounts.md)
  * [Deposit in DAO](docs/examples/examples-code/deposit-in-dao.md)
  * [Withdraw or unlock from DAO](docs/examples/examples-code/withdraw-or-unlock-from-dao.md)
  * [Send Tokens](docs/examples/examples-code/send-tokens.md)
  * [Issue Tokens](docs/examples/examples-code/issue-tokens.md)

## Usage <a href="#docs/usage" id="docs/usage"></a>

* [Introduction](docs/usage/introduction.md)
* [Creating a connection for each network](docs/usage/creating-a-connection-for-each-network.md)
* [Wallet loader](docs/usage/wallet-loader.md)
* [Use your wallet where necessary](docs/usage/use-your-wallet-where-necessary.md)

## Services Documentation <a href="#docs/services-documentation" id="docs/services-documentation"></a>

* [Preface](docs/services-documentation/preface.md)
* [WalletService](docs/services-documentation/walletservice/README.md)
  * [Static methods](docs/services-documentation/walletservice/static-methods.md)
  * [Common methods](docs/services-documentation/walletservice/common-methods.md)
  * [CKB methods](docs/services-documentation/walletservice/ckb-methods.md)
  * [DAO methods](docs/services-documentation/walletservice/dao-methods.md)
  * [Nft methods](docs/services-documentation/walletservice/nft-methods.md)
  * [Token methods](docs/services-documentation/walletservice/token-methods.md)
* [ConnectionService](docs/services-documentation/connectionservice.md)
* [Logger](docs/services-documentation/logger.md)

'''
'''--- docs/examples/examples-code/README.md ---
# Examples code

In this section you can view the code of all the examples that we talked about earlier. There is also some commentary where necessary.

'''
'''--- docs/examples/examples-code/create-wallet.md ---
# Create wallet

As we create a new wallet we do not synchronize.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const main = async () => {
    try {
        const mnemonic = WalletService.createNewMnemonic();
        Logger.info(mnemonic); // Your new generated mnemonic, save it

        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // You can have more than 1 public address per mnemonic
        const nextAddress = wallet.getNextAddress();
        Logger.info(nextAddress);

        // To get your private key you need to put you mnemonic as sdk does not keep it
        const { privateKey, address } = wallet.getAddressAndPrivateKey(mnemonic);
        Logger.info(privateKey);
        Logger.info(address);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
Get next address returns the next address where you can receive CKB. Once this address has a transaction the same call will return a new address. This method of creating a new address every time increases the security.
{% endhint %}

'''
'''--- docs/examples/examples-code/deposit-in-dao.md ---
# Deposit in DAO

This example shows how to deposit any amount of CKB in the DAO. You will be able to see the DAO balance once the transaction is committed and the wallet synchronized.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const amount = BigInt(500 * 10 ** 8);

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.depositInDAO(amount, mnemonic);
        Logger.info(txHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="warning" %}
Once you deposit in the DAO you can withdraw at any time, however once withdrawn it does not earn you any money.
{% endhint %}

{% hint style="info" %}
The DAO goes in cycles of approximately 30 days. This means that if you withdraw in day 1 or 31 you may have to wait another 29 days to unlock. It is best to withdraw in the end of the cycle but not too late because you may get caught in the next cycle!
{% endhint %}

'''
'''--- docs/examples/examples-code/get-dao-statistics.md ---
# Get DAO Statistics

Here we show how to get the wallet dao statistics. This statistics include the maximum withdraw amount and the earliest since.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const statistics = await wallet.getDAOStatistics();
        Logger.info(statistics);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
There are other methods to access information about the DAO. You can see them in the [documentation](../../services-documentation/walletservice/dao-methods.md).
{% endhint %}

'''
'''--- docs/examples/examples-code/get-dao-unlockable-amounts.md ---
# Get DAO unlockable amounts

Here we can see how to get DAO unlockable amounts. An unlockable amount is either a deposit in the dao or a withdraw not yet unlocked. Both types have and approximated optimal time to unlock and the current compensation amount.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        Logger.info(unlockableAmounts);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
Unlockable amounts are used to either withdraw and unlock from the DAO. To see the full documentation on the type go [here](../../services-documentation/walletservice/dao-methods.md).
{% endhint %}

'''
'''--- docs/examples/examples-code/get-transactions.md ---
# Get transactions

Here we can see how to get all the transactions from a wallet.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const transactions = wallet.getTransactions();
        Logger.info(transactions);
        Logger.info(transactions.length);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
The wallet we set as example has lots of transactions and the first synchronization may take some minutes.
{% endhint %}

'''
'''--- docs/examples/examples-code/import-wallet-error.md ---
# Import wallet error

This example show what happens when you enter an incorrect mnemonic.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        new WalletService(connectionService, mnemonic);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
It is a good practice to surround the creation of a WalletService with a try catch block. This way you can act accordingly if the mnemonic is incorrect.
{% endhint %}

{% hint style="info" %}
WalletService contains a static function called validateMnemonic which returns a boolean. This way you can be sure your mnemonic is correct before creating the service. In some situations this may be preferred.
{% endhint %}

'''
'''--- docs/examples/examples-code/import-wallet.md ---
# Import wallet

In this example we can see that we define a callback for the fourth parameter of the constructor of WalletService. This callback will be called when a synchronization finishes. You could also set up a fifth parameter which would be another callback called when a synchronization starts.

The third parameter (null in the example) corresponds of the WalletState. This is useful when you do not want to do full synchronization every time as it saves the state of the wallet at a given point so the next synchronization takes less time.

```typescript
import { ConnectionService, Environments, WalletService, Logger, WalletState } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);

        // The third parameter given in the constructor is a callback called when a synchronize finishes
        const wallet = new WalletService(connectionService, mnemonic, null, async (walletState: WalletState) => {
            Logger.info("Got wallet State:");
            Logger.info(walletState);
        });

        await wallet.synchronize();
        const accounts = wallet.getAccountIndexes();
        Logger.info(accounts);
        const addresses = wallet.getAllAddresses();
        Logger.info(addresses);
        const newAddress = wallet.getNextAddress();
        Logger.info(newAddress);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
The mnemonic provided here is the one we used to test and contains lots of transactions. This also means that the synchronization will last a lot. If you want you can create a new wallet and send you ckb through the [faucet](https://faucet.nervos.org/).
{% endhint %}

'''
'''--- docs/examples/examples-code/issue-tokens.md ---
# Issue Tokens

Here we can see how to issue a new token. Each token depends on who issued the token. They all have the same codeHash and the args value depends on the issuer.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.issueTokens(1000, mnemonic);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="warning" %}
This method is not properly tested and should be used only on testnet.
{% endhint %}

'''
'''--- docs/examples/examples-code/send-tokens.md ---
# Send Tokens

Here we show how to send a tokens you own. There is no need to sync before calling `transferTokens` as it synchronizes internally before making any transaction.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const quantity = 10;
const token = "0x099472fc82e74d050d524ba32f8efc05d4a53800f4ab0bf88be9c3383586339a";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.transferTokens(quantity, mnemonic, receivingAddress, token);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="warning" %}
This method is not properly tested and should be used only on testnet.
{% endhint %}

{% hint style="info" %}
The hash in the variable token is the args value of the type of the token. Tokens are stored in cells with a type that has the codeHash of SUDT and the args value depends on who has issued the token.
{% endhint %}

'''
'''--- docs/examples/examples-code/send-transaction.md ---
# Send transaction

Here we can see how to send a simple transaction of ckb.

```typescript
import { ConnectionService, Environments, WalletService, Logger, FeeRate } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const amount = BigInt(513 * 10 ** 8); // 513 CKB

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // No need to sync as sendTransactions syncs before building the transaction
        const txHash = await wallet.sendTransaction(amount, mnemonic, receivingAddress, FeeRate.NORMAL);
        Logger.info(txHash);

        // You can view newly generated transaction through wallet.getTransactions when the tx is committed
        // If you want to know transaction status
        const transaction = await wallet.getTransactionFromHash(txHash);
        Logger.info(JSON.stringify(transaction, null, 2));
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
To view not committed transactions we have to use the `getTransactionFromHash` method. Once it is finally committed we can sync and view it in `getTransactions`.
{% endhint %}

'''
'''--- docs/examples/examples-code/wallet-balance.md ---
# Wallet balance

Here we can see how to check the balance of all of the accounts or only of a single account of your wallet. Even though the function `getBalanceFromAccount` does not need a synchronization the function `getBalance` does.

```typescript
import { ConnectionService, Environments, WalletService, Logger, AddressType } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const balanceAcc0Rec = await wallet.getBalanceFromAccount(0, AddressType.Receiving);
        Logger.info(balanceAcc0Rec);
        const balanceAcc0Chg = await wallet.getBalanceFromAccount(0, AddressType.Change);
        Logger.info(balanceAcc0Chg);
        const balanceAcc1 = await wallet.getBalanceFromAccount(1, AddressType.Receiving);
        Logger.info(balanceAcc1);
        const totalBalance = await wallet.getBalance();
        Logger.info(totalBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();
```

{% hint style="info" %}
If you want the balance of for example only ckb or only tokens or only nfts, we have dedicated functions as you can see in our [documentation](../../services-documentation/walletservice/).
{% endhint %}

'''
'''--- docs/examples/examples-code/withdraw-or-unlock-from-dao.md ---
# Withdraw or unlock from DAO

Here we can see how to withdraw or unlock an unlockable amount. If the unlockable amount is a deposit it will be withdrawn. If it is a withdraw and it is available for unlock (the unlockable amount type has a boolean, `unlockable`, which indicates it) it will be unlocked and available with the compensation added.

```typescript
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // We will try to unlock first unlockable amount
        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        if (unlockableAmounts.length === 0) {
            throw new Error("No unlockable or withdrawable amount. Deposit before trying to withdraw");
        }

        Logger.info("Withdrawing or unlocking the following unlockable amount:");
        Logger.info(unlockableAmounts[0]);
        const unlockHash = await wallet.withdrawOrUnlock(unlockableAmounts[0], mnemonic);
        Logger.info(unlockHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
        Logger.error(`${error.stack}`);
    }
};

main();
```

{% hint style="info" %}
Remember to withdraw a deposit at the end of the cycle but be careful not to do it too late! We have the fields `remainingEpochs` and `remainingCycleMinutes` to control the cycle status.
{% endhint %}

'''
'''--- docs/examples/how-to-run-them.md ---
# How to run them

The first thing that should be done is to clone or fork the package. For example:

```
git clone git@github.com:Peersyst/ckb-wallet-sdk.git
```

The next step is to modify the node urls or mnemonic or other parameters of the example you want to run. All examples have some definitions of variables before the function main. These should be the ones to modify. For example:

```typescript
import { ConnectionService, Environments, WalletService, Logger, WalletState } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

// Main function
...
```

Once the example is set-up as you wish you can run it with the following code:

```
npm run example --name=<example-name>
```

If the example you want to run is named create-wallet.ts you should execute:

```
npm run example --name=create-wallet
```

'''
'''--- docs/examples/introduction.md ---
# Introduction

We have included 12 different examples showing basic functionalities on how to use the sdk. If your goal is do any of these basic functionalities this section should be enough for you.

The examples we included are:

* **create-wallet:** contains the necessary functions to create a new wallet.
* **import-wallet:** contains the necessary functions to import a wallet, synchronize it and set a callback after synchronization.
* **import-wallet-error:** contains an example of what happens if you create a wallet with an incorrect mnemonic.
* **wallet-balance:** contains the functions on how to check the balance of all the accounts of the wallet or just of a single one.
* **get-transactions:** contains the code to get all the transactions from a wallet.
* **send-transaction:** contains an example on how to send CKB to another address. It also shows how to get the status of the transaction when it is still not committed.
* **get-dao-statistics:** shows how to check your DAO statistics (maximum withdraw and earliest since).
* **get-dao-unlockable-amounts:** implements the code to obtain the DAO unlockable amounts. These are the different amounts that can be either withdrawn or unlock. Returns an approximation on when can be unlocked and the current compensation.
* **deposit-in-dao:** show how to deposit an amount in the DAO.
* **unlock-from-dao:** it actually should be called withdraw or unlock from DAO. Provides the code necessary to unlock or withdraw an amount from the DAO.
* **transfer-tokens:** this example contains the necessary information to send tokens to another address. It is still a work in progress and should not be used in mainnet.
* **issue-tokens:** contains the necessary code to issue a new token. As with transfer-token it should be done only on testnet.

All of these examples can be run locally as we explain in the following chapter.

'''
'''--- docs/getting-started/installation.md ---
# Installation

Install the package using **npm**:

```
npm install --save @peersyst/ckb-wallet-sdk
```

Install the package using **yarn**:

```
yarn add @peersyst/ckb-wallet-sdk
```

'''
'''--- docs/getting-started/instantiate-a-connection-service.md ---
# Instantiate a connection service

Once your nervos node is up and running we can begin our development by instatiating the [ConnectionService](../services-documentation/connectionservice.md):

```typescript
import { ConnectionService, Environments, Logger } from "@peersyst/ckb-wallet-sdk";

const rpcUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const connectionService = new ConnectionService(rpcUrl, indexerUrl, Environments.Testnet);
connectionService.getBlockchainInfo().then((blockchainInfo) => {
    Logger.info(blockchainInfo);
});
```

Running this code will print the blockchain info of the node you are connected to as long as the node is running correctly.

If your node is from Mainnet use `Environments.Mainnet` to indicate the network of the node.

The connectionService instance will be used to create your wallet instance. It can be reused for other wallets. It has some rpc related functions. Usually you won't need to use them but you have more specific documentation [here](../services-documentation/connectionservice.md).

'''
'''--- docs/getting-started/instantiate-your-wallet-service.md ---
# Instantiate your wallet service

Once we have instantiated the connection service the next step is to instantiate a WalletService for each wallet in each network we want to work with.

To create the service you need a mnemonic. This mnemonic can be generated or imported.&#x20;

## Create new wallet with a generated mnemonic

If, for example, you would want to create a mnemonic on mainnet you could do:

```typescript
import { ConnectionService, Environments, Logger, WalletService } from "@peersyst/ckb-wallet-sdk";

const rpcUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const mainnetConnectionService = new ConnectionService(rpcUrl, indexerUrl, Environments.Mainnet);
const myMnemonic = WalletService.createNewMnemonic();
Logger.info(myMnemonic);
const myWallet = new WalletService(mainnetConnectionService, myMnemonic);
Logger.info(myWallet.getNextAddress());
```

{% hint style="info" %}
WalletService does not save the mnemonic nor the private key. If you generate a new mnemonic make sure to save it!
{% endhint %}

At this point you can already use myWallet to get your address, send transactions or view your balance (which will be 0 as it is a newly created wallet!).

## Import a wallet from an existing mnemonic

If you already have your mnemonic you will not need to generate a new one. You can import the wallet as follows:

```typescript
import { ConnectionService, Environments, Logger, WalletService } from "@peersyst/ckb-wallet-sdk";

const rpcUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const mainnetConnectionService = new ConnectionService(rpcUrl, indexerUrl, Environments.Mainnet);
const myWallet = new WalletService(mainnetConnectionService, myMnemonic);
myWallet.synchronize().then(() => {
    Logger.info(myWallet.getBalance());
}
```

{% hint style="info" %}
Synchronizing is very important to view what your wallet has. There are some related functionalities with synchronizing such as saving the wallet state and having callbacks each time a wallet synchronizes.
{% endhint %}

## Importing and creating multiple wallets

To create multiple testnet or mainnet wallets you just need one ConnectionService for each network. For example:

```typescript
import { ConnectionService, Environments, Logger, WalletService } from "@peersyst/ckb-wallet-sdk";

// Create mainnet connection service
const mainRpcUrl = "http://localhost:8117/rpc";
const mainIndexerUrl = "http://localhost:8117/indexer";
const mainnetConnectionService = new ConnectionService(mainRpcUrl, mainIndexerUrl, Environments.Mainnet);

// Create testnet connection service
const testRpcUrl = "http://localhost:8118/rpc";
const testIndexerUrl = "http://localhost:8118/indexer";
const testnetConnectionService = new ConnectionService(testRpcUrl, testIndexerUrl, Environments.Testnet);

// Create wallets
const newMnemonic = WalletService.createNewMnemonic();
const importMnemonic = "private zero ..."
const newWalletMain = new WalletService(mainnetConnectionService, newMnemonic);
const newWalletTest = new WalletService(testnetConnectionService, newMnemonic);
const oldWalletMain = new WalletService(mainnetConnectionService, importMnemonic);
const oldWalletTest = new WalletService(testnetConnectionService, importMnemonic);
```

'''
'''--- docs/getting-started/launch-your-nervos-local-node.md ---
# Launch your nervos local node

{% hint style="info" %}
To use the sdk you will need a running node in the network you want to use it. If you already have one running you can safely skip this step.
{% endhint %}

## Launch your node using Docker

We recommend using docker to run your node as it is an easy and fast way to configure it.

To create the rpc and the indexer at the same time there is an image in docker that does both at the same time. The code to launch a mainnet and testnet node in local is the following:

* Launch a mainnet node rpc and indexer:

```
docker run -d -it  -p 8117:9115  --name=ckb-mainnet-indexer  -e "CKB_NETWORK=mainnet" -v "$PWD/data":/data nervos/perkins-tent:v0.43.0
```

* Launch a testnet node rpc and indexer:

```
docker run -d -it  -p 8117:9115  --name=ckb-testnet-indexer  -e "CKB_NETWORK=testnet" -v "$PWD/data":/data nervos/perkins-tent:v0.43.0
```

To check whether your rpc is correctly running you can do:

```
echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "get_blockchain_info",
    "params": []
}' \
| tr -d '\n' \
| curl -H 'content-type: application/json' -d @- \
http://localhost:8117/rpc
```

To check if the indexer is also up query it with:

```
echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "get_cells",
    "params": [
        {
            "script": {
                "code_hash": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
                "hash_type": "type",
                "args": "0x8211f1b938a107cd53b6302cc752a6fc3965638d"
            },
            "script_type": "lock"
        },
        "asc",
        "0x64"
    ]
}' \
| tr -d '\n' \
| curl -H 'content-type: application/json' -d @- \
http://localhost:8117/indexer
```

This documentation can be seen in the following url:

{% embed url="https://hub.docker.com/r/nervos/perkins-tent" %}
Nervos perkins tent which includes rpc and indexer
{% endembed %}

## Launching your node without Docker

If you want to launch your node without Docker we recommend following nervos official docs on how to set up your node:

{% embed url="https://docs.nervos.org/docs/basics/guides/mainnet" %}
Official guide to set up your node
{% endembed %}

'''
'''--- docs/getting-started/next-steps.md ---
# Next steps

Congratulations! You already have your wallets instantiated and running!

## Where to keep going?

* If you want some examples on how to do basic functionalities go to the [examples section](broken-reference).
* If you want to see the usage of the wallet service with code examples of the basic functionalities go to the [usage section](broken-reference).
* If you are more of a documentation person you might like our [documentation section](broken-reference).

'''
'''--- docs/services-documentation/connectionservice.md ---
# ConnectionService

The connection service is the one necessary to communicate with the node and to make any kind of call to it. Most of the methods are used by other services but there are few that may be useful for you app.

### Relevant Types

```typescript
export enum Environments {
    Mainnet = "mainnet",
    Testnet = "testnet",
}

export type HexString = string;
export type Hexadecimal = string;
export type Hash = HexString;
export type HexNumber = Hexadecimal;
export type PackedSince = string;
export type PackedDao = string;
export type Address = string;

export interface ChainInfo {
  chain: string;
  median_time: HexNumber;
  epoch: HexNumber;
  difficulty: HexNumber;
  is_initial_block_download: boolean;
  alerts: AlertMessage[];
}

export interface AlertMessage {
  id: HexNumber;
  priority: HexNumber;
  notice_until: HexNumber;
  message: string;
}

export interface Header {
  timestamp: HexNumber;
  number: HexNumber;
  epoch: HexNumber;
  compact_target: HexNumber;
  dao: Hash;
  hash: Hash;
  nonce: HexNumber;
  parent_hash: Hash;
  proposals_hash: Hash;
  transactions_root: Hash;
  extra_hash: Hash;
  version: HexNumber;
}

export interface CellWithStatus {
  cell: {
    data: {
      content: HexString;
      hash: Hash;
    };
    output: Output;
  } | null;
  status: "live" | "unknown";
}

export interface TransactionWithStatus {
  transaction: Transaction;
  tx_status: TxStatus;
}

export interface TxStatus {
  block_hash?: Hash;
  status: string;
}

export interface Transaction {
  cell_deps: CellDep[];
  hash?: Hash;
  header_deps: Hash[];
  inputs: Input[];
  outputs: Output[];
  outputs_data: HexString[];
  version: HexNumber;
  witnesses: HexString[];
}

export interface Input {
  previous_output: OutPoint;
  since: PackedSince;
}

export interface OutPoint {
  tx_hash: Hash;
  index: HexNumber;
}

export interface Output {
  capacity: HexString;
  lock: Script;
  type?: Script;
}

export interface Script {
  code_hash: Hash;
  hash_type: HashType;
  args: HexString;
}

export type HashType = "type" | "data" | "data1";
```

### Static methods

```typescript
// Providing an environment and address returns a boolean indicating:
// true address is Blake160, Blake160Multisig, ACP, Onepass
// false address is of another kind or invalid
static isAddress(network: Environments, address: string): boolean;
```

{% hint style="info" %}
This is probably the most useful method in this service for anyone using the sdk.
{% endhint %}

### Constructor and class methods

{% hint style="info" %}
We have omitted some of the methods for simplicity and because they should not be used outside of its context.
{% endhint %}

```typescript
// ckbUrl is the url of the node rpc
// indexerUrl is the url of the node indexer
// env is the environment of the node
constructor(ckbUrl: string, indexerUrl: string, env: Environments);

// Returns info of the blockchain connected by the rpc
async getBlockchainInfo(): Promise<ChainInfo>;

// Gets latest block header in the blockchain
async getCurrentBlockHeader(): Promise<Header>;

// Gets a block header from its hash
async getBlockHeaderFromHash(blockHash: string): Promise<Header>;

// Get a block header from its hex number
async getBlockHeaderFromNumber(blockNumber: string): Promise<Header>;

// Gets a cell by its out point
async getCell(outPoint: OutPoint): Promise<CellWithStatus>;

// Gets a transaction with status from a hash
// Useful for when the transaction is still not committed
// For transactions that fave not finished you should set useMap = false to not receive the same!
async getTransactionFromHash(transactionHash: string, useMap = true): Promise<TransactionWithStatus>;

// Get current environment
getEnvironment(): Environments;

// Gets rpc. Useful if you want to use methods not implemented here
// Check @ckb-lumos rpc class implementation for all the methods
getRPC(): RPC;

// Gets indexer. Useful if you want to use methods not implemented here
// Check @ckb-lumos indexer class implementation for all the methods
getIndexer(): IndexerType;

// Get current ckb url
getCKBUrl(): string;

// Get current indexer url
getIndexerUrl(): string;

// Generates an address from a lock script
getAddressFromLock(lock: Script): string;

// Gets the locks script from an address
getLockFromAddress(address: string): Script;

// Providing an address returns a boolean indicating:
// true address is Blake160, Blake160Multisig, ACP, Onepass
// false address is of another kind or invalid
isAddress(address: string): boolean;
```

{% hint style="warning" %}
The method `getTransactionFromHash` can be used but returns a different type of transaction. Better use the [WalletService](walletservice/common-methods.md#methods) option as it is the same type as `getTransactions`.&#x20;
{% endhint %}

'''
'''--- docs/services-documentation/logger.md ---
# Logger

We created a simple Logger to help us with logging in the sdk. If you want you can use it and it works either as a static class or instantiate it. If you create an instance you can set the logging level and the name will be shown in the log.

### Relevant types

```typescript
export enum LoggingLevel {
    DEBUG = "debug",
    INFO = "info",
    WARN = "warn",
    ERROR = "error",
}
```

### Static methods

```typescript
// Sends a message to standard output with tag debug
static debug(message: any, name = ""): void;

// Sends a message to standard output with tag info
static info(message: any, name = ""): void;

// Sends a message to standard output with tag log
static log(message: any, name = ""): void;

// Sends a message to standard error output with tag warn
static warn(message: any, name = ""): void;

// Sends a message to standard error output with tag error
static error(message: any, name = ""): void;
```

### Constructor and class methods

```typescript
// In the constructor we can pass a name that will always be added in the log
// and a logging level to choose which level of logs you want to be logged.
// If you choose logging level WARN only logger.warn and logger.error will be logged
constructor(name = "", loggingLevel: LoggingLevel = LoggingLevel.INFO);

// Sends a message to standard output with tag debug if logging level DEBUG or greater
debug(message: any): void;

// Sends a message to standard output with tag info if logging level INFO or greater
info(message: any): void;

// Sends a message to standard output with tag log if logging level INFO or greater
log(message: any): void

// Sends a message to standard error output with tag warn if logging level WARN or greater
warn(message: any): void;

// Sends a message to standard error output with tag error if logging level ERROR
error(message: any): void;
```

'''
'''--- docs/services-documentation/preface.md ---
# Preface

This section contains all the necessary types and functions definitions available in the sdk.

Only the services you should use are documented as the other services are used by these primary services.

{% content-ref url="walletservice/" %}
[WalletService](walletservice/)
{% endcontent-ref %}

{% content-ref url="connectionservice.md" %}
[ConnectionService](connectionservice.md)
{% endcontent-ref %}

{% content-ref url="logger.md" %}
[Logger](logger.md)
{% endcontent-ref %}

'''
'''--- docs/services-documentation/walletservice/README.md ---
# WalletService

The WalletService is the heart of our sdk. Almost everything should be done through instances of this class.

To not have too much information together we have split this service in different parts. Here we will only view the constructor and the synchronization.&#x20;

### Relevant types

```typescript
export interface addressMapI {
    [key: string]: string;
}

export interface cellMapI {
    [key: string]: Cell[];
}

export interface transactionMapI {
    [key: string]: Transaction[];
}

export interface WalletState {
    addressMap: addressMapI;
    firstRIndexWithoutTxs: number;
    firstCIndexWithoutTxs: number;
    lastHashBlock: string;
    accountCellsMap: cellMapI;
    accountTransactionMap: transactionMapI;
}
```

### Constructor and synchronization

```typescript
// The connectionService and a mnemonic are mandatory
// walletState is useful if you will close the instance and want to sync from a given state
// onSync method is called when sync finished. Useful to persist current state
// onSyncStart is called when a synchronization start
// It throws an error when mnemonic is invalid
constructor(
    connectionService: ConnectionService,
    mnemo: string,
    walletState?: WalletState,
    onSync?: (walletState: WalletState) => Promise<void>,
    onSyncStart?: () => void,
);

// Gets current wallet state
getWalletState(): WalletState;

// Synchronizes and returns new wallet state
// Calls onSyncStart at start and and onSync when finishes
async synchronize(): Promise<WalletState>;
```

'''
'''--- docs/services-documentation/walletservice/ckb-methods.md ---
# CKB methods

In this chapter we will see the ckb related methods. This includes the creating ckb transactions and getting ckb balance.

### Relevant types

```typescript
export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}

export interface CKBBalance {
    totalBalance: number;
    occupiedBalance: number;
    freeBalance: number;
}
```

### Methods

```typescript
// Sends a transaction from a single account
// Returns the transaction hash
async sendTransactionSingleAccount(
    amount: bigint,
    mnemo: string,
    to: string,
    accountId: number,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Sends a transaction from all the accounts in the wallet
// Returns the transaction hash
async sendTransaction(
    amount: bigint,
    mnemo: string,
    to: string,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Gets the ckb balance of a single account
async getCKBBalanceFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<CKBBalance>;

// Get the ckb balance of the wallet
// Should be synchronized first
getCKBBalance(): CKBBalance;
```

'''
'''--- docs/services-documentation/walletservice/common-methods.md ---
# Common methods

Here we will show all functions that are common in wallets. This includes addresses, transactions and balances.

### Relevant types

```typescript
export declare enum AddressType {
    Receiving = 0,
    Change = 1
}

export enum AddressScriptType {
    SECP256K1_BLAKE160 = "SECP256K1_BLAKE160",
    SUDT = "SUDT",
    DAO = "DAO",
}

export interface Balance {
    ckb: CKBBalance;
    tokens: TokenAmount[];
    nfts: Nft[];
    dao: DAOBalance;
}

export interface CKBBalance {
    totalBalance: number;
    occupiedBalance: number;
    freeBalance: number;
}

export interface TokenType {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface TokenAmount {
    type: TokenType;
    amount: number;
}

export interface Nft {
    tokenId: string;
    tokenUri: string;
    nftName: string;
    nftSymbol?: string;
    data?: any;
    nftExtraData?: string;
    issued?: number;
    total?: number;
}

export interface DAOBalance {
    daoDeposit: number;
    daoCompensation: number;
}

export interface ScriptType {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface DataRow {
    quantity: number;
    address: string;
    type?: ScriptType;
    data?: number;
}

export interface Transaction {
    status: TransactionStatus;
    transactionHash: string;
    inputs: DataRow[];
    outputs: DataRow[];
    type: TransactionType;
    scriptType?: ScriptType;
    amount: number;
    blockHash?: string;
    blockNumber?: number;
    timestamp?: Date;
}

export enum TransactionStatus {
    PENDING = "pending",
    PROPOSED = "proposed",
    COMMITTED = "committed",
    REJECTED = "rejected",
}

export enum TransactionType {
    SEND_CKB = "send_ckb",
    RECEIVE_CKB = "receive_ckb",
    SEND_TOKEN = "send_token",
    RECEIVE_TOKEN = "receive_token",
    SEND_NFT = "send_nft",
    RECEIVE_NFT = "receive_nft",
    DEPOSIT_DAO = "deposit_dao",
    WITHDRAW_DAO = "withdraw_dao",
    UNLOCK_DAO = "unlock_dao",
    SMART_CONTRACT_SEND = "smart_contract_send",
    SMART_CONTRACT_RECEIVE = "smart_contract_receive",
}

export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}
```

### Methods

```typescript
// Returns next receive address without any transactions
getNextAddress(): string;

// Gets lock from a specific accountId, addressType and script type
getLock(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): Script;
    
// Gets address from a specific accountId, addressType and script type
getAddress(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): string;

// Gets all addresses with at least one transactions
getAllAddresses(): string[];

// Gets balance from a single account
async getBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Balance>;

// Gets wallet total balance
async getBalance(): Promise<Balance>;

// Gets all transactions from a single account
async getTransactionsFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Transaction[]>;

// Gets all transactions of the wallet
getTransactions(): Transaction[];

// Get a transaction from hash
// Useful from uncommitted transactions
async getTransactionFromHash(txHash: string): Promise<Transaction>;
```

'''
'''--- docs/services-documentation/walletservice/dao-methods.md ---
# DAO methods

In this chapter we have all the methods related to DAO in the WalletService.

### Relevant types

```typescript
export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}

export interface DAOStatistics {
    maximumWithdraw: bigint;
    daoEarliestSince: bigint;
}

export interface DAOBalance {
    daoDeposit: number;
    daoCompensation: number;
}

export interface DAOUnlockableAmount {
    type: "deposit" | "withdraw";
    amount: bigint;
    compensation: bigint;
    unlockable: boolean;
    remainingCycleMinutes: number;
    remainingEpochs: number;
    txHash: string;
}

export enum DAOCellType {
    DEPOSIT = "deposit",
    WITHDRAW = "withdraw",
    ALL = "all",
}
```

### Methods

```typescript
// Deposits in the DAO from a single account
// Returns the hash of the transaction
async depositInDAOSingleAccount(
    amount: bigint,
    mnemo: string,
    accountId = 0,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Deposits in DAO from all the accounts with enough balance
// Returns the hash of the transaction
async depositInDAO(
    amount: bigint,
    mnemo: string,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Gets DAO unlockable amounts from a single account
async getDAOUnlockableAmountsFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<DAOUnlockableAmount[]>;

// Gets DAO unlockable amounts from the whole wallet
// Should be synchronized first
async getDAOUnlockableAmounts(): Promise<DAOUnlockableAmount[]>;

// Withdraws or unlocks an unlockable amount
// Returns the hash of the transaction
async withdrawOrUnlock(
    unlockableAmount: DAOUnlockableAmount,
    mnemonic: string,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Gets DAO statistic from a single account
async getDAOStatisticsFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<DAOStatistics>;

// Gets DAO statistic from the whole wallet
// Should be synchronized first
async getDAOStatistics(): Promise<DAOStatistics>;

// Get DAO balance from a single account
async getDAOBalanceFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<DAOBalance>;

// Get DAO balance from the whole wallet
// Should be synchronized first
async getDAOBalance(): Promise<DAOBalance>;
```

'''
'''--- docs/services-documentation/walletservice/nft-methods.md ---
# Nft methods

Here we can see the Nft related methods in the wallet service.

### Relevant types

```typescript
export interface Nft {
    tokenId: string;
    tokenUri: string;
    nftName: string;
    nftSymbol?: string;
    data?: any;
    nftExtraData?: string;
    issued?: number;
    total?: number;
}
```

### Methods

```typescript
// Gets all nfts from a single account
async getNftsBalanceFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<Nft[]>;

// Gets the nfts from the whole wallet
// Should be synchronized first
async getNftsBalance(): Promise<Nft[]>;
```

'''
'''--- docs/services-documentation/walletservice/static-methods.md ---
# Static methods

The statics methods in the wallet service are to create a mnemonic and to validate the correctness of a mnemonic:

```typescript
// Creates a new mnemonic
static createNewMnemonic(): string;

// Validates a mnemonic
static validateMnemonic(mnemo: string): boolean;
```

'''
'''--- docs/services-documentation/walletservice/token-methods.md ---
# Token methods

Here we will view the token related methods. Some of the methods right now are deprecated and should not be used outside testnet.

### Relevant types

```typescript
export interface TokenType {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface TokenAmount {
    type: TokenType;
    amount: number;
}

export declare enum AddressType {
    Receiving = 0,
    Change = 1
}

export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}
```

### Token methods

```typescript
// Gets the token balance from a single account
async getTokensBalanceFromAccount(
    accountId = 0,
    addressType: AddressType = AddressType.Receiving,
): Promise<TokenAmount[]>;

// Get the token balance of the whole wallet
// Should be synchronized first
getTokensBalance(): TokenAmount[];
```

### Deprecated methods

{% hint style="warning" %}
These methods should be only used in testnet
{% endhint %}

```typescript
// Deprecated in accounts
// Issue a new token from a specific account
// Returns transaction hash
async issueTokens(
    amount: number,
    mnemo: string,
    accountId = 0,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;

// Deprecated in accounts
// Transfer a token with where its type has args token (4th param)
// Amount is the number of token to transfer. Minumum cell size required.
// Returns transaction hash
async transferTokens(
    amount: number,
    mnemo: string,
    to: string,
    token: string,
    accountId = 0,
    feeRate: FeeRate = FeeRate.NORMAL,
): Promise<string>;
```

'''
'''--- docs/usage/creating-a-connection-for-each-network.md ---
# Creating a connection for each network

First off we will start creating a file that will export a connection service for mainnet and another one for testnet. We will use environment variables for the urls.

{% code title="network-connections.ts" %}
```typescript
import { ConnectionService, Environments } from "@peersyst/ckb-wallet-sdk";

const mainnetConnection = new ConnectionService(
    process.env.RPC_URL_MAIN,
    process.env.INDEXER_URL_MAIN,
    Environments.Mainnet,
);

const testnetConnection = new ConnectionService(
    process.env.RPC_URL_TEST,
    process.env.INDEXER_URL_TEST,
    Environments.Testnet,
);

export { mainnetConnection, testnetConnection };
```
{% endcode %}

'''
'''--- docs/usage/introduction.md ---
# Introduction

## What will we see?

In this section we will see how to implement a service for an application that uses our sdk to perform basic wallet functionalities. It will be able to see our balance, addresses, tokens and nft. We will also be able to send transactions and interact with the DAO.

We will also be capable of saving the wallet state, recover it and perform actions when a synchronization starts or ends.

'''
'''--- docs/usage/use-your-wallet-where-necessary.md ---
# Use your wallet where necessary

Here we will implement a class that loads a wallet and is able to do different operations on this wallet.

This class is not entirely necessary. There are other ways to achieve this but we made a class to have everything in one place. Also it allows you to modify some responses as you wish.

When the app starts you should create a `WalletWrapper` for each wallet the user has and save it in memory. A global map may be a good idea to be able to access the wallet from every component.

{% code title="WalletWrapper.ts" %}
```typescript
import { Logger, LoggingLevel, Transaction, FeeRate } from "@peersyst/ckb-wallet-sdk";
import { loadWallet } from "./wallet-loader";
import { getTokenFromTokenAmount, CustomToken } from "./wallet-loader";
import { loadWalletInfo } from "./storage-service";

export class WalletWrapper {
    private readonly wallet: WalletService;
    private readonly mnemonic: string;
    private readonly logger: Logger;

    constructor(walletId: number, loggingLevel?: LoggingLevel) {
        this.loadWalletInfowallet = loadWallet(walletId);
        this.mnemonic = loadWalletInfo(walletId);
        this.logger = new Logger(`${WalletWrapper.name}-${walletId}`, loggingLevel);
    }

    async synchronize(): Promise<void> {
        try {
            await this.wallet.synchronize();
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    getCKBBalance(): CKBBalance {
        return this.wallet.getCKBBalance();
    }

    async getDAOBalance(): Promise<DAOBalance> {
        try {
            return this.wallet.getDAOBalance();
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    getTransactions(): Transaction[] {
        return this.wallet.getTransactions();
    }

    async getTransaction(txHash: string): Promise<Transaction> {
        try {
            return this.wallet.getTransactionFromHash(txHash);
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    getTokensBalance(): CustomToken[] {
        const tokens = this.wallet.getTokensBalance();
        return tokens.map(getTokenFromTokenAmount);
    }

    getNfts(): Promise<Nft[]> {
        try {
            return this.wallet.getNftsBalance();
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    getAddress(): string {
        return this.wallet.getNextAddress();
    }

    async sendTransaction(amount: bigint, to: string, feeRate: FeeRate): Promise<string> {
        try {
            return this.wallet.sendTransaction(amount, this.mnemonic, to, feeRate);
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    async depositInDAO(amount: bigint, feeRate: FeeRate): Promise<string> {
        try {
            return this.wallet.depositInDAO(amount, this.mnemonic, feeRate);
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    async getDAOUnlockableAmounts(): Promise<DAOUnlockableAmount[]> {
        try {
            return this.wallet.getDAOUnlockableAmounts();
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }

    async withdrawOrUnlock(unlockableAmount: UnlockableAmount): Promise<string> {
        try {
            return this.wallet.withdrawOrUnlock(unlockableAmount, this.mnemonic);
        } catch (error) {
            this.logger.error(error.toString());
            throw error;
        }
    }
}
```
{% endcode %}

{% hint style="info" %}
We save the mnemonic in the class to not ask it every time to the user. We could also have it protected with a pin.
{% endhint %}

{% hint style="info" %}
On some cases we catch the errors. In these catches you could show something on screen to indicate the call failed.
{% endhint %}

{% hint style="info" %}
Having a class allows to wrap functions such as `getTokensBalance`. This function checks the type of a token and maps it to something more understandable for the user..&#x20;
{% endhint %}

'''
'''--- docs/usage/wallet-loader.md ---
# Wallet loader

In this section we will make a wallet loader that uses a storage service. The storage service will be used to save and load the wallet state.

We will show two different ways to achieve this.

### Calling `getWalletService`

{% code title="wallet-loader.ts" %}
```typescript
import { WalletService, Environments } from "@peersyst/ckb-wallet-sdk";
import { mainnetConnection, testnetConnection } from "./network-connections";
import { saveWalletState, loadWalletInfo } from "./storage-service";

export function loadWallet(walletId: number): WalletService {
    const { mnemonic, walletState, environment } = loadWalletInfo(walletId);
    
    if (environment === Environments.Mainnet) {
        const wallet = new WalletService(mainnetConnection, mnemonic, walletState);
        return wallet;
    }
    const wallet = new WalletService(testnetConnection, mnemonic, walletState);
    return wallet;
}

export function saveWallet(walletId: number, wallet: WalletService): void {
    const walletState = wallet.getWalletState();
    saveWalletState(walletId, walletState);
}
```
{% endcode %}

{% hint style="info" %}
The function `saveWallet` should be called when the app closes.
{% endhint %}

### With `onSync`

{% code title="wallet-loader.ts" %}
```typescript
import { WalletService, Environments, WalletState, Logger } from "@peersyst/ckb-wallet-sdk";
import { mainnetConnection, testnetConnection } from "./network-connections";
import { saveWalletState, loadWalletInfo } from "./storage-service";

export function loadWallet(walletId: number): WalletService {
    const { mnemonic, walletState, environment } = loadWalletInfo(walletId);
    const onSync = (walletFState: WalletState) => {
        Logger.log("New wallet state");
        saveWalletState(walletId, walletFState);
    };
    const onSyncStarts = () => {
        Logger.log("Synchronization started");
    };
    
    if (environment === Environments.Mainnet) {
        const wallet = new WalletService(mainnetConnection, mnemonic, walletState, onSync, onSyncStarts);
        return wallet;
    }
    const wallet = new WalletService(testnetConnection, mnemonic, walletState, onSync, onSyncStarts);
    return wallet;
}
```
{% endcode %}

{% hint style="info" %}
Latest wallet state will be saved automatically after every synchronization.
{% endhint %}

{% hint style="info" %}
`OnSyncStarts` is called every time a synchronization starts. May be useful on apps to show the user a synchronization is executing.
{% endhint %}

'''
'''--- examples/create-wallet.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";

const main = async () => {
    try {
        const mnemonic = WalletService.createNewMnemonic();
        Logger.info(mnemonic); // Your new generated mnemonic, save it

        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // You can have more than 1 public address per mnemonic
        const nextAddress = wallet.getNextAddress();
        Logger.info(nextAddress);

        // To get your private key you need to put you mnemonic as sdk does not keep it
        const { privateKey, address } = wallet.getAddressAndPrivateKey(mnemonic);
        Logger.info(privateKey);
        Logger.info(address);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/deposit-in-dao.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const amount = BigInt(500 * 10 ** 8);

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.depositInDAO(amount, mnemonic);
        Logger.info(txHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-dao-statistics.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const statistics = await wallet.getDAOStatistics();
        Logger.info(statistics);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-dao-unlockable-amounts.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        Logger.info(unlockableAmounts);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/get-transactions.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const transactions = wallet.getTransactions();
        Logger.info(transactions);
        Logger.info(transactions.length);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/import-wallet-error.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        new WalletService(connectionService, mnemonic);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/import-wallet.ts ---
import { ConnectionService, Environments, WalletService, Logger, WalletState } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);

        // The third parameter given in the constructor is a callback called when a synchronize finishes
        const wallet = new WalletService(connectionService, mnemonic, null, async (walletState: WalletState) => {
            Logger.info("Got wallet State:");
            Logger.info(walletState);
        });

        await wallet.synchronize();
        const accounts = wallet.getAccountIndexes();
        Logger.info(accounts);
        const addresses = wallet.getAllAddresses();
        Logger.info(addresses);
        const newAddress = wallet.getNextAddress();
        Logger.info(newAddress);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/issue-tokens.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.issueTokens(1000, mnemonic);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/send-transaction.ts ---
import { ConnectionService, Environments, WalletService, Logger, FeeRate } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const amount = BigInt(513 * 10 ** 8); // 513 CKB

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // No need to sync as sendTransactions syncs before building the transaction
        const txHash = await wallet.sendTransaction(amount, mnemonic, receivingAddress, FeeRate.NORMAL);
        Logger.info(txHash);

        // You can view newly generated transaction through wallet.getTransactions when the tx is committed
        // If you want to know transaction status
        const transaction = await connectionService.getTransactionFromHash(txHash);
        Logger.info(JSON.stringify(transaction, null, 2));
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/transfer-tokens.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";
const receivingAddress = "ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqflx85grt0mnny6qsqwfxwkkvud4x3gwqgq2d0su";
const quantity = 10;
const token = "0x099472fc82e74d050d524ba32f8efc05d4a53800f4ab0bf88be9c3383586339a";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        const txHash = await wallet.transferTokens(quantity, mnemonic, receivingAddress, token);
        Logger.info(txHash);

        // This balance will be updated when we sync after the tx status is committed
        await wallet.synchronize();
        const tokensBalance = wallet.getTokensBalance();
        Logger.info(tokensBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- examples/unlock-from-dao.ts ---
import { ConnectionService, Environments, WalletService, Logger } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);

        // We will try to unlock first unlockable amount
        const unlockableAmounts = await wallet.getDAOUnlockableAmounts();
        if (unlockableAmounts.length === 0) {
            throw new Error("No unlockable or withdrawable amount. Deposit before trying to withdraw");
        }

        Logger.info("Withdrawing or unlocking the following unlockable amount:");
        Logger.info(unlockableAmounts[0]);
        const unlockHash = await wallet.withdrawOrUnlock(unlockableAmounts[0], mnemonic);
        Logger.info(unlockHash);

        // You can view DAO balance with
        const daoBalance = await wallet.getDAOBalance();
        Logger.info(daoBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
        Logger.error(`${error.stack}`);
    }
};

main();

'''
'''--- examples/wallet-balance.ts ---
import { ConnectionService, Environments, WalletService, Logger, AddressType } from "../src";

const ckbUrl = "http://localhost:8117/rpc";
const indexerUrl = "http://localhost:8117/indexer";
const mnemonic = "private pond zero popular fashion omit february obscure pattern city camp pistol";

const main = async () => {
    try {
        const connectionService = new ConnectionService(ckbUrl, indexerUrl, Environments.Testnet);
        const wallet = new WalletService(connectionService, mnemonic);
        await wallet.synchronize();

        const balanceAcc0Rec = await wallet.getBalanceFromAccount(0, AddressType.Receiving);
        Logger.info(balanceAcc0Rec);
        const balanceAcc0Chg = await wallet.getBalanceFromAccount(0, AddressType.Change);
        Logger.info(balanceAcc0Chg);
        const balanceAcc1 = await wallet.getBalanceFromAccount(1, AddressType.Receiving);
        Logger.info(balanceAcc1);
        const totalBalance = await wallet.getBalance();
        Logger.info(totalBalance);
    } catch (error) {
        Logger.error(`${error.name}: ${error.message}`);
    }
};

main();

'''
'''--- package.json ---
{
    "name": "@peersyst/ckb-wallet-sdk",
    "version": "1.0.0",
    "description": "Nervos CKB wallet SDK",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
        "build": "tsc",
        "prepare": "npm run build",
        "start": "ts-node src/index.ts",
        "example": "ts-node examples/$npm_config_name.ts",
        "lint": "eslint . --ext .ts,.json",
        "test": "jest --passWithNoTests --detectOpenHandles",
        "test:coverage": "jest --coverage --passWithNoTests"
    },
    "files": [
        "dist/src/",
        "dist/index.d.ts",
        "dist/index.js",
        "dist/index.js.map"
    ],
    "repository": {
        "type": "git",
        "url": "https://github.com/Peersyst/ckb-wallet-sdk"
    },
    "jest": {
        "moduleFileExtensions": [
            "js",
            "json",
            "ts"
        ],
        "rootDir": ".",
        "testRegex": ".*\\.spec\\.ts$",
        "transform": {
            "^.+\\.ts$": "ts-jest"
        },
        "collectCoverageFrom": [
            "./src/modules/**/*.ts"
        ],
        "coverageDirectory": "./coverage",
        "testEnvironment": "node",
        "coverageThreshold": {
            "global": {
                "branches": 90,
                "statements": 90
            }
        }
    },
    "author": "Joan Grau <jgrau@peersyst.com>",
    "license": "ISC",
    "dependencies": {
        "@ckb-lumos/lumos": "^0.18.0-rc6",
        "@rather-labs/nrc-721-sdk": "0.0.16",
        "cross-fetch": "^3.1.5",
        "rimraf": "^3.0.2"
    },
    "devDependencies": {
        "@types/node": "^17.0.21",
        "@typescript-eslint/eslint-plugin": "^5.11.0",
        "@typescript-eslint/parser": "^5.11.0",
        "eslint": "^8.8.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.4",
        "eslint-plugin-prettier": "^4.0.0",
        "jest": "^27.5.1",
        "prettier": "^2.5.1",
        "supertest": "^6.2.2",
        "ts-jest": "^27.1.3",
        "ts-loader": "^9.2.6",
        "ts-node": "^10.5.0",
        "tsconfig-paths": "^3.14.1",
        "typescript": "^4.5.5",
        "webpack": "^5.68.0"
    }
}

'''
'''--- src/core/assets/ckb.service.ts ---
import { TransactionSkeleton } from "@ckb-lumos/helpers";
import { common } from "@ckb-lumos/common-scripts";
import { ConnectionService } from "../connection.service";
import { TransactionService, FeeRate } from "../transaction.service";
import { Cell } from "@ckb-lumos/lumos";

export interface CKBBalance {
    totalBalance: number;
    occupiedBalance: number;
    freeBalance: number;
}

export class CKBService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly transferCellSize = BigInt(61 * 10 ** 8);
    private readonly transferData = "0x";

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;
    }

    async transfer(from: string, to: string, amount: bigint, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        if (amount < this.transferCellSize) {
            throw new Error("Minimum transfer (cell) value is 61 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await common.transfer(txSkeleton, [from], to, amount, null, null, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async transferFromCells(
        cells: Cell[],
        fromAddresses: string[],
        to: string,
        amount: bigint,
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        if (amount < this.transferCellSize) {
            throw new Error("Minimum transfer (cell) value is 61 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });

        // Add output
        const toScript = this.connection.getLockFromAddress(to);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                },
                data: this.transferData,
            });
        });

        // Inject capacity
        txSkeleton = this.transactionService.addSecp256CellDep(txSkeleton);
        txSkeleton = this.transactionService.injectCapacity(txSkeleton, amount, cells);

        // Pay fee
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, fromAddresses, feeRate, null, this.connection.getConfigAsObject());

        // Get signing private keys
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, fromAddresses, privateKeys);

        return this.transactionService.signTransaction(txSkeleton, signingPrivKeys);
    }

    async getBalance(address: string): Promise<CKBBalance> {
        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const cells: Cell[] = [];
        for await (const cell of collector.collect()) {
            cells.push(cell);
        }

        return this.getBalanceFromCells(cells);
    }

    getBalanceFromCells(cells: Cell[]): CKBBalance {
        let totalBalanceBI = BigInt(0);
        let occupiedBalanceBI = BigInt(0);

        for (const cell of cells) {
            totalBalanceBI += BigInt(cell.cell_output.capacity);
            if (cell.cell_output.type) {
                occupiedBalanceBI += BigInt(cell.cell_output.capacity);
            }
        }
        const freeBalance = Number(totalBalanceBI - occupiedBalanceBI) / 10 ** 8;
        const totalBalance = Number(totalBalanceBI) / 10 ** 8;
        const occupiedBalance = Number(occupiedBalanceBI) / 10 ** 8;

        return { totalBalance, occupiedBalance, freeBalance };
    }
}

'''
'''--- src/core/assets/nft.service.ts ---
import { Cell } from "@ckb-lumos/lumos";
import * as NrcSdk from "@rather-labs/nrc-721-sdk";
import { Logger } from "../../utils/logger";
import { ConnectionService } from "../connection.service";
import { ScriptType } from "../transaction.service";
import { NftScript, NftSdk } from "./nft.types";

export interface Nft {
    tokenId: string;
    tokenUri: string;
    nftName: string;
    nftSymbol?: string;
    data?: any;
    nftExtraData?: string;
    issued?: number;
    total?: number;
}

export interface MNft {
    name: string;
    description: string;
    renderer: string;
    version: number;
    configure: number;
    issued: number;
    total: number;
}

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export class NftService {
    private readonly connection: ConnectionService;
    private readonly logger = new Logger(NftService.name);
    private readonly mNftCodeHash = "0x2b24f0d644ccbdd77bbf86b27c8cca02efa0ad051e447c212636d9ee7acaaec9";
    private readonly mNftClassCodeHash = "0xd51e6eaf48124c601f41abe173f1da550b4cbca9c6a166781906a287abbb3d9a";
    private nftSdk: NftSdk = null;
    private initializing = false;

    constructor(connectionService: ConnectionService) {
        this.connection = connectionService;
    }

    private static mNftFormat(dataHex: string): MNft {
        const data = dataHex.slice(2);
        const version = parseInt(data.slice(0, 1), 16);
        const total = parseInt(data.slice(1, 10), 16);
        const issued = parseInt(data.slice(10, 18), 16);
        const configure = parseInt(data.slice(18, 20), 16);
        const nameSize = parseInt(data.slice(20, 24), 16);
        const nameEnd = 24 + nameSize * 2;
        const name = decodeURIComponent(data.slice(24, nameEnd).replace(/[0-9a-f]{2}/g, "%$&"));
        const descriptionSizeEnd = nameEnd + 4;
        const descriptionSize = parseInt(data.slice(nameEnd, descriptionSizeEnd), 16);
        const descriptionEnd = descriptionSizeEnd + descriptionSize * 2;
        const description = decodeURIComponent(data.slice(descriptionSizeEnd, descriptionEnd).replace(/[0-9a-f]{2}/g, "%$&"));
        const rendererSizeEnd = descriptionEnd + 4;
        const rendererSize = parseInt(data.slice(descriptionEnd, rendererSizeEnd), 16);
        const rendererEnd = rendererSizeEnd + rendererSize * 2;
        const renderer = decodeURIComponent(data.slice(rendererSizeEnd, rendererEnd).replace(/[0-9a-f]{2}/g, "%$&"));

        return {
            name: name,
            description: description,
            renderer: renderer,
            version: version,
            configure: configure,
            issued: issued,
            total: total,
        };
    }

    async initialize() {
        if (!this.nftSdk && !this.initializing) {
            this.initializing = true;
            this.nftSdk = await NrcSdk.initialize({
                nodeUrl: this.connection.getCKBUrl(),
                indexerUrl: this.connection.getIndexerUrl(),
            });
            this.logger.info("NftService initialized");
        } else if (!this.nftSdk) {
            while (!this.nftSdk) {
                await sleep(100);
            }
        }
    }

    async isScriptNftScript(scriptType: ScriptType): Promise<boolean> {
        await this.initialize();

        let isNftCell: boolean;
        try {
            isNftCell = await this.nftSdk.nftCell.isCellNRC721(scriptType);
        } catch (error) {
            isNftCell = false;
        }

        return isNftCell;
    }

    private cellToNftScript(cell: Cell): NftScript {
        if (!cell.cell_output.type) {
            return null;
        }

        return {
            codeHash: cell.cell_output.type.code_hash,
            args: cell.cell_output.type.args,
            hashType: cell.cell_output.type.hash_type,
        };
    }

    private async getNftFromCell(cell: Cell): Promise<Nft | null> {
        const cellTypeScript = this.cellToNftScript(cell);
        if (!cellTypeScript) {
            return null;
        }

        let isNftCell: boolean;
        try {
            isNftCell = await this.nftSdk.nftCell.isCellNRC721(cellTypeScript);
        } catch (error) {
            isNftCell = false;
        }

        if (isNftCell) {
            const nft = await this.nftSdk.nftCell.read(cellTypeScript);

            return {
                tokenId: nft.tokenId,
                tokenUri: nft.tokenUri,
                data: JSON.parse(nft.data),
                nftName: nft.factoryData.name,
                nftSymbol: nft.factoryData.symbol,
                nftExtraData: nft.factoryData.extraData,
            };
        }
        if (cellTypeScript.codeHash === this.mNftCodeHash) {
            const cellProvider = this.connection.getCellProvider({
                type: {
                    code_hash: this.mNftClassCodeHash,
                    args: cellTypeScript.args.slice(0, -8),
                    hash_type: "type",
                },
            });

            const cells: Cell[] = [];
            const cellCollector = cellProvider.collector({});
            for await (const cell of cellCollector.collect()) {
                cells.push(cell);
            }

            if (cells.length === 1) {
                const mNft = NftService.mNftFormat(cells[0].data);

                return {
                    nftName: mNft.name,
                    tokenId: parseInt(cellTypeScript.args.slice(-8), 16).toString(),
                    tokenUri: mNft.renderer,
                    issued: mNft.issued,
                    total: mNft.total,
                    data: {
                        description: mNft.description,
                        version: mNft.version,
                        configure: mNft.configure,
                        type: "m-NFT",
                    },
                };
            }
        }

        return null;
    }

    async getBalance(address: string): Promise<Nft[]> {
        await this.initialize();

        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const nfts: Nft[] = [];
        for await (const cell of collector.collect()) {
            const nft = await this.getNftFromCell(cell);
            if (nft) {
                nfts.push(nft);
            }
        }

        return nfts;
    }

    async getBalanceFromCells(cells: Cell[]): Promise<Nft[]> {
        await this.initialize();

        const nfts: Nft[] = [];
        for await (const cell of cells) {
            const nft = await this.getNftFromCell(cell);
            if (nft) {
                nfts.push(nft);
            }
        }

        return nfts;
    }
}

'''
'''--- src/core/assets/nft.types.ts ---
// TODO change @nervosnetwork/ckb-sdk-core Cell and RawTransaction types
import { Cell, RawTransaction } from "@ckb-lumos/lumos";

export interface NftScript {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface MintNftParams {
    name: string;
    symbol: string;
    baseTokenUri: string;
    sourceAddress: string;
    targetAddress: string;
    extraData: Buffer;
    fee?: number;
    factoryContractTypeScript?: NftScript;
    factoryContractDep?: NftScript;
    extraDeps?: string[];
}

export interface MintNftResponse {
    rawTransaction: RawTransaction;
    typeScript: NftScript;
    usedCapacity: bigint;
    inputCells: Cell[];
}

export interface FactoryData {
    name: string;
    symbol: string;
    baseTokenUri: string;
    extraData: string;
}

export interface ReadFactoryResponse {
    data: FactoryData;
    rawCell: Cell;
}

export interface FactoryConstants {
    TYPE_CODE_HASH_SIZE: number;
    TYPE_ARGS_SIZE: number;
}

export interface CreateNewTypeScriptParams {
    rawTransaction: RawTransaction;
    factoryTypeScript: NftScript;
    nftTypeCodeHash: string;
    outputIndex: string;
}

export interface MintParams {
    nftContractTypeScript: NftScript;
    factoryTypeScript: NftScript;
    sourceAddress: string;
    targetAddress: string;
    nftContractDep?: NftScript;
    extraDeps?: string[];
    fee?: number;
    data?: any;
}

export interface MintResponse {
    rawTransaction: RawTransaction;
    nftTypeScript: NftScript;
    usedCapacity: bigint;
    inputCells: Cell[];
}

export interface ReadNftResponse {
    tokenId: string;
    tokenUri: string;
    data: string;
    factoryData: FactoryData;
    rawCell: Cell;
}

export interface NftFactoryCell {
    mint: (mintData: MintNftParams) => Promise<MintNftResponse>;
    readOne: (typeScript: NftScript) => Promise<ReadFactoryResponse>;
    isCellNRC721: (factoryTypeScript: NftScript) => Promise<boolean>;
    CONSTANTS: FactoryConstants;
}

export interface NftSdkCell {
    getAllFactoryNftsByAdress: ({ userAdress, factoryTypeScript }: { userAdress: string; factoryTypeScript: NftScript }) => Promise<Cell[]>;
    createNewTypeScript: (params: CreateNewTypeScriptParams) => NftScript;
    mint: (params: MintParams) => Promise<MintResponse>;
    read: (nftTypeScript: NftScript) => Promise<ReadNftResponse>;
    isCellNRC721: (nftTypeScript: NftScript) => Promise<boolean>;
}

export interface NftSdkUtils {
    getCellOccupiedCapacity: (cell: Cell, data: string) => number;
    bigNumberCKBToShannon: (amount: number | StringConstructor) => bigint;
    serializeInputCell: (inputCell: Cell) => Buffer;
    hxShannonToCKB: (hexNumber: string) => number;
    CKBToShannon: (amount: number) => bigint;
    shannonToCKB: (amount: number) => number;
    hexToBytes: (hexString: string) => number[];
}

export interface NftSdk {
    factoryCell: NftFactoryCell;
    nftCell: NftSdkCell;
    utils: NftSdkUtils;
}

'''
'''--- src/core/assets/token.service.ts ---
import { Cell, Script, utils } from "@ckb-lumos/lumos";
import { TransactionSkeleton } from "@ckb-lumos/helpers";
import { sudt, common } from "@ckb-lumos/common-scripts";
import { ConnectionService } from "../connection.service";
import { FeeRate, TransactionService } from "../transaction.service";

export interface TokenType {
    args: string;
    codeHash: string;
    hashType: string;
}
export interface TokenAmount {
    type: TokenType;
    amount: number;
}

export class TokenService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    // private readonly sudtCellSize = BI.from(142 * 10 ** 8);

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;
    }

    private isTokenScriptType(script: Script): boolean {
        if (!script) {
            return false;
        }

        const sudtScript = this.connection.getConfig().SCRIPTS.SUDT;
        return script.code_hash === sudtScript.CODE_HASH && script.hash_type === sudtScript.HASH_TYPE;
    }

    async issue(address: string, amount: number, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await sudt.issueToken(txSkeleton, address, amount, undefined, undefined, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [address], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async transfer(
        from: string,
        to: string,
        token: string,
        amount: number,
        privateKey: string,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getCellProvider() });
        txSkeleton = await sudt.transfer(txSkeleton, [from], token, to, amount, undefined, undefined, undefined, {
            config: this.connection.getConfig(),
        });
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async getBalance(address: string): Promise<TokenAmount[]> {
        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
        });

        const cells: Cell[] = [];
        for await (const cell of collector.collect()) {
            cells.push(cell);
        }

        return this.getBalanceFromCells(cells);
    }

    getBalanceFromCells(cells: Cell[]): TokenAmount[] {
        const tokenMap = new Map<string, number>();
        for (const cell of cells) {
            if (this.isTokenScriptType(cell.cell_output.type)) {
                const key = cell.cell_output.type.args;

                if (!tokenMap.has(key)) {
                    tokenMap.set(key, Number(utils.readBigUInt128LE(cell.data)));
                } else {
                    tokenMap.set(key, Number(utils.readBigUInt128LE(cell.data)) + tokenMap.get(key));
                }
            }
        }

        const tokens: TokenAmount[] = [];
        const { CODE_HASH: codeHash, HASH_TYPE: hashType } = this.connection.getConfig().SCRIPTS.SUDT;
        tokenMap.forEach((value, key) =>
            tokens.push({
                type: { args: key, codeHash, hashType },
                amount: value,
            }),
        );

        return tokens;
    }
}

'''
'''--- src/core/connection.service.ts ---
import { RPC, config, Script, helpers, OutPoint, Indexer } from "@ckb-lumos/lumos";
import {
    TransactionWithStatus,
    Header,
    ChainInfo,
    CellWithStatus,
    Indexer as IndexerType,
    CellProvider,
    CellCollector,
    QueryOptions,
} from "@ckb-lumos/base";
import { Config, ScriptConfig } from "@ckb-lumos/config-manager";
import { isSecp256k1Blake160Address, isAcpAddress, isSecp256k1Blake160MultisigAddress } from "@ckb-lumos/common-scripts/lib/helper";

// AGGRON4 for test, LINA for main
const { AGGRON4, LINA } = config.predefined;

export enum Environments {
    Mainnet = "mainnet",
    Testnet = "testnet",
}

const OnepassConfig: { [key in Environments]: ScriptConfig } = {
    [Environments.Mainnet]: {
        CODE_HASH: "0xd01f5152c267b7f33b9795140c2467742e8424e49ebe2331caec197f7281b60a",
        HASH_TYPE: "type",
        TX_HASH: "0x86a5e91ad93475caf30a3d3b0258786dd463984f71e8471abc5574f206f6207a",
        INDEX: "0x0",
        DEP_TYPE: "code",
    },
    [Environments.Testnet]: {
        CODE_HASH: "0x3e1eb7ed4809b2d60650be96a40abfbdafb3fb942b7b37ec7709e64e2cd0a783",
        HASH_TYPE: "type",
        TX_HASH: "0x8b98ede6bf7b5baba767b1d2d46a13749fc810375b14152abbc259a7fc98e46d",
        INDEX: "0x0",
        DEP_TYPE: "code",
    },
};

class CustomCellProvider implements CellProvider {
    public readonly uri: string;

    constructor(private readonly indexer: IndexerType, private readonly myQueryOptions: QueryOptions) {
        this.uri = indexer.uri;
    }

    collector(queryOptions: QueryOptions): CellCollector {
        return this.indexer.collector({ ...queryOptions, ...this.myQueryOptions });
    }
}

export class ConnectionService {
    private readonly ckbUrl: string;
    private readonly indexerUrl: string;
    private readonly env: Environments;
    private readonly rpc: RPC;
    private readonly indexer: IndexerType;
    private readonly config: Config;
    private blockHeaderNumberMap = new Map<string, Header>();
    private blockHeaderHashMap = new Map<string, Header>();
    private transactionMap = new Map<string, TransactionWithStatus>();

    // ckbUrl is the url of the node rpc
    // indexerUrl is the url of the node indexer
    // env is the environment of the node
    constructor(ckbUrl: string, indexerUrl: string, env: Environments) {
        this.ckbUrl = ckbUrl;
        this.indexerUrl = indexerUrl;
        this.env = env;
        this.rpc = new RPC(this.ckbUrl);
        this.indexer = new Indexer(this.indexerUrl, this.ckbUrl);
        this.config = env === Environments.Mainnet ? LINA : AGGRON4;
        config.initializeConfig(this.config);
    }

    // Returns info of the blockchain connected by the rpc
    async getBlockchainInfo(): Promise<ChainInfo> {
        return this.rpc.get_blockchain_info();
    }

    setBlockHeaderMaps(header: Header): void {
        this.blockHeaderHashMap.set(header.hash, header);
        this.blockHeaderNumberMap.set(header.number, header);
    }

    // Gets latest block header in the blockchain
    async getCurrentBlockHeader(): Promise<Header> {
        const lastBlockHeader = await this.rpc.get_tip_header();
        this.setBlockHeaderMaps(lastBlockHeader);
        return lastBlockHeader;
    }

    // Gets a block header from its hash
    async getBlockHeaderFromHash(blockHash: string): Promise<Header> {
        if (!this.blockHeaderHashMap.has(blockHash)) {
            const header = await this.rpc.get_header(blockHash);
            this.setBlockHeaderMaps(header);
        }
        return this.blockHeaderHashMap.get(blockHash);
    }

    // Get a block header from its hex number
    async getBlockHeaderFromNumber(blockNumber: string): Promise<Header> {
        if (!this.blockHeaderNumberMap.has(blockNumber)) {
            const header = await this.rpc.get_header_by_number(blockNumber);
            this.setBlockHeaderMaps(header);
        }
        return this.blockHeaderNumberMap.get(blockNumber);
    }

    // Gets a cell by its out point
    async getCell(outPoint: OutPoint): Promise<CellWithStatus> {
        return this.rpc.get_live_cell(outPoint, true);
    }

    // Gets a transaction with status from a hash
    // Useful for when the transaction is still not committed
    // For transactions that fave not finished you should set useMap = false to not receive the same!
    async getTransactionFromHash(transactionHash: string, useMap = true): Promise<TransactionWithStatus> {
        if (!useMap || !this.transactionMap.has(transactionHash)) {
            const transaction = await this.rpc.get_transaction(transactionHash);
            this.transactionMap.set(transactionHash, transaction);
        }
        return this.transactionMap.get(transactionHash);
    }

    getConfig(): Config {
        return this.config;
    }

    getConfigAsObject(): helpers.Options {
        return { config: this.config };
    }

    getRPC(): RPC {
        return this.rpc;
    }

    // Get current environment
    getEnvironment(): Environments {
        return this.env;
    }

    getIndexer(): IndexerType {
        return this.indexer;
    }

    getCellProvider(queryOptions: QueryOptions = {}): CellProvider {
        return new CustomCellProvider(this.indexer, queryOptions);
    }

    getEmptyCellProvider(queryOptions: QueryOptions = {}): CellProvider {
        return this.getCellProvider({ ...queryOptions, type: "empty" });
    }

    // Get current ckb url
    getCKBUrl(): string {
        return this.ckbUrl;
    }

    // Get current indexer url
    getIndexerUrl(): string {
        return this.indexerUrl;
    }

    // Generates an address from a lock script
    getAddressFromLock(lock: Script): string {
        // return helpers.generateAddress(lock, { config: this.config });
        return helpers.encodeToAddress(lock, { config: this.config });
    }

    // Gets the locks script from an address
    getLockFromAddress(address: string): Script {
        return helpers.parseAddress(address, { config: this.config });
    }

    static getLockFromAddress(address: string, config: Config): Script {
        return helpers.parseAddress(address, { config });
    }

    isAddress(address: string): boolean {
        try {
            return (
                isSecp256k1Blake160Address(address, this.config) ||
                isAcpAddress(address, this.config) ||
                isSecp256k1Blake160MultisigAddress(address, this.config) ||
                this.isOnepassAddress(address)
            );
        } catch (err) {
            return false;
        }
    }

    isOnepassAddress(address: string): boolean {
        const lock = this.getLockFromAddress(address);
        return lock.code_hash === OnepassConfig[this.env].CODE_HASH && lock.hash_type === OnepassConfig[this.env].HASH_TYPE;
    }

    // Providing an environment and addres returns a boolean indicating:
    // true address is Blake160, Blake160Multisig, ACP, Onepass
    // false address is of another kind or invalid
    static isAddress(network: Environments, address: string): boolean {
        const config = network === Environments.Mainnet ? LINA : AGGRON4;
        try {
            return (
                isSecp256k1Blake160Address(address, config) ||
                isAcpAddress(address, config) ||
                isSecp256k1Blake160MultisigAddress(address, config) ||
                ConnectionService.isOnepassAddress(network, address)
            );
        } catch (err) {
            return false;
        }
    }

    static isOnepassAddress(network: Environments, address: string): boolean {
        const config = network === Environments.Mainnet ? LINA : AGGRON4;
        const lock = ConnectionService.getLockFromAddress(address, config);
        return lock.code_hash === OnepassConfig[network].CODE_HASH && lock.hash_type === OnepassConfig[network].HASH_TYPE;
    }
}

'''
'''--- src/core/dao/dao.service.ts ---
import { Cell, Script } from "@ckb-lumos/base";
import { since } from "@ckb-lumos/lumos";
import { TransactionSkeleton, TransactionSkeletonType } from "@ckb-lumos/helpers";
import { dao, common } from "@ckb-lumos/common-scripts";
import { ConnectionService, Environments } from "../connection.service";
import { FeeRate, TransactionService } from "../transaction.service";
import { Logger } from "../../utils/logger";

export interface DAOStatistics {
    maximumWithdraw: bigint;
    daoEarliestSince: bigint;
}

export interface DAOBalance {
    daoDeposit: number;
    daoCompensation: number;
}

export interface DAOUnlockableAmount {
    type: "deposit" | "withdraw";
    amount: bigint;
    compensation: bigint;
    unlockable: boolean;
    remainingCycleMinutes: number;
    remainingEpochs: number;
    txHash: string;
}

export enum DAOCellType {
    DEPOSIT = "deposit",
    WITHDRAW = "withdraw",
    ALL = "all",
}

export class DAOService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly logger = new Logger(DAOService.name);
    private readonly daoCellSize = BigInt(102 * 10 ** 8);
    private readonly daoScriptArgs = "0x";
    private readonly depositDaoData = "0x0000000000000000";
    private blockTime = 8.02;

    constructor(connectionService: ConnectionService, transactionService: TransactionService) {
        this.connection = connectionService;
        this.transactionService = transactionService;

        if (this.connection.getEnvironment() === Environments.Mainnet) {
            this.blockTime = 11.25;
        } else {
            this.blockTime = 7.5;
        }
    }

    private getDAOScript(): Script {
        const daoConfig = this.connection.getConfig().SCRIPTS.DAO;

        return {
            code_hash: daoConfig.CODE_HASH,
            hash_type: daoConfig.HASH_TYPE,
            args: this.daoScriptArgs,
        };
    }

    private isCellDAO(cell: Cell): boolean {
        const daoScript = this.getDAOScript();
        if (!cell.cell_output.type) {
            return false;
        }
        const { code_hash, hash_type, args } = cell.cell_output.type;

        return code_hash === daoScript.code_hash && hash_type === daoScript.hash_type && args === daoScript.args;
    }

    private addDAOCellDep(txSkeleton: TransactionSkeletonType): TransactionSkeletonType {
        const template = this.connection.getConfig().SCRIPTS.DAO;
        return TransactionService.addCellDep(txSkeleton, template);
    }

    isCellDeposit(cell: Cell): boolean {
        return cell.data === this.depositDaoData;
    }

    async isCellUnlockable(cell: Cell): Promise<boolean> {
        let sinceBI: bigint;
        const currentBlockHeader = await this.connection.getCurrentBlockHeader();
        const currentEpoch = since.parseEpoch(currentBlockHeader.epoch);

        if (this.isCellDeposit(cell)) {
            sinceBI = await this.getDepositDaoEarliestSince(cell);
        } else {
            sinceBI = await this.getWithdrawDaoEarliestSince(cell);
        }
        const earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());

        const unlockable =
            currentEpoch.number > earliestSince.number ||
            (currentEpoch.number === earliestSince.number && currentEpoch.index >= earliestSince.index);
        return unlockable;
    }

    async getCells(address: string, cellType: DAOCellType = DAOCellType.ALL): Promise<Cell[]> {
        const cells = [];
        const daoScript = this.getDAOScript();
        const data = cellType === DAOCellType.DEPOSIT ? this.depositDaoData : "any";

        const collector = this.connection.getIndexer().collector({
            lock: this.connection.getLockFromAddress(address),
            type: daoScript,
            data,
        });

        for await (const inputCell of collector.collect()) {
            if (cellType === DAOCellType.WITHDRAW && this.isCellDeposit(inputCell)) {
                continue;
            }

            if (!inputCell.block_hash && inputCell.block_number) {
                const header = await this.connection.getBlockHeaderFromNumber(inputCell.block_number);
                cells.push({ ...inputCell, block_hash: header.hash });
            } else {
                cells.push(inputCell);
            }
        }

        return cells;
    }

    async filterDAOCells(cells: Cell[], cellType: DAOCellType = DAOCellType.ALL): Promise<Cell[]> {
        const filteredCells: Cell[] = [];
        for (const cell of cells) {
            if (this.isCellDAO(cell)) {
                if (
                    (cellType === DAOCellType.WITHDRAW && this.isCellDeposit(cell)) ||
                    (cellType === DAOCellType.DEPOSIT && !this.isCellDeposit(cell))
                ) {
                    continue;
                }

                if (!cell.block_hash && cell.block_number) {
                    const header = await this.connection.getBlockHeaderFromNumber(cell.block_number);
                    filteredCells.push({ ...cell, block_hash: header.hash });
                } else {
                    filteredCells.push(cell);
                }
            }
        }

        return filteredCells;
    }

    async getBalance(address: string): Promise<DAOBalance> {
        const cells = await this.getCells(address, DAOCellType.ALL);
        let daoDeposit = BigInt(0);
        let daoCompensation = BigInt(0);

        for (let i = 0; i < cells.length; i += 1) {
            let maxWithdraw = BigInt(0);
            daoDeposit += BigInt(cells[i].cell_output.capacity);

            if (this.isCellDeposit(cells[i])) {
                maxWithdraw = await this.getDepositCellMaximumWithdraw(cells[i]);
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(cells[i]);
            }

            daoCompensation += maxWithdraw - BigInt(cells[i].cell_output.capacity);
        }

        return { daoDeposit: Number(daoDeposit) / 10 ** 8, daoCompensation: Number(daoCompensation) / 10 ** 8 };
    }

    async getBalanceFromCells(cells: Cell[]): Promise<DAOBalance> {
        const daoCells = await this.filterDAOCells(cells, DAOCellType.ALL);
        let daoDeposit = BigInt(0);
        let daoCompensation = BigInt(0);

        for (let i = 0; i < daoCells.length; i += 1) {
            let maxWithdraw = BigInt(0);
            daoDeposit += BigInt(daoCells[i].cell_output.capacity);

            if (this.isCellDeposit(daoCells[i])) {
                maxWithdraw = await this.getDepositCellMaximumWithdraw(daoCells[i]);
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(daoCells[i]);
            }

            daoCompensation += maxWithdraw - BigInt(daoCells[i].cell_output.capacity);
        }

        return { daoDeposit: Number(daoDeposit) / 10 ** 8, daoCompensation: Number(daoCompensation) / 10 ** 8 };
    }

    async deposit(amount: bigint, from: string, to: string, privateKey: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        if (amount < this.daoCellSize) {
            throw new Error("Minimum deposit value is 102 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await dao.deposit(txSkeleton, from, to, amount, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, [from], feeRate, null, this.connection.getConfigAsObject());

        return this.transactionService.signTransaction(txSkeleton, [privateKey]);
    }

    async depositMultiAccount(
        amount: bigint,
        cells: Cell[],
        fromAddresses: string[],
        to: string,
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        if (amount < this.daoCellSize) {
            throw new Error("Minimum deposit value is 102 CKB");
        }

        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = this.addDAOCellDep(txSkeleton);

        // Add output
        const toScript = this.connection.getLockFromAddress(to);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                    type: this.getDAOScript(),
                },
                data: this.depositDaoData,
            });
        });
        const outputIndex = txSkeleton.get("outputs").size - 1;

        // Fix output entry
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
            return fixedEntries.push({
                field: "outputs",
                index: outputIndex,
            });
        });

        // Inject capacity
        txSkeleton = this.transactionService.addSecp256CellDep(txSkeleton);
        txSkeleton = this.transactionService.injectCapacity(txSkeleton, amount, cells);

        // Pay fee
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, fromAddresses, feeRate, null, this.connection.getConfigAsObject());

        // Get signing private keys
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, fromAddresses, privateKeys);

        return this.transactionService.signTransaction(txSkeleton, signingPrivKeys);
    }

    async withdraw(
        inputCell: Cell,
        privateKey: string,
        feeAddresses: string[],
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        txSkeleton = await dao.withdraw(txSkeleton, inputCell, null, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, feeAddresses, feeRate, null, this.connection.getConfigAsObject());
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, feeAddresses, privateKeys);
        const sortedSignPKeys = [privateKey, ...signingPrivKeys.filter((pkey) => pkey !== privateKey)];

        return this.transactionService.signTransaction(txSkeleton, sortedSignPKeys);
    }

    async unlock(
        withdrawCell: Cell,
        privateKey: string,
        from: string,
        to: string,
        feeAddresses: string[],
        privateKeys: string[],
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        let txSkeleton = TransactionSkeleton({ cellProvider: this.connection.getEmptyCellProvider() });
        const depositCell = await this.getDepositCellFromWithdrawCell(withdrawCell);
        if (!(await this.isCellUnlockable(withdrawCell))) {
            throw new Error("Cell can not be unlocked. Minimum time is 30 days.");
        }

        txSkeleton = await dao.unlock(txSkeleton, depositCell, withdrawCell, to, from, this.connection.getConfigAsObject());
        txSkeleton = await common.payFeeByFeeRate(txSkeleton, feeAddresses, feeRate, null, this.connection.getConfigAsObject());
        const signingPrivKeys = this.transactionService.extractPrivateKeys(txSkeleton, feeAddresses, privateKeys);
        const sortedSignPKeys = [privateKey, ...signingPrivKeys.filter((pkey) => pkey !== privateKey)];

        return this.transactionService.signTransaction(txSkeleton, sortedSignPKeys);
    }

    async findCorrectInputFromWithdrawCell(withdrawCell: Cell): Promise<{ index: string; txHash: string }> {
        const transaction = await this.connection.getTransactionFromHash(withdrawCell.out_point.tx_hash);

        let index: string;
        let txHash: string;
        for (let i = 0; i < transaction.transaction.inputs.length && !index; i += 1) {
            const prevOut = transaction.transaction.inputs[i].previous_output;

            const possibleTx = await this.connection.getTransactionFromHash(prevOut.tx_hash);
            const output = possibleTx.transaction.outputs[parseInt(prevOut.index, 16)];
            if (
                output.type &&
                output.capacity === withdrawCell.cell_output.capacity &&
                output.lock.args === withdrawCell.cell_output.lock.args &&
                output.lock.hash_type === withdrawCell.cell_output.lock.hash_type &&
                output.lock.code_hash === withdrawCell.cell_output.lock.code_hash &&
                output.type.args === withdrawCell.cell_output.type.args &&
                output.type.hash_type === withdrawCell.cell_output.type.hash_type &&
                output.type.code_hash === withdrawCell.cell_output.type.code_hash
            ) {
                index = prevOut.index;
                txHash = prevOut.tx_hash;
            }
        }

        return { index, txHash };
    }

    async findCellFromUnlockableAmount(unlockableAmount: DAOUnlockableAmount, address: string): Promise<Cell> {
        const cells = await this.getCells(address);
        return this.findCellFromUnlockableAmountAndCells(unlockableAmount, cells);
    }

    async findCellFromUnlockableAmountAndCells(unlockableAmount: DAOUnlockableAmount, cells: Cell[]): Promise<Cell> {
        const filtCells = await this.filterDAOCells(cells);
        const capacity = `0x${unlockableAmount.amount.toString(16)}`;

        for (let i = 0; i < filtCells.length; i += 1) {
            if (filtCells[i].cell_output.capacity === capacity && filtCells[i].out_point.tx_hash === unlockableAmount.txHash) {
                return filtCells[i];
            }
        }

        return null;
    }

    async getDepositCellFromWithdrawCell(withdrawCell: Cell): Promise<Cell> {
        const { index, txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return {
            cell_output: {
                capacity: withdrawCell.cell_output.capacity,
                lock: { ...withdrawCell.cell_output.lock },
                type: { ...withdrawCell.cell_output.type },
            },
            out_point: {
                tx_hash: txHash,
                index,
            },
            data: this.depositDaoData,
            block_hash: depositBlockHeader.hash,
            block_number: depositBlockHeader.number,
        };
    }

    async getWithdrawCellFromCapacityTx(capacity: string, address: string, txHash: string): Promise<Cell> {
        const cells = await this.getCells(address, DAOCellType.WITHDRAW);
        this.logger.info(`finding cell with capacity ${capacity} address ${address} and txHash ${txHash}`);

        for (let i = 0; i < cells.length; i += 1) {
            this.logger.info(cells[i]);
            if (cells[i].cell_output.capacity === capacity && cells[i].out_point.tx_hash === txHash) {
                return cells[i];
            }
        }

        return null;
    }

    async getStatistics(address: string): Promise<DAOStatistics> {
        const cells = await this.getCells(address, DAOCellType.ALL);

        return this.getStatisticsFromCells(cells);
    }

    async getStatisticsFromCells(cells: Cell[]): Promise<DAOStatistics> {
        const filtCells = await this.filterDAOCells(cells, DAOCellType.ALL);
        const statistics: DAOStatistics = { maximumWithdraw: BigInt(0), daoEarliestSince: null };

        for (let i = 0; i < filtCells.length; i += 1) {
            if (this.isCellDeposit(filtCells[i])) {
                const maxWithdraw = await this.getDepositCellMaximumWithdraw(filtCells[i]);
                statistics.maximumWithdraw += maxWithdraw;
                const earliestSince = await this.getDepositDaoEarliestSince(filtCells[i]);
                if (!statistics.daoEarliestSince || statistics.daoEarliestSince > earliestSince) {
                    statistics.daoEarliestSince = earliestSince;
                }
            } else {
                const maxWithdraw = await this.getWithdrawCellMaximumWithdraw(filtCells[i]);
                statistics.maximumWithdraw += maxWithdraw;
                const earliestSince = await this.getWithdrawDaoEarliestSince(filtCells[i]);
                if (!statistics.daoEarliestSince || statistics.daoEarliestSince > earliestSince) {
                    statistics.daoEarliestSince = earliestSince;
                }
            }
        }
        this.logger.info(since.parseSince("0x20070801d300112e"));

        return statistics;
    }

    async getDepositCellMaximumWithdraw(depositCell: Cell): Promise<bigint> {
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositCell.block_hash);
        const withdrawBlockHeader = await this.connection.getCurrentBlockHeader();

        return dao.calculateMaximumWithdraw(depositCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
    }

    async getWithdrawCellMaximumWithdraw(withdrawCell: Cell): Promise<bigint> {
        const withdrawBlockHeader = await this.connection.getBlockHeaderFromHash(withdrawCell.block_hash);
        const { txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return dao.calculateMaximumWithdraw(withdrawCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
    }

    async getDepositDaoEarliestSince(depositCell: Cell): Promise<bigint> {
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositCell.block_hash);
        const withdrawBlockHeader = await this.connection.getCurrentBlockHeader();

        return dao.calculateDaoEarliestSince(depositBlockHeader.epoch, withdrawBlockHeader.epoch);
    }

    async getWithdrawDaoEarliestSince(withdrawCell: Cell): Promise<bigint> {
        const withdrawBlockHeader = await this.connection.getBlockHeaderFromHash(withdrawCell.block_hash);
        const { txHash } = await this.findCorrectInputFromWithdrawCell(withdrawCell);
        const depositTransaction = await this.connection.getTransactionFromHash(txHash);
        const depositBlockHeader = await this.connection.getBlockHeaderFromHash(depositTransaction.tx_status.block_hash);

        return dao.calculateDaoEarliestSince(depositBlockHeader.epoch, withdrawBlockHeader.epoch);
    }

    async getUnlockableAmounts(address: string): Promise<DAOUnlockableAmount[]> {
        const cells = await this.getCells(address);
        return this.getUnlockableAmountsFromCells(cells);
    }

    async getUnlockableAmountsFromCells(cells: Cell[]): Promise<DAOUnlockableAmount[]> {
        const unlockableAmounts: DAOUnlockableAmount[] = [];
        const filtCells = await this.filterDAOCells(cells);
        const currentBlockHeader = await this.connection.getCurrentBlockHeader();
        const currentEpoch = since.parseEpoch(currentBlockHeader.epoch);

        for (let i = 0; i < filtCells.length; i += 1) {
            const unlockableAmount: DAOUnlockableAmount = {
                amount: BigInt(filtCells[i].cell_output.capacity),
                compensation: BigInt(0),
                unlockable: true,
                remainingCycleMinutes: 0,
                type: "withdraw",
                txHash: filtCells[i].out_point.tx_hash,
                remainingEpochs: 0,
            };
            let maxWithdraw = BigInt(0);
            let earliestSince: since.EpochSinceValue;

            if (this.isCellDeposit(filtCells[i])) {
                unlockableAmount.type = "deposit";
                maxWithdraw = await this.getDepositCellMaximumWithdraw(filtCells[i]);
                const sinceBI = await this.getDepositDaoEarliestSince(filtCells[i]);
                earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());
            } else {
                maxWithdraw = await this.getWithdrawCellMaximumWithdraw(filtCells[i]);
                const sinceBI = await this.getWithdrawDaoEarliestSince(filtCells[i]);
                earliestSince = since.parseAbsoluteEpochSince(sinceBI.toString());
            }

            const remainingEpochs = earliestSince.number - currentEpoch.number;
            unlockableAmount.compensation = maxWithdraw - unlockableAmount.amount;
            if (remainingEpochs === 0) {
                unlockableAmount.remainingEpochs = 0;
                const remainingBlocks = earliestSince.index - currentEpoch.index;
                if (remainingBlocks <= 0) {
                    unlockableAmount.remainingCycleMinutes = 0;
                } else {
                    unlockableAmount.remainingCycleMinutes = (remainingBlocks * this.blockTime) / 60;
                }
            } else if (remainingEpochs < 0) {
                unlockableAmount.remainingEpochs = 0;
                unlockableAmount.remainingCycleMinutes = 0;
            } else {
                unlockableAmount.remainingEpochs = remainingEpochs;
                let remainingBlocks = currentEpoch.length - currentEpoch.index;
                remainingBlocks += (remainingEpochs - 1) * currentEpoch.length;
                remainingBlocks += earliestSince.index;
                unlockableAmount.remainingCycleMinutes = (remainingBlocks * this.blockTime) / 60;
            }
            unlockableAmount.unlockable =
                currentEpoch.number > earliestSince.number ||
                (currentEpoch.number === earliestSince.number && currentEpoch.index >= earliestSince.index);
            unlockableAmounts.push(unlockableAmount);
        }

        return unlockableAmounts;
    }
}

'''
'''--- src/core/transaction.service.ts ---
import { ScriptConfig } from "@ckb-lumos/config-manager";
import { Cell, commons, hd, Script, utils } from "@ckb-lumos/lumos";
import { sealTransaction, TransactionSkeletonType } from "@ckb-lumos/helpers";
import { TransactionWithStatus, values, core, WitnessArgs } from "@ckb-lumos/base";
import { TransactionCollector as TxCollector } from "@ckb-lumos/ckb-indexer";
import { Reader, normalizers } from "@ckb-lumos/toolkit";
import { CKBIndexerQueryOptions } from "@ckb-lumos/ckb-indexer/src/type";
import { ConnectionService } from "./connection.service";
import { Logger } from "../utils/logger";
import { NftService } from "./assets/nft.service";

const { ScriptValue } = values;

export interface ScriptType {
    args: string;
    codeHash: string;
    hashType: string;
}

export interface DataRow {
    quantity: number;
    address: string;
    type?: ScriptType;
    data?: number;
}

export interface Transaction {
    status: TransactionStatus;
    transactionHash: string;
    inputs: DataRow[];
    outputs: DataRow[];
    type: TransactionType;
    scriptType?: ScriptType;
    amount: number;
    blockHash?: string;
    blockNumber?: number;
    timestamp?: Date;
}

export enum TransactionStatus {
    PENDING = "pending",
    PROPOSED = "proposed",
    COMMITTED = "committed",
    REJECTED = "rejected",
}

export enum TransactionType {
    SEND_CKB = "send_ckb",
    RECEIVE_CKB = "receive_ckb",
    SEND_TOKEN = "send_token",
    RECEIVE_TOKEN = "receive_token",
    SEND_NFT = "send_nft",
    RECEIVE_NFT = "receive_nft",
    DEPOSIT_DAO = "deposit_dao",
    WITHDRAW_DAO = "withdraw_dao",
    UNLOCK_DAO = "unlock_dao",
    SMART_CONTRACT_SEND = "smart_contract_send",
    SMART_CONTRACT_RECEIVE = "smart_contract_receive",
}

export enum FeeRate {
    SLOW = 1000,
    NORMAL = 100000,
    FAST = 10000000,
}

export class TransactionService {
    private readonly connection: ConnectionService;
    private readonly nftService: NftService;
    private readonly TransactionCollector: any;
    private readonly logger = new Logger(TransactionService.name);
    private readonly transactionMap = new Map<string, Transaction>();
    private readonly secpSignaturePlaceholder =
        "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    public readonly defaultFee = BigInt(100000);

    constructor(connectionService: ConnectionService, nftService: NftService) {
        this.connection = connectionService;
        this.nftService = nftService;
        this.TransactionCollector = TxCollector;
    }

    static addCellDep(txSkeleton: TransactionSkeletonType, scriptConfig: ScriptConfig): TransactionSkeletonType {
        return txSkeleton.update("cellDeps", (cellDeps) => {
            return cellDeps.push({
                out_point: {
                    tx_hash: scriptConfig.TX_HASH,
                    index: scriptConfig.INDEX,
                },
                dep_type: scriptConfig.DEP_TYPE,
            });
        });
    }

    static isScriptTypeScript(scriptType: ScriptType, scriptConfig: ScriptConfig): boolean {
        return scriptConfig.CODE_HASH === scriptType.codeHash && scriptConfig.HASH_TYPE === scriptType.hashType;
    }

    private getTransactionCollector(address: string, includeStatus = false, toBlock?: string, fromBlock?: string): any {
        const queryOptions: CKBIndexerQueryOptions = { lock: this.connection.getLockFromAddress(address) };
        if (toBlock) {
            queryOptions.toBlock = toBlock;
        }
        if (fromBlock) {
            queryOptions.fromBlock = fromBlock;
        }

        return new this.TransactionCollector(this.connection.getIndexer(), queryOptions, this.connection.getCKBUrl(), { includeStatus });
    }

    async getTransactionFromLumosTx(lumosTx: TransactionWithStatus, address: string, allAddresses: string[]): Promise<Transaction> {
        const inputs: DataRow[] = [];
        const inputAddresses: string[] = [];
        let scriptType: ScriptType;
        let inputIndex = null;
        let amount = 0;
        let complexAmount = 0;
        let inputType = null;
        let isRealSender = false;
        for (let i = 0; i < lumosTx.transaction.inputs.length; i += 1) {
            const input = lumosTx.transaction.inputs[i];
            const transaction = await this.connection.getTransactionFromHash(input.previous_output.tx_hash);
            const output = transaction.transaction.outputs[parseInt(input.previous_output.index, 16)];
            const inputAddress = this.connection.getAddressFromLock(output.lock);
            inputs.push({
                quantity: parseInt(output.capacity, 16) / 100000000,
                address: this.connection.getAddressFromLock(output.lock),
            });
            if (allAddresses.includes(inputAddress)) {
                inputIndex = i;
                amount -= parseInt(output.capacity, 16) / 100000000;
                complexAmount -= parseInt(output.capacity, 16) / 100000000;
                inputAddresses.push(inputAddress);
                if (output.type) {
                    inputType = {
                        args: output.type.args,
                        codeHash: output.type.code_hash,
                        hashType: output.type.hash_type,
                    };
                }
            }
            if (address === inputAddress) {
                isRealSender = true;
            }
        }

        let outputIndex = null;
        let receiveAmount = 0;
        const outputs: DataRow[] = lumosTx.transaction.outputs.map((output, index) => {
            const outputAddress = this.connection.getAddressFromLock(output.lock);
            if (allAddresses.includes(outputAddress)) {
                amount += parseInt(output.capacity, 16) / 100000000;
                if (output.type) {
                    outputIndex = index;
                }
            }
            if (inputAddresses.includes(outputAddress)) {
                complexAmount += parseInt(output.capacity, 16) / 100000000;
            }
            if (address === outputAddress) {
                receiveAmount = parseInt(output.capacity, 16) / 100000000;
            }
            return {
                quantity: parseInt(output.capacity, 16) / 100000000,
                address: this.connection.getAddressFromLock(output.lock),
                type: output.type
                    ? { args: output.type.args, codeHash: output.type.code_hash, hashType: output.type.hash_type }
                    : undefined,
            };
        });
        lumosTx.transaction.outputs_data.map((data, index) => {
            if (data !== "0x") {
                if (data.length === 34) {
                    outputs[index].data = Number(utils.readBigUInt128LE(data));
                } else if (data.length === 18) {
                    outputs[index].data = Number(utils.readBigUInt64LE(data));
                }
            }
        });

        let type: TransactionType;
        const isReceive = inputIndex === null;
        if (inputType === null && outputIndex === null) {
            // If neither input or output has type then it is a simple ckb transaction
            if (Math.abs(amount) < 1) {
                // It is fee, same receiver and sender
                if (isRealSender) {
                    type = TransactionType.SEND_CKB;
                    amount = complexAmount;
                } else {
                    type = TransactionType.RECEIVE_CKB;
                    amount = receiveAmount;
                }
            } else {
                type = !isReceive ? TransactionType.SEND_CKB : TransactionType.RECEIVE_CKB;
            }
        } else if (outputIndex !== null) {
            const { type: outputType, data, quantity } = outputs[outputIndex];
            scriptType = outputType;
            if (TransactionService.isScriptTypeScript(scriptType, this.connection.getConfig().SCRIPTS.SUDT)) {
                type = !isReceive ? TransactionType.SEND_TOKEN : TransactionType.RECEIVE_TOKEN;
            } else if (TransactionService.isScriptTypeScript(scriptType, this.connection.getConfig().SCRIPTS.DAO)) {
                if (data === 0) {
                    type = TransactionType.DEPOSIT_DAO;
                    amount = Math.abs(amount) < 1 ? -quantity : amount;
                } else {
                    type = TransactionType.WITHDRAW_DAO;
                    amount = Math.abs(amount) < 1 ? quantity : amount;
                }
            } else if (await this.nftService.isScriptNftScript(scriptType)) {
                type = !isReceive ? TransactionType.SEND_NFT : TransactionType.RECEIVE_NFT;
            } else {
                type = !isReceive ? TransactionType.SMART_CONTRACT_SEND : TransactionType.SMART_CONTRACT_RECEIVE;
            }
        } else {
            scriptType = inputType;
            type = TransactionType.UNLOCK_DAO;
        }

        const transaction: Transaction = {
            status: lumosTx.tx_status.status as TransactionStatus,
            transactionHash: lumosTx.transaction.hash,
            inputs,
            outputs,
            type: type,
            scriptType: scriptType,
            amount,
        };
        if (lumosTx.tx_status.block_hash) {
            const header = await this.connection.getBlockHeaderFromHash(lumosTx.tx_status.block_hash);
            transaction.blockHash = lumosTx.tx_status.block_hash;
            transaction.blockNumber = parseInt(header.number, 16);
            transaction.timestamp = new Date(parseInt(header.timestamp, 16));
        }

        return transaction;
    }

    addSecp256CellDep(txSkeleton: TransactionSkeletonType): TransactionSkeletonType {
        return TransactionService.addCellDep(txSkeleton, this.connection.getConfig().SCRIPTS.SECP256K1_BLAKE160);
    }

    injectCapacity(txSkeleton: TransactionSkeletonType, capacity: bigint, cells: Cell[]): TransactionSkeletonType {
        let lastScript: Script | undefined;
        let changeCell: Cell;
        let changeCapacity = BigInt(0);
        let currentAmount = BigInt(capacity);

        for (const cell of cells) {
            // Cell is empty
            if (!cell.cell_output.type) {
                txSkeleton = txSkeleton.update("inputs", (inputs) => inputs.push(cell));
                txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));

                const inputCapacity = BigInt(cell.cell_output.capacity);
                let deductCapacity = inputCapacity;
                if (deductCapacity > currentAmount) {
                    deductCapacity = currentAmount;
                }
                currentAmount -= deductCapacity;
                changeCapacity += inputCapacity - deductCapacity;

                const lockScript = cell.cell_output.lock;
                if (
                    !lastScript ||
                    lastScript.args !== lockScript.args ||
                    lastScript.code_hash !== lockScript.code_hash ||
                    lastScript.hash_type !== lockScript.hash_type
                ) {
                    txSkeleton = this.addWitnesses(txSkeleton, lockScript);
                    lastScript = lockScript;
                }

                // Got enough amount
                if (Number(currentAmount) === 0 && Number(changeCapacity) > 0) {
                    changeCell = {
                        cell_output: {
                            capacity: "0x" + changeCapacity.toString(16),
                            lock: cell.cell_output.lock,
                            type: undefined,
                        },
                        data: "0x",
                        out_point: undefined,
                        block_hash: undefined,
                    };
                    break;
                }
            }
        }

        if (changeCapacity > BigInt(0)) {
            txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        }

        return txSkeleton;
    }

    getScriptFirstIndex(txSkeleton: TransactionSkeletonType, fromScript: Script): number {
        return txSkeleton
            .get("inputs")
            .findIndex((input) =>
                new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })),
            );
    }

    addWitnesses(txSkeleton: TransactionSkeletonType, fromScript: Script): TransactionSkeletonType {
        // posar el index i from script
        const firstIndex = this.getScriptFirstIndex(txSkeleton, fromScript);

        if (firstIndex !== -1) {
            while (firstIndex >= txSkeleton.get("witnesses").size) {
                txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
            }

            let witness: string = txSkeleton.get("witnesses").get(firstIndex);
            const newWitnessArgs: WitnessArgs = { lock: this.secpSignaturePlaceholder };
            if (witness !== "0x") {
                const witnessArgs = new core.WitnessArgs(new Reader(witness));
                const lock = witnessArgs.getLock();
                if (lock.hasValue() && new Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                    throw new Error("Lock field in first witness is set aside for signature!");
                }

                const inputType = witnessArgs.getInputType();
                if (inputType.hasValue()) {
                    newWitnessArgs.input_type = new Reader(inputType.value().raw()).serializeJson();
                }
                const outputType = witnessArgs.getOutputType();
                if (outputType.hasValue()) {
                    newWitnessArgs.output_type = new Reader(outputType.value().raw()).serializeJson();
                }
            }
            witness = new Reader(core.SerializeWitnessArgs(normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
        }

        return txSkeleton;
    }

    extractPrivateKeys(txSkeleton: TransactionSkeletonType, fromAddresses: string[], privateKeys: string[]): string[] {
        const signingPrivKeys: string[] = [];

        for (let i = 0; i < fromAddresses.length; i += 1) {
            if (this.getScriptFirstIndex(txSkeleton, this.connection.getLockFromAddress(fromAddresses[i])) !== -1) {
                this.logger.info(i);
                signingPrivKeys.push(privateKeys[i]);
            }
        }

        return signingPrivKeys;
    }

    async addressHasTransactions(address: string, toBlock?: string, fromBlock?: string): Promise<boolean> {
        const transactionCollector = this.getTransactionCollector(address, false, toBlock, fromBlock);

        const txs = await transactionCollector.count();
        return txs > 0;
    }

    async getLumosTransactions(address: string, toBlock?: string, fromBlock?: string): Promise<TransactionWithStatus[]> {
        const transactionCollector = this.getTransactionCollector(address, true, toBlock, fromBlock);
        const transactions: TransactionWithStatus[] = [];

        for await (const lumosTx of transactionCollector.collect()) {
            transactions.push(lumosTx);
        }

        return transactions;
    }

    async getTransactions(address: string, allAddresses: string[], toBlock?: string, fromBlock?: string): Promise<Transaction[]> {
        const transactionCollector = this.getTransactionCollector(address, true, toBlock, fromBlock);
        const transactions: Transaction[] = [];
        let lumosTx: TransactionWithStatus;

        for await (lumosTx of transactionCollector.collect()) {
            const key = `${address}-${lumosTx.transaction.hash}`;
            if (!this.transactionMap.has(key)) {
                const transaction = await this.getTransactionFromLumosTx(lumosTx, address, allAddresses);
                this.transactionMap.set(key, transaction);
            }

            const transaction = this.transactionMap.get(key);
            if (!transactions.includes(transaction)) {
                transactions.push(transaction);
            }
        }

        return transactions;
    }

    async getTransactionFromHash(txHash: string, addresses: string[]): Promise<Transaction> {
        const transaction = await this.connection.getTransactionFromHash(txHash, false);
        return this.getTransactionFromLumosTx(transaction, addresses[addresses.length - 1], addresses);
    }

    async signTransaction(txSkeleton: TransactionSkeletonType, privateKeys: string[]): Promise<string> {
        const txSkeletonWEntries = commons.common.prepareSigningEntries(txSkeleton, this.connection.getConfigAsObject());
        if (privateKeys.length !== txSkeletonWEntries.get("signingEntries").count()) {
            this.logger.error("Invalid private keys length");
            throw new Error("Invalid private keys length");
        }

        const signatures = [];
        for (let i = 0; i < privateKeys.length; i += 1) {
            const entry = txSkeletonWEntries.get("signingEntries").get(i);
            signatures.push(hd.key.signRecoverable(entry.message, privateKeys[i]));
        }
        const tx = sealTransaction(txSkeletonWEntries, signatures);
        const hash = await this.connection.getRPC().send_transaction(tx, "passthrough");

        return hash;
    }
}

'''
'''--- src/core/wallet.service.ts ---
import { mnemonic, ExtendedPrivateKey, AccountExtendedPublicKey, AddressType } from "@ckb-lumos/hd";
import { TransactionWithStatus } from "@ckb-lumos/base";
import { ConnectionService } from "./connection.service";
import { TransactionService, Transaction, FeeRate } from "./transaction.service";
import { TokenService, TokenAmount } from "./assets/token.service";
import { CKBBalance, CKBService } from "./assets/ckb.service";
import { DAOBalance, DAOService, DAOStatistics, DAOUnlockableAmount } from "./dao/dao.service";
import { Cell, Script } from "@ckb-lumos/lumos";
import { QueryOptions } from "@ckb-lumos/base";
import { Nft, NftService } from "./assets/nft.service";
import { Logger } from "../utils/logger";

export { AddressType };

export enum AddressScriptType {
    SECP256K1_BLAKE160 = "SECP256K1_BLAKE160",
    SUDT = "SUDT",
    DAO = "DAO",
}

export interface Balance {
    ckb: CKBBalance;
    tokens: TokenAmount[];
    nfts: Nft[];
    dao: DAOBalance;
}

export interface addressMapI {
    [key: string]: string;
}

export interface cellMapI {
    [key: string]: Cell[];
}

export interface transactionMapI {
    [key: string]: Transaction[];
}

export interface WalletState {
    addressMap: addressMapI;
    firstRIndexWithoutTxs: number;
    firstCIndexWithoutTxs: number;
    lastHashBlock: string;
    accountCellsMap: cellMapI;
    accountTransactionMap: transactionMapI;
}

export class WalletService {
    private readonly connection: ConnectionService;
    private readonly transactionService: TransactionService;
    private readonly ckbService: CKBService;
    private readonly tokenService: TokenService;
    private readonly daoService: DAOService;
    private readonly nftService: NftService;
    private readonly accountPublicKey: AccountExtendedPublicKey;
    private readonly logger = new Logger(WalletService.name);
    private addressMap: addressMapI = {};
    private firstRIndexWithoutTxs = 0;
    private firstCIndexWithoutTxs = 0;
    private lastHashBlock!: string;
    private accountCellsMap: cellMapI = {};
    private accountTransactionMap: transactionMapI = {};
    private onSync!: (walletState: WalletState) => Promise<void>;
    private onSyncStart!: () => void;
    private synchronizing = false;

    // The connectionService and a mnemonic are mandatory
    // walletState is useful if you will close the instance and want to sync from a given state
    // onSync method is called when sync finished. Useful to persist current state
    // onSyncStart is called when a synchronization start
    // It throws an error when mnemonic is invalid
    constructor(
        connectionService: ConnectionService,
        mnemo: string,
        walletState?: WalletState,
        onSync?: (walletState: WalletState) => Promise<void>,
        onSyncStart?: () => void,
    ) {
        if (!WalletService.validateMnemonic(mnemo)) {
            this.logger.error("Invalid Mnemonic");
            throw new Error("Invalid Mnemonic");
        }

        this.connection = connectionService;
        this.nftService = new NftService(this.connection);
        this.transactionService = new TransactionService(this.connection, this.nftService);
        this.ckbService = new CKBService(this.connection, this.transactionService);
        this.tokenService = new TokenService(this.connection, this.transactionService);
        this.daoService = new DAOService(this.connection, this.transactionService);

        if (walletState) {
            this.addressMap = walletState.addressMap ? { ...walletState.addressMap } : this.addressMap;
            this.firstRIndexWithoutTxs = walletState.firstRIndexWithoutTxs || 0;
            this.firstCIndexWithoutTxs = walletState.firstCIndexWithoutTxs || 0;
            this.lastHashBlock = walletState.lastHashBlock || null;
            this.accountCellsMap = walletState.accountCellsMap ? { ...walletState.accountCellsMap } : this.accountCellsMap;
            this.accountTransactionMap = walletState.accountTransactionMap
                ? { ...walletState.accountTransactionMap }
                : this.accountTransactionMap;
        }

        if (onSync) {
            this.onSync = onSync;
        }
        if (onSyncStart) {
            this.onSyncStart = onSyncStart;
        }

        this.accountPublicKey = WalletService.getPrivateKeyFromMnemonic(mnemo).toAccountExtendedPublicKey();
    }

    // Creates a new mnemonic
    static createNewMnemonic(): string {
        return mnemonic.generateMnemonic();
    }

    // Validates a mnemonic
    static validateMnemonic(mnemo: string): boolean {
        return mnemonic.validateMnemonic(mnemo);
    }

    private static getPrivateKeyFromMnemonic(mnemo: string): ExtendedPrivateKey {
        const seed = mnemonic.mnemonicToSeedSync(mnemo);
        return ExtendedPrivateKey.fromSeed(seed);
    }

    // ----------------------
    // -- Wallet functions --
    // ----------------------

    // Gets current wallet state
    getWalletState(): WalletState {
        return {
            addressMap: { ...this.addressMap },
            firstRIndexWithoutTxs: this.firstRIndexWithoutTxs,
            firstCIndexWithoutTxs: this.firstCIndexWithoutTxs,
            lastHashBlock: this.lastHashBlock,
            accountCellsMap: { ...this.accountCellsMap },
            accountTransactionMap: { ...this.accountTransactionMap },
        };
    }

    // Synchronizes and returns new wallet state
    // Calls onSyncStart at start and and onSync when finishes
    async synchronize(): Promise<WalletState> {
        if (this.synchronizing) return this.getWalletState();
        this.synchronizing = true;
        if (this.onSyncStart) this.onSyncStart();
        let toBlock: string;
        let fromBlock: string;
        const currentBlock = await this.connection.getCurrentBlockHeader();

        if (!this.lastHashBlock) {
            toBlock = currentBlock.number;
        } else {
            fromBlock = this.lastHashBlock;
            toBlock = currentBlock.number;
        }

        const cellProvider = this.connection.getCellProvider({ toBlock });
        const addressTypes: AddressType[] = [AddressType.Receiving, AddressType.Change];
        const keysArr: string[] = [];
        const addressesArr: string[] = [];
        const lumosTxsArr: TransactionWithStatus[][] = [];

        for (const addressType of addressTypes) {
            let currentIndex = 0;
            let firstIndex = addressType === AddressType.Receiving ? this.firstRIndexWithoutTxs : this.firstCIndexWithoutTxs;

            while (currentIndex <= firstIndex) {
                const address = this.getAddress(currentIndex, addressType as AddressType);
                const lumosTxs = await this.transactionService.getLumosTransactions(address, toBlock, fromBlock);

                if (lumosTxs.length > 0) {
                    const lock = this.getLock(currentIndex, addressType as AddressType);
                    const mapKey = `${addressType}-${currentIndex}`;
                    keysArr.push(mapKey);
                    addressesArr.push(address);
                    lumosTxsArr.push(lumosTxs);

                    // Update cells
                    const newCells: Cell[] = [];
                    const collectorOptions: QueryOptions = { lock, toBlock };
                    const cellCollector = cellProvider.collector(collectorOptions);
                    for await (const cell of cellCollector.collect()) {
                        newCells.push(cell);
                    }
                    this.accountCellsMap[mapKey] = newCells;

                    // Update indexes
                    if (currentIndex === firstIndex) {
                        firstIndex += 1;
                    }
                }
                currentIndex += 1;
            }
            if (addressType === AddressType.Receiving) {
                this.firstRIndexWithoutTxs = firstIndex;
            } else {
                this.firstCIndexWithoutTxs = firstIndex;
            }
        }

        const allAddresses = this.getAllAddresses();
        for (let i = 0; i < keysArr.length && i < lumosTxsArr.length && i < addressesArr.length; i += 1) {
            const address = addressesArr[i];
            const promises = lumosTxsArr[i].map((tx) => this.transactionService.getTransactionFromLumosTx(tx, address, allAddresses));
            const transactions = await Promise.all(promises);

            // Update transactions
            const currentTxs: Transaction[] = this.accountTransactionMap[keysArr[i]] || [];
            this.accountTransactionMap[keysArr[i]] = [...currentTxs, ...transactions];
        }

        this.lastHashBlock = currentBlock.number;

        const walletState = this.getWalletState();
        if (this.onSync) {
            await this.onSync(walletState);
        }
        this.synchronizing = false;

        return walletState;
    }

    getCells(): Cell[] {
        return [...Object.values(this.accountCellsMap)].flat(1);
    }

    // Returns next receive address without any transactions
    getNextAddress(): string {
        return this.getAddress(this.firstRIndexWithoutTxs, AddressType.Receiving);
    }

    getAccountIndexes(addressType: AddressType = AddressType.Receiving): number[] {
        if (addressType === AddressType.Receiving) {
            return [...Array(this.firstRIndexWithoutTxs).keys()];
        }
        return [...Array(this.firstCIndexWithoutTxs).keys()];
    }

    // Gets lock from a specific accountId, addressType and script type
    getLock(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): Script {
        const template = this.connection.getConfig().SCRIPTS[script];
        const lockScript = {
            code_hash: template.CODE_HASH,
            hash_type: template.HASH_TYPE,
            args: this.accountPublicKey.publicKeyInfo(addressType, accountId).blake160,
        };

        return lockScript;
    }

    // Gets address from a specific accountId, addressType and script type
    getAddress(accountId = 0, addressType: AddressType, script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160): string {
        const key = `${accountId}-${addressType}-${script}`;
        if (!this.addressMap[key]) {
            const address = this.connection.getAddressFromLock(this.getLock(accountId, addressType, script));
            this.addressMap[key] = address;
        }

        return this.addressMap[key];
    }

    // Gets all addresses with at least one transactions
    getAllAddresses(): string[] {
        const addresses = [];
        for (let i = 0; i < this.firstRIndexWithoutTxs; i += 1) {
            addresses.push(this.getAddress(i, AddressType.Receiving));
        }
        for (let i = 0; i < this.firstCIndexWithoutTxs; i += 1) {
            addresses.push(this.getAddress(i, AddressType.Change));
        }

        return addresses;
    }

    getAllPrivateKeys(mnemo: string): string[] {
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const privateKeys = [];
        for (let i = 0; i < this.firstRIndexWithoutTxs; i += 1) {
            privateKeys.push(extPrivateKey.privateKeyInfo(AddressType.Receiving, i).privateKey);
        }
        for (let i = 0; i < this.firstCIndexWithoutTxs; i += 1) {
            privateKeys.push(extPrivateKey.privateKeyInfo(AddressType.Change, i).privateKey);
        }

        return privateKeys;
    }

    getAddressAndPrivateKey(
        mnemo: string,
        accountId = 0,
        script: AddressScriptType = AddressScriptType.SECP256K1_BLAKE160,
    ): { address: string; privateKey: string } {
        const address = this.getAddress(accountId, AddressType.Receiving, script);
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const privateKey = extPrivateKey.privateKeyInfo(AddressType.Receiving, accountId).privateKey;

        return { address, privateKey };
    }

    getAddressAndPrivKeyFromLock(mnemo: string, lock: Script): { address: string; privateKey: string } {
        const address = this.connection.getAddressFromLock(lock);
        const extPrivateKey = WalletService.getPrivateKeyFromMnemonic(mnemo);
        const addresses = this.getAllAddresses();

        let privateKey: string;
        if (addresses.indexOf(address) < this.firstRIndexWithoutTxs) {
            ({ privateKey } = extPrivateKey.privateKeyInfo(AddressType.Receiving, addresses.indexOf(address)));
        } else {
            ({ privateKey } = extPrivateKey.privateKeyInfo(AddressType.Change, addresses.indexOf(address) - this.firstRIndexWithoutTxs));
        }

        return { address, privateKey };
    }

    // Gets balance from a single account
    async getBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Balance> {
        const address = this.getAddress(accountId, addressType);
        const ckb = await this.ckbService.getBalance(address);
        const tokens = await this.tokenService.getBalance(address);
        const nfts = await this.nftService.getBalance(address);
        const dao = await this.daoService.getBalance(address);

        return { ckb, tokens, dao, nfts };
    }

    // Gets wallet total balance
    async getBalance(): Promise<Balance> {
        const cells = this.getCells();
        const ckb = this.ckbService.getBalanceFromCells(cells);
        const tokens = this.tokenService.getBalanceFromCells(cells);
        const nfts = await this.nftService.getBalanceFromCells(cells);
        const dao = await this.daoService.getBalanceFromCells(cells);

        return { ckb, tokens, dao, nfts };
    }

    // -----------------------------------
    // -- Transaction service functions --
    // -----------------------------------

    // Gets all transactions from a single account
    async getTransactionsFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Transaction[]> {
        const address = this.getAddress(accountId, addressType);

        return this.transactionService.getTransactions(address, this.getAllAddresses());
    }

    // Gets all transactions of the wallet
    getTransactions(): Transaction[] {
        const sortedTxs = [...Object.values(this.accountTransactionMap)].flat(1).sort((txa, txb) => txa.blockNumber - txb.blockNumber);

        // Remove equal transactions
        for (let i = 0; i < sortedTxs.length; i += 1) {
            let j = i + 1;

            while (j < sortedTxs.length) {
                if (sortedTxs[i].transactionHash === sortedTxs[j].transactionHash && sortedTxs[i].type === sortedTxs[j].type) {
                    sortedTxs.splice(j, 1);
                } else {
                    j += 1;
                }
            }
        }

        return sortedTxs;
    }

    // Get a transaction from hash
    // Useful from uncommitted transactions
    async getTransactionFromHash(txHash: string): Promise<Transaction> {
        return this.transactionService.getTransactionFromHash(txHash, [...this.getAllAddresses(), this.getNextAddress()]);
    }

    // ---------------------------
    // -- CKB service functions --
    // ---------------------------

    // Sends a transaction from a single account
    // Returns the transaction hash
    async sendTransactionSingleAccount(
        amount: bigint,
        mnemo: string,
        to: string,
        accountId: number,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);
        await this.synchronize();

        return this.ckbService.transfer(address, to, amount, privateKey, feeRate);
    }

    // Sends a transaction from all the accounts in the wallet
    // Returns the transaction hash
    async sendTransaction(amount: bigint, mnemo: string, to: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const addresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);

        return this.ckbService.transferFromCells(this.getCells(), addresses, to, amount, privateKeys, feeRate);
    }

    // Gets the ckb balance of a single account
    async getCKBBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<CKBBalance> {
        const address = this.getAddress(accountId, addressType);
        return this.ckbService.getBalance(address);
    }

    // Get the ckb balance of the wallet
    // Should be synchronized first
    getCKBBalance(): CKBBalance {
        return this.ckbService.getBalanceFromCells(this.getCells());
    }

    // -----------------------------
    // -- Token service functions --
    // -----------------------------

    // Deprecated in accounts
    // Issue a new token from a specific account
    // Returns transaction hash
    async issueTokens(amount: number, mnemo: string, accountId = 0, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);

        return this.tokenService.issue(address, amount, privateKey, feeRate);
    }

    // Deprecated in accounts
    // Transfer a token with where its type has args token (4th param)
    // Amount is the number of token to transfer. Minumum cell size required.
    // Returns transaction hash
    async transferTokens(
        amount: number,
        mnemo: string,
        to: string,
        token: string,
        accountId = 0,
        feeRate: FeeRate = FeeRate.NORMAL,
    ): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);

        return this.tokenService.transfer(address, to, token, amount, privateKey, feeRate);
    }

    // Gets the token balance from a single account
    async getTokensBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<TokenAmount[]> {
        const address = this.getAddress(accountId, addressType);
        return this.tokenService.getBalance(address);
    }

    // Get the token balance of the whole wallet
    // Should be synchronized first
    getTokensBalance(): TokenAmount[] {
        return this.tokenService.getBalanceFromCells(this.getCells());
    }

    // -----------------------------
    // -- Nft service functions --
    // -----------------------------

    // Gets all nfts from a single account
    async getNftsBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<Nft[]> {
        const address = this.getAddress(accountId, addressType);
        return this.nftService.getBalance(address);
    }

    // Gets the nfts from the whole wallet
    // Should be synchronized first
    async getNftsBalance(): Promise<Nft[]> {
        return this.nftService.getBalanceFromCells(this.getCells());
    }

    // ---------------------------
    // -- DAO service functions --
    // ---------------------------

    // Deposits in the DAO from a single account
    // Returns the hash of the transaction
    async depositInDAOSingleAccount(amount: bigint, mnemo: string, accountId = 0, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivateKey(mnemo, accountId);
        return this.daoService.deposit(amount, address, address, privateKey, feeRate);
    }

    // Deposits in DAO from all the accounts with enough balance
    // Returns the hash of the transaction
    async depositInDAO(amount: bigint, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const addresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);

        return this.daoService.depositMultiAccount(amount, this.getCells(), addresses, this.getNextAddress(), privateKeys, feeRate);
    }

    private async withdrawOrUnlockFromCell(cell: Cell, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        const { address, privateKey } = this.getAddressAndPrivKeyFromLock(mnemo, cell.cell_output.lock);
        const feeAddresses = this.getAllAddresses();
        const privateKeys = this.getAllPrivateKeys(mnemo);
        const to = this.getNextAddress();

        if (!this.daoService.isCellDeposit(cell)) {
            this.logger.info("Unlocking withdraw cell");

            // Check real unlockability
            if (!(await this.daoService.isCellUnlockable(cell))) {
                throw new Error("Cell can not yet be unlocked.");
            }
            return this.daoService.unlock(cell, privateKey, address, to, feeAddresses, privateKeys, feeRate);
        }

        this.logger.info("Withdrawing deposit cell");
        return this.daoService.withdraw(cell, privateKey, feeAddresses, privateKeys, feeRate);
    }

    // Gets DAO unlockable amounts from a single account
    async getDAOUnlockableAmountsFromAccount(
        accountId = 0,
        addressType: AddressType = AddressType.Receiving,
    ): Promise<DAOUnlockableAmount[]> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getUnlockableAmounts(address);
    }

    // Gets DAO unlockable amounts from the whole wallet
    // Should be synchronized first
    async getDAOUnlockableAmounts(): Promise<DAOUnlockableAmount[]> {
        return this.daoService.getUnlockableAmountsFromCells(this.getCells());
    }

    // Withdraws or unlocks an unlockable amount
    // Returns the hash of the transaction
    async withdrawOrUnlock(unlockableAmount: DAOUnlockableAmount, mnemo: string, feeRate: FeeRate = FeeRate.NORMAL): Promise<string> {
        await this.synchronize();
        const cells = await this.daoService.filterDAOCells(this.getCells());

        const cell = await this.daoService.findCellFromUnlockableAmountAndCells(unlockableAmount, cells);
        if (!cell) {
            throw new Error("Cell related to unlockable amount not found!");
        }
        this.logger.info(cell);
        return this.withdrawOrUnlockFromCell(cell, mnemo, feeRate);
    }

    // Gets DAO statistic from a single account
    async getDAOStatisticsFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<DAOStatistics> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getStatistics(address);
    }

    // Gets DAO statistic from the whole wallet
    // Should be synchronized first
    async getDAOStatistics(): Promise<DAOStatistics> {
        return this.daoService.getStatisticsFromCells(this.getCells());
    }

    // Get DAO balance from a single account
    async getDAOBalanceFromAccount(accountId = 0, addressType: AddressType = AddressType.Receiving): Promise<DAOBalance> {
        const address = this.getAddress(accountId, addressType);
        return this.daoService.getBalance(address);
    }

    // Get DAO balance from the whole wallet
    // Should be synchronized first
    async getDAOBalance(): Promise<DAOBalance> {
        return this.daoService.getBalanceFromCells(this.getCells());
    }
}

'''
'''--- src/index.ts ---
export * from "./core/connection.service";
export * from "./core/wallet.service";
export * from "./core/transaction.service";
export * from "./core/assets/ckb.service";
export * from "./core/assets/token.service";
export * from "./core/assets/nft.service";
export * from "./core/assets/nft.types";
export * from "./core/dao/dao.service";
export * from "./utils/logger";

'''
'''--- src/utils/logger.ts ---
/* eslint-disable no-console */
export enum LoggingLevel {
    DEBUG = "debug",
    INFO = "info",
    WARN = "warn",
    ERROR = "error",
}

export class Logger {
    private readonly name: string;
    private readonly loggingLevel: LoggingLevel;

    // In the constructor we can pass a name that will always be added in the log
    // and a logging level to choose which level of logs you want to be logged.
    // If you choose logging level WARN only logger.warn and logger.error will be logged
    constructor(name = "", loggingLevel: LoggingLevel = LoggingLevel.INFO) {
        this.name = name;
        this.loggingLevel = loggingLevel;
    }

    // Sends a message to standard output with tag debug
    static debug(message: any, name = ""): void {
        console.debug(`${name}[debug] >> `, message);
    }

    // Sends a message to standard output with tag debug if logging level DEBUG or greater
    debug(message: any): void {
        if (this.loggingLevel === LoggingLevel.DEBUG) {
            Logger.debug(message, this.name);
        }
    }

    // Sends a message to standard output with tag info
    static info(message: any, name = ""): void {
        console.info(`${name}[info] >> `, message);
    }

    // Sends a message to standard output with tag info if logging level INFO or greater
    info(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO].includes(this.loggingLevel)) {
            Logger.info(message, this.name);
        }
    }

    // Sends a message to standard output with tag log
    static log(message: any, name = ""): void {
        console.log(`${name}[log] >> `, message);
    }

    // Sends a message to standard output with tag log if logging level INFO or greater
    log(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO].includes(this.loggingLevel)) {
            Logger.log(message, this.name);
        }
    }

    // Sends a message to standard error output with tag warn
    static warn(message: any, name = ""): void {
        console.warn(`${name}[warn] >> `, message);
    }

    // Sends a message to standard error output with tag warn if logging level WARN or greater
    warn(message: any): void {
        if ([LoggingLevel.DEBUG, LoggingLevel.INFO, LoggingLevel.WARN].includes(this.loggingLevel)) {
            Logger.warn(message, this.name);
        }
    }

    // Sends a message to standard error output with tag error
    static error(message: any, name = ""): void {
        console.error(`${name}[error] >> `, message);
    }

    // Sends a message to standard error output with tag error if logging level ERROR
    error(message: any): void {
        Logger.error(message, this.name);
    }
}

'''
'''--- tsconfig.build.json ---
{
    "extends": "./tsconfig.json",
    "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "module": "commonjs",
        "declaration": true,
        "removeComments": true,
        "emitDecoratorMetadata": true,
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true,
        "resolveJsonModule": true,
        "target": "es2016",
        "moduleResolution": "node",
        "sourceMap": true,
        "outDir": "./dist",
        "baseUrl": "./",
        "incremental": true,
        "skipLibCheck": true
    },
    "include": ["src/**/*", "test/**/*.spec.ts"]
}

'''