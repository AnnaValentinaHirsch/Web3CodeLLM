*GitHub Repository "PotLock/nadabot-docs"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
---
description: use nada.bot (the NEAR contract based bot protection protocol
---

# üìç Start Here

[Nada.bot](http://nada.bot) is a NEAR Protocol-based smart contract based sybil resistance aggregator that safeguards web3 communities and applications from malicious actors.

Try the [app here ](https://app.nada.bot)

We are looking to create a trusted and inclusive web3 environment by eliminating sybil attacks and fostering genuine human interactions.

## Core Values

* **Transparency**: all checks and decisions are made on chain
* **Adaptability**: flexible scores and weights to prevent against sybil attacks
* **Adoption / Integration**: become widely adopted and a resource to applications with a vibrant ecosystem
* **Composability:** allow for other identity players to integrate and build with us easily and vice versa

## Stakeholders

* **üôãüèΩ‚Äç‚ôÇÔ∏è Users:** verify checks, confirm on nada.bot registry, earn points, get verified as human
* **‚úÖ Sybil providers:** add additional checks to get users to verify with you service
* **üì≤ Applications / Protocols:** integrate our contract via cross contract call to enforce bot protection

{% content-ref url="guides/for-users.md" %}
[for-users.md](guides/for-users.md)
{% endcontent-ref %}

{% content-ref url="guides/for-sybil-providers.md" %}
[for-sybil-providers.md](guides/for-sybil-providers.md)
{% endcontent-ref %}

{% content-ref url="guides/for-applications.md" %}
[for-applications.md](guides/for-applications.md)
{% endcontent-ref %}

Extra Stakeholders

* **üëî Admin** (in future DAO): approve checks, sets weights, flag weights, readjust human threshold
* **ü¶πüèΩ Developers / Bot Defense League:** get rewarded for developing tools to prevent and detect bots
* **ü§ñ Bots:** get caught, displaced, incarcerated, torn away from their families and generationally disenfranchised&#x20;

## For Builders / Providers

Want to integrate. in you application or get you stamp/check integrated into our registry?&#x20;

{% content-ref url="guides/for-sybil-providers.md" %}
[for-sybil-providers.md](guides/for-sybil-providers.md)
{% endcontent-ref %}

{% content-ref url="extra/our-contract.md" %}
[our-contract.md](extra/our-contract.md)
{% endcontent-ref %}

{% content-ref url="guides/for-applications.md" %}
[for-applications.md](guides/for-applications.md)
{% endcontent-ref %}

## Case Studies

Applications That Have Integrated nada.bot

* [**Potlock**](https://potlock.org): public goods funding on NEAR, used for sybil protection for quadratic funding
* [**Cplanet**](https://cplanet.org) Contests: art submission and funding platform, used to configure voting to delegate art contest for

Sybil Providers that are part of registry

* [I-AM-Human](https://i-am-human.app): aloow us to use liveness checks (face scans) via Fractal&#x20;
* [Shard.dog](https://shard.dog): allow us to choose active users and provide bot protection service for claims

{% content-ref url="extra/glossary.md" %}
[glossary.md](extra/glossary.md)
{% endcontent-ref %}

## Socials

* Nada.bot Twitter [https://nada.bot/twitter](https://nada.bot/twitter)
* Nada.bot Linkedin [https://nada.bot/linkedin](https://nada.bot/linkedin)
* Nada.bot on PotLock: [https://nada.bot/potlock](https://nada.bot/potlock)
* Nada.bot Support [https://nada.bot/support](https://nada.bot/support)

'''
'''--- SUMMARY.md ---
# Table of contents

* [üìç Start Here](README.md)

## üìñ Guides

* [üë®üíº For Users](guides/for-users.md)
* [‚úÖ For Sybil Providers](guides/for-sybil-providers.md)
* [üì± For Applications](guides/for-applications.md)
* [ü§ñ For Bots](guides/for-bots.md)
* [üëî For Admins](guides/for-admins.md)

## Extra

* [üõ† \[Devs\] Prod, Staging, Testnet](extra/devs-prod-staging-testnet.md)
* [üìÉ Our Contract](extra/our-contract.md)
* [üîÆ Future](extra/future.md)
* [üìö Glossary](extra/glossary.md)

***

* [‚Åâ Support](support.md)

'''
'''--- extra/devs-prod-staging-testnet.md ---
---
description: >-
  For developers looking to work in our testnet, staging, and production
  environments.
---

# üõ† \[Devs] Prod, Staging, Testnet

## App

Production (live for public) [https://app.nada.bot](https://app.nada.bot)

Staging (mainnnet testing) [https://staging.nada.bot](https://staging.nada.bot)

Testnet (NEAR testnet) [https://testnet.nada.bot](https://testnet.nada.bot)

## Contracts

Mainnet [v1.nadabot.near](https://nearblocks.io/address/v1.nadabot.near)

Staging [v1.staging.nadabot.near](https://nearblocks.io/address/v1.staging.nadabot.near)

Testnet [v1.nadabot.testnet](https://testnet.nearblocks.io/address/v1.nadabot.testnet)

## Repo

{% embed url="https://github.com/PotLock/nadabot-app/" %}

## Looking to Contribute

Check out at public backlog at [https://nada.bot/backlog ](https://nada.bot/backlog)

'''
'''--- extra/future.md ---
---
description: What's in store for nada bot
---

# üîÆ Future

While we have many plans to align incentives between sybil providers, humans, applications to integration, and our legion of bot defenders, here are some more immediate goals and priorities.

* Support multi chain solutions by adding [idos.network](https://idos.network/)
* Add more checks, different identity solutions, patterns, account mapping, 3rd party accounts
* Implementation of NEP413 to prevent from require users to pay gas to add stamp to registry
* Integrating verification processes more natively on our application
* Incentives for cluster mapping and more dynamic thresholds and bot protection

'''
'''--- extra/glossary.md ---
---
description: Words used in this documentation
---

# üìö Glossary

* **Stamp/Check:** Proof of Sybil resistance used in nada.bot's global registry.
* **Sybil Attack:** An attack where fake identities manipulate reputation or voting systems. (Consider replacing "think of it as..." with a concise definition.)
* **Validating a Check:** Verifying a Sybil proof (aka 3rd party authorization, identity) through a NEAR smart contract method provided by a Sybil Provider.
* **Sybil Provider:** An independent service offering Sybil resistance checks via NEAR smart contracts.
* **Human Threshold:** Minimum score in nada.bot's registry (initially set by core, later by DAO) required to be considered "human." Through aggregated checks x wieghts an individual must have after calculate\_score(accountId) function is called&#x20;
* **Weight:** Points assigned by nada.bot to each Sybil Provider based on factors like reliability and accuracy.
* **Nada.bot Registry (sybil.potlock.near):** A NEAR smart contract storing all stamps, calculating user weights against the human threshold, and providing standardized access to Sybil Providers.
* **Gas:** NEAR tokens required for on-chain transactions.
* **NEP413:** A NEAR standard enabling user ownership verification by requiring gas payment.
* **Near Protocol:** A Layer 1 blockchain built in Rust and compiled to WASM, focusing on fast and scalable dApp development through sharding.

'''
'''--- extra/our-contract.md ---
---
description: Our sybil contract
---

# üìÉ Our Contract

Deployed contract can be found at&#x20;

Our contract are at [https://github.com/PotLock/core/tree/main/contracts/sybil](https://github.com/PotLock/core/tree/main/contracts/sybil)&#x20;

### Purpose

1. Provides registry for sybil resistance providers (e.g. i-am-human, wormhole, others).
2. Allows users to collect stamps indicating their verification with registered providers.
3. Abstracts away individual sybil resistance providers/solutions to provide a single contract to call `is_human` (customizable parameters coming soon)

### Contract Structure

#### General Types

```
```

#### Contract

```
pub struct Contract {
    contract_source_metadata: LazyOption<VersionedContractSourceMetadata>,
    owner: AccountId,
    admins: UnorderedSet<AccountId>,
    providers_by_id: UnorderedMap<ProviderId, VersionedProvider>,
    default_provider_ids: UnorderedSet<ProviderId>,
    default_human_threshold: u32,
    // MAPPINGS
    // Stores all Stamp records, versioned for easy upgradeability
    stamps_by_id: UnorderedMap<StampId, VersionedStamp>,
    // Enables fetching of all stamps for a user
    provider_ids_for_user: LookupMap<AccountId, UnorderedSet<ProviderId>>,
    // Enables fetching of all users with given stamp (provider ID)
    user_ids_for_provider: LookupMap<ProviderId, UnorderedSet<AccountId>>,
    // Enables fetching of providers that a user has submitted (e.g. if user has submitted one malicious provider, they are likely to submit more and you'll want to be able to fetch these or filter them out of results)
    provider_ids_for_submitter: LookupMap<AccountId, UnorderedSet<ProviderId>>,
}

/// Ephemeral-only
pub struct Config {
    pub owner: AccountId,
    pub admins: Vec<AccountId>,
    pub default_provider_ids: Vec<ProviderId>,
    pub default_human_threshold: u32,
}
```

#### Providers

_NB: Providers are stored by their ID, which is a concatenation of the contract ID + method name, e.g. "iamhuman.near:is\_human"_

```
type ProviderId = String; // NB: this is stored internally as a struct

// Provider struct that is versioned & stored internally
pub struct Provider {
    // NB: contract address/ID and method name are contained in the Provider's ID (see `ProviderId`) so do not need to be stored here
    /// Name of the provider, e.g. "I Am Human"
    pub name: String,
    /// Description of the provider
    pub description: Option<String>,
    /// Whether this provider is active (updated by admin)
    pub is_active: bool,
    /// Whether this provider is flagged (updated by admin)
    pub is_flagged: bool,
    /// Admin notes, e.g. reason for flagging or marking inactive
    pub admin_notes: Option<String>,
    /// Default weight for this provider, e.g. 100
    pub default_weight: u32,
    /// Custom gas amount required
    pub gas: Option<u64>,
    /// Optional tags
    pub tags: Option<Vec<String>>,
    /// Optional icon URL
    pub icon_url: Option<String>,
    /// Optional external URL
    pub external_url: Option<String>,
    /// User who submitted this provider
    pub submitted_by: AccountId,
    /// Timestamp of when this provider was submitted
    pub submitted_at_ms: TimestampMs,
    /// Total number of times this provider has been used successfully
    pub stamp_count: u64,
}

// External-only/ephemeral Provider struct (not stored internally) that contains contract_id and method_name
pub struct ProviderExternal {
    /// Provider ID
    pub provider_id: ProviderId,
    /// Contract ID of the external contract that is the source of this provider
    pub contract_id: String,
    /// Method name of the external contract that is the source of this provider
    pub method_name: String,
    /// Name of the provider, e.g. "I Am Human"
    pub name: String,
    /// Description of the provider
    pub description: Option<String>,
    /// Whether this provider is active (updated by admin)
    pub is_active: bool,
    /// Whether this provider is flagged (updated by admin)
    pub is_flagged: bool,
    /// Admin notes, e.g. reason for flagging or marking inactive
    pub admin_notes: Option<String>,
    /// Default weight for this provider, e.g. 100
    pub default_weight: u32,
    /// Custom gas amount required
    pub gas: Option<u64>,
    /// Optional tags
    pub tags: Option<Vec<String>>,
    /// Optional icon URL
    pub icon_url: Option<String>,
    /// Optional external URL
    pub external_url: Option<String>,
    /// User who submitted this provider
    pub submitted_by: AccountId,
    /// Timestamp of when this provider was submitted
    pub submitted_at_ms: TimestampMs,
    /// Total number of times this provider has been used successfully
    pub stamp_count: u64,
}
```

#### Stamps

A **stamp** is the verification of a user against a given sybil provider.

```
pub struct StampId(pub String); // "{USER_ID}#{PROVIDER_ID}"

const STAMP_ID_DELIMITER: &str = "#"; // separates user_id and provider_id in StampId. * NB: should not be the same as PROVIDER_ID_DELIMITER (currently set to ":")

impl StampId {
    // Generate StampId ("{USER_ID}#{PROVIDER_ID}") from user_id and provider_id
    fn new(user_id: AccountId, provider_id: ProviderId) -> Self {
        StampId(format!(
            "{}{}{}",
            user_id, STAMP_ID_DELIMITER, provider_id.0
        ))
    }
}

/// Ephermal stamp data returned to user (not stored in contract)
pub struct StampExternal {
    user_id: AccountId,
    provider: ProviderExternal,
    validated_at_ms: TimestampMs,
}
```

#### Contract Source Metadata

_NB: Below implemented as per NEP 0330 (_[_https://github.com/near/NEPs/blob/master/neps/nep-0330.md_](https://github.com/near/NEPs/blob/master/neps/nep-0330.md)_), with addition of `commit_hash`_

```
pub struct ContractSourceMetadata {
    /// Version of source code, e.g. "v1.0.0", could correspond to Git tag
    pub version: String,
    /// Git commit hash of currently deployed contract code
    pub commit_hash: String,
    /// GitHub repo url for currently deployed contract code
    pub link: String,
}
```

### Methods

#### Write Methods

```
// INIT

pub fn new(
    source_metadata: Option<ContractSourceMetadata>,
    owner: AccountId,
    admins: Option<Vec<AccountId>>,
) -> Self

// PROVIDERS

#[payable]
pub fn register_provider(
    &mut self,
    contract_id: String,
    method_name: String,
    name: String,
    description: Option<String>,
    gas: Option<u64>,
    tags: Option<Vec<String>>,
    icon_url: Option<String>,
    external_url: Option<String>,
) -> ProviderExternal // NB: anyone can call this method to register a provider. If caller is admin, provider is automatically activated.

/// NB: this method can only be called by the provider's original submitter, or sybil contract owner/admin.
#[payable]
pub fn update_provider(
    &mut self,
    provider_id: ProviderId,
    name: Option<String>,
    description: Option<String>,
    gas: Option<u64>,
    tags: Option<Vec<String>>,
    icon_url: Option<String>,
    external_url: Option<String>,
) -> ProviderExternal

// STAMPS

#[payable]
pub fn set_stamp(&mut self, provider_id: ProviderId) -> Option<StampExternal> // None response indicates that user is not verified on target provider

pub fn delete_stamp(&mut self, provider_id: ProviderId) -> ()

// SOURCE METADATA

#[payable]
pub fn self_set_source_metadata(&mut self, source_metadata: ContractSourceMetadata) // only callable by the contract account (reasoning is that this should be able to be updated by the same account that can deploy code to the account)

// OWNER/ADMINS

#[payable]
pub fn owner_change_owner(&mut self, new_owner: AccountId)

#[payable]
pub fn owner_add_admins(&mut self, account_ids: Vec<AccountId>)

#[payable]
pub fn owner_remove_admins(&mut self, account_ids: Vec<AccountId>)

#[payable]
pub fn admin_activate_provider(
    &mut self,
    provider_id: ProviderId,
    default_weight: u32,
) -> Provider

#[payable]
pub fn admin_deactivate_provider(&mut self, provider_id: ProviderId) -> Provider

#[payable]
pub fn admin_flag_provider(&mut self, provider_id: ProviderId) -> Provider

#[payable]
pub fn admin_unflag_provider(&mut self, provider_id: ProviderId) -> Provider

#[payable]
pub fn admin_set_default_providers(&mut self, provider_ids: Vec<ProviderId>)

#[payable]
pub fn admin_add_default_providers(&mut self, provider_id: ProviderId)

#[payable]
pub fn admin_set_default_human_threshold(&mut self, default_human_threshold: u32)
```

#### Read Methods

```
// CONFIG

pub fn get_config(&self) -> Config

// PROVIDERS
pub fn get_provider(&self, contract_id: String, method_name: String) -> Option<ProviderJson>

pub fn get_providers(&self) -> Vec<ProviderJson>

// STAMPS

pub fn get_stamps_for_account_id(
    &self,
    account_id: AccountId,
    from_index: Option<u128>,
    limit: Option<u64>,
) -> Vec<StampExternal>

pub fn get_users_for_stamp(
    &self,
    provider_id: ProviderId,
    from_index: Option<u128>,
    limit: Option<u64>,
) -> Vec<AccountId>

pub fn get_providers_submitted_by_user(
    &self,
    account_id: AccountId,
    from_index: Option<u128>,
    limit: Option<u64>,
) -> Vec<ProviderExternal>

// IS-HUMAN

pub fn is_human(&self, account_id: String) -> bool // TODO: add option for caller to specify providers (with weights) + min_human_threshold

// OWNER/ADMINS

pub fn get_owner(&self) -> AccountId

pub fn get_admins(&self) -> Vec<AccountId>

// SOURCE METADATA

pub fn get_contract_source_metadata(&self) -> Option<ContractSourceMetadata>
```

### Events

#### `set_source_metadata`

Indicates that `ContractSourceMetadata` object has been set/updated.

**Example:**

```
{
    "standard": "potlock",
    "version": "1.0.0",
    "event": "set_source_metadata",
    "data": [
        {
            "source_metadata": {
                "commit_hash":"ec02294253b22c2d4c50a75331df23ada9eb04db",
                "link":"https://github.com/PotLock/core",
                "version":"0.1.0",
            }
        }
    ]
}
```

'''
'''--- guides/for-admins.md ---
---
description: For nada.bot administrations
---

# üëî For Admins

Certain admins and in the future this will be DAO enabled can approve checks and add weights. Set overall thresholds, and edit existing checks by flagging them or readjusting weights. Check out the admin panel (only accessible to core team).

## Navigating the Dashboard

When logged in their will be a "View Admin Dashboard" button on the navbar. When you click on this there 3 things you can do

* **Change Human Threshold:** Change Overall Human Threshold
* **Approve New Checks:** Approve Newly Submitted Checks and Set Weights
* **Review Past Check:** Flag / Deactive & Readjust Weights

<figure><img src="../.gitbook/assets/For Admins.png" alt=""><figcaption></figcaption></figure>

\

'''
'''--- guides/for-applications.md ---
---
description: For application looks for a sybil resistance Solution
---

# üì± For Applications

If you want to integrate us this usually means you are building an application on NEAR and either

* **Front End Gating:** check a user logged is a human to display different views
* **NEAR Contracts**: using for a cross contract call to our registry to enforce on the contract level

## Front End Gating

Check out the NEAR Docs to get a better sense of how to integrate in the front end. If you are using a javascript front end library you will most likely be integrating with our contract via NEAR API JS

```bash
npm install near-api-js near-wallet-selector
```

{% embed url="https://docs.near.org/tools/near-api-js/quick-reference" %}

In your javascript app

```javascript
import { connect, keyStores, WalletConnection } from 'near-api-js';
import { setupWalletSelector } from 'near-wallet-selector';

async function initNear() {
    const nearConfig = {
        networkId: "mainnet", // or "testnet"
        keyStore: new keyStores.BrowserLocalStorageKeyStore(),
        nodeUrl: "https://rpc.mainnet.near.org", // or "https://rpc.testnet.near.org" for testnet
        walletUrl: "https://app.mynearwallet.com", // or "https://wallet.testnet.near.org" for testnet
    };

    // Initialize connection to the NEAR protocol
    const near = await connect(nearConfig);

    // Initialize Wallet Selector
    const walletSelector = await setupWalletSelector({ 
        network: nearConfig.networkId,
        modules: [/* ... */],
    });

    // Initialize Wallet Connection
    const wallet = new WalletConnection(near, null);

    return { wallet, walletSelector, near };
}

async function checkIsHuman(accountId) {
    const { wallet } = await initNear();

    if (!wallet.isSignedIn()) {
        // Show login popup modal here
        // Example: showModal("Please sign in to continue");
        return;
    }

    const contract = new wallet.account().contract({
        viewMethods: ['isHuman'],
        changeMethods: [],
    });

    try {
        const isHuman = await contract.isHuman({ account_id: accountId });
        let grantAccess = isHuman;
        console.log("Grant Access: ", grantAccess);

        // Additional logic based on grantAccess
    } catch (error) {
        console.error("Error checking if human: ", error);
    }
}

// Replace with the actual account ID to check
const accountIdToCheck = "example-account.near";
checkIsHuman(accountIdToCheck);

```

This code does the following:

1. Initializes a connection to the NEAR blockchain using the `near-api-js` library.
2. Sets up the NEAR Wallet Selector, which allows users to log in using various NEAR wallets.
3. Checks if the user is logged in; if not, shows a popup modal prompting them to sign in.
4. Once logged in, it calls the `isHuman` view method on the `sybil.potlock.near` contract, passing the specified `accountId`.
5. The result (true/false) is saved in the `grantAccess` variable and can be used for further logic.

Make sure to handle the UI elements (like the popup modal) according to your application's frontend framework or library. The above code assumes a basic JavaScript setup and will need to be adapted to fit your specific implementation details.

## NEAR Contract

NEAR Protocl is a layer 1 blockchain with Rust contracts that compile to Wasm.&#x20;

**Create Your First Rust Contract**: After installing Rust, you can create your first Rust contract. Here are the steps:

* Download and install [Rust](https://doc.rust-lang.org/book/ch01-01-installation.html).
* Create a new Rust project using the [quickstart guide](https://app.hzn.xyz/2.develop/quickstart.md).
* Read the NEAR docs on [how to write smart contracts](https://app.hzn.xyz/2.develop/contracts/anatomy.md).

**Resources**: For more information and examples, you can refer to the following resources:

* Documentation: https://docs.near.org/develop/contracts/anatomy&#x20;
* Examples: https://docs.near.org/tutorials/welcome
* Github: https://github.com/near/near-sdk-rs

### Cross Contract Calls

{% embed url="https://github.com/near/docs/blob/master/docs/sdk/rust/cross-contract/callbacks.md" %}

Here is an example with how nada.bot does it with I-Am Human contract [https://github.com/PotLock/core/blob/71f35051f81c333c85fafc42d073173191ad14ca/contracts/sybil/src/human.rs#L43](https://github.com/PotLock/core/blob/71f35051f81c333c85fafc42d073173191ad14ca/contracts/sybil/src/human.rs#L43)

To make a cross-contract call in Rust for a NEAR smart contract, you would typically use the `promise_then` method to schedule the execution of a callback after the initial cross-contract call completes. Here's a basic example of how you might structure this in your Rust smart contract:

```
```

```rust
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, Promise, AccountId};
use near_sdk::json_types::U128;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct MyContract {
    // Your contract's state and fields go here
}

#[near_bindgen]
impl MyContract {
    pub fn call_is_human(&self, account_id: AccountId) {
        let sybil_contract: AccountId = "v1.nadabot.near".parse().unwrap();

        // Call `isHuman` method on the sybil_contract
        Promise::new(sybil_contract)
            .function_call(
                "isHuman".to_string(),
                // Here you would serialize the parameters for the `isHuman` method
                // For this example, assume that it takes an account_id in JSON format
                serde_json::to_vec(&account_id).unwrap(),
                0, // attached deposit
                env::prepaid_gas() / 2 // use half of the remaining gas
            )
            .then(
                // Schedule the execution of the callback method
                env::current_account_id(),
                "on_is_human_callback".to_string(),
                // You can pass any additional data needed for the callback here
                // In this case, we're not passing any extra data
                vec![],
                0, // attached deposit for the callback
                env::prepaid_gas() / 2 // use the remaining half of the gas
            );
    }

    // Callback function
    pub fn on_is_human_callback(&mut self) {
        // Here you would handle the result from the `isHuman` call
        // Assuming the result is a boolean
        let is_human: bool = match env::promise_result(0) {
            near_sdk::PromiseResult::Successful(result) => {
                // Deserialize the result to a bool
                serde_json::from_slice::<bool>(&result).unwrap_or(false)
            }
            _ => false,
        };

        // Store or use `is_human` as needed
        let is_valid = is_human;
        // Further logic depending on `is_valid`
    }
}

// Boilerplate code for tests and initialization goes here

```

###

## Ideas to Integrate

* Airdropping and amplified rewards for loyalty programs
* 1 person 1 vote for governance on governance contract

'''
'''--- guides/for-bots.md ---
---
description: Haha what a trick
---

# ü§ñ For Bots

Gotchuuuuuuuuu. Click here to verify you are a bot and to get on our [blacklist](https://nada.bot/blacklist)

'''
'''--- guides/for-sybil-providers.md ---
---
description: For those who want to get approved to our list of checks
---

# ‚úÖ For Sybil Providers

Want us to add your verification process inside of our human registry? \

## Benefits

* Get people sent to you through our aggregator
* Have all the applications that emit our contracts automatically integrate yourselve

### Requirements

* Create a contract We prefer you deploy your contract under a named account, preferably as a subaccount like twitter.womrhol3.near so users can trust your entity for maintaining this contract. For example; say you create a contract that binds as twitter account to, you will create a helper function that can be called to view whether an account has successfully binded on both ends. You do not have to create a mapping contract method. For example we are not asking you return the twitter account ID, rather we just are trusting that you just verify if an account has compelted a certain check. For example on twitter.wormhol3.near you would have a method isTwitterVerified(accountId): bool. Currently it is up to the PotLock Sybil team to determine weights based on impact of check and trustworthiness of entity.
* Need a clear external link
* Make sure you are compatible with all wallets on NEAR Wallet selector&#x20;
* Create a helper view method on a contract that takes in a accountid and returns a boolean
* Add the contract name and method&#x20;
* Create a picture
* A clear description of your verification process and what you are verifying
* Add an icon for your image

First login,  click ‚ÄúSubmit Check‚Äù, then a form will pull up. Submitting of the form requires a transaction

<figure><img src="../.gitbook/assets/Screenshot 2024-01-05 at 3.01.08 PM.png" alt=""><figcaption><p>Add A Custom Check</p></figcaption></figure>

Fill out all details about your form. Make sure you send a link. The best flow for users is to give an applciation link when after they verify their is redirect back to your check on nada.bot in order to streamline the need for users to also sign a verify transaction to add your stamp to their registry record. Also make sure to clearly describe steps and amount of gas needed.

\

<figure><img src="../.gitbook/assets/Submit Stamp for gitbook.png" alt=""><figcaption><p>Example of add a stamp / check</p></figcaption></figure>

Check out our registry contract to understand how to make your check compatible

{% content-ref url="../extra/our-contract.md" %}
[our-contract.md](../extra/our-contract.md)
{% endcontent-ref %}

### How It Works in Our System

* Afterward our bot prevention team will review the Check and then add a weight on it. (This weight can be changed)
* GIve 2-3 business days to be verified
* You will then be available for other people to verify. After they verify with you they must add a stamp (requires gas) to get their own score up, See proof you are not a bot&#x20;
* If we discover that bots are verifying with your system or any wrong doing your score can get eliminated or your check will be removed from the approve list.

### Examples of Contracts Related to Sybil Providers

* **Our Sybil Simulator Contract** [**https://github.com/PotLock/core/tree/main/contracts/sybil\_provider\_simulator**](https://github.com/PotLock/core/tree/main/contracts/sybil\_provider\_simulator)

**Other Examples**

* **Wormhol3 Twitter x NEAR Social Cross posting (WIP)** [https://github.com/wormhole3/wormhole3-account-binding](https://github.com/wormhole3/wormhole3-account-binding) (for connecting account with twitter and delegating access to contract to post on NEAR.social)
* **NDC I Am Human** [https://github.com/near-ndc/i-am-human/tree/master/contracts/human\_checker](https://github.com/near-ndc/i-am-human/tree/master/contracts/human\_checker) (uses fractal face scan for detecting)  [https://nearblocks.io/address/registry.i-am-human.near](https://nearblocks.io/address/registry.i-am-human.near) (WIP)
  *   I-Am-Human registry

      I am human is a registry contract that issues SBT based on Fractal's face verification to issue a SBT according to NEP 393. This was using in the first NDC election to verify humans for a vote. We leverage the registry is\_human method to check if someone has a face scan without the need for PotLock's contributor to keep track or having a Fractal api. &#x20;
* Holoynm (WIP) [https://github.com/holonym-foundation/v3-near-contract](https://github.com/holonym-foundation/v3-near-contract)
* **Dapplets using connected Accounts (WIP)** [https://github.com/dapplets/connected-accounts-assembly](https://github.com/dapplets/connected-accounts-assembly)

'''
'''--- guides/for-users.md ---
---
description: For users who are verifying that they are not a bot
---

# üë®üíº For Users

## Why Would Users Be Using Nada.bot

_**In order to prove you are not a bot you need to get different ‚ÄúChecks‚Äù which involves going to a 3rd party, verifying with their contract, than adding that check to our global registry.**_&#x20;

{% hint style="info" %}
Different applications like PotLock and Cplanet Contensts do cross contract calls that enforce that you are not a bot.&#x20;
{% endhint %}

## What you can do

* Verify with different checks on 3rd party providers&#x20;
* Validate and get a higher score

First you login, if you don‚Äôt have a wallet than create a NEAR Wallet. If you don‚Äôt have one get one at [shard.dog/nadabot](http://shard.dog/nadabot)

{% hint style="warning" %}
_It is important to note that this account will be the one you use to build your reputation and it cant be transferred to another account, so don‚Äôt you lose this._&#x20;
{% endhint %}

You should have a human score of zero. You aim is to get past this human score through a collection of stamps/checks. Then you are to look at stamp. Most stamps should say ‚ÄúGet Check‚Äù. This means we have checked their contract and you are not verified.

<figure><img src="../.gitbook/assets/After Log in.png" alt=""><figcaption></figcaption></figure>

Click on a stamp, read the instructions, then click on the get check button. This should take you to a 3rd party link where you need to connect your wallet again and then verify. Note that each verification may require gas an in instruction to load up your account with enough gas to prove this stamp.

\

<figure><img src="../.gitbook/assets/For normal person.png" alt=""><figcaption><p>Dummy example of what a sybil check would look like for a user</p></figcaption></figure>

Once you verify through the sybil provider's application, go back to the [app.nada.bot](https://app.nada.bot) homepage and refresh. There that section should now be in the **Verify** section where we now detect that you have gotten that stamp but you need to pay 0.01 N in order to add the check to our nada.bot check registry to improve your human score. Once you confirm the transaction you should then see this check in the approve section and your score to go up.&#x20;

\

{% hint style="warning" %}
_human threshold is subject ot change or get lower depending on bot activity, as well as weights based on perceived level of difficulty, however your status of verification doesn‚Äôt change. Say a weight for a Twitter Check by Shard.dog changes from 1->2 this means, your score will go up._
{% endhint %}

\

'''
'''--- support.md ---
---
description: Support and FAQ
---

# ‚Åâ Support

For a support ticket the best way is to use our intercom to directly report a ticket. If not than hop on our [support channel here](https://nada.bot/support) on telegram

## Why Use Our Human Check&#x20;

We will be running funding pools that bad actors will try to game. Not only will be verifying independent checks by different sybil providers, we will be adjusting weights based on importance, and human thresholds as addresses try to bot us in realtime. Additionally if our requirements are too strong we can adjust these to make more accesible. Most application developers and round maangers / chefs will not be monitoring all addresses that interact with their contract, rather relying on our aggregated "check"&#x20;

## U**s Vs idOS**

While their are other identity layer providers, Nada.bot is for NEAR contracts that need to use a cross contract call that is robust instead of idOS which is an SDK to be integrated into applications.&#x20;

## How We Determine Humans

On our contract we set weights and approves. Currently we are toggling based on different weights (see on [nada.bot](https://nada.bot))

'''