*GitHub Repository "luciotato/simple-rust-parser"*

'''--- .vscode/tasks.json ---
{
	"version": "2.0.0",
	"tasks": [
		{
			"type": "npm",
			"script": "build",
			"problemMatcher": [
				"$tsc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"label": "npm: build",
			"detail": "tsc --build",
		}
	]
}
'''
'''--- README.md ---
# Simple Rust Parser

This a simple hand-coded PEG parser for a subset of Rust, 
it is aimed to parse the subset of Rust used for writing 
smart contracts for the Near Blockchain

'''
'''--- build.js ---
import * as fs from "fs"
import * as path from "path"
import { execSync} from "child_process"

function fromDir(startPath, filter, callback) {

    //console.log('Starting from dir '+startPath+'/');

    if (!fs.existsSync(startPath)) {
        console.log("no dir ", startPath);
        return;
    }

    var files = fs.readdirSync(startPath);
    for (var i = 0; i < files.length; i++) {
        var filename = path.join(startPath, files[i]);
        var stat = fs.lstatSync(filename);
        if (stat.isDirectory()) {
            fromDir(filename, filter, callback); //recurse
        }
        else if (filter.test(filename)) callback(filename);
    };
};

function addDotJsToLocalImports(filename) {
    var buf = fs.readFileSync(filename);
    let replaced = buf.toString().replace(/(import .* from\s+['"])(?!.*\.js['"])(\..*?)(?=['"])/g, '$1$2.js')
    if (replaced !== buf.toString()) {
        fs.writeFileSync(filename, replaced)
        console.log("fixed imports at "+filename )
    }
}

//---------------------
//---START BUILD TASKS
//---------------------

execSync("npx tsc --build -verbose", { stdio: 'inherit' })

//add .js to ts-generated import-commands so the generated ES6 code works with node ES2020 type:module
//see: https://github.com/microsoft/TypeScript/issues/16577
fromDir("./dist", /\.js$/, addDotJsToLocalImports)

'''
'''--- package-lock.json ---
{
    "name": "simple-rust-parser",
    "version": "0.1.0",
    "lockfileVersion": 1,
    "requires": true,
    "dependencies": {
        "@types/node": {
            "version": "14.11.1",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-14.11.1.tgz",
            "integrity": "sha512-oTQgnd0hblfLsJ6BvJzzSL+Inogp3lq9fGgqRkMB/ziKMgEUaFl801OncOzUmalfzt14N0oPHMK47ipl+wbTIw==",
            "dev": true
        },
        "typescript": {
            "version": "4.0.3",
            "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.3.tgz",
            "integrity": "sha512-tEu6DGxGgRJPb/mVPIZ48e69xCn2yRmCgYmDugAVwmJ6o+0u1RI18eO7E7WBTLYLaEVVOhwQmcdhQHweux/WPg==",
            "dev": true
        }
    }
}

'''
'''--- package.json ---
{
    "name": "simple-rust-parser",
    "version": "0.1.0",
    "description": "simple PEG parser for a subset of rust",
    "type": "module",
    "main": "dist/index.js",
    "directories": {
        "lib": "dist/lib",
        "test": "dist/test"
    },
    "scripts": {
        "build": "node ./build.js",
        "test": "npm run-script build && node dist/test/test.js",
        "lint": "eslint . --ext .ts"
    },
    "devDependencies": {
        "@types/node": "^14.11.2",
        "typescript": "^4.0.3"
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/luciotato/simple-rust-parser.git"
    },
    "keywords": [
        "rust",
        "smart",
        "contracts",
        "parser"
    ],
    "author": "Lucio Tato",
    "license": "ISC",
    "homepage": "https://github.com/luciotato/simple-rust-parser#readme",
    "bugs": {
        "url": "https://github.com/luciotato/simple-rust-parser/issues"
    }
}

'''
'''--- res/test/expected/staking-pool.js ---
// ----------------------------------------------
// Transpiled by rs2as - source: ./res/test/staking-pool/src/lib.rs
// ---------------------------------------------
import { Context, logging, storage } from "near-sdk-as".js
// mod internal
/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64  = 100_000_000_000_000
/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64  = 20_000_000_000_000
/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance  = 1_000_000_000_000
/// There is no deposit balance attached.
const NO_DEPOSIT: Balance  = 0
/// A type to distinguish between a balance and "stake" shares for better readability.
type NumStakeShares  = Balance
construct_uint!{/// 256-bit unsigned integer.pubstructU256(4);}
//#[cfg(test)]
// mod test_utils
//#[global_allocator]
/// Inner account data of a delegate.
//#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
// declare struct Account
/// Represents an account structure readable by humans.
//#[derive(Serialize, Deserialize)]
//#[serde(crate = "near_sdk::serde")]
// declare struct HumanReadableAccount
// impl Default
function default(): Self {
    return {        unstaked : 0,
        stake_shares : 0,
        unstaked_available_epoch_height : 0} as Self
}
/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight  = 4
//#[near_bindgen]
//#[derive(BorshDeserialize, BorshSerialize)]
// declare struct StakingContract
// impl Default
function default(): Self {
    return env.panic(b"Staking contract should be initialized before usage")
}
//#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
//#[serde(crate = "near_sdk::serde")]
// declare struct RewardFeeFraction
// impl RewardFeeFraction
export function assert_valid() {
    assert_ne!(this.denominator,0,"Denominator must be a positive number")
    assert(this.numerator<=this.denominator,"The reward fee must be less or equal to 1")
}
export function multiply(value: Balance): Balance {
    return (U256.from(this.numerator) * U256.from(value) / U256.from(this.denominator))
}
/// Interface for a voting contract.
//#[ext_contract(ext_voting)]
VoteContract/// Method for validators to vote or withdraw the vote.
/// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
function vote(is_vote: bool)
/// Interface for the contract itself.
//#[ext_contract(ext_self)]
SelfContract/// A callback to check the result of the staking action.
/// In case the stake amount is less than the minimum staking threshold, the staking action
/// fails, and the stake amount is not changed. This might lead to inconsistent state and the
/// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
/// action in case of the failure of the first staking action.
function on_stake_action()
//#[near_bindgen]
// impl StakingContract
/// Initializes the contract with the given owner_id, initial staking public key (with ED25519
/// curve) and initial reward fee fraction that owner charges for the validation work.
///
/// The entire current balance of this contract will be used to stake. This allows contract to
/// always maintain staking shares that can't be unstaked or withdrawn.
/// It prevents inflating the price of the share too much.
//#[init]
export function new(owner_id: AccountId, stake_public_key: Base58PublicKey, reward_fee_fraction: RewardFeeFraction): Self {
    assert(!env::state_exists(),"Already initialized")
    reward_fee_fraction.assert_valid()
    assert(env::is_valid_account_id(owner_id.as_bytes()),"The owner account ID is invalid")
    let account_balance = Context.env.account_balance()
    let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND
    assert(env.account_locked_balance() == 0) //"The staking pool shouldn't be staking at the initialization"
    let this = {        [positional] : owner_id,
        stake_public_key : stake_public_key.into(),
        last_epoch_height : env.epoch_height(),
        last_total_balance : account_balance,
        [positional] : total_staked_balance,
        total_stake_shares : NumStakeShares.from(total_staked_balance),
        [positional] : reward_fee_fraction,
        accounts : UnorderedMap.new(b"u"),
        paused : false} as Self
    // Staking with the current pool to make sure the staking key is valid.
    this.internal_restake()
    return this
}
/// Distributes rewards and restakes if needed.
export function ping() {
    if (this.internal_ping()){
        this.internal_restake()
    }
}
/// Deposits the attached amount into the inner account of the predecessor.
//#[payable]
export function deposit() {
    let need_to_restake = this.internal_ping()
    this.internal_deposit()
    if (need_to_restake){
        this.internal_restake()
    }
}
/// Deposits the attached amount into the inner account of the predecessor and stakes it.
//#[payable]
export function deposit_and_stake() {
    this.internal_ping()
    let amount = this.internal_deposit()
    this.internal_stake(amount)
    this.internal_restake()
}
/// Withdraws the entire unstaked balance from the predecessor account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
export function withdraw_all() {
    let need_to_restake = this.internal_ping()
    let account_id = Context.env.predecessor_account_id()
    let account = this.internal_get_account(account_id)
    this.internal_withdraw(account.unstaked)
    if (need_to_restake){
        this.internal_restake()
    }
}
/// Withdraws the non staked balance for given account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
export function withdraw(amount: U128) {
    let need_to_restake = this.internal_ping()
    let amount: Balance = amount.into()
    this.internal_withdraw(amount)
    if (need_to_restake){
        this.internal_restake()
    }
}
/// Stakes all available unstaked balance from the inner account of the predecessor.
export function stake_all() {
    // Stake action always restakes
    this.internal_ping()
    let account_id = Context.env.predecessor_account_id()
    let account = this.internal_get_account(account_id)
    this.internal_stake(account.unstaked)
    this.internal_restake()
}
/// Stakes the given amount from the inner account of the predecessor.
/// The inner account should have enough unstaked balance.
export function stake(amount: U128) {
    // Stake action always restakes
    this.internal_ping()
    let amount: Balance = amount.into()
    this.internal_stake(amount)
    this.internal_restake()
}
/// Unstakes all staked balance from the inner account of the predecessor.
/// The new total unstaked balance will be available for withdrawal in four epochs.
export function unstake_all() {
    // Unstake action always restakes
    this.internal_ping()
    let account_id = Context.env.predecessor_account_id()
    let account = this.internal_get_account(account_id)
    let amount = this.staked_amount_from_num_shares_rounded_down(account.stake_shares)
    this.inner_unstake(amount)
    this.internal_restake()
}
/// Unstakes the given amount from the inner account of the predecessor.
/// The inner account should have enough staked balance.
/// The new total unstaked balance will be available for withdrawal in four epochs.
export function unstake(amount: U128) {
    // Unstake action always restakes
    this.internal_ping()
    let amount: Balance = amount.into()
    this.inner_unstake(amount)
    this.internal_restake()
}
/****************/
/* View methods */
/****************/
/// Returns the unstaked balance of the given account.
export function get_account_unstaked_balance(account_id: AccountId): U128 {
    return this.get_account(account_id).unstaked_balance
}
/// Returns the staked balance of the given account.
/// NOTE: This is computed from the amount of "stake" shares the given account has and the
/// current amount of total staked balance and total stake shares on the account.
export function get_account_staked_balance(account_id: AccountId): U128 {
    return this.get_account(account_id).staked_balance
}
/// Returns the total balance of the given account (including staked and unstaked balances).
export function get_account_total_balance(account_id: AccountId): U128 {
    let account = this.get_account(account_id)
    return (account.unstaked_balance.. + account.staked_balance..)
}
/// Returns `true` if the given account can withdraw tokens in the current epoch.
export function is_account_unstaked_balance_available(account_id: AccountId): bool {
    return this.get_account(account_id).can_withdraw
}
/// Returns the total staking balance.
export function get_total_staked_balance(): U128 {
    return this.total_staked_balance.into()
}
/// Returns account ID of the staking pool owner.
export function get_owner_id(): AccountId {
    return this.owner_id.clone()
}
/// Returns the current reward fee as a fraction.
export function get_reward_fee_fraction(): RewardFeeFraction {
    return this.reward_fee_fraction.clone()
}
/// Returns the staking public key
export function get_staking_key(): Base58PublicKey {
    return this.stake_public_key.clone().try_into().unwrap()
}
/// Returns true if the staking is paused
export function is_staking_paused(): bool {
    return this.paused
}
/// Returns human readable representation of the account for the given account ID.
export function get_account(account_id: AccountId): HumanReadableAccount {
    let account = this.internal_get_account(account_id)
    return {        [positional] : account_id,
        unstaked_balance : account.unstaked.into(),
        staked_balance : this.staked_amount_from_num_shares_rounded_down(account.stake_shares).into(),
        can_withdraw : account.unstaked_available_epoch_height <= env.epoch_height()} as HumanReadableAccount
}
/// Returns the number of accounts that have positive balance on this staking pool.
export function get_number_of_accounts(): u64 {
    return this.accounts.len()
}
/// Returns the list of accounts
export function get_accounts(from_index: u64, limit: u64): Vec {
    let keys = this.accounts.keys_as_vector()
    return (from_index .. std.cmp::min(from_index + limit, keys.len()))
}
/*************/
/* Callbacks */
/*************/
export function on_stake_action() {
    assert(env.current_account_id() == env.predecessor_account_id()) //"Can be called only as a callback"
    assert(env.promise_results_count() == 1) //"Contract expected a result on the callback"
    let stake_action_succeeded = const value=env.promise_result(0)
    value==PromiseResult.Successful(undefined)? true : value==false
    // If the stake action failed and the current locked amount is positive, then the contract
    // has to unstake.
    if ( ! stake_action_succeeded && env.account_locked_balance() > 0){
        Promise.new(env.current_account_id()).stake(0, this.stake_public_key.clone())
    }
}
/*******************/
/* Owner's methods */
/*******************/
/// Owner's method.
/// Updates current public key to the new given public key.
export function update_staking_key(stake_public_key: Base58PublicKey) {
    this.assert_owner()
    // When updating the staking key, the contract has to restake.
    let _need_to_restake = this.internal_ping()
    this.stake_public_key = stake_public_key.into()
    this.internal_restake()
}
/// Owner's method.
/// Updates current reward fee fraction to the new given fraction.
export function update_reward_fee_fraction(reward_fee_fraction: RewardFeeFraction) {
    this.assert_owner()
    reward_fee_fraction.assert_valid()
    let need_to_restake = this.internal_ping()
    this.reward_fee_fraction = reward_fee_fraction
    if (need_to_restake){
        this.internal_restake()
    }
}
/// Owner's method.
/// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
export function vote(voting_account_id: AccountId, is_vote: bool): Promise {
    this.assert_owner()
    assert(env::is_valid_account_id(voting_account_id.as_bytes()),"Invalid voting account ID")
    return ext_voting.vote(is_vote, voting_account_id, NO_DEPOSIT, VOTE_GAS)
}
/// Owner's method.
/// Pauses pool staking.
export function pause_staking() {
    this.assert_owner()
    assert(!this.paused,"The staking is already paused")
    this.internal_ping()
    this.paused = true
    Promise.new(env.current_account_id()).stake(0, this.stake_public_key.clone())
}
/// Owner's method.
/// Resumes pool staking.
export function resume_staking() {
    this.assert_owner()
    assert(this.paused,"The staking is not paused")
    this.internal_ping()
    this.paused = false
    this.internal_restake()
}
//#[cfg(test)]
// mod tests
// declare struct Emulator
function zero_fee(): RewardFeeFraction {
    return {        numerator : 0,
        denominator : 1} as RewardFeeFraction
}
// impl Emulator
export function new(owner: String, stake_public_key: String, reward_fee_fraction: RewardFeeFraction): Self {
    let context = VMContextBuilder.new().current_account_id(owner.clone()).account_balance(ntoy(30)).finish()
    testing_env!(context.clone())
    let contract = StakingContract.new(owner, Base58PublicKey.try_from(stake_public_key).unwrap(), reward_fee_fraction)
    let last_total_staked_balance = contract.total_staked_balance
    let last_total_stake_shares = contract.total_stake_shares
    return {        [positional] : contract,
        epoch_height : 0,
        amount : ntoy(30),
        locked_amount : 0,
        [positional] : last_total_staked_balance,
        [positional] : last_total_stake_shares,
        [positional] : context} as Emulator
}
function verify_stake_price_increase_guarantee() {
    let total_staked_balance = this.contract.total_staked_balance
    let total_stake_shares = this.contract.total_stake_shares
    assert(U256::from(total_staked_balance)*U256::from(this.last_total_stake_shares)>=U256::from(this.last_total_staked_balance)*U256::from(total_stake_shares),"Price increase guarantee was violated.")
    this.last_total_staked_balance = total_staked_balance
    this.last_total_stake_shares = total_stake_shares
}
export function update_context(predecessor_account_id: String, deposit: Balance) {
    this.verify_stake_price_increase_guarantee()
    this.context = VMContextBuilder.new().current_account_id(staking()).predecessor_account_id(predecessor_account_id.clone()).signer_account_id(predecessor_account_id).attached_deposit(deposit).account_balance(this.amount).account_locked_balance(this.locked_amount).epoch_height(this.epoch_height).finish()
    testing_env!(this.context.clone())
    console.log("Epoch: " + self.epoch_height.toString() + ", Deposit: " + deposit.toString() + ", amount: " + self.amount.toString() + ", locked_amount: " + self.locked_amount.toString())
}
export function simulate_stake_call() {
    let total_stake = this.contract.total_staked_balance
    // Stake action
    this.amount = this.amount + this.locked_amount - total_stake
    this.locked_amount = total_stake
    // Second function call action
    this.update_context(staking(), 0)
}
export function skip_epochs(num: EpochHeight) {
    this.epoch_height += num
    this.locked_amount = (this.locked_amount * (100 + u128.from(num))) / 100
}
//#[test]
function test_restake_fail() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    emulator.update_context(bob(), 0)
    emulator.contract.internal_restake()
    let receipts = Context.env.created_receipts()
    assert(receipts.len() == 2)
    // Mocked Receipt fields are private, so can't check directly.
    assert(serde_json::to_string(&receipts[0]).unwrap().contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"))
    assert(serde_json::to_string(&receipts[1]).unwrap().contains("\"method_name\":\"on_stake_action\""))
    emulator.simulate_stake_call()
    emulator.update_context(staking(), 0)
    testing_env_with_promise_results(emulator.context.clone(), PromiseResult.Failed)
    emulator.contract.on_stake_action()
    let receipts = Context.env.created_receipts()
    assert(receipts.len() == 1)
    assert(serde_json::to_string(&receipts[0]).unwrap().contains("\"actions\":[{\"Stake\":{\"stake\":0,"))
}
//#[test]
function test_deposit_withdraw() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    let deposit_amount = ntoy(1_000_000)
    emulator.update_context(bob(), deposit_amount)
    emulator.contract.deposit()
    emulator.amount += deposit_amount
    emulator.update_context(bob(), 0)
    assert(emulator.contract.get_account_unstaked_balance(bob()).. == deposit_amount)
    emulator.contract.withdraw(deposit_amount.into())
    assert(emulator.contract.get_account_unstaked_balance(bob()).. == 0u128)
}
//#[test]
function test_stake_with_fee() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", {        numerator : 10,
        denominator : 100} as RewardFeeFraction)
    let deposit_amount = ntoy(1_000_000)
    emulator.update_context(bob(), deposit_amount)
    emulator.contract.deposit()
    emulator.amount += deposit_amount
    emulator.update_context(bob(), 0)
    emulator.contract.stake(deposit_amount.into())
    emulator.simulate_stake_call()
    assert(emulator.contract.get_account_staked_balance(bob()).. == deposit_amount)
    let locked_amount = emulator.locked_amount
    let n_locked_amount = yton(locked_amount)
    emulator.skip_epochs(10)
    // Overriding rewards (+ 100K reward)
    emulator.locked_amount = locked_amount + ntoy(100_000)
    emulator.update_context(bob(), 0)
    emulator.contract.ping()
    let expected_amount = deposit_amount + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,expected_amount)
    // Owner got 10% of the rewards
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(owner()).0,ntoy(10_000))
    let locked_amount = emulator.locked_amount
    let n_locked_amount = yton(locked_amount)
    emulator.skip_epochs(10)
    // Overriding rewards (another 100K reward)
    emulator.locked_amount = locked_amount + ntoy(100_000)
    emulator.update_context(bob(), 0)
    emulator.contract.ping()
    // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,expected_amount+ntoy((yton(expected_amount)*90_000+n_locked_amount/2)/n_locked_amount))
    // owner earns 10% with the fee and also small percentage from restaking.
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(owner()).0,ntoy(10_000)+ntoy(10_000)+ntoy((10_000u128*90_000+n_locked_amount/2)/n_locked_amount))
    assert(emulator.contract.get_number_of_accounts() == 2)
}
//#[test]
function test_stake_unstake() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    let deposit_amount = ntoy(1_000_000)
    emulator.update_context(bob(), deposit_amount)
    emulator.contract.deposit()
    emulator.amount += deposit_amount
    emulator.update_context(bob(), 0)
    emulator.contract.stake(deposit_amount.into())
    emulator.simulate_stake_call()
    assert(emulator.contract.get_account_staked_balance(bob()).. == deposit_amount)
    let locked_amount = emulator.locked_amount
    // 10 epochs later, unstake half of the money.
    emulator.skip_epochs(10)
    // Overriding rewards
    emulator.locked_amount = locked_amount + ntoy(10)
    emulator.update_context(bob(), 0)
    emulator.contract.ping()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,deposit_amount+ntoy(10))
    emulator.contract.unstake((deposit_amount / 2))
    emulator.simulate_stake_call()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,deposit_amount/2+ntoy(10))
    assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0,deposit_amount/2)
    let acc = emulator.contract.get_account(bob())
    assert(acc.account_id == bob())
    assert_eq_in_near!(acc.unstaked_balance.0,deposit_amount/2)
    assert_eq_in_near!(acc.staked_balance.0,deposit_amount/2+ntoy(10))
    assert(!acc.can_withdraw)
    assert(!emulator.contract.is_account_unstaked_balance_available(bob()),)
    emulator.skip_epochs(4)
    emulator.update_context(bob(), 0)
    assert(emulator.contract.is_account_unstaked_balance_available(bob()),)
}
//#[test]
function test_stake_all_unstake_all() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    let deposit_amount = ntoy(1_000_000)
    emulator.update_context(bob(), deposit_amount)
    emulator.contract.deposit_and_stake()
    emulator.amount += deposit_amount
    emulator.simulate_stake_call()
    assert(emulator.contract.get_account_staked_balance(bob()).. == deposit_amount)
    assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0,0)
    let locked_amount = emulator.locked_amount
    // 10 epochs later, unstake all.
    emulator.skip_epochs(10)
    // Overriding rewards
    emulator.locked_amount = locked_amount + ntoy(10)
    emulator.update_context(bob(), 0)
    emulator.contract.ping()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,deposit_amount+ntoy(10))
    emulator.contract.unstake_all()
    emulator.simulate_stake_call()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,0)
    assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0,deposit_amount+ntoy(10))
}
/// Test that two can delegate and then undelegate their funds and rewards at different time.
//#[test]
function test_two_delegates() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    emulator.update_context(alice(), ntoy(1_000_000))
    emulator.contract.deposit()
    emulator.amount += ntoy(1_000_000)
    emulator.update_context(alice(), 0)
    emulator.contract.stake(ntoy(1_000_000).into())
    emulator.simulate_stake_call()
    emulator.skip_epochs(3)
    emulator.update_context(bob(), ntoy(1_000_000))
    emulator.contract.deposit()
    emulator.amount += ntoy(1_000_000)
    emulator.update_context(bob(), 0)
    emulator.contract.stake(ntoy(1_000_000).into())
    emulator.simulate_stake_call()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,ntoy(1_000_000))
    emulator.skip_epochs(3)
    emulator.update_context(alice(), 0)
    emulator.contract.ping()
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(alice()).0,ntoy(1_060_900)-1)
    assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0,ntoy(1_030_000))
    // Checking accounts view methods
    // Should be 2, because the pool has 0 fee.
    assert(emulator.contract.get_number_of_accounts() == 2)
    let accounts = emulator.contract.get_accounts(0, 10)
    assert(accounts.len() == 2)
    assert(accounts[0].account_id == alice())
    assert(accounts[1].account_id == bob())
    let accounts = emulator.contract.get_accounts(1, 10)
    assert(accounts.len() == 1)
    assert(accounts[0].account_id == bob())
    let accounts = emulator.contract.get_accounts(0, 1)
    assert(accounts.len() == 1)
    assert(accounts[0].account_id == alice())
    let accounts = emulator.contract.get_accounts(2, 10)
    assert(accounts.len() == 0)
}
//#[test]
function test_low_balances() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    let initial_balance = 100
    emulator.update_context(alice(), initial_balance)
    emulator.contract.deposit()
    emulator.amount += initial_balance
    let remaining = initial_balance
    let amount = 1
    whileemulator.update_context(alice(), 0)amount = 2 + (amount - 1) % 3emulator.contract.stake(amount.into())emulator.simulate_stake_call()remaining -= amount
}
//#[test]
function test_rewards() {
    let emulator = Emulator.new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7", zero_fee())
    let initial_balance = ntoy(100)
    emulator.update_context(alice(), initial_balance)
    emulator.contract.deposit()
    emulator.amount += initial_balance
    let remaining = 100
    let amount = 1
    whileemulator.skip_epochs(3)emulator.update_context(alice(), 0)emulator.contract.ping()emulator.update_context(alice(), 0)amount = 2 + (amount - 1) % 3emulator.contract.stake(ntoy(amount).into())emulator.simulate_stake_call()remaining -= amount
}

'''
'''--- res/test/rust-samples/declaration.rs ---
/// comment
const VOTE_GAS: u64 = 100_000_000_000_000;

'''
'''--- res/test/rust-samples/outer-tests.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}
'''
'''--- res/test/rust-samples/test1-full.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}
'''
'''--- res/test/rust-samples/test1-start.rs ---
/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

'''
'''--- res/test/staking-pool/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}
'''
'''--- src/index.ts ---
import { ASTBase } from "./lib/Parser/ASTBase.js"
import { ASTModule } from "./lib/Parser/Grammar.js"
import { Lexer } from "./lib/Lexer/Lexer.js"
import { Parser } from "./lib/Parser/Parser.js"

export { ASTBase, ASTModule, Lexer , Parser }

'''
'''--- src/lib/Lexer/Lexer.ts ---
//The main class in this module is the Tokenizer.

//The Lexer translates code (a string or a file) into a list of anottated tokens ready to be parsed

//--eslint no-constant-condition: ["error", { "checkLoops": false }]*/

import "../util/String.extensions.js"

import { logger } from '../util/logger.js'

import { UTF8FileReader } from "../util/UTF8FileReader.js"

export enum TokenCode {
    BOF = 0,
    EOF,
    NEWLINE,
    WHITESPACE,
    COMMENT,
    ATTRIBUTE,
    PUNCTUATION,
    WORD,
    OPERATOR,
    ASSIGNMENT, // Assignment operators = += /= *=, etc
    NUMBER,
    HEXANUMBER,
    BINARYNUMBER,
    LITERAL_STRING,
    LITERAL_OBJECT,
}

//----------------------
//The Token Class
//===============

//Each token instance has:
//-a "type" e.g.: NEWLINE,EOF, when the token is a special char
//-a "value": the parsed text
//-the column in the source line in which the token appears

//class Token
// constructor
export class Token {
    owner: Lexer
    tokenCode: TokenCode
    value: string
    line: number
    col: number
    constructor(owner: Lexer, tokenCode: TokenCode, tokenText: string, line: number, column: number) {
        this.owner = owner
        this.tokenCode = tokenCode
        this.value = tokenText
        this.line = line
        this.col = column
    }
    // ---------------------------
    isSpace(): boolean { return this.tokenCode == TokenCode.NEWLINE || this.tokenCode == TokenCode.WHITESPACE }
    isEOF(): boolean { return this.tokenCode == TokenCode.EOF }

    // ---------------------------
    toString(): string {
        const code = TokenCode[this.tokenCode]
        if (this.tokenCode == TokenCode.BOF ||
            this.tokenCode == TokenCode.EOF ||
            this.tokenCode == TokenCode.WHITESPACE ||
            this.tokenCode == TokenCode.NEWLINE
        ) {
            return '(' + code + ')'
        }
        let v = this.value
        if (v && v.length > 20) v = v.slice(0, 17) + '...'
        return '(' + code + ' ' + v + ')'
    }
    posToString(): string {
        return `${this.owner.filename}:${this.line}:${(this.col)}`
    }
    toStringDebug(): string {
        return `${this.line}:${(this.col)} ${this.toString()}`
    }
}

//===============
//The Lexer Class
//===============
export class Lexer {

    token: Token //current token

    filename: string
    private file: UTF8FileReader
    private readString: string = '' //data already read from the file

    private curReadLine: number = 1
    private curReadCol: number = 1
    private cachedTokens: Token[]

    private savedPositions: Token[]

    hardError: Error
    softError: Error
    //outCode: OutCode
    private BOFToken: Token
    private EOFToken: Token

    autoSkipWhitespaceAndNewLine: boolean = true
    semiNotRequired: boolean = false

    static WHITESPACE_CHARS: string = ' \t\u00A0\u2028\u2029'
    
    /**
         * MAIN LEXER FUNCTION: recognizeToken
         * In this function you define the rules to tokenize the input stream 
         * the data to analize is at: this.readString
         * this.readString have the next 4Kb from the input stream
         * 
         * if the token is invalid, throw an error, else return [TokenCode, endPos]
         * where endPos is the position after the last character recognized
         * 
         * */
    private recognizeToken(): [TokenCode, number] {

        //fastest recognition based on 1st char
        const char = this.readString.charAt(0)
        const twoChars: string = this.readString.slice(0, 2)

        //based on 2-chars
        switch (twoChars) {
            case "//": {
                const endOfComment = this.untilNewLine()
                return [TokenCode.COMMENT, endOfComment]
            }
            case "#[": {
                const endPos = this.untilNewLine()
                return [TokenCode.ATTRIBUTE, endPos]
            }
            case '\r\n': {
                return [TokenCode.NEWLINE, 2]
            }
            //rust namespace separator
            case '::': {
                return [TokenCode.PUNCTUATION, 2]
            }
            //rust match pair: X => Y
            case '=>': {
                return [TokenCode.PUNCTUATION, 2]
            }
            // /* multiline comment
            case '/*': { 
                const endPos = this.findRead("*/")
                return [TokenCode.COMMENT, endPos+ 2] //includes opening /* and closing */
            }
            //rust 2-char special LITERAL_STRINGs
            //b"..." , r"..." 
            case 'b"': { //byte literal string
                const quoteChar = '"'
                const endQuotePos = this.untilUnescaped(quoteChar, 2)
                //return new Token 'LITERAL_STRING' 
                return [TokenCode.LITERAL_STRING, endQuotePos + 1] //includes opening (b") and closing quotes (")
            }

            //'0x' => Hexadecimal number, can inlude u64, u128
            case '0x': {
                const endPos = this.whileRanges('a-fA-F0-9u', 2)
                return [TokenCode.HEXANUMBER, endPos]
            }

            //'0b' => Binary number, , can inlude u64, u128
            case '0b': {
                const endPos = this.whileRanges('a-fA-F0-9u', 2)
                return [TokenCode.BINARYNUMBER, endPos]
            }

        }

        //based on single-char
        if (char == '\n') {
            return [TokenCode.NEWLINE, 1]
        }

        //check for NUMBER,, can inlude u64, u128
        if (char >= '0' && char <= '9') {
            let endPos = this.whileRanges('0-9._u')
            if (this.readString.charAt(endPos-1) == '.') endPos--; // can't end in '.'
            return [TokenCode.NUMBER, endPos]
        }

        if (Lexer.WHITESPACE_CHARS.includes(char)) {
            const endPos = this.whileRanges(Lexer.WHITESPACE_CHARS)
            return [TokenCode.WHITESPACE, endPos]
        }

        //rust 3-char assignment operators
        if (['<<=', '>>='].includes(this.readString.slice(0, 3))) {
            return [TokenCode.ASSIGNMENT, 3]
        }
        //rust 3-char operators
        if (['...', '..='].includes(this.readString.slice(0, 3))) {
            return [TokenCode.OPERATOR, 3]
        }

        //rust 2-char assignment operators
        if (['*=', '+=', '-=', '/=', '^=', '|=', '%=', '&='].includes(twoChars)) {
            return [TokenCode.ASSIGNMENT, 2]
        }
        //rust 2-char operators
        if (['!=', '&&', '||', '->', '..', '<=', '==', '>=', '>>'].includes(twoChars)) {
            return [TokenCode.OPERATOR, 2]
        }

        //assignment operator
        if (char == '=') {
            return [TokenCode.ASSIGNMENT, 1]
        }
        //rust 1-char operators
        if ('!%&*+-/<>@^|?'.includes(char)) {
            return [TokenCode.OPERATOR, 1]
        }

        //Punctuation: () [] {} ; , . : 
        if ('()[]{};,.:'.includes(char)) {
            return [TokenCode.PUNCTUATION, 1]
        }

        //String Literals can be either single or double quoted.
        //['STRING', /^'(?:[^'\\]|\\.)*'/],
        if (char == "'" || char == '"') {
            const quoteChar = char
            const endQuotePos = this.untilUnescaped(quoteChar, 1)
            //return new Token 'LITERAL_STRING' 
            return [TokenCode.LITERAL_STRING, endQuotePos + 1] //includes opening and closing quotes
        }

        //Regex tokens are regular expressions. The javascript producer, just passes the raw regex to JavaScript.
        //['REGEX', /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/],
        //if chunk.startsWith('/') and chunk.indexOf('/',1) isnt -1
        //if (chunk.startsWith('/') && chunk.indexOf('/', 1) !== -1) {
        //    //var regexpContents = PMREX.quotedContent(chunk)
        //    var regexpContents = PMREX.quotedContent(chunk)
        //    //var regexpExpr:string = chunk.slice(0,regexpContents.length+2) //include quote-chars: / & /
        //    var regexpExpr = chunk.slice(0, regexpContents.length + 2)
        //    //var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length),"gimy")
        //    var regexpFlags = PMREX.whileRanges(chunk.slice(regexpExpr.length), 'gimy')
        //    //return new Token('REGEX', regexpExpr & regexpFlags)
        //    return new Token('REGEX', regexpExpr + regexpFlags)
        //}

        //**Numbers** can be either in hex format (like `0xa5b`) or decimal/scientific format (`10`, `3.14159`, or `10.02e23`).
        //As in js, all numbers are floating point.

        //['NUMBER',/^0x[a-f0-9]+/i ],
        //['NUMBER',/^[0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?/i],

        //Identifiers (generally variable names), must start with a letter, `$`, or underscore.
        //Subsequent characters can also be numbers. Unicode characters are supported in variable names.
        //['IDENTIFIER',/^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/] ]
        //a IDENTIFIER starts with A-Z a-z (a unicode codepoint), $ or _

        //note we checked for numbers above
        const endIdentifier = this.whileRanges('A-Za-z0-9\x7F-\xFF$_')
        if (endIdentifier) {
            return [TokenCode.WORD, endIdentifier]
        }

        throw new Error("unrecognized token")
    }

    /**
     * helper function to get comments attached after the semicolon in the same line of a statement
     * @param separator
     */
    getAttachedCommentAfter(separator: string): string {
        this.savePosition()
        this.skipWhiteSpace()
        if (this.token.value == separator) {
            this.skipWhiteSpace()
            if (this.token.tokenCode == TokenCode.COMMENT) {
                //comment after the separator, on the same line (no NEWLINE)
                this.discardSavedPosition()
                return this.token.value
            }
        }
        //if ;//comment not found - rewind
        this.restoreSavedPosition()
    }

    /**
     * helper function consume comments, return string
     */
    consumeCommentsAndAttr(storeInList: string[]): void {
        while (this.token.tokenCode == TokenCode.COMMENT || this.token.tokenCode == TokenCode.ATTRIBUTE) {
            storeInList.push(this.token.value)
            this.advance()
        }
    }

    /**
     * Init all the options for the tokenizer
     * @param options
     */
    constructor() {

        //this.project = project

        //use same options as compiler

        this.BOFToken = new Token(this, TokenCode.BOF, '', 0, 0)
        this.EOFToken = new Token(this, TokenCode.EOF, '', 0, 0)

        //stringInterpolationChar starts for every file the same: "#"
        //can be changed in-file with `tokenizer options` directive

        //.hardError = null # stores most significative (deepest) error, when parsing fails
        this.hardError = null

    }

    //--------
    private initTokenList() {
        this.savedPositions = []
        this.cachedTokens = []
        this.token = this.BOFToken
        if (this.autoSkipWhitespaceAndNewLine) {
            this.advance()
            this.skipWhiteSpaceAndNewLine()
        }
    }

    // ---------------------------
    startFromString(code: string) {
        this.readString = code
        this.initTokenList()
    }

    // ---------------------------
    /**
     * attach a file as input for the tokenizer
     * @param filename
     */
    openFile(filename: string): void {

        this.filename = filename

        this.file = new UTF8FileReader()
        this.file.open(filename, 8 * 1024) 

        //read the first chunk
        this.readString = this.file.readChunk()
        //start with Token:BOF
        this.initTokenList()
    }

    // ---------------------------
    savePosition() {
        this.savedPositions.push(this.token)
    }
    // ---------------------------
    discardSavedPosition(): void {
        this.savedPositions.pop() //discard saved pos
    }
    // ---------------------------
    /**
     * rewind the token stream to the last saved position
     * */
    restoreSavedPosition(): void {
        this.token = this.savedPositions.pop() //go back to saved position
    }

    //------------------------------
    prevToken(n: number = 1) {
        //veo si el actual est en el cache
        const inxInCached = this.indexInCached()
        if (inxInCached <= n - 1) { //si n=1 y esta en el index 0 (o no est), no se puede 
            throw new Error("Cant read previous [current - " + n + "] token")
        }
        //return tok at [current-n]
        return this.cachedTokens[inxInCached - n]
    }

    // ---------------------------
    rewind(n: number = 1) {
        const prev = this.prevToken(n)
        //do rewind
        this.token = prev
        logger.debug('<<REW -' + n, this.token.toStringDebug())
    }

    // ---------------------------
    private cacheOneMoreToken(): Token {

        const newToken = this.readNewToken()
        this.cachedTokens.push(newToken)
        return newToken
    }

    // ---------------------------
    private indexInCached() {
        //search if current token is in cached (from the last one to the first)
        for (let inx = this.cachedTokens.length - 1; inx >= 0; inx--) {
            const t = this.cachedTokens[inx]
            if (t.line == this.token.line && t.col == this.token.col) return inx
        }
        return -1
    }

    // ---------------------------
    /**
     * peek next token
     * */
    nextToken(): Token {

        //veo si est en el cache
        const inxInCached = this.indexInCached()
        if (inxInCached > 0 && inxInCached + 1 < this.cachedTokens.length) {
            return this.cachedTokens[inxInCached + 1]
        }
        //si no est agrego uno al cache y retorno ese
        return this.cacheOneMoreToken()
    }

    // ---------------------------
    skipWhiteSpaceAndNewLine() {
        //skip newlines & whitespace
        while (this.token.tokenCode == TokenCode.NEWLINE || this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken()
        }
    }
    // ---------------------------
    skipNewLines() {
        //skip newlines
        while (this.token.tokenCode == TokenCode.NEWLINE) {
            this.token = this.nextToken()
        }
    }
    // ---------------------------
    skipWhiteSpace() {
        //skip whitespace
        while (this.token.tokenCode == TokenCode.WHITESPACE) {
            this.token = this.nextToken()
        }
    }
    // ---------------------------
    advance(): string {
        if (this.token.tokenCode == TokenCode.EOF) throw ("asked for a token after EOF")
        //set next as current 
        this.token = this.nextToken()
        if (this.autoSkipWhitespaceAndNewLine) this.skipWhiteSpaceAndNewLine()
        return this.token.value
    }

    //--------------------------
    curPosString(): string {
        return this.curReadLine + ':' + this.curReadCol
    }

    //--------------------------
    private consumeStringFromRead(endPos: number): string {
        const result = this.readString.slice(0, endPos)
        this.readString = this.readString.slice(endPos)
        if (this.readString.length < 8 * 1024 && this.file && this.file.isOpen) {
            this.readString += this.file.readChunk()
        }
        return result
    }

    //--------------------------
    /**
     * returns position in this.readString or this.readString.length if not found
     * @param what what to search
     */
    private findRead(what: string): number {
        const foundPos = this.readString.indexOf(what)
        if (foundPos < 0) return this.readString.length
        return foundPos
    }

    //--------------------------
    /**
     * creates a new token from @endPos chars from readLine
     * and also advances curLine and curCol
     * @param type
     * @param endPos
     */
    private createTokenUpToPos(type: TokenCode, endPos: number): Token {
        const result = new Token(this, type, this.consumeStringFromRead(endPos), this.curReadLine, this.curReadCol)
        if (type == TokenCode.NEWLINE) {
            this.curReadLine++
            this.curReadCol = 0
        }
        else if (type == TokenCode.COMMENT) {
            const internalNewLinesCount = result.value.split(/\r\n|\r|\n/).length
            if (internalNewLinesCount) {
                this.curReadLine += internalNewLinesCount-1
                this.curReadCol = 0
            }
        }
        else {
            this.curReadCol += endPos
        }

        //#debug
        if (logger.debugEnabled) logger.debug('>>>READ', `${result.line}:${result.col}`, result.toString())

        return result
    }

    //--------------------------
    private untilNewLine(): number {
        let endPos = this.findRead("\n")
        if (this.readString.charAt(endPos - 1) == '\r') endPos--
        return endPos
    }

    //--------------------------
    private readNewToken(): Token {

        if (this.readString.length == 0) return this.EOFToken

        try {
            const [tokenCode, endPos] = this.recognizeToken()
            return this.createTokenUpToPos(tokenCode, endPos)
        }
        catch (ex) {
            //add current position to error message
            throw new Error(ex.message + `@${this.filename}:${this.curReadLine}:${(this.curReadCol)}`)
        }

    }

    // ---------------------------
    //   function whileUnescaped(chunk:string,endChar:string) returns number
    // ---------------------------
    /**
     *  returns position of unescaped endChar, starting from start
     * @param endChar
     * @param fromPos
     */
    untilUnescaped(endChar: string, fromPos: number) {

        //advance until unescaped endChar
        //return pos of endChar 
        // throws id endChar not found

        //var pos = 0
        let pos = fromPos
        while (true) {

            //find the next quote
            const inx = this.readString.indexOf(endChar, pos)
            //if inx is -1, fail with 'missing closing quote-char: #{endChar} ' // closer not found
            if (inx === -1) { throw new Error(`missing closing quote-char: ${endChar}`) }

            //quote found
            pos = inx

            //check if escaped with '\'
            if (inx > 0 && this.readString.charAt(inx - 1) === '\\') {
                //seems escaped, let's see if the escape is escaped
                let countEscape = 1
                while (inx > countEscape && this.readString.charAt(inx - 1 - countEscape) === '\\') {
                    countEscape++
                }
                //how many escapes?
                if (countEscape % 2 === 0) { //even, means escaped-escapeChar, means: not escaped
                    break //we found the closing quote
                }
                else {
                    //odd number means escaped quote, so it's not the closing quote yet
                    pos = inx + 1
                }
            }
            else {
                //not escaped
                break //we found the closing quote
            }
        }// loop looking for the closing quote

        return pos
    }

    /**
     * Helper functions. simplified regex over this.readString
     * @param rangesStr
     */
    static parseRanges(rangesStr) {

        //Range examples:

        //* "1-9" means all chars between 1 and 9 (inclusive)
        //* "1-9J-Z" means all chars between 1 and 9 or between "J" and "Z"
        //* "1-9JNW" means all chars between 1 and 9, a "J" a "N" or a "W"

        //This function returns a normalized range string without "-"
        //and composed always from ranges:
        //
        //    "1-9" => "19"
        //    "1-9J-Z" => "19JZ"
        //    "1-9JNW" => "19JJNNWW"

        //var result = ""
        let result = ''

        let ch = undefined
        let inx = 0
        while (inx < rangesStr.length) {
            ch = rangesStr.charAt(inx)
            result += ch
            if (rangesStr.charAt(inx + 1) === '-') {
                inx++
                result += rangesStr.charAt(inx + 1)
            }
            else {
                result += ch //same char twice
            }
            inx++
        }

        return result
    }

    whileRanges(rangesStr: string, startPos: number = 0): number {

        //whileRanges, advance while the char is in the ranges specified.
        //will return pos of first char not in range, or entire string if all chars are in ranges
        //e.g.: whileRanges("123ABC","0-9") will return 3:"A"
        //e.g.: whileRanges("123ABC","0-9A-Z") will return 6:{EOS} because all chars are in range

        const len = this.readString.length

        //normalize ranges
        const ranges = Lexer.parseRanges(rangesStr)

        //advance while in any of the ranges
        let inx = startPos
        //do while inx<len
        while (inx < len) {
            const ch = this.readString.charAt(inx)
            let isIn = false
            //check all ranges
            const upTo = ranges.length - 1
            for (let r = 0; r <= upTo; r += 2) {
                if (ch >= ranges.charAt(r) && ch <= ranges.charAt(r + 1)) {
                    isIn = true
                    break
                }
            }

            if (!isIn) { break }
            inx++
        }

        return inx
    }
}

'''
'''--- src/lib/Parser/ASTBase.ts ---

//This module defines the base abstract syntax tree node used by the grammar.
//It's main purpose is to provide utility methods used in the grammar
//for **req**uired tokens, **opt**ional tokens
//and comma or semicolon **Separated Lists** of symbols.

import { TokenCode } from '../Lexer/Lexer'
import { ControlledError } from '../util/ControlledError'

import { logger } from '../util/logger'
import { Parser } from './Parser'
import { TypeAnnotation} from './Grammar'
import { EOL } from 'os'

export class ASTBase {

    owner: Parser
    parent: ASTBase
    children: ASTBase[] = []
    keyword: string
    name: string
    typeAnnotation: TypeAnnotation
    //AST node position in source
    sourceLineNum
    sourceColumn
    //wile-parsing info
    locked: boolean
    commentsAndAttr: string[] //comments and #attributes
    attachedComment: string
    //extraInfo // if parse failed, extra information
    extraInfo
    isPublic: boolean = false
    isMut: boolean = false
    isAddressOf: boolean
    nativeSuffixes: ASTBase // to_vec, as_u128, .map, .collect etc.

    constructor(parent, name) {
        this.parent = parent
        this.name = name

        //Get owner from parent
        if (parent) {

            this.owner = parent.owner

            //Remember this node source position.
            //Also remember line index in tokenized lines, and indent
            if (this.owner) {
                //this.sourceLineNum = this.lexer.sourceLineNum
                //this.column = this.lexer.token.column
                //this.indent = this.lexer.indent
                //this.lineInx = this.lexer.lineInx
            }
        }
    }

    // ---------------------------
    lock() {
        //**lock** marks this node as "locked", meaning we are certain this is the right class
        //for the given syntax. For example, if the `FunctionDeclaration` class see the token `function`,
        //we are certain this is the right class to use, so we 'lock()'.
        //Once locked, any **req**uired token not present causes compilation to fail.

        //.locked = true
        this.locked = true
    }
    // ---------------------------
    getParent(searchedClass) {
        //**getParent** method searchs up the AST tree until a specfied node class is found

        //var node = this.parent
        let node = this.parent
        //while node and node isnt instance of searchedClass
        while (node && !(node instanceof searchedClass)) {
            //node = node.parent # move to parent
            node = node.parent
        }// end loop
        //return node
        return node
    }
    // ---------------------------
    positionText() {
        if (!this.owner) { return '(compiler-defined)' }
        return `${this.owner.lexer.filename}:${this.sourceLineNum}:${this.sourceColumn || 0}`
    }
    // ---------------------------
    toString() {
        return `[${this.constructor.name}]` + (this.keyword ? this.keyword + ' ' : '') + this.name
    }
    // ---------------------------
    sayErr(msg) {
        logger.error(this.positionText(), msg)
    }
    // ---------------------------
    warn(msg) {
        logger.warning(this.positionText(), msg)
    }
    // ---------------------------
    throwError(msg) {
        //**throwError** add node position info and throws a 'controlled' error.

        //A 'controlled' error, shows only err.message

        //A 'un-controlled' error is an unhandled exception in the compiler code itself,
        //and it shows error message *and stack trace*.

        logger.throwControlled(`${this.positionText()}. ${msg}`)
    }
    // ---------------------------
    throwParseFailed(msg) {
        //throws a parseFailed-error

        //During a node.parse(), if there is a token mismatch, a "parse failed" is raised.
        //"parse failed" signals a failure to parse the tokens from the stream,
        //however the syntax might still be valid for another AST node.
        //If the AST node was locked-on-target, it is a hard-error.
        //If the AST node was NOT locked, it's a soft-error, and will not abort compilation
        //as the parent node will try other AST classes against the token stream before failing.

        //var cErr = new ControlledError("#{.lexer.posToString()}. #{msg}")
        const cErr = new ControlledError(`${this.owner.lexer.token.posToString()}. ${msg}`)
        cErr.soft = !(this.locked)
        throw cErr
    }
    // ---------------------------
    parse() {
        //abstract method representing the TRY-Parse of the node.
        //Child classes _must_ override this method
        this.throwError('ASTBase parse is abstract')
    }

    // ---------------------------
    /**produce():string is the method to produce target code for this node.
     * derived classes _should_ override this, if the default production isnt: this.name
     * Default behavior is to
     * recursively produce the entire sub-tree to a UTF file
     * 
     */
    produce(): void {
        this.owner.codeWriter.write(this.name)
        this.produceChildren()
    }

    produceChildren(separator?): void {
        const o=this.owner.codeWriter
        let inx=0
        for (const child of this.children) {
            if (inx > 0 && separator) o.write(separator)
            if (separator && separator.includes(EOL)) o.write(' '.repeat(o.indent))
            child.writeComments()
            child.produce()
            inx++
        }
        //if (separator == EOL) o.write(separator)
    }

    /**
     * output all node children as the body of a function
     * indented, one on each line
     * */
    produceBody(indent: number = 4): void {
        const o = this.owner.codeWriter
        o.newLine()
        o.indent += indent
        for (const child of this.children) {
            child.writeComments()
            child.produce()
            o.newLine()
        }
        o.indent -= indent
    }

    writeComments(watchForThis?: string): boolean {
        let result = false;
        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (const s of this.commentsAndAttr) {
                if (!s.startsWith("/")) this.owner.codeWriter.write('//')
                if (watchForThis && watchForThis == s) result = true;
                this.owner.codeWriter.writeLine(s)
            }
        }
        return result;
    }

    //--- helper
    tokVal(): string {
        return this.owner.lexer.token.value
    }

    // ---------------------------
    //parseDirect(key, directMap) {

    //    //We use a DIRECT associative array to pick the exact AST node to parse
    //    //based on the actual token value or type.
    //    //This speeds up parsing, avoiding parsing by trial & error

    //    //Check keyword

    //    //if directMap.get(key) into var param
    //    let param = directMap[key]
    //    if (param) {
    //        //try parse by calling .opt
    //        let statement = undefined
    //        if (param instanceof Array) {
    //            //#accept Arrays also
    //            statement = this.optList(param)
    //        }
    //        else {
    //            //#normal call
    //            statement = this.optList([param])
    //        }
    //        //return parsed statement or nothing
    //        return statement
    //    }
    //}

    // ---------------------------
    optList(list: (string | number | typeof ASTBase)[]): string | ASTBase {
        //**opt** (optional) parses optional parts of a grammar. It attempts to parse
        //the token stream using one of the classes or token types specified.
        //This method takes a variable number of arguments.
        //For example:
        //calling `.opt IfStatement, Expression, 'IDENTIFIER'`
        //would attempt to parse the token stream first as an `IfStatement`. If that fails, it would attempt
        //to use the `Expression` class. If that fails, it will accept a token of type `IDENTIFIER`.
        //If all of those fail, it will return `undefined`.

        //Method start:

        const t = this.owner.lexer.token
        //For each argument, -a class or a string-, we will attempt to parse the token stream
        //with the class, or match the token type to the string.

        //for each searched in arguments.toArray()
        for (const searched of list) {

            //skip empty, null & undefined
            if (!searched) { continue }

            let found: boolean = false

            //For strings, we check the token **value** 
            if (typeof searched === 'string') {
                const searchedString: string = searched
                found = (t.value == searchedString)
                if (found && logger.debugEnabled) {
                    logger.debug(this.constructor.name, 'matched OK:', searched, t.value)
                }
            }

            //For numbers, we assume it's a TokenCode
            else if (typeof searched === 'number') { //it's a TokenCode
                const searchedToken: TokenCode = searched as TokenCode
                found = (t.tokenCode == searchedToken)
                if (found && logger.debugEnabled) {
                    logger.debug(this.constructor.name, 'matched OK:', TokenCode[searchedToken], t.value)
                }
            }

            if (found) { //simple string/Token match
                //Ok, type/value found! now we return: token.value
                //Note: we shouldn't return the 'token' object, because returning objects (here and in js)
                //is "pass-by-reference" for the object members. You return a "pointer" to the object.
                //If we return the 'token' object, the calling function will recive a "pointer"
                //and it can inadvertedly alter the token object members in the token stream. (it should not, leads to subtle bugs)

                //Consume this token
                this.owner.lexer.advance()
                //discard saved position
                this.owner.lexer.discardSavedPosition()
                //return token value
                return t.value
            }

            else if (typeof searched === 'function') { //it's a Grammar class

                const searchedClass = searched as (typeof ASTBase)

                logger.debug(this.constructor.name, 'TRY', searchedClass.name, 'on', t.toString())

                //if the argument is an AST node class, we instantiate the class and try the `parse()` method.
                //`parse()` can throw `ParseFailed` if the syntax do not matches the parse

                //Remember the actual position, to rewind if parse soft-fails
                this.owner.lexer.savePosition()

                try {

                    //create required ASTNode, to try method parse()
                    const astNode = new searchedClass(this, t.value)
                    astNode.sourceLineNum = t.line
                    astNode.sourceColumn = t.col

                    //if it can't parse, will raise an exception
                    astNode.parse()

                    //logger.debug spaces, 'Parsed OK!->',searched.name
                    logger.debug('Parsed OK!->', searchedClass.name)

                    //discard saved position
                    this.owner.lexer.discardSavedPosition()
                    //parsed ok!, return instance
                    return astNode

                }
                catch (err) {

                    if (!(err instanceof ControlledError)) { //non-controlled error
                        //discard saved position
                        this.owner.lexer.discardSavedPosition()
                        throw err
                    }

                    //If parsing fail, but the AST node was not 'locked' on target, (that is, if it was a "soft" exception),
                    //we try other AST nodes.

                    //if err.soft => no match, try next
                    if (err.soft) {
                        this.owner.lexer.softError = err
                        logger.debug(searchedClass.name, 'parse failed.', err.message)
                        //rewind the token stream, to try other AST nodes
                        this.owner.lexer.restoreSavedPosition()
                        logger.debug('<<REW to', this.owner.lexer.token.toStringDebug())
                    }
                    else {
                        //else: it's a hard-error. The AST node were locked-on-target.
                        //We abort parsing and throw.

                        //discard saved position
                        this.owner.lexer.discardSavedPosition()

                        //# the first hard-error is the most informative, the others are cascading ones
                        //if .lexer.hardError is null, .lexer.hardError = err
                        if (this.owner.hardError === null) { this.owner.hardError = err }

                        //raise up, abort parsing
                        throw err
                    } //end if - type of error

                }//end catch

            }//end if - string/TokenCode/ASTclass

        }//end loop - try the next argument

        //No more arguments.
        //`opt` returns `undefined` if none of the arguments can be use to parse the token stream.
        return undefined
    }

    // ---------------------------
    opt(singleItem: string | typeof ASTBase): string | ASTBase {
        return this.optList([singleItem])
    }

    // ---------------------------
    /**
     * Require one of a list
     * 
     * @param list to try parsing, in order, one of the list must parse
     */
    reqList(list: (string | number | typeof ASTBase)[]): string | ASTBase {

        //**req** (required) try to parse *required* symbols of the grammar.
        //It works the same way as `opt` except that it throws an error if none of the arguments
        //can be used to parse the stream.

        //We first call `opt` to try the arguments in order.
        //If a value is returned, the parsing was successful,
        //so we just return the node that `opt` found.
        const result = this.optList(list)

        //If `opt` returned "undefined" (no match), we give the user a useful error message.
        if (!result) {
            this.throwParseFailed(`${this.constructor.name}:${this.extraInfo || ''} found ${this.owner.lexer.token.toString()} but ${ASTBase.listToString(list)} required`)
        }
        return result
    }

    // ---------------------------
    req(item: string): string {
        return this.reqList([item]) as string
    }
    // ---------------------------
    reqClass(ASTClass: typeof ASTBase): ASTBase {
        return this.reqList([ASTClass]) as ASTBase
    }
    // ---------------------------
    reqChild(ASTClass: typeof ASTBase): void {
        this.children.push(this.reqList([ASTClass]) as ASTBase)
    }
    optChild(ASTClass: typeof ASTBase): void {
        const result = this.opt(ASTClass) as ASTBase
        if (result) {
            this.children.push(result)
        }
    }
    // ---------------------------
    reqToken(tokenCode: TokenCode): string {
        return this.reqList([tokenCode]) as string
    }

    // ---------------------------
    reqOneOf(list: string[]): string {
        //(performance) check before try to parse, that the next token is in the list
        //if .lexer.token.value in arr
        if (list.includes(this.owner.lexer.token.value)) {
            return this.reqList(list) as string
        }
        else {
            this.throwParseFailed('not in list')
        }
    }

    /**
     * a [separator] separated list of [astClass] ended by [closer] 
     * 
     * the last closer is consumed
     * 
     * @param astClass
     * @param separator
     * @param closer
     */
    // ---------------------------
    optSeparatedList(astClass: typeof ASTBase, separator: string, closer: string): ASTBase[] {

        //Start optSeparatedList
        //normal separated list,
        //loop until closer found

        const result: ASTBase[] = []

        logger.debug(`optSeparatedList [${this.constructor.name}] get SeparatedList of [${astClass.name}] by '${separator}' closer:`, closer || '-no closer-')

        const startLine = this.owner.lexer.token.line

        while (true) {
            if (this.owner.lexer.token.tokenCode == TokenCode.EOF) break //break on EOF
            if (closer && this.opt(closer)) break //if closer set, and closer found, break

            //pre comments and attrs
            const preComments: string[] = []
            this.owner.lexer.consumeCommentsAndAttr(preComments)

            //get an item
            const item = this.reqClass(astClass) as ASTBase
            this.lock()

            //add item to result
            result.push(item)

            item.commentsAndAttr = preComments
            //post comments and attr - NO, se come pre comments del siguiente
            //this.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr )

            //if .opt(closer) then break #closer found
            if (this.opt(closer)) { break }

            //here, a 'separator' (comma/semicolon) means: 'there is another item'.
            //Any token other than 'separator' means 'end of list'

            //if no .opt(separator)
            if (!this.opt(separator)) {
                //# any token other than comma/semicolon means 'end of comma separated list'
                //# but if a closer was required, then "other" token is an error
                //if closer, .throwError "Expected '#{closer}' to end list started at line #{startLine}, got '#{.lexer.token.value}'"
                if (closer) { this.throwError(`Expected '${closer}' to end list started at line ${startLine}, got '${this.owner.lexer.token.value}'`) }
                break
            }

        }// try another item after the separator

        if (closer == '}') this.owner.lexer.semiNotRequired = true //semicolon not required if list closed by '}'

        return result
    }

    // ---------------------------
    reqSeparatedList(astClass: typeof ASTBase, separator: string, closer: string): ASTBase[] {
        //**reqSeparatedList** is the same as `optSeparatedList` except that it throws an error
        //if the list is empty

        //First, call optSeparatedList
        const result = this.optSeparatedList(astClass, separator, closer)
        if (result.length === 0) { this.throwParseFailed(`${this.constructor.name}: Get list: At least one [${astClass.name}] was expected`) }

        return result
    }

    //------------------------
    optPub() {
        //manage special prefixes like 'pub'
        if (this.owner.lexer.token.value == 'pub') {
            this.isPublic = true
            this.owner.lexer.advance()
        }
    }
    optAddrOf() {
        //manage special prefixes like '&'
        if (this.owner.lexer.token.value == '&') {
            this.isAddressOf = true
            this.owner.lexer.advance()
        }
    }
    optMut() {
        //manage special prefixes like 'mut'
        if (this.owner.lexer.token.value == 'mut') {
            this.isMut = true
            this.owner.lexer.advance()
        }
    }

    // ---------------------------
    /**
     * Helper function toString of an argument list to opt() or req()
     * @param args
     */
    static listToString(args: (string | number | typeof ASTBase)[]) {
        //listArgs list arguments (from opt or req). used for debugging
        //and syntax error reporting

        //var msg = []
        const msg = []
        //for each i in args
        for (const i of args) {

            //if typeof i is 'string'
            if (typeof i === 'string') {
                msg.push(`'${i}'`)
            }

            else if (i) {

                if (typeof i === 'function') {
                    msg.push(`[${i.name}]`)
                }
                else if (typeof i === 'number') {
                    msg.push(`[${TokenCode[i]}]`)
                }
                else {
                    msg.push(`<${i["name"]}>`)
                }
            }

            else {
                msg.push('[null]')
            }
        }
        return msg.join('|')
    }

    // ---------------------------
    /*
    out(list: (string | object | ASTBase)[]) {

        //*out* is a helper function for code generation
        //It evaluates and output its arguments. uses .lexer.out

        var rawOut = .lexer.outCode
        const rawOut = this.owner.outCode

        //for each item in arguments.toArray()
        for (const item of list) {

            //skip empty items
            //if no item, continue
            if (!item) { continue }

            //if it is the first thing in the line, out indentation

            //if rawOut.currLine.length is 0  and .indent > 0
            //if (rawOut.currLine.length === 0 && this.indent > 0) {
            //    //rawOut.put String.spaces(.indent)
            //    rawOut.put(' '.repeat(this.indent))
            //}

            //if it is an AST node, call .produce()

            //if item instance of ASTBase
            if (item instanceof ASTBase) {
                item.produce()
            }

            else if (item === '\n') {
                rawOut.startNewLine()
            }

            else if (typeof item === 'string') {
                rawOut.put(item)
            }
            else if (item instanceof Array) {

                //# Recursive #
                this.out(item)
            }

            else if (item instanceof Object) {

                // expected keys:
                //  COMMENT:string, NLI, CSL:Object array, freeForm, h

                //{CSL:arr} -> output the array as Comma Separated List (note: CSL can be present and undefined)

                //if item.hasProperty('CSL')
                let comment = undefined
                //var header = undefined
                if ("CSL" in item) {
                    const CSL = item["CSL"]
                    // additional keys: pre,post,separator
                    const separator = item['separator'] || ', '
                    //var freeFormMode = item.tryGetProperty('freeForm')
                    const newLineIncluded = false
                    //var actualIndent = rawOut.getIndent()

                    //for each inx,listItem in CSL
                    let inx = 0;
                    for (const listItem in CSL as object) {
                        if (inx > 0) {
                            rawOut.put(separator)
                        }
                        inx++
                        //#recurse
                        this.out([item['pre'], listItem, item['post']])
                    }

                    //if newLineIncluded # prettier generated code
                    if (newLineIncluded) {
                        //rawOut.startNewLine
                        rawOut.startNewLine()
                    }
                }

                else if ((comment = item['COMMENT']) != undefined) {
                    //# prepend // if necessary
                    if (typeof item !== 'string' || !(comment.startsWith('//'))) { rawOut.put('// ') }
                    this.out(comment)
                }

                else {
                    this.sayErr(`ASTBase method out Map|Object: unrecognized keys: ${item}`)
                }
            }

            else {
                rawOut.put(item as string)
            }

        }//end loop, next item

    }

    /*
    // ---------------------------
    outPreviousComments = function () {

        //out previous lines with comments

        //if no .sourceLineNum, return // if undefined or 0
        if (!this.sourceLineNum) { return }

        //search CODE line, immediatly previous to this
        //var prevCODElineInx = .lexer.getPrevCODEInfoLineIndex(.sourceLineNum)
        var prevCODElineInx = this.lexer.getPrevCODEInfoLineIndex(this.sourceLineNum)

        //search line previous to this (any type)
        //var endAtInx = .lexer.getInfoLineIndex(.sourceLineNum-1)
        var endAtInx = this.lexer.getInfoLineIndex(this.sourceLineNum - 1)

        // print in-between lines (comments & blank lines)
        //for lineInx=prevCODElineInx+1 to endAtInx
        var _end1 = endAtInx
        for (var lineInx = prevCODElineInx + 1; lineInx <= _end1; lineInx++) {
            //.outInfoLineAsComment lineInx
            this.outInfoLineAsComment(lineInx)
        }// end for lineInx

    }
    // ---------------------------
    outSourceLinesAsComment = function (upTo, fromLineNum) {

        //if no .lexer.options.comments, return
        if (!this.lexer.options.comments) { return }

        //default fromLineNum = .sourceLineNum // this statement
        if (fromLineNum === undefined) fromLineNum = this.sourceLineNum
        //default upTo = .sourceLineNum // this statement
        if (upTo === undefined) upTo = this.sourceLineNum

        //var startAtInx = .lexer.getInfoLineIndex(fromLineNum)
        var startAtInx = this.lexer.getInfoLineIndex(fromLineNum)
        //var endAtInx = .lexer.getInfoLineIndex(upTo)
        var endAtInx = this.lexer.getInfoLineIndex(upTo)

        //for lineInx=startAtInx to endAtInx
        var _end2 = endAtInx
        for (var lineInx = startAtInx; lineInx <= _end2; lineInx++) {
            //.outInfoLineAsComment lineInx
            this.outInfoLineAsComment(lineInx)
        }// end for lineInx

    }
    // ---------------------------

    levelIndent() {
        //show indented messaged for debugging

        //var indent = 0
        var indent = 0
        //var node = this
        var node = this.parent
        //while node.parent into node
        while (node) {
            //indent += 2 //add 2 spaces
            indent += 2
            node = node.parent
        }// end loop

        //return String.spaces(indent)
        return ' '.repeat(indent)
    }
    */

}

'''
'''--- src/lib/Parser/CodeWriter.ts ---
//public helper class CodeWriter

import * as fs from 'fs'
import * as mkPath from '../util/mkPath'
import { assert } from 'console'
import { EOL } from 'os'

export class CodeWriter {

    lineNum: number
    column: number
    currLine: string[]

    fileMode = true
    filenames = ['', '', '']
    fileIsOpen = [false, false, false]
    fHandles = [null, null, null]
    selectedStream: number = 0

    indent: number =0

    lines
    browser: boolean
    exportNamespace: boolean
    public data: any
    
    // ---------------------------
    constructor(fn1: string, data: any, fn2: string = '', fn3: string = '') {
        this.filenames = [fn1, fn2, fn3]
        this.data = data
        //Initialize output array
        this.lineNum = 1
        this.column = 1
        this.currLine = []
        this.lines = [[], [], []]
    }

    // ---------------------------
    selectOutStream (index: 0|1|2) {
        this.newLine()
        this.selectedStream= index
    }

    // ---------------------------
    write (text: string) {
        //put a string into produced code
        if (text) {
            this.currLine.push(text)
            this.column += text.length
        }
    }

    // ---------------------------
    writeLine(text: string) {
        this.write(text)
        this.newLine()
    }

    // ---------------------------
    getIndent () {
        //if no .currLine.length, return 0
        if (!this.currLine.length) { return 0 }
        return this.currLine[0].countSpaces()
    }

    // ---------------------------
    newLine () {
        //Start New Line into produced code
        //send the current line
        if (this.currLine.length) {
            if (this.fileMode) {
                if (!this.fileIsOpen[this.selectedStream]) {
                    // make sure output dir exists
                    const filename = this.filenames[this.selectedStream]
                    assert(filename)
                    mkPath.toFile(filename)
                    //open output file
                    this.fHandles[this.selectedStream] = fs.openSync(filename, 'w')
                    this.fileIsOpen[this.selectedStream] = true
                }

                const fd = this.fHandles[this.selectedStream]
                //save all the parts to file
                if (this.indent > 0) fs.writeSync(fd, ' '.repeat(this.indent))
                //for each part in .currLine
                for (const part of this.currLine) {
                    fs.writeSync(fd, part)
                }
                //close the line: "\n"
                fs.writeSync(fd, EOL)
            }
            else {
                //not fileMode
                //store in array
                this.lines[this.selectedStream].push(this.currLine.join(''))
            }

            if (this.selectedStream=== 0) {
                this.lineNum++
            }

        }

        this.clearCurrentLine()
    }

    //----------------------------
    // clear current working line
    clearCurrentLine() {
        //clear current line
        this.currLine = []
        this.column = 1
    }
    //----------------------------
    // return current working line
    getCurrentLine() {
        return this.currLine.join("")
    }

    // ---------------------------
    ensureNewLine () {
        //if there's something on the line, start a new one
        if (this.currLine.length) { this.newLine() }
    }

    // ---------------------------
    blankLine () {
        this.newLine()
        this.currLine.push('')
        this.newLine()
    }

    // ---------------------------
    getResult (inx: 0|1|2 = 0) {
        //get result and clear memory

        if (inx === undefined) inx = 0

        this.selectedStream= inx
        //#close last line
        this.newLine()
        return this.lines[inx]
    }

    // ---------------------------
    close () {

        //save last pending line
        this.newLine()

        if (this.fileMode) {
            for (let inx = 0; inx <= 2; inx++) {
                if (this.fileIsOpen[inx]) {
                    fs.closeSync(this.fHandles[inx])
                    this.fileIsOpen[inx] = false
                }
            }

        }
    }

}

'''
'''--- src/lib/Parser/Grammar.ts ---
/* 
 * This Grammar is based on [Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)
 * *with extensions*.
*/

//Grammar Meta-Syntax
//-------------------

//Each Grammar class, contains a 'grammar definition' as reference.
//The meta-syntax for the grammar definitions is an extended form of
//[Parsing Expression Grammars (PEGs)](http://en.wikipedia.org/wiki/Parsing_expression_grammar)

//The differences with classic PEG are:
//* instead of `Symbol <- definition`, we use `Symbol: definition` (colon instead of arrow)
//* we use `[Symbol]` for optional symbols instead of `Symbol?` (brackets also groups symbols, the entire group is optional)
//* symbols upper/lower case has meaning
//* we add `(Symbol,)` for `comma separated List of` as a powerful syntax option

//Meta-Syntax Examples:

//`function`     : all-lowercase means the literal word: "function"<br>
//`":"`              : literal symbols are quoted<br>
//`ReturnStatement`  : CamelCase is reserved for composed, non-terminal symbol<br>

//`IDENTIFIER`,`OPER` : all-uppercase denotes a entire class of symbols<br>
//`NEWLINE`,`EOF`     : or special unprintable characters<br>

//`[to]`               : Optional symbols are enclosed in brackets<br>
//`(var|let)`          : The vertical bar represents ordered alternatives<br>

//`(Oper Operand)`     : Parentheses groups symbols<br>
//`(Oper Operand)*`    : Asterisk after a group `()*` means the group can repeat (meaning one or more)<br>
//`[Oper Operand]*`    : Asterisk after a optional group `[]*` means *zero* or more of the group.<br>

//`[Expression,]` : means: "optional comma separated list of Expressions".<br>
//`Body: (Statement;)` : means "Body is a semicolon-separated list of statements".<br>

//Full Meta-Syntax Example:

//`PrintStatement: print [Expression,]`

//It reads: composed symbol `PrintStatement` is conformed by the word `print` followed by
//an _optional_ comma-separated list of `Expression`

//###More on comma-separated lists

//Let's analyze the example: `PrintStatement: print [Expression,]`

//`[Expression,]` means *optional* **comma "Separated List"** of Expressions.
//Since the comma is inside a **[ ]** group, it means the entire list is optional.

//Another example:

//`VariableDecl: IDENTIFIER ["=" Expression]`

//`VarStatement: var (VariableDecl,)`

//It reads: composed symbol `VarStatement` is conformed by the word `var` followed by
//a comma-separated list of `VariableDecl` (at least one)

//The construction `(VariableDecl,)` means: **comma "Separated List"** of `VariableDecl`

//Since the comma is inside a **( )** group, it means _at least one VariableDecl_ is required.

import { ASTBase } from './ASTBase'
import { logger } from '../util/logger'
import { TokenCode } from '../Lexer/Lexer'
import { Parser } from './Parser'
import { EOL } from 'os'

//Reserved Words
//---------------

//Words that are reserved and cannot be used as variable or function names
const RESERVED_WORDS = ['fn', 'async', 'class', 'if', 'then', 'else', 'null', 'true', 'false',
    'new', 'loop', 'while', 'crate', 'for', 'to', 'break', 'continue',
    'return', 'try', 'catch', 'throw', 'raise', 'fail', 'exception', 'finally',
    'mut', 'var', 'let',
    'yield', 'await', 'self', 'super', 'export',
    'async', 'short', 'long', 'int',
    'unsigned', 'void', 'null', 'bool', 'assert']

//Operators precedence
//--------------------
//The order of symbols here determines operators precedence
//var operatorsPrecedence = [
//'++','--', 'unary -', 'unary +', 'bitnot' ,'bitand', 'bitor', 'bitxor'
//,'>>','<<'
//,'new','type of','instance of','has property'
//,'*','/','%','+','-','&'
//,'into','in'
//,'>','<','>=','<=','is','<>','!==','like'
//,'no','not','and','but','or'
//,'?',':'
//]
const OPERATORS_PRECEDENCE = ['&', '&mut', '*',
    '!', '?',
    'unary -', 'unary +',
    'as',
    '*', '/', '%', '&', '|', '^', '>>', '<<',
    '+', '-',
    '==', '!=', '>', '<', '>=', '<=',
    '||', '&&',
    '..']

//--------------------------
//Grammar - AST Classes
//================================
//You'll find a class for each syntax construction the parser accepts

/**
 * can include namespace::namespace::name
 * */
export class Identifier extends ASTBase {
    // ---------------------------
    parse() {

        this.name = this.reqToken(TokenCode.WORD)
        while (this.opt('::')) {
            this.name += '::'
            this.name += this.reqToken(TokenCode.WORD)
        }
    }
}

//## Oper

//```
//Oper: ('~'|'&'|'^'|'|'|'>>'|'<<'
//|'*'|'/'|'+'|'-'|mod
//|instance of|instanceof
//|'>'|'<'|'>='|'<='
//|is|'==='|isnt|is not|'!=='
//|and|but|or
//|[not] in
//|(has|hasnt) property
//|? true-Expression : false-Expression)`
//```

//An Oper sits between two Operands ("Oper" is a "Binary Operator",
//different from *UnaryOperators* which optionally precede a Operand)

//If an Oper is found after an Operand, a second Operand is expected.

//Operators can include:
//* arithmetic operations "*"|"/"|"+"|"-"
//* boolean operations "and"|"or"
//* `in` collection check.  (js: `indexOx()>=0`)
//* instance class checks   (js: instanceof)
//* short-if ternary expressions ? :
//* bit operations (|&)
//* `has property` object property check (js: 'propName in object')

//    public class Oper extends ASTBase
// constructor
export class Oper extends ASTBase {
    negated
    left: Operand
    right: Operand
    pushed
    precedence
    intoVar
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.OPERATOR)
        this.lock()

        //A) validate double-word opers

        //A.1) validate `instance of`

        //if .name is 'instance'
        if (this.name === 'instance') {

            //.req('of')
            this.req('of')
            //.name = "instance of"
            this.name = 'instance of'
        }
        //if .name is 'instance'

        else if (this.name === 'has') {

            //.negated = .opt('not')? true:false # set the 'negated' flag
            this.negated = this.opt('not') ? true : false
            //.req('property')
            this.req('property')
            //.name = "has property"
            this.name = 'has property'
        }
        //else if .name is 'has'

        else if (this.name === 'hasnt') {

            //.req('property')
            this.req('property')
            //.negated = true # set the 'negated' flag
            this.negated = true
            //.name = "has property"
            this.name = 'has property'
        }
        //else if .name is 'hasnt'

        else if (this.name === 'not') {

            //.negated = true # set the 'negated' flag
            this.negated = true
            //.name = .req('in','like') # require 'not in'|'not like'
            //this.name = this.req('in', 'like');
        }

        //A.4) handle 'into [var] x', assignment-Expression

        //if .name is 'into' and .opt('var')
        if (this.name === 'into' && this.opt('var')) {

            //.intoVar = '*r' //.right operand is "into" var
            this.intoVar = '*r'
            //.getParent(Statement).intoVars = true #mark owner statement
            // this.getParent(Statement).intoVars = true;
        }

        else if (this.name === 'isnt') {

            // set the 'negated' flag
            this.negated = true
            //treat as 'Negated is'
            this.name = 'is'
        }

        //else if .name is 'isnt'
        else if (this.name === 'instanceof') {

            //.name = 'instance of'
            this.name = 'instance of'
        }

        //C) Variants on 'is/isnt...'
        //if .name is 'is' # note: 'isnt' was converted to 'is {negated:true}' above
        if (this.name === 'is') {
            //C.1) is not<br>
            //Check for `is not`, which we treat as `isnt` rather than `is ( not`.

            //if .opt('not') # --> is not/has not...
            if (this.opt('not')) {

                //if .negated, .throwError '"isnt not" is invalid'
                if (this.negated) { this.throwError('"isnt not" is invalid') }
                //.negated = true # set the 'negated' flag
                this.negated = true
            }

            //end if

            //C.2) accept 'is/isnt instance of' and 'is/isnt instanceof'

            //if .opt('instance')

            //C.2) accept 'is/isnt instance of' and 'is/isnt instanceof'

            //if .opt('instance')
            if (this.opt('instance')) {

                //.req('of')
                this.req('of')
                //.name = 'instance of'
                this.name = 'instance of'
            }
            //if .opt('instance')

            else if (this.opt('instanceof')) {
                //this.name = 'instance of'
            }

        }

        //Get operator precedence index
        this.getPrecedence()
    }

    // ---------------------------
    getPrecedence = function () {
        this.precedence = OPERATORS_PRECEDENCE.indexOf(this.name)
        if (this.precedence === -1) {
            this.sayErr(`OPER '${this.name}' not found in the operator precedence list`)
        }
    }

    //----------------
    produce() {
        this.left?.produce()
        this.owner.codeWriter.write(' ' + this.name + ' ')
        this.right?.produce()
    }
}
// end class Oper

//public class UnaryOper extends Oper
// constructor
export class UnaryOper extends Oper {
    // ---------------------------
    parse() {
        this.name = this.reqOneOf(['+', '-', '!'])
        //Lock, we have a unary oper
        this.lock()

        //Rename - and + to 'unary -' and 'unary +',
        //if .name is '-'
        if (this.name == '-' || this.name == '+') {
            this.precedence = 0
        }
        else {
            //calculate precedence - Oper.getPrecedence()
            this.getPrecedence()
        }
    }
}
// end class UnaryOper

//## NumberLiteral
//`NumberLiteral: [0-9_.u] | '0x[0-9a-fA-F] | 0b[0-1][u0-9] `
export class NumberLiteral extends ASTBase {
    tokenCode: TokenCode //save token format: decimal, hexa, binary
    // ---------------------------
    parse() {
        this.tokenCode = this.owner.lexer.token.tokenCode
        this.name = this.reqList([TokenCode.NUMBER, TokenCode.HEXANUMBER, TokenCode.BINARYNUMBER]) as string
        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }
}
// end class NumberLiteral

//## StringLiteral
//`StringLiteral: '"' [ any* | '\"' ] '"' | ''' [ any* | '\'' ] '''
//A string constant token. Can be anything the lexer supports, including single or double-quoted strings.
//The token include the enclosing quotes
export class StringLiteral extends ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.LITERAL_STRING)
        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }
    // ---------------------------
    unquoted(): string {
        return this.name.slice(1, -1)
    }
}
// end class StringLiteral

//## RegExpLiteral
//`RegExpLiteral: REGEX`
//A regular expression token constant. Can be anything the lexer supports.
export class RegExpLiteral extends ASTBase {
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.LITERAL_STRING)
        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }
}
// end class RegExpLiteral

export class Operand extends ASTBase {
    //-------------------------
    //value is at children[0]
    // -------------------------
    parse() {

        //Let's look for operands in a expression, i.e: "a" and "b" in  "a+b*5"

        const t = this.owner.lexer.token

        if ([TokenCode.NUMBER, TokenCode.HEXANUMBER, TokenCode.BINARYNUMBER].includes(t.tokenCode)) {
            this.children.push(this.reqClass(NumberLiteral))
            return //**** early exit
        }
        if (t.tokenCode == TokenCode.LITERAL_STRING) {
            this.children.push(this.reqClass(StringLiteral))
            return //**** early exit
        }

        if (t.value == "match") {//Rust match expression
            this.name = 'match'
            this.children.push(this.reqClass(MatchExpression))
            return //**** early exit
        }

        if (t.value == "(") { // parent expression
            this.name = 'parentized'
            this.children.push(this.reqClass(ParenExpression))
            return //**** early exit
        }

        //here, the OPERAND is a var reference, fn-call or macro!
        this.owner.lexer.savePosition()
        const vr = this.reqClass(VarRef)

        //let's see if this is a macro! invocation
        if (this.owner.lexer.token.value == '!') { //it's a macro!
            this.owner.lexer.restoreSavedPosition()
            this.keyword = "macro!"
            this.name = vr.name
            this.children.push(this.reqClass(MacroInvocation))
            return //**** early exit
        }

        //it's not a macro, last options are var reference or fn-call 
        //the vr is good for both
        this.owner.lexer.discardSavedPosition()

        //let's see if this is a struct instantiation expression
        //rust's struct instantiation can only be detected by 'Self {...' or 'Declared-Struct-Type-Name {...' used as a statement
        //ojo ambiguos if we're in [match expr '{' ... '}' ] - commented
        if (this.owner.lexer.token.value == "{"
            && this.parent.parent.name != 'match'
            && this.parent.parent.name != 'if'
        ) { //it's a struct Instantiation
            const objectLiteral = this.reqClass(ObjectLiteral)
            objectLiteral.name = vr.name
            objectLiteral.keyword = "struct-instantiation"
            this.children.push(objectLiteral)
            return //**** early exit
        }

        //last option, this is just a varRef acting as a expression
        this.name = vr.name
        this.children.push(vr)
    }

    //--------
    produce() {
        this.produceChildren();
    }
}
// end class Operand

export class FunctionArgument extends ASTBase {
    expression: Expression
    // ---------------------------
    parse() {
        this.lock()
        if (this.owner.lexer.token.value == "_") { //  _ => wildcard, ignore param
            this.name = "_"
            this.owner.lexer.advance()
            return //early exit
        }
        this.optAddrOf()
        this.optMut()
        this.expression = this.reqClass(Expression) as Expression
    }
}// end class FunctionArgument

//-----------
//## Expression

//`Expression: [UnaryOper] Operand [Oper [UnaryOper] Operand]*`

//The expression class parses intially a *flat* array of nodes.
//After the expression is parsed, a *Expression Tree* is created based on operator precedence.

//public class Expression extends ASTBase
// constructor
export class Expression extends ASTBase {
    root: UnaryOper | Oper | Operand
    operandCount
    ternaryCount
    // ---------------------------
    parse() {

        const arr = []
        this.operandCount = 0
        this.ternaryCount = 0

        //(performance) Fast exit for no-expression `);{` => end of expression.
        if (');}'.includes(this.owner.lexer.token.value)) {
            return //early exit
        }

        while (true) {

            //Get optional unary operator
            //(performance) check token first

            if (['+', '-', '!'].includes(this.owner.lexer.token.value)) {
                const unaryOper = this.opt(UnaryOper)
                if (unaryOper) {
                    arr.push(unaryOper)
                    this.lock()
                }
            }

            //Get operand
            arr.push(this.reqClass(Operand))
            this.operandCount++
            this.lock()

            //(performance) Fast exit for common tokens: `=> = , ] ) ; { ` => end of expression.
            if (this.owner.lexer.token.value == "=>" || '=,]);{'.includes(this.owner.lexer.token.value)) {
                break //early exit
            }

            //Try to parse next token as an operator
            const oper = this.opt(Oper)
            //if no oper then break # no more operators, end of expression
            if (!oper) { break }

            //If it was an operator, store, and continue because we expect another operand.
            //(operators sits between two operands)
            arr.push(oper)
        }

        ////Fix 'new' calls. Check parameters for 'new' unary operator, for consistency, add '()' if not present,
        ////so `a = new MyClass` turns into `a = new MyClass()`
        //for (let index = 0, item; index < arr.length; index++) {
        //    item = arr[index]
        //    //if item instanceof UnaryOper and item.name is 'new'
        //    if (item instanceof UnaryOper && item.name === 'new') {
        //        const operand = arr[index + 1]
        //        if (operand.name instanceof VarRef) {
        //            const valueRef = operand.name
        //            //if no varRef.executes, varRef.addAccessor new FunctionAccess(this)
        //            if (!valueRef.executes) { valueRef.addAccessor(new FunctionAccess(this, '')) }
        //        }
        //    }
        //}// end for each in arr

        //Now we create a tree from .arr[], based on operator precedence
        //.growExpressionTree(arr)
        this.growExpressionTree(arr)
    }

    // ---------------------------
    growExpressionTree = function (arr) {

        //do while arr.length > 1
        while (arr.length > 1) {

            //find the one with highest precedence (lower number) to push down
            //(on equal precedende, we use the leftmost)

            let pos = -1
            let minPrecedenceInx = 100
            for (let inx = 0, item; inx < arr.length; inx++) {
                item = arr[inx]

                //debug "item at #{inx} #{item.name}, Oper? #{item instanceof Oper}. precedence:",item.precedence

                if (item instanceof Oper) {

                    //if not item.pushed and item.precedence < minPrecedenceInx
                    if (!(item.pushed) && item.precedence < minPrecedenceInx) {
                        pos = inx
                        minPrecedenceInx = item.precedence
                    }
                }
            }
            //end for

            //#control
            if (pos < 0) {
                this.throwError("can't find highest precedence operator")
            }

            //Un-flatten: Push down the operands a level down
            const oper = arr[pos]
            oper.pushed = true
            if (oper instanceof UnaryOper) {
                //#control
                if (pos === arr.length) {
                    this.throwError(`can't get RIGHT operand for unary operator '${oper}'`)
                }

                //# if it's a unary operator, take the only (right) operand, and push-it down the tree
                oper.right = arr.splice(pos + 1, 1)[0]
            }

            else {
                //#control
                if (pos === arr.length) {
                    this.throwError(`can't get RIGHT operand for binary operator '${oper}'`)
                }
                if (pos === 0) {
                    this.throwError(`can't get LEFT operand for binary operator '${oper}'`)
                }

                //# if it's a binary operator, take the left and right operand, and push them down the tree
                oper.right = arr.splice(pos + 1, 1)[0]
                oper.left = arr.splice(pos - 1, 1)[0]
            }

            //loop #until there's only one operator
        }

        //Store the root operator
        this.root = arr[0]
    }

    static checkNativeRustConversionMapCollect(node: ASTBase) {
        if (node.tokVal() == ".") {
            node.nativeSuffixes = node.reqClass(RustNativeSuffixes)
        }
    }
}
// end class Expression

export class RustNativeSuffixes extends ASTBase {
    // ---------------------------
    parse() {
        //veo si al final de la expresion hay uno o mas .into() o .as_u128() .to_vec() .map() . collect() etc, 
        // que son sufijos de conversiones de rust y de map()

        while (this.owner.lexer.token.value == '.') {
            this.owner.lexer.advance()
            const suffix = this.reqClass(Identifier)
            this.req("(")
            if (suffix.name == "map") { //.map() param is a closure
                suffix.reqChild(RustClosure)
            }
            else if (this.tokVal() != ')') { //has parameters
                suffix.reqChild(Expression)
            }
            this.req(")")
        }

    }

}

//## NameValuePair
//`NameValuePair: (IDENTIFIER|StringLiteral|NumberLiteral) ':' Expression`
//A single item inside a `ObjectLiteral / StructInstantiation.value`
//a `property-name: value` pair.
export class NameValuePair extends ASTBase {
    value: Expression
    // ---------------------------
    parse() {
        this.owner.lexer.savePosition()
        this.name = this.reqToken(TokenCode.WORD)
        if (this.opt(':')) { //por alguna razon en rust decidieron q se podia instanciar un obj por posicion, los : son opcionales
            this.owner.lexer.discardSavedPosition()
            this.lock()
            this.value = this.reqClass(Expression) as Expression
        }
        else {
            //asumpo posicional
            this.owner.lexer.restoreSavedPosition()
            this.name = "[positional]"
            this.value = this.reqClass(Expression) as Expression
        }
    }
    // ---------------------------
    produce() {
        this.owner.codeWriter.write(this.name)
        this.owner.codeWriter.write(" : ")
        this.value.produce()
    }
}
// end class NameValuePair

//## ObjectLiteral

//`ObjectLiteral: '{' NameValuePair* '}'`

//Defines an object with a list of key value pairs. This is a JavaScript-style definition.
//For LiteC (the Litescript-to-C compiler), a ObjectLiteral crates a `Map string to any` on the fly.

//`x = {a:1,b:2,c:{d:1}}`

//public class ObjectLiteral extends Literal
// constructor
export class ObjectLiteral extends ASTBase {

    // ---------------------------
    parse() {
        this.req('{')
        this.lock()
        this.children = this.optSeparatedList(NameValuePair, ',', '}')

        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }

    // ---------------------------
    forEach(callback: Function) {
        //for each nameValue in .items
        for (const nameValue of this.children) {
            callback(nameValue)
        }
    }

    // ---------------------------
    produce() {
        this.owner.codeWriter.write("{")
        this.produceChildren(","+EOL)
        this.owner.codeWriter.write("}")
    }

}

export class StaticDeclaration extends ASTBase {
    valueExpression: Expression
    // ---------------------------
    parse() {
        this.req('static')
        //At this point we lock because it is definitely a `static` declaration. Failure to parse the expression
        //from this point is a syntax error.
        this.lock()
        //After the word 'static' we require an identifier:type=value
        this.name = this.reqToken(TokenCode.WORD)
        this.req(":")
        this.reqChild(TypeAnnotation)
        this.req("=")
        this.reqChild(Expression)
    }
}
// end static place declaration

//## ArrayLiteral
//`ArrayLiteral: '[' (Expression,)* ']'`
//An array definition, such as `a = [1,2,3]`
export class ArrayLiteral extends ASTBase {
    items: Expression[] = []
    // ---------------------------
    parse() {
        this.req('[')
        this.lock()
        //closer "]" required
        this.items = this.optSeparatedList(Expression, ',', ']') as Expression[]
    }
}// end class ArrayLiteral

export class ConstDeclaration extends ASTBase {
    // ---------------------------
    parse() {

        this.req('const')
        //At this point we lock because it is definitely a `const` declaration. Failure to parse the expression
        //from this point is a syntax error.
        this.lock()
        //After the word 'const' we require an identifier
        this.name = this.reqToken(TokenCode.WORD)
        this.req(":")
        this.reqChild(TypeAnnotation)
        this.req("=")
        this.reqChild(Expression)
    }
}
// end ConstValueDeclaration

//## ParenExpression
//`ParenExpression: '(' Expression ')'`
//An expression enclosed by parentheses, like `(a + b)`.
//public class ParenExpression extends ASTBase
// constructor
export class ParenExpression extends ASTBase {
    expr: Expression
    // ---------------------------
    parse() {
        this.req('(')
        this.lock()
        this.reqChild(Expression)
        this.req(')')

        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }
}
// end class ParenExpression

/**
 * a type annotation with optional <type-paramenters,...>
 *      IDENT [ '<' (type-paramenter,) '>' ]
 * */
export class TypeAnnotation extends ASTBase {
    parse() {
        this.optAddrOf()
        this.optMut()
        const ident = this.reqClass(Identifier)
        this.name = ident.name //composed::namespace::name
        if (this.opt('<')) {
            this.children = this.reqSeparatedList(Identifier, ',', '>')
        }
    }
}

/**
 * class UseDeclaration
 *      'use' WORD ([::WORD...]  | '{' (Identifier,) '}' | * )
 * */
export class UseDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('use')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        while (this.owner.lexer.token.value == '::') {
            this.name += '::'
            const nextValue = this.owner.lexer.advance()
            if (nextValue == '{') { //special rust case, several use declarations sharing the same root
                this.owner.lexer.advance()
                this.children = this.reqSeparatedList(Identifier, ",", "}")
                break //no more ::'s possible
            }
            else if (nextValue == '*') { //special: all items
                this.name += '*'
                this.owner.lexer.advance()
                break //no more ::'s possible
            }
            else { //more indentifiers
                this.name += this.reqToken(TokenCode.WORD)
            }
        }
    }
}

export class ModDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('mod')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        Body.optIntoChildren(this)
    }
}

export class TypeDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('type')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        this.req('=')
        this.reqChild(Expression)
    }
}

export class MacroInvocation extends ASTBase {
    macroWords: string[] = []
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.WORD)
        this.name += this.req('!')
        this.lock()

        //casos especiales de rust de como delimitan los parametros de la macro
        const initial = this.owner.lexer.token.value
        let opener = initial, closer: string
        if (initial == '{') {
            closer = '}'
        }
        else if (initial == '(') {
            closer = ')'
        }
        else if (initial == '[') {
            closer = ']'
        }
        else {
            opener = undefined
            closer = ';'
        }

        //special recognized macros: assert_eq!(a,b) => expect(a).toBe(b)
        if (this.name == "assert_eq!" && opener == "(") {
            //parse the 2 expression and store at children[]
            this.req("(")
            this.reqChild(Expression)
            this.req(",")
            this.reqChild(Expression)
            if (this.opt(",")){ //third parameter, message if asssert failed
                this.reqChild(Expression)
            }
            this.req(")")
        }
        else {
            //read balanced openers/closers { } / () or up to ;
            //because it's a "macro" anything goes (can't use AST Body parser)
            this.macroWords.push(initial)
            let openBalance = 1
            do {
                const word = this.owner.lexer.advance()
                if (opener && word == opener) { openBalance++ }
                else if (word == closer) { openBalance-- }
                this.macroWords.push(word)
            }
            while (openBalance > 0)
            this.owner.lexer.advance() // consume the closer
        }

        //check if the macro!() ends with .into() .as_bytes() .as_U128() etc
        Expression.checkNativeRustConversionMapCollect(this)

        this.owner.lexer.semiNotRequired = true // no need for a semicolon after this
    }

    toString() {
        return Function.apply(ASTBase.toString, this) + ' ' + this.macroWords.join(' ')
    }
}

export class StructDeclaration extends ASTBase {
    // ---------------------------
    parse() {
        this.req('struct')
        this.name = this.reqToken(TokenCode.WORD)
        this.req('{')
        this.children = this.reqSeparatedList(VariableDecl, ",", "}")
    }
}

export class ImplDeclaration extends ASTBase {
    for: Identifier
    // ---------------------------
    parse() {
        this.req('impl')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)
        if (this.opt('for')) {
            this.for = this.reqClass(Identifier)
        }
        this.req("{")
        Body.parseIntoChildren(this) //parse as a Body (no separator, several fn { } blocks) => children
    }
}

/**
 * A single-line attribute
 * comments attached to statements are stored in Statement.comment
 * */
export class LineAttribute extends ASTBase {
    parse() {
        this.name = this.reqToken(TokenCode.ATTRIBUTE)
    }
}

//## RustClosure
//
//`RustClosure: ` '|' (WORD,...) '|' ( Body | Expression | fn-call ) `
//
export class RustClosure extends ASTBase {
    mapItemName: string
    params: Identifier[]

    // ---------------------------
    parse() {
        this.req('|')
        this.lock()
        this.params = this.reqSeparatedList(Identifier, ",", "|") //closure params
        // it's a body?
        if (this.opt('{')) {
            Body.parseIntoChildren(this)
        }
        else {
            //let's assume it is an Expression
            this.children.push(this.reqClass(Expression))
        }
    }
}
// end class RustClosure

//## MatchPair
//
//`MatchPair: ` (Expression | '_' ) '=>' Expression 
//
export class MatchPair extends ASTBase {
    left: Expression
    right: Expression
    // ---------------------------
    parse() {
        if (this.opt('_')) {
            this.left = null
        }
        else {
            this.left = this.reqClass(Expression) as Expression
        }
        this.req("=>")
        this.right = this.reqClass(Expression) as Expression
    }

    toString() {
        return Function.apply(ASTBase.toString, this) + (this.left ? this.left.name : '_') + " => " + this.right.name
    }
}

//## MatchExpression
//
//`MatchExpression: ` match Expression '{' ( (Expression | '_' ) => Expression ,... ) '}'`
//
export class MatchExpression extends ASTBase {
    exprToMatch: Expression
    // ---------------------------
    parse() {
        this.req('match')
        this.lock()
        this.exprToMatch = this.reqClass(Expression) as Expression
        this.req('{')
        this.children = this.optSeparatedList(MatchPair, ",", "}")

        Expression.checkNativeRustConversionMapCollect(this) //veo si tiene una llamada a .to_vec() u otra conversin
    }
}
// end class MatchExpression

//## FunctionDeclaration
//
//`FunctionDeclaration: 'function [IDENTIFIER] ["(" [VariableDecl,]* ")"] [returns type-VariableRef] Body`
//
//Functions: parametrized pieces of callable code.
//
export class FunctionDeclaration extends ASTBase {
    paramsDeclarations: FunctionParameters

    // ---------------------------
    parse() {

        //manage special keywords like 'pub'
        this.optPub()

        this.req('fn')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)

        //.parseParametersAndBody
        this.parseParametersAndBody()
    }

    // ---------------------------
    parseParametersAndBody() {

        //This method is shared by functions, methods and constructors.
        //`()` after `function` are optional. It parses: `'(' [VariableDecl,] ')' '->' Return-TypeAnnotation '{' Body '}'`

        //get parameters declarations
        this.paramsDeclarations = this.opt(FunctionParameters) as FunctionParameters

        // get the return-type (optional)
        if (this.opt('->')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation)
        }

        //now parse the body
        if (this.owner.lexer.token.value == ";") {
            //just a fn signature declaration (no body)
            return
        }
        else {
            this.req("{")
            Body.parseIntoChildren(this)
        }
    }
}
// end class FunctionDeclaration

/**
 * [pub mut &] Name,Type and optional assignment
 * 
 * Identifier: TypeAnnotation [ = Expression ]
 * 
 * */
export class VariableDecl extends ASTBase {
    typeAnnotation: TypeAnnotation
    assignedExpression: Expression
    // ---------------------------
    parse() {

        // accept '...' to denote a variadic function
        //if (this.owner.tokenizer.token.value === '...' && this.parent instanceof FunctionParameters) {
        //    this.name = this.req('...');
        //    return;
        //};

        //manage special keywords like 'pub' & mut
        this.optPub()
        this.optAddrOf()
        this.optMut()

        this.name = this.reqToken(TokenCode.WORD)
        this.lock()

        //if .parent instance of VarStatement
        if (this.parent instanceof LetStatement && RESERVED_WORDS.indexOf(this.name) >= 0) {
            this.sayErr(`"${this.name}" is a reserved word`)
        }

        //optional type annotation 
        if (this.opt(':')) {
            this.typeAnnotation = this.reqClass(TypeAnnotation) as TypeAnnotation
        }

        //optional assigned value
        if (this.opt('=')) {
            this.assignedExpression = this.reqClass(Expression) as Expression
        }
    }
}
// end class VariableDecl

//export class VarDeclList extends ASTBase {
//    list: VariableDecl[]
//    // ---------------------------
//    parseList(closer:string) {
//        this.list = this.reqSeparatedList(VariableDecl, ',', closer) as VariableDecl[]
//    }
//    // ---------------------------
//    getNames = function () {
//        var result = []
//        for (const varDecl of this.list) {
//            result.push(varDecl.name)
//        }
//        return result
//    }
//}
//// end class VarDeclList

export class LetStatement extends ASTBase {
    // ---------------------------
    parse() {
        this.req('let')
        this.optMut()
        this.lock()
        this.children = this.reqSeparatedList(VariableDecl, ',', ';')
    }
}

// constructor
export class FunctionParameters extends ASTBase {
    // ---------------------------
    parse() {

        //if we define a list of specific parameters, fuction is no longer variadic
        this.lock()

        this.req('(')
        this.children = this.optSeparatedList(VariableDecl, ',', ')') as VariableDecl[]

        ////check if we've parsed "..." ellipsis in the parameters list.
        ////ellipsis are valid as "last parameter", and restores the "variadic" flag
        ////for each inx,item in .list
        //for (let [inx, item] of this.list) {

        //    //if item.name is '...'
        //    if (item.name === '...') {

        //        //if inx<.list.length-1
        //        if (inx < this.list.length - 1) {

        //            //.sayErr "variadic indicator: '...' is valid only as last parameter"
        //            this.sayErr('variadic indicator: "..." is valid only as last parameter');
        //        }
        //        //if inx<.list.length-1

        //        else {
        //            //.list.pop //remove "..."
        //            this.list.pop();
        //            //.variadic = true
        //            this.variadic = true;
        //            //break
        //            break;
        //        };
        //    };
        //};// end for each in this.list

    }
}// end class FunctionParameters

//public class TraitDeclaration extends ASTBase
// constructor
export class TraitDeclaration extends ASTBase {
    traitAncestors: Identifier[]
    // ---------------------------
    parse() {
        this.req('trait')
        this.lock()
        this.name = this.reqToken(TokenCode.WORD)

        //See if there is an inheritance declaration
        if (this.opt(':')) {
            // now a list of references (to other traits, separated by "+", ended by the "{" )
            this.traitAncestors = this.reqSeparatedList(Identifier, '+', '{')
        }

        //Now get the trait body
        this.req("{")
        Body.parseIntoChildren(this)
    }
}
// end class TraitDeclaration

//    export class TryCatch extends ASTBase
// constructor
export class TryCatch extends ASTBase {
    exceptionBlock
    // ---------------------------
    parse() {
        this.req('try')
        this.lock()
        Body.reqAsChild(this, "try-block")
        if (this.opt('catch')) {
            Body.reqAsChild(this, "catch-block")
        }
        if (this.opt('finally')) {
            Body.reqAsChild(this, "finally-block")
        }
    }
}

export class ThrowStatement extends ASTBase {
    // ---------------------------
    parse() {
        this.req('throw')
        //At this point we lock because it is definitely a `throw` statement
        this.lock()
        this.reqChild(Expression)
    }
}
// end class ThrowStatement

/**
 * 'return' [Expression]
 * */
export class ReturnStatement extends ASTBase {
    expr: Expression
    // ---------------------------
    parse() {
        this.req('return')
        this.lock()
        this.optChild(Expression)
    }
}
// end class ReturnStatement

// ---------------------------
export class IfStatement extends ASTBase {
    conditional: Expression
    // ---------------------------
    parse() {
        this.req('if')
        this.lock()
        this.conditional = this.reqClass(Expression) as Expression
        Body.reqAsChild(this, "then-block") //first child, then block
        if (this.opt('else')) {
            Body.reqAsChild(this, "else-block") //second child, optional else block
        }
    }
}
// end class IfStatement

// ---------------------------
export class WhileStatement extends ASTBase {
    conditional: Expression
    // ---------------------------
    parse() {
        this.req('while')
        this.lock()
        this.conditional = this.reqClass(Expression) as Expression
        this.req("{")
        Body.parseIntoChildren(this)
    }
    toString() {
        return Function.apply(ASTBase.toString, this) + ' ' + this.conditional.name
    }
}
// end class WhileStatement 

//export class ElseIfStatement extends ASTBase {
//    nextIf
//    // ---------------------------
//    parse () {
//        //.req 'else'
//        this.req('else');
//        //.req 'if'
//        this.req('if');
//        //.lock()
//        this.lock();

//        //return the consumed 'if', to parse as a normal `IfStatement`

//        //.lexer.returnToken()
//        this.lexer.returnToken();
//        //.nextIf = .req(IfStatement)
//        this.nextIf = this.req(IfStatement);
//    }
//}// end class ElseIfStatement

//Loops
//=====
/*
export class DoLoop extends ASTBase {
    preWhileUntilExpression
    body
    postWhileUntilExpression
    // ---------------------------
    parse () {
        //.req 'do'
        this.req('do');
        //if .opt('nothing')
        if (this.opt('nothing')) {

            //.throwParseFailed('is do nothing')
            this.throwParseFailed('is do nothing');
        };
        //.opt ":"
        this.opt(':');
        //.lock()
        this.lock();

        //Get optional pre-condition

        //.preWhileUntilExpression = .opt(WhileUntilExpression)
        this.preWhileUntilExpression = this.opt(WhileUntilExpression);
        //.body = .opt(Body)
        this.body = this.opt(Body);
        //.req "loop"
        this.req('loop');

        //Get optional post-condition

        //.postWhileUntilExpression = .opt(WhileUntilExpression)
        this.postWhileUntilExpression = this.opt(WhileUntilExpression);
        //if .preWhileUntilExpression and .postWhileUntilExpression
        if (this.preWhileUntilExpression && this.postWhileUntilExpression) {

            //.sayErr "Loop: cannot have a pre-condition a and post-condition at the same time"
            this.sayErr('Loop: cannot have a pre-condition a and post-condition at the same time');
        };
    }
}// end class DoLoop

//    export class WhileUntilLoop extends DoLoop
// constructor
export class WhileUntilLoop extends DoLoop {
    // ---------------------------
    parse () {
        //.preWhileUntilExpression = .req(WhileUntilExpression)
        this.preWhileUntilExpression = this.req(WhileUntilExpression);
        //.lock()
        this.lock();
        //.body = .opt(Body)
        this.body = this.opt(Body);
    }
}// end class WhileUntilLoop

//    export helper class WhileUntilExpression extends ASTBase
// constructor
export class WhileUntilExpression extends ASTBase {
    expr: Expression
    // ---------------------------
    parse () {
        //.name = .req('while','until')
        this.name = this.req('while', 'until');
        //.lock()
        this.lock();
        //.expr = .req(Expression)
        this.expr = this.req(Expression);
    }
}// end class WhileUntilExpression

//    export class LoopControlStatement extends ASTBase
// constructor
export class LoopControlStatement extends ASTBase {
    control
    // ---------------------------
    parse () {
        //.control = .req('break','continue')
        this.control = this.req('break', 'continue');
        //.opt 'loop'
        this.opt('loop');
    }
}// end class LoopControlStatement

//    export class DoNothingStatement extends ASTBase
// constructor
export class DoNothingStatement extends ASTBase {
    // ---------------------------
    parse () {
        //.req 'do'
        this.req('do');
        //.req 'nothing'
        this.req('nothing');
    }
}// end class DoNothingStatement
*/

//## For Statement
export class ForStatement extends ASTBase {
    variant: ASTBase
    // ---------------------------
    parse() {
        //We start with commonn `for` keyword
        this.req('for')
        this.lock()

        //we now require one of the variants
        //.variant = .req(ForEachProperty,ForEachInArray,ForIndexNumeric)
        //this.variant = this.req(ForEachProperty, ForEachInArray, ForIndexNumeric);
    }
}// end class ForStatement

/*
//##Variant 1) **for each [own] property**
//###Loop over **object property names**

//Grammar:
//`ForEachProperty: for each [own] property name-VariableDecl ["," value-VariableDecl] in object-VariableRef [where Expression]`

//where `name-VariableDecl` is a variable declared on the spot to store each property name,
//and `object-VariableRef` is the object having the properties

//    export class ForEachProperty extends ASTBase
// constructor
export class ForEachProperty extends ASTBase {
    keyIndexVar: VariableDecl
    valueVar: VariableDecl
    iterable: Expression
    where: ForWhereFilter
    body
    ownKey
    // ---------------------------
    parse () {
        //.req('each')
        this.req('each');

        //optional "own"

        //if .opt("own") into .ownKey
        if ((this.ownKey = this.opt('own'))) {

            //.lock()
            this.lock();
        };

        //next we require: 'property', and lock.

        //.req('property')
        this.req('property');
        //.lock()
        this.lock();

        //Get main variable name (to store property value)

        //.valueVar = .req(VariableDecl)
        this.valueVar = this.req(VariableDecl);

        //if comma present, it was propName-index (to store property names)

        //if .opt(",")
        if (this.opt(',')) {

            //.keyIndexVar = .valueVar
            this.keyIndexVar = this.valueVar;
            //.valueVar = .req(VariableDecl)
            this.valueVar = this.req(VariableDecl);
        };

        //Then we require `in`, and the iterable-Expression (a object)

        //.req 'in'
        this.req('in');
        //.iterable = .req(Expression)
        this.iterable = this.req(Expression);

        //optional where expression (filter)

        //.where = .opt(ForWhereFilter)
        this.where = this.opt(ForWhereFilter);

        //Now, get the loop body

        //.body = .req(Body)
        this.body = this.req(Body);
    }
}// end class ForEachProperty

//##Variant 2) **for each in**
//### loop over **Arrays**

//Grammar:
//`ForEachInArray: for each [index-VariableDecl,]item-VariableDecl in array-VariableRef [where Expression]`

//where:
//* `index-VariableDecl` is a variable declared on the spot to store each item index (from 0 to array.length)
//* `item-VariableDecl` is a variable declared on the spot to store each array item (array[index])
//and `array-VariableRef` is the array to iterate over

//    export class ForEachInArray extends ASTBase
// constructor
export class ForEachInArray extends ASTBase {
    intIndexVar: VariableDecl
    keyIndexVar: VariableDecl
    valueVar: VariableDecl
    iterable: Expression
    where: ForWhereFilter
    body
    // ---------------------------
    parse () {

        //first, require 'each'

        //.req 'each'
        this.req('each');

        //Get value variable name.
        //Keep it simple: index and value are always variables declared on the spot

        //.valueVar = .req(VariableDecl)
        this.valueVar = this.req(VariableDecl);

        //a comma means: previous var was 'nameIndex', so register previous as index and get value var

        //if .opt(',')
        if (this.opt(',')) {

            //.keyIndexVar = .valueVar
            this.keyIndexVar = this.valueVar;
            //.valueVar = .req(VariableDecl)
            this.valueVar = this.req(VariableDecl);
        };

        //another comma means: full 3 vars: for each intIndex,nameIndex,value in iterable.
        //Previous two where intIndex & nameIndex

        //if .opt(',')
        if (this.opt(',')) {

            //.intIndexVar = .keyIndexVar
            this.intIndexVar = this.keyIndexVar;
            //.keyIndexVar = .valueVar
            this.keyIndexVar = this.valueVar;
            //.valueVar = .req(VariableDecl)
            this.valueVar = this.req(VariableDecl);
        };

        //we now *require* `in` and the iterable: Object|Map|Array... any class having a iterableNext(iter) method

        //.req 'in'
        this.req('in');
        //.lock()
        this.lock();
        //.isMap = .opt('map')
        this.isMap = this.opt('map');
        //.iterable = .req(Expression)
        this.iterable = this.req(Expression);

        //optional where expression

        //.where = .opt(ForWhereFilter)
        this.where = this.opt(ForWhereFilter);

        //and then, loop body

        //.body = .req(Body)
        this.body = this.req(Body);
    }
}// end class ForEachInArray

//##Variant 3) **for index=...**
//### to do **numeric loops**

//This `for` variant is just a verbose expressions of the standard C (and js) `for(;;)` loop

//Grammar:
//`ForIndexNumeric: for index-VariableDecl [","] (while|until|to|down to) end-Expression ["," increment-SingleLineBody]`

//where `index-VariableDecl` is a numeric variable declared on the spot to store loop index,
//`start-Expression` is the start value for the index (ussually 0)
//`end-Expression` is:
//- the end value (`to`)
//- the condition to keep looping (`while`)
//- the condition to end looping (`until`)
//<br>and `increment-SingleLineBody` is the statement(s) used to advance the loop index.
//If omitted the default is `index++`

//    export class ForIndexNumeric extends ASTBase
// constructor
export class ForIndexNumeric extends ASTBase {
    keyIndexVar: VariableDecl
    conditionPrefix
    endExpression
    increment: Statement
    body
    // ---------------------------
    parse () {
        //.keyIndexVar = .req(VariableDecl)
        this.keyIndexVar = this.req(VariableDecl);
        //.lock()
        this.lock();

        //next comma is  optional, then
        //get 'while|until|to' and condition

        //.opt ','
        this.opt(',');
        //.conditionPrefix = .req('while','until','to','down')
        this.conditionPrefix = this.req('while', 'until', 'to', 'down');
        //if .conditionPrefix is 'down', .req 'to'
        if (this.conditionPrefix === 'down') { this.req('to') };
        //.endExpression = .req(Expression)
        this.endExpression = this.req(Expression);

        //another optional comma, and increment-Statement(s)
        if (this.opt(',')) {
            this.increment = this.req(Statement);
        };

        //Now, get the loop body
        this.body = this.req(Body);
    }
}// end class ForIndexNumeric

//    public helper class ForWhereFilter extends ASTBase
// constructor
export class ForWhereFilter extends ASTBase {
    filterExpression
    // ---------------------------
    parse () {
        //var optNewLine = .opt('NEWLINE')
        var optNewLine = this.opt('NEWLINE');

        //if .opt('where')
        if (this.opt('where')) {

            //.lock()
            this.lock();
            //.filterExpression = .req(Expression)
            this.filterExpression = this.req(Expression);
        }
        //if .opt('where')

        else {
            //if optNewLine, .lexer.returnToken # return NEWLINE
            if (optNewLine) { this.lexer.returnToken() };
            //.throwParseFailed "expected '[NEWLINE] where'"
            this.throwParseFailed("expected '[NEWLINE] where'");
        };
    }
}// end class ForWhereFilter

//--------------------------------

//    public class DeleteStatement extends ASTBase
// constructor
export class DeleteStatement extends ASTBase {
    varRef
    // ---------------------------
    parse () {
        //.req('delete')
        this.req('delete');
        //.lock()
        this.lock();
        //.varRef = .req(VariableRef)
        this.varRef = this.req(VariableRef);
    }
}// end class DeleteStatement
*/

/*
 * Partial AssignmentStatement
 * the L-Value has been parsed already
 * a '=' followed by an Expression 
 * */
export class AssignmentStatement extends ASTBase {
    lvalue: VarRef
    rvalue: Expression
    // ---------------------------
    parse() {
        this.name = this.reqToken(TokenCode.ASSIGNMENT)
        this.lock()
        this.rvalue = this.reqClass(Expression) as Expression
    }
    toString() {
        return Function.apply(ASTBase.toString, this) + ' = ' + this.rvalue.name
    }
    produce() {
        const o = this.owner.codeWriter
        this.lvalue.produce()
        o.write(' ' + this.name + ' ')
        this.rvalue.produce()
    }
}
// end class AssignmentStatement

//-----------------------
//## Accessors
//`Accessors: (PropertyAccess | FunctionAccess | IndexAccess)`

//Accessors:
//`PropertyAccess: '.' IDENTIFIER`
//`IndexAccess: '[' Expression ']'`
//`FunctionAccess: '('[Expression,] * ')'`

//Accessors can appear after a VariableRef (most common case)
//but also after a String constant, a Regex Constant,
//a ObjectLiteral and a ArrayLiteral

//Examples:
//- `myObj.item.fn(call)`  <-- 3 accesors, two PropertyAccess and a FunctionAccess
//- `myObj[5](param).part`  <-- 3 accesors, IndexAccess, FunctionAccess and PropertyAccess
//- `[1, 2, 3, 4].indexOf(3)` <-- 2 accesors, PropertyAccess and FunctionAccess

//#####Actions:

//`.` -> PropertyAccess: Search the property in the object and in his pototype chain.
//It resolves to the property value

//`[...]` -> IndexAccess: Same as PropertyAccess

//`(...)` -> FunctionAccess: The object is assumed to be a function, and the code executed.
//It resolves to the function return value.

//## Implementation
//We provide a class Accessor to be super class for the three accessors types.

export class Accessor extends ASTBase {

    static parseAccessors(node: VarRef) {

        let accessorFound=true
        //Loop parsing accessors
        while (accessorFound) {

            switch (node.owner.lexer.token.value) {

                case '.':  // . => property acceess
                    node.reqChild(PropertyAccess)
                    node.isFunctionCall = false
                    break

                case '(': // ( => function access
                    node.reqChild(FunctionAccess)
                    node.isFunctionCall = true //if the very last accesor is "(", it means the entire expression is a function call
                    node.hasSideEffects = true //if any accessor is a function call, this statement is assumed to have side-effects
                    break

                case '[': // [ => array access
                    node.reqChild(IndexAccess)
                    node.isFunctionCall = false
                    break

                default:
                    accessorFound=false
            }
        }
    }
}
// end class Accessor

export class FunctionAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('(')
        this.lock()
        this.children = this.optSeparatedList(FunctionArgument, ',', ')')
    }
    // ---------------------------
    toString() {
        return '(...)'
    }
    produce() {
        const o = this.owner.codeWriter
        //function accessor => function call
        o.write("(")
        this.produceChildren(", ")
        o.write(")")
    }
}
// end class FunctionAccess 

export class PropertyAccess extends Accessor {
    // ---------------------------
    parse() {
        this.req('.')
        this.lock()
        //check for NumberLiteral  x.0 rust tuple dot-index access. https://stackoverflow.com/questions/32030756/reasons-for-dot-notation-for-tuple
        if (this.owner.lexer.token.tokenCode == TokenCode.NUMBER) {
            this.keyword="tuple-index"
            this.extraInfo = this.owner.lexer.token.value
            this.owner.lexer.advance()
        }
        else {
            //let's assume .field access 
            this.name = this.reqToken(TokenCode.WORD)
        }
    }
    // ---------------------------
    toString() {
        return `.${this.name} `
    }
    produce() {
        const o = this.owner.codeWriter
        //function accessor => function call
        o.write(".")
        o.write(this.name)
    }
}
// end class PropertyAccess 

export class IndexAccess extends Accessor {
    // ---------------------------
    parse() {
        this.name = this.req('[')
        this.lock()
        this.reqChild(Expression)
        this.req(']')
    }// ---------------------------
    toString() {
        return '[...]'
    }
    produce() {
        const o = this.owner.codeWriter
        //function accessor => function call
        o.write("[")
        this.produceChildren()
        o.write("]")
    }
}
// end class IndexAccess

//-----------------------
/**
 * a VarRef can be:
 * 1. A "place" or L-Value, an Identifier with optional Accessors referencig a specific memory location with a type
 * 2. A Function call, returning a value (an R-value)
 * 
 * When used in Expressions, both interpretations are used as an R-Value, either by reading the value from the referenced place or executing the function call
 * 
 * The property `VarRref.isFunctionCall = true` marks it as a Function Call
 * 
 * A VarRef be an "Operand" of "InfixExpression"
 * 
 * Examples:
 *      myVar
 *      std::Rand(5)
 *      myData[7]
 *      myData[utils::getIndex(s)]
 *      myStruct.name
 *      myStruct.values[7].price
 *  
 * */
export class VarRef extends ASTBase {
    preIncDec
    postIncDec
    isFunctionCall: boolean
    hasSideEffects: boolean
    // ---------------------------
    parse() {

        this.preIncDec = this.optList(['--', '++'])
        this.isFunctionCall = false

        this.name = this.reqClass(Identifier).name
        this.lock()

        //Now we check for accessors:
        //<br>`.`->**PropertyAccess**
        //<br>`[...]`->**IndexAccess**
        //<br>`(...)`->**FunctionAccess**

        //Note: **.paserAccessors()** will:
        //- set .hasSideEffects=true if a function accessor is parsed
        //- set .isFunctionCall=true if the last accessor is a function accessor

        //.parseAccessors
        Accessor.parseAccessors(this)

        //.postIncDec = .opt('--','++')
        this.postIncDec = this.optList(['--', '++'])

        //If this variable ref has ++ or --, IT IS CONSIDERED a "call to execution" in itself,
        //a "imperative statement", because it has side effects.
        //(`i++` has a "imperative" part, It means: "give me the value of i, and then increment it!")

        if (this.preIncDec || this.postIncDec) {
            this.isFunctionCall = true
            this.hasSideEffects = true
        }
    }
    // ---------------------------
    toString() {
        //This method is only valid to be used in error reporting.
        //function accessors will be output as "(...)", and index accessors as [...]
        let result = `${this.preIncDec || ''}${this.name}`
        if (this.children) {
            for (const ac of this.children) {
                result = `${result}${ac.toString()} `
            }
        }
        return `${result}${this.postIncDec || ''}`
    }
}
// end class VariableRef

//## Operand

//```
//Operand: (
//(NumberLiteral|StringLiteral|RegExpLiteral|ArrayLiteral|ObjectLiteral
//|ParenExpression|FunctionDeclaration)[Accessors])
//|VariableRef)
//```

//Examples:
//<br> 4 + 3 -> `Operand Oper Operand`
//<br> -4    -> `UnaryOper Operand`

//A `Operand` is the data on which the operator operates.
//It's the left and right part of a binary operator.
//It's the data affected (righ) by a UnaryOper.

//To make parsing faster, associate a token type/value,
//with exact AST class to call parse() on.

//var OPERAND_DIRECT_TYPE = map

//'STRING': StringLiteral
//'NUMBER': NumberLiteral
//'REGEX': RegExpLiteral
//'SPACE_BRACKET':ArrayLiteral # one or more spaces + "["

/*
//    public class DefinePropertyItem extends ASTBase
// constructor
export class DefinePropertyItem extends ASTBase {
    negated: Boolean
    // ---------------------------
    parse () {
        //.lock()
        this.lock();
        //.negated = .opt('not')
        this.negated = this.opt('not');
        //.name = .req('enumerable','configurable','writable')
        //this.name = this.req('enumerable', 'configurable', 'writable');
    }
}// end class DefinePropertyItem

//## NamespaceDeclaration

//`NamespaceDeclaration: namespace IDENTIFIER Body`

//Declares a namespace.
//for js: creates a object with methods and properties
//for LiteC, just declare a namespace. All classes created inside will have the namespace prepended with "_"

//public class NamespaceDeclaration extends TraitDeclaration // NamespaceDeclaration is instance of TraitDeclaration
// constructor
export class NamespaceDeclaration extends TraitDeclaration {
    constructor() { // default constructor
        super(arguments)
    };
    // ---------------------------
    parse () {

        //.req 'namespace','Namespace'
        this.req('namespace', 'Namespace');

        //.lock()
        this.lock();
        //.name=.req('IDENTIFIER')
        this.name = this.req('IDENTIFIER');

        //Now get the namespace body

        //.body = .req(Body)
        this.body = this.req(Body);

        //.body.validate
        //PropertiesDeclaration
        //MethodDeclaration
        //TraitDeclaration
        //NamespaceDeclaration

        //## DebuggerStatement

        //`DebuggerStatement: debugger`

        //When a debugger is attached, break at this point.

        //public class DebuggerStatement extends ASTBase
        this.body.validate(PropertiesDeclaration, MethodDeclaration, TraitDeclaration, NamespaceDeclaration);
    }
}// end class NamespaceDeclaration

//## DebuggerStatement

//`DebuggerStatement: debugger`

//When a debugger is attached, break at this point.

//public class DebuggerStatement extends ASTBase
// constructor
export class DebuggerStatement extends ASTBase {
    constructor() { // default constructor
        super(arguments)
    };
    // ---------------------------
    parse () {
        //.name = .req("debugger")
        this.name = this.req('debugger');
    }
}// end class DebuggerStatement

//CompilerStatement
//-----------------

//`compiler` is a generic entry point to alter LiteScript compiler from source code.
//It allows conditional complilation, setting compiler options, and execute macros
//to generate code on the fly.
//Future: allow the programmer to hook transformations on the compiler process itself.
//<br>`CompilerStatement: (compiler|compile) (set|if|debugger|option) Body`
//<br>`set-CompilerStatement: compiler set (VariableDecl,)`
//<br>`conditional-CompilerStatement: 'compile if IDENTIFIER Body`

//public class CompilerStatement extends ASTBase
// constructor
export class CompilerStatement extends ASTBase {
    kind
    conditional: String
    list
    body
    endLineInx
    constructor() { // default constructor
        super(arguments)
        //properties
        //kind, conditional:string
        //list, body
        //endLineInx
    };
    // ---------------------------
    parse () {
        //.req 'compiler','compile'
        this.req('compiler', 'compile');
        //.lock()
        this.lock();

        //.kind = .req('set','if','debugger','options')
        this.kind = this.req('set', 'if', 'debugger', 'options');

        //### compiler set
        //get list of declared names, add to root node 'Compiler Vars'

        //if .kind is 'set'
        if (this.kind === 'set') {

            //.list = .reqSeparatedList(VariableDecl,',')
            this.list = this.reqSeparatedList(VariableDecl, ',');
        }
        //if .kind is 'set'

        else if (this.kind === 'debugger') {

            //debugger
            debugger;
        }
        //else if .kind is 'debugger' #debug-pause the compiler itself, to debug compiling process

        else {
            //.sayErr 'invalid compiler command'
            this.sayErr('invalid compiler command');
        };
    }
}// end class CompilerStatement

//## Import Statement

//`ImportStatement: import (ImportStatementItem,)`

//Example: `import fs, path` ->  js:`var fs=require('fs'),path=require('path')`

//Example: `import Args, wait from 'wait.for'` ->  js:`var http=require('./Args'),wait=require('./wait.for.js')`

//public class ImportStatement extends ASTBase
// constructor
export class ImportStatement extends ASTBase {
    global: Boolean
    list: []
    // ---------------------------
    parse () {
        //.req('import')
        this.req('import');
        //.lock
        this.lock();

        //if .lexer.options.browser, .throwError "'import' statement invalid in browser-mode. Do you mean 'global declare'?"
        if (this.lexer.options.browser) { this.throwError("'import ' statement invalid in browser-mode. Do you mean 'global declare'?") };

        //.list = .reqSeparatedList(ImportStatementItem,",")
        this.list = this.reqSeparatedList(ImportStatementItem, ',');

        //keep track of `import/require` calls

        //var parentModule = .getParent(Module)
        var parentModule = this.getParent(Module);
        //for each item in .list
        for (const item of this.list) {
            //parentModule.requireCallNodes.push item
            parentModule.requireCallNodes.push(item);
        };// end for each in this.list

    }
}// end class ImportStatement

//    export class ImportStatementItem extends ASTBase
// constructor
export class ImportStatementItem extends ASTBase {
    importParameter: StringLiteral
    constructor() { // default constructor
        super(arguments)
        //properties
        //importParameter:StringLiteral
    };
    // ---------------------------
    parse () {
        //.name = .req('IDENTIFIER')
        this.name = this.req('IDENTIFIER');
        //if .opt('from')
        if (this.opt('from')) {

            //.lock()
            this.lock();
            //.importParameter = .req(StringLiteral)
            this.importParameter = this.req(StringLiteral);
        };
        //end if

        //## DeclareStatement

        //Declare allows you to define a variable and/or its type
        //*for the type-checker (at compile-time)*

        //#####Declare variable:type
        //`DeclareStatement: declare VariableRef:type-VariableRef`

        //Declare a variable type on the fly, from declaration point onward

        //Example: `declare name:string, parent:Grammar.Statement` #on the fly, from declaration point onward

        //#####Global Declare
        //`global declare (ImportStatementItem+)`
        //Browser-mode: Import a *.interface.md* file to declare a global pre-existent complex objects
        //Example: `global declare jQuery,Document,Window`

        //#####Declare [global] var
        //`DeclareStatement: declare [global] var (VariableDecl,)+`

        //Allows you to declare a preexistent [global] variable
        //Example: `declare global var window:object`

        //#####Declare global type for VariableRef

        //Allows you to set the type on a existing variable
        //globally for the entire compilation.

        //Example:
        //`declare global type for LocalData.user: Models.userData` #set type globally for the entire compilation

        //#####Declare name affinity
        //`DeclareStatement: name affinity (IDENTIFIER,)+`

        //To be used inside a class declaration, declare var names
        //that will default to Class as type

        //Example
        //```
        //Class VariableDecl
        //properties
        //name: string, sourceLine, column
        //declare name affinity varDecl
        //```

        //Given the above declaration, any `var` named (or ending in) **"varDecl"** or **"VariableDecl"**
        //will assume `:VariableDecl` as type. (Class name is automatically included in 'name affinity')

        //Example:
        //`var varDecl, parentVariableDecl, childVarDecl, variableDecl`

        //all three vars will assume `:VariableDecl` as type.

        //#####Declare valid
        //`DeclareStatement: declare valid IDENTIFIER("."(IDENTIFIER|"()"|"[]"))* [:type-VariableRef]`

        //To declare, on the fly, known-valid property chains for local variables.
        //Example:
        //`declare valid data.user.name`
        //`declare valid node.parent.parent.text:string`
        //`declare valid node.parent.items[].name:string`

        //#####Declare on
        //`DeclareStatement: declare on IDENTIFIER (VariableDecl,)+`

        //To declare valid members on scope vars.
        //Allows you to declare the valid properties for a local variable or parameter
        //Example:
        //
        //    function startServer(options)
        //        declare on options
        //            name:string, useHeaders:boolean, port:number

        //    export class DeclareStatement extends ASTBase

    }
}// end class ImportStatementItem

//## DeclareStatement

//Declare allows you to define a variable and/or its type
//*for the type-checker (at compile-time)*

//#####Declare variable:type
//`DeclareStatement: declare VariableRef:type-VariableRef`

//Declare a variable type on the fly, from declaration point onward

//Example: `declare name:string, parent:Grammar.Statement` #on the fly, from declaration point onward

//#####Global Declare
//`global declare (ImportStatementItem+)`
//Browser-mode: Import a *.interface.md* file to declare a global pre-existent complex objects
//Example: `global declare jQuery,Document,Window`

//#####Declare [global] var
//`DeclareStatement: declare [global] var (VariableDecl,)+`

//Allows you to declare a preexistent [global] variable
//Example: `declare global var window:object`

//#####Declare global type for VariableRef

//Allows you to set the type on a existing variable
//globally for the entire compilation.

//Example:
//`declare global type for LocalData.user: Models.userData` #set type globally for the entire compilation

//#####Declare name affinity
//`DeclareStatement: name affinity (IDENTIFIER,)+`

//To be used inside a class declaration, declare var names
//that will default to Class as type

//Example
//```
//Class VariableDecl
//properties
//name: string, sourceLine, column
//declare name affinity varDecl
//```

//Given the above declaration, any `var` named (or ending in) **"varDecl"** or **"VariableDecl"**
//will assume `:VariableDecl` as type. (Class name is automatically included in 'name affinity')

//Example:
//`var varDecl, parentVariableDecl, childVarDecl, variableDecl`

//all three vars will assume `:VariableDecl` as type.

//#####Declare valid
//`DeclareStatement: declare valid IDENTIFIER("."(IDENTIFIER|"()"|"[]"))* [:type-VariableRef]`

//To declare, on the fly, known-valid property chains for local variables.
//Example:
//`declare valid data.user.name`
//`declare valid node.parent.parent.text:string`
//`declare valid node.parent.items[].name:string`

//#####Declare on
//`DeclareStatement: declare on IDENTIFIER (VariableDecl,)+`

//To declare valid members on scope vars.
//Allows you to declare the valid properties for a local variable or parameter
//Example:
//
//    function startServer(options)
//        declare on options
//            name:string, useHeaders:boolean, port:number

//FunctionCall
//------------
//`FunctionCall: VariableRef ["("] (FunctionArgument,) [")"]`

export class FunctionCall extends ASTBase {
    varRef: VariableRef
    // ---------------------------
    parse () {

        //Check for VariableRef. - can include (...) FunctionAccess
        this.varRef = this.reqClass(VariableRef);

        //if the last accessor is function call, this is already a FunctionCall
        //debug "#{.varRef.toString()} #{.varRef.executes?'executes':'DO NOT executes'}"

        //if .varRef.executes
        if (this.varRef.executes) {
            //already a function call
            return;
        };

        if (this.owner.tokenizer.token.type === TokenCode.EOF) {
            // no more tokens
            return;
        };

        // get parameters, add to varRef as FunctionAccess accessor,

        var functionAccess = new FunctionAccess(this.varRef,'');
        functionAccess.args = functionAccess.reqSeparatedList(FunctionArgument, ',',')');
        //.varRef.addAccessor functionAccess
        this.varRef.addAccessor(functionAccess);
    }
}// end class FunctionCall

//## CaseStatement

//`CaseStatement: case [VariableRef] [instance of] NEWLINE (when (Expression,) Body)* [else Body]`

//Similar syntax to ANSI-SQL 'CASE', and ruby's 'case'
//but it is a "statement" not a expression

//Examples:
//
//
//    case b
//      when 2,4,6:
//        print 'even'
//      when 1,3,5:
//        print 'odd'
//      else
//        print 'idk'
//    end
//
//    // case instance of
//    case b instance of
//
//      when VarStatement:
//        print 'variables #{b.list}'
//
//      when AppendToDeclaration:
//        print 'it is append to #{b.varRef}'
//
//      when NamespaceDeclaration:
//        print 'namespace #{b.name}'
//
//      when TraitDeclaration:
//        print 'a class, extends #{b.varRefSuper}'
//
//      else
//        print 'unexpected class'
//
//    end
//
//    // case when TRUE
//    var result
//    case
//        when a is 3 or b < 10:
//            result = 'option 1'
//        when b >= 10 or a<0 or c is 5:
//            result= 'option 2'
//        else
//            result = 'other'
//    end
//

//    public class CaseStatement extends ASTBase
// constructor
export class CaseStatement extends ASTBase {
    varRef: VariableRef
    isInstanceof: Boolean
    cases: Array
    elseBody: Body
    constructor() { // default constructor
        super(arguments)
        //properties
        //varRef: VariableRef
        //isInstanceof: boolean
        //cases: array of WhenSection
        //elseBody: Body
    };
    // ---------------------------
    parse () {

        //.req 'case'
        this.req('case');
        //.lock
        this.lock();

        //.varRef = .opt(VariableRef)
        this.varRef = this.opt(VariableRef);

        //.isInstanceof = .opt('instance','instanceof') //case foo instance of
        this.isInstanceof = this.opt('instance', 'instanceof');
        //if .isInstanceof is 'instance', .opt('of')
        if (this.isInstanceof === 'instance') { this.opt('of') };

        //.req('NEWLINE')
        this.req('NEWLINE');

        //.cases=[]
        this.cases = [];
        //while .opt(WhenSection) into var whenSection
        var whenSection:= undefined
        while ((whenSection = this.opt(WhenSection))) {
            //.cases.push whenSection
            this.cases.push(whenSection);
        };// end loop

        //if .cases.length is 0, .sayErr 'no "when" sections found for "case" construction'
        if (this.cases.length === 0) { this.sayErr('no "when" sections found for "case" construction') };

        //if .opt('else')
        if (this.opt('else')) {

            //.elseBody = .req(Body)
            this.elseBody = this.req(Body);
        };
    }
}// end class CaseStatement

//    public helper class WhenSection extends ASTBase
// constructor
export class WhenSection extends ASTBase {
    expressions: Array
    body
    constructor() { // default constructor
        super(arguments)
        //properties
        //expressions: Expression array
        //body
    };
    // ---------------------------
    parse () {

        //.req 'when'
        this.req('when');
        //.lock
        this.lock();
        //.expressions = .reqSeparatedList(Expression, ",",":")
        this.expressions = this.reqSeparatedList(Expression, ',', ':');

        //if .lexer.token.type is 'NEWLINE'
        if (this.owner.tokenizer.token.type === 'NEWLINE') {

            //.body = .req(Body) //indented body block
            this.body = this.req(Body);
        }
        //if .lexer.token.type is 'NEWLINE'

        else {
            //.body = .req(SingleLineBody)
            this.body = this.req(SingleLineBody);
        };
    }
}// end class WhenSection

//#### Module level var: valid combinations adjective-statement

//var validCombinations = map
//export: ['class','namespace','function','var']
//only: ['class','namespace']
//generator: ['function','method']
//nice: ['function','method']
//shim: ['function','method','import']
//helper:  ['function','method','class','namespace']
//global: ['declare','class','namespace','function','var']

//    append to class ASTBase
var validCombinations = new Map().fromObject({
    export: ['class', 'namespace', 'function', 'var']
    , only: ['class', 'namespace']
    , generator: ['function', 'method']
    , nice: ['function', 'method']
    , shim: ['function', 'method', 'import']
    , helper: ['function', 'method', 'class', 'namespace']
    , global: ['declare', 'class', 'namespace', 'function', 'var']
});

//    append to class ASTBase

//      helper method hasAdjective(names:string) returns boolean
// ---------------------------
hasAdjective = function (names) {
    //To check if a statement has one or more adjectives.
    //We assume .parent is Grammar.Statement

    //var stat:Statement = this.constructor is Statement? this else .getParent(Statement)
    var stat = this.constructor === Statement ? this : this.getParent(Statement);
    //if no stat, .throwError "[#{.constructor.name}].hasAdjective('#{names}'): can't find a parent Statement"
    if (!stat) { this.throwError(`[${.constructor.name}].hasAdjective('#{names}'): can't find a parent Statement`) };

    //var allToSearch = names.split(" ")
    var allToSearch = names.split(' ');
    //for each name in allToSearch
    for (const name of allToSearch) {
        //if no name in stat.adjectives, return false
        if (!(stat.adjectives.indexOf(name) >= 0)) { return false };
    };// end for each in allToSearch

    //return true //if all requested are adjectives
    return true;
};

//## Trait bodt
//Trait bodt is a semicolon-separated list of {fn}s 
export class TraitBody extends ASTBase {
    fnDecls: FunctionDeclaration[]
    // ---------------------------
    parse() {
        this.fnDecls = this.reqSeparatedList(FunctionDeclaration, ';', '}') as FunctionDeclaration[]
    }
}

*/

// ------------------------
/*
 * export class TypeDeclaration extends ASTBase {
    mainType
    keyType
    itemType
    // ---------------------------
    parse() {

        //parse type declaration:

        //function [(VariableDecl,)]
        //type-IDENTIFIER [array]
        //[array of] type-IDENTIFIER
        //map type-IDENTIFIER to type-IDENTIFIER

        //if .opt('function','Function') #function as type
        if (this.opt('function', 'Function')) {

            //.lock
            this.lock();
            //.mainType= new VariableRef(this, 'Function')
            this.mainType = new VariableRef(this, 'Function');
            //if .lexer.token.value is '(', .parseAccessors
            if (this.owner.tokenizer.token.value === '(') { this.parseAccessors() };
            //return
            return;
        };

        //check for 'array', e.g.: `var list : array of String`

        //if .opt('array','Array')
        if (this.opt('array', 'Array')) {

            //.lock
            this.lock();
            //.mainType = 'Array'
            this.mainType = 'Array';
            //if .opt('of')
            if (this.opt('of')) {

                //.itemType = .req(VariableRef) #reference to an existing class
                this.itemType = this.req(VariableRef);
                //auto-capitalize core classes
                //declare .itemType:VariableRef

                //.itemType.name = autoCapitalizeCoreClasses(.itemType.name)
                this.itemType.name = autoCapitalizeCoreClasses(this.itemType.name);
            };
            //end if
            //return

            //return
            return;
        };

        //Check for 'map', e.g.: `var list : map string to Statement`

        //.mainType = .req(VariableRef) #reference to an existing class
        this.mainType = this.req(VariableRef);
        //.lock
        this.lock();
        //auto-capitalize core classes
        //declare .mainType:VariableRef

        //.mainType.name = autoCapitalizeCoreClasses(.mainType.name)
        this.mainType.name = autoCapitalizeCoreClasses(this.mainType.name);

        //if .mainType.name is 'Map'
        if (this.mainType.name === 'Map') {

            //.parent.isMap = true
            this.parent.isMap = true;
            //.extraInfo = 'map [type] to [type]' //extra info to show on parse fail
            this.extraInfo = 'map [type] to [type]';
            //.keyType = .req(VariableRef) #type for KEYS: reference to an existing class
            this.keyType = this.req(VariableRef);
            //auto-capitalize core classes
            //declare .keyType:VariableRef

            //.keyType.name = autoCapitalizeCoreClasses(.keyType.name)
            this.keyType.name = autoCapitalizeCoreClasses(this.keyType.name);
            //.req('to')
            this.req('to');
            //.itemType = .req(VariableRef) #type for values: reference to an existing class
            this.itemType = this.req(VariableRef);
            //#auto-capitalize core classes
            //declare .itemType:VariableRef

            //.itemType.name = autoCapitalizeCoreClasses(.itemType.name)
            this.itemType.name = autoCapitalizeCoreClasses(this.itemType.name);
        }
        //if .mainType.name is 'Map'

        else {
            //#check for 'type array', e.g.: `var list : string array`
            //if .opt('Array','array')
            if (this.opt('Array', 'array')) {

                //.itemType = .mainType #assign read mainType as sub-mainType
                this.itemType = this.mainType;
                //.mainType = 'Array' #real type
                this.mainType = 'Array';
            };
        };
    }// ---------------------------
    toString () {
        //return .mainType
        return this.mainType;
    }
}// end class TypeDeclaration
*/

//##Statement

//A `Statement` is an imperative statment (command) or a control construct.

//The `Statement` node is a generic container for all previously defined statements.

//The generic `Statement` is used to define `Body: (Statement;)`, that is,
//**Body** is a list of semicolon (or NEWLINE) separated **Statements**.

//Grammar:
//```
//Statement: [Adjective]* (TraitDeclaration|FunctionDeclaration
//|IfStatement|ForStatement|WhileUntilLoop|DoLoop
//|AssignmentStatement
//|LoopControlStatement|ThrowStatement
//|TryCatch|ExceptionBlock
//|ReturnStatement|PrintStatement|DoNothingStatement)

//Statement: ( AssignmentStatement | fnCall-VariableRef [ ["("] (Expression,) [")"] ] )
//```

//public class Statement extends ASTBase
// constructor
export class Statement {

    //----------------------------------------
    //Table-based (fast) Statement parsing
    //------------------------------------
    //This a extension to PEGs.
    //To make the compiler faster and easier to debug, we define an
    //object with name-value pairs: `"keyword" : AST node class`
    //We look here for fast-statement parsing, selecting the right AST node to call `parse()` on
    //based on `token.value`. (instead of parsing by ordered trial & error)
    //This table makes a direct parsing of almost all statements, thanks to a core definition of LiteScript:
    //Anything standing alone in it's own line, its an imperative statement (it does something, it produces effects).
    static DirectKeywordMap: Record<string, typeof ASTBase> = {
        'use': UseDeclaration
        , 'mod': ModDeclaration
        , 'const': ConstDeclaration
        , 'static': StaticDeclaration
        , 'trait': TraitDeclaration
        , 'type': TypeDeclaration
        , '#': LineAttribute
        , 'struct': StructDeclaration
        , 'impl': ImplDeclaration
        , 'fn': FunctionDeclaration
        , 'let': LetStatement
        , 'if': IfStatement
        , 'while': WhileStatement
        , 'for': ForStatement
        , 'match': MatchExpression
        //, 'break': LoopControlStatement
        //, 'continue': LoopControlStatement
        , 'return': ReturnStatement
        , 'throw': ThrowStatement
        , 'raise': ThrowStatement
        , 'try': TryCatch
    }

    // ---------------------------
    /** static Statement.tryParse
     *  try to parse a statement and return the specific node found | throws
     * @param node
     */
    static tryParse(node: ASTBase): ASTBase {

        node.lock() //no other option than a statement

        //manage rust attributes (lines starting with #)
        if (node.owner.lexer.token.tokenCode == TokenCode.ATTRIBUTE) {
            return node.reqClass(LineAttribute)
        }

        //manage special keywords like 'pub'
        const isPublic = (node.opt('pub') == 'pub')

        const key = node.owner.lexer.token.value

        const resultASTNode = Statement.tryParseByKeyword(node, key)

        resultASTNode.keyword = key
        resultASTNode.isPublic = isPublic
        Expression.checkNativeRustConversionMapCollect(resultASTNode) //veo si tiene una llamada a .to_vec() u otra conversin

        return resultASTNode

    }

    private static tryParseByKeyword(node: ASTBase, key: string): ASTBase {

        //manage rust macros
        if (node.owner.lexer.nextToken().value == '!') { //it's a macro!
            return node.reqClass(MacroInvocation)
        }

        //rust expression as as statement, discarded or returned if it is the last expression in the function
        if (key == '(') { //it's a (Expression-maybeReturn-Statement)
            return node.reqClass(ParenExpression)
        }

        //Now we can look up the keyword in the **StatementsDirect** table, and parse the specific AST node
        const ClassByKeyword = Statement.DirectKeywordMap[key]
        if (ClassByKeyword) {
            //keyword found, use the AST class to parse
            return node.reqClass(ClassByKeyword)
        }

        //if keyword not found in table
        //let's asume it's a fn call or an assignment statement
        // lets try then to parse a varRef, that could result in a fn-call or in an L-Value for an assignment
        const vr: VarRef = node.reqClass(VarRef) as VarRef
        if (vr.isFunctionCall) {//it was a fn call
            return vr
        }

        //let's see if node is a struct instantiation expression
        //rust's struct instantiation have the form: IDENT ObjectLiteral 
        //ObjectLiteral  = '{' [ NameValuePair, ] '}'
        if (node.owner.lexer.token.value == "{") { //let's assume is a Struct Instantiation
            //it's a Struct Instantiation
            const objectLiteral = node.reqClass(ObjectLiteral)
            objectLiteral.name = vr.name
            objectLiteral.keyword = "struct-instantiation"
            return objectLiteral 
        }

        //it wasn't a function call,
        //if there's an assignmen token => AssignmentStatement
        //else is just an expression-maybe-return-value
        if (node.owner.lexer.token.tokenCode == TokenCode.ASSIGNMENT) {
            //it's is an AssignmentStatement
            const assignmentStatement = node.reqClass(AssignmentStatement) as AssignmentStatement
            assignmentStatement.lvalue = vr //complete the AssignmentStatement L-value with the prevously parsed VarRef
            return assignmentStatement
        }

        //finally, just a expression
        //the preParsedVarRef is just a R-Value, an expression-maybe-return-value
        return vr
    }
}
// end class Statement

//## Body
// a Body is a (optional)semicolon-separated list of statements (At least one) ending with a "closer", either '}' or EOF
//Body is used for "fn" body, for body, if& else bodies, etc.
// Anywhere a list of semicolon separated statements apply.
/**
 * '{' [Statements;] '}'
 * */
export class Body extends ASTBase {
    parse() {
        this.req("{")
        this.lock()
        Body.parseIntoChildren(this)
    }
    // ---------------------------
    produce() {
        this.produceBody(4)
    }
    // ---------------------------
    static reqAsChild(parent: ASTBase, name: string = "Body"): void {
        const newBlock = parent.reqClass(Body)
        newBlock.name = name
        parent.children.push(newBlock)
    }
    // ---------------------------
    static optIntoChildren(node: ASTBase, closer: string = "}") {
        if (node.opt("{")) {
            Body.parseIntoChildren(node, closer)
        }
    }
    // ---------------------------
    static parseIntoChildren(node: ASTBase, closer: string = "}") {
        node.lock()
        //We accept statements and comments as items in the body
        //A Body is a list of Statements|LineComments separated by *semicolon* and, closed by "}"
        const separator = ';'
        logger.debug(`Body for ${node.constructor.name}: get LineComments & Statements separated by '${separator}' closer:`, closer || ' to EOF')

        while (true) {

            node.owner.lexer.skipWhiteSpaceAndNewLine()

            //pre comments and attrs
            const preComments: string[] = []
            node.owner.lexer.consumeCommentsAndAttr(preComments)

            if (node.owner.lexer.token.tokenCode == TokenCode.EOF) break //break on EOF
            if (closer && node.opt(closer)) break //on closer:'}', break - end of body, (a single extra separator before closer is allowed)

            //-----------------------
            //here we assume it's a Statement
            //Statement.tryParse will return the right AST class parsed
            const statement = Statement.tryParse(node)
            //attach pre-comments to the statement
            statement.commentsAndAttr = preComments
            //keep a dict of declaredStructs in order to be able to recognize struct instantiation 
            //(there's no keyword in a struct instantiation, just the struct's name | Self)
            if (statement instanceof StructDeclaration) {
                node.owner.declaredStructs[statement.name] = statement
            }
            //add post comments and attr - NO, se come precomments del sieguiente after a struct { }
            //node.owner.tokenizer.consumeCommentsAndAttr(item.commentsAndAttr)

            node.children.push(statement)

            if (node.opt(closer)) break //if closer '}' found here, break - end of body

            //special case: check if now comes a separator (;) followed of a comment on the same line...
            statement.attachedComment = node.owner.lexer.getAttachedCommentAfter(separator)
            if (statement.attachedComment) {
                //keep the comments atttached to the statement
                continue //Next sentence, separator found and consumed
            }

            //if the statement had a body defined by { }, or the statemente consumend the separator ";" -- it's OK
            if (node.owner.lexer.token.value != separator) {
                //allow exceptions, separator is not required
                continue
            }

            //if there is a 'separator' (semicolon), let's consume it
            node.owner.lexer.semiNotRequired = false
            node.req(separator)

        }// try another item after the separator

        if (closer == '}') node.owner.lexer.semiNotRequired = true // no need for a semicolon if closed by '}'
    }
}
// end class Body

//## Module
//The `Module` represents a complete source file.
export class ASTModule extends ASTBase {
    dependencyTreeLevel = 0
    dependencyTreeLevelOrder = 0
    importOrder = 0
    //------------
    constructor(owner: Parser, filename: string) {
        super(null, filename)
        this.owner = owner
    }
    parse() {
        const closer = undefined //parse until EOF
        Body.parseIntoChildren(this, closer)
    }

}

'''
'''--- src/lib/Parser/Parser.ts ---
import { Lexer } from "../Lexer/Lexer"
import { ASTModule, StructDeclaration } from "./Grammar"
import { CodeWriter } from "./CodeWriter";

export class Parser {
    lexer: Lexer
    hardError: Error;
    codeWriter: CodeWriter

    //declaredStructs = new Map<string, StructDeclaration>()
    declaredStructs: { [index: string]: StructDeclaration } = { };

    /**
     * creates the AST 
     * returns Root Node: type Module
     * */
    parse(lexer: Lexer): ASTModule {
        this.lexer = lexer
        const ASTRoot = new ASTModule(this, lexer.filename)
        ASTRoot.parse()
        return ASTRoot
    }

    parseFile(filename:string): ASTModule {
        const lexer = new Lexer()
        lexer.openFile(filename)
        return this.parse(lexer)
    }
}
'''
'''--- src/lib/Producer/AssemblyScriptProducer.ts ---
import { ASTBase } from "../Parser/ASTBase";
import * as Grammar from "../Parser/Grammar";
import { Parser } from "../Parser/Parser";
import { CodeWriter } from "../Parser/CodeWriter";

import * as Path from 'path'

let globalTestFlag = false; //if the rust fn is decorated with "#[test]
let debugProduceLineNumbers = false

class ASCodeWriter extends CodeWriter {
    importDone: boolean
}

/**
 * extended here to insert "return" before the last expression (rust returns the last expression implicitly)
 * output all node children as the body of a function
 * indented, one on each line
 * */
class RustFnBodyWriter extends ASTBase {

    produceBody(indent: number = 4, insertReturn: boolean = true): void {

        const o = this.owner.codeWriter
        o.newLine()
        o.indent += indent
        let inx = 0
        for (const child of this.children) {

            globalTestFlag = child.writeComments("#[test]")

            if (debugProduceLineNumbers) {
                o.write(`${child.sourceLineNum}: `)
                if (child.sourceLineNum == 544) {
                    o.write("*") //debug breakpoint here
                }
            }

            child.produce()

            if (insertReturn && inx == this.children.length - 1) { //ultimo statement
                if (child instanceof Grammar.VarRef
                    || child instanceof Grammar.ObjectLiteral
                    || child instanceof Grammar.MatchExpression
                    || child instanceof Grammar.Expression
                    || child instanceof Grammar.ParenExpression) {
                    o.currLine.splice(0, 0, "return ")
                }
            }

            inx++
            o.newLine()
        }

        o.indent -= indent
    }
}

class ASTModuleWriter extends Grammar.ASTModule {
    produce() {
        this.owner.codeWriter.writeLine("// ----------------------------------------------")
        this.owner.codeWriter.writeLine("// Transpiled by rs2as - source: " + this.owner.lexer.filename)
        this.owner.codeWriter.writeLine("// ---------------------------------------------")
        this.produceBody(0)
    }
}
Grammar.ASTModule.prototype.produce = ASTModuleWriter.prototype.produce

Grammar.UseDeclaration.prototype.produce = function () {
    if (!this.owner.codeWriter.importDone) {
        this.owner.codeWriter.importDone = true
        this.owner.codeWriter.writeLine('import { Context, logging, storage } from "near-sdk-as".js')
    }
}

Grammar.StaticDeclaration.prototype.produce = function () {
    if (this.name != "ALLOC") {
        this.owner.codeWriter.writeLine('// static ' + this.name)
    }
}

Grammar.StructDeclaration.prototype.produce = function () {
    //if (this.children.count == 1) {
    this.owner.codeWriter.writeLine('// declare struct ' + this.name)
    //}
}

class ImplDeclarationWriter extends Grammar.ImplDeclaration {
    produceTS() {
        const o = this.owner.codeWriter
        o.write('// ' + this.keyword + ' ' + this.name)
        this.produceBody(0)
    }
}
Grammar.ImplDeclaration.prototype.produce = ImplDeclarationWriter.prototype.produceTS
Grammar.ModDeclaration.prototype.produce = ImplDeclarationWriter.prototype.produceTS

class FunctionDeclarationWriter extends Grammar.FunctionDeclaration {
    produceTS() {
        const o = this.owner.codeWriter
        if (this.isPublic) o.write("export ")
        o.write("function ")
        o.write(this.name)

        //param decl
        o.write("(")
        let inx = 0
        for (const paramDecl of this.paramsDeclarations.children) {
            if (paramDecl.name != 'self') { //rust 'self' is implicit 'this' in ts
                if (inx > 0) o.write(", ")
                paramDecl.produce()
                inx++
            }
        }
        o.write(")")
        //end param decl

        //Type Annotation
        this.typeAnnotation?.produce()
        const hasReturnValue = (this.typeAnnotation!=undefined)

        //Body
        if (this.children.length) {
            o.write(' {')
            RustFnBodyWriter.prototype.produceBody.call(this, 4, hasReturnValue)
            o.writeLine('}')
        }
    }
}
Grammar.FunctionDeclaration.prototype.produce = FunctionDeclarationWriter.prototype.produceTS

export class TypeAnnotationWriter extends Grammar.TypeAnnotation {
    produceTS() {
        const o = this.owner.codeWriter
        o.write(": ")
        //this.optAddrOf()
        //this.optMut()
        let replaced = this.name.replace("::", ".")
        switch (replaced) {
            case 'str': replaced = "string"; break
            default:
        }
        o.write(replaced)
        //if (this.opt('<')) {
        //    this.children = this.reqSeparatedList(Identifier, ',', '>')
        //}
    }
}
Grammar.TypeAnnotation.prototype.produce = TypeAnnotationWriter.prototype.produceTS

export class VarDeclWriter extends Grammar.VariableDecl {
    produceTS() {
        const o = this.owner.codeWriter
        o.write(this.name)
        this.typeAnnotation?.produce()

        if (this.assignedExpression) {

            o.write(" = ")

            if (this.assignedExpression.name == 'env') { //rust 'env' => AS 'Context'

                o.write('Context.')

                switch (this.assignedExpression.root.name) {
                    case 'env::signer_account_id':
                        o.write('sender')
                        break;

                    default:
                        this.assignedExpression.root.produce()
                }
            }

            else {
                this.assignedExpression.produce()
            }
        }
    }
}
Grammar.VariableDecl.prototype.produce = VarDeclWriter.prototype.produceTS

export class ExpressionWriter extends Grammar.Expression {
    produceTS() {
        //const o = this.owner.codeWriter
        this.root?.produce()
    }
}
Grammar.Expression.prototype.produce = ExpressionWriter.prototype.produceTS

export class ParenExpressionWriter extends Grammar.ParenExpression {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("(")
        this.produceChildren()
        o.write(")")
    }
}
Grammar.ParenExpression.prototype.produce = ParenExpressionWriter.prototype.produceTS

export class LetStatementWriter extends Grammar.LetStatement {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("let ")
        this.produceChildren(", ")
    }
}
Grammar.LetStatement.prototype.produce = LetStatementWriter.prototype.produceTS

export class ConstDeclarationWriter extends Grammar.ConstDeclaration {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("const ")
        o.write(this.name)
        this.children[0].produce() //type annotation
        o.write("  = ")
        this.children[1].produce() //assigned expression
    }
}
Grammar.ConstDeclaration.prototype.produce = ConstDeclarationWriter.prototype.produceTS

export class TypeDeclarationWriter extends Grammar.TypeDeclaration {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("type ")
        o.write(this.name)
        o.write("  = ")
        this.produceChildren()
    }
}
Grammar.TypeDeclaration.prototype.produce = TypeDeclarationWriter.prototype.produceTS

export class VarRefWriter extends Grammar.VarRef {
    produceTS() {
        const o = this.owner.codeWriter
        if (this.name == 'self') { 
            o.write('this')
        }
        else if (this.name == 'env::log') { //rust 'env::log' => AS logging.log
            o.write('logging.log')
        }
        else {
            o.write(this.name.replace("::","."))
        }
        //accessors 
        this.produceChildren()
    }
}
Grammar.VarRef.prototype.produce = VarRefWriter.prototype.produceTS

const superObjectLiteralProduce : Function = Grammar.ObjectLiteral.prototype.produce
export class ObjectLiteralWriter extends Grammar.ObjectLiteral {
    produceTS() {
        const o = this.owner.codeWriter
        o.indent+=4
        superObjectLiteralProduce.call(this)
        if (this.name) { //"struct-instantiation") {
            o.write(` as ${this.name}`)
        }
        o.indent -= 4
    }
}
Grammar.ObjectLiteral.prototype.produce = ObjectLiteralWriter.prototype.produceTS

export class FunctionArgumentWriter extends Grammar.FunctionArgument {
    produceTS() {
        const o = this.owner.codeWriter
        if (this.expression) {
            this.expression.produce()
        }
        else {
            o.write("undefined") // rust _ wildcard argument
        }
    }
}
Grammar.FunctionArgument.prototype.produce = FunctionArgumentWriter.prototype.produceTS

// ---------------------------
//function outNativeRustConversionMapCollect(item: ASTBase) {
//    //veo si al final de la expresion hay uno o mas .into() o .as_u128() .to_vec() .map() . collect() etc, 
//    // que son sufijos de conversiones de rust y de map()
//    const o = item.owner.codeWriter
//    if (item.nativeSuffixes) {
//        for (const suffixIdent of item.nativeSuffixes.children) {
//            o.write(".")
//            suffixIdent.produce()
//            o.write("(")
//            suffixIdent.produceChildren()
//            o.write(")")
//        }
//    }
//}

export class RustClosureWriter extends Grammar.RustClosure {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("function(")
        for (const param of this.params) {
            param.produce()
        }
        o.writeLine(") {")
        if (this.children.length == 1 && this.children[0] instanceof Grammar.Expression) {
            o.write("return ")
        }
        this.produceChildren()
        o.writeLine("}")
    }
}
Grammar.RustClosure.prototype.produce = RustClosureWriter.prototype.produceTS

export class MacroInvocationWriter extends Grammar.MacroInvocation {

    produceStringInterpolation(o: CodeWriter) {
        const template = this.macroWords[1].slice(1, -1) //Remove quotes
        const allParams: string = this.macroWords.slice(3,-1).join("") //remove macro!("template", and closing parenthesis
        const paramUnits = allParams.split(",")
        //const templateParams = this.macroWords.filter(word => word != ',' && word != ')') //exclude commas and the closing ")"
        let inx = 0
        const parts = template.split("{}")
        for (const part of parts) {
            if (part == "") continue
            if (inx > 0) o.write(" + ")
            o.write('"' + part + '"')
            if (inx < paramUnits.length) {
                o.write(" + ")
                o.write(paramUnits[inx])
                o.write(".toString()")
                inx++
            }
        }
    }

    produceMacroWords(name: string, o: CodeWriter) {
        o.write(name)
        for (const word of this.macroWords) {
            let out = word;
            if (word == "self") out = "this";
            o.write(out)
        }
    }

    produceTS() {
        const o = this.owner.codeWriter
        let name = this.name
        switch (name) {
            case "format!": {
                this.produceStringInterpolation(o)
                break
            }
            case "println!": {
                o.write("console.log(")
                this.produceStringInterpolation(o)
                o.write(")")
                break
            }
            case "assert!": {
                this.produceMacroWords("assert", o)
                break;
            }
            case "assert_eq!": {
                if (globalTestFlag) {
                    o.write("expect(")
                    this.children[0].produce()
                    o.write(").toBe(")
                    this.children[1].produce()
                    o.write(")")
                }
                else {
                    o.write("assert(")
                    this.children[0].produce()
                    o.write(" == ")
                    this.children[1].produce()
                    o.write(")")
                    if (this.children.length > 2) { //assert failed message
                        o.write(" //") 
                        this.children[2].produce()
                    }
                }
                break
            }
            default:
                this.produceMacroWords(this.name,o)
        }
    }
}
Grammar.MacroInvocation.prototype.produce = MacroInvocationWriter.prototype.produceTS
//@ts-ignore
Grammar.MacroInvocation.prototype.produceStringInterpolation = MacroInvocationWriter.prototype.produceStringInterpolation
//@ts-ignore
Grammar.MacroInvocation.prototype.produceMacroWords = MacroInvocationWriter.prototype.produceMacroWords

export class MatchExpressionWriter extends Grammar.MatchExpression {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("const value=")
        this.exprToMatch.produce()
        o.newLine()
        let inx = 0;
        for (const mp of this.children as Grammar.MatchPair[]) {
            if (inx >= 1) o.write(" : ")
            o.write("value==")
            if (mp.left) {
                if (mp.left.name == "None") {
                    o.write("undefined")
                }
                else {
                    mp.left.produce()
                }
                o.write("? ")
                mp.right.produce()
            }
            else {
                mp.right.produce()
            }
            inx++
        }
    }
}
Grammar.MatchExpression.prototype.produce = MatchExpressionWriter.prototype.produceTS

// ---------------------------
export class IfStatementWriter extends Grammar.IfStatement {
    //conditional: Expression
    // ---------------------------
    produceTS() {
        const o = this.owner.codeWriter
        o.write("if (")
        this.conditional.produce()
        o.write("){")
        this.children[0].produce()
        o.write("}")
        if (this.children.length > 1) {
            o.write("else {")
            this.children[0].produce()
            o.write("}")
        }
    }
}
Grammar.IfStatement.prototype.produce = IfStatementWriter.prototype.produceTS
// end class IfStatement

export class AssemblyScriptProducer {

    static produce(root: ASTBase, outFilename: string) {

        const parser: Parser = root.owner
        parser.codeWriter = new ASCodeWriter(outFilename, {})

        console.log(Path.join(process.cwd(), outFilename))

        root.produce()

        parser.codeWriter.close()

    }
}

'''
'''--- src/lib/Producer/D3Visualization.ts ---
import { ASTBase } from "../Parser/ASTBase";
import { writeFileSync } from "fs";

type treeNodeData = {
    id?: number;
    text?: string;
    children?: treeNodeData[];
}

// @ts-ignore
ASTBase.prototype.getTreeData = function () {
    const childrenData = []
    global["level"] = global["level"] + 1
    if (global["level"] < 3) {
        for (const child of this.children) {
            childrenData.push(child.getTreeData())
        }
    }
    global["level"] = global["level"] - 1
    global["treeNodeID"] = global["treeNodeID"] +1
    return {
        id: global["treeNodeID"],
        text: this.toString(),
        children: childrenData
    }
}

export class D3Visualization {

    static saveForTree(root: ASTBase, outFilename: string) {

        global["treeNodeID"] = 1
        global["level"] = 0

        // @ts-ignore
        const data = root.getTreeData()

        writeFileSync(outFilename, JSON.stringify(data))

        console.log(process.cwd())

    }
}

'''
'''--- src/lib/Producer/create-contract-cli-producer.ts ---
import { ASTBase } from "../Parser/ASTBase";
import * as Grammar from "../Parser/Grammar";
import { Parser } from "../Parser/Parser";
import { CodeWriter } from "../Parser/CodeWriter";

import * as Path from 'path'

let globalTestFlag = false; //if the rust fn is decorated with "#[test]
let debugProduceLineNumbers = false

class ASTModuleWriter extends Grammar.ASTModule {

    produce() {
        const o = this.owner.codeWriter
        o.writeLine(`
// ----------------------------------------------
// generated by create-contract-cli from ${this.owner.lexer.filename}
// ---------------------------------------------
            
import { spawnNearCli } from "./util/SpawnNearCli"
import { CommandLineArgs } from "./util/CommandLineArgs"
import { commonCliOptions } from "./util/CommonCLIOptions"

//name of this script
export const NickName = '${o.data.nickName}'
//account id where this contrat is deployed
export const defaultContractName = '${o.data.defaultContractName}'

//one function for each pub fn in the contract
//get parameters by consuming from CommandLineParser
export class ContractAPI {
        `)
        o.indent += 2
        o.newLine()

        let mainImpl = undefined

        //look for main Impl (the one with #[init])
        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                for (const fns of implDecl.children) {
                    if (fns.commentsAndAttr.includes("#[init]")) {
                        mainImpl = implDecl
                    }
                }
            }
        }

        for (const implDecl of this.children) {
            if (implDecl instanceof Grammar.ImplDeclaration) {
                if (mainImpl !== undefined && implDecl !== mainImpl) {
                    continue
                }
                else {
                    //produce children of main impl
                    for (const child of implDecl.children) {
                        child.produce()
                        o.newLine()
                    }
                }
            }
        }
        o.indent -= 2
        o.newLine()
        o.writeLine(`}`)
    }
}
Grammar.ASTModule.prototype.produce = ASTModuleWriter.prototype.produce

class EmptyProducer extends Grammar.Statement {
    produce() {
    }
}
Grammar.ImplDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.StructDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.StaticDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.UseDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.ModDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.ConstDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.TypeDeclaration.prototype.produce = EmptyProducer.prototype.produce
Grammar.MacroInvocation.prototype.produce = EmptyProducer.prototype.produce
Grammar.MatchExpression.prototype.produce = EmptyProducer.prototype.produce

class FunctionDeclarationWriter extends Grammar.FunctionDeclaration {

    produceTS() {

        const o = this.owner.codeWriter
        if (!this.isPublic) {
            //o.writeLine(`NON-PUB fn ${this.name}`) //debug
            return //only pub fns are part of the ContractAPI
        }

        const selfParam: Grammar.VariableDecl = this.paramsDeclarations.children[0] as Grammar.VariableDecl
        //pub fn(&mut self) are "calls" -- alter state
        //pub fn(&self) are views -- do not alter state
        const isView = !(selfParam.isMut)

        //output pub fn comments
        //this.writeComments() -- no, they're include in the help string

        o.writeLine(`${this.name}_help =\``) //start help declaration

        if (this.commentsAndAttr && this.commentsAndAttr.length) {
            for (let s of this.commentsAndAttr) {
                while (s.startsWith("/")) s = s.slice(1);
                o.writeLine(s.replace(/`/g, "'"))
            }
        }
        o.blankLine()
        //construct usage example from pub fn params
        let argsDecl = ""
        const hasArguments = this.paramsDeclarations.children.length > 1 // 1st = 'self'
        if (hasArguments) {
            o.write("{")
            let inx = 0
            for (const paramDecl of this.paramsDeclarations.children) {
                if (paramDecl.name !== 'self') { //rust 'self' is implicit 'this' in ts
                    if (inx > 0) o.write(", ")
                    paramDecl.produce()
                    inx++
                }
            }
            o.write("}")
        }
        argsDecl = o.getCurrentLine() //save line 
        o.clearCurrentLine() //clear
        if (hasArguments) {
            //ensure all { and } have spaces around
            argsDecl = argsDecl.replace(/\{/g, " { ")
            argsDecl = argsDecl.replace(/\}/g, " } ").trim()
        }

        o.writeLine("usage:")
        o.write("> " + o.data.nickName + " " + this.name + " " + argsDecl)

        //Type Annotation -- remove
        /*let hasReturnValue = false;
        if (this.typeAnnotation) {
            if (this.typeAnnotation.name !== "Self") {
                this.typeAnnotation?.produce()
                hasReturnValue = true
            }
        }
        */

        const isPayable = (this.commentsAndAttr.includes("#[payable]"))

        //EXAMPLE -- for the user to add 
        //o.blankLine()
        //o.writeLine("example:")
        //o.writeLine(PromptNickName + " " + argsDecl)
        //o.writeLine("this command will " + this.name)
        //o.blankLine()

        o.writeLine("\`;") //close help string
        o.blankLine()

        //function as method of ContractAPI
        o.write(this.name)
        o.writeLine("(a /*:CommandLineArgs*/) {"); //API receives CommandLineArgs parser utlity
        o.indent += 2 //start body
        o.blankLine()

        //standard contractName option
        o.writeLine("//consume contract name from options if present")
        o.writeLine("const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName")
        o.blankLine()

        if (isPayable) {
            o.writeLine("//function is #payable, --amount option is required")
            o.writeLine("//IMPORTANT! manually check if the function requires YOCTONEAR and change the 2nd param to 'Y'")
            o.writeLine("a.requireOptionWithAmount(commonCliOptions.amount,'N'); //contract require an amount in expressed in N=NEARS, Y=YoctoNears")
        }

        //commented options for the user to expand
        o.writeLine('//--these are some examples on how to consume arguments')
        o.writeLine('//const argument = a.consumeString("api argument")')
        o.writeLine('//const argumentJson = a.consumeJSON("JSON argument")')
        o.blankLine()

        //get JSON args for the fn
        if (hasArguments) {
            o.writeLine('//get fn arguments as JSON')
            o.writeLine(`const params = a.consumeJSON("${argsDecl}")`)
        }
        else {
            o.writeLine(`//--${this.name} has no arguments, if you add some, uncomment the following line`)
            o.writeLine('//const params = a.consumeJSON("{ x:0, y:1, z:3 }")')
        }
        o.blankLine()

        //standard end of args mark
        o.writeLine("a.noMoreArgs() //end of arguments")
        o.blankLine()

        //composing const nearCliArgs = [
        o.writeLine("const nearCliArgs = [")
        o.indent += 2
        o.writeLine(isView ? `"view",` : `"call",`)
        o.writeLine(`contract,`)
        o.writeLine(`"${this.name}",`)
        if (hasArguments) {
            o.writeLine('JSON.stringify(params)')
        }
        o.indent -= 2
        o.writeLine("]")
        o.blankLine()

        //standard rest of options
        o.writeLine("a.addOptionsTo(nearCliArgs); //add any other --options found the command line")
        o.blankLine()

        //call to near-cli
        o.writeLine("spawnNearCli(nearCliArgs);")
        o.blankLine()

        o.indent -= 2 //end APi method body
        o.writeLine("}")
        o.blankLine()

        //rust contract pub fn Body
        //if (this.children.length) {
        //    o.write(' {')
        //    RustFnBodyWriter.prototype.produceBody.call(this, 4, hasReturnValue)
        //    o.writeLine('}')
        //}
    }
}
Grammar.FunctionDeclaration.prototype.produce = FunctionDeclarationWriter.prototype.produceTS

export class TypeAnnotationWriter extends Grammar.TypeAnnotation {
    produceTS() {
        const o = this.owner.codeWriter
        o.write(": ")
        //this.optAddrOf()
        //this.optMut()
        let replaced = this.name.replace("::", ".")
        switch (replaced) {
            case 'str': replaced = "string"; break
            default:
        }
        o.write(replaced)
        //if (this.opt('<')) {
        //    this.children = this.reqSeparatedList(Identifier, ',', '>')
        //}
    }
}
Grammar.TypeAnnotation.prototype.produce = TypeAnnotationWriter.prototype.produceTS

export class VarDeclWriter extends Grammar.VariableDecl {
    produceTS() {
        const o = this.owner.codeWriter
        o.write(this.name)
        this.typeAnnotation?.produce()

        if (this.assignedExpression) {

            o.write(" = ")

            if (this.assignedExpression.name === 'env') { //rust 'env' => AS 'Context'

                o.write('Context.')

                switch (this.assignedExpression.root.name) {
                    case 'env::signer_account_id':
                        o.write('sender')
                        break;

                    default:
                        this.assignedExpression.root.produce()
                }
            }

            else {
                this.assignedExpression.produce()
            }
        }
    }
}
Grammar.VariableDecl.prototype.produce = VarDeclWriter.prototype.produceTS

export class ExpressionWriter extends Grammar.Expression {
    produceTS() {
        //const o = this.owner.codeWriter
        this.root?.produce()
    }
}
Grammar.Expression.prototype.produce = ExpressionWriter.prototype.produceTS

export class ParenExpressionWriter extends Grammar.ParenExpression {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("(")
        this.produceChildren()
        o.write(")")
    }
}
Grammar.ParenExpression.prototype.produce = ParenExpressionWriter.prototype.produceTS

export class LetStatementWriter extends Grammar.LetStatement {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("let ")
        this.produceChildren(", ")
    }
}
Grammar.LetStatement.prototype.produce = LetStatementWriter.prototype.produceTS

export class VarRefWriter extends Grammar.VarRef {
    produceTS() {
        const o = this.owner.codeWriter
        if (this.name == 'self') {
            o.write('this')
        }
        else if (this.name == 'env::log') { //rust 'env::log' => AS logging.log
            o.write('logging.log')
        }
        else {
            o.write(this.name.replace("::", "."))
        }
        //accessors 
        this.produceChildren()
    }
}
Grammar.VarRef.prototype.produce = VarRefWriter.prototype.produceTS

const superObjectLiteralProduce: Function = Grammar.ObjectLiteral.prototype.produce
export class ObjectLiteralWriter extends Grammar.ObjectLiteral {
    produceTS() {
        const o = this.owner.codeWriter
        o.indent += 4
        superObjectLiteralProduce.call(this)
        if (this.name) { //"struct-instantiation") {
            o.write(` as ${this.name}`)
        }
        o.indent -= 4
    }
}
Grammar.ObjectLiteral.prototype.produce = ObjectLiteralWriter.prototype.produceTS

export class FunctionArgumentWriter extends Grammar.FunctionArgument {
    produceTS() {
        const o = this.owner.codeWriter
        if (this.expression) {
            this.expression.produce()
        }
        else {
            o.write("undefined") // rust _ wildcard argument
        }
    }
}
Grammar.FunctionArgument.prototype.produce = FunctionArgumentWriter.prototype.produceTS

// ---------------------------
//function outNativeRustConversionMapCollect(item: ASTBase) {
//    //veo si al final de la expresion hay uno o mas .into() o .as_u128() .to_vec() .map() . collect() etc, 
//    // que son sufijos de conversiones de rust y de map()
//    const o = item.owner.codeWriter
//    if (item.nativeSuffixes) {
//        for (const suffixIdent of item.nativeSuffixes.children) {
//            o.write(".")
//            suffixIdent.produce()
//            o.write("(")
//            suffixIdent.produceChildren()
//            o.write(")")
//        }
//    }
//}

export class RustClosureWriter extends Grammar.RustClosure {
    produceTS() {
        const o = this.owner.codeWriter
        o.write("function(")
        for (const param of this.params) {
            param.produce()
        }
        o.writeLine(") {")
        if (this.children.length == 1 && this.children[0] instanceof Grammar.Expression) {
            o.write("return ")
        }
        this.produceChildren()
        o.writeLine("}")
    }
}
Grammar.RustClosure.prototype.produce = RustClosureWriter.prototype.produceTS

// ---------------------------
export class IfStatementWriter extends Grammar.IfStatement {
    //conditional: Expression
    // ---------------------------
    produceTS() {
        const o = this.owner.codeWriter
        o.write("if (")
        this.conditional.produce()
        o.write("){")
        this.children[0].produce()
        o.write("}")
        if (this.children.length > 1) {
            o.write("else {")
            this.children[0].produce()
            o.write("}")
        }
    }
}
Grammar.IfStatement.prototype.produce = IfStatementWriter.prototype.produceTS
// end class IfStatement

export class ContractCliProducer {

    static produce(root: ASTBase, data: any, outFilename: string) {

        const parser: Parser = root.owner
        parser.codeWriter = new CodeWriter(outFilename, data)

        root.produce()

        parser.codeWriter.close()

    }
}

'''
'''--- src/lib/util/ControlledError.ts ---
export class ControlledError extends Error {

    soft:Boolean

    constructor(message?:string){
        super(message)
    }
    
}

'''
'''--- src/lib/util/String.extensions.ts ---
//utils.ts
//## utility methods 

interface String {
  replaceAll: (searched: string, newStr: string) => string;
  quoted(quoteChar: string): string;
  countSpaces(): number;
}

String.prototype.replaceAll = function (searched: string, newStr: string) {
    return searched.replace(new RegExp(searched, 'g'), newStr)
}
String.prototype.quoted = function (quoteChar: string) {
    return `${quoteChar}${this}${quoteChar}`
}
String.prototype.countSpaces = function () {
    //var inx=0
    let inx = 0
    //while inx<this.length
    while (inx < this.length) {
    //if this.charAt(inx) isnt ' ', break
        if (this.charAt(inx) !== ' ') { break }
        //inx++
        inx++
    }// end loop

    //return inx
    return inx
}

/*
//Helper methods to class String.
//Also add 'remove' & 'clear' to class Array

    //    append to class String

        //shim method startsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'startsWith'))
        startsWith = function(text){
            //return this.slice(0, text.length) is text
            return this.slice(0, text.length) === text;
        };

        //shim method endsWith(text:string)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'endsWith'))
        endsWith = function(text){
            //return this.slice(-text.length) is text
            return this.slice(-text.length) === text;
        };

        //shim method trimRight()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimRight'))
        trimRight = function(){
            //if no this.length into var inx, return this //empty str
            var inx:=undefined
            if (!((inx=this.length))) {return this};
            //do
            do{

                //inx--
                inx--;
            } while (inx >= 0 && this.charAt(inx) === ' ');// end loop
            //return this.slice(0,inx+1)
            return this.slice(0, inx + 1);
        };

        //shim method trimLeft()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'trimLeft'))
        trimLeft = function(){
            //if no this.length into var len, return this
            var len:=undefined
            if (!((len=this.length))) {return this};
            //var inx=0
            var inx = 0;
            //while inx<len and this.charAt(inx) is ' '
            while(inx < len && this.charAt(inx) === ' '){
                //inx++
                inx++;
            };// end loop
            //return this.slice(inx)
            return this.slice(inx);
        };

//.capitalized

        //method capitalized returns string
        // ---------------------------
        capitalized = function(){
           //if this, return "#{this.charAt(0).toUpperCase()}#{this.slice(1)}"
           if (this) {return `${this.charAt(0).toUpperCase()}#{this.slice(1)}`};
        };

//.replaceAll, equiv. to .replace(/./g, newStr)

        //shim method replaceAll(searched,newStr)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'replaceAll'))
        replaceAll = function(searched, newStr){
           //return this.replace(new RegExp(searched,"g"), newStr)
           return this.replace(new RegExp(searched, 'g'), newStr);
        };

//.countSpaces()

        //shim method countSpaces()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'countSpaces'))
        countSpaces = function(){
            //var inx=0
            var inx = 0;
            //while inx<this.length
            while(inx < this.length){
                //if this.charAt(inx) isnt ' ', break
                if (this.charAt(inx) !== ' ') {break};
                //inx++
                inx++;
            };// end loop

            //return inx
            return inx;
        };

//.quoted(quotechar)

        //method quoted(quoteChar)
        // ---------------------------
        quoted = function(quoteChar){
            //return '#{quoteChar}#{this}#{quoteChar}'
            return `${quoteChar}#{this}#{quoteChar}`;
        };

        //shim method rpad(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'rpad'))
        rpad = function(howMany){
            //return .concat(String.spaces(howMany-.length))
            return this.concat(String.spaces(howMany - this.length));
        };

//repeat(howMany)

        //shim method repeat(howMany)
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'repeat'))
        repeat = function(howMany){
            //if howMany<=0, return ''
            if (howMany <= 0) {return ''};

            //var a=''
            var a = '';
            //while howMany--
            while(howMany--){
                //a &= this
                a += this;
            };// end loop

            //return a
            return a;
        };

    //    append to namespace String

//Checks if a name is Capitalized, unicode aware.
//capitalized is like: /^[A-Z]+[$_a-z0-9]+$/ ,but unicode aware.

        //method isCapitalized(text:string) returns boolean
        // ---------------------------
        isCapitalized = function(text){
            //if text and text.charAt(0) is text.charAt(0).toUpperCase()
            if (text && text.charAt(0) === text.charAt(0).toUpperCase()) {

                //if text.length is 1, return true;
                if (text.length === 1) {return true};

                //for n=1 while n<text.length
                for( var n=1; n < text.length; n++) {
                    //if text.charAt(n) is text.charAt(n).toLowerCase(), return true
                    if (text.charAt(n) === text.charAt(n).toLowerCase()) {return true};
                };// end for n

            };

            //return false
            return false;
        };

//String.findMatchingPair(text,start,closer).
//Note: text[start] MUST be the opener char

        //method findMatchingPair(text:string, start, closer)
        // ---------------------------
        findMatchingPair = function(text, start, closer){
            //var opener=text.charAt(start);
            var opener = text.charAt(start);
            //var opencount=1;
            var opencount = 1;
            //for n=start+1 while n<text.length
            for( var n=start + 1; n < text.length; n++) {
                //if text.charAt(n) is closer and --opencount is 0
                if (text.charAt(n) === closer && --opencount === 0) {

                    //return n
                    return n;
                }
                //if text.charAt(n) is closer and --opencount is 0

                else if (text.charAt(n) === opener) {

                    //opencount++
                    opencount++;
                };
            };// end for n

            //return -1
            return -1;
        };

    //    append to class Array

//method .remove(element)

        //shim method remove(element)  [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'remove'))
        Object.defineProperty(
        ,'remove',{value:function(element){

            //if this.indexOf(element) into var inx >= 0
            var inx:=undefined
            if ((inx=this.indexOf(element)) >= 0) {

                 //return this.splice(inx,1)
                 return this.splice(inx, 1);
            };
        }
        ,enumerable:false
        });

        //shim method clear       [not enumerable]
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'clear'))
        Object.defineProperty(
        ,'clear',{value:function(){
            //empty the array
            //for n=1 to .length
            var _end7=this.length;
            for( var n=1; n<=_end7; n++) {
                //.pop
                this.pop();
            };// end for n

        }
        ,enumerable:false
        });

//##Console group

    //    append to namespace console

//Note: Today, Node.js "console" object do not have `group` & `groupEnd` methods
//neither do older browsers

        //properties indentLevel

        //properties indentLevel

        //shim method group()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'group'))
        group = function(){
            //console.log.apply undefined,arguments
            console.log.apply(undefined, Array.prototype.slice.call(arguments));
            //console.indentLevel = console.indentLevel or 0 + 1
            console.indentLevel = console.indentLevel || 0 + 1;
        };

        //shim method groupEnd()
        // ---------------------------
        if (!Object.prototype.hasOwnProperty.call(,'groupEnd'))
        groupEnd = function(){
            //if console.indentLevel
            if (console.indentLevel) {

                //console.indentLevel--
                console.indentLevel--;
            };
        };
// -----------
// Module code
// -----------
// end of module
*/

'''
'''--- src/lib/util/UTF8FileReader.ts ---
//--------------------
// UTF8FileReader
//--------------------
import * as fs from 'fs';
import { StringDecoder} from "string_decoder";

export class UTF8FileReader {

    filename: string;
    isOpen: boolean = false;
    private chunkSize: number;
    private fd: number; //file handle from fs.OpenFileSync
    private readFilePos: number;
    private readBuffer: Buffer;

    private utf8decoder: StringDecoder

    /**
     * open the file | throw
     * @param filename
     */
    open(filename, chunkSize: number = 16 * 1024) {

        this.chunkSize = chunkSize;

        try {
            this.fd = fs.openSync(filename, 'r');
        }
        catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString());
        }

        this.filename = filename;
        this.isOpen = true;

        this.readBuffer = Buffer.alloc(this.chunkSize);
        this.readFilePos = 0;

        //a StringDecoder is a buffered object that ensures complete UTF-8 multibyte decoding from a byte buffer
        this.utf8decoder = new StringDecoder('utf8')

    }

    /**
     * read another chunk from the file 
     * return the decoded UTF8 into a string
     * (or throw)
     * */
    readChunk(): string {

        let decodedString = '' //return '' by default

        if (!this.isOpen) {
            return decodedString;
        }

        let readByteCount: number;
        try {
            readByteCount = fs.readSync(this.fd, this.readBuffer, 0, this.chunkSize, this.readFilePos);
        }
        catch (e) {
            throw new Error("reading " + this.filename + ", error:" + e.toString());
        }

        if (readByteCount) {
            //some data read, advance readFilePos 
            this.readFilePos += readByteCount;
            //get only the read bytes (if we reached the end of the file)
            const onlyReadBytesBuf = this.readBuffer.slice(0, readByteCount);
            //correctly decode as utf8, and store in decodedString
            //yes, the api is called "write", but it decodes a string - it's a write-decode-and-return the string kind-of-thing :)
            decodedString = this.utf8decoder.write(onlyReadBytesBuf); 
        }
        else {
            //read returns 0 => all bytes read
            this.close();
        }
        return decodedString 
    }

    close() {
        if (!this.isOpen) {
            return;
        }
        fs.closeSync(this.fd);
        this.isOpen = false;
        this.utf8decoder.end();
    }

}

'''
'''--- src/lib/util/UTF8FileWriter.ts ---
//--------------------
// UTF8FileReader
//--------------------
import * as fs from 'fs';

export class UTF8FileWriter {

    filename: string;
    isOpen: boolean = false;
    private fd: number; //file handle from fs.OpenFileSync
    indent: number=0

    /**
     * open the file | throw
     * @param filename
     */
    open(filename) {

        try {
            this.fd = fs.openSync(filename, 'w');
        }
        catch (e) {
            throw new Error("opening " + filename + ", error:" + e.toString());
        }

        this.filename = filename;
        this.isOpen = true;

    }

    /**
     * write text to the file
     * (or throw)
     * */
    write(s: string) {

        if (!this.isOpen) {
            throw new Error(this.filename + " is closed.")
        }
        
        try {
            fs.writeSync(this.fd, s);
        }
        catch (e) {
            throw new Error("writing to " + this.filename + ", error:" + e.toString());
        }
    }

    writeLine(s: string) {
        this.write(' '.repeat(this.indent) + s + '\n')
    }
    
    close() {
        if (!this.isOpen) {
            return;
        }
        fs.closeSync(this.fd);
        this.isOpen = false;
    }

}

'''
'''--- src/lib/util/color.ts ---
export namespace color{
            export const normal = '\x1b[39;49m'
            export const red = '\x1b[91m'
            export const yellow = '\x1b[93m'
            export const green = '\x1b[32m'
    }
'''
'''--- src/lib/util/logger.ts ---
import { color } from './color.js'
import { ControlledError } from './ControlledError.js'

//Main namespace
/*eslint no-inner-declarations: "off"*/
export namespace logger {

    //errorCount = 0
    //warningCount = 0

    //if storeMessages, messages are pushed at messages[] instead of console.

    //storeMessages: boolean
    //messages: string Array = []

    //Implementation
    //---------------

    //     properties

    //errorCount = 0
    //warningCount = 0

    //if storeMessages, messages are pushed at messages[] instead of console.

    export var storeMessages: boolean
    export var verboseLevel = 1
    export var errorCount = 0
    export var warningLevel= 0
    export var warningCount = 0
    export var messages = []
    export var debugEnabled = false
    export var verboseLevel = 1
    //     method debug
    // ---------------------------
    // eslint-disable-next-line no-shadow-restricted-names
    export function debug(...vargs: any[]) {

        //if options.debugEnabled
        if (debugEnabled) {

            //var args = arguments.toArray()
            var args = Array.prototype.slice.call(vargs)
            //console.error.apply undefined,args
            console.error.apply(undefined, args)
        }
    }

    //     method debugGroup
    // ---------------------------
    export function debugGroup() {

        //if options.debugEnabled
        if (debugEnabled) {

            //console.error.apply undefined,arguments
            console.error.apply(undefined, Array.prototype.slice.call(arguments))
            //console.group.apply undefined,arguments
            console.group.apply(undefined, Array.prototype.slice.call(arguments))
        }
    }

    //     method debugGroupEnd
    // ---------------------------
    export function debugGroupEnd() {

        //if options.debugEnabled
        if (debugEnabled) {

            //console.groupEnd
            console.groupEnd()
        }
    }

    //     method error
    // ---------------------------
    export function error(...vargs: any[]) {

        errorCount++
        var args = Array.prototype.slice.call(vargs)

        //add "ERROR:", send to debug logger
        args.unshift('ERROR:')
        debug.apply(undefined, args)

        //if messages should be stored...
        if (storeMessages) {
            messages.push(args.join(' '))
        }
        else {
            args.unshift(color.red)
            args.push(color.normal)
            console.error.apply(undefined, args)
        }
    }

    //     method warning
    // ---------------------------
    export function warning(...vargs: string[]) {

        warningCount++
        var args = Array.prototype.slice.call(vargs)

        args.unshift('WARNING:')
        debug.apply(undefined, args)

        if (warningLevel > 0) {

            //if messages should be stored...
            if (storeMessages) {
                messages.push(args.join(' '))
            }
            else {
                args.unshift(color.yellow)
                args.push(color.normal)
                console.error.apply(undefined, args)
            }
        }
    }

    //     method msg
    // ---------------------------
    export function msg(...vargs: string[]) {

        var args = Array.prototype.slice.call(vargs)
        debug.apply(undefined, args)
        if (verboseLevel >= 1) {

            //if messages should be stored...
            if (storeMessages) {
                messages.push(args.join(' '))
            }
            else {
                console.log.apply(undefined, args)
            }
        }
    }

    //     method info
    // ---------------------------
    export function info() {

        var args = Array.prototype.slice.call(arguments)
        if (verboseLevel >= 2) {

            //msg.apply(undefined,args)
            msg.apply(undefined, args)
        }
    }

    //     method extra
    // ---------------------------
    export function extra() {

        var args = Array.prototype.slice.call(arguments)
        if (verboseLevel >= 3) {
            msg.apply(undefined, args)
        }
    }

    //     method getMessages
    // ---------------------------
    export function getMessages() {
        //get & clear
        var result = messages
        messages = []
        return result
    }

    //     method throwControlled(msg)
    // ---------------------------
    export function throwControlled(errorMsg: string) {

        //Throws Error, but with a "controlled" flag set,
        //to differentiate from unexpected compiler errors

        debug('Controlled ERROR:', errorMsg)
        throw new ControlledError(errorMsg)
    }

}

'''
'''--- src/lib/util/mkPath.ts ---
//Generated by LiteScript compiler v0.8.9, source: lib/mkPath.lite.md
// -----------
// Module Init
// -----------
//=============

//import fs, path
import * as fs from 'fs'
import * as path from 'path'

//    export function toFile(filename, mode)
// ---------------------------
export function toFile(filename: string) {
    //Create a path to a file
    create(path.dirname(filename))
}

//    export function create (dirPath, mode)
// ---------------------------
export function create(dirPath) {
    //Make sure a path exists - Recursive

    if (dirExists(dirPath)) { return } //ok! dir exists

    //else... recursive:
    //try a folder up, until a dir is found (or an error thrown)
    create(path.dirname(dirPath)) //recurse

    //ok, found parent dir! - make the children dir
    fs.mkdirSync(dirPath)

    //return into recursion, creating children subdirs in reverse order (of recursion)
    return
}

//    helper function dirExists(dirPath)
// ---------------------------
export function dirExists(dirPath) {
    try {

        if (fs.statSync(dirPath).isDirectory()) {
            return true //ok! exists and is a directory
        }
        else {
            throw new Error(`${dirPath} exists but IT IS NOT a directory`)
        }

    } catch (err) {

        //if dir does not exists, return false
        if (err.code === 'ENOENT') { return false }
        throw err //another error
    }
}

'''
'''--- src/test/expect.ts ---
import { inspect } from "util";
// ------------------------------
// -- function expect().toBe() --
// ------------------------------

// ---------------------------
function deepEqual(object1:any, object2:any) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);

    if (keys1.length !== keys2.length) {
        return false;
    }

    for (const key of keys1) {
        const val1 = object1[key];
        const val2 = object2[key];
        const areObjects = isObject(val1) && isObject(val2);
        if (
            areObjects && !deepEqual(val1, val2) ||
            !areObjects && val1 !== val2
        ) {
            console.log(red+val1 + " !== " + val2 + normal)
            return false;
        }
    }

    return true;
}

function isObject(object) {
    return object != null && typeof object === 'object';
}

let saveReceived: any = undefined;
const red = '\x1b[91m'
const yellow = '\x1b[93m'
const green = '\x1b[32m'
const normal = '\x1b[39;49m'

function expect(received:any) {
    saveReceived = received
    return expect.prototype
}
expect.prototype.toBe = function (expected, message) {
    let eq = false;
    message = message? message : ""
    if (isObject(expected) && isObject(saveReceived)) {
        eq = deepEqual(expected, saveReceived)
    }
    else {
        eq = (expected == saveReceived)
    }
    if (!eq) {
        console.log(red+"expect failed: " + message +normal);
        console.log("      received: " + inspect(saveReceived, { depth: 10 }));
        console.log("      expected: " + inspect(expected, { depth: 10 }));
    }
    else {
        console.log(green+"OK. " + message + normal);
    }
    return expect.prototype
}

export default expect

'''
'''--- src/test/test.AssemblyScript.ts ---
import * as path from "path"
import * as mkPath from "../lib/util/mkPath.js"
import { copyFileSync, readFileSync } from "fs"
import { logger } from "../lib/util/logger.js"
import { Parser } from "../lib/Parser/Parser.js"
import { AssemblyScriptProducer as Producer} from "../lib/Producer/AssemblyScriptProducer.js"
import { color } from "../lib/util/color.js"

export function testAssemblyScript() {

    console.log("Testing AssemblyScript Transpiler")

    logger.debugEnabled = false

    const outPath = "out"
    mkPath.create(outPath)

    console.log("writing temp files in " +path.join(process.cwd(), outPath))

    //parse
    let parsedModule 
    try {
        const parser = new Parser()
        parsedModule = parser.parseFile('./res/test/staking-pool/src/lib.rs')
    }
    catch (ex) {
        console.log(ex)
        console.log(process.cwd())
        console.log("Error parsing " + parsedModule?.name)
        throw(ex)
    }

    console.log("parsed ok: " + parsedModule?.name)

    const generatedFile= path.join(outPath, "out.js")

    //produce
    try {
        Producer.produce(parsedModule, generatedFile)
    }
    catch (ex) {
        console.log(ex)
        console.log("Error producing " + parsedModule?.name)
        throw (ex)
    }

    const generated = readFileSync(generatedFile)

    const expectedFile = "./res/test/expected/staking-pool.js"
    const expected = readFileSync(expectedFile)

    if (generated.toString()!==expected.toString()){
        console.log(color.red+"FAILED "+color.normal)
        console.log("expected: "+expectedFile)
        console.log("generated: "+generatedFile)
    }
    else {
        console.log("AssemblyScript Transpiler "+color.green+"OK"+color.normal)
       
    }
}

'''
'''--- src/test/test.Tokenizer.ts ---
import { TokenCode, Lexer, Token } from "../lib/Lexer/Lexer.js"
import expect from "./expect.js"

export function testTokenizer() {

    process.stdout.write("Testing tokenizer ")

    let lexer = new Lexer()

    let rustCode = "\n\
    /// The amount of gas given to complete `vote` call.\n\
    const VOTE_GAS: u64 = 100_000_000_000_000;\n\
    \n\
    /// The amount of gas given to complete internal `on_stake_action` call.\n\
    const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;\n\
    "

    lexer.startFromString(rustCode)

    let tokens: string[] = []
    while (true) {
        let t: Token = lexer.token
        if (!t.isSpace()) tokens.push(`(${TokenCode[t.tokenCode]} ${t.value})`)
        if (t.tokenCode == TokenCode.EOF) break
        lexer.advance()
    }

    expect(tokens).toBe(
        ["(COMMENT /// The amount of gas given to complete `vote` call.)",
            "(WORD const)", "(WORD VOTE_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(ASSIGNMENT =)", "(NUMBER 100_000_000_000_000)", "(PUNCTUATION ;)",
            "(COMMENT /// The amount of gas given to complete internal `on_stake_action` call.)",
            "(WORD const)", "(WORD ON_STAKE_ACTION_GAS)", "(PUNCTUATION :)", "(WORD u64)", "(ASSIGNMENT =)", "(NUMBER 20_000_000_000_000)", "(PUNCTUATION ;)",
            "(EOF )"])

}

'''
'''--- src/test/test.ts ---
import {testTokenizer} from "./test.Tokenizer.js"
import {testAssemblyScript} from "./test.AssemblyScript.js"

console.log("---------- START TESTS ---------")

testTokenizer()
testAssemblyScript()

console.log("---------- END TESTS ---------")

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "module": "ES2020",
        "target": "ES2019",
        "lib": [ "ES2019" ],
        "sourceMap": true,
        "outDir": "dist",
        "rootDir": "src",
    },
    "include": ["src"]

}

'''
'''--- z-old/test_OLD/Test.TokenizeDeclaration.ts ---
import { TokenCode, Lexer } from "../src/Lexer/Lexer"

/*describe("Tokenizer", function () {
    it("should parse a declaration", function () {
        let lexer = new Lexer()

        let rustCode = "\n\
            /// The amount of gas given to complete `vote` call.\n\
            const VOTE_GAS: u64 = 100_000_000_000_000;\n\
            \n\
            /// The amount of gas given to complete internal `on_stake_action` call.\n\
            const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;\n\
            "
        lexer.startFromString(rustCode)

        let tokens: string[] = []
        while (true) {
            let t = lexer.token
            if (!t.isSpace()) tokens.push(t.toString())
            if (t.tokenCode == TokenCode.EOF) break
            lexer.advance()
        }
        assert.deepEqual(tokens,
            ["(BOF)",
                "(COMMENT /// The amount of gas given to complete `vote` call.)",
                "(IDENTIFIER const)", "(IDENTIFIER VOTE_GAS)", "(PUNCTUATION :)", "(IDENTIFIER u64)", "(OPERATOR =)", "(NUMBER 100_000_000_000_000)", "(PUNCTUATION ;)",
                "(COMMENT /// The amount of gas given to complete internal `on_stake_action` call.)",
                "(IDENTIFIER const)", "(IDENTIFIER ON_STAKE_ACTION_GAS)", "(PUNCTUATION :)", "(IDENTIFIER u64)", "(OPERATOR =)", "(NUMBER 20_000_000_000_000)", "(PUNCTUATION ;)",
                "(EOF)"
            ])
    })
})
*/

'''
'''--- z-old/test_OLD/UnitTest1.ts ---
/*import assert = require('assert');

describe("Test Suite 1", () => {
    it("Test A", () => {
        assert.ok(true, "This shouldn't fail")
    })

    it("Test B", () => {
        assert.ok(1 === 1, "This shouldn't fail")
        assert.ok(false, "This should fail")
    })
})
*/
'''
'''--- z-old/tests-ccc/model/hand-coded-tom/.vscode/tasks.json ---
{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    "version": "2.0.0",
    "tasks": [
      {
        "type": "typescript",
        "tsconfig": "tsconfig.json",
        "problemMatcher": ["$tsc"],
        "group": {
          "kind": "build",
          "isDefault": true
        }
      }
    ]
  }
'''
'''--- z-old/tests-ccc/model/hand-coded-tom/ContractAPI.ts ---
import { spawnNearCli } from "./util/SpawnNearCli.js"
import { CommandLineArgs } from "./util/CommandLineArgs.js"
import { commonCliOptions } from "./util/CommonCLIOptions.js"

//name of this script
export const NickName = "tom" 
//account id where this contrat is deployed
export const defaultContractName = "tomcontract.near"

//one function for each pub fn in the contract
//get parameters by consuming from CommandLineParser
export class ContractAPI {
    
    deploy_help = `
    deploy a WASM file into the account ${defaultContractName} and call init function
    
    usage:
    > ${NickName} deploy [--account xx] code.WASM new { owner_id:string, stake_public_key:string, reward_fee_fraction: { numerator:x, denominator:y } }
    
    example:
    > ${NickName} deploy code.WASM new { owner_id:lucio.near, stake_public_key:"7fa387483934", reward_fee_fraction: { numerator:8, denominator:100 } }
    willl deploy code.WASM at ${defaultContractName} and then initialize it
    `;
    
    deploy(a: CommandLineArgs) {
        
        const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
        
        const wasmFile = a.consumeString("wasmFile")

        a.optionalString("new") //can be ommited
        
        const initArgs = a.consumeJSON("init fn params")
        
        a.noMoreArgs()
        
        const nearCliArgs = [
            'deploy',
            contract,
            wasmFile,
            "new", JSON.stringify(initArgs)
        ]
        
        a.addOptionsTo(nearCliArgs); //add any other --options found the command line
        
        spawnNearCli(nearCliArgs);
        
    }
    
    ping_help =`
    Distributes rewards and restakes if needed.
    
    usage:
    > tom ping `;
    
    ping(a :CommandLineArgs) {
        
        //consume contract name from options if present
        const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
        
        a.noMoreArgs() //end of arguments
        
        const nearCliArgs = [
            "call",
            contract,
            "ping",
        ]
        
        a.addOptionsTo(nearCliArgs); //add any other --options found the command line
        
        spawnNearCli(nearCliArgs);
        
    }
    
    get_accounts_help: string = `
    get registered accounts from the contract
    
    usage:
    > ${NickName} get_accounts { from_index:number, limit:number }
    
    example:
    > ${NickName} get_accounts { from_index:0, limit:10 }
    will get 10 accounts starting from 0
    `;
    get_accounts(a: CommandLineArgs) {
        
        const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
        
        const params = a.consumeJSON("{ from_index:number, limit:number }")
        
        a.noMoreArgs()
        
        const nearCliArgs = [
            'view',
            contract,
            "get_accounts",
            JSON.stringify(params)
        ]
        
        a.addOptionsTo(nearCliArgs); //add any other --options found the command line
        
        spawnNearCli(nearCliArgs);
        
    }
    
    deposit_help: string = `
    deposit into the contract for staking later
    
    usage:
    > ${NickName} deposit --accountId myaccount.betanet --attach Near-amount
    
    example:
    > ${NickName} deposit --accountId myaccount.betanet --attach 40N
    will deposit 40N on behalf of myaccount.betanet into the pool
    
    `;
    deposit(a: CommandLineArgs) {
        
        const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
        
        a.requireOptionString(commonCliOptions.accountId); //require accountId
        
        a.requireOptionWithAmount(commonCliOptions.amount, "N"); //require --amount, in Nears
        
        a.noMoreArgs()
        
        const nearCliArgs = ['call',
        contract,
        "deposit",
    ]
    
    a.addOptionsTo(nearCliArgs); //add any other --options found the command line
    
    spawnNearCli(nearCliArgs);
}

//function depo: example manually coded composed/aternative command
depo_help: string = `
shotcut for deposit

usage:
> ${NickName} depo amountN myaccount.betanet [and] [stake]

example:
> ${NickName} depo 40N myaccount.betanet 
will deposit 40N on behalf of myaccount.betanet into ${NickName}'s pool
> ${NickName} depo 40N myaccount.betanet anf stake
will deposit 40N on behalf of myaccount.betanet into ${NickName}'s pool and stake it in the same transaction

`;
depo(a: CommandLineArgs) {
    
    const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
    
    const amount = a.consumeAmount("amount to deposit", "N");
    
    const account = a.consumeString("accountId");
    
    //check if [and] [stake] is next in the command line
    a.optionalString("and")
    let stake = a.optionalString("stake")
    
    const fnToCall = stake ? "deposit_and_stake" : "deposit"
    
    a.noMoreArgs()
    
    const nearCliArgs = ['call',
    contract,
    fnToCall,
    "--accountId", account,
    "--amount", amount
]

a.addOptionsTo(nearCliArgs); //add any other --options found the command line

spawnNearCli(nearCliArgs);
}

get_total_staked_balance(a: CommandLineArgs) {
    
    const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
    
    a.noMoreArgs()
    
    const nearCliArgs = [
        'view',
        contract,
        "get_total_staked_balance"
    ]
    
    a.addOptionsTo(nearCliArgs); //add any other --options found the command line
    
    spawnNearCli(nearCliArgs);
}

get_owner_id(a: CommandLineArgs) {
    
    const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
    
    a.noMoreArgs()
    
    const nearCliArgs = [
        'view',
        contract,
        "get_owner_id"
    ]
    
    a.addOptionsTo(nearCliArgs); //add any other --options found the command line
    
    spawnNearCli(nearCliArgs);
}

get_staking_key(a: CommandLineArgs) {
    
    const contract = a.consumeOption(commonCliOptions.contractName) || defaultContractName
    
    a.noMoreArgs()
    
    const nearCliArgs = [
        'view',
        contract,
        "get_staking_key"
    ]
    
    a.addOptionsTo(nearCliArgs); //add any other --options found the command line
    
    spawnNearCli(nearCliArgs);
}

//function info: example manually coded composed command
info(a: CommandLineArgs) {
    this.get_owner_id(a)
    this.get_staking_key(a)
    this.get_total_staked_balance(a)
}

}

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/package-lock.json ---
{
  "name": "hand-coded-tom",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@types/node": {
      "version": "14.11.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.11.2.tgz",
      "integrity": "sha512-jiE3QIxJ8JLNcb1Ps6rDbysDhN4xa8DJJvuC9prr6w+1tIh+QAbYyNF3tyiZNLDBIuBCf4KEcV2UvQm/V60xfA==",
      "dev": true
    },
    "typescript": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.3.tgz",
      "integrity": "sha512-tEu6DGxGgRJPb/mVPIZ48e69xCn2yRmCgYmDugAVwmJ6o+0u1RI18eO7E7WBTLYLaEVVOhwQmcdhQHweux/WPg==",
      "dev": true
    }
  }
}

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/package.json ---
{
  "name": "hand-coded-tom",
  "version": "1.0.0",
  "description": "model for create-command-cli",
  "main": "tom.js",
  "scripts": {
    "test": "tom --help"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/luciotato/tom.git"
  },
  "keywords": [
    "create-command-cli"
  ],
  "author": "Lucio Tato",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/luciotato/tom/issues"
  },
  "homepage": "https://github.com/luciotato/tom/#readme",
  "devDependencies": {
    "@types/node": "^14.11.2",
    "typescript": "^4.0.3"
  }
}

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/tom.ts ---
import { CommandLineArgs } from "./util/CommandLineArgs.js"
import { ShowHelpPage } from "./util/ShowHelpPage.js"
import { NickName, ContractAPI } from "./ContractAPI.js"
import { commonCliOptions } from "./util/CommonCLIOptions.js"

const API:any = new ContractAPI()

const args = new CommandLineArgs(commonCliOptions)

//check if the command is in the API
if (args.command && typeof API[args.command] != "function") {
    console.log("ERROR: unknown command " + args.command)
    console.log(`${NickName} --help to see a list of commands`)
    process.exit(1)
}

//Show help
if (args.options.help) {
    ShowHelpPage(args.command, API, commonCliOptions)
    process.exit(0)
}

//default network
if (!args.options.networkId) {
    args.options.networkId = "betanet"
}

//call the contract API -> near-cli
API[args.command](args);

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/tsconfig.json ---
{
    "$schema": "https://json.schemastore.org/tsconfig",
    "display": "Node 12+es2020",
   
    "compilerOptions": {
      "lib": ["es2020", "es2020.promise", "es2020.bigint", "es2020.string"],
      "module": "es2020",
      "target": "es2020",
      "outDir": "dist",
      "sourceMap": true,
   
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    }  
  }
'''
'''--- z-old/tests-ccc/model/hand-coded-tom/util/CommandLineArgs.ts ---
/**
 #Simple and minimun command line args parser
 * 
 ##Functionalities:
 * * Rebuilds JSON object from severral CL args. 
 *    --Note:  spaces *must* be used around { and }
 * 

##Separates positional arguments from --options
-------------------------------
```
>mycontract transfer { account_id:luciotato, dest:otheraccount.betanet, stake:false } --amount 100N

result:
positional:
[ 
    {
     account_id:"luciotato",
     dest:"otheraccount.betanet",
     stake:false,
    }
]
options:
[
    "amount" : "100_000_000_000_000_000_000_000_000"
]
```

-----------------------------
## Planned funcionalities:
### parse [ ]
*/

import { sep } from "path"; //host OS path separator
import { inspect } from "util";

export type OptionDeclaration =
    {
        name: string;
        shortName: string;
        valueType?: string;
        helpText?: string
    }

export class CommandLineArgs {

    clArgs: string[] //initial list process.argv

    positional: (string | {})[] //string or JSON objects -- positional arguments

    public options: any; // options. e.g.:  --its-on  -o  --amount 100N

    public command: string;

    constructor(optionsDeclaration: any) {

        this.clArgs = process.argv
        this.options = {}
        this.positional = []

        //remove 'node' if called as a node script
        if (this.clArgs.length && (this.clArgs[0] === 'node'
            || this.clArgs[0].endsWith(sep + 'node'))
            || this.clArgs[0].endsWith(sep + 'node.exe')
        ) {
            this.clArgs = this.clArgs.slice(1);
        };

        //remove this script/executable name from command line arguments
        this.clArgs = this.clArgs.slice(1);

        if (this.clArgs.length === 0) { //no command => --help
            this.options.help = true;
            this.command = ""
            return
        }

        //process each item separating options from posiitonal args

        //First: process --options 
        for (const key in optionsDeclaration) {
            const optionDecl = optionsDeclaration[key]
            //search for option name & variations 
            const pos = this.searchOption(optionDecl)
            if (pos >= 0) { //found in command line args

                const literal = this.clArgs[pos]; //as written
                this.clArgs.splice(pos, 1); //remove from cl args

                if (optionDecl.valueType) { //has a value
                    if (pos >= this.clArgs.length) {
                        console.log("expecting value after " + literal)
                        process.exit(1)
                    }
                    const value = this.clArgs[pos]; //take value
                    this.options[optionDecl.name] = value //set value
                    this.clArgs.splice(pos, 1); //also remove value from list
                }
                else //valueless option 
                {
                    this.options[optionDecl.name] = true //set as present 
                }
            }
        }

        //if at this point there are still --opt or -opt in the command line args, those are unknown options
        let hasErrors = false
        for (const item of this.clArgs) {
            if (item.startsWith("-")) {
                console.log("UNKNOWN option: " + item)
                hasErrors = true
            }
        }
        if (hasErrors) process.exit(1);

        //create consumible positional arguments, processing JSON command-line format
        for (let index = 0; index < this.clArgs.length; index++) {
            const item = this.clArgs[index]
            if (item == "{") { //a JSON object in the command line
                const extracted = this.extractJSONObject(index)
                this.positional.push(extracted.value)
                index = extracted.end
            }
            else {
                this.positional.push(item)
            }
        }

        //command is the 1st positional argument
        //special case, no command => "--help"
        if (this.positional.length === 0) {
            this.options.help = true;
            this.command = ""
        }
        else if (this.positional.length > 0 && typeof this.positional[0] !== "string") {
            console.log("ERROR: expected a command as first argument'")
            process.exit(1)
        }
        else {
            //take the first argument
            this.command = this.positional.shift() as string
        }
    }

    /**
     * consume one string from the positional args
     * if it matches the expected string
     * returns false if the next arg doesn't match
     * @param which which string is expected
     */
    optionalString(which:string) {
        
        if (this.positional.length == 0) return false;

        if (typeof this.positional[0] != "string") {
            console.log(`ERROR: expected a string argument, got {... }`)
            process.exit(1)
        }
        if (this.positional[0]==which) {
            this.positional.shift() //consume
            return true
        }
        return false //not the expected string
    }

    /**
     * requires a string as the next positional argument
     * @param name
     */
    consumeString(name: string) {
        if (this.positional.length == 0) {
            console.log(`ERROR: expected ${name}' argument`)
            process.exit(1)
        }
        if (typeof this.positional[0] != "string") {
            console.log(`ERROR: expected ${name} string argument, got {... }`)
            process.exit(1)
        }
        return this.positional.shift() as string
    }

    /**
     * requires an amount in NEAR or YOCTO as the next positional argument
     * @param name
     */
    consumeAmount(name: string, units: "N" | "Y"): string {
        let value = this.consumeString(name)
        return this.convertAmount(value, units)
    }

    /**
     * requires a JSON as the next positional arg
     * @param name 
     */
    consumeJSON(name: string) {
        if (this.positional.length == 0) {
            console.log(`ERROR: expected ${name} as { }`)
            process.exit(1)
        }
        if (typeof this.positional[0] == "string") {
            console.log(`ERROR: expected ${name} as {... } got a string: '${this.positional[0]}'`)
            process.exit(1)
        }
        return this.positional.shift() as any
    }

    /**
     * marks the end of the required arguments
     * if there are more arguments => error
     */
    noMoreArgs() {
        if (this.positional.length) {
            console.log(`ERROR: unrecognized extra arguments`)
            console.log(inspect(this.positional))
            process.exit(1)
        }
    }

    /**
     * requires the presence of an option with an amount
     * @param optionName option name
     */
    requireOptionString(option: OptionDeclaration): void {

        let value: string = this.options[option.name].toString().trim()

        if (value == undefined || value == "") {
            console.log(`ERROR: required --${option.name}`)
            process.exit(1)
        }

        this.options[option.name] = value; //store trimmed
    }

    /**
 * requires the presence of an option with an amount
 * @param optionName option name
 */
    requireOptionWithAmount(option: OptionDeclaration, units: "N" | "Y"): void {

        let value: string = this.options[option.name].toString().trim()

        if (value == undefined || value == "") {
            console.log(`ERROR: required --${option.name}`)
            process.exit(1)
        }

        const converted = this.convertAmount(value, units);
        this.options[option.name] = converted; //store in the required units

    }

    /**
     * search for the presence of an option 
     * removes it from the options if found
     * 
     * @param optionName option name
     */
    consumeOption(option: OptionDeclaration, defaultValue?: string): string {

        let value: string = this.options[option.name]

        if (value) { //found
            this.options[option.name] = undefined; //remove from options (consume)
        }

        return value
    }

    /**
     * add options found in command line to nearCliArgs for near-cli
     * @param nearCliArgs prepared array for nearCliArgs, normally containing view|call contractName fn {args}
     */
    addOptionsTo(nearCliArgs: string[]) {

        //for each option 
        for (let key in this.options) {
            const value=this.options[key]
            if (value) { //if it was set
                nearCliArgs.push("--" + key) //add option presence 
                if (typeof value!='boolean') { //if the option included a value 
                    nearCliArgs.push(this.options[key]) //add option value
                }
            }
        }

    }

    /**
     * converts an argument from the command line into a numeric string expresed in the required units
     * example:
     * convertAmount("10N","N") => "10"
     * convertAmount("1.25N","Y") => "12500000000000000000000000"
     * convertAmount("1365465465464564654654Y","N") => "0.00000000001365465465464564654654"
     * convertAmount("100_000_000Y","Y") => "100000000"
     * 
     * @param value string as read from the command line
     * @param requiredUnits N|Y unit in which the amount is required
     */
    convertAmount(value: string, requiredUnits: "N" | "Y") {

        let result: string

        if (value.length > 1 && value.endsWith("N")) { //NEARS
            result = value.slice(0, -1) //remove N
            result = result.replace("_", "") //allow 100_000_000, ignore _
            if (requiredUnits == "N") return result; //already in Nears

            //Yoctos required -- convert to yoctos
            let parts = value.split(".")
            if (parts.length > 2) {
                console.log("ERROR: invalid amount format, too many decimal points: " + value)
                process.exit(1)
            }
            let decimalString = parts[1].padEnd(24, '0')
            result = parts[0] + "" + decimalString // +""+ is for making sure + means concat here
            return result

        }
        else if (value.length > 1 && value.endsWith("Y")) { //YOCTOS

            if (value.includes(".")) {
                console.log("ERROR: invalid amount format, YOCTOS can't have decimals: " + value)
                process.exit(1)
            }

            result = value.slice(0, -1) // remove Y
            result = result.replace("_", "") //allow 100_000_000, ignore _
            if (requiredUnits == "Y") return result; //already in Yoctos

            //NEARS required -- convert to NEARS
            if (result.length <= 24) {
                result = "0." + result.padStart(24, '0').slice(-24)
            }
            else {
                //insert decimal point at 1e24
                result = result.slice(0, result.length - 24) + "." + result.slice(-24)
            }
            return result
        }
        else {
            console.log("ERROR: invalid amount format, expecting [0-9.](Y|N). Received: " + value)
            console.log("valid examples are: 0.5N | 100N | 100_000_000Y")
            process.exit(1)
        }
    }

    /**
     * extract { a: b, d:100 } from the command line as a JSON object
     * @param start open brace position in this.list
     */
    private extractJSONObject(start: number) {

        // find the closing "}"
        let opened = 1
        let end = -1
        for (let n = start + 1; n < this.clArgs.length; n++) {
            const item = this.clArgs[n]
            if (item == "{") {
                opened++;
            }
            else if (item == "}") {
                opened--;
                if (opened == 0) {
                    end = n;
                    break;
                }
            }
        }

        if (end == -1) { //unmatched opener error
            console.log("ERROR: Unmatched '{' . remember to put spaces around { and }")
            this.clArgs[start] = "**{**"
            console.log(this.clArgs.join(" "))
            process.exit(1)
        }

        //Here we have start & end for matching { }
        let resultObj:any = {}
        for (let index = start + 1; index < end; index++) {
            let propName = this.clArgs[index];
            let propValue = undefined

            if (propName == ",") continue;

            if ("{}".includes(propName)) {
                console.log("ERROR: expected name:value")
                this.clArgs[index] = `**${propName}**`
                console.log(this.clArgs.slice(start, end+1).join(" "))
                process.exit(1)
            }

            let parts = propName.split(":")
            propName = parts[0]?.trim()
            propValue = parts[1]?.trim()

            if (propValue == undefined || propValue == "") {
                //let's assume the user typed "name: value" instead of "name:value"
                index++ //take the next arg
                propValue = this.clArgs[index]
                if (index>=end || propValue=="}"){
                    console.log(`ERROR: expected value after ${propName}`)
                    process.exit(1)
                }
            }

            if (propValue == "{") { //subornidated object
                const subObj = this.extractJSONObject(index) //recursive***
                //store as object
                resultObj[propName] = subObj.value
                index = subObj.end //skip internal object
                continue;
            }
            //it's a string
            //remove ending "," if it's there
            if (propValue.endsWith(",")) propValue = propValue.slice(0, propValue.length - 1)
            //check if it's a js-compatible number
            if (propValue.length<=15 && propValue.match(/^[0-9_\.]*$/)) { //it's a js number
                resultObj[propName] = Number(propValue.replace("_", "")) //store as number
                continue;
            }
            //store as string
            resultObj[propName] = propValue

        } //end for

        //return positions and composed object
        return { start: start, end: end, value: resultObj }
    }

    // ---------------------------
    /**
     * removes valueless options into the options object
     * returns true if the option was present
     * @param shortName short name, e.g -verb
     * @param fullName full name,e.g. --verbose
     */
    /*
    option(shortName: string, fullName: string) {

        //if .getPos(shortOption,argName) into var pos >= 0
        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) {
            this.positional.splice(pos, 1);
            return true;
        };
        return false;
    }
     */

    // ---------------------------
    /**
     * removes options that has a value after it
     * @param shortName short name, e.g -ata 100N
     * @param fullName full name,e.g. --attach 100N
     */
    /*
    valueFor(shortName: string, fullName: string) {

        var pos = this.removeOption(shortName, fullName);
        if (pos >= 0) { //found
            var value = this.positional[pos + 1]; //take value
            this.positional.splice(pos, 2);
            return value;
        };
        return undefined; //not found
    }
    */

    // ---------------------------
    /**
     * search for an option in the command line args, with variations
     * removes the option from the array
     * return position in the array where it was found|-1
     */
    private searchOption(option: OptionDeclaration): number {

        let name = option.name
        let shortName = option.shortName

        //search several possible forms of the option, e.g. -o --o -outdir --outdir
        var variants = ['-' + name, '--' + name];
        if (shortName) { variants.push('--' + shortName, '-' + shortName) };

        //for each item in list
        for(const variant of variants){
            var inx = this.clArgs.indexOf(variant);
            if (inx >= 0) {
                return inx //found
            }
        }
        return -1;//not found
    }

}
// end class CommandLineArgs

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/util/CommonCLIOptions.ts ---
export const commonCliOptions = {

    help: {
        name: "help",
        shortName: "h",
    },

    verbose: {
        name: "verbose",
        shortName: "v",
        helpText: 'Prints out verbose output',
    },

    amount: {
        name: "amount",
        shortName: "am",
        valueType: "NEAR",
        helpText: `attach NEAR tokens to this call. Example: --amount 100N`
    },

    networkId:{
        name: "networkId",
        shortName: "net",
        valueType: "string",
        helpText: 'NEAR network ID, allows using different keys based on network',
    },

    accountId:{
        name: "accountId",
        shortName: "acc",
        valueType: "string",
        helpText: `user accountId, sets signer`
    },

    contractName:{
        name: "contractName",
        shortName: "c",
        valueType: "string",
        helpText: `sets the contract account ID`
    },

}

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/util/ShowHelpPage.ts ---

export function ShowHelpPage(command: string, contractAPI:any, optionsDeclaration:any) {

    const commandsHelp:any={}

    //check all functions in the ContractAPI class, except the class constructor
    const methodNames =
        Object.getOwnPropertyNames(contractAPI.__proto__)
            .filter(name => name !== "constructor" && (command==="" || name===command)) //filter requested command

    //populate commandsHelp
    methodNames.forEach((value)=>commandsHelp[value]="")

    //see which functions have proper help text
    //check all *_help string items in the ContractAPI class
    const properHelpStrings = Object.getOwnPropertyNames(contractAPI)
    for (const item of properHelpStrings) {
        if (item.endsWith("_help") && typeof contractAPI[item]==="string") {
            const method = item.replace("_help", "")
            if (command === "" || command == method) { //filter the requested help
                commandsHelp[method] = contractAPI[item] as string //add proper help
            }
        }
    }
    //print all commands and their help if it's there
    for (const key in commandsHelp) {
        console.log("-".repeat(60));
        console.log('command: '+key); //name the command
        console.log(commandsHelp[key]); //print the help
    }

    //show general options
    console.log()
    console.log("-".repeat(60));
    console.log("Options:")
    for (let key in optionsDeclaration) {
        let line=""
        let opt=optionsDeclaration[key]
        let name = "--"+opt.name
        if (opt.valueType) name=name+" "+opt.valueType
        let sname = "-"+opt.shortName
        if (opt.valueType) sname=sname+" "+opt.valueType

        line=`  ${name}, ${sname}`.padEnd(50) + (opt.helpText? opt.helpText:"")
        console.log(line)
    }
    console.log("-".repeat(60))
}

'''
'''--- z-old/tests-ccc/model/hand-coded-tom/util/SpawnNearCli.ts ---
import * as child_process from "child_process";
import * as util from "util"
import * as fs from "fs"

let debug = 0
export function setDebug(value: 0 | 1 | 2) { debug = value }

export function spawnNearCli(args: string[]) {
    
    //-----------------------------
    //as of today 2020/09/19 near-cli seems to be ignoring --networkId 
    // and won't work unless you set NODE_ENV
    // this is a workround for that problem
    //-----------------------------
    // get process.env, clone the actual env vars 
    var env = Object.create( process.env );
    const pos=args.indexOf("--networkId")
    if (pos>=0) {
        const network=args[pos+1]
        env.NODE_ENV = network;
        console.log(`NODE_ENV=${network}`);
    }
    //-----------------------------
    
    console.log(`near ${args.join(" ")}`);
    var execResult = child_process.spawnSync("near", args, {shell:true, env:env}); // shell:true => to be able to invoke near-cli on windows
    
    //console.log(execResult.stdout.toString())
    //console.log(execResult.stderr.toString())
    
    if (execResult.error) {
        console.log(execResult.error)
        process.exit(1)
    }
    

    if (execResult.stdout) {
        //console.log("stdout:")
        //console.log("-*-")
        process.stdout.write(execResult.stdout)
        //console.log("-*-")
        //show large numbers converted to near
        //get all numbers where number.lenght>=20
        let numbersFound = execResult.stdout.toString().match(/\d+/g)
        if (numbersFound) {
            let largeNumbers = numbersFound.filter((value)=>value.length>=20)
            //deduplicate
            let numbers=[...new Set(largeNumbers)]
            //show conversion to NEARs
            for (let num of numbers) {
                if (num.length >= 20) {
                    let near = num;
                    if (near.length < 25) near = near.padStart(25,'0');
                    near = near.slice(0, near.length - 24) + "." + near.slice(near.length - 24) + " NEAR"
                    //show reference line
                    console.log(num.padStart(36, ' ') + " => " + near.padStart(38, ' '))
                }
            }
        }
        
        
        
    }
    if (execResult.stderr) {
        //console.log("stderr:")
        //console.log("-*-")
        process.stdout.write(execResult.stderr)
        //console.log("-*-")
    }
    //}
    
    if (execResult.status != 0) {
        process.exit(execResult.status as number);
    }
    
    return execResult.stdout;
}

'''
'''--- z-old/tests-ccc/test.ts ---
//test/index.ts
import { logger } from "../util/logger"
import { Parser } from "../Parser/Parser"
//import { D3Visualization } from "./src/Producer/D3Visualization"
//import { AssemblyScriptProducer as Producer} from "../Producer/AssemblyScriptProducer"
import { ContractCliProducer as Producer } from "../Producer/create-contract-cli-producer"
import * as mkPath from "../util/mkPath"
import * as path from "path"
import { copyFileSync } from "fs"

function main() {

    logger.debugEnabled = false

    let parsedModule 

    const data = {
        nickName: "tom",
        defaultContractName: "tomstaker.stakehouse.betanet"
    }
    const projectName = `${data.nickName}-cli`

    const projectPath = path.join("out", projectName)
    mkPath.create(projectPath)

    console.log(path.join(process.cwd(), projectPath))

    //parse
    try {

        const parser = new Parser()
        parsedModule = parser.parseFile('./src/tests/staking-pool/src/lib.rs')

    }
    catch (ex) {
        console.log("Error parsing " + parsedModule.name)
        console.log(ex)
        throw(ex)
    }

    console.log("parsed ok: " + parsedModule.name)
    //D3Visualization.saveForTree(parsedModule, "./data.json")

    //produce
    try {
        Producer.produce(parsedModule, data, path.join(projectPath, "ContractAPI.js"))
    }
    catch (ex) {
        console.log("Error producing " + parsedModule.name)
        console.log(ex)
        throw (ex)
    }

    //add auxiliary files
    try {
        mkPath.create(path.join(projectPath, "util"))
        const modelPath = path.join("dist", "src", "tests", "model", "hand-coded-tom")
        copyFileSync(path.join(modelPath, "tom.js"), path.join(projectPath, data.nickName+".js"))
        for (const file of ["CommandLineArgs", "CommonCLIOptions", "ShowHelpPage", "SpawnNearCli"]) {
            copyFileSync(path.join(modelPath, "util", file + ".js"), path.join(projectPath, "util", file + ".js"))
        }
    }
    catch (ex) {
        console.log("copying files")
        console.log(ex)
        throw (ex)
    }

    console.log("END")
}

try {
    console.log('Starting')
    main()
}
catch (ex) {
    console.log(ex)
}

/*process.stdin.setRawMode(true);
process.stdin.resume();
process.stdin.on('data', process.exit.bind(process, 0));
*/

'''