*GitHub Repository "NguyenTrongTin1107/dMart_sm"*

'''--- README.md ---
# NEAR.fm

### Setup to call contract function:

```sh
dmart_cid=$(<dmart/neardev/dev-account)
nft_cid=$(<nft/neardev/dev-account)
```

'''
'''--- dmart/Cargo.toml ---
[package]
name = "dmart"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "4.0.0"
regex = "1.5.4"
url = { version = "2.2.2", features = ["serde"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- dmart/README.md ---
near_fm Smart Contract
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- dmart/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p res
cp target/wasm32-unknown-unknown/release/dmart.wasm res/contract.wasm

'''
'''--- dmart/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- dmart/neardev/dev-account.env ---
CONTRACT_NAME=dev-1672461317093-76077856192551
'''
'''--- dmart/src/account.rs ---
use crate::*;
use near_sdk::collections::UnorderedSet;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub avatar: String,
    pub thumbnail: String,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStats {
    pub avatar: String,
    pub thumbnail: String,
    pub nfts_id: Vec<NftId>,
}

impl From<Account> for AccountStats {
    fn from(account: Account) -> Self {
        Self {
            avatar: account.avatar,
            thumbnail: account.thumbnail,
            nfts_id: vec![],
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn set_avatar(&mut self, avatar: String) {
        let account_id = env::predecessor_account_id();

        let storage_update = self.new_storage_update(account_id.clone());
        let mut account = self.internal_get_account(&account_id);
        account.avatar = avatar;
        self.internal_set_account(&account_id, account);
        self.finalize_storage_update(storage_update);
    }

    pub fn set_thumbnail(&mut self, thumbnail: String) {
        let account_id = env::predecessor_account_id();

        let storage_update = self.new_storage_update(account_id.clone());
        let mut account = self.internal_get_account(&account_id);
        account.thumbnail = thumbnail;
        self.internal_set_account(&account_id, account);
        self.finalize_storage_update(storage_update);
    }

    pub fn get_account(&self, account_id: AccountId) -> Option<AccountStats> {
        let account_stats: Option<AccountStats> = self
            .internal_get_account_optional(&account_id)
            .map(|a| a.into());
        if let Some(mut account_stats_unwrapped) = account_stats {
            account_stats_unwrapped.nfts_id =
                if let Some(user_nfts) = self.user_nfts.get(&account_id) {
                    user_nfts.to_vec()
                } else {
                    vec![]
                };
            return Some(account_stats_unwrapped);
        }
        None
    }

    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<(AccountId, AccountStats)> {
        let account_ids = self.accounts.keys_as_vector();
        let accounts = self.accounts.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .map(|index| {
                let account_id = account_ids.get(index).unwrap();
                let account: Account = accounts.get(index).unwrap().into();
                (account_id, account.into())
            })
            .collect()
    }

    pub fn get_num_accounts(&self) -> u64 {
        self.accounts.len()
    }

    pub fn get_accounts_with_ids(&self, account_ids: Vec<AccountId>) -> Vec<AccountStats> {
        account_ids
            .iter()
            .map(|id| {
                let account: Account = self.accounts.get(id).unwrap().into();
                account.into()
            })
            .collect()
    }
}

'''
'''--- dmart/src/internal_account.rs ---
use crate::*;

impl Contract {
    pub(crate) fn get_account_range(
        &self,
        account_ids: &Vector<AccountId>,
        from_index: u64,
        limit: u64,
    ) -> Vec<(AccountId, AccountStats)> {
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .filter_map(|index| {
                account_ids.get(index).and_then(|account_id| {
                    self.internal_get_account_optional(&account_id)
                        .map(|account| (account_id, account.into()))
                })
            })
            .collect()
    }

    pub(crate) fn internal_create_account(&mut self, account_id: &AccountId) -> Account {
        let hash = env::sha256(account_id.as_bytes());
        let mut following_key = vec![b'o'];
        following_key.extend_from_slice(&hash);
        let mut followers_key = vec![b'i'];
        followers_key.extend(&hash);
        let mut messages_key = vec![b'z'];
        messages_key.extend(&hash);
        let mut joined_communites_key = vec![b'j'];
        joined_communites_key.extend(&hash);

        let account = Account {
            avatar: "".to_string(),
            thumbnail: "".to_string(),
        };
        let v_account = account.into();
        assert!(
            self.accounts.insert(account_id, &v_account).is_none(),
            "Account already exists"
        );
        v_account.into()
    }

    pub(crate) fn internal_get_account_optional(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|a| a.into())
    }

    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account_optional(account_id)
            .expect("Account doesn't exist")
    }

    pub(crate) fn internal_set_account(&mut self, account_id: &AccountId, account: Account) {
        self.accounts.insert(account_id, &account.into());
    }
}

'''
'''--- dmart/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use near_sdk::collections::Vector;
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, setup_alloc, AccountId, Balance, BlockHeight, BorshStorageKey, Promise,
    StorageUsage,
};

pub use crate::account::*;
pub use crate::internal_account::*;
pub use crate::nft::*;
pub use crate::storage::*;
pub use crate::storage_key::*;

mod account;
mod internal_account;
mod nft;
mod storage;
mod storage_key;

type NftId = String;
type Auction = String;

setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub nft_contract: AccountId,

    pub storage_accounts: LookupMap<AccountId, StorageAccount>,
    pub storage_account_in_bytes: StorageUsage,

    pub accounts: UnorderedMap<AccountId, Account>,
    pub user_nfts: LookupMap<AccountId, UnorderedSet<NftId>>,

    pub marketplace: UnorderedSet<NftId>,
    pub auction: UnorderedSet<Auction>,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic(b"Contract should be initialized before usage");
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(nft_contract: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let this = Self {
            nft_contract,
            storage_accounts: LookupMap::new(StorageKey::StorageAccount),
            storage_account_in_bytes: 0,
            accounts: UnorderedMap::new(StorageKey::Accounts),
            user_nfts: LookupMap::new(StorageKey::UserNFT),

            marketplace: UnorderedSet::new(StorageKey::Marketplace),
            auction: UnorderedSet::new(StorageKey::Auction),
        };
        this
    }
    pub fn test(&self) -> String {
        "tinguyen".to_string()
    }
}

'''
'''--- dmart/src/nft.rs ---
use super::*;
use near_sdk::serde_json::json;
use near_sdk::{ext_contract, AccountId, Gas, PromiseResult};

const DEFAULT_GAS_FEE: Gas = 20_000_000_000_000;
#[ext_contract(ext_self)]
pub trait ExtContract {
    fn on_minted_nft(&mut self, owner_id: AccountId, nft_id: String) -> bool;
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn on_minted_nft(&mut self, owner_id: AccountId, nft_id: String) -> bool {
        env::log(format!("promise_result_count = {}", env::promise_results_count()).as_bytes());
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let owner = self
                    .accounts
                    .get(&owner_id.clone())
                    .expect("Account not found");
                let mut user_nfts = match self.user_nfts.get(&owner_id.clone()) {
                    Some(user_nfts) => user_nfts,
                    None => UnorderedSet::<NftId>::new(StorageKey::UserNFTsInner {
                        id: owner_id.clone().to_string(),
                    }),
                };
                user_nfts.insert(&nft_id);
                self.user_nfts.insert(&owner_id, &user_nfts);

                true
            }
            _ => {
                panic!("Mint chest failed")
            }
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn set_nft_contract(&mut self, nft_contract: AccountId) {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "You can't set new nft contract id"
        );
        self.nft_contract = nft_contract
    }

    #[payable]
    pub fn mint_nft(
        &mut self,
        account_id: Option<AccountId>,
        title: String,
        description: String,
        media: String,
        nft_type: String,
    ) -> Promise {
        let receiver_id = account_id.unwrap_or(env::predecessor_account_id());
        let amount = env::attached_deposit();

        let _ = self.accounts.get(&receiver_id);

        assert!(
            amount == 1_000_000_000_000_000_000_000_000,
            "Must attach exacts 1 NEAR to mint NFT"
        );

        let block_timestamp = env::block_timestamp() / 1_000_000_000;
        let token_id = block_timestamp.to_string() + "_" + &receiver_id.as_str();

        return Promise::new(self.nft_contract.clone())
            .function_call(
                b"nft_mint".to_vec(),
                json!({
                    "token_id": token_id,
                    "receiver_id": receiver_id,
                    "token_metadata": {
                        "title": title,
                        "description": description,
                        "media": media,
                        "copies": 1,
                    }
                })
                .to_string()
                .as_bytes()
                .to_vec(),
                20_000_000_000_000_000_000_000,
                DEFAULT_GAS_FEE,
            )
            .then(ext_self::on_minted_nft(
                receiver_id,
                token_id,
                &env::current_account_id(),
                0,
                DEFAULT_GAS_FEE,
            ));
    }
}

'''
'''--- dmart/src/storage.rs ---
use super::*;
use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;
use near_sdk::utils::assert_one_yocto;
use std::convert::TryInto;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

/// The minimum amount in bytes to register an account.
const MIN_STORAGE_SIZE: StorageUsage = 1000;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct StorageAccount {
    pub balance: Balance,
    pub used_bytes: StorageUsage,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStorageBalance {
    total: U128,
    available: U128,
}

pub trait StorageManager {
    fn storage_deposit(&mut self, account_id: Option<AccountId>) -> AccountStorageBalance;

    fn storage_withdraw(&mut self, amount: Option<U128>) -> AccountStorageBalance;

    fn storage_minimum_balance(&self) -> U128;

    fn storage_balance_of(&self, account_id: AccountId) -> AccountStorageBalance;
}

#[near_bindgen]
impl StorageManager for Contract {
    #[payable]
    fn storage_deposit(&mut self, account_id: Option<AccountId>) -> AccountStorageBalance {
        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        if let Some(mut storage_account) = self.storage_accounts.get(&account_id) {
            storage_account.balance += amount;
            self.storage_accounts.insert(&account_id, &storage_account);
        } else {
            let min_balance = self.storage_minimum_balance().0;
            if amount < min_balance {
                env::panic(b"Requires attached deposit of at least the storage minimum balance");
            }
            let initial_storage = env::storage_usage();
            self.internal_create_account(&account_id);
            let used_bytes = env::storage_usage() - initial_storage;
            let storage_account = StorageAccount {
                balance: amount,
                used_bytes: self.storage_account_in_bytes + used_bytes,
            };
            self.storage_accounts.insert(&account_id, &storage_account);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> AccountStorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let storage_balance = self.storage_balance_of(account_id.clone());
        let amount: Balance = amount.unwrap_or(storage_balance.available).into();
        if amount > storage_balance.available.0 {
            env::panic(b"Requested storage balance withdrawal amount is larger than available");
        } else if amount > 0 {
            let mut storage_account = self.storage_accounts.get(&account_id).unwrap();
            storage_account.balance -= amount;
            self.storage_accounts.insert(&account_id, &storage_account);
            Promise::new(account_id.clone()).transfer(amount + 1);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
    }

    fn storage_minimum_balance(&self) -> U128 {
        (Balance::from(MIN_STORAGE_SIZE) * STORAGE_PRICE_PER_BYTE).into()
    }

    fn storage_balance_of(&self, account_id: AccountId) -> AccountStorageBalance {
        if let Some(storage_account) = self.storage_accounts.get(&account_id) {
            AccountStorageBalance {
                total: storage_account.balance.into(),
                available: (storage_account.balance
                    - std::cmp::max(
                        self.storage_minimum_balance().0,
                        Balance::from(storage_account.used_bytes) * STORAGE_PRICE_PER_BYTE,
                    ))
                .into(),
            }
        } else {
            AccountStorageBalance {
                total: 0.into(),
                available: 0.into(),
            }
        }
    }
}

pub(crate) struct StorageUpdate {
    account_id: AccountId,
    storage_account: StorageAccount,
    initial_storage: StorageUsage,
}

impl StorageAccount {
    pub fn assert_enough_balance(&self) {
        assert!(
            Balance::from(self.used_bytes) * STORAGE_PRICE_PER_BYTE <= self.balance,
            "Not enough storage balance to cover changes"
        );
    }
}

impl Contract {
    pub(crate) fn new_storage_update(&mut self, account_id: AccountId) -> StorageUpdate {
        let storage_account = self
            .storage_accounts
            .get(&account_id)
            .expect("Account is not registered");
        let initial_storage = env::storage_usage();
        StorageUpdate {
            account_id,
            storage_account,
            initial_storage,
        }
    }

    pub(crate) fn finalize_storage_update(&mut self, storage_update: StorageUpdate) {
        let StorageUpdate {
            account_id,
            mut storage_account,
            initial_storage,
        } = storage_update;
        storage_account.used_bytes =
            (storage_account.used_bytes + env::storage_usage()).saturating_sub(initial_storage);
        storage_account.assert_enough_balance();
        self.storage_accounts.insert(&account_id, &storage_account);
    }
}

'''
'''--- dmart/src/storage_key.rs ---
use crate::*;
use near_sdk::BorshStorageKey;

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    StorageAccount,
    Accounts,
    UserNFT,
    UserNFTsInner { id: String },

    Marketplace,
    Auction,
}

'''
'''--- nft/.gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default && npm install near-cli -g --no-optional
    init: yarn && brew install tree
    command: clear && echo Explore non-fungible tokens on NEAR Protocol

'''
'''--- nft/Cargo.toml ---
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "test-approval-receiver",
  "test-token-receiver",
]
exclude  = [
  "integration-tests"
]
'''
'''--- nft/README-Windows.md ---
Non-fungible Token (NFT)
===================

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/NFT)

This repository includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and [simulation] tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim
Prerequisites
=============
If you're using Gitpod, you can skip this step.

  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

Explore this contract
=====================

The source for this contract is in `nft/src/lib.rs`. It provides methods to manage access to tokens, transfer tokens, check access, and get token owner. Note, some further exploration inside the rust macros is needed to see how the `NonFungibleToken` contract is implemented.

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `res/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```batch
build.bat
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.
```bash
cargo test -- --nocapture
```
The more complex simulation tests aren't run with this command, but we can find them in `tests/sim`.

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://wallet.testnet.near.org) or ([NEAR Wallet](https://wallet.near.org/) if we're using mainnet).

In the project root, log in to your newly created account with `near-cli` by following the instructions after this command.

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for our account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name we just logged in with, including the `.testnet` (or `.near` for `mainnet`):

    set ID=MY_ACCOUNT_NAME

We can tell if the environment variable is set correctly if our command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/non_fungible_token.wasm --accountId %ID%

NFT contract should be initialized before usage. More info about the metadata at [nomicon.io](https://nomicon.io/Standards/NonFungibleToken/Metadata.html). But for now, we'll initialize with the default metadata.

    near call %ID% new_default_meta "{\"owner_id\": \""%ID%"\"}" --accountId %ID%

We'll be able to view our metadata right after:

    near view %ID% nft_metadata

Then, let's mint our first token. This will create a NFT based on Olympus Mons where only one copy exists:

    near call %ID% nft_mint "{\"token_id\": \"0\", \"receiver_id\": \""%ID%"\", \"token_metadata\": { \"title\": \"Olympus Mons\", \"description\": \"Tallest mountain in charted solar system\", \"copies\": 1}}' --accountId %ID% --deposit 0.1

Transferring our NFT
====================

Let's set up an account to transfer our freshly minted token to. This account will be a sub-account of the NEAR account we logged in with originally via `near login`.

    near create-account alice.%ID% --masterAccount %ID% --initialBalance 10

Checking Alice's account for tokens:

    near view %ID% nft_tokens_for_owner "{\"account_id": \""alice.%ID%"\"}"

Then we'll transfer over the NFT into Alice's account. Exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% nft_transfer "{\"token_id\": \"0\", \"receiver_id\": \""alice.%ID%"\", \"memo\": \"transfer ownership\"}" --accountId %ID% --depositYocto 1

Checking Alice's account again shows us that she has the Olympus Mons token.

Notes
=====

* The maximum balance value is limited by U128 (2**128 - 1).
* JSON calls should pass U128 as a base-10 string. E.g. "100".
* This does not include escrow functionality, as ft_transfer_call provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

AssemblyScript
==============
Currently, AssemblyScript is not supported for this example. An old version can be found in the [NEP4 example](https://github.com/near-examples/NFT/releases/tag/nep4-example), but this is not recommended as it is out of date and does not follow the standards the NEAR SDK has set currently.

'''
'''--- nft/README.md ---
Non-fungible Token (NFT)
===================

>**Note**: If you'd like to learn how to create an NFT contract from scratch that explores every aspect of the [NEP-171](https://github.com/near/NEPs/blob/master/neps/nep-0171.md) standard including an NFT marketplace, check out the NFT [Zero to Hero Tutorial](https://docs.near.org/tutorials/nfts/introduction).

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/NFT)

This repository includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and workspaces-js and -rs tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim
Prerequisites
=============
If you're using Gitpod, you can skip this step.

  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

Explore this contract
=====================

The source for this contract is in `nft/src/lib.rs`. It provides methods to manage access to tokens, transfer tokens, check access, and get token owner. Note, some further exploration inside the rust macros is needed to see how the `NonFungibleToken` contract is implemented.

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `res/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```bash
./scripts/build.sh
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.

*Unit Tests*
```bash
cd nft
cargo test -- --nocapture
```

*Integration Tests*
*Rust*
```bash
cd integration-tests/rs
cargo run --example integration-tests
```
*TypeScript*
```bash
cd integration-tests/ts
yarn && yarn test 
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/concepts/basics/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/non_fungible_token.wasm
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to set the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```

To view the NFT metadata:

```bash
near view $CONTRACT_NAME nft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://wallet.testnet.near.org) or ([NEAR Wallet](https://wallet.near.org/) if we're using `mainnet`).

In the project root, log in to your newly created account with `near-cli` by following the instructions after this command.

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for our account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name we just logged in with, including the `.testnet` (or `.near` for `mainnet`):

    ID=MY_ACCOUNT_NAME

We can tell if the environment variable is set correctly if our command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/non_fungible_token.wasm --accountId $ID

NFT contract should be initialized before usage. More info about the metadata at [nomicon.io](https://nomicon.io/Standards/NonFungibleToken/Metadata.html). But for now, we'll initialize with the default metadata.

    near call $ID new_default_meta '{"owner_id": "'$ID'"}' --accountId $ID

We'll be able to view our metadata right after:

    near view $ID nft_metadata

Then, let's mint our first token. This will create a NFT based on Olympus Mons where only one copy exists:

    near call $ID nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Olympus Mons", "description": "Tallest mountain in charted solar system", "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg", "copies": 1}}' --accountId $ID --deposit 0.1

Transferring our NFT
====================

Let's set up an account to transfer our freshly minted token to. This account will be a sub-account of the NEAR account we logged in with originally via `near login`.

    near create-account alice.$ID --masterAccount $ID --initialBalance 10

Checking Alice's account for tokens:

    near view $ID nft_tokens_for_owner '{"account_id": "'alice.$ID'"}'

Then we'll transfer over the NFT into Alice's account. Exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID nft_transfer '{"token_id": "0", "receiver_id": "alice.'$ID'", "memo": "transfer ownership"}' --accountId $ID --depositYocto 1

Checking Alice's account again shows us that she has the Olympus Mons token.

Notes
=====

* The maximum balance value is limited by U128 (2**128 - 1).
* JSON calls should pass U128 as a base-10 string. E.g. "100".
* This does not include escrow functionality, as ft_transfer_call provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

AssemblyScript
==============
Currently, AssemblyScript is not supported for this example. An old version can be found in the [NEP4 example](https://github.com/near-examples/NFT/releases/tag/nep4-example), but this is not recommended as it is out of date and does not follow the standards the NEAR SDK has set currently.

'''
'''--- nft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p res
cp target/wasm32-unknown-unknown/release/*.wasm res/contract.wasm

'''
'''--- nft/integration-tests/rs/Cargo.toml ---
[package]
name = "non-fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.3.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- nft/integration-tests/rs/src/tests.rs ---
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const NFT_WASM_FILEPATH: &str = "../../res/non_fungible_token.wasm";
const TR_WASM_FILEPATH: &str = "../../res/token_receiver.wasm";
const AR_WASM_FILEPATH: &str = "../../res/approval_receiver.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let nft_wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft_contract = worker.dev_deploy(&nft_wasm).await?;
    let tr_wasm = std::fs::read(TR_WASM_FILEPATH)?;
    let tr_contract = worker.dev_deploy(&tr_wasm).await?;
    let ar_wasm = std::fs::read(AR_WASM_FILEPATH)?;
    let ar_contract = worker.dev_deploy(&ar_wasm).await?;

    // create accounts
    let owner = worker.root_account();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    nft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": owner.id()
        }))?
        .transact()
        .await?;
    tr_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;
    ar_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;

    // begin tests
    test_simple_approve(&owner, &alice, &nft_contract, &worker).await?;
    test_approval_simple_call(&owner, &nft_contract, &ar_contract, &worker).await?;
    test_approved_account_transfers_token(&owner, &alice, &nft_contract, &worker).await?;
    test_revoke(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_revoke_all(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_simple_transfer(&owner, &alice, &nft_contract, &worker).await?;
    test_transfer_call_fast_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_fast_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_receiver_panics(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_enum_total_supply(&nft_contract, &worker).await?;
    test_enum_nft_tokens(&nft_contract, &worker).await?;
    test_enum_nft_supply_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    test_enum_nft_tokens_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    Ok(())
}

async fn test_simple_approve(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "0",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "The tallest mountain in the charted solar system",
                "copies": 10000,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id":  "0",
            "account_id": user.id(),
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let approval_no_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval_no_id);

    let approval: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 1
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval);

    let approval_wrong_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 2
        }))?
        .transact()
        .await?
        .json()?;

    assert!(!approval_wrong_id);
    println!("      Passed ✅ test_simple_approve");
    Ok(())
}

async fn test_approval_simple_call(
    owner: &Account,
    nft_contract: &Contract,
    approval_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 2",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": "return-now"
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!("cool", outcome);

    let msg = "test message";
    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": msg.clone(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!(msg, outcome);

    println!("      Passed ✅ test_approval_simple_call");
    Ok(())
}

async fn test_approved_account_transfers_token(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": user.id(),
            "token_id": '0',
            "approval_id": 1,
            "memo": "message for test 3",
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "0"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_approved_account_transfers_token");
    Ok(())
}

async fn test_revoke(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root revokes user
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert user is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // assert token receiver still approved
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    // root revokes token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert alice is still revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // and now so is token_receiver
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    println!("      Passed ✅ test_revoke");
    Ok(())
}

async fn test_revoke_all(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // assert everyone is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    println!("      Passed ✅ test_revoke_all");
    Ok(())
}

async fn test_simple_transfer(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_simple_transfer");
    Ok(())
}

async fn test_transfer_call_fast_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 3",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_fast_return_to_sender");
    Ok(())
}

async fn test_transfer_call_slow_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_slow_return_to_sender");
    Ok(())
}

async fn test_transfer_call_fast_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_fast_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_slow_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 4",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "3"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_slow_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_receiver_panics(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 5",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "incorrect message",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "4"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_receiver_panics");
    Ok(())
}

async fn test_enum_total_supply(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let supply: String = nft_contract
        .call(&worker, "nft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, "5");

    println!("      Passed ✅ test_enum_total_supply");
    Ok(())
}

async fn test_enum_nft_tokens(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(tokens.len(), 5);

    println!("      Passed ✅ test_enum_nft_tokens");
    Ok(())
}

async fn test_enum_nft_supply_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let owner_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": owner.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(owner_tokens, "1");

    let user_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": user.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(user_tokens, "2");

    println!("      Passed ✅ test_enum_nft_supply_for_owner");
    Ok(())
}

async fn test_enum_nft_tokens_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 2);

    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": owner.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 1);
    println!("      Passed ✅ test_enum_nft_tokens_for_owner");
    Ok(())
}

'''
'''--- nft/integration-tests/ts/package.json ---
{
  "name": "non-fungible-token-integration-tests-ts",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "^2.0.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- nft/integration-tests/ts/src/main.ava.ts ---
import { Worker, NearAccount, tGas, NEAR, BN } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { mint_more, nft_total_supply } from './utils';

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const nft = await root.createAndDeploy(
        'non-fungible-token',
        '../../res/non_fungible_token.wasm',
        {
            method: "new_default_meta",
            args: { owner_id: root },
        }
    );
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: "0",
            receiver_id: root,
            token_metadata: {
                title: "Olympus Mons",
                description: "The tallest mountain in the charted solar system",
                media: null,
                media_hash: null,
                copies: 10000,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    );

    const alice = await root.createSubAccount('alice', { initialBalance: NEAR.parse('100 N').toJSON() });

    const tokenReceiver = await root.createAndDeploy(
        'token-receiver',
        '../../res/token_receiver.wasm',
        {
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );
    const approvalReceiver = await root.createAndDeploy(
        'approval-receiver',
        '../../res/approval_receiver.wasm',
        {
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );

    t.context.worker = worker;
    t.context.accounts = { root, alice, nft, tokenReceiver, approvalReceiver };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Simple approve', async test => {
    const { root, alice, nft, tokenReceiver } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        {
            attachedDeposit: new BN('270000000000000000000'), // need more deposit than the sim-tests, cause names are longer
            gas: tGas('150')
        },
    );

    // check nft_is_approved, don't provide approval_id
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
            })
    );

    // check nft_is_approved, with approval_id=1
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 1,
            })
    );

    // check nft_is_approved, with approval_id=2
    test.false(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            })
    );

    // alternatively, one could check the data returned by nft_token
    const token: any = await nft.view('nft_token', { token_id: '0', });
    test.deepEqual(token.approved_account_ids, { [alice.accountId]: 1 })

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            },
        )
    );

    // approving another account gives different approval_id
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        // note that token_receiver's account name is longer, and so takes more bytes to store and
        // therefore requires a larger deposit!
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: tokenReceiver,
                approval_id: 3,
            })
    );
});

test('Approval with call', async test => {
    const { root, nft, approvalReceiver } = test.context.accounts;
    let outcome: string = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: 'return-now',
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );

    test.is(outcome, 'cool');

    const msg = 'hahaha';
    outcome = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: msg,
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );
    test.is(outcome, msg);
});

test('Approved account transfers token', async test => {
    const { root, alice, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    await alice.call(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            approval_id: 1,
            memo: 'gotcha! bahahaha',
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Revoke', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    // root revokes alice
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: alice }, { attachedDeposit: '1' });

    // alice is revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // but token_receiver is still approved
    test.true(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );

    // root revokes token_receiver
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: tokenReceiver }, { attachedDeposit: '1' });

    // alice is still revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // ...and now so is token_receiver
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Revoke all', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    await root.call(nft, 'nft_revoke_all', { token_id: '0' }, { attachedDeposit: '1' });

    // everyone revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Simple transfer', async test => {
    const { root, alice, nft } = test.context.accounts;
    let token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);

    const result = await root.callRaw(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            memo: "simple transfer",
        },
        { attachedDeposit: '1' },
    );
    test.assert(result.succeeded);
    token = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Transfer call fast return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call slow return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call fast keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'keep-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call slow keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'keep-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call receiver panics', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'incorrect message',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Enum total supply', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    const total_supply = await nft_total_supply(nft, alice);
    test.deepEqual(total_supply, new BN(4));
});

test('Enum nft tokens', async test => {
    const { root, nft } = test.context.accounts;
    await mint_more(root, nft);

    // No optional args should return all
    let tokens: any[] = await nft.view('nft_tokens');
    test.is(tokens.length, 4);

    // Start at "1", with no limit arg
    tokens = await nft.view('nft_tokens', { from_index: '1' });
    test.is(tokens.length, 3);
    test.is(tokens[0].token_id, '1');
    test.is(tokens[1].token_id, '2');
    test.is(tokens[2].token_id, '3');

    // Start at "2", with limit 1
    tokens = await nft.view('nft_tokens', { from_index: '2', limit: 1 });
    test.is(tokens.length, 1);
    test.is(tokens[0].token_id, '2');

    // Don't specify from_index, but limit 2
    tokens = await nft.view('nft_tokens', { limit: 2 });
    test.is(tokens.length, 2);
    test.is(tokens[0].token_id, '0');
    test.is(tokens[1].token_id, '1');
});

test('Enum nft supply for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    // Get number from account with no NFTs
    let ownerNumTokens: BN = new BN(await nft.view('nft_supply_for_owner', { account_id: alice }));
    test.deepEqual(ownerNumTokens, new BN(0));

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(1));

    await mint_more(root, nft);

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(4));
});

test('Enum nft tokens for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    // Get tokens from account with no NFTs
    let ownerTokens: any[] = await nft.view('nft_tokens_for_owner', { account_id: alice });
    test.deepEqual(ownerTokens.length, 0);

    // Get tokens with no optional args
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root });
    test.deepEqual(ownerTokens.length, 4);

    // With from_index and no limit
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(2) });
    test.deepEqual(ownerTokens.length, 2);
    test.is(ownerTokens[0].token_id, '2');
    test.is(ownerTokens[1].token_id, '3');

    // With from_index and limit 1
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(1), limit: 1 });
    test.deepEqual(ownerTokens.length, 1);
    test.is(ownerTokens[0].token_id, '1');

    // No from_index but limit 3
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, limit: 3 });
    test.deepEqual(ownerTokens.length, 3);
    test.is(ownerTokens[0].token_id, '0');
    test.is(ownerTokens[1].token_id, '1');
    test.is(ownerTokens[2].token_id, '2');
});
'''
'''--- nft/integration-tests/ts/src/utils.ts ---
import { NearAccount, BN } from 'near-workspaces';

export async function helper_mint(
    token_id: string,
    root: NearAccount,
    nft: NearAccount,
    title: String,
    desc: String) {
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: token_id,
            receiver_id: root,
            token_metadata: {
                title: title,
                description: desc,
                media: null,
                media_hash: null,
                copies: 1,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    )
}
export async function mint_more(root: NearAccount, nft: NearAccount) {
    await helper_mint(
        "1",
        root,
        nft,
        "Black as the Night",
        "In charcoal"
    );
    await helper_mint(
        "2",
        root,
        nft,
        "Hamakua",
        "Vintage recording"
    );
    await helper_mint(
        "3",
        root,
        nft,
        "Aloha ke akua",
        "Original with piano"
    );
}

export async function nft_total_supply(nft: NearAccount, user: NearAccount): Promise<BN> {
    return new BN(await nft.view('nft_total_supply'));
}

'''
'''--- nft/nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
base64 = "0.13.1"

'''
'''--- nft/nft/src/account.rs ---
use crate::*;
use near_sdk::collections::UnorderedSet;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub account_info: String,

    pub bookmarks: Vec<TokenId>,
    pub following: UnorderedSet<AccountId>,
    pub followers: UnorderedSet<AccountId>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStats {
    pub account_info: String,

    pub favourite_nfts: Vec<DMartToken>,
    pub num_followers: u64,
    pub num_following: u64,
    pub num_nfts: u64,
}

impl From<Account> for AccountStats {
    fn from(account: Account) -> Self {
        Self {
            account_info: account.account_info,

            favourite_nfts: vec![],
            num_followers: account.followers.len(),
            num_following: account.following.len(),
            num_nfts: 0,
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_num_nfts(&self, account_id: &AccountId) -> u64 {
        self.tokens
            .tokens_per_owner
            .as_ref()
            .unwrap()
            .get(account_id)
            .unwrap_or(UnorderedSet::new(b"t"))
            .len()
    }

    pub fn set_account_info(&mut self, account_info: String) {
        let account_id = env::predecessor_account_id();
        let storage_update = self.new_storage_update(account_id.clone());

        let mut account = self.internal_get_account(&account_id);
        account.account_info = validate_account_data(account_info.clone());
        self.internal_set_account(&account_id, account);

        self.finalize_storage_update(storage_update);
    }

    pub fn get_account(&self, account_id: AccountId) -> Option<AccountStats> {
        let account: Option<Account> = self.internal_get_account_optional(&account_id);
        if let Some(account_unwrapped) = account {
            let mut account_stats: AccountStats = self.internal_get_account(&account_id).into();
            account_stats.num_nfts = self.get_num_nfts(&account_id);
            account_stats.favourite_nfts = account_unwrapped
                .bookmarks
                .iter()
                .map(|id| DMartToken {
                    token_id: id.clone(),
                    owner_id: self.tokens.owner_by_id.get(&id).unwrap(),
                    metadata: self.token_metadata(id.to_string()),
                })
                .collect();
            return Some(account_stats);
        }
        None
    }

    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<(AccountId, AccountStats)> {
        let account_ids = self.accounts.keys_as_vector();
        let accounts = self.accounts.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .map(|index| {
                let account_id = account_ids.get(index).unwrap();
                let mut account_stats: AccountStats = accounts.get(index).unwrap().into();
                account_stats.num_nfts = self.get_num_nfts(&account_id);
                (account_id, account_stats)
            })
            .collect()
    }

    pub fn get_num_accounts(&self) -> u64 {
        self.accounts.len()
    }

    pub fn get_accounts_with_ids(&self, account_ids: Vec<AccountId>) -> Vec<AccountStats> {
        account_ids
            .iter()
            .map(|id| {
                let mut account_stats: AccountStats = self.accounts.get(id).unwrap().into();
                account_stats.num_nfts = self.get_num_nfts(id);
                account_stats
            })
            .collect()
    }

    pub fn add_bookmark(&mut self, nft_id: TokenId) {
        let account_id = env::predecessor_account_id();
        let storage_update = self.new_storage_update(account_id.clone());

        let mut account = self.internal_get_account(&account_id);
        account.bookmarks.push(nft_id);
        self.internal_set_account(&account_id, account);

        self.finalize_storage_update(storage_update);
    }

    pub fn remove_bookmark(&mut self, nft_id: TokenId) {
        let account_id = env::predecessor_account_id();
        let storage_update = self.new_storage_update(account_id.clone());

        let mut account = self.internal_get_account(&account_id);
        let index = account
            .bookmarks
            .iter()
            .position(|x| *x == nft_id)
            .expect("NFT not found");
        account.bookmarks.remove(index);
        self.internal_set_account(&account_id, account);

        self.finalize_storage_update(storage_update);
    }

    pub fn get_bookmarks(&self, account_id: AccountId) -> Vec<DMartToken> {
        let account = self.internal_get_account_optional(&account_id);
        if let Some(account) = account {
            account
                .bookmarks
                .iter()
                .map(|id| DMartToken {
                    token_id: id.clone(),
                    owner_id: self.tokens.owner_by_id.get(&id).unwrap(),
                    metadata: self.token_metadata(id.to_string()),
                })
                .collect()
        } else {
            vec![]
        }
    }
}

'''
'''--- nft/nft/src/constant.rs ---
pub const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 74.46 74.46'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23414042;%7D.cls-2%7Bfill:%23d1d3d4;%7D.cls-3%7Bfill:%23ed1c24;%7D%3C/style%3E%3C/defs%3E%3Cg id='Layer_2' data-name='Layer 2'%3E%3Cg id='Layer_1-2' data-name='Layer 1'%3E%3Ccircle class='cls-1' cx='37.23' cy='37.23' r='37.23'/%3E%3Cpath class='cls-2' d='M28.3,51.43v-2a12,12,0,0,1-6.86,2.14,12.12,12.12,0,0,1,0-24.24,12,12,0,0,1,6.86,2.14V15.23h9.38Z'/%3E%3Cpolygon class='cls-3' points='63.14 59.11 63.14 59.23 51.09 59.23 51.09 37.57 47.3 42.67 48.7 46.51 45.88 46.51 45.16 45.54 44.44 46.51 41.62 46.51 43.02 42.67 39.22 37.57 39.22 59.23 27.17 59.23 27.17 59.11 38.02 17.23 45.16 36.8 52.29 17.23 63.14 59.11'/%3E%3Cpolygon class='cls-3' points='37.24 37.17 37.24 37.29 37.22 37.29 37.24 37.17'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E%0A";

'''
'''--- nft/nft/src/internal_account.rs ---
use crate::*;

impl Contract {
    pub(crate) fn get_account_range(
        &self,
        account_ids: &Vector<AccountId>,
        from_index: u64,
        limit: u64,
    ) -> Vec<(AccountId, AccountStats)> {
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .filter_map(|index| {
                account_ids.get(index).and_then(|account_id| {
                    self.internal_get_account_optional(&account_id)
                        .map(|account| (account_id, account.into()))
                })
            })
            .collect()
    }

    pub(crate) fn internal_create_account(&mut self, account_id: &AccountId) -> Account {
        let hash = env::sha256(account_id.as_bytes());
        let mut following_key = vec![b'o'];
        following_key.extend_from_slice(&hash);
        let mut followers_key = vec![b'i'];
        followers_key.extend(&hash);

        let account = Account {
            account_info: "".to_string(),
            bookmarks: Vec::new(),
            following: UnorderedSet::new(following_key),
            followers: UnorderedSet::new(followers_key),
        };
        let v_account = account.into();
        assert!(
            self.accounts.insert(account_id, &v_account).is_none(),
            "Account already exists"
        );
        v_account.into()
    }

    pub(crate) fn internal_get_account_optional(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|a| a.into())
    }

    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account_optional(account_id)
            .expect("Account doesn't exist")
    }

    pub(crate) fn internal_set_account(&mut self, account_id: &AccountId, account: Account) {
        self.accounts.insert(account_id, &account.into());
    }
}

'''
'''--- nft/nft/src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet, Vector};
use near_sdk::json_types::{ValidAccountId, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise, PromiseOrValue, StorageUsage,
};

pub use crate::account::*;
pub use crate::constant::*;
pub use crate::internal_account::*;
pub use crate::nft::*;
pub use crate::order::*;
pub use crate::storage::*;
pub use crate::storage_key::*;
pub use crate::validator::*;

mod account;
mod constant;
mod internal_account;
mod nft;
mod order;
mod storage;
mod storage_key;
mod validator;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // roles: LookupMap<AccountId, String>,
    pub tokens: NonFungibleToken,
    pub metadata: LazyOption<NFTContractMetadata>,
    pub token_ids: UnorderedSet<TokenId>,

    pub storage_accounts: LookupMap<AccountId, StorageAccount>,
    pub storage_account_in_bytes: StorageUsage,

    pub accounts: UnorderedMap<AccountId, Account>,

    pub orders: LookupMap<OrderId, Order>,
    pub order_by_nft: LookupMap<TokenId, OrderId>,
    pub order_by_user: LookupMap<AccountId, UnorderedSet<OrderId>>,
    pub marketplace: UnorderedSet<OrderId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "DMart".to_string(),
                symbol: "DMART".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            // roles: LookupMap::new(StorageKey::Roles),
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            token_ids: UnorderedSet::new(StorageKey::TokenIds),

            storage_accounts: LookupMap::new(StorageKey::StorageAccount),
            storage_account_in_bytes: 0,

            accounts: UnorderedMap::new(StorageKey::Accounts),

            orders: LookupMap::new(StorageKey::Orders),
            order_by_nft: LookupMap::new(StorageKey::OrderByNft),
            order_by_user: LookupMap::new(StorageKey::OrderByAccount),
            marketplace: UnorderedSet::new(StorageKey::Marketplace),
        }
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- nft/nft/src/nft.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct DMartToken {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: TokenMetadata,
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn mint_art_nft(&mut self, receiver_id: Option<AccountId>, metadata: TokenMetadata) {
        let caller = env::predecessor_account_id();
        let _ = self.internal_get_account(&caller);

        let storage_update = self.new_storage_update(caller.clone());

        let receiver_id = receiver_id.unwrap_or(caller);
        let block_timestamp = env::block_timestamp() / 1_000_000_000;
        let token_id = block_timestamp.to_string() + "_invite_" + &receiver_id.to_string();

        self.nft_mint(token_id, receiver_id, metadata);
        self.finalize_storage_update(storage_update);
    }

    pub(crate) fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        let token = self
            .tokens
            .internal_mint(token_id, receiver_id, Some(token_metadata));
        self.token_ids.insert(&token.token_id);
        return token;
    }

    pub fn tokens_of_owner(&self, owner_id: AccountId) -> Vec<TokenId> {
        self.tokens
            .tokens_per_owner
            .as_ref()
            .unwrap()
            .get(&owner_id)
            .unwrap_or(UnorderedSet::new(b"x"))
            .to_vec()
    }

    pub fn tokens_metadata_of_owner(&self, owner_id: AccountId) -> Vec<DMartToken> {
        self.tokens
            .tokens_per_owner
            .as_ref()
            .unwrap()
            .get(&owner_id)
            .unwrap_or(UnorderedSet::new(b"t"))
            .iter()
            .map(|v| DMartToken {
                token_id: v.clone(),
                owner_id: owner_id.clone(),
                metadata: self
                    .tokens
                    .token_metadata_by_id
                    .as_ref()
                    .unwrap()
                    .get(&v)
                    .unwrap(),
            })
            .collect()
    }

    pub fn token_metadata(&self, token_id: TokenId) -> TokenMetadata {
        self.tokens
            .token_metadata_by_id
            .as_ref()
            .unwrap()
            .get(&token_id.to_string())
            .unwrap()
    }

    pub fn get_nfts(&self) -> Vec<DMartToken> {
        self.token_ids
            .iter()
            .map(|id| DMartToken {
                token_id: id.clone(),
                owner_id: self.tokens.owner_by_id.get(&id).unwrap(),
                metadata: self.token_metadata(id),
            })
            .collect()
    }
}

'''
'''--- nft/nft/src/order.rs ---
use near_sdk::serde_json::json;
use near_sdk::Promise;
use near_sdk::{env::attached_deposit, Timestamp};
use near_sdk::{ext_contract, Gas, PromiseResult};

use crate::*;
const DEFAULT_GAS_FEE: Gas = Gas(20_000_000_000_000);

pub type OrderId = String;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {
    owner_id: AccountId,
    nft_id: TokenId,
    price: Balance, // Yocto near
    create_at: Timestamp,
    is_sold: bool,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderDto {
    order_id: String,
    owner_id: AccountId,
    nft_id: TokenId,
    price: U128, // Yocto near
    create_at: U64,
    is_sold: bool,
    metadata: TokenMetadata,
}

#[near_bindgen]
impl Contract {
    pub fn get_orders(&self, //from_index: u64, limit: u64
    ) -> Vec<OrderDto> {
        self.marketplace
            .iter()
            .map(|id| {
                let order = self.orders.get(&id).expect("Contain invalid order(s)");
                let metadata = self
                    .tokens
                    .token_metadata_by_id
                    .as_ref()
                    .unwrap()
                    .get(&order.nft_id)
                    .expect("Not exist NFT");
                OrderDto {
                    order_id: id,
                    owner_id: order.owner_id,
                    nft_id: order.nft_id,
                    price: U128::from(order.price), // Yocto near
                    create_at: U64::from(order.create_at),
                    is_sold: order.is_sold,
                    metadata,
                }
            })
            .collect()
    }

    pub fn get_account_orders(
        &self,
        account_id: AccountId, //from_index: u64, limit: u64
    ) -> Vec<OrderDto> {
        self.order_by_user
            .get(&account_id)
            .unwrap_or(UnorderedSet::new(StorageKey::OrderByAccountInner {
                id: account_id.to_string(),
            }))
            .iter()
            .map(|id| {
                let order = self.orders.get(&id).expect("Contain invalid order(s)");
                let metadata = self
                    .tokens
                    .token_metadata_by_id
                    .as_ref()
                    .unwrap()
                    .get(&order.nft_id)
                    .expect("Not exist NFT");
                OrderDto {
                    order_id: id,
                    owner_id: order.owner_id,
                    nft_id: order.nft_id,
                    price: U128::from(order.price), // Yocto near
                    create_at: U64::from(order.create_at),
                    is_sold: order.is_sold,
                    metadata,
                }
            })
            .collect()
    }

    #[payable]
    pub fn sell_nft(&mut self, nft_id: TokenId, price: U128) {
        let account_id = env::predecessor_account_id();
        let owner_id = self
            .tokens
            .owner_by_id
            .get(&nft_id)
            .expect("Can't find owner of this NFT");
        let attached_deposit = env::attached_deposit();

        assert!(
            account_id == owner_id,
            "Require owner of NFT to call sell it!"
        );
        assert!(self.orders.get(&nft_id).is_none(), "NFT are selling.");

        let block_timestamp = env::block_timestamp() / 1_000_000_000;
        let order_id = block_timestamp.to_string() + "_" + &nft_id;

        let order = Order {
            owner_id: owner_id.clone(),
            nft_id: nft_id.clone(),
            price: price.into(),
            create_at: env::block_timestamp().into(),
            is_sold: false,
        };

        self.nft_transfer(env::current_account_id(), nft_id.clone(), None, None);

        self.orders.insert(&order_id, &order);
        self.order_by_nft.insert(&nft_id, &order_id);
        let mut orders = match self.order_by_user.get(&owner_id) {
            Some(orders) => orders,
            None => UnorderedSet::<OrderId>::new(StorageKey::OrderByAccountInner {
                id: owner_id.clone().to_string(),
            }),
        };
        orders.insert(&order_id);
        self.order_by_user.insert(&owner_id, &orders);
        self.marketplace.insert(&order_id);
    }

    // #[payable]
    // pub fn cancel_sell_nft(&mut self, nft_id: TokenId, price: U128) {
    //     let account_id = env::predecessor_account_id();
    //     let owner_id = self
    //         .tokens
    //         .owner_by_id
    //         .get(&nft_id)
    //         .expect("Can't find owner of this NFT");
    //     let attached_deposit = env::attached_deposit();
    //
    //     assert!(
    //         account_id == owner_id,
    //         "Require owner of NFT to call sell it!"
    //     );
    //     assert!(self.orders.get(&nft_id).is_none(), "NFT are selling.");
    //
    //     let block_timestamp = env::block_timestamp() / 1_000_000_000;
    //     let order_id = block_timestamp.to_string() + "_" + &nft_id;
    //
    //     let order = Order {
    //         owner_id: owner_id.clone(),
    //         nft_id: nft_id.clone(),
    //         price: price.into(),
    //         create_at: env::block_timestamp().into(),
    //         is_sold: false,
    //     };
    //
    //     self.nft_transfer(env::current_account_id(), nft_id.clone(), None, None);
    //
    //     self.orders.insert(&order_id, &order);
    //     self.order_by_nft.insert(&nft_id, &order_id);
    //     let mut orders = match self.order_by_user.get(&owner_id) {
    //         Some(orders) => orders,
    //         None => UnorderedSet::<OrderId>::new(StorageKey::OrderByAccountInner {
    //             id: owner_id.clone().to_string(),
    //         }),
    //     };
    //     orders.insert(&order_id);
    //     self.order_by_user.insert(&owner_id, &orders);
    //     self.marketplace.insert(&order_id);
    // }

    #[payable]
    pub fn buy_nft(&mut self, order_id: OrderId) {
        let account_id = env::predecessor_account_id();
        let mut order = self.orders.get(&order_id).expect("Not exist Order");
        let attached_deposit = env::attached_deposit();

        assert!(!order.is_sold, "Nft is already been sold");
        assert!(account_id != order.owner_id, "Can't buy Nft of yourself");
        assert!(
            attached_deposit == order.price,
            "Need to attach exactly the price of order"
        );

        order.is_sold = false;
        self.orders.insert(&order_id, &order);

        // self.nft_transfer(account_id, order.nft_id, None, None);
        let mut storage_account = self
            .storage_accounts
            .get(&order.owner_id)
            .expect("Cant't found owner of this order");
        storage_account.balance += order.price;
        self.storage_accounts
            .insert(&order.owner_id, &storage_account);

        // Remove this order
        self.orders.remove(&order_id);
        self.order_by_nft.remove(&order.nft_id);
        let mut orders = match self.order_by_user.get(&order.owner_id) {
            Some(orders) => orders,
            None => UnorderedSet::<OrderId>::new(StorageKey::OrderByAccountInner {
                id: order.owner_id.clone().to_string(),
            }),
        };
        orders.remove(&order_id);
        self.order_by_user.insert(&order.owner_id, &orders);
        self.marketplace.remove(&order_id);

        Promise::new(env::current_account_id()).function_call(
            "nft_transfer".to_string(),
            json!({
                "receiver_id": account_id,
                "token_id": order.nft_id,
            })
            .to_string()
            .as_bytes()
            .to_vec(),
            1,
            DEFAULT_GAS_FEE,
        );
    }
}

'''
'''--- nft/nft/src/storage.rs ---
use super::*;
use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;
use near_sdk::utils::assert_one_yocto;
use std::convert::TryInto;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

/// The minimum amount in bytes to register an account.
const MIN_STORAGE_SIZE: StorageUsage = 1000;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct StorageAccount {
    pub balance: Balance,
    pub used_bytes: StorageUsage,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStorageBalance {
    total: U128,
    available: U128,
}

pub trait StorageManager {
    fn storage_deposit(&mut self, account_id: Option<AccountId>) -> AccountStorageBalance;

    fn storage_withdraw(&mut self, amount: Option<U128>) -> AccountStorageBalance;

    fn storage_minimum_balance(&self) -> U128;

    fn storage_balance_of(&self, account_id: AccountId) -> AccountStorageBalance;
}

#[near_bindgen]
impl StorageManager for Contract {
    #[payable]
    fn storage_deposit(&mut self, account_id: Option<AccountId>) -> AccountStorageBalance {
        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        if let Some(mut storage_account) = self.storage_accounts.get(&account_id) {
            storage_account.balance += amount;
            self.storage_accounts.insert(&account_id, &storage_account);
        } else {
            let min_balance = self.storage_minimum_balance().0;
            if amount < min_balance {
                env::panic(b"Requires attached deposit of at least the storage minimum balance");
            }
            let initial_storage = env::storage_usage();
            self.internal_create_account(&account_id);
            let used_bytes = env::storage_usage() - initial_storage;
            let storage_account = StorageAccount {
                balance: amount,
                used_bytes: self.storage_account_in_bytes + used_bytes,
            };
            self.storage_accounts.insert(&account_id, &storage_account);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> AccountStorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let storage_balance = self.storage_balance_of(account_id.clone());
        let amount: Balance = amount.unwrap_or(storage_balance.available).into();
        if amount > storage_balance.available.0 {
            env::panic(b"Requested storage balance withdrawal amount is larger than available");
        } else if amount > 0 {
            let mut storage_account = self.storage_accounts.get(&account_id).unwrap();
            storage_account.balance -= amount;
            self.storage_accounts.insert(&account_id, &storage_account);
            Promise::new(account_id.clone()).transfer(amount + 1);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
    }

    fn storage_minimum_balance(&self) -> U128 {
        (Balance::from(MIN_STORAGE_SIZE) * STORAGE_PRICE_PER_BYTE).into()
    }

    fn storage_balance_of(&self, account_id: AccountId) -> AccountStorageBalance {
        if let Some(storage_account) = self.storage_accounts.get(&account_id) {
            AccountStorageBalance {
                total: storage_account.balance.into(),
                available: (storage_account.balance
                    - std::cmp::max(
                        self.storage_minimum_balance().0,
                        Balance::from(storage_account.used_bytes) * STORAGE_PRICE_PER_BYTE,
                    ))
                .into(),
            }
        } else {
            AccountStorageBalance {
                total: 0.into(),
                available: 0.into(),
            }
        }
    }
}

pub(crate) struct StorageUpdate {
    account_id: AccountId,
    storage_account: StorageAccount,
    initial_storage: StorageUsage,
}

impl StorageAccount {
    pub fn assert_enough_balance(&self) {
        assert!(
            Balance::from(self.used_bytes) * STORAGE_PRICE_PER_BYTE <= self.balance,
            "Not enough storage balance to cover changes"
        );
    }
}

#[near_bindgen]
impl Contract {
    pub fn is_registered(&self, account_id: AccountId) -> bool {
        self.storage_accounts.get(&account_id).is_some()
    }
}

impl Contract {
    pub(crate) fn new_storage_update(&mut self, account_id: AccountId) -> StorageUpdate {
        let storage_account = self
            .storage_accounts
            .get(&account_id)
            .expect("Account is not registered");
        let initial_storage = env::storage_usage();
        StorageUpdate {
            account_id,
            storage_account,
            initial_storage,
        }
    }

    pub(crate) fn finalize_storage_update(&mut self, storage_update: StorageUpdate) {
        let StorageUpdate {
            account_id,
            mut storage_account,
            initial_storage,
        } = storage_update;
        storage_account.used_bytes =
            (storage_account.used_bytes + env::storage_usage()).saturating_sub(initial_storage);
        storage_account.assert_enough_balance();
        self.storage_accounts.insert(&account_id, &storage_account);
    }
}

'''
'''--- nft/nft/src/storage_key.rs ---
use crate::*;
use near_sdk::BorshStorageKey;

#[derive(BorshSerialize, BorshStorageKey)]
pub(crate) enum StorageKey {
    StorageAccount,
    Accounts,

    Orders,
    OrderByNft,
    OrderByAccount,
    OrderByAccountInner { id: String },
    Marketplace,

    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    TokenIds,
}

'''
'''--- nft/nft/src/validator.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
struct AccountInfo {
    display_name: Option<String>,
    avatar: Option<String>,
    thumbnail: Option<String>,

    about: Option<String>,
    occupation: Option<String>,

    profile_image: Option<String>,
    profile_video: Option<String>,

    email: Option<String>,
    location: Option<String>,

    twitter: Option<String>,
    github: Option<String>,
    telegram: Option<String>,
    linkedin: Option<String>,
    behance: Option<String>,
    website: Option<String>,
}

pub fn validate_account_data(base64: String) -> String {
    let bytes = base64::decode(base64).expect("Can not decode base 64");
    if let Ok(about_me) = serde_json::from_slice::<AccountInfo>(&bytes) {
        let json = serde_json::to_string(&about_me).expect("Can't encode data");
        return base64::encode(json.clone());
    } else {
        panic!("Can not extract data from bytes");
    }
}

'''
'''--- nft/scripts/build.bat ---
@echo off

cd ..
title NFT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- nft/scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/..
source scripts/flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- nft/scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- nft/test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- nft/test-approval-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_approve for simulation testing nft_approve.
*/
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ApprovalReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

#[near_bindgen]
impl ApprovalReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for ApprovalReceiver {
    /// Could do anything useful to the approval-receiving contract, such as store the given
    /// approval_id for use later when calling the NFT contract. Can also return whatever it wants,
    /// maybe after further promise calls. This one simulates "return anything" behavior only.
    /// Supports the following `msg` patterns:
    /// * "return-now" - immediately return `"cool"`
    /// * anything else - return the given `msg` after one more cross-contract call
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        match msg.as_str() {
            "return-now" => PromiseOrValue::Value("cool".to_string()),
            _ => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(msg).into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for ApprovalReceiver {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String> {
        log!("in ok_go, msg={}", msg);
        PromiseOrValue::Value(msg)
    }
}
'''
'''--- nft/test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- nft/test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_transfer for simulation testing nft_transfer_call.
*/
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_transfer; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &sender_id,
            &previous_owner_id,
            &token_id,
            msg
        );
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(true),
            "return-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(true).into()
            }
            "keep-it-now" => PromiseOrValue::Value(false),
            "keep-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(false).into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool> {
        log!("in ok_go, return_it={}", return_it);
        PromiseOrValue::Value(return_it)
    }
}
'''
'''--- shell.sh ---
#!/bin/bash
# set -e

attrib=1
color=35

# Define function
Help ()
{
   # Display Help
   echo "Usage:"
   echo "   Syntax:"
   echo $'\t'"scriptTemplate [flag <action: string>]"
   echo "\n   Flag:"
   echo $'\t'"-m | --dmart        dMart contract."
   echo $'\t'"-n | --nft          NFT contract."
   echo "\n   Action:"
   echo $'\t'"b | build           Build specific contract."
   echo $'\t'"o | override        Deploy specific contract with old contract id."
   echo $'\t'"n | new             Deploy specific contract with new contract id."
   echo
   exit
}

Highlight_print_line ()
{
  printf %b "\033[$attrib;${color}m|| => $@\033[m\n"
}

build=0
deploy=0
new=0

Handle_received_value () 
{
  local val=$1
  build=0
  deploy=0
  new=0
 
  case "$val" in
    b | build)
      build=1
      ;;
    o | override)
      build=1
      deploy=1
      ;;
    n | new)
      new=1
      build=1
      deploy=1
      ;;
  esac
}

# Init variable
OWNER_ACCOUNT_ID=nttin.testnet

NEW_DMART=0
NEW_NFT=0

BUILD_DMART=0
BUILD_NFT=0

DEPLOY_DMART=0
DEPLOY_NFT=0

# rep.run contract
DMART_CTX_ID=
# nft contract
NFT_CTX_ID=

#################################################################################

###  GET PARAMS               ##########            ########         ############

#################################################################################

while getopts :m-:n-: flag
do
  case "${flag}" in
    -)
      case "${OPTARG}" in
        dmart) 
          val="${!OPTIND}"
          Handle_received_value $val
          NEW_DMART=$new
          BUILD_DMART=$build
          DEPLOY_DMART=$deploy
          ;;
        nft)
          val="${!OPTIND}"
          Handle_received_value $val
          NEW_NFT=$new
          BUILD_NFT=$build
          DEPLOY_NFT=$deploy
          ;;
        *)
          Help 
          exit
          ;;
      esac
      ;;
    m) 
      val="${!OPTIND}"
      Handle_received_value $val
      NEW_DMART=$new
      BUILD_DMART=$build
      DEPLOY_DMART=$deploy
      ;;
    n)
      val="${!OPTIND}"
      Handle_received_value $val
      NEW_NFT=$new
      BUILD_NFT=$build
      DEPLOY_NFT=$deploy
      ;;
    *)
      Help 
      exit
      ;;
  esac
  shift $(($optind + 1))
done

if [ $OPTIND -eq 1 ]; then
  Help
  exit
fi

#################################################################################

###  HANDLE                   ##########            ########         ############

#################################################################################

##################################################
## Handle contract dmart        ##################
##################################################
cd "dmart"
# Check new
if [ $NEW_DMART -eq 1 ]
then
  rm -rf neardev
fi

# Check build
if [ $BUILD_DMART -eq 1 ]
then
  echo "Building dmart..."
  RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
  mkdir -p res
  cp target/wasm32-unknown-unknown/release/dmart.wasm res/contract.wasm
fi

# Check deploy
if [ $DEPLOY_DMART -eq 1 ]
then
  wait
  near dev-deploy res/contract.wasm
fi

# Get ctx id
wait
DMART_CTX_ID=$(<neardev/dev-account)
cd ".."

##################################################
## Handle contract NFT    ########################
##################################################
cd "NFT"
# Check new
if [ $NEW_NFT -eq 1 ]
then
  rm -rf neardev
fi

# Check build
if [ $BUILD_NFT -eq 1 ]
then
  echo "Building nft..."
  sh ./scripts/build.sh
fi

# Check deploy
if [ $DEPLOY_NFT -eq 1 ]
then
  wait
  near dev-deploy --wasmFile ./res/non_fungible_token.wasm
fi

# Get ctx id
wait
NFT_CTX_ID=$(<neardev/dev-account)
cd ".."

#################################################################################

###  SET UP                   ##########            ########         ############

#################################################################################

#############################
# Set up NFT        ###   ###
#############################
if [ $NEW_NFT -eq 1 ]
then
  near call $NFT_CTX_ID new_default_meta '{"owner_id": "'$OWNER_ACCOUNT_ID'"}' --accountId $OWNER_ACCOUNT_ID
  near call $NFT_CTX_ID set_role '{"account_id": "'$DMART_CTX_ID'"}' --accountId $OWNER_ACCOUNT_ID
  
  #############################
  # Set up dMart      ###   ###
  #############################
  if [ $NEW_DMART -eq 1 ]
  then
    near call $DMART_CTX_ID new '{"nft_contract": "'$NFT_CTX_ID'"}' --accountId $OWNER_ACCOUNT_ID
  else
    near call $DMART_CTX_ID set_nft_contract '{"nft_contract": "'$NFT_CTX_ID'"}' --accountId $DMART_CTX_ID
  fi
else
  #############################
  # Set up dMart      ###   ###
  #############################
  if [ $NEW_DMART -eq 1 ]
  then
    near call $NFT_CTX_ID set_role '{"account_id": "'$DMART_CTX_ID'"}' --accountId $OWNER_ACCOUNT_ID
    near call $DMART_CTX_ID new '{"nft_contract": "'$NFT_CTX_ID'"}' --accountId $OWNER_ACCOUNT_ID
  fi
fi

printf %b "\033[$attrib;${color}m|| --------------------------------------------\033[m\n"
Highlight_print_line "DMart contract id: $DMART_CTX_ID"
Highlight_print_line "NFT contract id: $NFT_CTX_ID"
Highlight_print_line "Owner account id: $OWNER_ACCOUNT_ID"
printf %b "\033[$attrib;${color}m|| --------------------------------------------\033[m\n"

'''