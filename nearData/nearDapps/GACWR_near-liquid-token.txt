*GitHub Repository "GACWR/near-liquid-token"*

'''--- Cargo.toml ---
[workspace]
members = [
    "contracts/*"
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# near-liquid-token

The contracts directory contains 3 crates which are:

1. nearx: The main nearx contract.
2. mock-stake-pool: A mock validator stake pool contract which is used in the integration tests
3. integration-tests: A set of integration tests

### Building the project

`make all
`

it moves all wasm files to res/ directory

Running unit and integration tests

`make run-all-tests
`

Miro Board with product documentation: https://miro.com/app/board/uXjVOzCp74g=/

### Bug Bounty!

Stader Near has a bug bounty on NEAR. Please refer to the link here: https://immunefi.com/bounty/staderfornear/

'''
'''--- contracts/integration-tests/Cargo.toml ---
[package]
name = "integration-tests"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
near-units = "0.1.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.10.0", features = ["full"] }
workspaces = { git = "https://github.com/near/workspaces-rs" }
near-x = { path = "./../near-x" }
'''
'''--- contracts/integration-tests/src/constants.rs ---
pub const ONE_EPOCH: u64 = 500;

'''
'''--- contracts/integration-tests/src/context.rs ---
use crate::constants::ONE_EPOCH;
use crate::helpers::ntoy;
use crate::legacy_types::{LegacyNearxPoolStateResponse, LegacyRolesResponse};
use near_sdk::json_types::{U128, U64};
use near_units::parse_near;
use near_x::constants::NUM_EPOCHS_TO_UNLOCK;
use near_x::contract::OperationControls;
use near_x::state::{
    AccountResponse, Fraction, HumanReadableAccount, NearxPoolStateResponse,
    OperationsControlUpdateRequest, RolesResponse, ValidatorInfoResponse,
};
use serde_json::json;
use std::collections::HashMap;
use std::str::FromStr;
use workspaces::prelude::DevAccountDeployer;
use workspaces::result::CallExecutionDetails;
use workspaces::{network::Sandbox, prelude::*, Account, AccountId, Contract, Worker};

const NEARX_WASM_FILEPATH: &str = "./../../res/near_x.wasm";
const STAKE_POOL_WASM: &str = "./../../res/mock_stake_pool.wasm";

pub fn get_validator_account_id(validator_idx: u32) -> AccountId {
    AccountId::from_str(format!("stake_public_key_{}", validator_idx).as_str()).unwrap()
}

pub struct IntegrationTestContext<T> {
    pub worker: Worker<T>,
    pub validator_count: u32,
    pub nearx_contract: Contract,
    pub validator_to_stake_pool_contract: HashMap<AccountId, Contract>,
    pub nearx_operator: Account,
    pub nearx_owner: Account,
    pub nearx_treasury: Account,
    pub user1: Account,
    pub user2: Account,
    pub user3: Account,
}

impl IntegrationTestContext<Sandbox> {
    // Return type is the worker, nearx liquid token contract and stake pool contract with 3 users and operator, owner account
    pub async fn new(
        validator_count: u32,
        nearx_wasm_file: Option<&str>,
    ) -> anyhow::Result<IntegrationTestContext<Sandbox>> {
        println!("Connecting to sandbox!");
        let worker = workspaces::sandbox().await?;
        let nearx_wasm = std::fs::read(nearx_wasm_file.unwrap_or(NEARX_WASM_FILEPATH))?;
        let stake_pool_wasm = std::fs::read(STAKE_POOL_WASM)?;
        let nearx_contract = worker.dev_deploy(&nearx_wasm).await?;
        let mut validator_to_stake_pool_contract = HashMap::default();

        let nearx_operator = worker.dev_create_account().await?;
        let nearx_owner = worker.dev_create_account().await?;
        let nearx_treasury = worker.dev_create_account().await?;

        println!("nearx_operator is {:?}", nearx_operator.id().clone());
        println!("nearx_owner is {:?}", nearx_owner.id().clone());
        println!("nearx_treasury is {:?}", nearx_treasury.id().clone());

        let user1 = worker.dev_create_account().await?;
        let user2 = worker.dev_create_account().await?;
        let user3 = worker.dev_create_account().await?;

        println!("Setting up the sandbox workspace!");

        // init the near pool contract
        println!("Initializing the Nearx pool contract!");
        nearx_contract
            .call(&worker, "new")
            .args_json(json!({
                    "owner_account_id": nearx_owner.id().clone(),
                    "operator_account_id": nearx_operator.id().clone(),
                    "treasury_account_id": nearx_treasury.id().clone()
            }))?
            .transact()
            .await?;
        println!("Initialized the Nearx pool contract!");

        // Deploy all validator stake pool contracts
        println!(
            "Deploying validator stake pool contracts for {:?}",
            validator_count
        );

        for i in 0..validator_count {
            let stake_pool_contract = worker.dev_deploy(&stake_pool_wasm).await?;
            let validator_account_id = get_validator_account_id(i);

            // Initialized the stake pool contract
            println!("Initializing the stake pool contract");
            stake_pool_contract
                .call(&worker, "new")
                .max_gas()
                .transact()
                .await?;
            println!("Initializing the stake pool contract");

            println!("Adding validator {:?}", stake_pool_contract.id());
            // Add the stake pool
            // Initially give all validators equal weight
            println!("Adding validator");
            let res = nearx_operator
                .call(&worker, nearx_contract.id(), "add_validator")
                .deposit(1)
                .args_json(json!({ "validator": stake_pool_contract.id() , "weight": 10 }))?
                .transact()
                .await?;
            println!("add_validator res is {:?}", res);
            println!("Successfully Added the validator!");

            validator_to_stake_pool_contract.insert(validator_account_id, stake_pool_contract);
        }

        for i in 0..validator_count {
            println!("Seeding with manager deposit of 5N");
            let res = nearx_owner
                .call(&worker, nearx_contract.id(), "manager_deposit_and_stake")
                .args_json(json!({ "validator": validator_to_stake_pool_contract.get(&get_validator_account_id(i)).unwrap().id().clone() }))?
                .max_gas()
                .deposit(parse_near!("5 N"))
                .transact()
                .await?;
            println!("Seed with manager deposit of 5N");
        }

        println!("Fast forward to around 10 epochs");
        worker.fast_forward(10 * ONE_EPOCH).await?;

        Ok(IntegrationTestContext {
            worker,
            validator_count,
            nearx_contract,
            validator_to_stake_pool_contract,
            nearx_operator,
            nearx_owner,
            nearx_treasury,
            user1,
            user2,
            user3,
        })
    }

    pub async fn update_operation_controls(
        &mut self,
        operations_control: OperationsControlUpdateRequest,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(
                &self.worker,
                self.nearx_contract.id(),
                "update_operations_control",
            )
            .deposit(1)
            .args_json(json!({
                "update_operations_control_request": operations_control
            }))?
            .transact()
            .await
    }

    pub async fn update_validator(
        &mut self,
        account_id: AccountId,
        weight: u16,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_operator
            .call(&self.worker, self.nearx_contract.id(), "update_validator")
            .deposit(1)
            .args_json(json!({ "validator": account_id, "weight": weight }))?
            .transact()
            .await
    }

    pub async fn add_validator(&mut self, weight: u16) -> anyhow::Result<()> {
        let new_validator_id = self.validator_count;
        self.validator_count += 1;
        let stake_pool_wasm = std::fs::read(STAKE_POOL_WASM)?;

        let stake_pool_contract = self.worker.dev_deploy(&stake_pool_wasm).await?;
        let validator_account_id = get_validator_account_id(new_validator_id);
        // Initialized the stake pool contract
        println!("Initializing the stake pool contract");
        stake_pool_contract
            .call(&self.worker, "new")
            .max_gas()
            .transact()
            .await?;

        self.nearx_operator
            .call(&self.worker, self.nearx_contract.id(), "add_validator")
            .deposit(1)
            .args_json(json!({ "validator": stake_pool_contract.id(), "weight": weight}))?
            .transact()
            .await?;

        self.validator_to_stake_pool_contract
            .insert(validator_account_id, stake_pool_contract);

        Ok(())
    }

    pub async fn run_epoch_methods(&self) -> anyhow::Result<()> {
        let current_epoch = self.get_current_epoch().await?;

        println!("Running epoch methods!");

        let MAX_LOOP_COUNT: u32 = 3 * self.validator_count;

        // Run the autocompounding epoch
        for i in 0..self.validator_count {
            let res = self
                .autocompounding_epoch(self.get_stake_pool_contract(i).id())
                .await;
            if res.is_err() {
                continue;
            }
            println!("autocompounding logs are {:?}", res.unwrap().logs());
        }

        // Run the staking epoch
        let mut res = true;
        let mut i = 0;
        while res {
            let output = self.staking_epoch().await;
            if output.is_err() {
                println!("epoch stake errored out!");
                break;
            }
            println!("epoch_stake output is {:?}", output.as_ref().unwrap());
            res = output.unwrap().json::<bool>().unwrap();
            i += 1;
            if i >= MAX_LOOP_COUNT {
                break;
            }
        }

        // Run the unstaking epoch
        let mut res = true;
        let mut i = 0;
        while res {
            let output = self.unstaking_epoch().await;
            if output.is_err() {
                println!("epoch unstake errored out!");
                break;
            }
            println!("output of epoch unstake is {:?}", output);
            res = output.unwrap().json::<bool>().unwrap();
            i += 1;
            if i >= MAX_LOOP_COUNT {
                break;
            }
        }

        // Run the withdraw epoch
        for i in 0..self.validator_count {
            let validator_info = self
                .get_validator_info(self.get_stake_pool_contract(i).id().clone())
                .await?;

            if validator_info.unstaked.0 != 0
                && validator_info.last_unstake_start_epoch.0 + NUM_EPOCHS_TO_UNLOCK
                    < current_epoch.0
            {
                let res = self
                    .withdraw_epoch(self.get_stake_pool_contract(i).id().clone())
                    .await;
                if res.is_err() {
                    continue;
                }
            }
        }

        Ok(())
    }

    pub async fn update_rewards_buffer(
        &self,
        amount: u128,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(
                &self.worker,
                self.nearx_contract.id(),
                "update_rewards_buffer",
            )
            .deposit(amount)
            .max_gas()
            .transact()
            .await
    }

    pub async fn set_owner(&self, new_owner: &AccountId) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "set_owner")
            .args_json(json!({ "new_owner": new_owner.clone() }))?
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn commit_owner(&self, new_owner: &Account) -> anyhow::Result<CallExecutionDetails> {
        new_owner
            .call(&self.worker, self.nearx_contract.id(), "commit_owner")
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn set_operator(
        &self,
        new_operator: &AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "set_operator_id")
            .args_json(json!({ "new_operator_account_id": new_operator.clone() }))?
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn commit_operator(
        &self,
        new_operator: &Account,
    ) -> anyhow::Result<CallExecutionDetails> {
        new_operator
            .call(&self.worker, self.nearx_contract.id(), "commit_operator_id")
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn set_treasury(
        &self,
        new_treasury_id: &AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "set_treasury_id")
            .args_json(json!({ "new_treasury_account_id": new_treasury_id.clone() }))?
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn commit_treasury(
        &self,
        new_treasury_id: &Account,
    ) -> anyhow::Result<CallExecutionDetails> {
        new_treasury_id
            .call(&self.worker, self.nearx_contract.id(), "commit_treasury_id")
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub fn get_stake_pool_contract(&self, validator_idx: u32) -> &Contract {
        let validator_account_id = get_validator_account_id(validator_idx);
        self.validator_to_stake_pool_contract
            .get(&validator_account_id)
            .unwrap()
    }

    pub async fn ft_transfer_call(
        &self,
        user: &Account,
        receiving_contract: &Contract,
        amount: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        user.call(&self.worker, self.nearx_contract.id(), "ft_transfer_call")
            .args_json(json!({ "receiver_id": receiving_contract.id().clone(), "amount": amount, "msg": amount.0.to_string() }))?
            .deposit(1)
            .max_gas()
            .transact()
            .await
    }

    pub async fn deposit(
        &self,
        user: &Account,
        amount: u128,
    ) -> anyhow::Result<CallExecutionDetails> {
        user.call(&self.worker, self.nearx_contract.id(), "storage_deposit")
            .max_gas()
            .args_json(json!({}))?
            .deposit(3000000000000000000000)
            .transact()
            .await?;

        user.call(&self.worker, self.nearx_contract.id(), "deposit_and_stake")
            .max_gas()
            .deposit(amount)
            .transact()
            .await
    }

    pub async fn manager_deposit_and_stake(
        &self,
        amount: u128,
        stake_pool_contract: AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(
                &self.worker,
                self.nearx_contract.id(),
                "manager_deposit_and_stake",
            )
            .args_json(json!({ "validator": stake_pool_contract }))?
            .max_gas()
            .deposit(amount)
            .transact()
            .await
    }

    pub async fn unstake(
        &self,
        user: &Account,
        amount: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        user.call(&self.worker, self.nearx_contract.id(), "unstake")
            .max_gas()
            .args_json(json!({ "amount": amount }))?
            .transact()
            .await
    }

    pub async fn withdraw_all(&self, user: &Account) -> anyhow::Result<CallExecutionDetails> {
        user.call(&self.worker, self.nearx_contract.id(), "withdraw_all")
            .max_gas()
            .transact()
            .await
    }

    pub async fn withdraw(
        &self,
        user: &Account,
        amount: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        user.call(&self.worker, self.nearx_contract.id(), "withdraw")
            .max_gas()
            .args_json(json!({ "amount": amount }))?
            .transact()
            .await
    }

    pub async fn pause_validator(
        &self,
        validator: &AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "pause_validator")
            .max_gas()
            .deposit(1)
            .args_json(json!({ "validator": validator }))?
            .transact()
            .await
    }

    pub async fn remove_validator(
        &self,
        validator: &AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "remove_validator")
            .deposit(1)
            .max_gas()
            .args_json(json!({ "validator": validator }))?
            .transact()
            .await
    }

    pub async fn staking_epoch(&self) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_contract
            .call(&self.worker, "staking_epoch")
            .max_gas()
            .transact()
            .await
    }

    pub async fn unstaking_epoch(&self) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_contract
            .call(&self.worker, "unstaking_epoch")
            .max_gas()
            .transact()
            .await
    }

    pub async fn drain_unstake(
        &self,
        validator: AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "drain_unstake")
            .max_gas()
            .args_json(json!({ "validator": validator }))?
            .transact()
            .await
    }

    pub async fn withdraw_epoch(
        &self,
        validator: AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_contract
            .call(&self.worker, "withdraw_epoch")
            .max_gas()
            .args_json(json!({ "validator": validator }))?
            .transact()
            .await
    }

    pub async fn drain_withdraw(
        &self,
        validator: AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, self.nearx_contract.id(), "drain_withdraw")
            .max_gas()
            .args_json(json!({ "validator": validator }))?
            .transact()
            .await
    }

    pub async fn autocompounding_epoch(
        &self,
        validator: &AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_contract
            .call(&self.worker, "autocompounding_epoch")
            .max_gas()
            .args_json(json!({ "validator": validator.clone() }))?
            .transact()
            .await
    }

    pub async fn upgrade(&self, code: Vec<u8>) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, &self.nearx_contract.id(), "upgrade")
            .max_gas()
            .args(code)
            .transact()
            .await
    }

    pub async fn post_upgrade_function(&self) -> anyhow::Result<String> {
        self.nearx_contract
            .call(&self.worker, "test_post_upgrade")
            .view()
            .await?
            .json::<String>()
    }

    pub async fn ft_transfer(
        &self,
        sender: &Account,
        receiver: &Account,
        amount: String,
    ) -> anyhow::Result<CallExecutionDetails> {
        sender
            .call(&self.worker, self.nearx_contract.id(), "ft_transfer")
            .deposit(parse_near!("0.000000000000000000000001 N"))
            .max_gas()
            .args_json(json!({ "receiver_id": receiver.id(), "amount": amount }))?
            .transact()
            .await
    }

    pub async fn adjust_balance(
        &self,
        stake_pool_contract: &AccountId,
        staked_delta: U128,
        unstaked_delta: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner.call(&self.worker, stake_pool_contract, "adjust_balance").max_gas()
            .args_json(json!({ "account_id": stake_pool_contract, "staked_delta": staked_delta.0, "unstaked_delta": unstaked_delta.0 }))?
            .transact()
            .await
    }

    pub async fn add_stake_pool_rewards(
        &self,
        amount: U128,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<CallExecutionDetails> {
        stake_pool_contract
            .call(&self.worker, "add_reward_for")
            .max_gas()
            .args_json(json!({ "amount": amount, "account_id": self.nearx_contract.id().clone() }))?
            .transact()
            .await
    }

    pub async fn set_refund_amount(
        &self,
        amount: U128,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<CallExecutionDetails> {
        stake_pool_contract
            .call(&self.worker, "set_refund_amount")
            .max_gas()
            .args_json(json!({ "amount": amount }))?
            .transact()
            .await
    }

    pub async fn add_min_storage_reserve(
        &self,
        amount: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(
                &self.worker,
                &self.nearx_contract.id(),
                "add_min_storage_reserve",
            )
            .max_gas()
            .deposit(amount.0)
            .transact()
            .await
    }

    pub async fn ping_stake_pool_contract(
        &self,
        stake_pool_contract: &Contract,
        amount: U128,
    ) -> anyhow::Result<CallExecutionDetails> {
        stake_pool_contract
            .call(&self.worker, "ping")
            .args_json(json!({
                "amount": amount,
                "account_id": self.nearx_contract.id().clone()
            }))?
            .max_gas()
            .transact()
            .await
    }

    pub async fn set_stake_pool_panic(
        &self,
        stake_pool_contract: &AccountId,
        panic: bool,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, stake_pool_contract, "set_panic")
            .max_gas()
            .args_json(json!({ "panic": panic }))?
            .transact()
            .await
    }

    pub async fn set_reward_fee(
        &self,
        reward_fee: Fraction,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, &self.nearx_contract.id(), "set_reward_fee")
            .max_gas()
            .deposit(1)
            .args_json(
                json!({ "numerator": reward_fee.numerator, "denominator": reward_fee.denominator }),
            )?
            .transact()
            .await
    }

    pub async fn commit_reward_fee(&self) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(&self.worker, &self.nearx_contract.id(), "commit_reward_fee")
            .max_gas()
            .deposit(1)
            .transact()
            .await
    }

    pub async fn sync_validator_balances(
        &self,
        validator_id: AccountId,
    ) -> anyhow::Result<CallExecutionDetails> {
        self.nearx_owner
            .call(
                &self.worker,
                &self.nearx_contract.id(),
                "sync_balance_from_validator",
            )
            .max_gas()
            .args_json(json!({ "validator_id": validator_id }))?
            .transact()
            .await
    }

    pub async fn get_stake_pool_accounts(
        &self,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<Vec<HumanReadableAccount>> {
        stake_pool_contract
            .call(&self.worker, "get_accounts")
            .args_json(json!({ "from_index": 0, "limit": 10 }))?
            .view()
            .await?
            .json::<Vec<HumanReadableAccount>>()
    }

    pub async fn get_total_validator_weight(&self) -> anyhow::Result<u16> {
        self.nearx_contract
            .call(&self.worker, "get_total_validator_weight")
            .view()
            .await?
            .json::<u16>()
    }

    pub async fn get_stake_pool_total_staked_balance(
        &self,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<U128> {
        stake_pool_contract
            .call(&self.worker, "get_total_staked_balance")
            .view()
            .await?
            .json::<U128>()
    }

    #[deprecated]
    pub async fn get_user_deposit(&self, user: AccountId) -> anyhow::Result<U128> {
        let result = self
            .nearx_contract
            .call(&self.worker, "get_user_account")
            .args_json(json!({ "account_id": user }))?
            .view()
            .await?
            .json::<AccountResponse>()?;

        Ok(result.staked_balance)
    }

    pub async fn get_user_account(&self, user: AccountId) -> anyhow::Result<AccountResponse> {
        self.nearx_contract
            .call(&self.worker, "get_user_account")
            .args_json(json!({ "account_id": user }))?
            .view()
            .await?
            .json::<AccountResponse>()
    }

    pub async fn get_legacy_user_account(
        &self,
        user: AccountId,
    ) -> anyhow::Result<AccountResponse> {
        self.nearx_contract
            .call(&self.worker, "get_account")
            .args_json(json!({ "account_id": user }))?
            .view()
            .await?
            .json::<AccountResponse>()
    }

    pub async fn get_account(&self, user: AccountId) -> anyhow::Result<HumanReadableAccount> {
        self.nearx_contract
            .call(&self.worker, "get_account")
            .args_json(json!({ "account_id": user }))?
            .view()
            .await?
            .json::<HumanReadableAccount>()
    }

    pub async fn get_validator_info(
        &self,
        validator: AccountId,
    ) -> anyhow::Result<ValidatorInfoResponse> {
        self.nearx_contract
            .call(&self.worker, "get_validator_info")
            .args_json(json!({ "validator": validator }))?
            .view()
            .await?
            .json::<ValidatorInfoResponse>()
    }

    pub async fn get_user_token_balance(&self, user: AccountId) -> anyhow::Result<U128> {
        self.nearx_contract
            .call(&self.worker, "ft_balance_of")
            .args_json(json!({ "account_id": user }))?
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_nearx_price(&self) -> anyhow::Result<U128> {
        self.nearx_contract
            .call(&self.worker, "get_nearx_price")
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_nearx_state(&self) -> anyhow::Result<NearxPoolStateResponse> {
        self.nearx_contract
            .call(&self.worker, "get_nearx_pool_state")
            .view()
            .await?
            .json::<NearxPoolStateResponse>()
    }

    pub async fn get_legacy_nearx_state(&self) -> anyhow::Result<LegacyNearxPoolStateResponse> {
        self.nearx_contract
            .call(&self.worker, "get_nearx_pool_state")
            .view()
            .await?
            .json::<LegacyNearxPoolStateResponse>()
    }

    pub async fn get_total_staked_amount(&self) -> anyhow::Result<U128> {
        self.nearx_contract
            .call(&self.worker, "get_total_staked_balance")
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_stake_pool_total_staked_amount(
        &self,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<U128> {
        stake_pool_contract
            .call(&self.worker, "get_account_staked_balance")
            .args_json(json!({ "account_id": self.nearx_contract.id().clone() }))?
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_stake_pool_total_unstaked_amount(
        &self,
        stake_pool_contract: &Contract,
    ) -> anyhow::Result<U128> {
        stake_pool_contract
            .call(&self.worker, "get_account_unstaked_balance")
            .args_json(json!({ "account_id": self.nearx_contract.id().clone() }))?
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_total_tokens_supply(&self) -> anyhow::Result<U128> {
        self.nearx_contract
            .call(&self.worker, "ft_total_supply")
            .view()
            .await?
            .json::<U128>()
    }

    pub async fn get_current_epoch(&self) -> anyhow::Result<U64> {
        self.nearx_contract
            .call(&self.worker, "get_current_epoch")
            .view()
            .await?
            .json::<U64>()
    }

    pub async fn get_reward_fee(&self) -> anyhow::Result<Fraction> {
        self.nearx_contract
            .call(&self.worker, "get_reward_fee_fraction")
            .view()
            .await?
            .json::<Fraction>()
    }

    pub async fn is_validator_unstake_pending(&self, validator: AccountId) -> anyhow::Result<bool> {
        self.nearx_contract
            .call(&self.worker, "is_validator_unstake_pending")
            .args_json(json!({ "validator": validator }))?
            .view()
            .await?
            .json::<bool>()
    }

    pub async fn get_validators(&self) -> anyhow::Result<Vec<ValidatorInfoResponse>> {
        self.nearx_operator
            .call(&self.worker, self.nearx_contract.id(), "get_validators")
            .view()
            .await?
            .json::<Vec<ValidatorInfoResponse>>()
    }

    pub async fn get_roles(&self) -> anyhow::Result<RolesResponse> {
        self.nearx_operator
            .call(&self.worker, self.nearx_contract.id(), "get_roles")
            .view()
            .await?
            .json::<RolesResponse>()
    }

    pub async fn get_legacy_roles(&self) -> anyhow::Result<LegacyRolesResponse> {
        self.nearx_operator
            .call(&self.worker, self.nearx_contract.id(), "get_roles")
            .view()
            .await?
            .json::<LegacyRolesResponse>()
    }

    pub async fn get_operations_controls(&self) -> anyhow::Result<OperationControls> {
        self.nearx_operator
            .call(
                &self.worker,
                self.nearx_contract.id(),
                "get_operations_control",
            )
            .view()
            .await?
            .json::<OperationControls>()
    }
}

'''
'''--- contracts/integration-tests/src/helpers.rs ---
use near_sdk::json_types::U128;
use near_sdk::ONE_NEAR;

// const CLOSE_DELTA: u128 = 1_000_000_000_000_000_000_000;
const CLOSE_DELTA: u128 = 5_000_000_000_000_000_000_000_0; // Delta for now

pub fn ntoy(near_amount: u128) -> u128 {
    near_amount * 10u128.pow(24)
}

pub(crate) fn abs_diff_eq(left: u128, right: u128, epsilon: u128) -> bool {
    left <= right + epsilon && right <= left + epsilon
}

'''
'''--- contracts/integration-tests/src/legacy_types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use near_sdk::EpochHeight;
use near_x::state::Fraction;
use workspaces::types::Balance;

#[derive(Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LegacyNearxPoolStateResponse {
    pub owner_account_id: AccountId,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    pub total_staked: U128,

    /// how many "shares" were minted. Every time someone "stakes" he "buys pool shares" with the staked amount
    // the buy share price is computed so if she "sells" the shares on that moment she recovers the same near amount
    // staking produces rewards, rewards are added to total_for_staking so share_price will increase with rewards
    // share_price = total_staked/total_shares
    pub total_stake_shares: U128, //total NearX minted

    pub accumulated_staked_rewards: U128,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: U128,

    pub operator_account_id: AccountId,

    /// pct of rewards which will go to the operator
    pub rewards_fee_pct: Fraction,

    /// Amount of NEAR that is users requested to stake
    pub user_amount_to_stake_in_epoch: U128,
    /// Amount of NEAR that is users requested to unstake
    pub user_amount_to_unstake_in_epoch: U128,

    /// Amount of NEAR that actually needs to be staked in the epoch
    pub reconciled_epoch_stake_amount: U128,
    /// Amount of NEAR that actually needs to be unstaked in the epoch
    pub reconciled_epoch_unstake_amount: U128,
    /// Last epoch height stake/unstake amount were reconciled
    pub last_reconcilation_epoch: U64,

    pub temp_reward_fee: Option<Fraction>,

    pub rewards_buffer: U128,

    pub accumulated_rewards_buffer: U128,

    pub last_reward_fee_set_epoch: EpochHeight,
}

#[derive(Default, BorshDeserialize, BorshSerialize, Debug, PartialEq, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LegacyAccount {
    pub stake_shares: u128, //nearx this account owns

    pub unstaked_amount: Balance,

    pub withdrawable_epoch_height: EpochHeight,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LegacyRolesResponse {
    pub owner_account: AccountId,
    pub operator_account: AccountId,
    pub treasury_account: AccountId,
    pub temp_owner: Option<AccountId>,
}

'''
'''--- contracts/integration-tests/src/lib.rs ---
mod constants;
mod context;
mod helpers;
mod legacy_types;

use crate::constants::ONE_EPOCH;
use crate::helpers::{abs_diff_eq, ntoy};
use context::IntegrationTestContext;
use near_sdk::json_types::{U128, U64};
use near_sdk::ONE_NEAR;
use near_units::*;
use near_x::constants::gas::ON_STAKE_POOL_WITHDRAW_ALL_CB;
use near_x::constants::NUM_EPOCHS_TO_UNLOCK;
use near_x::state::{
    AccountResponse, Fraction, HumanReadableAccount, NearxPoolStateResponse,
    OperationsControlUpdateRequest, ValidatorInfoResponse,
};
use serde_json::json;
use workspaces::network::DevAccountDeployer;

// Important data points to check
/// 1. nearx state
/// 2. nearx price
/// 3. user account
/// 4. validator account
/// 5. actual staked info
/// 6. actual unstaked info
///

#[tokio::test]
async fn test_set_owner() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    let new_owner_account = context.worker.dev_create_account().await?;
    let new_owner_near_sdk_account =
        near_sdk::AccountId::new_unchecked(new_owner_account.id().to_string());

    context.set_owner(&new_owner_account.id().clone()).await?;

    let roles = context.get_roles().await?;
    assert_eq!(roles.temp_owner, Some(new_owner_near_sdk_account.clone()));

    context.commit_owner(&new_owner_account).await?;

    let roles = context.get_roles().await?;

    assert_eq!(roles.owner_account, new_owner_near_sdk_account);

    let roles = context.get_roles().await?;
    assert!(roles.temp_owner.is_none());

    Ok(())
}

#[tokio::test]
async fn test_set_operator() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    let new_operator_account = context.worker.dev_create_account().await?;
    let new_operator_near_sdk_account =
        near_sdk::AccountId::new_unchecked(new_operator_account.id().to_string());

    context
        .set_operator(&new_operator_account.id().clone())
        .await?;

    let roles = context.get_roles().await?;
    assert_eq!(
        roles.temp_operator,
        Some(new_operator_near_sdk_account.clone())
    );

    context.commit_operator(&new_operator_account).await?;

    let roles = context.get_roles().await?;

    assert_eq!(roles.operator_account, new_operator_near_sdk_account);

    let roles = context.get_roles().await?;
    assert!(roles.temp_operator.is_none());

    Ok(())
}

#[tokio::test]
async fn test_set_treasury() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    let new_treasury_account = context.worker.dev_create_account().await?;
    let new_treasury_near_sdk_account =
        near_sdk::AccountId::new_unchecked(new_treasury_account.id().to_string());

    println!("setting treasury");
    context
        .set_treasury(&new_treasury_account.id().clone())
        .await?;

    let roles = context.get_roles().await?;
    assert_eq!(
        roles.temp_treasury,
        Some(new_treasury_near_sdk_account.clone())
    );

    println!("commit treasury!");
    context.commit_treasury(&new_treasury_account).await?;

    let roles = context.get_roles().await?;

    assert_eq!(roles.treasury_account, new_treasury_near_sdk_account);

    let roles = context.get_roles().await?;
    assert!(roles.temp_treasury.is_none());

    Ok(())
}

#[tokio::test]
async fn test_reward_fee_set() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    context.set_reward_fee(Fraction::new(6, 100)).await?;

    let nearx_pool_state = context.get_nearx_state().await?;
    assert_eq!(nearx_pool_state.temp_reward_fee.unwrap().numerator, 6);
    assert_eq!(nearx_pool_state.temp_reward_fee.unwrap().denominator, 100);

    context.worker.fast_forward(ONE_EPOCH).await?;

    assert!(context.commit_reward_fee().await.is_err());

    context.worker.fast_forward(5 * ONE_EPOCH).await?;

    context.commit_reward_fee().await?;

    let nearx_pool_state = context.get_nearx_state().await?;
    assert_eq!(nearx_pool_state.rewards_fee_pct.numerator, 6);
    assert_eq!(nearx_pool_state.rewards_fee_pct.denominator, 100);
    assert!(nearx_pool_state.temp_reward_fee.is_none());

    Ok(())
}

// TODO - update this test when we do the next contract upgrade
#[tokio::test]
#[ignore]
async fn test_contract_upgrade() -> anyhow::Result<()> {
    let old_contract = "./../../res/near_x_c70812191a07c4c6b8a9ba7bd7f6dd4f615923af.wasm";

    println!("Deploying old contract!");
    let mut context = IntegrationTestContext::new(3, Some(old_contract)).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    let new_contract = "./../../res/near_x.wasm";

    println!("depositing!");
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );

    let nearx_state = context.get_legacy_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_legacy_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let current_epoch = context.get_current_epoch().await?;
    println!("validator1 is {:?}", validator1_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: validator1_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: validator2_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: validator3_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(3 * ONE_EPOCH).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    let nearx_state = context.get_legacy_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(40)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    context.run_epoch_methods().await?;

    let nearx_state = context.get_legacy_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(40)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let current_epoch = context.get_current_epoch().await?;
    println!("validator1 is {:?}", validator1_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: validator1_info.account_id.clone(),
            staked: U128(ntoy(10)),
            unstaked: U128(ntoy(5)),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(current_epoch_2.0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: validator2_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: validator3_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.unstake(&context.user2, U128(ntoy(5))).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    println!("user2_account is {:?}", user2_account);
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );

    assert!(context
        .add_min_storage_reserve(U128(ntoy(10)))
        .await
        .is_err());

    println!("Reading the new contract!");
    let nearx_2_wasm = std::fs::read(new_contract)?;

    context.upgrade(nearx_2_wasm).await?;

    let user2_account = context.get_account(context.user2.id().clone()).await?;
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.can_withdraw, false);

    // test set_min_storage_reserve
    context.add_min_storage_reserve(U128(ntoy(60))).await?;

    context.worker.fast_forward(2 * ONE_EPOCH).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    // test reward buffer update
    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);
    assert_eq!(nearx_state.total_staked, U128(ntoy(35)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(0));
    assert_eq!(nearx_state.accumulated_rewards_buffer, U128(0));
    assert_eq!(nearx_state.min_storage_reserve, U128(ntoy(110)));

    context.update_rewards_buffer(ntoy(5)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(ntoy(5)));
    assert_eq!(nearx_state.accumulated_rewards_buffer, U128(ntoy(5)));

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx_price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(1142857142857142857142857));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(0));
    assert_eq!(nearx_state.accumulated_rewards_buffer, U128(ntoy(5)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let current_epoch_4 = context.get_current_epoch().await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: validator1_info.account_id.clone(),
            staked: U128(ntoy(10)),
            unstaked: U128(ntoy(5)),
            last_asked_rewards_epoch_height: current_epoch_4,
            last_unstake_start_epoch: U64(current_epoch_2.0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: validator2_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_4,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: validator3_info.account_id.clone(),
            staked: U128(ntoy(15)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_4,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    Ok(())
}

#[tokio::test]
async fn test_all_epochs_paused() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    let current_epoch = context.get_current_epoch().await?;

    context
        .update_operation_controls(OperationsControlUpdateRequest {
            stake_paused: None,
            unstake_paused: None,
            withdraw_paused: None,
            staking_epoch_paused: Some(true),
            unstaking_epoch_paused: Some(true),
            withdraw_epoch_paused: Some(true),
            autocompounding_epoch_paused: Some(true),
            sync_validator_balance_paused: Some(true),
            ft_transfer_paused: Some(true),
            ft_transfer_call_paused: Some(true),
        })
        .await?;

    let operations_controls = context.get_operations_controls().await?;
    assert_eq!(operations_controls.autocompounding_epoch_paused, true);
    assert_eq!(operations_controls.staking_epoch_paused, true);
    assert_eq!(operations_controls.unstaking_epoch_paused, true);
    assert_eq!(operations_controls.withdraw_epoch_paused, true);
    assert_eq!(operations_controls.ft_transfer_paused, true);
    assert_eq!(operations_controls.ft_transfer_call_paused, true);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(40)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(user1_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(5)));
    assert_eq!(
        user1_account.withdrawable_epoch,
        U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
    );
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(40)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.worker.fast_forward(6 * ONE_EPOCH).await?;

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        (user1_balance_after_withdraw - user1_balance_before_withdraw),
        ntoy(5),
        100000000000000000000000
    ));

    Ok(())
}

#[tokio::test]
async fn test_system_with_no_validators() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(0, None).await?;

    // deposit and unstake
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(25)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(25)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(user1_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(25)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(25)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(25)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH).await?;

    context.unstake(&context.user1, U128(ntoy(5))).await?;
    context.unstake(&context.user2, U128(ntoy(5))).await?;
    context.unstake(&context.user3, U128(ntoy(5))).await?;
    context.unstake(&context.user3, U128(ntoy(5))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(user1_account.staked_balance, U128(0));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(10)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(5)));
    assert_eq!(user3_account.staked_balance, U128(0));
    assert_eq!(user3_account.unstaked_balance, U128(ntoy(10)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(5)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(5)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(20)));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(user1_account.staked_balance, U128(ntoy(0)));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(10)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(5)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(0)));
    assert_eq!(user3_account.unstaked_balance, U128(ntoy(10)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(5)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(5)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));

    context.worker.fast_forward(5 * ONE_EPOCH).await?;

    context.run_epoch_methods().await?;

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        (user1_balance_after_withdraw - user1_balance_before_withdraw),
        ntoy(10),
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        (user2_balance_after_withdraw - user2_balance_before_withdraw),
        ntoy(5),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context.user3.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context.user3.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        (user3_balance_after_withdraw - user3_balance_before_withdraw),
        ntoy(10),
        ntoy(1)
    ));

    Ok(())
}

#[tokio::test]
async fn test_manager_deposit_and_stake() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    context
        .manager_deposit_and_stake(ntoy(10), context.get_stake_pool_contract(0).id().clone())
        .await?;
    context
        .manager_deposit_and_stake(ntoy(10), context.get_stake_pool_contract(1).id().clone())
        .await?;
    context
        .manager_deposit_and_stake(ntoy(10), context.get_stake_pool_contract(2).id().clone())
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!("got stake pool staked amount");

    assert_eq!(stake_pool_1_amount, U128(ntoy(15)));
    assert_eq!(stake_pool_2_amount, U128(ntoy(15)));
    assert_eq!(stake_pool_3_amount, U128(ntoy(15)));

    Ok(())
}

#[tokio::test]
async fn test_validator_selection_with_0_weight() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    context.add_validator(20).await?;
    context.add_validator(20).await?;

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 70);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(65)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(65)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    let validator5_info = context
        .get_validator_info(context.get_stake_pool_contract(4).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    println!("validator4_info is {:?}", validator4_info);
    println!("validator5_info is {:?}", validator5_info);

    assert_eq!(validator1_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator2_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator3_info.staked, U128(9285714285714285714285716));
    assert_eq!(validator4_info.staked, U128(18571428571428571428571428));
    assert_eq!(validator5_info.staked, U128(18571428571428571428571428));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));
    assert_eq!(validator5_info.unstaked, U128(0));

    context.worker.fast_forward(ONE_EPOCH).await?;

    context
        .pause_validator(context.get_stake_pool_contract(0).id())
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.weight, 0);

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 60);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(115)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(115)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    let validator5_info = context
        .get_validator_info(context.get_stake_pool_contract(4).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    println!("validator4_info is {:?}", validator4_info);
    println!("validator5_info is {:?}", validator5_info);

    assert_eq!(validator1_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator2_info.staked, U128(19761904761904761904761904));
    assert_eq!(validator3_info.staked, U128(9285714285714285714285716));
    assert_eq!(validator4_info.staked, U128(38333333333333333333333333));
    assert_eq!(validator5_info.staked, U128(38333333333333333333333333));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));
    assert_eq!(validator5_info.unstaked, U128(0));

    context.worker.fast_forward(ONE_EPOCH).await?;

    context
        .pause_validator(context.get_stake_pool_contract(1).id())
        .await?;

    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    assert_eq!(validator2_info.weight, 0);

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 50);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(165)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(165)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    let validator5_info = context
        .get_validator_info(context.get_stake_pool_contract(4).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    println!("validator4_info is {:?}", validator4_info);
    println!("validator5_info is {:?}", validator5_info);

    assert_eq!(validator1_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator2_info.staked, U128(19761904761904761904761904));
    assert_eq!(validator3_info.staked, U128(31619047619047619047619049));
    assert_eq!(validator4_info.staked, U128(66000000000000000000000000));
    assert_eq!(validator5_info.staked, U128(38333333333333333333333333));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));
    assert_eq!(validator5_info.unstaked, U128(0));

    context.worker.fast_forward(ONE_EPOCH).await?;

    context
        .pause_validator(context.get_stake_pool_contract(2).id())
        .await?;

    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator3_info.weight, 0);

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 40);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(215)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(215)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    let validator5_info = context
        .get_validator_info(context.get_stake_pool_contract(4).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    println!("validator4_info is {:?}", validator4_info);
    println!("validator5_info is {:?}", validator5_info);

    assert_eq!(validator1_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator2_info.staked, U128(19761904761904761904761904));
    assert_eq!(validator3_info.staked, U128(31619047619047619047619049));
    assert_eq!(validator4_info.staked, U128(66000000000000000000000000));
    assert_eq!(validator5_info.staked, U128(88333333333333333333333333));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));
    assert_eq!(validator5_info.unstaked, U128(0));

    /// All validators are paused
    context.worker.fast_forward(ONE_EPOCH).await?;

    context
        .pause_validator(context.get_stake_pool_contract(3).id())
        .await?;
    context
        .pause_validator(context.get_stake_pool_contract(4).id())
        .await?;

    context.deposit(&context.user1, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(225)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(225)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(10)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(225)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(225)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(10)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    let validator5_info = context
        .get_validator_info(context.get_stake_pool_contract(4).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    println!("validator4_info is {:?}", validator4_info);
    println!("validator5_info is {:?}", validator5_info);

    assert_eq!(validator1_info.staked, U128(9285714285714285714285714));
    assert_eq!(validator2_info.staked, U128(19761904761904761904761904));
    assert_eq!(validator3_info.staked, U128(31619047619047619047619049));
    assert_eq!(validator4_info.staked, U128(66000000000000000000000000));
    assert_eq!(validator5_info.staked, U128(88333333333333333333333333));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));
    assert_eq!(validator5_info.unstaked, U128(0));

    Ok(())
}

#[tokio::test]
async fn test_validator_selection() -> anyhow::Result<()> {
    let mut context = IntegrationTestContext::new(3, None).await?;

    /// All validators have equal weight
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    // Update validator weights to 1:2:3
    context
        .update_validator(context.get_stake_pool_contract(0).id().clone(), 10)
        .await?;
    context
        .update_validator(context.get_stake_pool_contract(1).id().clone(), 20)
        .await?;
    context
        .update_validator(context.get_stake_pool_contract(2).id().clone(), 30)
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.weight, 10);
    assert_eq!(validator2_info.weight, 20);
    assert_eq!(validator3_info.weight, 30);

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 60);

    context.worker.fast_forward(ONE_EPOCH).await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(95)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(95)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(32500000000000000000000000));
    assert_eq!(validator3_info.staked, U128(47500000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    // Add a new validator
    context.add_validator(40).await?;

    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;
    assert_eq!(validator4_info.weight, 40);

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 100);

    context.worker.fast_forward(ONE_EPOCH).await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(145)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(145)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    println!("validator 4 info is {:?}", validator4_info);

    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(32500000000000000000000000));
    assert_eq!(validator3_info.staked, U128(47500000000000000000000000));
    assert_eq!(validator4_info.staked, U128(50000000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));

    // One more round!
    context.worker.fast_forward(ONE_EPOCH).await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(195)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(195)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(195)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(195)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    println!("validator 4 info is {:?}", validator4_info);

    assert_eq!(validator1_info.staked, U128(19500000000000000000000000));
    assert_eq!(validator2_info.staked, U128(39000000000000000000000000));
    assert_eq!(validator3_info.staked, U128(58500000000000000000000000));
    assert_eq!(validator4_info.staked, U128(78000000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(0));

    context.worker.fast_forward(ONE_EPOCH).await?;

    // Imbalance the pool by unstaking
    context.unstake(&context.user1, U128(ntoy(30))).await?;
    context.unstake(&context.user2, U128(ntoy(20))).await?;
    context.unstake(&context.user3, U128(ntoy(20))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(125)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(125)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(70)));

    context.run_epoch_methods().await?;

    let current_epoch = context.get_current_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(125)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(125)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    println!("validator 4 info is {:?}", validator4_info);

    assert_eq!(validator1_info.staked, U128(19500000000000000000000000));
    assert_eq!(validator2_info.staked, U128(39000000000000000000000000));
    assert_eq!(validator3_info.staked, U128(58500000000000000000000000));
    assert_eq!(validator4_info.staked, U128(8000000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(70000000000000000000000000));
    assert_eq!(validator4_info.last_unstake_start_epoch, current_epoch);

    // Update the weights mid way
    context
        .update_validator(context.get_stake_pool_contract(0).id().clone(), 40)
        .await?;
    context
        .update_validator(context.get_stake_pool_contract(1).id().clone(), 30)
        .await?;
    context
        .update_validator(context.get_stake_pool_contract(2).id().clone(), 20)
        .await?;
    context
        .update_validator(context.get_stake_pool_contract(3).id().clone(), 10)
        .await?;

    let total_validator_weight = context.get_total_validator_weight().await?;
    assert_eq!(total_validator_weight, 100);

    context.worker.fast_forward(ONE_EPOCH).await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(175)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(175)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(175)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(175)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let validator4_info = context
        .get_validator_info(context.get_stake_pool_contract(3).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    println!("validator 4 info is {:?}", validator4_info);

    assert_eq!(validator1_info.staked, U128(69500000000000000000000000));
    assert_eq!(validator2_info.staked, U128(39000000000000000000000000));
    assert_eq!(validator3_info.staked, U128(58500000000000000000000000));
    assert_eq!(validator4_info.staked, U128(8000000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator4_info.unstaked, U128(70000000000000000000000000));
    assert_eq!(validator4_info.last_unstake_start_epoch, current_epoch);

    Ok(())
}

/// Test ft_on_transfer
#[tokio::test]
async fn test_ft_on_transfer_receiver_failure() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // get 10 Nearx
    context.deposit(&context.user1, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));

    context
        .set_stake_pool_panic(context.get_stake_pool_contract(0).id(), true)
        .await?;

    // Transfer 7N to the contract with 3N being used only
    let res = context
        .ft_transfer_call(
            &context.user1,
            context.get_stake_pool_contract(0),
            U128(ntoy(7)),
        )
        .await?;
    println!("res logs are {:?}", res);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));

    Ok(())
}

#[tokio::test]
async fn test_ft_on_transfer() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // get 10 Nearx
    context.deposit(&context.user1, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));

    context
        .set_refund_amount(U128(ntoy(6)), context.get_stake_pool_contract(0))
        .await?;

    // Transfer 7N to the contract with 3N being used only
    let res = context
        .ft_transfer_call(
            &context.user1,
            context.get_stake_pool_contract(0),
            U128(ntoy(7)),
        )
        .await?;
    println!("res logs are {:?}", res);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(9)));

    context
        .set_refund_amount(U128(ntoy(0)), context.get_stake_pool_contract(0))
        .await?;

    let res = context
        .ft_transfer_call(
            &context.user1,
            context.get_stake_pool_contract(0),
            U128(ntoy(9)),
        )
        .await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(0)));

    Ok(())
}

/// Stake pool Failures
/// Stake pool deposit_and_stake failures
#[tokio::test]
async fn test_stake_pool_failures_deposit() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    println!("user1_depositing 10N");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("user2 depositing 5N");
    context.deposit(&context.user2, ntoy(5)).await?;
    println!("User 3 depositing 2N");
    context.deposit(&context.user3, ntoy(2)).await?;

    context
        .set_stake_pool_panic(context.get_stake_pool_contract(0).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(1).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(2).id(), true)
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    let res = context.staking_epoch().await?;
    println!("res is {:?}", res.logs());
    // assert!(res.is_err());

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(17)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    println!("Getting validator info");
    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator2_info.staked, U128(ntoy(5)));
    assert_eq!(validator3_info.staked, U128(ntoy(5)));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    println!("Got validator info");

    println!("getting stake pool staked amount");
    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!("got stake pool staked amount");

    assert_eq!(stake_pool_1_amount, U128(ntoy(5)));
    assert_eq!(stake_pool_2_amount, U128(ntoy(5)));
    assert_eq!(stake_pool_3_amount, U128(ntoy(5)));

    println!("Getting stake pool unstaked amount");
    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));
    println!("Got stake pool unstaked amount");

    Ok(())
}

#[tokio::test]
async fn test_stake_pool_failures_unstake() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    println!("user1_depositing 10N");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("user2 depositing 5N");
    context.deposit(&context.user2, ntoy(5)).await?;
    println!("User 3 depositing 2N");
    context.deposit(&context.user3, ntoy(2)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(10666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(10666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(20 * ONE_EPOCH).await?;

    let current_epoch_2 = context.get_current_epoch().await?;
    println!("current_epoch_2 is {:?}", current_epoch_2);

    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(27)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(27)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    // set stake pool panic
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(0).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(1).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(2).id(), true)
        .await?;

    context.run_epoch_methods().await?;
    // context.epoch_unstake().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(27)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(27)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(10666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(10666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    Ok(())
}

#[tokio::test]
async fn test_stake_pool_failures_withdraw() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    println!("user1_depositing 10N");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("user2 depositing 5N");
    context.deposit(&context.user2, ntoy(5)).await?;
    println!("User 3 depositing 2N");
    context.deposit(&context.user3, ntoy(2)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(10666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(10666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(27)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(27)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(27)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(27)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(5666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(ntoy(5)));
    assert_eq!(validator3_info.last_unstake_start_epoch, current_epoch_2);

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(5666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(5)));

    context.worker.fast_forward(ONE_EPOCH * 5).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    // set stake pool panic
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(0).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(1).id(), true)
        .await?;
    context
        .set_stake_pool_panic(context.get_stake_pool_contract(2).id(), true)
        .await?;

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(27)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(27)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(5666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(ntoy(5)));
    assert_eq!(validator3_info.last_unstake_start_epoch, current_epoch_2);

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(5666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(5)));

    Ok(())
}

/// User flow specific integration tests
#[tokio::test]
async fn test_eight_epochs_user_flows() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;
    println!("current_epoch_1 is {:?}", current_epoch_1);

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;
    context.unstake(&context.user1, U128(ntoy(5))).await?;
    context.unstake(&context.user2, U128(ntoy(5))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(35)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(10)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(35)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(11666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(11666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(11666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(11666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(11666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(11666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH).await?;

    context
        .set_reward_fee(Fraction {
            numerator: 10,
            denominator: 100,
        })
        .await?;
    context.worker.fast_forward(4 * ONE_EPOCH).await?;
    context.commit_reward_fee().await?;

    let reward_fee = context.get_reward_fee().await?;
    assert_eq!(reward_fee.numerator, 10);
    assert_eq!(reward_fee.denominator, 100);

    context.worker.fast_forward(5 * ONE_EPOCH).await?;

    context.deposit(&context.user1, ntoy(5)).await?;
    context.deposit(&context.user2, ntoy(5)).await?;
    context.unstake(&context.user1, U128(ntoy(5))).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    println!(
        "current_epoch_2_post_reward_fee_set is {:?}",
        current_epoch_2
    );

    context
        .add_stake_pool_rewards(U128(ntoy(10)), context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(15)), context.get_stake_pool_contract(1))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(10)), context.get_stake_pool_contract(2))
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(40)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(40)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(10)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(10)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(75)));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(42298092307692307692307691)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1773129611955585558323052));

    let nearx_treasury_account = context
        .get_user_account(context.nearx_treasury.id().clone())
        .await?;
    println!("nearx_treasury_account is {:?}", nearx_treasury_account);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(ntoy(25)));
    assert_eq!(validator2_info.staked, U128(26666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(23333333333333333333333334));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(ntoy(25)));
    assert_eq!(stake_pool_2_amount, U128(26666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(23333333333333333333333334));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    context.unstake(&context.user1, U128(ntoy(5))).await?;
    context.unstake(&context.user3, U128(ntoy(5))).await?;

    context
        .add_stake_pool_rewards(U128(ntoy(10)), context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(10)), context.get_stake_pool_contract(1))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(10)), context.get_stake_pool_contract(2))
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(64999999999999999999999998));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(36658346666666666666666665)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(10000000000000000000000002)
    );
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx_price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(1773129611955585558323052));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(15000000000000000000000001),
            staked_balance: U128(3865648059777927791615260),
            withdrawable_epoch: U64(current_epoch_3.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(17731296119555855583230522),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(12731296119555855583230521),
            withdrawable_epoch: U64(current_epoch_3.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(94999999999999999999999998));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(37979772245333333333333330)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);

    let treasury_account = context
        .get_user_account(context.nearx_treasury.id().clone())
        .await?;
    println!("treasury account is {:?}", treasury_account);

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx_price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(2501331482093678964853995));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(35000000000000000000000000));
    assert_eq!(validator2_info.staked, U128(26666666666666666666666664));
    assert_eq!(validator3_info.staked, U128(33333333333333333333333334));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(10000000000000000000000002));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(35000000000000000000000000));
    assert_eq!(stake_pool_2_amount, U128(26666666666666666666666664));
    assert_eq!(stake_pool_3_amount, U128(33333333333333333333333334));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(0));
    assert_eq!(
        stake_pool_2_unstaked_amount,
        U128(10000000000000000000000002)
    );
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH * 5).await?;

    let contract_balance_before_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id())
        .await?
        .balance;
    context.run_epoch_methods().await?;
    let contract_balance_after_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id())
        .await?
        .balance;
    assert!(abs_diff_eq(
        (contract_balance_after_withdraw - contract_balance_before_withdraw),
        10000000000000000000000002,
        ntoy(1)
    ));

    let user1_balance_before_withdraw = context
        .worker
        .view_account(&context.user1.id())
        .await?
        .balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context
        .worker
        .view_account(&context.user1.id())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user1_balance_after_withdraw - user1_balance_before_withdraw),
        15000000000000000000000001,
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context
        .worker
        .view_account(&context.user2.id())
        .await?
        .balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context
        .worker
        .view_account(&context.user2.id())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user2_balance_after_withdraw - user2_balance_before_withdraw),
        ntoy(5),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context
        .worker
        .view_account(&context.user3.id())
        .await?
        .balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context
        .worker
        .view_account(&context.user3.id())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user3_balance_after_withdraw - user3_balance_before_withdraw),
        5000000000000000000000001,
        ntoy(1)
    ));

    Ok(())
}

#[tokio::test]
async fn test_bank_run() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;
    println!("current_epoch_1 is {:?}", current_epoch_1);

    println!("user1_depositing 10N");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("user2 depositing 5N");
    context.deposit(&context.user2, ntoy(5)).await?;
    println!("User 3 depositing 2N");
    context.deposit(&context.user3, ntoy(2)).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(0)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(32)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(32)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(10666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(10666666666666666666666668));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.unstake(&context.user1, U128(ntoy(10))).await?;
    context.unstake(&context.user2, U128(ntoy(5))).await?;
    context.unstake(&context.user3, U128(ntoy(2))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(15)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(15)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(10)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(2)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );

    context.worker.fast_forward(ONE_EPOCH).await?;
    let current_epoch_2 = context.get_current_epoch().await?;

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(15)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(15)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(4333333333333333333333334));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(6333333333333333333333332));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(10666666666666666666666668));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(4333333333333333333333334));
    assert_eq!(stake_pool_2_amount, U128(10666666666666666666666666));
    assert_eq!(stake_pool_3_amount, U128(0));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(
        stake_pool_1_unstaked_amount,
        U128(6333333333333333333333332)
    );
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(
        stake_pool_3_unstaked_amount,
        U128(10666666666666666666666668)
    );

    context.worker.fast_forward(ONE_EPOCH * 5).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    let balance_before_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    context.run_epoch_methods().await?;
    let balance_after_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;

    assert!(abs_diff_eq(
        (balance_after_withdraw - balance_before_withdraw),
        ntoy(17),
        ntoy(1)
    ));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(4333333333333333333333334));
    assert_eq!(validator2_info.staked, U128(10666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user1_balance_after_withdraw - user1_balance_before_withdraw,
        ntoy(10),
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user2_balance_after_withdraw - user2_balance_before_withdraw,
        ntoy(5),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context.user3.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context.user3.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user3_balance_after_withdraw - user3_balance_before_withdraw,
        ntoy(2),
        ntoy(1)
    ));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.unstaked_balance, U128(0));
    assert_eq!(user2_account.unstaked_balance, U128(0));
    assert_eq!(user3_account.unstaked_balance, U128(0));

    Ok(())
}

#[tokio::test]
async fn test_user_deposit_unstake_autcompounding_withdraw_with_grouped_epoch() -> anyhow::Result<()>
{
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;
    println!("current_epoch_1 is {:?}", current_epoch_1);

    // user 1 deposits 10N
    println!("user1_depositing 10N");
    context.deposit(&context.user1, ntoy(10)).await?;
    // user 2 deposits 5N
    println!("user2 depositing 5N");
    context.deposit(&context.user2, ntoy(5)).await?;
    // user 1 unstakes 5N
    println!("User 1 unstake 5N");
    context.unstake(&context.user1, U128(ntoy(5))).await?;
    // user 3 deposits 2N
    println!("User 3 depositing 2N");
    context.deposit(&context.user3, ntoy(2)).await?;
    // User 2 unstakes 1N
    println!("user 1 unstake 1N");
    context.unstake(&context.user2, U128(ntoy(1))).await?;

    // User 1 transfers 4N to user 3
    println!("User 1 transfers 4N to user 3");
    context
        .ft_transfer(&context.user1, &context.user3, ntoy(4).to_string())
        .await?;

    // User 3 unstakes 4N
    println!("User 3 unstakes 4N");
    context.unstake(&context.user3, U128(ntoy(4))).await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(22)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(22)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(17)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(10)));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(1)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(1)),
            staked_balance: U128(ntoy(4)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(4)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    // Run user epoch
    println!("Running epoch methods!");
    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(7333333333333333333333333));
    assert_eq!(validator2_info.staked, U128(7333333333333333333333333));
    assert_eq!(validator3_info.staked, U128(7333333333333333333333334));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(7333333333333333333333333));
    assert_eq!(stake_pool_2_amount, U128(7333333333333333333333333));
    assert_eq!(stake_pool_3_amount, U128(7333333333333333333333334));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    // Move one epoch
    context.worker.fast_forward(ONE_EPOCH).await?;
    let current_epoch_2 = context.get_current_epoch().await?;
    println!("current_epoch_2 is {:?}", current_epoch_2);

    context
        .add_stake_pool_rewards(U128(ntoy(11)), &context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(10)), &context.get_stake_pool_contract(1))
        .await?;

    println!("user1 depositing");
    context.deposit(&context.user2, ntoy(5)).await?;
    println!("user1 deposited");
    println!("user 1 unstaking ");
    context.unstake(&context.user2, U128(ntoy(6))).await?;
    println!("user1 unstaked");

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(21)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(21)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(6)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(5)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(1)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(7)),
            staked_balance: U128(ntoy(3)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(4)),
            staked_balance: U128(ntoy(2)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(42)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(21)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(17333333333333333333333333));
    assert_eq!(validator2_info.staked, U128(17333333333333333333333333));
    assert_eq!(validator3_info.staked, U128(7333333333333333333333334));
    assert_eq!(validator1_info.unstaked, U128(ntoy(1)));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_2);

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_amount, U128(17333333333333333333333333));
    assert_eq!(stake_pool_2_amount, U128(17333333333333333333333333));
    assert_eq!(stake_pool_3_amount, U128(7333333333333333333333334));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(1)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    context.worker.fast_forward(ONE_EPOCH).await?;
    let current_epoch_3 = context.get_current_epoch().await?;

    // user 1 deposits 10N
    context.deposit(&context.user1, ntoy(10)).await?;
    // user 2 deposits 5N
    context.deposit(&context.user2, ntoy(5)).await?;
    // user 3 deposits 2N
    context.deposit(&context.user3, ntoy(3)).await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(60)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(18)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    let owner_account = context
        .get_user_account(context.nearx_owner.id().clone())
        .await?;
    println!("owner_account is {:?}", owner_account);
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(12)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(7)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(4)),
            staked_balance: U128(ntoy(7)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    context.run_epoch_methods().await?;
    // while context.epoch_unstake().await?.json::<bool>().unwrap() {};

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(60)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(20000000000000000000000000));
    assert_eq!(validator2_info.staked, U128(20000000000000000000000000));
    assert_eq!(validator3_info.staked, U128(20000000000000000000000000));
    assert_eq!(validator1_info.unstaked, U128(ntoy(1)));
    assert_eq!(validator2_info.unstaked, U128(0));
    assert_eq!(validator3_info.unstaked, U128(0));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_2);

    let stake_pool_1_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_amount = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    println!("stake pool 1 staked amount {:?}", stake_pool_1_amount);
    println!("stake pool 2 staked amount {:?}", stake_pool_2_amount);
    println!("stake pool 3 staked amount {:?}", stake_pool_3_amount);

    assert_eq!(stake_pool_1_amount, U128(20000000000000000000000000));
    assert_eq!(stake_pool_2_amount, U128(20000000000000000000000000));
    assert_eq!(stake_pool_3_amount, U128(20000000000000000000000000));

    let stake_pool_1_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_amount = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    println!(
        "stake pool 1 unstaked amount {:?}",
        stake_pool_1_unstaked_amount
    );
    println!(
        "stake pool 2 unstaked amount {:?}",
        stake_pool_2_unstaked_amount
    );
    println!(
        "stake pool 3 unstaked amount {:?}",
        stake_pool_3_unstaked_amount
    );

    assert_eq!(stake_pool_1_unstaked_amount, U128(ntoy(1)));
    assert_eq!(stake_pool_2_unstaked_amount, U128(ntoy(0)));
    assert_eq!(stake_pool_3_unstaked_amount, U128(ntoy(0)));

    // Test withdraw after 3 epochs
    context.worker.fast_forward(ONE_EPOCH * 10).await?;
    let current_epoch_4 = context.get_current_epoch().await?;
    println!("current_epoch_4 is {:?}", current_epoch_4);

    let balance_before_withdraw = context.nearx_contract.view_account(&context.worker).await?;
    println!(
        "balance_before_withdraw {:?}",
        balance_before_withdraw.balance
    );
    context.run_epoch_methods().await?;
    let balance_after_withdraw = context.nearx_contract.view_account(&context.worker).await?;
    println!(
        "balance_after_withdraw {:?}",
        balance_after_withdraw.balance
    );

    assert!(abs_diff_eq(
        (balance_after_withdraw.balance - balance_before_withdraw.balance),
        ntoy(1),
        900000000000000000000000
    ));

    Ok(())
}

/// Fuzzy integration tests
#[tokio::test]
async fn test_validator_balance_sync() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    println!(
        "stake_pool_1_staked_balance after init is {:?}",
        stake_pool_1_staked_balance
    );

    let current_epoch_1 = context.get_current_epoch().await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.staking_epoch().await?;

    context
        .adjust_balance(context.get_stake_pool_contract(0).id(), U128(50), U128(50))
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    println!(
        "stake_pool_1_staked_balance is {:?}",
        stake_pool_1_staked_balance
    );
    let stake_pool_1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    println!(
        "stake_pool_1_unstaked_balance is {:?}",
        stake_pool_1_unstaked_balance
    );
    println!("validator staked is {:?}", validator1_info.staked);
    assert!(abs_diff_eq(
        validator1_info.staked.0,
        stake_pool_1_staked_balance.0,
        50
    ));

    context.worker.fast_forward(1000).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    context.unstake(&context.user1, U128(ntoy(3))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(7)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(42)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(42)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(3)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    context.unstaking_epoch().await?;

    context
        .adjust_balance(context.get_stake_pool_contract(0).id(), U128(50), U128(50))
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;

    let stake_pool_1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    assert!(abs_diff_eq(
        validator1_info.unstaked.0,
        stake_pool_1_unstaked_balance.0,
        10
    ));

    context
        .sync_validator_balances(context.get_stake_pool_contract(0).id().clone())
        .await?;

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;

    let stake_pool_1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, stake_pool_1_staked_balance);
    assert_eq!(validator1_info.unstaked, stake_pool_1_unstaked_balance);

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(42)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(42)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    Ok(())
}

#[tokio::test]
async fn test_validator_removal() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // Add deposits to validator 1
    let current_epoch_1 = context.get_current_epoch().await?;

    // Fill up all validators
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_1_staked_balance, U128(ntoy(15)));
    assert_eq!(stake_pool_2_staked_balance, U128(ntoy(15)));
    assert_eq!(stake_pool_3_staked_balance, U128(ntoy(15)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    context.worker.fast_forward(ONE_EPOCH * 10).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    // Pause validator 1
    context
        .pause_validator(&context.get_stake_pool_contract(0).id())
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.weight, 0);

    // drain unstake from validator 1
    println!("Calling drain unstake");
    context
        .drain_unstake(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(ntoy(15)));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_2);

    let stake_pool1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    assert_eq!(stake_pool1_unstaked_balance, U128(ntoy(15)));

    context.worker.fast_forward(ONE_EPOCH * 10).await?;

    // normal withdraw
    println!("epoch_withdraw");
    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(ntoy(15)));

    // drain withdraw from validator 1
    let contract_balance_before_drain_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    println!("Calling drain withdraw");
    let res = context
        .drain_withdraw(context.get_stake_pool_contract(0).id().clone())
        .await?;
    println!("logs are {:?}", res.failures());
    // println!("res is {:?}", res);
    let contract_balance_after_drain_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;

    assert!(abs_diff_eq(
        contract_balance_after_drain_withdraw - contract_balance_before_drain_withdraw,
        ntoy(15),
        ntoy(1)
    ));

    let stake_pool1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    assert_eq!(stake_pool1_unstaked_balance, U128(ntoy(0)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(0));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_2);
    assert_eq!(validator1_info.weight, 0);

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(15)));

    // remove validator 1 from set
    let all_validators = context.get_validators().await?;
    assert_eq!(all_validators.len(), 3);
    println!("Calling remove_validator");
    let res = context
        .remove_validator(&context.get_stake_pool_contract(0).id())
        .await?;
    println!("res logs are {:?}", res.logs());
    let all_validators = context.get_validators().await?;
    assert_eq!(all_validators.len(), 2);

    Ok(())
}

#[tokio::test]
async fn test_user_stake_autocompound_unstake_withdraw_flows_all_validators_involved(
) -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    // Fill up all validators
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(10)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_1_staked_balance, U128(ntoy(15)));
    assert_eq!(stake_pool_2_staked_balance, U128(ntoy(15)));
    assert_eq!(stake_pool_3_staked_balance, U128(ntoy(15)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    context.worker.fast_forward(1000).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(user1_account.staked_balance, U128(ntoy(20)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(20)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(20)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(75)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(75)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(25)));
    assert_eq!(validator2_info.staked, U128(ntoy(25)));
    assert_eq!(validator3_info.staked, U128(ntoy(25)));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_1_staked_balance, U128(ntoy(25)));
    assert_eq!(stake_pool_2_staked_balance, U128(ntoy(25)));
    assert_eq!(stake_pool_3_staked_balance, U128(ntoy(25)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(75)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(75)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    context.worker.fast_forward(1000).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(30)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(30)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(30)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(105)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(105)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(35)));
    assert_eq!(validator2_info.staked, U128(ntoy(35)));
    assert_eq!(validator3_info.staked, U128(ntoy(35)));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_1_staked_balance, U128(ntoy(35)));
    assert_eq!(stake_pool_2_staked_balance, U128(ntoy(35)));
    assert_eq!(stake_pool_3_staked_balance, U128(ntoy(35)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(105)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(105)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);

    context.worker.fast_forward(1000).await?;

    let current_epoch_4 = context.get_current_epoch().await?;

    // Now we need to unstake enough to cross all validators
    context.unstake(&context.user1, U128(ntoy(25))).await?;
    context.unstake(&context.user2, U128(ntoy(25))).await?;
    context.unstake(&context.user3, U128(ntoy(25))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user1_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user2_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user3_account.staked_balance, U128(ntoy(5)));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(user3_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(user3_account.unstaked_balance, U128(ntoy(25)));
    assert_eq!(
        user1_account.withdrawable_epoch,
        U64(current_epoch_4.0 + NUM_EPOCHS_TO_UNLOCK)
    );
    assert_eq!(
        user2_account.withdrawable_epoch,
        U64(current_epoch_4.0 + NUM_EPOCHS_TO_UNLOCK)
    );
    assert_eq!(
        user3_account.withdrawable_epoch,
        U64(current_epoch_4.0 + NUM_EPOCHS_TO_UNLOCK)
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(30)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(75)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);

    context.unstaking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(30)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(40)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_4);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(ntoy(35)));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_4);
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    assert_eq!(validator2_info.staked, U128(ntoy(35)));
    assert_eq!(validator2_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator2_info.last_unstake_start_epoch, U64(0));
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator3_info.staked, U128(ntoy(35)));
    assert_eq!(validator3_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator3_info.last_unstake_start_epoch, U64(0));

    context.unstaking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(30)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(5)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_4);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(ntoy(35)));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_4);
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    assert_eq!(validator2_info.staked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(ntoy(35)));
    assert_eq!(validator2_info.last_unstake_start_epoch, current_epoch_4);
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator3_info.staked, U128(ntoy(35)));
    assert_eq!(validator3_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator3_info.last_unstake_start_epoch, U64(0));

    context.unstaking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(30)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_4);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(0));
    assert_eq!(validator1_info.unstaked, U128(ntoy(35)));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch_4);
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    assert_eq!(validator2_info.staked, U128(0));
    assert_eq!(validator2_info.unstaked, U128(ntoy(35)));
    assert_eq!(validator2_info.last_unstake_start_epoch, current_epoch_4);
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator3_info.staked, U128(ntoy(30)));
    assert_eq!(validator3_info.unstaked, U128(ntoy(5)));
    assert_eq!(validator3_info.last_unstake_start_epoch, current_epoch_4);

    assert_eq!(
        context
            .is_validator_unstake_pending(context.get_stake_pool_contract(0).id().clone())
            .await?,
        true
    );
    assert_eq!(
        context
            .is_validator_unstake_pending(context.get_stake_pool_contract(1).id().clone())
            .await?,
        true
    );
    assert_eq!(
        context
            .is_validator_unstake_pending(context.get_stake_pool_contract(2).id().clone())
            .await?,
        true
    );

    // Now user 3 unstakes remaining amount. The unstake epoch wait time should be twice since all validators are in stake
    context.unstake(&context.user3, U128(ntoy(3))).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(user3_account.staked_balance, U128(ntoy(2)));
    assert_eq!(user3_account.unstaked_balance, U128(ntoy(28)));
    assert_eq!(
        user3_account.withdrawable_epoch,
        U64(current_epoch_4.0 + 2 * NUM_EPOCHS_TO_UNLOCK + 1)
    );

    context.worker.fast_forward(10000).await?;

    let contract_before_withdraw_from_val1 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    context
        .withdraw_epoch(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let contract_after_withdraw_from_val1 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    assert!(abs_diff_eq(
        contract_after_withdraw_from_val1 - contract_before_withdraw_from_val1,
        ntoy(35),
        ntoy(1)
    ));

    let contract_before_withdraw_from_val2 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    context
        .withdraw_epoch(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let contract_after_withdraw_from_val2 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    assert!(abs_diff_eq(
        contract_after_withdraw_from_val2 - contract_before_withdraw_from_val2,
        ntoy(35),
        ntoy(1)
    ));

    let contract_before_withdraw_from_val3 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    context
        .withdraw_epoch(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let contract_after_withdraw_from_val3 = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    assert!(abs_diff_eq(
        contract_after_withdraw_from_val3 - contract_before_withdraw_from_val3,
        ntoy(5),
        ntoy(1)
    ));

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?.balance;
    let res = context.withdraw_all(&context.user1).await?;
    println!("res is {:?}", res);
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?.balance;
    assert!(abs_diff_eq(
        user1_balance_after_withdraw - user1_balance_before_withdraw,
        ntoy(25),
        ntoy(1)
    ));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.unstaked_balance, U128(0));

    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?.balance;
    assert!(abs_diff_eq(
        user2_balance_after_withdraw - user2_balance_before_withdraw,
        ntoy(25),
        ntoy(1)
    ));

    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    assert_eq!(user2_account.unstaked_balance, U128(0));

    Ok(())
}

#[tokio::test]
async fn test_user_stake_autocompound_unstake_withdraw_flows_across_epochs() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // User 1 stakes
    context.deposit(&context.user1, ntoy(10)).await?;
    // User 2 stakes
    context.deposit(&context.user2, ntoy(10)).await?;
    // User 1 unstakes 5N
    context.unstake(&context.user1, U128(ntoy(5))).await?;
    // User 3 stakes
    context.deposit(&context.user3, ntoy(10)).await?;
    // User 2 unstakes 5N
    context.unstake(&context.user2, U128(ntoy(5))).await?;
    // User 3 unstakes 5N
    context.unstake(&context.user3, U128(ntoy(5))).await?;
    // User 1 stakes
    context.deposit(&context.user1, ntoy(10)).await?;
    // User 2 stakes
    context.deposit(&context.user2, ntoy(10)).await?;
    // User 3 stakes
    context.deposit(&context.user3, ntoy(10)).await?;
    // User 2 unstakes 4N
    context.unstake(&context.user3, U128(ntoy(4))).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(15)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(15)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(9)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;
    assert_eq!(user1_token_balance, U128(ntoy(15)));
    assert_eq!(user2_token_balance, U128(ntoy(15)));
    assert_eq!(user3_token_balance, U128(ntoy(11)));

    let total_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_supply, U128(ntoy(56)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(56)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(56)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(60)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(19)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: validator1_info.account_id.clone(),
            staked: U128(ntoy(5)),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: validator2_info.account_id.clone(),
            staked: U128(ntoy(5)),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: validator3_info.account_id.clone(),
            staked: U128(ntoy(5)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    // epoch stake
    while context.staking_epoch().await?.json::<bool>().unwrap() {}

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(18666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(18666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(18666666666666666666666668));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(
        stake_pool_1_staked_balance,
        U128(18666666666666666666666666)
    );
    assert_eq!(
        stake_pool_2_staked_balance,
        U128(18666666666666666666666666)
    );
    assert_eq!(
        stake_pool_3_staked_balance,
        U128(18666666666666666666666668)
    );

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(ntoy(1)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(56)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(56)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));

    // User 1 stakes
    context.deposit(&context.user1, ntoy(10)).await?;
    // User 2 stakes
    context.deposit(&context.user2, ntoy(10)).await?;
    // User 3 stakes
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(25)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(25)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(9)),
            staked_balance: U128(ntoy(21)),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    // epoch autocompound add 20N rewards
    context
        .add_stake_pool_rewards(U128(ntoy(20)), context.get_stake_pool_contract(0))
        .await?;

    context
        .autocompounding_epoch(context.get_stake_pool_contract(0).id())
        .await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    assert_eq!(validator1_info.staked, U128(38666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(18666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(18666666666666666666666668));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(
        stake_pool_1_staked_balance,
        U128(38666666666666666666666666)
    );
    assert_eq!(
        stake_pool_2_staked_balance,
        U128(18666666666666666666666666)
    );
    assert_eq!(
        stake_pool_3_staked_balance,
        U128(18666666666666666666666668)
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(106)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(86)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(20)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1232558139534883720930232));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(30813953488372093023255813),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(30813953488372093023255813),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(ntoy(9)),
            staked_balance: U128(25883720930232558139534883),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    // User 3 unstakes 10N
    context.unstake(&context.user3, U128(ntoy(5))).await?;

    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user3_account is {:?}", user3_account);
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(14000000000000000000000001),
            staked_balance: U128(20883720930232558139534883),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(100999999999999999999999999));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(81943396226415094339622641)
    );
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(20)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(5000000000000000000000001)
    );
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(ntoy(0)));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1232558139534883720930232));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(validator1_info.staked, U128(38666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(18666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(18666666666666666666666668));
    assert_eq!(validator1_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator2_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator3_info.unstaked, U128(ntoy(0)));

    // epoch unstake
    while context.unstaking_epoch().await?.json::<bool>().unwrap() {}

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(100999999999999999999999999));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(81943396226415094339622641)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(5000000000000000000000001)
    );
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    let stake_pool_1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_1_unstaked_balance, U128(0));
    assert_eq!(stake_pool_2_unstaked_balance, U128(0));
    assert_eq!(stake_pool_3_unstaked_balance, U128(0));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(
        stake_pool_1_staked_balance,
        U128(38666666666666666666666666)
    );
    assert_eq!(
        stake_pool_2_staked_balance,
        U128(18666666666666666666666666)
    );
    assert_eq!(
        stake_pool_3_staked_balance,
        U128(18666666666666666666666668)
    );

    // fast forward by 1000
    context.worker.fast_forward(1000).await?;
    let current_epoch_2 = context.get_current_epoch().await?;

    // epoch stake
    while context.staking_epoch().await?.json::<bool>().unwrap() {}

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!(
        "stake_pool_1_staked_balance {:?}",
        stake_pool_1_staked_balance
    );
    println!(
        "stake_pool_2_staked_balance {:?}",
        stake_pool_2_staked_balance
    );
    println!(
        "stake_pool_3_staked_balance {:?}",
        stake_pool_3_staked_balance
    );

    assert_eq!(
        stake_pool_1_staked_balance,
        U128(38666666666666666666666666)
    );
    assert_eq!(
        stake_pool_2_staked_balance,
        U128(33666666666666666666666666)
    );
    assert_eq!(
        stake_pool_3_staked_balance,
        U128(28666666666666666666666667)
    );

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(100999999999999999999999999));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(81943396226415094339622641)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1232558139534883720930232));

    // epoch autocompound add 10N rewards
    context
        .add_stake_pool_rewards(U128(ntoy(5)), context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(5)), context.get_stake_pool_contract(1))
        .await?;

    context
        .autocompounding_epoch(context.get_stake_pool_contract(0).id())
        .await?;
    context
        .autocompounding_epoch(context.get_stake_pool_contract(1).id())
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(110999999999999999999999999));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(81943396226415094339622641)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(30)));

    let stake_pool_1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_2_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_3_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!(
        "stake_pool_1_staked_balance {:?}",
        stake_pool_1_staked_balance
    );
    println!(
        "stake_pool_2_staked_balance {:?}",
        stake_pool_2_staked_balance
    );
    println!(
        "stake_pool_3_staked_balance {:?}",
        stake_pool_3_staked_balance
    );

    assert_eq!(
        stake_pool_1_staked_balance,
        U128(43666666666666666666666666)
    );
    assert_eq!(
        stake_pool_2_staked_balance,
        U128(38666666666666666666666666)
    );
    assert_eq!(
        stake_pool_3_staked_balance,
        U128(28666666666666666666666667)
    );

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(43666666666666666666666666));
    assert_eq!(validator2_info.staked, U128(38666666666666666666666666));
    assert_eq!(validator3_info.staked, U128(28666666666666666666666667));
    assert_eq!(validator1_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator2_info.unstaked, U128(ntoy(0)));
    assert_eq!(validator3_info.unstaked, U128(ntoy(0)));

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1354593598894773198250057));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;
    println!("user1_token_balance is {:?}", user1_token_balance);
    println!("user2_token_balance is {:?}", user2_token_balance);
    println!("user3_token_balance is {:?}", user3_token_balance);

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);
    println!("Checked user accounts");

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(33864839972369329956251439),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(33864839972369329956251439),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(14000000000000000000000001),
            staked_balance: U128(22951416071839742113746257),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );

    // epoch unstake
    while context.unstaking_epoch().await?.json::<bool>().unwrap() {}

    // epoch withdraw
    context.worker.fast_forward(10000).await?;
    let current_epoch_3 = context.get_current_epoch().await?;
    println!("current_epoch_3 is {:?}", current_epoch_3);

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    if validator1_info.unstaked.0 != 0 {
        context
            .withdraw_epoch(context.get_stake_pool_contract(0).id().clone())
            .await?;
    }
    if validator2_info.unstaked.0 != 0 {
        context
            .withdraw_epoch(context.get_stake_pool_contract(1).id().clone())
            .await?;
    }
    if validator3_info.unstaked.0 != 0 {
        context
            .withdraw_epoch(context.get_stake_pool_contract(2).id().clone())
            .await?;
    }

    // user 1 unstakes 1N
    context.unstake(&context.user1, U128(ntoy(1))).await?;

    // user 2 withdraws
    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?.balance;
    assert!(abs_diff_eq(
        user2_balance_after_withdraw - user2_balance_before_withdraw,
        ntoy(5),
        ntoy(1)
    ));

    // user 3 withdraws
    let user3_balance_before_withdraw = context.user3.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context.user3.view_account(&context.worker).await?.balance;
    println!(
        "user3_balance_before_withdraw is {}",
        user3_balance_before_withdraw
    );
    println!(
        "user3_balance_after_withdraw is {}",
        user3_balance_after_withdraw
    );
    assert!(abs_diff_eq(
        user3_balance_after_withdraw - user3_balance_before_withdraw,
        ntoy(14),
        ntoy(1)
    ));

    // User 3 unstakes 5N
    context.unstake(&context.user3, U128(ntoy(5))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);
    println!("Checked user accounts");

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(6000000000000000000000001),
            staked_balance: U128(32864839972369329956251438),
            withdrawable_epoch: U64(current_epoch_3.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(33864839972369329956251438),
            withdrawable_epoch: U64(current_epoch_1.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(17951416071839742113746256),
            withdrawable_epoch: U64(current_epoch_3.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    Ok(())
}

/// Happy flows of testing
#[tokio::test]
async fn test_user_stake_unstake_withdraw_flows_in_same_epoch_2() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // User 1 deposits 10N
    context.deposit(&context.user1, ntoy(10)).await?;
    // User 2 deposits 10N
    context.deposit(&context.user2, ntoy(10)).await?;

    // User 1 unstakes 3 N
    context.unstake(&context.user1, U128(ntoy(3))).await?;
    // User 3 deposits 10N
    context.deposit(&context.user3, ntoy(10)).await?;

    // User 3 unstakes 5N
    context.unstake(&context.user3, U128(ntoy(5))).await?;
    // User 1 deposits 10N
    context.deposit(&context.user1, ntoy(10)).await?;
    // User 2 deposits 10N
    context.deposit(&context.user2, ntoy(10)).await?;
    // User 2 unstakes 10N
    context.unstake(&context.user2, U128(ntoy(10))).await?;
    // User 1 unstaked 10N
    context.unstake(&context.user1, U128(ntoy(10))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    let nearx_state = context.get_nearx_state().await?;
    println!(
        "reconcilation epoch is {:?}",
        nearx_state.last_reconcilation_epoch
    );
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));
    assert_eq!(nearx_state.total_staked, U128(ntoy(37)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(37)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(28)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let current_epoch = context.get_current_epoch().await?;
    println!("current epoch is {:?}", current_epoch);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(13)),
            staked_balance: U128(ntoy(7)),
            withdrawable_epoch: user1_account.withdrawable_epoch
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(10)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: user2_account.withdrawable_epoch
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: user3_account.withdrawable_epoch
        }
    );

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(7)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(5)));

    let total_token_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_token_supply, U128(ntoy(37)));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(5)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }
    );

    // now run epoch stake
    while context.staking_epoch().await?.json::<bool>().unwrap() {}

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(
        stake_pool_contract_balance_0,
        U128(12333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_1,
        U128(12333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_2,
        U128(12333333333333333333333334)
    );

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(12333333333333333333333333));
    assert_eq!(validator2_info.staked, U128(12333333333333333333333333));
    assert_eq!(validator3_info.staked, U128(12333333333333333333333334));

    // now we run unstake epoch
    while context.unstaking_epoch().await?.json::<bool>().unwrap() {}

    let last_unstake_epoch = context.get_current_epoch().await?;

    let stake_pool_contract_unstaked_balance_0 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_unstaked_balance_1 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_unstaked_balance_2 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_unstaked_balance_0, U128(ntoy(0)));
    assert_eq!(stake_pool_contract_unstaked_balance_1, U128(ntoy(0)));
    assert_eq!(stake_pool_contract_unstaked_balance_2, U128(ntoy(0)));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!("Stake pool balances after unstake");
    println!(
        "stake_pool_contract_balance_0 is {:?}",
        stake_pool_contract_balance_0
    );
    println!(
        "stake_pool_contract_balance_1 is {:?}",
        stake_pool_contract_balance_1
    );
    println!(
        "stake_pool_contract_balance_2 is {:?}",
        stake_pool_contract_balance_2
    );

    assert_eq!(
        stake_pool_contract_balance_0,
        U128(12333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_1,
        U128(12333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_2,
        U128(12333333333333333333333334)
    );

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("Validator accounts after unstake");
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(12333333333333333333333333),
            unstaked: U128(ntoy(0)),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(12333333333333333333333333),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(12333333333333333333333334),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(5000).await?;

    println!(
        "epoch_withdraw for val 0 {:?}",
        context.get_stake_pool_contract(0).id()
    );

    if validator1_info.unstaked.0 != 0 {
        context
            .withdraw_epoch(context.get_stake_pool_contract(0).id().clone())
            .await?;
        println!("epoch_withdraw for val 1");
    }

    if validator2_info.unstaked.0 != 0 {
        context
            .withdraw_epoch(context.get_stake_pool_contract(1).id().clone())
            .await?;
    }

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user1_balance_after_withdraw - user1_balance_before_withdraw,
        ntoy(13),
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user2_balance_after_withdraw - user2_balance_before_withdraw,
        ntoy(10),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context.user3.view_account(&context.worker).await?.balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context.user3.view_account(&context.worker).await?.balance;

    assert!(abs_diff_eq(
        user3_balance_after_withdraw - user3_balance_before_withdraw,
        ntoy(5),
        ntoy(1)
    ));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    println!("User accounts after withdrawal");
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(7)),
            withdrawable_epoch: user1_account.withdrawable_epoch
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: user2_account.withdrawable_epoch
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: user3_account.withdrawable_epoch
        }
    );

    context.worker.fast_forward(1000).await?;

    // Now user does batched staking
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: user1_account.account_id.clone(),
            unstaked_balance: U128(0),
            staked_balance: U128(ntoy(17)),
            withdrawable_epoch: user1_account.withdrawable_epoch
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: user2_account.account_id.clone(),
            unstaked_balance: U128(0),
            staked_balance: U128(ntoy(20)),
            withdrawable_epoch: user2_account.withdrawable_epoch
        }
    );

    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: user3_account.account_id.clone(),
            unstaked_balance: U128(0),
            staked_balance: U128(ntoy(15)),
            withdrawable_epoch: user3_account.withdrawable_epoch
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    println!(
        "reconcilation epoch is {:?}",
        nearx_state.last_reconcilation_epoch
    );
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch);
    assert_eq!(nearx_state.total_staked, U128(ntoy(67)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(67)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    while context.staking_epoch().await?.json::<bool>().unwrap() {}

    let nearx_state = context.get_nearx_state().await?;
    println!(
        "reconcilation epoch is {:?}",
        nearx_state.last_reconcilation_epoch
    );
    let current_epoch = context.get_current_epoch().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch);
    assert_eq!(nearx_state.total_staked, U128(ntoy(67)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(67)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    println!("Stake pool balances after unstake");
    println!(
        "stake_pool_contract_balance_0 is {:?}",
        stake_pool_contract_balance_0
    );
    println!(
        "stake_pool_contract_balance_1 is {:?}",
        stake_pool_contract_balance_1
    );
    println!(
        "stake_pool_contract_balance_2 is {:?}",
        stake_pool_contract_balance_2
    );

    assert_eq!(
        stake_pool_contract_balance_0,
        U128(22333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_1,
        U128(22333333333333333333333333)
    );
    assert_eq!(
        stake_pool_contract_balance_2,
        U128(22333333333333333333333334)
    );

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("Validator accounts after unstake");
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);

    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(22333333333333333333333333),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(22333333333333333333333333),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(22333333333333333333333334),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    Ok(())
}

#[tokio::test]
async fn test_stake_unstake_and_withdraw_flow_with_reward_boost() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(2 * ONE_EPOCH).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    // boost rewards
    context
        .update_rewards_buffer(4500000000000000000000000)
        .await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);
    assert_eq!(nearx_state.total_staked, U128(49500000000000000000000000));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(4500000000000000000000000));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(4500000000000000000000000)
    );

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(1100000000000000000000000));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );

    // User unstake

    context.unstake(&context.user1, U128(ntoy(5))).await?;
    context.unstake(&context.user2, U128(ntoy(5))).await?;
    context.unstake(&context.user3, U128(ntoy(5))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(5999999999999999999999999),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(5999999999999999999999999),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(5999999999999999999999999),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);
    assert_eq!(nearx_state.total_staked, U128(34499999999999999999999997));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(31363636363636363636363635)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(15000000000000000000000003)
    );
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(4500000000000000000000000));

    // Run this to check the reconcilation given the rewards buffer
    context.staking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);
    assert_eq!(nearx_state.total_staked, U128(34499999999999999999999997));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(31363636363636363636363635)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(
        nearx_state.reconciled_epoch_unstake_amount,
        U128(10500000000000000000000003)
    );
    assert_eq!(nearx_state.rewards_buffer, U128(0));

    context.unstaking_epoch().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(4499999999999999999999997),
            unstaked: U128(10500000000000000000000003),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: current_epoch_2,
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(6 * ONE_EPOCH).await?;

    let current_epoch_3 = context.get_current_epoch().await?;

    let contract_balance_before_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id())
        .await?
        .balance;
    context.run_epoch_methods().await?;
    let contract_balance_after_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (contract_balance_after_withdraw - contract_balance_before_withdraw),
        10500000000000000000000003,
        ntoy(1)
    ));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(4499999999999999999999997),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_3,
            last_unstake_start_epoch: current_epoch_2,
            weight: 10
        }
    );

    context
        .update_rewards_buffer(3450000000000002503999491)
        .await?;

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(1210000000000000079837664));

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);
    assert_eq!(nearx_state.total_staked, U128(37950000000000002503999488));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(31363636363636363636363635)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(3450000000000002503999491));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(7950000000000002503999491)
    );

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    println!("user2_account is {:?}", user2_account);
    println!("user3_account is {:?}", user3_account);

    let owner_account = context
        .get_user_account(context.nearx_owner.id().clone())
        .await?;
    println!("owner_account is {:?}", owner_account);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(6600000000000000435478171),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(6600000000000000435478171),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(5000000000000000000000001),
            staked_balance: U128(6600000000000000435478171),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    context.unstake(&context.user1, U128(ntoy(1))).await?;
    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    println!("user1_account is {:?}", user1_account);
    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(6000000000000000000000002),
            staked_balance: U128(5600000000000000435478170),
            withdrawable_epoch: U64(current_epoch_3.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);
    assert_eq!(nearx_state.total_staked, U128(36950000000000002503999487));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(30537190082644628153703751)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(1000000000000000000000001)
    );
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(3450000000000002503999491));

    context.staking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_3);
    assert_eq!(nearx_state.total_staked, U128(36950000000000002503999487));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(30537190082644628153703751)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(
        nearx_state.user_amount_to_unstake_in_epoch,
        U128(1000000000000000000000001)
    );
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(3450000000000002503999491));

    context.worker.fast_forward(2 * ONE_EPOCH).await?;

    let current_epoch_4 = context.get_current_epoch().await?;

    context.staking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_4);
    assert_eq!(nearx_state.total_staked, U128(36950000000000002503999487));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(30537190082644628153703751)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(2450000000000002503999490));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(7950000000000002503999491)
    );

    context.unstaking_epoch().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(4499999999999999999999997),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_3,
            last_unstake_start_epoch: current_epoch_2,
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_3,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(15)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_3,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(6 * ONE_EPOCH).await?;

    let current_epoch_5 = context.get_current_epoch().await?;

    context.run_epoch_methods().await?;

    let user1_balance_before_withdraw = context
        .worker
        .view_account(&context.user1.id().clone())
        .await?
        .balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context
        .worker
        .view_account(&context.user1.id().clone())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user1_balance_after_withdraw - user1_balance_before_withdraw),
        6000000000000000000000002,
        ntoy(1)
    ));

    context.worker.fast_forward(3 * ONE_EPOCH).await?;

    let current_epoch_6 = context.get_current_epoch().await?;

    // Add staking rewards
    context
        .add_stake_pool_rewards(U128(ntoy(2)), context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(2)), context.get_stake_pool_contract(1))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(2)), context.get_stake_pool_contract(2))
        .await?;

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_6);
    assert_eq!(nearx_state.total_staked, U128(42950000000000002503999487));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(30537190082644628153703751)
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(2450000000000002503999490));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(7950000000000002503999491)
    );

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx_price is {:?}", nearx_price);

    assert_eq!(nearx_price, U128(1406481732070365438079500));

    Ok(())
}

#[tokio::test]
async fn test_bank_run_with_boosted_apr() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.deposit(&context.user3, ntoy(10)).await?;

    context
        .update_rewards_buffer(4500000000000000000000000)
        .await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(11)),
            withdrawable_epoch: U64(0)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));
    assert_eq!(nearx_state.total_staked, U128(49500000000000000000000000));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(4500000000000000000000000));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(4500000000000000000000000)
    );

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);
    assert_eq!(nearx_state.total_staked, U128(49500000000000000000000000));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(4500000000000000000000000));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(4500000000000000000000000)
    );

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(16500000000000000000000000),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(16500000000000000000000000),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(12000000000000000000000000),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_1,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    // unstake from all users

    context.worker.fast_forward(2 * ONE_EPOCH).await?;

    let current_epoch_2 = context.get_current_epoch().await?;

    context.unstake(&context.user1, U128(ntoy(11))).await?;
    context.unstake(&context.user2, U128(ntoy(11))).await?;
    context.unstake(&context.user3, U128(ntoy(11))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(11)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(11)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(11)),
            staked_balance: U128(ntoy(0)),
            withdrawable_epoch: U64(current_epoch_2.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);
    assert_eq!(nearx_state.total_staked, U128(16500000000000000000000000));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(15)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(33)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.rewards_buffer, U128(4500000000000000000000000));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(4500000000000000000000000)
    );

    context.staking_epoch().await?;

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_2);
    assert_eq!(nearx_state.total_staked, U128(16500000000000000000000000));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(15)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(
        nearx_state.reconciled_epoch_unstake_amount,
        U128(28500000000000000000000000)
    );
    assert_eq!(nearx_state.rewards_buffer, U128(0));
    assert_eq!(
        nearx_state.accumulated_rewards_buffer,
        U128(4500000000000000000000000)
    );

    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(0),
            unstaked: U128(16500000000000000000000000),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(current_epoch_2.0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(4500000000000000000000000),
            unstaked: U128(12000000000000000000000000),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(current_epoch_2.0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(12000000000000000000000000),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: current_epoch_2,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(7 * ONE_EPOCH).await?;

    let contract_balance_before_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id().clone())
        .await?
        .balance;
    context.run_epoch_methods().await?;
    let contract_balance_after_withdraw = context
        .worker
        .view_account(&context.nearx_contract.id().clone())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (contract_balance_after_withdraw - contract_balance_before_withdraw),
        28500000000000000000000000,
        ntoy(1)
    ));

    let user1_balance_before_withdraw = context
        .worker
        .view_account(&context.user1.id().clone())
        .await?
        .balance;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context
        .worker
        .view_account(&context.user1.id().clone())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user1_balance_after_withdraw - user1_balance_before_withdraw),
        ntoy(11),
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context
        .worker
        .view_account(&context.user2.id().clone())
        .await?
        .balance;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context
        .worker
        .view_account(&context.user2.id().clone())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user2_balance_after_withdraw - user2_balance_before_withdraw),
        ntoy(11),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context
        .worker
        .view_account(&context.user3.id().clone())
        .await?
        .balance;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context
        .worker
        .view_account(&context.user3.id().clone())
        .await?
        .balance;

    assert!(abs_diff_eq(
        (user3_balance_after_withdraw - user3_balance_before_withdraw),
        ntoy(11),
        ntoy(1)
    ));

    Ok(())
}

#[tokio::test]
async fn test_user_stake_unstake_withdraw_flows_in_same_epoch() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // User 1 deposit
    // User 2 deposit
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;

    // User 1 unstakes 3 N
    context.unstake(&context.user1, U128(ntoy(3))).await?;
    // User 3 deposits
    context.deposit(&context.user3, ntoy(10)).await?;

    // User 3 unstakes 5N
    context.unstake(&context.user3, U128(ntoy(5))).await?;
    // User 1 deposits again
    context.deposit(&context.user1, ntoy(10)).await?;
    context.deposit(&context.user2, ntoy(10)).await?;
    context.unstake(&context.user2, U128(ntoy(10))).await?;

    let current_epoch = context.get_current_epoch().await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(3)),
            staked_balance: U128(ntoy(17)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(10)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(17)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(5)));

    let total_token_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_token_supply, U128(ntoy(47)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));
    assert_eq!(nearx_state.total_staked, U128(ntoy(47)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(47)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(50)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(18)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;
    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(5)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(ntoy(5)),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    let current_epoch = context.get_current_epoch().await?;

    // Run stake epoch
    while context.staking_epoch().await?.json::<bool>().unwrap() {}

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch);
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator 1 info is {:?}", validator1_info);
    println!("validator 2 info is {:?}", validator2_info);
    println!("validator 3 info is {:?}", validator3_info);

    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666666),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666666),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666668),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(
        stake_pool_contract_balance_0,
        U128(15666666666666666666666666)
    );
    assert_eq!(
        stake_pool_contract_balance_1,
        U128(15666666666666666666666666)
    );
    assert_eq!(
        stake_pool_contract_balance_2,
        U128(15666666666666666666666668)
    );

    let stake_pool_contract_unstaked_balance_0 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_unstaked_balance_1 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_unstaked_balance_2 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_unstaked_balance_0, U128(0));
    assert_eq!(stake_pool_contract_unstaked_balance_1, U128(0));
    assert_eq!(stake_pool_contract_unstaked_balance_2, U128(0));

    // now we run unstake epoch
    while context.unstaking_epoch().await?.json::<bool>().unwrap() {}

    let stake_pool_contract_unstaked_balance_0 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_unstaked_balance_1 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_unstaked_balance_2 = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_unstaked_balance_0, U128(0));
    assert_eq!(stake_pool_contract_unstaked_balance_1, U128(0));
    assert_eq!(stake_pool_contract_unstaked_balance_2, U128(0));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(0)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666666),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(1)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666666),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: context
                .get_stake_pool_contract(2)
                .id()
                .clone()
                .parse()
                .unwrap(),
            staked: U128(15666666666666666666666668),
            unstaked: U128(ntoy(0)),
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    context.worker.fast_forward(5 * ONE_EPOCH).await?;

    let user1_balance_before_withdraw = context.user1.view_account(&context.worker).await?;
    context.withdraw_all(&context.user1).await?;
    let user1_balance_after_withdraw = context.user1.view_account(&context.worker).await?;

    assert!(abs_diff_eq(
        user1_balance_after_withdraw.balance - user1_balance_before_withdraw.balance,
        ntoy(3),
        ntoy(1)
    ));

    let user2_balance_before_withdraw = context.user2.view_account(&context.worker).await?;
    context.withdraw_all(&context.user2).await?;
    let user2_balance_after_withdraw = context.user2.view_account(&context.worker).await?;

    assert!(abs_diff_eq(
        user2_balance_after_withdraw.balance - user2_balance_before_withdraw.balance,
        ntoy(10),
        ntoy(1)
    ));

    let user3_balance_before_withdraw = context.user3.view_account(&context.worker).await?;
    context.withdraw_all(&context.user3).await?;
    let user3_balance_after_withdraw = context.user3.view_account(&context.worker).await?;

    assert!(abs_diff_eq(
        user3_balance_after_withdraw.balance - user3_balance_before_withdraw.balance,
        ntoy(5),
        ntoy(1)
    ));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(17)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK)
        }
    );

    Ok(())
}

// Tests: Deposit and stake with epoch
#[tokio::test]
async fn test_deposit_and_stake_with_epoch() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // Deposit for the 3 users
    // Add user deposits
    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount, U128(ntoy(10)));
    assert_eq!(user2_staked_amount, U128(ntoy(10)));
    assert_eq!(user3_staked_amount, U128(ntoy(10)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(10)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator2_info.staked, U128(ntoy(5)));
    assert_eq!(validator3_info.staked, U128(ntoy(5)));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(5)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));

    // Run epoch stake
    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;

    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(
        nearx_state.last_reconcilation_epoch,
        context.get_current_epoch().await?
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(15)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(15)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(15)));

    Ok(())
}

// Tests: Unstake with a withdraw following up
#[tokio::test]
async fn test_stake_unstake_and_withdraw_flow_happy_flow() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    // Deposit for the 3 users
    // Add user deposits
    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount, U128(ntoy(10)));
    assert_eq!(user2_staked_amount, U128(ntoy(10)));
    assert_eq!(user3_staked_amount, U128(ntoy(10)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(10)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator2_info.staked, U128(ntoy(5)));
    assert_eq!(validator3_info.staked, U128(ntoy(5)));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(5)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(5)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));

    // Run epoch stake
    context.run_epoch_methods().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(
        nearx_state.last_reconcilation_epoch,
        context.get_current_epoch().await?
    );
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));

    let stake_pool_contract_balance_0 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    let stake_pool_contract_balance_1 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(1))
        .await?;
    let stake_pool_contract_balance_2 = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(2))
        .await?;

    assert_eq!(stake_pool_contract_balance_0, U128(ntoy(15)));
    assert_eq!(stake_pool_contract_balance_1, U128(ntoy(15)));
    assert_eq!(stake_pool_contract_balance_2, U128(ntoy(15)));

    // User 1 and User 2 unstake 5 NEAR each
    context.unstake(&context.user1, U128(ntoy(5))).await?;
    context.unstake(&context.user2, U128(ntoy(5))).await?;

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    let current_epoch = context.get_current_epoch().await?;
    println!("current_epoch is {:?}", current_epoch);

    assert_eq!(
        user1_account,
        AccountResponse {
            account_id: context.user1.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );
    assert_eq!(
        user2_account,
        AccountResponse {
            account_id: context.user2.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(5)),
            staked_balance: U128(ntoy(5)),
            withdrawable_epoch: U64(current_epoch.0 + NUM_EPOCHS_TO_UNLOCK + 1)
        }
    );
    assert_eq!(
        user3_account,
        AccountResponse {
            account_id: context.user3.id().clone().parse().unwrap(),
            unstaked_balance: U128(ntoy(0)),
            staked_balance: U128(ntoy(10)),
            withdrawable_epoch: U64(0)
        }
    );

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(5)));
    assert_eq!(user2_token_balance, U128(ntoy(5)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let total_token_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_token_supply, U128(ntoy(35)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(10)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.total_staked, U128(ntoy(35)));

    context.worker.fast_forward(ONE_EPOCH * 2).await?;

    let validator_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    println!(
        "validator unstaked balance before unstake epoch is {:?}",
        validator_unstaked_balance
    );
    assert_eq!(validator_unstaked_balance, U128(ntoy(0)));

    // Run the unstake epoch
    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(35)));
    assert_eq!(nearx_state.total_staked, U128(ntoy(35)));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));

    let current_epoch = context.get_current_epoch().await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator1_info.unstaked, U128(ntoy(10)));
    assert_eq!(validator1_info.last_unstake_start_epoch, current_epoch);

    let validator1_staked_balance = context
        .get_stake_pool_total_staked_amount(context.get_stake_pool_contract(0))
        .await?;
    assert_eq!(validator1_staked_balance, U128(ntoy(5)));

    let validator1_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    let validator2_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(1))
        .await?;
    println!(
        "validator1 unstaked balance after unstake epoch is {:?}",
        validator1_unstaked_balance
    );
    assert_eq!(validator1_unstaked_balance, U128(ntoy(10)));

    // Run the withdraw epoch after 4 epochs to get the amount back
    // Check the contract balance before and after the withdraw call

    context.worker.fast_forward(5 * ONE_EPOCH).await?;

    let balance_before_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    println!("initial contract balance is {:?}", balance_before_withdraw);
    let res = context.run_epoch_methods().await?;
    let balance_after_withdraw = context
        .nearx_contract
        .view_account(&context.worker)
        .await?
        .balance;
    println!("balance after withdraw is {:?}", balance_after_withdraw);
    assert!(abs_diff_eq(
        balance_after_withdraw - balance_before_withdraw,
        ntoy(10),
        ntoy(1)
    ));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    assert_eq!(validator1_info.unstaked, U128(ntoy(0)));

    let validator_unstaked_balance = context
        .get_stake_pool_total_unstaked_amount(context.get_stake_pool_contract(0))
        .await?;
    println!(
        "validator unstaked balance after unstake epoch is {:?}",
        validator_unstaked_balance
    );
    assert_eq!(validator_unstaked_balance, U128(ntoy(0)));

    // User withdraw flow
    let user1_balance = context.user1.view_account(&context.worker).await?.balance;
    println!("initial user balance is {:?}", user1_balance);
    let res = context.withdraw_all(&context.user1).await?;
    println!("res is {:?}", res);
    println!("withdrawal gas burnt {:?}", res.outcome());
    let user1_balance_after_withdrawal = context.user1.view_account(&context.worker).await?.balance;
    println!(
        "user balance after withdrawal is {:?}",
        user1_balance_after_withdrawal
    );
    println!(
        "diff in user balance after withdrawal is {:?}",
        ((user1_balance_after_withdrawal) - user1_balance)
    );

    assert!(abs_diff_eq(
        user1_balance_after_withdrawal - user1_balance,
        ntoy(5),
        ntoy(1)
    ));

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    assert_eq!(user1_account.unstaked_balance, U128(ntoy(0)));

    // User withdraw flow
    let user2_balance = context.user2.view_account(&context.worker).await?.balance;
    println!("initial user balance is {:?}", user2_balance);
    let res = context.withdraw_all(&context.user2).await?;
    println!("res is {:?}", res);
    println!("withdrawal gas burnt {:?}", res.outcome());
    let user2_balance_after_withdrawal = context.user2.view_account(&context.worker).await?.balance;
    println!(
        "user balance after withdrawal is {:?}",
        user2_balance_after_withdrawal
    );
    println!(
        "diff in user balance after withdrawal is {:?}",
        ((user2_balance_after_withdrawal) - user2_balance)
    );
    assert!(abs_diff_eq(
        user2_balance_after_withdrawal - user2_balance,
        ntoy(5),
        ntoy(1)
    ));

    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    assert_eq!(user2_account.unstaked_balance, U128(ntoy(0)));

    Ok(())
}

// Tests: Autocompound with treasury rewards and autocompound in the same epoch
#[tokio::test]
async fn test_autocompound_with_treasury_rewards() -> anyhow::Result<()> {
    let context = IntegrationTestContext::new(3, None).await?;

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator2_info.staked, U128(ntoy(5)));
    assert_eq!(validator3_info.staked, U128(ntoy(5)));

    // Add user deposits
    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    context.run_epoch_methods().await?;

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount, U128(ntoy(10)));
    assert_eq!(user2_staked_amount, U128(ntoy(10)));
    assert_eq!(user3_staked_amount, U128(ntoy(10)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(10)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let total_token_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_token_supply, U128(ntoy(45)));

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(0)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));

    // Set reward fee to 10%
    context
        .set_reward_fee(Fraction {
            numerator: 10,
            denominator: 100,
        })
        .await?;
    context.worker.fast_forward(5 * ONE_EPOCH).await?;
    context.commit_reward_fee().await?;

    let reward_fee = context.get_reward_fee().await?;
    assert_eq!(reward_fee.numerator, 10);
    assert_eq!(reward_fee.denominator, 100);

    context.worker.fast_forward(2 * ONE_EPOCH).await?;

    // Add 30Near of rewards
    context
        .add_stake_pool_rewards(U128(ntoy(45)), context.get_stake_pool_contract(0))
        .await?;

    // Get the operator details

    // auto compound the rewards?;
    context.run_epoch_methods().await?;
    // let res = context
    //     .auto_compound_rewards(context.get_stake_pool_contract(0).id())
    //     .await?;

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1904761904761904761904761));

    let validator = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    println!("validator is {:?}", validator);
    assert_eq!(
        validator,
        ValidatorInfoResponse {
            account_id: validator.account_id.clone(),
            staked: U128(ntoy(60)),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: context.get_current_epoch().await?,
            last_unstake_start_epoch: U64(0),
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(90)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(45)));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(47250000000000000000000000)
    );

    let treasury_account = context
        .get_user_account(context.nearx_treasury.id().clone())
        .await?;
    println!(
        "Treasury account amount is {:?}",
        treasury_account.staked_balance
    );
    assert!(abs_diff_eq(
        treasury_account.staked_balance.0,
        4500000000000000000000000,
        ntoy(1)
    ));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(10)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    println!("user1_staked_amount is {:?}", user1_staked_amount);
    println!("user2_staked_amount is {:?}", user2_staked_amount);
    println!("user3_staked_amount is {:?}", user3_staked_amount);

    assert_eq!(user1_staked_amount, U128(19047619047619047619047619));
    assert_eq!(user2_staked_amount, U128(19047619047619047619047619));
    assert_eq!(user3_staked_amount, U128(19047619047619047619047619));

    let near_owner_account = context
        .get_user_account(context.nearx_owner.id().clone())
        .await?;

    println!(
        "near_owner_account staked balance is {:?}",
        near_owner_account.staked_balance
    );

    context.worker.fast_forward(1000).await?;
    // Deposit with NearX price > 1
    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);

    let res = context.run_epoch_methods().await?;
    println!("res is {:?}", res);

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    println!("user1_staked_amount is {:?}", user1_staked_amount);
    println!("user2_staked_amount is {:?}", user2_staked_amount);
    println!("user3_staked_amount is {:?}", user3_staked_amount);

    assert_eq!(user1_staked_amount, U128(29047619047619047619047619));
    assert_eq!(user2_staked_amount, U128(29047619047619047619047619));
    assert_eq!(user3_staked_amount, U128(29047619047619047619047619));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    println!("user1_token_balance is {:?}", user1_token_balance);
    println!("user2_token_balance is {:?}", user2_token_balance);
    println!("user3_token_balance is {:?}", user3_token_balance);

    assert_eq!(user1_token_balance, U128(15250000000000000000000000));
    assert_eq!(user2_token_balance, U128(15250000000000000000000000));
    assert_eq!(user3_token_balance, U128(15250000000000000000000000));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    println!("validator1_info is {:?}", validator1_info);
    println!("validator2_info is {:?}", validator2_info);
    println!("validator3_info is {:?}", validator3_info);
    assert_eq!(validator1_info.staked, U128(ntoy(60)));
    assert_eq!(validator2_info.staked, U128(ntoy(40)));
    assert_eq!(validator3_info.staked, U128(ntoy(20)));

    let total_token_supply = context.get_total_tokens_supply().await?;
    assert_eq!(total_token_supply, U128(63000000000000000000000000));

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state is {:?}", nearx_state);
    assert_eq!(nearx_state.total_staked, U128(ntoy(120)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(45)));
    assert_eq!(
        nearx_state.total_stake_shares,
        U128(63000000000000000000000000)
    );

    context
        .autocompounding_epoch(context.get_stake_pool_contract(0).id())
        .await?;

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(1904761904761904761904761));

    Ok(())
}

// Tests: Autocompound with no stake
#[tokio::test]
async fn test_autocompound_with_no_stake() -> anyhow::Result<()> {
    println!("***** Step 1: Initialization *****");
    let context = IntegrationTestContext::new(3, None).await?;

    // Auto compound
    println!("autocompounding!");
    context
        .autocompounding_epoch(context.get_stake_pool_contract(0).id())
        .await?;
    println!("done autocompounding!");

    println!("getting nearx_price");
    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(ntoy(1)));
    println!("getting nearx_state");
    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(0));
    assert_eq!(nearx_state.total_staked, U128(ntoy(15)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(15)));

    println!("getting validator info");
    let validator_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let current_epoch = context.get_current_epoch().await?;
    assert_eq!(validator_info.staked, U128(ntoy(5)));
    assert_eq!(
        validator_info.last_asked_rewards_epoch_height,
        current_epoch
    );

    Ok(())
}

#[tokio::test]
async fn test_deposit_flows() -> anyhow::Result<()> {
    println!("***** Step 1: Initialization *****");
    let context = IntegrationTestContext::new(3, None).await?;

    let current_epoch_1 = context.get_current_epoch().await?;

    // First test
    // user1, user2 and user3 deposit 10 NEAR each. We check whether the staking contract
    // Check initial deposits
    println!("**** Step 2: User deposit test ****");
    println!("Checking initial user deposits");

    let user1_account = context.get_user_account(context.user1.id().clone()).await?;
    let user2_account = context.get_user_account(context.user2.id().clone()).await?;
    let user3_account = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(user1_account.staked_balance, U128(0));
    assert_eq!(user2_account.staked_balance, U128(0));
    assert_eq!(user3_account.staked_balance, U128(0));

    println!("Successfully checked initial user deposits");

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(5)));
    assert_eq!(validator2_info.staked, U128(ntoy(5)));
    assert_eq!(validator3_info.staked, U128(ntoy(5)));

    println!("**** Simulating user deposits ****");
    println!("User 1 depositing");
    context.deposit(&context.user1, ntoy(10)).await?;
    println!("User 1 successfully deposited");

    println!("User 2 depositing");
    context.deposit(&context.user2, ntoy(10)).await?;
    println!("User 2 successfully deposited");

    println!("User 3 depositing");
    context.deposit(&context.user3, ntoy(10)).await?;
    println!("User 3 successfully deposited");

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(30)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, U64(0));

    context.run_epoch_methods().await?;

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));
    assert_eq!(nearx_state.user_amount_to_stake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.user_amount_to_unstake_in_epoch, U128(ntoy(0)));
    assert_eq!(nearx_state.reconciled_epoch_stake_amount, U128(0));
    assert_eq!(nearx_state.reconciled_epoch_unstake_amount, U128(0));
    assert_eq!(nearx_state.last_reconcilation_epoch, current_epoch_1);

    println!("Checking user deposits after users have deposited");
    let user1_staked_amount = context.get_user_account(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_account(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount.staked_balance, U128(ntoy(10)));
    assert_eq!(user2_staked_amount.staked_balance, U128(ntoy(10)));
    assert_eq!(user3_staked_amount.staked_balance, U128(ntoy(10)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(10)));
    assert_eq!(user2_token_balance, U128(ntoy(10)));
    assert_eq!(user3_token_balance, U128(ntoy(10)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    assert_eq!(validator1_info.staked, U128(ntoy(15)));
    assert_eq!(validator2_info.staked, U128(ntoy(15)));
    assert_eq!(validator3_info.staked, U128(ntoy(15)));

    let nearx_price = context.get_nearx_price().await?;
    println!("nearx_price is {:?}", nearx_price);
    assert_eq!(nearx_price, U128(ntoy(1)));

    let total_staked_amount = context.get_total_staked_amount().await?;
    println!("total_staked_amount is {:?}", total_staked_amount);
    assert_eq!(total_staked_amount, U128(ntoy(45)));

    let total_tokens_minted = context.get_total_tokens_supply().await?;
    assert_eq!(total_tokens_minted, U128(ntoy(45)));

    // Second test
    // Test token transfers
    println!("**** Step 3: Token transferring ****");

    println!("Successfully checked initial user deposits");

    println!("User 1 transfers 5 tokens to User 2");
    context
        .ft_transfer(&context.user1, &context.user2, ntoy(5).to_string())
        .await?;
    println!("User 2 transfers 3 tokens to User 3");
    context
        .ft_transfer(&context.user2, &context.user3, ntoy(3).to_string())
        .await?;
    println!("User 3 transfers 1 token to User 1");
    context
        .ft_transfer(&context.user3, &context.user1, ntoy(1).to_string())
        .await?;

    println!("Checking user deposits after users have deposited");
    let user1_staked_amount = context.get_user_account(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_account(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_account(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount.staked_balance, U128(ntoy(6)));
    assert_eq!(user2_staked_amount.staked_balance, U128(ntoy(12)));
    assert_eq!(user3_staked_amount.staked_balance, U128(ntoy(12)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(6)));
    assert_eq!(user2_token_balance, U128(ntoy(12)));
    assert_eq!(user3_token_balance, U128(ntoy(12)));

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(ntoy(1)));

    let total_staked_amount = context.get_total_staked_amount().await?;
    assert_eq!(total_staked_amount, U128(ntoy(45)));

    let total_tokens_minted = context.get_total_tokens_supply().await?;
    assert_eq!(total_tokens_minted, U128(ntoy(45)));

    println!("**** Step 4: Auto compounding ****");

    println!("Fast forward 1 epoch");
    context.worker.fast_forward(ONE_EPOCH).await?;

    println!("Auto compounding stake pool");

    // Adding rewards
    context
        .add_stake_pool_rewards(U128(ntoy(35)), context.get_stake_pool_contract(0))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(5)), context.get_stake_pool_contract(1))
        .await?;
    context
        .add_stake_pool_rewards(U128(ntoy(5)), context.get_stake_pool_contract(2))
        .await?;

    // restake_staking_pool(&worker, &stake_pool_contract).await?;
    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state before auto compounding is {:?}", nearx_state);

    println!("Auto compounding nearx pool");
    let res = context
        .autocompounding_epoch(context.get_stake_pool_contract(0).id())
        .await?;
    println!("res is {:?}", res);
    let res = context
        .autocompounding_epoch(context.get_stake_pool_contract(1).id())
        .await?;
    println!("res is {:?}", res);
    let res = context
        .autocompounding_epoch(context.get_stake_pool_contract(2).id())
        .await?;
    println!("res is {:?}", res);

    let nearx_state = context.get_nearx_state().await?;
    println!("nearx_state after auto compounding is {:?}", nearx_state);

    let nearx_price = context.get_nearx_price().await?;
    assert_eq!(nearx_price, U128(ntoy(2)));

    let total_tokens_minted = context.get_total_tokens_supply().await?;
    assert_eq!(total_tokens_minted, U128(ntoy(45)));

    let user1_staked_amount = context.get_user_deposit(context.user1.id().clone()).await?;
    let user2_staked_amount = context.get_user_deposit(context.user2.id().clone()).await?;
    let user3_staked_amount = context.get_user_deposit(context.user3.id().clone()).await?;

    assert_eq!(user1_staked_amount, U128(ntoy(12)));
    assert_eq!(user2_staked_amount, U128(ntoy(24)));
    assert_eq!(user3_staked_amount, U128(ntoy(24)));

    let user1_token_balance = context
        .get_user_token_balance(context.user1.id().clone())
        .await?;
    let user2_token_balance = context
        .get_user_token_balance(context.user2.id().clone())
        .await?;
    let user3_token_balance = context
        .get_user_token_balance(context.user3.id().clone())
        .await?;

    assert_eq!(user1_token_balance, U128(ntoy(6)));
    assert_eq!(user2_token_balance, U128(ntoy(12)));
    assert_eq!(user3_token_balance, U128(ntoy(12)));

    let validator1_info = context
        .get_validator_info(context.get_stake_pool_contract(0).id().clone())
        .await?;
    let validator2_info = context
        .get_validator_info(context.get_stake_pool_contract(1).id().clone())
        .await?;
    let validator3_info = context
        .get_validator_info(context.get_stake_pool_contract(2).id().clone())
        .await?;
    let current_epoch = context.get_current_epoch().await?;
    println!("validator1 is {:?}", validator1_info);
    assert_eq!(
        validator1_info,
        ValidatorInfoResponse {
            account_id: validator1_info.account_id.clone(),
            staked: U128(ntoy(50)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator2_info,
        ValidatorInfoResponse {
            account_id: validator2_info.account_id.clone(),
            staked: U128(ntoy(20)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );
    assert_eq!(
        validator3_info,
        ValidatorInfoResponse {
            account_id: validator3_info.account_id.clone(),
            staked: U128(ntoy(20)),
            unstaked: U128(0),
            last_asked_rewards_epoch_height: current_epoch,
            last_unstake_start_epoch: U64(0),
            weight: 10
        }
    );

    let nearx_state = context.get_nearx_state().await?;
    assert_eq!(nearx_state.total_staked, U128(ntoy(90)));
    assert_eq!(nearx_state.accumulated_staked_rewards, U128(ntoy(45)));
    assert_eq!(nearx_state.total_stake_shares, U128(ntoy(45)));

    println!("nearx_state after auto compounding is {:?}", nearx_state);

    Ok(())
}

'''
'''--- contracts/mock-stake-pool/Cargo.toml ---
[package]
name = "mock-stake-pool"
version = "0.0.1"
authors = ["bchain <bchain@staderlabs.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint = { version = "0.9.0", default-features = false }
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- contracts/mock-stake-pool/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::env::log;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, require, serde_json, AccountId, PanicOnDefault, Promise, PromiseOrValue,
};

pub fn ntoy(near_amount: u128) -> u128 {
    near_amount * 10u128.pow(24)
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

/// Staking pool interface
trait StakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128;

    fn get_account(&self, account_id: AccountId) -> HumanReadableAccount;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128);

    fn withdraw_all(&mut self);

    fn stake(&mut self, amount: U128);

    fn unstake(&mut self, amount: U128);

    fn unstake_all(&mut self);

    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

/// mockup of staking pool, for testing
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MockStakingPool {
    deposits: LookupMap<AccountId, u128>,
    staked: LookupMap<AccountId, u128>,
    /// For ft_on_transfer testing
    refund_amount: U128,
    panic: bool,
}

#[near_bindgen]
impl MockStakingPool {
    #[init]
    pub fn new() -> Self {
        Self {
            deposits: LookupMap::new(b"d"),
            staked: LookupMap::new(b"s"),
            refund_amount: U128(ntoy(5)),
            panic: false,
        }
    }
}

#[near_bindgen]
impl StakingPool for MockStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        U128::from(self.internal_get_staked(&account_id))
    }

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        U128::from(self.internal_get_unstaked_deposit(&account_id))
    }

    fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        U128::from(
            self.internal_get_unstaked_deposit(&account_id) + self.internal_get_staked(&account_id),
        )
    }

    fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        HumanReadableAccount {
            account_id: account_id.clone(),
            staked_balance: U128::from(self.internal_get_staked(&account_id)),
            unstaked_balance: U128::from(self.internal_get_unstaked_deposit(&account_id)),
            can_withdraw: true,
        }
    }

    #[payable]
    fn deposit(&mut self) {
        require!(!self.panic, "Test Panic!");
        self.internal_deposit()
    }

    #[payable]
    fn deposit_and_stake(&mut self) {
        require!(!self.panic, "Test Panic!");
        let account_id = env::predecessor_account_id();

        self.internal_deposit();

        // let amount = self.internal_get_unstaked_deposit(&account_id);
        self.internal_stake(env::attached_deposit());
    }

    fn withdraw(&mut self, amount: U128) {
        require!(!self.panic, "Test Panic!");
        let account_id = env::predecessor_account_id();
        self.internal_withdraw(&account_id, amount.0);
    }

    fn withdraw_all(&mut self) {
        require!(!self.panic, "Test Panic!");
        let account_id = env::predecessor_account_id();
        let unstaked = self.internal_get_unstaked_deposit(&account_id);
        self.internal_withdraw(&account_id, unstaked);
    }

    fn stake(&mut self, amount: U128) {
        require!(!self.panic, "Test Panic!");
        self.internal_stake(amount.0)
    }

    fn unstake(&mut self, amount: U128) {
        require!(!self.panic, "Test Panic!");
        self.internal_unstake(amount.0);
    }

    fn unstake_all(&mut self) {
        require!(!self.panic, "Test Panic!");
        let account_id = env::predecessor_account_id();
        let staked_amount = self.internal_get_staked(&account_id);
        self.internal_unstake(staked_amount);
    }

    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        require!(!self.panic);
        PromiseOrValue::Value(self.refund_amount)
    }
}

#[near_bindgen]
impl MockStakingPool {
    /// manually generate some reward for the caller,
    /// for testing purpose only
    pub fn add_reward(&mut self, amount: U128) {
        let account_id = env::predecessor_account_id();
        self.add_reward_for(amount, account_id);
    }

    pub fn set_refund_amount(&mut self, amount: U128) {
        self.refund_amount = amount;
    }

    pub fn add_reward_for(&mut self, amount: U128, account_id: AccountId) {
        let staked_amount = self.internal_get_staked(&account_id);
        assert!(staked_amount > 0);

        let new_amount = staked_amount + amount.0;
        self.staked.insert(&account_id, &new_amount);
    }

    pub fn set_panic(&mut self, panic: bool) {
        self.panic = panic;
    }

    pub fn adjust_balance(
        &mut self,
        account_id: AccountId,
        staked_delta: u128,
        unstaked_delta: u128,
    ) {
        let staked_amount = self
            .internal_get_staked(&account_id)
            .saturating_sub(staked_delta);
        let unstaked_amount = self.internal_get_unstaked_deposit(&account_id) + unstaked_delta;

        self.staked.insert(&account_id, &staked_amount);
        self.deposits.insert(&account_id, &unstaked_amount);
    }
}

impl MockStakingPool {
    fn internal_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let amount = env::attached_deposit();
        assert!(amount > 0);

        let current_deposit = self.internal_get_unstaked_deposit(&account_id);
        let new_deposit = current_deposit + amount;

        self.deposits.insert(&account_id, &new_deposit);
    }

    fn internal_stake(&mut self, amount: u128) {
        let account_id = env::predecessor_account_id();
        let unstaked_deposit = self.internal_get_unstaked_deposit(&account_id);
        log!("amount is {}", amount);
        log!("unstaked deposit is {}", unstaked_deposit);
        assert!(unstaked_deposit >= amount);

        let new_deposit = unstaked_deposit - amount;
        let new_staked = self.internal_get_staked(&account_id) + amount;

        log!("New deposit amount is {}", new_deposit);
        log!("New staked amount is {}", new_staked);

        self.deposits.insert(&account_id, &new_deposit);
        self.staked.insert(&account_id, &new_staked);
    }

    fn internal_unstake(&mut self, amount: u128) {
        let account_id = env::predecessor_account_id();
        let staked = self.internal_get_staked(&account_id);
        assert!(staked >= amount);

        let unstaked_deposit = self.internal_get_unstaked_deposit(&account_id);
        let new_deposit = unstaked_deposit + amount;
        let new_staked = staked - amount;

        self.deposits.insert(&account_id, &new_deposit);
        self.staked.insert(&account_id, &new_staked);
    }

    fn internal_withdraw(&mut self, account_id: &AccountId, amount: u128) {
        let unstaked_amount = self.internal_get_unstaked_deposit(account_id);
        assert!(unstaked_amount >= amount);

        let new_unstaked = unstaked_amount - amount;
        self.deposits.insert(account_id, &new_unstaked);

        Promise::new(account_id.clone()).transfer(amount);
    }

    fn internal_get_unstaked_deposit(&self, account_id: &AccountId) -> u128 {
        self.deposits.get(account_id).unwrap_or_default()
    }

    fn internal_get_staked(&self, account_id: &AccountId) -> u128 {
        self.staked.get(account_id).unwrap_or_default()
    }
}

'''
'''--- contracts/near-x/Cargo.toml ---
[package]
edition = "2018"
name = "near-x"
version = "0.1.0"
authors = ["bchain <bchain@staderlabs.com>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0"
near-contract-standards = "=4.0.0"
uint = { version = "0.8.3", default-features = false }
near-sys= "=0.2.0"

[dev-dependencies]
anyhow = "1.0"
near-units = "0.1.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.10.0", features = ["full"] }
workspaces = { git = "https://github.com/near/workspaces-rs" }

'''
'''--- contracts/near-x/src/constants.rs ---
use near_sdk::{EpochHeight, ONE_NEAR};

pub const NO_DEPOSIT: u128 = 0;
pub const NEAR_CENT: u128 = ONE_NEAR / 100;
pub const ONE_MILLI_NEAR: u128 = ONE_NEAR / 1_000;
pub const ONE_MICRO_NEAR: u128 = ONE_NEAR / 1_000_000;
pub const TWO_NEAR: u128 = 2 * ONE_NEAR;
pub const FIVE_NEAR: u128 = 5 * ONE_NEAR;
pub const TEN_NEAR: u128 = 10 * ONE_NEAR;
pub const K_NEAR: u128 = 1_000 * ONE_NEAR;

pub const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;
// Number of epochs to wait for reward fee to set
pub const REWARD_FEE_SET_WAIT_TIME: EpochHeight = 4;

/// Storage keys
pub const ACCOUNTS_MAP: &str = "A";
pub const VALIDATOR_MAP: &str = "B";

uint::construct_uint! {
        /// 256-bit unsigned integer.
        pub struct U256(4);
}

pub mod gas {
    use near_sdk::Gas;

    /// Gas attached to deposit call on the staking pool contract.
    pub const DEPOSIT_AND_STAKE: Gas = base_gas(3);

    /// Gas attached to stake call on the staking pool contract.
    pub const STAKE: Gas = base_gas(3);

    /// The amount of gas required to get current unstaked balance of this account from the
    /// staking pool.
    pub const GET_ACCOUNT_UNSTAKED_BALANCE: Gas = base_gas(1);

    /// The amount of gas required to get the current total balance of this account from the
    /// staking pool.
    pub const GET_ACCOUNT_TOTAL_BALANCE: Gas = base_gas(1);

    /// Gas attached to the inner callback for processing result of the deposit and stake call to
    /// the staking pool.
    pub const ON_STAKE_POOL_DEPOSIT_AND_STAKE: Gas = base_gas(1);

    pub const ON_STAKE_POOL_DEPOSIT_AND_STAKE_CB: Gas = base_gas(1);

    /// The amount of gas required to get the current staked balance of this account from the
    /// staking pool.
    pub const ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE: Gas = base_gas(1);

    pub const ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE_CB: Gas = base_gas(1);

    pub const ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE: Gas = base_gas(1);

    pub const ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE_CB: Gas = base_gas(1);

    /// Gas attached to the inner callback for processing result of the call to get the current total balance from the staking pool.
    pub const ON_GET_SP_STAKED_BALANCE_TO_RECONCILE: Gas = tera(5);

    pub const ON_STAKE_POOL_WITHDRAW_ALL: Gas = base_gas(3);

    pub const ON_STAKE_POOL_WITHDRAW_ALL_CB: Gas = base_gas(3);

    pub const ON_STAKE_POOL_UNSTAKE: Gas = base_gas(3);

    pub const ON_STAKE_POOL_UNSTAKE_CB: Gas = base_gas(3);

    pub const WITHDRAW_EPOCH: Gas = base_gas(3);

    pub const UNSTAKING_EPOCH: Gas = base_gas(3);

    pub const STAKING_EPOCH: Gas = base_gas(3);

    pub const AUTOCOMPOUNDING_EPOCH: Gas = base_gas(3);

    pub const SYNC_VALIDATOR_EPOCH: Gas = base_gas(3);

    pub const DRAIN_UNSTAKE: Gas = base_gas(3);

    pub const DRAIN_WITHDRAW: Gas = base_gas(3);

    pub const FT_TRANSFER_RESOLVE: Gas = tera(12);

    pub const FT_TRANSFER: Gas = tera(35);

    const fn base_gas(n: u64) -> Gas {
        Gas(1_000_000_000_000 * 25 * n)
    }

    const fn tera(n: u64) -> Gas {
        Gas(1_000_000_000_000 * n)
    }
}

'''
'''--- contracts/near-x/src/contract.rs ---
mod internal;
mod metadata;
mod operator;
mod public;
mod storage_spec;
mod upgrade;
mod util;

use crate::state::*;
use near_sdk::json_types::U128;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env, ext_contract, near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, Balance, EpochHeight, PanicOnDefault, PromiseOrValue, PublicKey,
};

#[derive(
    Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Copy, PartialEq,
)]
#[serde(crate = "near_sdk::serde")]
pub struct OperationControls {
    pub stake_paused: bool,
    pub unstaked_paused: bool,
    pub withdraw_paused: bool,
    pub staking_epoch_paused: bool,
    pub unstaking_epoch_paused: bool,
    pub withdraw_epoch_paused: bool,
    pub autocompounding_epoch_paused: bool,
    pub sync_validator_balance_paused: bool,
    pub ft_transfer_paused: bool,
    pub ft_transfer_call_paused: bool,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct NearxPool {
    pub owner_account_id: AccountId,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // nearx_price = (total_staked) / (total_stake_shares)
    pub total_staked: u128,

    /// how many "NearX" were minted.
    pub total_stake_shares: u128, //total NearX minted

    pub accumulated_staked_rewards: u128,

    /// Amount of NEAR that is users requested to stake
    pub user_amount_to_stake_in_epoch: Balance,
    /// Amount of NEAR that is users requested to unstake
    pub user_amount_to_unstake_in_epoch: Balance,

    /// Amount of NEAR that actually needs to be staked in the epoch
    pub reconciled_epoch_stake_amount: Balance,
    /// Amount of NEAR that actually needs to be unstaked in the epoch
    pub reconciled_epoch_unstake_amount: Balance,
    /// Last epoch height stake/unstake amount were reconciled
    pub last_reconcilation_epoch: EpochHeight,

    // User account map
    pub accounts: UnorderedMap<AccountId, Account>,

    pub validator_info_map: UnorderedMap<AccountId, ValidatorInfo>,
    pub total_validator_weight: u16,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: u128,

    pub operator_account_id: AccountId,

    pub treasury_account_id: AccountId,

    pub rewards_fee: Fraction,

    // extra rewards which the owner/operator can drop to increase the exchange rate and increase the
    // staked amounts of all users
    pub rewards_buffer: u128,

    pub accumulated_rewards_buffer: u128,

    // Temp owner for owner update
    // This is to have 2 commit owner update
    pub temp_owner: Option<AccountId>,

    pub temp_operator: Option<AccountId>,

    pub temp_treasury: Option<AccountId>,

    pub temp_reward_fee: Option<Fraction>,

    pub last_reward_fee_set_epoch: EpochHeight,

    // Operations control
    pub operations_control: OperationControls,

    pub min_storage_reserve: u128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct LegacyNearxPoolV1 {
    pub owner_account_id: AccountId,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // nearx_price = (total_staked) / (total_stake_shares)
    pub total_staked: u128,

    /// how many "NearX" were minted.
    pub total_stake_shares: u128, //total NearX minted

    pub accumulated_staked_rewards: u128,

    /// Amount of NEAR that is users requested to stake
    pub user_amount_to_stake_in_epoch: Balance,
    /// Amount of NEAR that is users requested to unstake
    pub user_amount_to_unstake_in_epoch: Balance,

    /// Amount of NEAR that actually needs to be staked in the epoch
    pub reconciled_epoch_stake_amount: Balance,
    /// Amount of NEAR that actually needs to be unstaked in the epoch
    pub reconciled_epoch_unstake_amount: Balance,
    /// Last epoch height stake/unstake amount were reconciled
    pub last_reconcilation_epoch: EpochHeight,

    // User account map
    pub accounts: UnorderedMap<AccountId, Account>,

    pub validator_info_map: UnorderedMap<AccountId, ValidatorInfo>,
    pub total_validator_weight: u16,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: u128,

    pub operator_account_id: AccountId,

    pub treasury_account_id: AccountId,

    pub rewards_fee: Fraction,

    // Temp owner for owner update
    // This is to have 2 commit owner update
    pub temp_owner: Option<AccountId>,

    // Operations control
    pub operations_control: OperationControls,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct LegacyNearxPoolV2 {
    pub owner_account_id: AccountId,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // nearx_price = (total_staked) / (total_stake_shares)
    pub total_staked: u128,

    /// how many "NearX" were minted.
    pub total_stake_shares: u128, //total NearX minted

    pub accumulated_staked_rewards: u128,

    /// Amount of NEAR that is users requested to stake
    pub user_amount_to_stake_in_epoch: Balance,
    /// Amount of NEAR that is users requested to unstake
    pub user_amount_to_unstake_in_epoch: Balance,

    /// Amount of NEAR that actually needs to be staked in the epoch
    pub reconciled_epoch_stake_amount: Balance,
    /// Amount of NEAR that actually needs to be unstaked in the epoch
    pub reconciled_epoch_unstake_amount: Balance,
    /// Last epoch height stake/unstake amount were reconciled
    pub last_reconcilation_epoch: EpochHeight,

    // User account map
    pub accounts: UnorderedMap<AccountId, Account>,

    pub validator_info_map: UnorderedMap<AccountId, ValidatorInfo>,
    pub total_validator_weight: u16,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: u128,

    pub operator_account_id: AccountId,

    pub treasury_account_id: AccountId,

    pub rewards_fee: Fraction,

    pub rewards_buffer: u128,

    pub accumulated_rewards_buffer: u128,

    // Temp owner for owner update
    // This is to have 2 commit owner update
    pub temp_owner: Option<AccountId>,

    pub temp_operator: Option<AccountId>,

    pub temp_treasury: Option<AccountId>,

    pub temp_reward_fee: Option<Fraction>,

    pub last_reward_fee_set_epoch: EpochHeight,

    // Operations control
    pub operations_control: OperationControls,
}

//self-callbacks
#[ext_contract(ext_staking_pool_callback)]
pub trait ExtNearxStakingPoolCallbacks {
    fn on_stake_pool_deposit(&mut self, amount: U128) -> bool;

    fn on_stake_pool_deposit_and_stake_manager(
        &mut self,
        validator_info: ValidatorInfo,
        amount: u128,
        shares: u128,
        user: AccountId,
    ) -> PromiseOrValue<bool>;

    fn on_stake_pool_deposit_and_stake(&mut self, validator: AccountId, amount: u128);

    fn on_stake_pool_withdraw_all(&mut self, validator_info: ValidatorInfo, amount: u128);

    fn on_stake_pool_unstake(&mut self, validator_id: AccountId, amount_to_unstake: u128);

    fn on_stake_pool_drain_unstake(&mut self, validator_id: AccountId, amount_to_unstake: u128);

    fn on_stake_pool_drain_withdraw(&mut self, validator_id: AccountId, amount_to_withdraw: u128);

    fn on_get_sp_staked_balance_for_rewards(
        &mut self,
        validator_info: ValidatorInfo,
        #[callback] total_staked_balance: U128,
    ) -> PromiseOrValue<bool>;

    fn on_stake_pool_get_account(
        &mut self,
        validator_id: AccountId,
        #[callback] account: HumanReadableAccount,
    );
}

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128;

    fn get_account(&self, account_id: AccountId) -> HumanReadableAccount;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128);

    fn withdraw_all(&mut self);

    fn stake(&mut self, amount: U128);

    fn unstake(&mut self, amount: U128);

    fn unstake_all(&mut self);
}

'''
'''--- contracts/near-x/src/contract/internal.rs ---
use crate::constants::*;
use crate::errors::*;
use crate::events::Event;
use crate::{
    constants::{gas, NO_DEPOSIT},
    contract::*,
    state::*,
};
use near_contract_standards::storage_management::StorageManagement;
use near_sdk::{
    is_promise_success, log, require, AccountId, Balance, Promise, PromiseOrValue, ONE_NEAR,
};

#[near_bindgen]
impl NearxPool {
    pub(crate) fn internal_update_rewards_buffer(&mut self, rewards_amount: Balance) {
        self.total_staked += rewards_amount;
        self.rewards_buffer += rewards_amount;
        self.accumulated_rewards_buffer += rewards_amount;

        Event::UpdateRewardBuffer {
            amount_added: U128(rewards_amount),
            new_reward_buffer: U128(self.rewards_buffer),
        }
        .emit();
    }

    pub(crate) fn internal_manager_deposit_and_stake(
        &mut self,
        user_amount: Balance,
        validator: AccountId,
    ) {
        let account_id = env::predecessor_account_id();

        // Calculate the number of nearx (stake shares) that the account will receive for staking the given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(user_amount);
        require!(num_shares > 0, ERROR_NON_POSITIVE_STAKE_SHARES);

        let validator_info = self.internal_get_validator(&validator);

        //schedule async deposit_and_stake on that pool
        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::DEPOSIT_AND_STAKE)
            .with_attached_deposit(user_amount)
            .deposit_and_stake()
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_DEPOSIT_AND_STAKE)
                    .on_stake_pool_deposit_and_stake_manager(
                        validator_info,
                        user_amount,
                        num_shares,
                        account_id,
                    ),
            );
    }

    #[private]
    pub fn on_stake_pool_deposit_and_stake_manager(
        &mut self,
        #[allow(unused_mut)] mut validator_info: ValidatorInfo,
        amount: u128,
        shares: u128,
        user: AccountId,
    ) -> PromiseOrValue<bool> {
        let mut acc = &mut self.accounts.get(&user).unwrap_or_default();

        if is_promise_success() {
            validator_info.staked += amount;
            acc.stake_shares += shares;
            self.total_stake_shares += shares;
            self.total_staked += amount;
            log!(
                "Successfully staked {} into {}",
                amount,
                validator_info.account_id
            );
            self.internal_update_validator(&validator_info.account_id, &validator_info);
            self.internal_update_account(&user, acc);
            PromiseOrValue::Value(true)
        } else {
            log!(
                "Failed to stake {} into {}",
                amount,
                validator_info.account_id
            );
            log!("Transfering back {} to {} after stake failed", amount, user);
            PromiseOrValue::Promise(Promise::new(user).transfer(amount))
        }
    }

    pub(crate) fn internal_deposit_and_stake(&mut self, amount: u128) {
        self.assert_staking_not_paused();

        self.assert_min_deposit_amount(amount);

        let account_id = env::predecessor_account_id();
        // we need to call storage_deposit and register the user storage before the user deposits
        let mut account = self.internal_get_account_unwrap(&account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        require!(num_shares > 0, ERROR_NON_POSITIVE_STAKE_SHARES);

        account.stake_shares += num_shares;
        self.internal_update_account(&account_id, &account);

        self.total_staked += amount;
        self.total_stake_shares += num_shares;

        // Increase requested stake amount within the current epoch
        self.user_amount_to_stake_in_epoch += amount;

        Event::DepositAndStake {
            account_id,
            amount: U128(amount),
            minted_stake_shares: U128(num_shares),
            new_stake_shares: U128(account.stake_shares),
        }
        .emit();
    }

    pub(crate) fn internal_unstake(&mut self, amount: u128) {
        self.assert_unstaking_not_paused();

        require!(amount > 0, ERROR_NON_POSITIVE_UNSTAKE_AMOUNT);

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        require!(
            self.total_staked > 0,
            ERROR_NOT_ENOUGH_CONTRACT_STAKED_AMOUNT
        );

        let mut num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        require!(num_shares > 0, ERROR_NON_POSITIVE_UNSTAKING_SHARES);
        require!(
            account.stake_shares >= num_shares,
            ERROR_NOT_ENOUGH_STAKED_AMOUNT_TO_UNSTAKE
        );

        let mut receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        require!(
            receive_amount > 0,
            ERROR_NON_POSITIVE_UNSTAKE_RECEVIE_AMOUNT
        );

        account.stake_shares -= num_shares;
        account.unstaked_amount += receive_amount;

        let remaining_amount =
            self.staked_amount_from_num_shares_rounded_down(account.stake_shares);

        let storage_balance_bounds = self.storage_balance_bounds();
        // if the amount remaining is lower than the storage balance, unstake the remaining amount in order to
        // avoid large number of accounts piling up with v.v small amounts
        if remaining_amount <= storage_balance_bounds.min.0 {
            receive_amount += remaining_amount;
            num_shares += account.stake_shares;

            account.stake_shares = 0;
            account.unstaked_amount += remaining_amount;
        }

        account.withdrawable_epoch_height =
            env::epoch_height() + self.get_unstake_release_epoch(account.unstaked_amount);
        if self.last_reconcilation_epoch == env::epoch_height() {
            // The unstake request is received after epoch_reconcilation
            // so actual unstake will happen in the next epoch,
            // which will put withdraw off for one more epoch.
            account.withdrawable_epoch_height += 1;
        }

        self.internal_update_account(&account_id, &account);

        self.total_staked -= receive_amount;
        self.total_stake_shares -= num_shares;

        // Increase requested unstake amount within the current epoch
        self.user_amount_to_unstake_in_epoch += receive_amount;

        Event::Unstake {
            account_id: account_id.clone(),
            unstaked_amount: U128(receive_amount),
            burnt_stake_shares: U128(num_shares),
            new_unstaked_balance: U128(account.unstaked_amount),
            new_stake_shares: U128(account.stake_shares),
            unstaked_available_epoch_height: account.withdrawable_epoch_height,
        }
        .emit();

        Event::FtBurn {
            account_id,
            amount: U128(num_shares),
        }
        .emit();
    }

    // Make this return a promise
    pub(crate) fn internal_withdraw(&mut self, amount: Balance) {
        self.assert_withdraw_not_paused();

        let mut amount_to_send = amount;
        let account_id = env::predecessor_account_id();

        require!(amount_to_send > 0, ERROR_NON_POSITIVE_WITHDRAWAL);

        let account = self.internal_get_account(&account_id);
        require!(
            account.unstaked_amount >= amount_to_send,
            ERROR_NOT_ENOUGH_UNSTAKED_AMOUNT_TO_WITHDRAW
        );
        require!(
            account.withdrawable_epoch_height <= env::epoch_height(),
            ERROR_UNSTAKED_AMOUNT_IN_UNBONDING_PERIOD
        );

        require!(
            env::account_balance().saturating_sub(self.min_storage_reserve) >= amount_to_send,
            ERROR_NOT_ENOUGH_BALANCE_FOR_STORAGE
        );

        let mut account = self.internal_get_account(&account_id);
        account.unstaked_amount -= amount_to_send;

        let storage_balance_bounds = self.storage_balance_bounds();
        // If the unstaked amount is less than the minimum required storage amount for storage, then send the remaining amount back to the user
        if account.unstaked_amount <= storage_balance_bounds.min.0 {
            amount_to_send += account.unstaked_amount;
            account.unstaked_amount = 0;
        }

        self.internal_update_account(&account_id, &account);

        Event::Withdraw {
            account_id: account_id.clone(),
            amount: U128(amount_to_send),
            new_unstaked_balance: U128(account.unstaked_amount),
        }
        .emit();

        Promise::new(account_id).transfer(amount_to_send);
    }

    pub(crate) fn internal_get_validator(&self, validator: &AccountId) -> ValidatorInfo {
        if let Some(val_info) = self.validator_info_map.get(validator) {
            val_info
        } else {
            panic!("{}", ERROR_VALIDATOR_IS_NOT_PRESENT);
        }
    }

    pub(crate) fn internal_update_validator(
        &mut self,
        validator: &AccountId,
        validator_info: &ValidatorInfo,
    ) {
        self.validator_info_map.insert(validator, validator_info);
    }

    pub(crate) fn num_shares_from_staked_amount_rounded_down(&self, amount: Balance) -> u128 {
        // At this point the er will be 1
        if self.total_stake_shares == 0 || self.total_staked == 0 {
            return amount;
        }

        (U256::from(self.total_stake_shares) * U256::from(amount) / U256::from(self.total_staked))
            .as_u128()
    }

    pub(crate) fn num_shares_from_staked_amount_rounded_up(&self, amount: Balance) -> u128 {
        if self.total_stake_shares == 0 || self.total_staked == 0 {
            return amount;
        }

        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked - 1))
            / U256::from(self.total_staked))
        .as_u128()
    }

    pub(crate) fn staked_amount_from_num_shares_rounded_down(&self, num_shares: u128) -> Balance {
        if self.total_staked == 0 || self.total_stake_shares == 0 {
            return num_shares;
        }

        (U256::from(self.total_staked) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    pub(crate) fn staked_amount_from_num_shares_rounded_up(&self, num_shares: u128) -> Balance {
        if self.total_staked == 0 || self.total_stake_shares == 0 {
            return num_shares;
        }

        ((U256::from(self.total_staked) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    pub(crate) fn internal_get_account_unwrap(&self, account_id: &AccountId) -> Account {
        self.accounts
            .get(account_id)
            .expect("Account is not registered. Please register the account using storage_deposit")
    }

    pub(crate) fn internal_update_account(&mut self, account_id: &AccountId, account: &Account) {
        // accounts can only be removed by storage_unregister
        self.accounts.insert(account_id, account);
    }

    pub(crate) fn get_validator_expected_stake(&self, validator: &ValidatorInfo) -> Balance {
        if validator.weight == 0 {
            0
        } else {
            self.total_staked * (validator.weight as u128) / (self.total_validator_weight as u128)
        }
    }

    #[private]
    pub fn get_validator_to_stake(&self, amount: Balance) -> (Option<ValidatorInfo>, Balance) {
        let mut selected_validator = None;
        let mut amount_to_stake: Balance = 0;

        for validator in self.validator_info_map.values() {
            let target_amount = self.get_validator_expected_stake(&validator);
            if validator.staked < target_amount {
                let delta = std::cmp::min(target_amount - validator.staked, amount);
                if delta > amount_to_stake {
                    amount_to_stake = delta;
                    selected_validator = Some(validator);
                }
            }
        }

        if amount_to_stake > 0 && amount - amount_to_stake <= ONE_NEAR {
            amount_to_stake = amount;
        }

        // Note that it's possible that no validator is available
        (selected_validator, amount_to_stake)
    }

    #[private]
    pub fn get_validator_to_unstake(&self) -> Option<ValidatorInfo> {
        let mut max_validator_stake_amount: u128 = 0;
        let mut current_validator: Option<ValidatorInfo> = None;

        for validator in self.validator_info_map.values() {
            if !validator.pending_unstake_release()
                && !validator.paused()
                && validator.staked.gt(&max_validator_stake_amount)
            {
                max_validator_stake_amount = validator.staked;
                current_validator = Some(validator)
            }
        }

        current_validator
    }

    #[private]
    pub fn get_unstake_release_epoch(&self, amount: u128) -> EpochHeight {
        let mut available_amount: Balance = 0;
        let mut total_staked_amount: Balance = 0;
        for validator in self.validator_info_map.values() {
            total_staked_amount += validator.staked;

            if !validator.paused() && !validator.pending_unstake_release() && validator.staked > 0 {
                available_amount += validator.staked;
            }

            // found enough balance to unstake from available validators
            if available_amount >= amount {
                return NUM_EPOCHS_TO_UNLOCK;
            }
        }

        // nothing is actually staked, all balance should be available now
        // still leave a buffer for the user
        if total_staked_amount == 0 {
            return NUM_EPOCHS_TO_UNLOCK;
        }

        // no enough available validators to unstake
        // double the unstake wating time
        2 * NUM_EPOCHS_TO_UNLOCK
    }
}

'''
'''--- contracts/near-x/src/contract/metadata.rs ---
use crate::contract::*;
use near_sdk::near_bindgen;

/// To make it easier for the contract to be audited and validated by community
/// and 3rd party, we adopt [NEP-330 standard](https://github.com/near/NEPs/blob/master/neps/nep-0330.md)
/// to make contract source metadata (including versions and source code links)
/// available to auditors, developers and users.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractSourceMetadata {
    pub version: String,
    pub link: String,
}

pub trait ContractSourceMetadataTrait {
    fn contract_source_metadata(&self) -> ContractSourceMetadata;
}

#[near_bindgen]
impl ContractSourceMetadataTrait for NearxPool {
    fn contract_source_metadata(&self) -> ContractSourceMetadata {
        ContractSourceMetadata {
            version: env!("CARGO_PKG_VERSION").to_string(),
            link: "https://github.com/stader-labs/near-liquid-token".to_string(),
        }
    }
}

'''
'''--- contracts/near-x/src/contract/operator.rs ---
use crate::errors::*;
use crate::events::*;
use crate::utils::*;
use crate::{
    constants::{gas, NO_DEPOSIT},
    contract::*,
    state::*,
};
use near_sdk::{env, log, near_bindgen, require};

#[near_bindgen]
impl NearxPool {
    // keep calling this method until false is return
    pub fn staking_epoch(&mut self) -> bool {
        self.assert_staking_epoch_not_paused();

        let min_gas = gas::STAKING_EPOCH
            + gas::ON_STAKE_POOL_DEPOSIT_AND_STAKE
            + gas::ON_STAKE_POOL_DEPOSIT_AND_STAKE_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        self.epoch_reconcilation();
        // after cleanup, there might be no need to stake
        if self.reconciled_epoch_stake_amount == 0 {
            log!("no need to stake, amount to settle is zero");
            return false;
        }

        let validator_to_stake_info =
            self.get_validator_to_stake(self.reconciled_epoch_stake_amount);
        require!(
            validator_to_stake_info.0.is_some(),
            ERROR_NO_VALIDATOR_AVAILABLE_TO_STAKE
        );

        let validator = validator_to_stake_info.0.unwrap();

        let amount_to_stake = validator_to_stake_info.1;

        log!("amount to stake is {:?}", amount_to_stake);

        require!(
            env::account_balance() >= amount_to_stake + self.min_storage_reserve,
            ERROR_MIN_BALANCE_FOR_CONTRACT_STORAGE
        );

        // update internal state
        self.reconciled_epoch_stake_amount = self
            .reconciled_epoch_stake_amount
            .checked_sub(amount_to_stake)
            .unwrap();

        // do staking on selected validator
        ext_staking_pool::ext(validator.account_id.clone())
            .with_attached_deposit(amount_to_stake)
            .with_static_gas(gas::ON_STAKE_POOL_DEPOSIT_AND_STAKE)
            .deposit_and_stake()
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_DEPOSIT_AND_STAKE_CB)
                    .on_stake_pool_deposit_and_stake(validator.account_id.clone(), amount_to_stake),
            );

        Event::StakingEpochAttempt {
            validator_id: validator.account_id,
            amount: U128(amount_to_stake),
        }
        .emit();

        true
    }

    #[private]
    pub fn on_stake_pool_deposit_and_stake(&mut self, validator: AccountId, amount: Balance) {
        let mut validator_info = self.internal_get_validator(&validator);
        if is_promise_success() {
            validator_info.staked += amount;

            Event::StakingEpochCallbackSuccess {
                validator_id: validator.clone(),
                amount: U128(amount),
            }
            .emit();
        } else {
            self.reconciled_epoch_stake_amount += amount;

            Event::StakingEpochCallbackFailed {
                validator_id: validator.clone(),
                amount: U128(amount),
            }
            .emit();
        }

        self.internal_update_validator(&validator, &validator_info);
    }

    pub fn autocompounding_epoch(&mut self, validator: AccountId) {
        self.assert_autocompounding_epoch_not_paused();

        let min_gas = gas::AUTOCOMPOUNDING_EPOCH
            + gas::ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE
            + gas::ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        let validator_info = self.internal_get_validator(&validator);

        let epoch_height = env::epoch_height();

        if validator_info.staked == 0 {
            return;
        }

        if validator_info.last_redeemed_rewards_epoch == epoch_height {
            return;
        }

        log!(
            "Fetching total balance from the staking pool {}",
            validator_info.account_id
        );

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_attached_deposit(NO_DEPOSIT)
            .with_static_gas(gas::ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE)
            .get_account_staked_balance(env::current_account_id())
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_GET_ACCOUNT_STAKED_BALANCE_CB)
                    .on_get_sp_staked_balance_for_rewards(validator_info),
            );

        Event::AutocompoundingEpochRewardsAttempt {
            validator_id: validator,
        }
        .emit();
    }

    #[private]
    pub fn on_get_sp_staked_balance_for_rewards(
        &mut self,
        #[allow(unused_mut)] mut validator_info: ValidatorInfo,
        #[callback] total_staked_balance: U128,
    ) -> PromiseOrValue<bool> {
        validator_info.last_redeemed_rewards_epoch = env::epoch_height();

        //new_total_balance has the new staked amount for this pool
        let new_total_balance = total_staked_balance.0;
        log!("total staked balance is {}", total_staked_balance.0);

        //compute rewards, as new balance minus old balance
        let rewards = new_total_balance.saturating_sub(validator_info.staked);

        log!(
            "validator account:{} old_balance:{} new_balance:{} rewards:{}",
            validator_info.account_id,
            validator_info.staked,
            new_total_balance,
            rewards
        );

        self.internal_update_validator(&validator_info.account_id, &validator_info);

        Event::AutocompoundingEpochRewards {
            validator_id: validator_info.account_id.clone(),
            old_balance: U128(validator_info.staked),
            new_balance: U128(new_total_balance),
            rewards: U128(rewards),
        }
        .emit();

        if rewards > 0 {
            //updated accumulated_staked_rewards value for the contract
            self.accumulated_staked_rewards += rewards;
            //updated new "staked" value for this pool
            validator_info.staked = new_total_balance;

            let operator_fee = rewards * self.rewards_fee;
            log!("operator fee is {}", operator_fee);
            self.total_staked += rewards;
            let treasury_account_shares =
                self.num_shares_from_staked_amount_rounded_down(operator_fee);

            self.internal_update_validator(&validator_info.account_id, &validator_info);

            if treasury_account_shares > 0 {
                // Mint shares for the treasury account
                let treasury_account_id = self.treasury_account_id.clone();
                let mut treasury_account = self.internal_get_account(&treasury_account_id);
                treasury_account.stake_shares += treasury_account_shares;
                self.total_stake_shares += treasury_account_shares;
                self.internal_update_account(&treasury_account_id, &treasury_account);

                PromiseOrValue::Value(true)
            } else {
                PromiseOrValue::Value(false)
            }
        } else {
            PromiseOrValue::Value(false)
        }
    }

    pub fn unstaking_epoch(&mut self) -> bool {
        self.assert_unstaking_epoch_not_paused();

        let min_gas =
            gas::UNSTAKING_EPOCH + gas::ON_STAKE_POOL_UNSTAKE + gas::ON_STAKE_POOL_UNSTAKE_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        self.epoch_reconcilation();

        // after cleanup, there might be no need to unstake
        if self.reconciled_epoch_unstake_amount == 0 {
            log!("No amount to unstake");
            return false;
        }

        let validator_to_unstake = self.get_validator_to_unstake();

        require!(
            validator_to_unstake.is_some(),
            ERROR_NO_VALIDATOR_AVAILABLE_FOR_UNSTAKE
        );

        let mut validator_info = validator_to_unstake.unwrap();

        let amount_to_unstake =
            std::cmp::min(validator_info.staked, self.reconciled_epoch_unstake_amount);

        require!(
            amount_to_unstake <= validator_info.staked,
            ERROR_CANNOT_UNSTAKED_MORE_THAN_STAKED_AMOUNT
        );

        self.reconciled_epoch_unstake_amount -= amount_to_unstake;
        validator_info.staked -= amount_to_unstake;
        validator_info.last_unstake_start_epoch = validator_info.unstake_start_epoch;
        validator_info.unstake_start_epoch = env::epoch_height();

        self.internal_update_validator(&validator_info.account_id, &validator_info);

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::ON_STAKE_POOL_UNSTAKE)
            .with_attached_deposit(NO_DEPOSIT)
            .unstake(U128(amount_to_unstake))
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_UNSTAKE_CB)
                    .on_stake_pool_unstake(validator_info.account_id.clone(), amount_to_unstake),
            );

        Event::UnstakingEpochAttempt {
            validator_id: validator_info.account_id,
            amount: U128(amount_to_unstake),
        }
        .emit();

        true
    }

    #[private]
    pub fn on_stake_pool_unstake(&mut self, validator_id: AccountId, amount_to_unstake: u128) {
        let mut validator = self.internal_get_validator(&validator_id);

        if is_promise_success() {
            validator.unstaked_amount += amount_to_unstake;

            Event::UnstakingEpochCallbackSuccess {
                validator_id: validator_id.clone(),
                amount: U128(amount_to_unstake),
            }
            .emit();
        } else {
            self.reconciled_epoch_unstake_amount += amount_to_unstake;
            validator.staked += amount_to_unstake;
            validator.unstake_start_epoch = validator.last_unstake_start_epoch;

            Event::UnstakingEpochCallbackFailed {
                validator_id: validator_id.clone(),
                amount: U128(amount_to_unstake),
            }
            .emit();
        }

        self.internal_update_validator(&validator_id, &validator);
    }

    pub fn withdraw_epoch(&mut self, validator: AccountId) {
        self.assert_epoch_withdraw_not_paused();

        // make sure enough gas was given
        let min_gas = gas::WITHDRAW_EPOCH
            + gas::ON_STAKE_POOL_WITHDRAW_ALL
            + gas::ON_STAKE_POOL_WITHDRAW_ALL_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        let mut validator_info = self.internal_get_validator(&validator);

        // If we run epoch_withdraw before drain_withdraw for a validator, we will loose the drained funds.
        // So don't run epoch_withdraw for a paused validator
        require!(!validator_info.paused(), ERROR_VALIDATOR_IS_PAUSED);

        require!(
            validator_info.unstaked_amount > 0,
            ERROR_NON_POSITIVE_UNSTAKE_AMOUNT
        );

        require!(
            !validator_info.pending_unstake_release(),
            ERROR_VALIDATOR_UNSTAKE_STILL_UNBONDING
        );

        let amount = validator_info.unstaked_amount;

        validator_info.unstaked_amount -= amount;

        self.internal_update_validator(&validator, &validator_info);

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::ON_STAKE_POOL_WITHDRAW_ALL)
            .with_attached_deposit(NO_DEPOSIT)
            .withdraw(U128(amount))
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_WITHDRAW_ALL_CB)
                    .on_stake_pool_withdraw_all(validator_info, amount),
            );

        Event::WithdrawEpochAttempt {
            validator_id: validator,
            amount: U128(amount),
        }
        .emit();
    }

    #[private]
    pub fn on_stake_pool_withdraw_all(&mut self, validator_info: ValidatorInfo, amount: u128) {
        if !is_promise_success() {
            let mut validator_info = self.internal_get_validator(&validator_info.account_id);
            validator_info.unstaked_amount += amount;
            self.internal_update_validator(&validator_info.account_id, &validator_info);

            Event::WithdrawEpochCallbackFailed {
                validator_id: validator_info.account_id,
                amount: U128(amount),
            }
            .emit();
        } else {
            Event::WithdrawEpochCallbackSuccess {
                validator_id: validator_info.account_id,
                amount: U128(amount),
            }
            .emit();
        }
    }

    pub fn sync_balance_from_validator(&mut self, validator_id: AccountId) {
        self.assert_sync_validator_balance_not_paused();

        let min_gas = gas::SYNC_VALIDATOR_EPOCH
            + gas::ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE
            + gas::ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        let validator_info = self.internal_get_validator(&validator_id);

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE)
            .with_attached_deposit(NO_DEPOSIT)
            .get_account(env::current_account_id())
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_GET_ACCOUNT_TOTAL_BALANCE_CB)
                    .on_stake_pool_get_account(validator_info.account_id),
            );

        Event::BalanceSyncedFromValidatorAttempt { validator_id }.emit();
    }

    #[private]
    pub fn on_stake_pool_get_account(
        &mut self,
        validator_id: AccountId,
        #[callback] account: HumanReadableAccount,
    ) {
        let mut validator = self.internal_get_validator(&validator_id);

        let new_total_balance = account.staked_balance.0 + account.unstaked_balance.0;
        require!(
            abs_diff_eq(new_total_balance, validator.total_balance(), 10000),
            ERROR_VALIDATOR_TOTAL_BALANCE_OUT_OF_SYNC
        );

        require!(
            abs_diff_eq(account.staked_balance.0, validator.staked, 5000),
            ERROR_VALIDATOR_STAKED_BALANCE_OUT_OF_SYNC
        );
        require!(
            abs_diff_eq(account.unstaked_balance.0, validator.unstaked_amount, 5000),
            ERROR_VALIDATOR_UNSTAKED_BALANCE_OUT_OF_SYNC
        );

        Event::BalanceSyncedFromValidator {
            validator_id: validator_id.clone(),
            old_staked_balance: U128(validator.staked),
            old_unstaked_balance: U128(validator.unstaked_amount),
            staked_balance: account.staked_balance,
            unstaked_balance: account.unstaked_balance,
        }
        .emit();

        // update balance
        validator.staked = account.staked_balance.0;
        validator.unstaked_amount = account.unstaked_balance.0;

        self.internal_update_validator(&validator_id, &validator);
    }

    #[private]
    pub fn epoch_reconcilation(&mut self) {
        if self.last_reconcilation_epoch == env::epoch_height() {
            return;
        }
        self.last_reconcilation_epoch = env::epoch_height();

        // here we use += because cleanup amount might not be 0
        self.reconciled_epoch_stake_amount += self.user_amount_to_stake_in_epoch;
        self.reconciled_epoch_unstake_amount += self.user_amount_to_unstake_in_epoch;
        self.user_amount_to_stake_in_epoch = 0;
        self.user_amount_to_unstake_in_epoch = 0;

        let reconciled_stake_amount = self
            .reconciled_epoch_stake_amount
            .saturating_sub(self.reconciled_epoch_unstake_amount);
        let mut reconciled_unstake_amount = self
            .reconciled_epoch_unstake_amount
            .saturating_sub(self.reconciled_epoch_stake_amount);

        // while unstaking first drain the unstaked from the rewards_buffer and then from the validators
        if reconciled_unstake_amount > self.rewards_buffer {
            reconciled_unstake_amount =
                reconciled_unstake_amount.saturating_sub(self.rewards_buffer);
            self.rewards_buffer = 0;
        } else {
            self.rewards_buffer = self
                .rewards_buffer
                .saturating_sub(reconciled_unstake_amount);
            reconciled_unstake_amount = 0;
        }

        self.reconciled_epoch_stake_amount = reconciled_stake_amount;
        self.reconciled_epoch_unstake_amount = reconciled_unstake_amount;

        Event::EpochReconcile {
            actual_epoch_stake_amount: U128(self.user_amount_to_stake_in_epoch),
            actual_epoch_unstake_amount: U128(self.user_amount_to_unstake_in_epoch),
            reconciled_stake_amount: U128(self.reconciled_epoch_stake_amount),
            reconciled_unstake_amount: U128(self.reconciled_epoch_unstake_amount),
        }
        .emit();
    }

    pub fn drain_unstake(&mut self, validator: AccountId) {
        self.assert_operator_or_owner();

        let min_gas =
            gas::DRAIN_UNSTAKE + gas::ON_STAKE_POOL_UNSTAKE + gas::ON_STAKE_POOL_UNSTAKE_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        let mut validator_info = self.internal_get_validator(&validator);

        // make sure the validator:
        // 1. has been paused
        // 2. not in pending release
        // 3. has not unstaked balance (because this part is from user's unstake request)
        require!(validator_info.paused(), ERROR_VALIDATOR_NOT_PAUSED);
        require!(
            !validator_info.pending_unstake_release(),
            ERROR_VALIDATOR_UNSTAKE_STILL_UNBONDING
        );
        // we have not unstaked.
        require!(
            validator_info.unstaked_amount == 0,
            ERROR_NON_POSITIVE_UNSTAKE_AMOUNT
        );

        let amount_to_unstake = validator_info.staked;

        validator_info.staked -= amount_to_unstake;
        validator_info.last_unstake_start_epoch = validator_info.unstake_start_epoch;
        validator_info.unstake_start_epoch = env::epoch_height();

        self.internal_update_validator(&validator, &validator_info);

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::ON_STAKE_POOL_UNSTAKE)
            .with_attached_deposit(NO_DEPOSIT)
            .unstake(U128(amount_to_unstake))
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_UNSTAKE_CB)
                    .on_stake_pool_drain_unstake(
                        validator_info.account_id.clone(),
                        amount_to_unstake,
                    ),
            );
        Event::DrainUnstake {
            account_id: validator,
            amount: U128(amount_to_unstake),
        }
        .emit();
    }

    #[private]
    pub fn on_stake_pool_drain_unstake(
        &mut self,
        validator_id: AccountId,
        amount_to_unstake: u128,
    ) {
        let mut validator = self.internal_get_validator(&validator_id);

        if is_promise_success() {
            validator.unstaked_amount += amount_to_unstake;

            Event::DrainUnstakeCallbackSuccess {
                validator_id: validator_id.clone(),
                amount: U128(amount_to_unstake),
            }
            .emit();
        } else {
            validator.staked += amount_to_unstake;
            validator.unstake_start_epoch = validator.last_unstake_start_epoch;

            Event::DrainUnstakeCallbackFail {
                validator_id: validator_id.clone(),
                amount: U128(amount_to_unstake),
            }
            .emit();
        }

        self.internal_update_validator(&validator_id, &validator);
    }

    /// Withdraw from a drained validator
    pub fn drain_withdraw(&mut self, validator: AccountId) {
        self.assert_operator_or_owner();

        // make sure enough gas was given
        let min_gas = gas::DRAIN_WITHDRAW
            + gas::ON_STAKE_POOL_WITHDRAW_ALL
            + gas::ON_STAKE_POOL_WITHDRAW_ALL_CB;
        require!(
            env::prepaid_gas() >= min_gas,
            format!("{}. require at least {:?}", ERROR_NOT_ENOUGH_GAS, min_gas)
        );

        let mut validator_info = self.internal_get_validator(&validator);

        // make sure the validator:
        // 1. has weight set to 0
        // 2. has no staked balance
        // 3. not pending release
        require!(validator_info.paused(), ERROR_VALIDATOR_NOT_PAUSED);
        require!(validator_info.staked == 0, ERROR_NON_POSITIVE_STAKE_AMOUNT);
        require!(
            !validator_info.pending_unstake_release(),
            ERROR_VALIDATOR_UNSTAKE_STILL_UNBONDING
        );

        let amount = validator_info.unstaked_amount;
        validator_info.unstaked_amount -= amount;

        self.internal_update_validator(&validator, &validator_info);

        ext_staking_pool::ext(validator_info.account_id.clone())
            .with_static_gas(gas::ON_STAKE_POOL_WITHDRAW_ALL)
            .with_attached_deposit(NO_DEPOSIT)
            .withdraw(U128(amount))
            .then(
                ext_staking_pool_callback::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::ON_STAKE_POOL_WITHDRAW_ALL_CB)
                    .on_stake_pool_drain_withdraw(validator_info.account_id, amount),
            );
        Event::DrainWithdraw {
            validator_id: validator,
            amount: U128(amount),
        }
        .emit();
    }

    #[private]
    pub fn on_stake_pool_drain_withdraw(
        &mut self,
        validator_id: AccountId,
        amount_to_withdraw: u128,
    ) {
        let mut validator_info = self.internal_get_validator(&validator_id);

        if is_promise_success() {
            // stake the drained amount into the next epoch
            self.user_amount_to_stake_in_epoch += amount_to_withdraw;

            Event::DrainWithdrawCallbackSuccess {
                validator_id,
                amount: U128(amount_to_withdraw),
            }
            .emit();
        } else {
            validator_info.unstaked_amount += amount_to_withdraw;
            self.internal_update_validator(&validator_id, &validator_info);

            Event::DrainWithdrawCallbackFail {
                validator_id,
                amount: U128(amount_to_withdraw),
            }
            .emit();
        }
    }
}

'''
'''--- contracts/near-x/src/contract/public.rs ---
use crate::constants::{ACCOUNTS_MAP, REWARD_FEE_SET_WAIT_TIME, VALIDATOR_MAP};
use crate::errors::*;
use crate::events::Event;
use crate::{contract::*, state::*};
use near_sdk::json_types::U64;
use near_sdk::near_bindgen;
use near_sdk::{assert_one_yocto, require, ONE_NEAR};

#[near_bindgen]
impl NearxPool {
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        operator_account_id: AccountId,
        treasury_account_id: AccountId,
    ) -> Self {
        require!(
            owner_account_id != operator_account_id,
            ERROR_OWNER_OPERATOR_SAME
        );
        require!(
            owner_account_id != treasury_account_id,
            ERROR_OWNER_TREASURY_SAME
        );
        require!(
            operator_account_id != treasury_account_id,
            ERROR_OPERATOR_TREASURY_SAME
        );
        require!(
            operator_account_id != env::current_account_id(),
            ERROR_OPERATOR_CURRENT_CONTRACT_SAME
        );
        require!(
            treasury_account_id != env::current_account_id(),
            ERROR_TREASURY_CURRENT_CONTRACT_SAME
        );
        require!(
            owner_account_id != env::current_account_id(),
            ERROR_OWNER_CURRENT_CONTRACT_SAME
        );

        Self {
            owner_account_id,
            operator_account_id,
            accumulated_staked_rewards: 0,
            user_amount_to_stake_in_epoch: 0,
            user_amount_to_unstake_in_epoch: 0,
            reconciled_epoch_stake_amount: 0,
            reconciled_epoch_unstake_amount: 0,
            total_stake_shares: 0,
            accounts: UnorderedMap::new(ACCOUNTS_MAP.as_bytes()),
            min_deposit_amount: ONE_NEAR,
            validator_info_map: UnorderedMap::new(VALIDATOR_MAP.as_bytes()),
            total_staked: 0,
            rewards_fee: Fraction::new(0, 1),
            last_reconcilation_epoch: 0,
            temp_owner: None,
            temp_operator: None,
            temp_treasury: None,
            temp_reward_fee: None,
            last_reward_fee_set_epoch: 0,
            operations_control: OperationControls {
                stake_paused: false,
                unstaked_paused: false,
                withdraw_paused: false,
                staking_epoch_paused: false,
                unstaking_epoch_paused: false,
                withdraw_epoch_paused: false,
                autocompounding_epoch_paused: false,
                sync_validator_balance_paused: false,
                ft_transfer_paused: false,
                ft_transfer_call_paused: false,
            },
            treasury_account_id,
            total_validator_weight: 0,
            rewards_buffer: 0,
            accumulated_rewards_buffer: 0,
            min_storage_reserve: 0,
        }
    }

    /*
       Main staking pool api
    */
    #[payable]
    pub fn update_rewards_buffer(&mut self) {
        self.assert_operator_or_owner();
        self.internal_update_rewards_buffer(env::attached_deposit())
    }

    #[payable]
    pub fn manager_deposit_and_stake(&mut self, validator: AccountId) {
        self.assert_owner_calling();
        self.internal_manager_deposit_and_stake(env::attached_deposit(), validator);
    }

    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_deposit_and_stake(env::attached_deposit());
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.internal_unstake(amount);
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        let amount: Balance = amount.into();
        self.internal_unstake(amount);
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked_amount);
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let amount: Balance = amount.into();
        self.internal_withdraw(amount);
    }

    /*
       Validator pool addition and deletion
    */
    #[payable]
    pub fn pause_validator(&mut self, validator: AccountId) {
        self.assert_operator_or_owner();
        assert_one_yocto();

        let mut validator_info = self.internal_get_validator(&validator);

        // Need to check for this as drain_withdraw and epoch_withdraw are not the same
        // drain_withdraw places the withdrawn amount back to the batched deposit
        require!(
            !validator_info.pending_unstake_release(),
            ERROR_VALIDATOR_UNSTAKE_STILL_UNBONDING
        );

        let current_validator_weight = validator_info.weight;
        self.total_validator_weight -= current_validator_weight;
        validator_info.weight = 0;
        self.internal_update_validator(&validator, &validator_info);

        Event::ValidatorPaused {
            account_id: validator,
            old_weight: current_validator_weight,
        }
        .emit();
    }

    #[payable]
    pub fn remove_validator(&mut self, validator: AccountId) {
        self.assert_operator_or_owner();
        assert_one_yocto();

        let validator_info = self.internal_get_validator(&validator);

        require!(validator_info.is_empty(), ERROR_INVALID_VALIDATOR_REMOVAL);

        self.total_validator_weight -= validator_info.weight;
        self.validator_info_map.remove(&validator);

        Event::ValidatorRemoved {
            account_id: validator,
        }
        .emit();
    }

    #[payable]
    pub fn add_validator(&mut self, validator: AccountId, weight: u16) {
        self.assert_operator_or_owner();
        assert_one_yocto();
        if self.validator_info_map.get(&validator).is_some() {
            panic!("{}", ERROR_VALIDATOR_IS_ALREADY_PRESENT);
        }
        self.validator_info_map
            .insert(&validator, &ValidatorInfo::new(validator.clone(), weight));
        self.total_validator_weight += weight;

        Event::ValidatorAdded {
            account_id: validator,
            weight,
        }
        .emit();
    }

    #[payable]
    pub fn update_validator(&mut self, validator: AccountId, weight: u16) {
        self.assert_operator_or_owner();
        assert_one_yocto();
        let mut validator_info = self
            .validator_info_map
            .get(&validator)
            .expect(ERROR_VALIDATOR_DOES_NOT_EXIST);

        if weight == 0 {
            require!(false, ERROR_INVALID_VALIDATOR_WEIGHT);
        }

        // update total weight
        self.total_validator_weight = self.total_validator_weight + weight - validator_info.weight;
        validator_info.weight = weight;
        self.validator_info_map.insert(&validator, &validator_info);

        Event::ValidatorUpdated {
            account_id: validator,
            weight,
        }
        .emit();
    }

    // Owner update methods
    #[payable]
    pub fn set_owner(&mut self, new_owner: AccountId) {
        assert_one_yocto();
        self.assert_owner_calling();

        // owner, operator, treasury and current contract address should all be different
        require!(
            new_owner != self.operator_account_id,
            ERROR_OWNER_OPERATOR_SAME
        );
        require!(
            new_owner != self.treasury_account_id,
            ERROR_OWNER_TREASURY_SAME
        );
        require!(new_owner != self.owner_account_id, ERROR_OWNER_SAME);
        require!(
            new_owner != env::current_account_id(),
            ERROR_OWNER_CURRENT_CONTRACT_SAME
        );

        self.temp_owner = Some(new_owner.clone());
        Event::SetOwner {
            old_owner: self.owner_account_id.clone(),
            new_owner,
        }
        .emit();
    }

    #[payable]
    pub fn commit_owner(&mut self) {
        assert_one_yocto();

        if let Some(temp_owner) = self.temp_owner.clone() {
            require!(
                env::predecessor_account_id() == temp_owner,
                ERROR_UNAUTHORIZED
            );
            self.owner_account_id = self.temp_owner.as_ref().unwrap().clone();
            self.temp_owner = None;
            Event::CommitOwner {
                new_owner: self.owner_account_id.clone(),
                caller: env::predecessor_account_id(),
            }
            .emit();
        } else {
            require!(false, ERROR_TEMP_OWNER_NOT_SET);
        }
    }

    #[payable]
    pub fn set_operator_id(&mut self, new_operator_account_id: AccountId) {
        assert_one_yocto();
        self.assert_owner_calling();

        // owner, operator, treasury and current contract address should all be different
        require!(
            new_operator_account_id != self.operator_account_id,
            ERROR_OPERATOR_SAME
        );
        require!(
            new_operator_account_id != self.treasury_account_id,
            ERROR_OPERATOR_TREASURY_SAME
        );
        require!(
            new_operator_account_id != self.owner_account_id,
            ERROR_OPERATOR_OWNER_SAME
        );
        require!(
            new_operator_account_id != env::current_account_id(),
            ERROR_OPERATOR_CURRENT_CONTRACT_SAME
        );

        Event::SetOperator {
            old_operator: self.operator_account_id.clone(),
            new_operator: new_operator_account_id.clone(),
        }
        .emit();

        self.temp_operator = Some(new_operator_account_id);
    }

    #[payable]
    pub fn commit_operator_id(&mut self) {
        assert_one_yocto();

        if let Some(temp_operator) = self.temp_operator.clone() {
            require!(
                env::predecessor_account_id() == temp_operator,
                ERROR_UNAUTHORIZED
            );
            self.operator_account_id = temp_operator;
            self.temp_operator = None;

            Event::CommitOperator {
                new_operator: self.operator_account_id.clone(),
            }
            .emit();
        } else {
            require!(false, ERROR_TEMP_OPERATOR_NOT_SET);
        }
    }

    #[payable]
    pub fn set_treasury_id(&mut self, new_treasury_account_id: AccountId) {
        assert_one_yocto();
        self.assert_owner_calling();

        // owner, operator, treasury and current contract address should all be different
        require!(
            new_treasury_account_id != self.operator_account_id,
            ERROR_TREASURY_OPERATOR_SAME
        );
        require!(
            new_treasury_account_id != self.treasury_account_id,
            ERROR_TREASURY_SAME
        );
        require!(
            new_treasury_account_id != self.owner_account_id,
            ERROR_TREASURY_OWNER_SAME
        );
        require!(
            new_treasury_account_id != env::current_account_id(),
            ERROR_TREASURY_CURRENT_CONTRACT_SAME
        );

        Event::SetTreasury {
            old_treasury_account: self.treasury_account_id.clone(),
            new_treasury_account: new_treasury_account_id.clone(),
        }
        .emit();

        self.temp_treasury = Some(new_treasury_account_id);
    }

    #[payable]
    pub fn commit_treasury_id(&mut self) {
        assert_one_yocto();

        if let Some(temp_treasury) = self.temp_treasury.clone() {
            require!(
                env::predecessor_account_id() == temp_treasury,
                ERROR_UNAUTHORIZED
            );
            self.treasury_account_id = temp_treasury;
            self.temp_treasury = None;

            Event::CommitTreasury {
                new_treasury_account: self.treasury_account_id.clone(),
            }
            .emit();
        } else {
            require!(false, ERROR_TEMP_TREASURY_NOT_SET);
        }
    }

    #[payable]
    pub fn update_operations_control(
        &mut self,
        update_operations_control_request: OperationsControlUpdateRequest,
    ) {
        assert_one_yocto();
        self.assert_owner_calling();

        self.operations_control.stake_paused = update_operations_control_request
            .stake_paused
            .unwrap_or(self.operations_control.stake_paused);
        self.operations_control.unstaked_paused = update_operations_control_request
            .unstake_paused
            .unwrap_or(self.operations_control.unstaked_paused);
        self.operations_control.withdraw_paused = update_operations_control_request
            .withdraw_paused
            .unwrap_or(self.operations_control.withdraw_paused);
        self.operations_control.staking_epoch_paused = update_operations_control_request
            .staking_epoch_paused
            .unwrap_or(self.operations_control.staking_epoch_paused);
        self.operations_control.unstaking_epoch_paused = update_operations_control_request
            .unstaking_epoch_paused
            .unwrap_or(self.operations_control.unstaking_epoch_paused);
        self.operations_control.withdraw_epoch_paused = update_operations_control_request
            .withdraw_epoch_paused
            .unwrap_or(self.operations_control.withdraw_epoch_paused);
        self.operations_control.autocompounding_epoch_paused = update_operations_control_request
            .autocompounding_epoch_paused
            .unwrap_or(self.operations_control.autocompounding_epoch_paused);
        self.operations_control.sync_validator_balance_paused = update_operations_control_request
            .sync_validator_balance_paused
            .unwrap_or(self.operations_control.sync_validator_balance_paused);
        self.operations_control.ft_transfer_paused = update_operations_control_request
            .ft_transfer_paused
            .unwrap_or(self.operations_control.ft_transfer_paused);
        self.operations_control.ft_transfer_call_paused = update_operations_control_request
            .ft_transfer_call_paused
            .unwrap_or(self.operations_control.ft_transfer_call_paused);

        Event::UpdateOperationsControl {
            operations_control: OperationControls {
                stake_paused: self.operations_control.stake_paused,
                unstaked_paused: self.operations_control.unstaked_paused,
                withdraw_paused: self.operations_control.withdraw_paused,
                staking_epoch_paused: self.operations_control.staking_epoch_paused,
                unstaking_epoch_paused: self.operations_control.unstaking_epoch_paused,
                withdraw_epoch_paused: self.operations_control.withdraw_epoch_paused,
                autocompounding_epoch_paused: self.operations_control.autocompounding_epoch_paused,
                sync_validator_balance_paused: self
                    .operations_control
                    .sync_validator_balance_paused,
                ft_transfer_paused: self.operations_control.ft_transfer_paused,
                ft_transfer_call_paused: self.operations_control.ft_transfer_call_paused,
            },
        }
        .emit();
    }

    #[payable]
    pub fn add_min_storage_reserve(&mut self) {
        self.assert_min_deposit_amount(env::attached_deposit());

        self.min_storage_reserve += env::attached_deposit();
    }

    #[payable]
    pub fn set_reward_fee(&mut self, numerator: u32, denominator: u32) {
        self.assert_owner_calling();
        assert_one_yocto();
        require!(numerator * 10 <= denominator); // less than or equal to 10%

        let old_reward_fee = self.rewards_fee;
        let future_reward_fee = Fraction::new(numerator, denominator);
        self.temp_reward_fee = Some(future_reward_fee);
        self.last_reward_fee_set_epoch = env::epoch_height();

        Event::SetRewardFee {
            old_reward_fee,
            new_reward_fee: future_reward_fee,
        }
        .emit();
    }

    // Don't immediaitely set the rewards, wait for 4 epochs and then set the rewards to allow
    // users to opt out if they feel that the reward fee is too high
    #[payable]
    pub fn commit_reward_fee(&mut self) {
        self.assert_owner_calling();
        assert_one_yocto();

        if self.temp_reward_fee.is_some() {
            require!(
                self.last_reward_fee_set_epoch + REWARD_FEE_SET_WAIT_TIME <= env::epoch_height(),
                ERROR_TEMP_REWARD_FEE_SET_IN_WAIT_PERIOD
            );

            self.rewards_fee = self.temp_reward_fee.unwrap();
            self.temp_reward_fee = None;

            Event::CommitRewardFee {
                commited_reward_fee: self.rewards_fee,
            }
            .emit();
        } else {
            require!(false, ERROR_TEMP_REWARD_FEE_IS_NOT_SET);
        }
    }

    #[payable]
    pub fn set_min_deposit(&mut self, min_deposit: U128) {
        self.assert_owner_calling();
        assert_one_yocto();

        require!(min_deposit > U128(ONE_NEAR), ERROR_MIN_DEPOSIT_TOO_LOW);
        require!(
            min_deposit < U128(100 * ONE_NEAR),
            ERROR_MIN_DEPOSIT_TOO_HIGH
        );

        let old_min_deposit = self.min_deposit_amount;
        self.min_deposit_amount = min_deposit.0;

        Event::SetMinDeposit {
            old_min_deposit: U128(old_min_deposit),
            new_min_deposit: U128(self.min_deposit_amount),
        }
        .emit();
    }

    // View methods

    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let acc = self.internal_get_account(&account_id);
        self.staked_amount_from_num_shares_rounded_down(acc.stake_shares)
            .into()
    }

    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    pub fn get_owner_id(&self) -> AccountId {
        self.owner_account_id.clone()
    }

    pub fn get_reward_fee_fraction(&self) -> Fraction {
        self.rewards_fee
    }

    pub fn is_staking_paused(&self) -> bool {
        self.operations_control.stake_paused
    }

    pub fn get_total_staked_balance(&self) -> U128 {
        U128::from(self.total_staked)
    }

    pub fn get_staking_key(&self) -> PublicKey {
        panic!("{}", ERROR_NO_STAKING_KEY);
    }

    pub fn get_roles(&self) -> RolesResponse {
        RolesResponse {
            treasury_account: self.treasury_account_id.clone(),
            operator_account: self.operator_account_id.clone(),
            owner_account: self.owner_account_id.clone(),
            temp_owner: self.temp_owner.clone(),
            temp_operator: self.temp_operator.clone(),
            temp_treasury: self.temp_treasury.clone(),
        }
    }

    pub fn get_operations_control(&self) -> OperationControls {
        self.operations_control
    }

    pub fn get_user_account(&self, account_id: AccountId) -> AccountResponse {
        let account = self.internal_get_account(&account_id);
        AccountResponse {
            account_id,
            unstaked_balance: U128(account.unstaked_amount),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            withdrawable_epoch: U64(account.withdrawable_epoch_height),
        }
    }

    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: U128(account.unstaked_amount),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.withdrawable_epoch_height <= env::epoch_height(),
        }
    }

    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    pub fn get_snapshot_users(&self, from: usize, length: usize) -> Vec<SnapshotUser> {
        self.accounts
            .keys_as_vector()
            .iter()
            .skip(from)
            .take(length)
            .map(|account_id| SnapshotUser {
                account_id: account_id.clone(),
                nearx_balance: U128(self.internal_get_account(&account_id).stake_shares),
            })
            .collect()
    }

    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    pub fn get_storage_usage(&self) -> U64 {
        U64(env::storage_usage())
    }

    // Contract state query
    pub fn get_nearx_pool_state(&self) -> NearxPoolStateResponse {
        NearxPoolStateResponse {
            owner_account_id: self.owner_account_id.clone(),
            total_staked: U128::from(self.total_staked),
            total_stake_shares: U128::from(self.total_stake_shares),
            accumulated_staked_rewards: U128::from(self.accumulated_staked_rewards),
            min_deposit_amount: U128::from(self.min_deposit_amount),
            operator_account_id: self.operator_account_id.clone(),
            rewards_fee_pct: self.rewards_fee,
            user_amount_to_stake_in_epoch: U128(self.user_amount_to_stake_in_epoch),
            user_amount_to_unstake_in_epoch: U128(self.user_amount_to_unstake_in_epoch),
            reconciled_epoch_stake_amount: U128(self.reconciled_epoch_stake_amount),
            reconciled_epoch_unstake_amount: U128(self.reconciled_epoch_unstake_amount),
            last_reconcilation_epoch: U64(self.last_reconcilation_epoch),
            temp_reward_fee: self.temp_reward_fee,
            rewards_buffer: U128(self.rewards_buffer),
            accumulated_rewards_buffer: U128(self.accumulated_rewards_buffer),
            last_reward_fee_set_epoch: self.last_reward_fee_set_epoch,
            min_storage_reserve: U128(self.min_storage_reserve),
        }
    }

    pub fn get_nearx_price(&self) -> U128 {
        if self.total_staked == 0 || self.total_stake_shares == 0 {
            return U128(ONE_NEAR);
        }

        let amount = self.staked_amount_from_num_shares_rounded_down(ONE_NEAR);
        if amount == 0 {
            U128(ONE_NEAR)
        } else {
            U128(amount)
        }
    }

    pub fn get_validator_info(&self, validator: AccountId) -> ValidatorInfoResponse {
        let validator_info = if let Some(val_info) = self.validator_info_map.get(&validator) {
            val_info
        } else {
            ValidatorInfo::new(validator, 0)
        };

        ValidatorInfoResponse {
            account_id: validator_info.account_id.clone(),
            staked: validator_info.staked.into(),
            unstaked: U128(validator_info.unstaked_amount),
            weight: validator_info.weight,
            last_asked_rewards_epoch_height: validator_info.last_redeemed_rewards_epoch.into(),
            last_unstake_start_epoch: U64(validator_info.unstake_start_epoch),
        }
    }

    pub fn get_validators(&self) -> Vec<ValidatorInfoResponse> {
        self.validator_info_map
            .iter()
            .map(|pool| ValidatorInfoResponse {
                account_id: pool.1.account_id.clone(),
                staked: U128::from(pool.1.staked),
                last_asked_rewards_epoch_height: U64(pool.1.last_redeemed_rewards_epoch),
                last_unstake_start_epoch: U64(pool.1.unstake_start_epoch),
                unstaked: U128(pool.1.unstaked_amount),
                weight: pool.1.weight,
            })
            .collect()
    }

    pub fn get_total_validator_weight(&self) -> u16 {
        self.total_validator_weight
    }

    pub fn is_validator_unstake_pending(&self, validator: AccountId) -> bool {
        let validator_info = self.internal_get_validator(&validator);

        validator_info.pending_unstake_release()
    }

    pub fn get_current_epoch(&self) -> U64 {
        U64(env::epoch_height())
    }

    pub fn get_contract_summary(&self) -> ContractSummary {
        let treasury_account = self.get_account(self.treasury_account_id.clone());

        ContractSummary {
            total_staked: U128(self.total_staked),
            total_shares: U128(self.total_stake_shares),
            total_validators: U128(self.validator_info_map.len() as u128),
            treasury_staked_balance: treasury_account.staked_balance,
            treasury_unstaked_balance: treasury_account.unstaked_balance,
            nearx_price: self.get_nearx_price(),
        }
    }

    pub fn get_near_from_nearx(&self, nearx_amount: U128) -> U128 {
        U128(self.staked_amount_from_num_shares_rounded_down(nearx_amount.0))
    }
}

'''
'''--- contracts/near-x/src/contract/storage_spec.rs ---
use crate::contract::*;
use crate::state::Account;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::{assert_one_yocto, env, log, AccountId, Balance, Promise};

/// Fixed amount of storage bytes. The contract is light weight in terms of storage amount.
/// The below storage spec should cover all storage needs of the contract
const STORAGE_AMOUNT_BYTES: usize = 250;

impl NearxPool {
    pub(crate) fn internal_storage_balance_of(
        &self,
        account_id: &AccountId,
    ) -> Option<StorageBalance> {
        if self.accounts.get(account_id).is_some() {
            Some(StorageBalance {
                total: self.storage_balance_bounds().min,
                available: 0.into(),
            })
        } else {
            None
        }
    }

    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self
            .accounts
            .insert(account_id, &Account::default())
            .is_some()
        {
            env::panic_str("The account is already registered");
        }
    }
}

#[allow(unused_variables)]
#[near_bindgen]
impl StorageManagement for NearxPool {
    // `registration_only` doesn't affect the implementation for vanilla fungible token.
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        if let Some(account) = self.accounts.get(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            self.internal_register_account(&account_id);
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    /// While storage_withdraw normally allows the caller to retrieve `available` balance, the basic
    /// Fungible Token implementation sets storage_balance_bounds.min == storage_balance_bounds.max,
    /// which means available balance will always be 0. So this implementation:
    /// * panics if `amount > 0`
    /// * never transfers  to caller
    /// * returns a `storage_balance` struct if `amount` is 0
    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let predecessor_account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&predecessor_account_id) {
            match amount {
                Some(amount) if amount.0 > 0 => {
                    env::panic_str("The amount is greater than the available storage balance");
                }
                _ => storage_balance,
            }
        } else {
            env::panic_str(
                format!("The account {} is not registered", &predecessor_account_id).as_str(),
            );
        }
    }

    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();

        if let Some(f) = force {
            if f {
                panic!("We don't support force unregister");
            }
        }

        let account_id = env::predecessor_account_id();

        if self.accounts.get(&account_id).is_none() {
            return false;
        }

        let account = self.internal_get_account(&account_id);

        // if account registered check if amount staked and unstaked is 0
        if account.is_empty() {
            self.accounts.remove(&account_id);
        } else {
            panic!("Account is not empty!");
        }

        true
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        let required_storage_balance = STORAGE_AMOUNT_BYTES as Balance * env::storage_byte_cost();
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(&account_id)
    }
}

'''
'''--- contracts/near-x/src/contract/upgrade.rs ---
use crate::contract::*;
use near_sdk::*;

#[near_bindgen]
impl NearxPool {
    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old
    /// struct with different name to deserialize it first).
    /// After migration goes live, revert back to this implementation for next updates.
    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        let contract: LegacyNearxPoolV2 = env::state_read().expect("ERR_NOT_INITIALIZED");
        let new_contract: NearxPool = NearxPool {
            owner_account_id: contract.owner_account_id,
            total_staked: contract.total_staked,
            total_stake_shares: contract.total_stake_shares,
            accumulated_staked_rewards: contract.accumulated_staked_rewards,
            user_amount_to_stake_in_epoch: contract.user_amount_to_stake_in_epoch,
            user_amount_to_unstake_in_epoch: contract.user_amount_to_unstake_in_epoch,
            reconciled_epoch_stake_amount: contract.reconciled_epoch_stake_amount,
            reconciled_epoch_unstake_amount: contract.reconciled_epoch_unstake_amount,
            last_reconcilation_epoch: contract.last_reconcilation_epoch,
            accounts: contract.accounts,
            validator_info_map: contract.validator_info_map,
            total_validator_weight: contract.total_validator_weight,
            min_deposit_amount: contract.min_deposit_amount,
            operator_account_id: contract.operator_account_id,
            treasury_account_id: contract.treasury_account_id,
            rewards_fee: contract.rewards_fee,
            rewards_buffer: contract.rewards_buffer,
            accumulated_rewards_buffer: contract.accumulated_rewards_buffer,
            temp_owner: contract.temp_owner,
            temp_operator: contract.temp_operator,
            temp_treasury: contract.temp_treasury,
            temp_reward_fee: contract.temp_reward_fee,
            last_reward_fee_set_epoch: contract.last_reward_fee_set_epoch,
            operations_control: contract.operations_control,
            min_storage_reserve: 50 * ONE_NEAR,
        };
        env::state_write(&new_contract);
        new_contract
    }
}

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::Gas;
    use near_sys as sys;

    use super::*;

    /// Gas for completing the upgrade call
    pub const GAS_FOR_COMPLETING_UPGRADE_CALL: Gas = Gas(10 * 1_000_000_000_000);
    /// Minimum gas for calling state migration call. Please notice the gas cost will be higher
    /// if the number of accounts and validator pools grows.
    pub const MIN_GAS_FOR_MIGRATE_CALL: Gas = Gas(10 * 1_000_000_000_000);
    /// Gas for calling `get_summary` method
    pub const GAS_FOR_GET_SUMMARY_CALL: Gas = Gas(15 * 1_000_000_000_000);

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub fn upgrade() {
        env::setup_panic_hook();
        let contract: NearxPool = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_owner_calling();
        let current_id = env::current_account_id().as_bytes().to_vec();
        let migrate_method_name = b"migrate".to_vec();
        let get_summary_method_name = b"get_contract_summary".to_vec();
        unsafe {
            // Load input (wasm code) into register 0.
            sys::input(0);
            // Create batch action promise for the current contract ID
            let promise_id =
                sys::promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
            // 1st batch action in the Tx: "deploy contract" (code is taken from register 0)
            sys::promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
            // 2nd batch action in the Tx: call `migrate()` in the contract with sufficient gas
            let required_gas =
                env::used_gas() + GAS_FOR_COMPLETING_UPGRADE_CALL + GAS_FOR_GET_SUMMARY_CALL;
            require!(
                env::prepaid_gas() >= required_gas + MIN_GAS_FOR_MIGRATE_CALL,
                "Not enough gas to complete contract state migration"
            );
            let migrate_attached_gas = env::prepaid_gas() - required_gas;
            sys::promise_batch_action_function_call(
                promise_id,
                migrate_method_name.len() as _,
                migrate_method_name.as_ptr() as _,
                0 as _,
                0 as _,
                0 as _,
                migrate_attached_gas.0,
            );
            // 3rd batch action in the Tx: call `get_contract_summary()` in the contract to validate
            // the contract state. If the validation failed, the entire `upgrade()` method
            // will be rolled back. The `get_contract_summary()` view call will access most of the
            // states in the contract, so should guarantee the contract is working as expected
            sys::promise_batch_action_function_call(
                promise_id,
                get_summary_method_name.len() as _,
                get_summary_method_name.as_ptr() as _,
                0 as _,
                0 as _,
                0 as _,
                GAS_FOR_GET_SUMMARY_CALL.0,
            );
            sys::promise_return(promise_id);
        }
    }
}

'''
'''--- contracts/near-x/src/contract/util.rs ---
use crate::contract::NearxPool;
use crate::errors::*;
use near_sdk::{env, require};

impl NearxPool {
    /// Asserts that the method was called by the owner.
    pub fn assert_owner_calling(&self) {
        require!(
            env::predecessor_account_id() == self.owner_account_id,
            ERROR_UNAUTHORIZED
        )
    }

    pub fn assert_operator_or_owner(&self) {
        require!(
            env::predecessor_account_id() == self.owner_account_id
                || env::predecessor_account_id() == self.operator_account_id,
            ERROR_UNAUTHORIZED
        );
    }

    pub fn assert_min_deposit_amount(&self, amount: u128) {
        require!(amount >= self.min_deposit_amount, ERROR_MIN_DEPOSIT);
    }

    pub fn assert_staking_not_paused(&self) {
        require!(!self.operations_control.stake_paused, ERROR_STAKING_PAUSED);
    }

    pub fn assert_unstaking_not_paused(&self) {
        require!(
            !self.operations_control.unstaked_paused,
            ERROR_UNSTAKING_PAUSED
        );
    }

    pub fn assert_withdraw_not_paused(&self) {
        require!(
            !self.operations_control.withdraw_paused,
            ERROR_UNSTAKING_PAUSED
        );
    }

    pub fn assert_staking_epoch_not_paused(&self) {
        require!(
            !self.operations_control.staking_epoch_paused,
            ERROR_STAKING_EPOCH_PAUSED
        );
    }

    pub fn assert_unstaking_epoch_not_paused(&self) {
        require!(
            !self.operations_control.unstaking_epoch_paused,
            ERROR_UNSTAKING_EPOCH_PAUSED
        );
    }

    pub fn assert_epoch_withdraw_not_paused(&self) {
        require!(
            !self.operations_control.withdraw_epoch_paused,
            ERROR_WITHDRAW_EPOCH_PAUSED
        );
    }

    pub fn assert_autocompounding_epoch_not_paused(&self) {
        require!(
            !self.operations_control.autocompounding_epoch_paused,
            ERROR_AUTOCOMPOUNDING_EPOCH_PAUSED
        );
    }

    pub fn assert_sync_validator_balance_not_paused(&self) {
        require!(
            !self.operations_control.sync_validator_balance_paused,
            ERROR_SYNC_VALIDATOR_BALANCE_PAUSED
        );
    }

    pub fn assert_ft_transfer_not_paused(&self) {
        require!(
            !self.operations_control.ft_transfer_paused,
            ERROR_FT_TRANSFER_PAUSED
        );
    }

    pub fn assert_ft_transfer_call_not_paused(&self) {
        require!(
            !self.operations_control.ft_transfer_call_paused,
            ERROR_FT_TRANSFER_CALL_PAUSED
        );
    }
}

'''
'''--- contracts/near-x/src/errors.rs ---
/// Unstake/Stake/Withdraw related
pub const ERROR_DEPOSIT_SHOULD_BE_GREATER_THAN_ZERO: &str = "Deposit should be greater than 0";
pub const ERROR_NON_POSITIVE_UNSTAKE_AMOUNT: &str = "Unstake amount needs to be greater than 0";
pub const ERROR_NO_STAKED_BALANCE: &str = "Staked balance is 0";
pub const ERROR_NON_POSITIVE_UNSTAKING_SHARES: &str = "Unstaked shares should be greater than 0";
pub const ERROR_NON_POSITIVE_UNSTAKE_RECEVIE_AMOUNT: &str =
    "Received unstake amount needs to be greater than 0";
pub const ERROR_NON_POSITIVE_WITHDRAWAL: &str = "Withdrawal amount needs to be greater than 0";
pub const ERROR_NOT_ENOUGH_UNSTAKED_AMOUNT_TO_WITHDRAW: &str =
    "Not enough unstaked amount to withdraw";
pub const ERROR_UNSTAKED_AMOUNT_IN_UNBONDING_PERIOD: &str =
    "Unstaking amount still in unbonding period";
pub const ERROR_NOT_ENOUGH_BALANCE_FOR_STORAGE: &str = "Not enough balance for storage staking";
pub const ERROR_CANNOT_UNSTAKED_MORE_THAN_STAKED_AMOUNT: &str =
    "Cannot unstake more than staked amount";
pub const ERROR_NOT_ENOUGH_STAKED_AMOUNT_TO_UNSTAKE: &str = "Not enough staked amount to unstake";
pub const ERROR_NOT_ENOUGH_CONTRACT_STAKED_AMOUNT: &str = "Not enough staked amount in contract";
pub const ERROR_NON_POSITIVE_STAKE_AMOUNT: &str = "Amount to stake must be greater than 0";
pub const ERROR_NON_POSITIVE_STAKE_SHARES: &str = "nearx to be minted must be greater than 0";

/// Misc
pub const ERROR_TEMP_OWNER_NOT_SET: &str = "Temp owner has not been set to any account";
pub const ERROR_TEMP_OPERATOR_NOT_SET: &str = "Temp operator has not been set to any account";
pub const ERROR_TEMP_TREASURY_NOT_SET: &str = "Temp treasury has not been set to any account";
pub const ERROR_TEMP_REWARD_FEE_IS_NOT_SET: &str = "Temp reward fee is not set";
pub const ERROR_UNAUTHORIZED: &str = "Unauthorized";
pub const ERROR_MIN_DEPOSIT: &str = "Deposit should be greater than min deposit";
pub const ERROR_MIN_BALANCE_FOR_CONTRACT_STORAGE: &str =
    "Contract balance should not go below the required minimum storage balance";
pub const ERROR_CONTRACT_ALREADY_INITIALIZED: &str = "Contract has already been initialized";
pub const ERROR_NO_STAKING_KEY: &str = "Staking key not present";
pub const ERROR_NOT_ENOUGH_GAS: &str = "Not enough pre-paid gas";
pub const ERROR_REQUIRE_ONE_YOCTO_NEAR: &str = "Function requires at least one yocto near";
pub const ERROR_EXPECT_RESULT_ON_CALLBACK: &str = "Callback expected result on callback";
pub const ERROR_MIN_DEPOSIT_TOO_HIGH: &str = "Min deposit too high";
pub const ERROR_MIN_DEPOSIT_TOO_LOW: &str = "Min deposit too low";
pub const ERROR_TEMP_REWARD_FEE_SET_IN_WAIT_PERIOD: &str =
    "Still in wait period for reward fee to be set";

/// Owner/Operator/Treasury mechanism related errors
pub const ERROR_OPERATOR_OWNER_SAME: &str = "Operator and owner account cannot be the same";
pub const ERROR_OPERATOR_TREASURY_SAME: &str = "Operator and treasury account cannot be the same";
pub const ERROR_OPERATOR_CURRENT_CONTRACT_SAME: &str =
    "Operator and current contract cannot be the same";
pub const ERROR_OPERATOR_SAME: &str = "Operator cannot be same as current operator";
pub const ERROR_OWNER_OPERATOR_SAME: &str = "Owner and operator account cannot be the same";
pub const ERROR_OWNER_TREASURY_SAME: &str = "Owner and treasury account cannot be the same";
pub const ERROR_OWNER_CURRENT_CONTRACT_SAME: &str = "Owner and current contract cannot be the same";
pub const ERROR_OWNER_SAME: &str = "Owner cannot be same as current owner";
pub const ERROR_TREASURY_OPERATOR_SAME: &str = "Treasury and operator account cannot be the same";
pub const ERROR_TREASURY_OWNER_SAME: &str = "Treasury and owner account cannot be the same";
pub const ERROR_TREASURY_CURRENT_CONTRACT_SAME: &str =
    "Treasury and current contract cannot be the same";
pub const ERROR_TREASURY_SAME: &str = "Treasury cannot be same as current treasury";
pub const ERROR_SENDER_RECEIVER_SAME: &str = "Sender and receiver cannot be the same";
pub const ERROR_REQUIRE_AMOUNT_GT_0: &str = "Amount should be greater than 0";

/// Validator related errors
pub const ERROR_VALIDATOR_NOT_PAUSED: &str = "Validator not paused";
pub const ERROR_INVALID_VALIDATOR_REMOVAL: &str = "Cannot remove this validator";
pub const ERROR_NO_VALIDATOR_AVAILABLE_TO_STAKE: &str = "No validator available to stake";
pub const ERROR_VALIDATOR_DOES_NOT_EXIST: &str = "Validator not exist in pool";
pub const ERROR_VALIDATOR_UNSTAKE_STILL_UNBONDING: &str =
    "Unstaked amount is still in unbonding period";
pub const ERROR_NO_VALIDATOR_AVAILABLE_FOR_UNSTAKE: &str =
    "No validator is available to unstake from";
pub const ERROR_VALIDATOR_IS_NOT_PRESENT: &str = "Validator is not present";
pub const ERROR_VALIDATOR_IS_ALREADY_PRESENT: &str = "Validator is already present";
pub const ERROR_VALIDATOR_IS_BUSY: &str = "Validator is busy";
pub const ERROR_ALL_VALIDATORS_ARE_BUSY: &str = "All validators are busy";
pub const ERROR_INVALID_VALIDATOR_WEIGHT: &str = "Invalid validator weight";
pub const ERROR_VALIDATOR_IS_PAUSED: &str = "Validator is paused";

/// Validator sync errors
pub const ERROR_VALIDATOR_TOTAL_BALANCE_OUT_OF_SYNC: &str = "Total balance is out of sync";
pub const ERROR_VALIDATOR_STAKED_BALANCE_OUT_OF_SYNC: &str =
    "Total staked balance is out of sync by more than 200yNEAR";
pub const ERROR_VALIDATOR_UNSTAKED_BALANCE_OUT_OF_SYNC: &str =
    "Total unstaked amount is out of sync by more than 200yNEAR";

/// Operations controls
pub const ERROR_STAKING_PAUSED: &str = "Staking paused";
pub const ERROR_UNSTAKING_PAUSED: &str = "Unstaking paused";
pub const ERROR_WITHDRAW_PAUSED: &str = "Withdraw paused";
pub const ERROR_STAKING_EPOCH_PAUSED: &str = "Staking epoch paused";
pub const ERROR_UNSTAKING_EPOCH_PAUSED: &str = "Unstaking epoch paused";
pub const ERROR_WITHDRAW_EPOCH_PAUSED: &str = "Withdraw epoch paused";
pub const ERROR_AUTOCOMPOUNDING_EPOCH_PAUSED: &str = "Autocompounding epoch paused";
pub const ERROR_SYNC_VALIDATOR_BALANCE_PAUSED: &str = "Sync validator balance paused";
pub const ERROR_FT_TRANSFER_PAUSED: &str = "ft_transfer paused";
pub const ERROR_FT_TRANSFER_CALL_PAUSED: &str = "ft_transfer_call paused";

'''
'''--- contracts/near-x/src/events.rs ---
use crate::contract::OperationControls;
use crate::state::Fraction;
use near_sdk::{json_types::U128, log, serde::Serialize, serde_json::json, AccountId};

const EVENT_STANDARD: &str = "nearx";
const EVENT_STANDARD_VERSION: &str = "1.0.0";

#[derive(Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
pub enum Event {
    // Epoch Actions
    StakingEpochAttempt {
        validator_id: AccountId,
        amount: U128,
    },
    StakingEpochCallbackSuccess {
        validator_id: AccountId,
        amount: U128,
    },
    StakingEpochCallbackFailed {
        validator_id: AccountId,
        amount: U128,
    },
    UnstakingEpochAttempt {
        validator_id: AccountId,
        amount: U128,
    },
    UnstakingEpochCallbackSuccess {
        validator_id: AccountId,
        amount: U128,
    },
    UnstakingEpochCallbackFailed {
        validator_id: AccountId,
        amount: U128,
    },
    WithdrawEpochAttempt {
        validator_id: AccountId,
        amount: U128,
    },
    WithdrawEpochCallbackSuccess {
        validator_id: AccountId,
        amount: U128,
    },
    WithdrawEpochCallbackFailed {
        validator_id: AccountId,
        amount: U128,
    },
    AutocompoundingEpochRewardsAttempt {
        validator_id: AccountId,
    },
    AutocompoundingEpochRewards {
        validator_id: AccountId,
        old_balance: U128,
        new_balance: U128,
        rewards: U128,
    },
    EpochReconcile {
        actual_epoch_stake_amount: U128,
        actual_epoch_unstake_amount: U128,
        reconciled_stake_amount: U128,
        reconciled_unstake_amount: U128,
    },
    // Sync validator balance
    BalanceSyncedFromValidatorAttempt {
        validator_id: AccountId,
    },
    BalanceSyncedFromValidator {
        validator_id: AccountId,
        old_staked_balance: U128,
        old_unstaked_balance: U128,
        staked_balance: U128,
        unstaked_balance: U128,
    },
    // Staking Pool Interface
    DepositAndStake {
        account_id: AccountId,
        amount: U128,
        minted_stake_shares: U128,
        new_stake_shares: U128,
    },
    Withdraw {
        account_id: AccountId,
        amount: U128,
        new_unstaked_balance: U128,
    },
    Unstake {
        account_id: AccountId,
        unstaked_amount: U128,
        burnt_stake_shares: U128,
        new_unstaked_balance: U128,
        new_stake_shares: U128,
        unstaked_available_epoch_height: u64,
    },
    // Validators
    ValidatorAdded {
        account_id: AccountId,
        weight: u16,
    },
    ValidatorRemoved {
        account_id: AccountId,
    },
    ValidatorUpdated {
        account_id: AccountId,
        weight: u16,
    },
    ValidatorPaused {
        account_id: AccountId,
        old_weight: u16,
    },
    // Validator draining
    DrainUnstake {
        account_id: AccountId,
        amount: U128,
    },
    DrainUnstakeCallbackFail {
        validator_id: AccountId,
        amount: U128,
    },
    DrainUnstakeCallbackSuccess {
        validator_id: AccountId,
        amount: U128,
    },
    DrainWithdraw {
        validator_id: AccountId,
        amount: U128,
    },
    DrainWithdrawCallbackFail {
        validator_id: AccountId,
        amount: U128,
    },
    DrainWithdrawCallbackSuccess {
        validator_id: AccountId,
        amount: U128,
    },
    // Ft related events
    FtTransfer {
        receiver_id: AccountId,
        sender_id: AccountId,
        amount: U128,
    },
    FtTransferCall {
        receiver_id: AccountId,
        sender_id: AccountId,
        msg: String,
        amount: U128,
    },
    FtBurn {
        account_id: AccountId,
        amount: U128,
    },
    // Owner events
    SetOwner {
        old_owner: AccountId,
        new_owner: AccountId,
    },
    CommitOwner {
        new_owner: AccountId,
        caller: AccountId,
    },
    SetOperator {
        old_operator: AccountId,
        new_operator: AccountId,
    },
    CommitOperator {
        new_operator: AccountId,
    },
    SetTreasury {
        old_treasury_account: AccountId,
        new_treasury_account: AccountId,
    },
    CommitTreasury {
        new_treasury_account: AccountId,
    },
    UpdateOperationsControl {
        operations_control: OperationControls,
    },
    SetRewardFee {
        old_reward_fee: Fraction,
        new_reward_fee: Fraction,
    },
    CommitRewardFee {
        commited_reward_fee: Fraction,
    },
    SetMinDeposit {
        old_min_deposit: U128,
        new_min_deposit: U128,
    },
    UpdateRewardBuffer {
        amount_added: U128,
        new_reward_buffer: U128,
    },
}

impl Event {
    pub fn emit(&self) {
        emit_event(&self);
    }
}

// Emit event that follows NEP-297 standard: https://nomicon.io/Standards/EventsFormat
// Arguments
// * `standard`: name of standard, e.g. nep171
// * `version`: e.g. 1.0.0
// * `event`: type of the event, e.g. nft_mint
// * `data`: associate event data. Strictly typed for each set {standard, version, event} inside corresponding NEP
pub(crate) fn emit_event<T: ?Sized + Serialize>(data: &T) {
    let result = json!(data);
    let event_json = json!({
        "standard": EVENT_STANDARD,
        "version": EVENT_STANDARD_VERSION,
        "event": result["event"],
        "data": [result["data"]]
    })
    .to_string();
    log!(format!("EVENT_JSON:{}", event_json));
}

'''
'''--- contracts/near-x/src/fungible_token.rs ---
mod metadata;
mod nearx_internal;
mod nearx_token;

'''
'''--- contracts/near-x/src/fungible_token/metadata.rs ---
use crate::contract::*;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_sdk::near_bindgen;

const NEARX_LOGO: &str = "data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM17.1421 21.3847L21.3848 17.1421L19.3669 15.1243C18.5576 17.0302 17.0303 18.5576 15.1243 19.3669L17.1421 21.3847ZM9.4329 19.5792C7.45318 18.9089 5.82112 17.4847 4.87847 15.6484L3.24263 17.2842L7.48527 21.5269L9.4329 19.5792ZM4.63307 8.87568C5.4424 6.96973 6.96977 5.44237 8.87573 4.63305L7.24263 2.99995L2.99999 7.24259L4.63307 8.87568ZM15.6484 4.87847L17.3848 3.14209L21.6274 7.38473L19.5792 9.4329C18.9089 7.45318 17.4847 5.82112 15.6484 4.87847Z' fill='%232FA8AF'/%3E%3Cpath d='M8.00119 11.9921C8.00119 11.0268 8.00119 10.0615 8.00119 9.09612C8.00119 8.50505 8.16497 8.1743 8.56285 8.05781C8.97778 7.93628 9.40619 7.97917 9.79565 8.45228C11.3533 10.3447 12.9343 12.218 14.5092 14.0959C14.5692 14.1676 14.6117 14.3122 14.734 14.2626C14.8496 14.2157 14.7858 14.0805 14.786 13.9878C14.7904 12.6326 14.7898 11.2774 14.7868 9.92226C14.7868 9.83668 14.838 9.7162 14.7271 9.67372C14.6401 9.64029 14.5824 9.74185 14.522 9.79358C14.0492 10.1981 13.5804 10.6073 13.1088 11.0133C13.0208 11.089 12.9332 11.2118 12.8002 11.1012C12.6657 10.9894 12.7696 10.8872 12.8364 10.7881C13.3547 10.0186 13.8728 9.24898 14.3909 8.47919C14.6656 8.07085 15.0079 7.92282 15.4056 8.04141C15.786 8.15475 15.9986 8.48592 15.9992 8.97668C16.0007 10.0905 15.9996 11.2045 15.9996 12.3183C15.9996 13.2094 16.0003 14.1005 15.9994 14.9916C15.999 15.4826 15.8137 15.798 15.4512 15.9324C15.0256 16.0901 14.5767 15.9683 14.2734 15.6058C12.6823 13.705 11.0924 11.8029 9.50198 9.90144C9.46029 9.85161 9.42303 9.7961 9.37377 9.75489C9.28998 9.68487 9.21967 9.68108 9.21314 9.81797C9.20999 9.88273 9.21188 9.94791 9.21188 10.0129C9.21188 11.3496 9.21062 12.6862 9.2142 14.0227C9.21441 14.1186 9.15609 14.2557 9.26114 14.3038C9.38093 14.3587 9.45061 14.2178 9.52998 14.1503C9.98259 13.7651 10.4291 13.3728 10.8805 12.9859C10.9729 12.9066 11.0626 12.7651 11.208 12.8973C11.3402 13.0176 11.2213 13.1196 11.159 13.2127C10.6323 13.9989 10.1032 14.7837 9.57145 15.5663C9.32788 15.9248 8.9881 16.056 8.61085 15.9488C8.23739 15.8428 8.00498 15.5246 8.00287 15.0827C7.99761 14.0523 8.00119 13.022 8.00119 11.9917V11.9921Z' fill='white'/%3E%3C/svg%3E%0A";

#[near_bindgen]
impl FungibleTokenMetadataProvider for NearxPool {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: "NearX".to_string(),
            symbol: "NearX".to_string(),
            icon: Some(NEARX_LOGO.to_string()),
            reference: Some("https://near.staderlabs.com".into()),
            reference_hash: None,
            decimals: 24,
        }
    }
}

'''
'''--- contracts/near-x/src/fungible_token/nearx_internal.rs ---
use crate::contract::NearxPool;
use crate::errors::{ERROR_REQUIRE_AMOUNT_GT_0, ERROR_SENDER_RECEIVER_SAME};
use near_sdk::json_types::U128;
use near_sdk::{env, log, require, AccountId, Balance, PromiseResult};

impl NearxPool {
    pub fn internal_nearx_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: u128,
    ) {
        require!(sender_id != receiver_id, ERROR_SENDER_RECEIVER_SAME);
        require!(amount > 0, ERROR_REQUIRE_AMOUNT_GT_0);

        let mut sender_acc = self.internal_get_account(sender_id);
        assert!(
            amount <= sender_acc.stake_shares,
            "{} does not have enough NearX balance {}",
            sender_id,
            sender_acc.stake_shares
        );

        sender_acc.stake_shares -= amount;
        self.internal_update_account(sender_id, &sender_acc);

        let mut receiver_acc = self.internal_get_account(receiver_id);
        receiver_acc.stake_shares += amount;
        self.internal_update_account(receiver_id, &receiver_acc);
    }

    pub fn int_ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> (u128, u128) {
        let receiver_id = receiver_id;
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let mut receiver_acc = self.internal_get_account(&receiver_id);
            let receiver_balance = receiver_acc.stake_shares;
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                receiver_acc.stake_shares -= refund_amount;
                self.internal_update_account(&receiver_id, &receiver_acc);

                let mut sender_acc = self.internal_get_account(sender_id);
                sender_acc.stake_shares += refund_amount;
                self.internal_update_account(sender_id, &sender_acc);

                log!(
                    "Refund {} from {} to {}",
                    refund_amount,
                    receiver_id,
                    sender_id
                );
                return (amount - refund_amount, 0);
            }
        }
        (amount, 0)
    }
}

'''
'''--- contracts/near-x/src/fungible_token/nearx_token.rs ---
use crate::constants::{gas, NO_DEPOSIT};
use crate::contract::*;
use crate::events::Event;
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_sdk::{
    assert_one_yocto, env, ext_contract, json_types::U128, log, near_bindgen, AccountId,
    PromiseOrValue,
};

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for NearxPool {
    /// NEP-141 for NEARX
    #[payable]
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        #[allow(unused)] memo: Option<String>,
    ) {
        assert_one_yocto();
        self.assert_ft_transfer_not_paused();
        Event::FtTransfer {
            receiver_id: receiver_id.clone(),
            sender_id: env::predecessor_account_id(),
            amount,
        }
        .emit();
        self.internal_nearx_transfer(&env::predecessor_account_id(), &receiver_id, amount.0);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        #[allow(unused)] memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_one_yocto();
        self.assert_ft_transfer_call_not_paused();
        let min_gas = gas::FT_TRANSFER + gas::FT_TRANSFER_RESOLVE;
        assert!(
            env::prepaid_gas() > min_gas,
            "require at least {:?} gas",
            min_gas
        );

        Event::FtTransferCall {
            receiver_id: receiver_id.clone(),
            sender_id: env::predecessor_account_id(),
            msg: msg.clone(),
            amount,
        }
        .emit();

        self.internal_nearx_transfer(&env::predecessor_account_id(), &receiver_id, amount.0);

        ext_ft_receiver::ext(receiver_id.clone())
            .with_attached_deposit(NO_DEPOSIT)
            .with_static_gas(env::prepaid_gas() - gas::FT_TRANSFER - gas::FT_TRANSFER_RESOLVE)
            .ft_on_transfer(env::predecessor_account_id(), amount, msg)
            .then(
                ext_self::ext(env::current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas(gas::FT_TRANSFER_RESOLVE)
                    .ft_resolve_transfer(env::predecessor_account_id(), receiver_id, amount),
            )
            .into()
    }

    fn ft_total_supply(&self) -> U128 {
        self.total_stake_shares.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        self.internal_get_account(&account_id).stake_shares.into()
    }
}

#[near_bindgen]
impl FungibleTokenResolver for NearxPool {
    #[private]
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let (used_amount, burned_amount) =
            self.int_ft_resolve_transfer(&sender_id, receiver_id, amount);
        if burned_amount > 0 {
            log!("{} tokens burned", burned_amount);
        }
        used_amount.into()
    }
}

'''
'''--- contracts/near-x/src/lib.rs ---
#![allow(clippy::bool_comparison)]

pub mod constants;
pub mod contract;
pub mod errors;
pub mod events;
pub mod fungible_token;
pub mod state;
pub mod utils;

'''
'''--- contracts/near-x/src/state.rs ---
use crate::constants::NUM_EPOCHS_TO_UNLOCK;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::{U128, U64},
    serde::{Deserialize, Serialize},
    AccountId, Balance, EpochHeight,
};

#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountResponse {
    pub account_id: AccountId,
    pub unstaked_balance: U128,
    pub staked_balance: U128,
    pub withdrawable_epoch: U64,
}

#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "camelCase")]
pub struct SnapshotUser {
    pub account_id: AccountId,
    pub nearx_balance: U128,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NearxPoolStateResponse {
    pub owner_account_id: AccountId,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    pub total_staked: U128,

    /// how many "shares" were minted. Every time someone "stakes" he "buys pool shares" with the staked amount
    // the buy share price is computed so if she "sells" the shares on that moment she recovers the same near amount
    // staking produces rewards, rewards are added to total_for_staking so share_price will increase with rewards
    // share_price = total_staked/total_shares
    pub total_stake_shares: U128, //total NearX minted

    pub accumulated_staked_rewards: U128,

    /// min amount accepted as deposit or stake
    pub min_deposit_amount: U128,

    pub operator_account_id: AccountId,

    /// pct of rewards which will go to the operator
    pub rewards_fee_pct: Fraction,

    /// Amount of NEAR that is users requested to stake
    pub user_amount_to_stake_in_epoch: U128,
    /// Amount of NEAR that is users requested to unstake
    pub user_amount_to_unstake_in_epoch: U128,

    /// Amount of NEAR that actually needs to be staked in the epoch
    pub reconciled_epoch_stake_amount: U128,
    /// Amount of NEAR that actually needs to be unstaked in the epoch
    pub reconciled_epoch_unstake_amount: U128,
    /// Last epoch height stake/unstake amount were reconciled
    pub last_reconcilation_epoch: U64,

    pub temp_reward_fee: Option<Fraction>,

    pub rewards_buffer: U128,

    pub accumulated_rewards_buffer: U128,

    pub last_reward_fee_set_epoch: EpochHeight,

    pub min_storage_reserve: U128,
}

#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct ValidatorInfoResponse {
    pub account_id: AccountId,
    pub staked: U128,
    pub unstaked: U128,
    pub weight: u16,
    pub last_asked_rewards_epoch_height: U64,
    pub last_unstake_start_epoch: U64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ValidatorInfo {
    pub account_id: AccountId,

    pub staked: u128,

    pub weight: u16,

    pub last_redeemed_rewards_epoch: EpochHeight,

    pub unstaked_amount: Balance,

    pub unstake_start_epoch: EpochHeight,

    pub last_unstake_start_epoch: EpochHeight,
}

impl ValidatorInfo {
    pub fn is_empty(&self) -> bool {
        self.paused()
            && !self.pending_unstake_release()
            && self.staked == 0
            && self.unstaked_amount == 0
    }

    pub fn new(account_id: AccountId, weight: u16) -> Self {
        Self {
            account_id,
            staked: 0,
            weight,
            last_redeemed_rewards_epoch: 0,
            unstaked_amount: 0,
            unstake_start_epoch: 0,
            last_unstake_start_epoch: 0,
        }
    }

    pub fn total_balance(&self) -> u128 {
        self.staked + self.unstaked_amount
    }

    pub fn paused(&self) -> bool {
        self.weight == 0
    }

    /// whether the validator is in unstake releasing period.
    pub fn pending_unstake_release(&self) -> bool {
        env::epoch_height() >= self.unstake_start_epoch
            && env::epoch_height() < self.unstake_start_epoch + NUM_EPOCHS_TO_UNLOCK
    }
}

#[derive(Default, BorshDeserialize, BorshSerialize, Debug, PartialEq, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub stake_shares: u128, //nearx this account owns

    pub unstaked_amount: Balance,

    pub withdrawable_epoch_height: EpochHeight,
}

impl Account {
    pub fn is_empty(&self) -> bool {
        self.stake_shares == 0 && self.unstaked_amount == 0
    }

    pub fn add_stake_shares(&mut self, num_shares: u128) {
        self.stake_shares += num_shares;
    }

    pub fn sub_stake_shares(&mut self, num_shares: u128) {
        assert!(
            self.stake_shares >= num_shares,
            "sub_stake_shares self.stake_shares {} < num_shares {}",
            self.stake_shares,
            num_shares
        );
        self.stake_shares -= num_shares;
    }
}

/// Rewards fee fraction structure for the staking pool contract.
#[derive(Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Fraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl Fraction {
    pub fn new(numerator: u32, denominator: u32) -> Self {
        Self {
            numerator,
            denominator,
        }
    }
}

impl std::ops::Mul<Fraction> for u128 {
    type Output = u128;

    fn mul(self, rhs: Fraction) -> Self::Output {
        crate::utils::proportional(self, rhs.numerator.into(), rhs.denominator.into())
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RolesResponse {
    pub owner_account: AccountId,
    pub operator_account: AccountId,
    pub treasury_account: AccountId,
    pub temp_owner: Option<AccountId>,
    pub temp_operator: Option<AccountId>,
    pub temp_treasury: Option<AccountId>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OperationsControlUpdateRequest {
    pub stake_paused: Option<bool>,
    pub unstake_paused: Option<bool>,
    pub withdraw_paused: Option<bool>,
    pub staking_epoch_paused: Option<bool>,
    pub unstaking_epoch_paused: Option<bool>,
    pub withdraw_epoch_paused: Option<bool>,
    pub autocompounding_epoch_paused: Option<bool>,
    pub sync_validator_balance_paused: Option<bool>,
    pub ft_transfer_paused: Option<bool>,
    pub ft_transfer_call_paused: Option<bool>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractSummary {
    pub total_staked: U128,
    pub total_shares: U128,
    pub total_validators: U128,
    pub treasury_staked_balance: U128,
    pub treasury_unstaked_balance: U128,
    pub nearx_price: U128,
}

'''
'''--- contracts/near-x/src/utils.rs ---
use crate::{constants::*, errors::*};
use near_sdk::{env, require, PromiseResult};

pub fn is_promise_success() -> bool {
    require!(
        env::promise_results_count() == 1,
        ERROR_EXPECT_RESULT_ON_CALLBACK
    );

    matches!(env::promise_result(0), PromiseResult::Successful(_))
}

pub(crate) fn abs_diff_eq(left: u128, right: u128, epsilon: u128) -> bool {
    left <= right + epsilon && right <= left + epsilon
}

/// Returns amount * numerator/denominator
#[allow(clippy::all)]
pub fn proportional(amount: u128, numerator: u128, denominator: u128) -> u128 {
    (U256::from(amount) * U256::from(numerator) / U256::from(denominator)).as_u128()
}

'''
'''--- contracts/near-x/tests/helpers/mod.rs ---
pub fn ntoy(near_amount: u128) -> u128 {
    near_amount * 10u128.pow(24)
}
pub(crate) fn abs_diff_eq(left: u128, right: u128, epsilon: u128) -> bool {
    left <= right + epsilon && right <= left + epsilon
}

'''
'''--- contracts/near-x/tests/unit_tests.rs ---
mod helpers;

use crate::helpers::abs_diff_eq;
use helpers::ntoy;
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_contract_standards::storage_management::StorageManagement;
use near_sdk::json_types::{U128, U64};
use near_sdk::test_utils::testing_env_with_promise_results;
use near_sdk::{
    testing_env, AccountId, FunctionError, Gas, MockedBlockchain, PromiseOrValue, PromiseResult,
    PublicKey, RuntimeFeesConfig, VMConfig, VMContext,
};
use near_x::constants::NUM_EPOCHS_TO_UNLOCK;
use near_x::contract::{NearxPool, OperationControls};
use near_x::state::{
    Account, AccountResponse, Fraction, HumanReadableAccount, OperationsControlUpdateRequest,
    ValidatorInfo, ValidatorInfoResponse,
};
use std::collections::HashMap;
use std::{convert::TryFrom, str::FromStr};

pub fn owner_account() -> AccountId {
    AccountId::from_str("owner_account").unwrap()
}

pub fn public_key(byte_val: u8) -> PublicKey {
    let mut pk = vec![byte_val; 33];
    pk[0] = 0;
    PublicKey::try_from(pk).unwrap()
}

pub fn system_account() -> AccountId {
    AccountId::from_str("system").unwrap()
}

pub fn to_nanos(num_days: u64) -> u64 {
    num_days * 86_400_000_000_000
}

pub fn to_ts(num_days: u64) -> u64 {
    // 2018-08-01 UTC in nanoseconds
    1_533_081_600_000_000_000 + to_nanos(num_days)
}

pub fn operator_account() -> AccountId {
    AccountId::from_str("operator_account").unwrap()
}

pub fn contract_account() -> AccountId {
    AccountId::from_str("nearx-pool").unwrap()
}

pub fn treasury_account() -> AccountId {
    AccountId::from_str("treasury_account").unwrap()
}

pub fn check_equal_vec<S: PartialEq>(v1: Vec<S>, v2: Vec<S>) -> bool {
    v1.len() == v2.len() && v1.iter().all(|x| v2.contains(x)) && v2.iter().all(|x| v1.contains(x))
}

pub fn default_pubkey() -> PublicKey {
    PublicKey::try_from(vec![0; 33]).unwrap()
}

pub fn get_context(
    predecessor_account_id: AccountId,
    account_balance: u128,
    account_locked_balance: u128,
    block_timestamp: u64,
) -> VMContext {
    VMContext {
        current_account_id: contract_account(),
        signer_account_id: predecessor_account_id.clone(),
        signer_account_pk: default_pubkey(),
        predecessor_account_id,
        input: vec![],
        block_index: 1,
        block_timestamp,
        epoch_height: 1,
        account_balance,
        account_locked_balance,
        storage_usage: 10u64.pow(6),
        attached_deposit: 0,
        prepaid_gas: Gas(10u64.pow(15)), //10u64.pow(15),
        random_seed: [0; 32],
        view_config: None,
        output_data_receivers: vec![],
    }
}

fn get_validator(contract: &NearxPool, validator: AccountId) -> ValidatorInfo {
    contract.validator_info_map.get(&validator).unwrap()
}

fn update_validator(
    contract: &mut NearxPool,
    validator: AccountId,
    validator_info: &ValidatorInfo,
) {
    contract
        .validator_info_map
        .insert(&validator, validator_info)
        .unwrap();
}

fn get_account(contract: &NearxPool, account_id: AccountId) -> Account {
    contract.accounts.get(&account_id).unwrap()
}

fn get_account_option(contract: &NearxPool, account_id: AccountId) -> Option<Account> {
    contract.accounts.get(&account_id)
}

fn update_account(contract: &mut NearxPool, account_id: AccountId, account: &Account) {
    contract.accounts.insert(&account_id, account);
}

fn basic_context() -> VMContext {
    get_context(system_account(), ntoy(100), 0, to_ts(500))
}

fn new_contract(
    owner_account: AccountId,
    operator_account: AccountId,
    treasury_account: AccountId,
) -> NearxPool {
    NearxPool::new(owner_account, operator_account, treasury_account)
}

fn contract_setup(
    owner_account: AccountId,
    operator_account: AccountId,
    treasury_account: AccountId,
) -> (VMContext, NearxPool) {
    let context = basic_context();
    testing_env!(context.clone());
    let contract = new_contract(owner_account, operator_account, treasury_account);
    (context, contract)
}

#[test]
#[should_panic]
fn test_non_owner_calling_update_operations_control() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = operator_account();
    context.signer_account_id = operator_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.update_operations_control(OperationsControlUpdateRequest {
        stake_paused: None,
        unstake_paused: None,
        withdraw_paused: None,
        staking_epoch_paused: None,
        unstaking_epoch_paused: None,
        withdraw_epoch_paused: None,
        autocompounding_epoch_paused: None,
        sync_validator_balance_paused: None,
        ft_transfer_paused: None,
        ft_transfer_call_paused: None,
    });
}

#[test]
fn test_update_operations_control_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.update_operations_control(OperationsControlUpdateRequest {
        stake_paused: Some(true),
        unstake_paused: Some(true),
        withdraw_paused: None,
        staking_epoch_paused: Some(true),
        unstaking_epoch_paused: Some(true),
        withdraw_epoch_paused: Some(true),
        autocompounding_epoch_paused: None,
        sync_validator_balance_paused: Some(true),
        ft_transfer_paused: Some(true),
        ft_transfer_call_paused: Some(true),
    });

    let operations_control = contract.get_operations_control();
    assert_eq!(
        operations_control,
        OperationControls {
            stake_paused: true,
            unstaked_paused: true,
            withdraw_paused: false,
            staking_epoch_paused: true,
            unstaking_epoch_paused: true,
            withdraw_epoch_paused: true,
            autocompounding_epoch_paused: false,
            sync_validator_balance_paused: true,
            ft_transfer_paused: true,
            ft_transfer_call_paused: true
        }
    );
}

#[test]
#[should_panic]
fn test_update_rewards_buffer_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = AccountId::from_str("abc").unwrap();
    context.attached_deposit = 1;
    testing_env!(context); // this updates the context

    contract.update_rewards_buffer();
}

#[test]
fn test_update_rewards_buffer_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = operator_account();
    context.attached_deposit = ntoy(10);
    testing_env!(context); // this updates the context

    contract.total_staked = ntoy(100);
    contract.rewards_buffer = 0;

    contract.update_rewards_buffer();

    assert_eq!(contract.total_staked, ntoy(110));
    assert_eq!(contract.rewards_buffer, ntoy(10));
    assert_eq!(contract.accumulated_rewards_buffer, ntoy(10));
}

#[test]
#[should_panic]
fn test_update_validator_fail() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       Non operator adding stake pool
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.update_validator(stake_public_key_1.clone(), 10);
}

#[test]
#[should_panic]
fn test_update_validator_invalid_weight_fail() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       Non operator adding stake pool
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.update_validator(stake_public_key_1.clone(), 0);
}

#[test]
fn test_update_validator_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       owner adding stake pool
    */
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 30);
    contract.add_validator(stake_public_key_3.clone(), 20);

    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    val1.weight = 10;
    val1.staked = ntoy(100);
    update_validator(&mut contract, stake_public_key_1.clone(), &val1);

    let mut val2 = get_validator(&contract, stake_public_key_2.clone());
    val2.weight = 10;
    val2.staked = ntoy(100);
    update_validator(&mut contract, stake_public_key_2.clone(), &val2);

    let mut val3 = get_validator(&contract, stake_public_key_3.clone());
    val3.weight = 10;
    val3.staked = ntoy(100);
    update_validator(&mut contract, stake_public_key_3.clone(), &val3);

    contract.total_validator_weight = 30;

    contract.update_validator(stake_public_key_1.clone(), 20);

    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    assert_eq!(val1.weight, 20);
    assert_eq!(val1.staked, ntoy(100));
    assert_eq!(contract.total_validator_weight, 40);
}

#[test]
#[should_panic]
fn test_add_validator_fail() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       Non operator adding stake pool
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
}

#[test]
#[should_panic]
fn test_remove_validator_fail() {
    let (_context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       Non operator removing stake pool
    */
    contract.remove_validator(AccountId::from_str("test_validator").unwrap());
}

#[test]
#[should_panic]
fn test_remove_validator_validator_in_unbonding_period() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 11;
    testing_env!(context); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);

    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    val1.weight = 0;
    val1.staked = ntoy(0);
    val1.unstaked_amount = ntoy(0);
    val1.unstake_start_epoch = 10;
    update_validator(&mut contract, stake_public_key_1, &val1);

    contract.remove_validator(AccountId::from_str("stake_public_key_1").unwrap());
}

#[test]
#[should_panic]
fn test_remove_validator_validator_non_zero_weight() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 11;
    testing_env!(context); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);

    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    val1.weight = 10;
    val1.staked = ntoy(10);
    val1.unstaked_amount = ntoy(0);
    val1.unstake_start_epoch = 10;
    update_validator(&mut contract, stake_public_key_1, &val1);

    contract.remove_validator(AccountId::from_str("stake_public_key_1").unwrap());
}

#[test]
#[should_panic]
fn test_remove_validator_validator_non_zero_staked_unstaked_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 11;
    testing_env!(context); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);

    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    val1.weight = 0;
    val1.staked = ntoy(10);
    val1.unstaked_amount = ntoy(0);
    val1.unstake_start_epoch = 10;
    update_validator(&mut contract, stake_public_key_1, &val1);

    contract.remove_validator(AccountId::from_str("stake_public_key_1").unwrap());
}

#[test]
fn test_remove_validator_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       seed staking pools
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 40;
    context.attached_deposit = 1;
    testing_env!(context); // this updates the context

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 10);
    contract.add_validator(stake_public_key_3.clone(), 10);

    let stake_pools = contract.get_validators();

    assert_eq!(stake_pools.len(), 3);
    assert!(check_equal_vec(
        stake_pools,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));
    assert_eq!(contract.total_validator_weight, 30);

    /*
       Remove a stake pool
    */
    let mut val1 = get_validator(&contract, stake_public_key_1.clone());
    val1.weight = 0;
    contract.total_validator_weight = 20;
    val1.unstake_start_epoch = 10;
    update_validator(&mut contract, stake_public_key_1.clone(), &val1);

    contract.remove_validator(stake_public_key_1.clone());
    let stake_pools = contract.get_validators();

    assert_eq!(stake_pools.len(), 2);
    assert!(check_equal_vec(
        stake_pools,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));
    assert_eq!(contract.total_validator_weight, 20);

    /*
        Remove another stake pool
    */
    let mut val2 = get_validator(&contract, stake_public_key_2.clone());
    val2.weight = 0;
    val1.unstake_start_epoch = 10;
    contract.total_validator_weight = 10;
    update_validator(&mut contract, stake_public_key_2.clone(), &val2);

    contract.remove_validator(stake_public_key_2.clone());
    let stake_pools = contract.get_validators();

    assert_eq!(stake_pools.len(), 1);
    assert!(check_equal_vec(
        stake_pools,
        vec![ValidatorInfoResponse {
            account_id: stake_public_key_3.clone(),
            staked: U128(0),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }]
    ));
    assert_eq!(contract.total_validator_weight, 10);

    /*
        Remove last stake pool
    */
    let mut val3 = get_validator(&contract, stake_public_key_3.clone());
    val3.weight = 0;
    val1.unstake_start_epoch = 10;
    contract.total_validator_weight = 0;
    update_validator(&mut contract, stake_public_key_3.clone(), &val3);

    contract.remove_validator(stake_public_key_3);
    let stake_pools = contract.get_validators();

    assert!(stake_pools.is_empty());
    assert_eq!(contract.total_validator_weight, 0);
}

#[test]
fn test_add_validator_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       initial staking pools should be empty
    */
    let stake_pools = contract.get_validators();
    assert!(
        stake_pools.is_empty(),
        "Stake pools should initially be empty!"
    );

    /*
       add a stake pool
    */
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    let stake_pools = contract.get_validators();
    assert_eq!(stake_pools.len(), 1);
    assert_eq!(contract.total_validator_weight, 10);
    assert!(check_equal_vec(
        stake_pools,
        vec![ValidatorInfoResponse {
            account_id: stake_public_key_1.clone(),
            staked: U128(0),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }]
    ));

    /*
       add another stake pool
    */
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();

    contract.add_validator(stake_public_key_2.clone(), 10);
    let stake_pools = contract.get_validators();
    assert_eq!(stake_pools.len(), 2);
    assert_eq!(contract.total_validator_weight, 20);
    assert!(check_equal_vec(
        stake_pools,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1,
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2,
                staked: U128(0),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));
}

#[test]
fn test_get_validator_to_unstake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
        Get validator in empty validator set
    */
    let validator = contract.get_validator_to_unstake();
    assert!(validator.is_none());

    /*
        seed staking pools
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 100;
    testing_env!(context); // this updates the context

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 10);
    contract.add_validator(stake_public_key_3.clone(), 10);

    let mut validator_1 = get_validator(&contract, stake_public_key_1.clone());
    let mut validator_2 = get_validator(&contract, stake_public_key_2.clone());
    let mut validator_3 = get_validator(&contract, stake_public_key_3.clone());

    validator_1.staked = 100;
    validator_2.staked = 200;
    validator_3.staked = 300;

    update_validator(&mut contract, stake_public_key_1.clone(), &validator_1);
    update_validator(&mut contract, stake_public_key_2.clone(), &validator_2);
    update_validator(&mut contract, stake_public_key_3.clone(), &validator_3);

    let validators = contract.get_validators();

    assert_eq!(validators.len(), 3);
    assert!(check_equal_vec(
        validators,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(100),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(200),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(300),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));

    contract.total_staked = 600;
    contract.total_stake_shares = 600;

    /*
       Get stake pool to stake into
    */
    let validator = contract.get_validator_to_unstake();
    assert!(validator.is_some());
    assert_eq!(validator.unwrap().account_id, stake_public_key_3);

    // Validators with non_equal weights

    let mut validator_1 = get_validator(&contract, stake_public_key_1.clone());
    let mut validator_2 = get_validator(&contract, stake_public_key_2.clone());
    let mut validator_3 = get_validator(&contract, stake_public_key_3.clone());

    validator_1.staked = ntoy(100);
    validator_1.weight = 10;
    validator_2.staked = ntoy(400);
    validator_2.weight = 20;
    validator_3.staked = ntoy(300);
    validator_3.weight = 30;
    contract.total_validator_weight = 60;

    update_validator(&mut contract, stake_public_key_1.clone(), &validator_1);
    update_validator(&mut contract, stake_public_key_2.clone(), &validator_2);
    update_validator(&mut contract, stake_public_key_3.clone(), &validator_3);

    let validators = contract.get_validators();

    assert_eq!(validators.len(), 3);
    assert!(check_equal_vec(
        validators,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(ntoy(400)),
                unstaked: U128(0),
                weight: 20,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(ntoy(300)),
                unstaked: U128(0),
                weight: 30,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));

    contract.total_staked = ntoy(800);
    contract.total_stake_shares = ntoy(800);

    /*
       Get stake pool to stake into
    */
    let validator = contract.get_validator_to_unstake();
    assert!(validator.is_some());
    assert_eq!(validator.unwrap().account_id, stake_public_key_2);
}

#[test]
fn test_get_validator_to_stake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
        Get stake pool in empty stake pool set
    */
    let stake_pool = contract.get_validator_to_stake(0);
    assert!(stake_pool.0.is_none());

    /*
       seed staking pools
    */
    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context); // this updates the context

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 10);
    contract.add_validator(stake_public_key_3.clone(), 10);

    let mut validator_1 = get_validator(&contract, stake_public_key_1.clone());
    let mut validator_2 = get_validator(&contract, stake_public_key_2.clone());
    let mut validator_3 = get_validator(&contract, stake_public_key_3.clone());

    validator_1.staked = 100;
    validator_2.staked = 200;
    validator_3.staked = 300;

    update_validator(&mut contract, stake_public_key_1.clone(), &validator_1);
    update_validator(&mut contract, stake_public_key_2.clone(), &validator_2);
    update_validator(&mut contract, stake_public_key_3.clone(), &validator_3);

    let validators = contract.get_validators();

    assert_eq!(validators.len(), 3);
    assert!(check_equal_vec(
        validators,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(100),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(200),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(300),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));

    contract.total_staked = 700;
    contract.total_stake_shares = 700;

    /*
       Get stake pool to stake into
    */
    let validator = contract.get_validator_to_stake(100);
    assert!(validator.0.is_some());
    assert_eq!(validator.0.unwrap().account_id, stake_public_key_1);
    assert_eq!(validator.1, 100);

    // Validators with non_equal weights

    let mut validator_1 = get_validator(&contract, stake_public_key_1.clone());
    let mut validator_2 = get_validator(&contract, stake_public_key_2.clone());
    let mut validator_3 = get_validator(&contract, stake_public_key_3.clone());

    validator_1.staked = ntoy(100);
    validator_1.weight = 10;
    validator_2.staked = ntoy(100);
    validator_2.weight = 20;
    validator_3.staked = ntoy(400);
    validator_3.weight = 30;
    contract.total_validator_weight = 60;

    update_validator(&mut contract, stake_public_key_1.clone(), &validator_1);
    update_validator(&mut contract, stake_public_key_2.clone(), &validator_2);
    update_validator(&mut contract, stake_public_key_3.clone(), &validator_3);

    let validators = contract.get_validators();

    assert_eq!(validators.len(), 3);
    assert!(check_equal_vec(
        validators,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 20,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(ntoy(400)),
                unstaked: U128(0),
                weight: 30,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));

    contract.total_staked = ntoy(700);
    contract.total_stake_shares = ntoy(700);

    /*
       Get stake pool to stake into
    */
    let validator = contract.get_validator_to_stake(ntoy(100));
    assert!(validator.0.is_some());
    assert_eq!(validator.0.unwrap().account_id, stake_public_key_2);
    assert_eq!(validator.1, ntoy(100));

    let validator = contract.get_validator_to_stake(ntoy(101));
    assert!(validator.0.is_some());
    assert_eq!(validator.0.unwrap().account_id, stake_public_key_2);
    assert_eq!(validator.1, ntoy(101));

    // Validators with equal weights and equal amounts

    let mut validator_1 = get_validator(&contract, stake_public_key_1.clone());
    let mut validator_2 = get_validator(&contract, stake_public_key_2.clone());
    let mut validator_3 = get_validator(&contract, stake_public_key_3.clone());

    validator_1.staked = ntoy(100);
    validator_1.weight = 10;
    validator_2.staked = ntoy(100);
    validator_2.weight = 10;
    validator_3.staked = ntoy(100);
    validator_3.weight = 10;
    contract.total_validator_weight = 30;

    update_validator(&mut contract, stake_public_key_1.clone(), &validator_1);
    update_validator(&mut contract, stake_public_key_2.clone(), &validator_2);
    update_validator(&mut contract, stake_public_key_3.clone(), &validator_3);

    let validators = contract.get_validators();

    assert_eq!(validators.len(), 3);
    assert!(check_equal_vec(
        validators,
        vec![
            ValidatorInfoResponse {
                account_id: stake_public_key_1.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_2.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            },
            ValidatorInfoResponse {
                account_id: stake_public_key_3.clone(),
                staked: U128(ntoy(100)),
                unstaked: U128(0),
                weight: 10,
                last_asked_rewards_epoch_height: U64(0),
                last_unstake_start_epoch: U64(0),
            }
        ]
    ));

    contract.total_staked = ntoy(700);
    contract.total_stake_shares = ntoy(700);

    /*
       Get stake pool to stake into
    */
    let validator = contract.get_validator_to_stake(ntoy(100));
    assert!(validator.0.is_some());
    assert_eq!(validator.0.unwrap().account_id, stake_public_key_1);
    assert_eq!(validator.1, ntoy(100));

    let validator = contract.get_validator_to_stake(ntoy(101));
    assert!(validator.0.is_some());
    assert_eq!(validator.0.unwrap().account_id, stake_public_key_1);
    assert_eq!(validator.1, ntoy(101));
}

#[test]
#[should_panic]
fn test_add_min_storage_reserve_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = operator_account();
    context.signer_account_id = operator_account();
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    contract.add_min_storage_reserve();
}

#[test]
fn test_add_min_storage_reserve_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = ntoy(50);
    testing_env!(context.clone()); // this updates the context

    contract.min_storage_reserve = ntoy(10);

    contract.add_min_storage_reserve();

    assert_eq!(contract.min_storage_reserve, ntoy(60));
}

#[test]
#[should_panic]
fn test_set_reward_fee_fail() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 5;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    /*
       Set reward fee more than 10%
    */
    contract.set_reward_fee(15, 100);
}

#[test]
fn test_set_reward_fee_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 5;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    /*
       Set reward fee to 9%
    */
    contract.set_reward_fee(9, 100);

    assert!(contract.temp_reward_fee.is_some());
    assert_eq!(contract.temp_reward_fee.unwrap().numerator, 9);
    assert_eq!(contract.temp_reward_fee.unwrap().denominator, 100);

    /*
        Set reward fee to 10%
    */
    contract.set_reward_fee(10, 100);

    assert!(contract.temp_reward_fee.is_some());
    assert_eq!(contract.temp_reward_fee.unwrap().numerator, 10);
    assert_eq!(contract.temp_reward_fee.unwrap().denominator, 100);
}

#[test]
#[should_panic]
fn test_commit_future_reward_fee_not_set() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 10;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    contract.commit_reward_fee();
}

#[test]
#[should_panic]
fn test_commit_future_reward_fee_in_wait_time() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 10;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    contract.temp_reward_fee = Some(Fraction::new(5, 100));
    contract.last_reward_fee_set_epoch = 8;

    contract.commit_reward_fee();
}

#[test]
fn test_commit_future_reward_fee_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 13;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    contract.rewards_fee = Fraction::new(9, 100);
    contract.temp_reward_fee = Some(Fraction::new(8, 100));
    contract.last_reward_fee_set_epoch = 8;

    contract.commit_reward_fee();

    assert_eq!(contract.rewards_fee.numerator, 8);
    assert_eq!(contract.rewards_fee.denominator, 100);
    assert!(contract.temp_reward_fee.is_none());
}

#[test]
#[should_panic]
fn test_autocompound_rewards_contract_busy() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.autocompounding_epoch(AccountId::from_str("random_validator").unwrap());
}

#[test]
#[should_panic]
fn test_autocompound_rewards_invalid_validator() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.autocompounding_epoch(AccountId::from_str("invalid_validator").unwrap());
}

#[test]
fn test_autocompound_rewards_stake_pool_with_no_stake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    /*
       Add stake pool
    */
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 5;
    context.attached_deposit = 1;
    testing_env!(context.clone()); // this updates the context

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    let stake_pools = contract.get_validators();
    assert_eq!(stake_pools.len(), 1);
    assert!(check_equal_vec(
        stake_pools,
        vec![ValidatorInfoResponse {
            account_id: stake_public_key_1.clone(),
            staked: U128(0),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }]
    ));

    // Redeeming rewards with no stake amount with validators
    contract.autocompounding_epoch(stake_public_key_1.clone());

    let mut validator1 = get_validator(&contract, stake_public_key_1.clone());

    /*
       Redeeming rewards in the same epoch
    */

    validator1.last_redeemed_rewards_epoch = context.epoch_height;
    validator1.staked = ntoy(100);

    update_validator(&mut contract, stake_public_key_1.clone(), &validator1);
    contract.autocompounding_epoch(stake_public_key_1.clone());

    let mut validator1 = get_validator(&contract, stake_public_key_1.clone());

    /*
       Successful case
    */
    context.epoch_height = 100;
    testing_env!(context.clone());
    validator1.last_redeemed_rewards_epoch = 4;
    validator1.staked = ntoy(100);
    update_validator(&mut contract, stake_public_key_1.clone(), &validator1);

    contract.autocompounding_epoch(stake_public_key_1.clone());
}

#[test]
fn test_on_get_sp_staked_balance_for_rewards() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    let stake_pools = contract.get_validators();
    assert_eq!(stake_pools.len(), 1);
    assert!(check_equal_vec(
        stake_pools,
        vec![ValidatorInfoResponse {
            account_id: stake_public_key_1.clone(),
            staked: U128(0),
            unstaked: U128(0),
            weight: 10,
            last_asked_rewards_epoch_height: U64(0),
            last_unstake_start_epoch: U64(0),
        }]
    ));

    context.predecessor_account_id = contract_account();
    context.epoch_height = 100;
    testing_env!(context.clone());

    let mut validator1 = get_validator(&contract, stake_public_key_1.clone());
    validator1.staked = ntoy(100);
    update_validator(&mut contract, stake_public_key_1.clone(), &validator1);

    contract.rewards_fee = Fraction::new(10, 100);
    contract.total_staked = ntoy(100);
    contract.total_stake_shares = ntoy(100);

    let _res = contract.on_get_sp_staked_balance_for_rewards(validator1, U128::from(ntoy(150)));

    let validator1 = get_validator(&contract, stake_public_key_1.clone());
    assert_eq!(validator1.staked, ntoy(150));
    assert_eq!(validator1.last_redeemed_rewards_epoch, context.epoch_height);
    assert_eq!(contract.total_staked, ntoy(150));
    assert_eq!(contract.total_stake_shares, 103333333333333333333333333);
    assert_eq!(contract.accumulated_staked_rewards, ntoy(50));

    let treasury_account = contract.get_account(treasury_account());
    assert!(abs_diff_eq(
        treasury_account.staked_balance.0,
        ntoy(5),
        ntoy(1)
    ));
}

#[test]
#[should_panic]
fn test_deposit_and_stake_fail_min_deposit() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.attached_deposit = 100;
    testing_env!(context);

    contract.min_deposit_amount = 200;

    contract.deposit_and_stake();
}

#[test]
#[should_panic]
fn test_deposit_and_stake_fail_zero_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.attached_deposit = 0;
    testing_env!(context);

    contract.deposit_and_stake();
}

#[test]
fn test_deposit_and_stake_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.min_deposit_amount = ntoy(1);
    contract.total_staked = ntoy(10);
    contract.total_stake_shares = ntoy(10);
    contract.user_amount_to_stake_in_epoch = ntoy(10);

    context.attached_deposit = 3000000000000000000000;
    testing_env!(context.clone());
    contract.storage_deposit(None, None);

    context.attached_deposit = ntoy(100);
    testing_env!(context.clone());
    contract.deposit_and_stake();

    let user1_account = contract.get_account(user1.clone());
    assert_eq!(user1_account.staked_balance, U128(ntoy(100)));

    assert_eq!(contract.total_staked, ntoy(110));
    assert_eq!(contract.total_stake_shares, ntoy(110));
    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(110));

    // Test when price > 1
    // price is 1.5
    contract.total_staked = ntoy(15);
    contract.total_stake_shares = ntoy(10);
    contract.user_amount_to_stake_in_epoch = ntoy(20);

    context.attached_deposit = ntoy(100);
    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.deposit_and_stake();

    let user1_account = contract.get_account(user1.clone());

    assert_eq!(
        user1_account.staked_balance,
        U128(250000000000000000000000001)
    );

    assert_eq!(contract.total_staked, ntoy(115));
    assert_eq!(contract.total_stake_shares, 76666666666666666666666666);
    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(120));
}

#[test]
fn test_epoch_reconcilation() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    testing_env!(context);

    contract.last_reconcilation_epoch = 99;
    contract.user_amount_to_stake_in_epoch = ntoy(100);
    contract.user_amount_to_unstake_in_epoch = ntoy(150);
    contract.reconciled_epoch_stake_amount = ntoy(10);
    contract.reconciled_epoch_unstake_amount = ntoy(10);

    contract.epoch_reconcilation();

    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(0));
    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(0));
    assert_eq!(contract.reconciled_epoch_unstake_amount, ntoy(50));
    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(0));
    assert_eq!(contract.last_reconcilation_epoch, 100);
}

#[test]
fn test_epoch_reconcilation_with_rewards_buffer() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.predecessor_account_id = operator_account();
    context.attached_deposit = ntoy(10);
    testing_env!(context.clone());

    contract.total_staked = ntoy(200);

    contract.update_rewards_buffer();

    assert_eq!(contract.total_staked, ntoy(210));
    assert_eq!(contract.rewards_buffer, ntoy(10));
    assert_eq!(contract.accumulated_rewards_buffer, ntoy(10));

    contract.last_reconcilation_epoch = 99;
    contract.user_amount_to_stake_in_epoch = ntoy(100);
    contract.user_amount_to_unstake_in_epoch = ntoy(150);
    contract.reconciled_epoch_stake_amount = ntoy(10);
    contract.reconciled_epoch_unstake_amount = ntoy(10);

    contract.epoch_reconcilation();

    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(0));
    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(0));
    assert_eq!(contract.reconciled_epoch_unstake_amount, ntoy(40));
    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(0));
    assert_eq!(contract.last_reconcilation_epoch, 100);
    assert_eq!(contract.rewards_buffer, ntoy(0));
    assert_eq!(contract.accumulated_rewards_buffer, ntoy(10));

    contract.user_amount_to_unstake_in_epoch = ntoy(20);
    contract.user_amount_to_stake_in_epoch = ntoy(0);
    contract.reconciled_epoch_stake_amount = ntoy(0);
    contract.reconciled_epoch_unstake_amount = ntoy(0);

    context.epoch_height = 101;
    context.predecessor_account_id = operator_account();
    context.attached_deposit = ntoy(30);
    testing_env!(context);

    contract.update_rewards_buffer();

    assert_eq!(contract.rewards_buffer, ntoy(30));
    assert_eq!(contract.accumulated_rewards_buffer, ntoy(40));

    contract.epoch_reconcilation();

    assert_eq!(contract.rewards_buffer, ntoy(10));
    assert_eq!(contract.accumulated_rewards_buffer, ntoy(40));
    assert_eq!(contract.reconciled_epoch_unstake_amount, ntoy(0));
    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(0));
    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(0));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(0));
}

#[test]
#[should_panic]
fn test_epoch_stake_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.staking_epoch_paused = true;

    contract.staking_epoch();
}

#[test]
#[should_panic]
fn test_epoch_unstake_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.unstaking_epoch_paused = true;

    contract.unstaking_epoch();
}

#[test]
#[should_panic]
fn test_epoch_withdraw_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.withdraw_epoch_paused = true;

    contract.withdraw_epoch(AccountId::from_str("random_validator").unwrap());
}

#[test]
#[should_panic]
fn test_epoch_autocompounding_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.autocompounding_epoch_paused = true;

    contract.autocompounding_epoch(AccountId::from_str("random_validator").unwrap());
}

#[test]
#[should_panic]
fn test_stake_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.stake_paused = true;

    contract.deposit_and_stake();
}

#[test]
#[should_panic]
fn test_unstake_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.unstaked_paused = true;

    contract.unstake(U128(100));
}

#[test]
#[should_panic]
fn test_withdraw_paused() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.withdraw_paused = true;

    contract.withdraw(U128(100));
}

#[test]
#[should_panic]
fn test_ft_transfer_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.ft_transfer_paused = true;
    context.attached_deposit = 1;
    testing_env!(context);

    contract.ft_transfer(operator_account(), U128(100), None);
}

#[test]
#[should_panic]
fn test_ft_transfer_call_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.ft_transfer_call_paused = true;
    context.attached_deposit = 1;
    testing_env!(context);

    contract.ft_transfer_call(operator_account(), U128(100), None, "".to_string());
}

#[test]
#[should_panic]
fn test_epoch_stake_no_validator() {
    let (mut _context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.last_reconcilation_epoch = 99;
    contract.total_staked = ntoy(350);
    contract.user_amount_to_stake_in_epoch = ntoy(150);
    contract.user_amount_to_unstake_in_epoch = ntoy(100);
    contract.reconciled_epoch_stake_amount = ntoy(10);
    contract.reconciled_epoch_unstake_amount = ntoy(10);

    while contract.staking_epoch() {}

    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(0));
    assert_eq!(contract.last_reconcilation_epoch, 100);
}

#[test]
fn test_epoch_stake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.attached_deposit = 1;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    testing_env!(context);

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1_info);

    let mut val2_info = get_validator(&contract, validator2.clone());
    val2_info.staked = ntoy(200);
    update_validator(&mut contract, validator2.clone(), &val2_info);

    contract.last_reconcilation_epoch = 99;
    contract.total_staked = ntoy(350);
    contract.user_amount_to_stake_in_epoch = ntoy(150);
    contract.user_amount_to_unstake_in_epoch = ntoy(100);
    contract.reconciled_epoch_stake_amount = ntoy(10);
    contract.reconciled_epoch_unstake_amount = ntoy(10);

    while contract.staking_epoch() {}

    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(0));
    assert_eq!(contract.last_reconcilation_epoch, 100);
}

#[test]
fn test_on_validator_deposit_and_stake_failed() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    context.predecessor_account_id = contract_account();
    testing_env!(context.clone());

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.reconciled_epoch_stake_amount = ntoy(10);

    testing_env_with_promise_results(context.clone(), PromiseResult::Failed);

    contract.on_stake_pool_deposit_and_stake(validator1.clone(), ntoy(10));

    assert_eq!(contract.reconciled_epoch_stake_amount, ntoy(20));
}

#[test]
fn test_on_validator_unstake_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    context.predecessor_account_id = contract_account();
    testing_env!(context.clone());

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(90);
    val1_info.unstake_start_epoch = 10;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    testing_env_with_promise_results(context.clone(), PromiseResult::Successful(Vec::default()));

    contract.on_stake_pool_unstake(val1_info.account_id, ntoy(10));

    let mut val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.staked, ntoy(90));
    assert_eq!(val1_info.unstaked_amount, ntoy(10));
    assert_eq!(val1_info.unstake_start_epoch, 10);
}

#[test]
fn test_on_validator_unstake_fail() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    context.predecessor_account_id = contract_account();
    testing_env!(context.clone());

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(90);
    val1_info.unstake_start_epoch = 10;
    val1_info.last_unstake_start_epoch = 5;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.reconciled_epoch_unstake_amount = ntoy(10);

    testing_env_with_promise_results(context.clone(), PromiseResult::Failed);

    contract.on_stake_pool_unstake(val1_info.account_id, ntoy(10));

    let mut val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.staked, ntoy(100));
    assert_eq!(val1_info.unstaked_amount, ntoy(0));
    assert_eq!(val1_info.unstake_start_epoch, 5);

    assert_eq!(contract.reconciled_epoch_unstake_amount, ntoy(20));
}

#[test]
fn test_on_validator_deposit_and_stake_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    context.predecessor_account_id = contract_account();
    testing_env!(context.clone());

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1_info);

    testing_env_with_promise_results(context.clone(), PromiseResult::Successful(Vec::default()));

    contract.on_stake_pool_deposit_and_stake(validator1.clone(), ntoy(10));

    let val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.staked, ntoy(110));
}

#[test]
fn test_get_unstake_release_epoch() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.epoch_height = 10;
    context.attached_deposit = 1;
    testing_env!(context.clone());

    // Enough amount available to unstake

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1_info);

    let mut val2_info = get_validator(&contract, validator2.clone());
    val2_info.staked = ntoy(200);
    update_validator(&mut contract, validator2.clone(), &val2_info);

    let mut val3_info = get_validator(&contract, validator3.clone());
    val3_info.staked = ntoy(300);
    update_validator(&mut contract, validator3.clone(), &val3_info);

    let wait_time = contract.get_unstake_release_epoch(ntoy(100));
    assert_eq!(wait_time, NUM_EPOCHS_TO_UNLOCK);

    context.epoch_height = 10;
    testing_env!(context.clone());

    // Not enough amount available to unstake
    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    val1_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    let mut val2_info = get_validator(&contract, validator2.clone());
    val2_info.staked = ntoy(200);
    val2_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator2.clone(), &val2_info);

    let mut val3_info = get_validator(&contract, validator3.clone());
    val3_info.staked = ntoy(300);
    val3_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator3.clone(), &val3_info);

    let wait_time = contract.get_unstake_release_epoch(ntoy(300));
    assert_eq!(wait_time, 2 * NUM_EPOCHS_TO_UNLOCK);
}

#[test]
#[should_panic]
fn test_withdraw_fail_zero_deposit() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.withdraw(U128(0));
}

#[test]
#[should_panic]
fn test_withdraw_fail_not_enough_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount += ntoy(100);
    update_account(&mut contract, user1.clone(), &user1_account);

    context.predecessor_account_id = user1;
    testing_env!(context.clone());

    contract.withdraw(U128(ntoy(200)));
}

#[test]
#[should_panic]
fn test_withdraw_fail_before_withdrawable_epoch() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount = ntoy(300);
    user1_account.withdrawable_epoch_height = 10;
    update_account(&mut contract, user1.clone(), &user1_account);

    context.epoch_height = 8;
    context.predecessor_account_id = user1;
    testing_env!(context.clone());

    contract.withdraw(U128(ntoy(200)));
}

#[test]
#[should_panic]
fn test_withdraw_fail_not_enough_storage_balance() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount = ntoy(200);
    user1_account.withdrawable_epoch_height = 10;
    update_account(&mut contract, user1.clone(), &user1_account);

    context.epoch_height = 12;
    context.predecessor_account_id = user1;
    context.account_balance = ntoy(230);
    contract.min_storage_reserve = ntoy(50);
    testing_env!(context.clone());

    contract.withdraw(U128(ntoy(200)));
}

#[test]
fn test_withdraw_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount += ntoy(300);
    user1_account.withdrawable_epoch_height = 10;
    update_account(&mut contract, user1.clone(), &user1_account);

    context.epoch_height = 12;
    context.predecessor_account_id = user1.clone();
    context.account_balance = ntoy(270);
    testing_env!(context.clone());

    contract.withdraw(U128(ntoy(200)));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.unstaked_amount, ntoy(100));
}

#[test]
fn test_withdraw_success_with_storage_balance_with_no_staked_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount += ntoy(300);
    user1_account.withdrawable_epoch_height = 10;
    update_account(&mut contract, user1.clone(), &user1_account);

    contract.min_storage_reserve = ntoy(50);

    context.epoch_height = 12;
    context.predecessor_account_id = user1.clone();
    context.account_balance = ntoy(400);
    testing_env!(context.clone());

    contract.withdraw(U128(299999900000000000000000000));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.unstaked_amount, 0);
    assert_eq!(user1_account.stake_shares, 0);
}

#[test]
fn test_withdraw_success_with_storage_balance_with_staked_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();

    let mut user1_account = Account::default();
    user1_account.unstaked_amount += ntoy(300);
    user1_account.stake_shares = ntoy(10);
    user1_account.withdrawable_epoch_height = 10;
    update_account(&mut contract, user1.clone(), &user1_account);

    contract.min_storage_reserve = ntoy(50);

    context.epoch_height = 12;
    context.predecessor_account_id = user1.clone();
    context.account_balance = ntoy(400);
    testing_env!(context.clone());

    contract.withdraw(U128(299999900000000000000000000));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(10));
    assert_eq!(user1_account.unstaked_amount, ntoy(0));
}

#[test]
#[should_panic]
fn test_epoch_withdraw_fail_validator_in_unbonding() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 10;
    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.unstaked_amount = ntoy(100);
    val1_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.withdraw_epoch(validator1.clone());
}

#[test]
#[should_panic]
fn test_epoch_withdraw_fail_validator_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 20;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.unstaked_amount = ntoy(100);
    val1_info.unstake_start_epoch = 9;
    val1_info.weight = 0;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.withdraw_epoch(validator1.clone());
}

#[test]
fn test_epoch_withdraw_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 4;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(50);
    val1_info.unstaked_amount = ntoy(100);
    val1_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.withdraw_epoch(validator1.clone());

    let val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.unstaked_amount, ntoy(0));
}

#[test]
fn test_on_stake_pool_withdraw_all_fail() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.epoch_height = 4;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    contract.add_validator(validator1.clone(), 10);

    context.predecessor_account_id = contract_account();
    testing_env!(context.clone());

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(50);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    testing_env_with_promise_results(context.clone(), PromiseResult::Failed);

    contract.on_stake_pool_withdraw_all(val1_info, ntoy(100));

    let val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.unstaked_amount, ntoy(100));
}

#[test]
#[should_panic]
fn test_unstake_fail_zero_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.unstake(U128(ntoy(0)));
}

#[test]
#[should_panic]
fn test_unstake_fail_greater_than_total_staked_amount() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.total_staked = ntoy(100);

    contract.unstake(U128(ntoy(200)));
}

#[test]
fn test_unstake_success_remaining_amount_less_than_storage_deposit() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();
    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    context.epoch_height = 10;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(500);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.total_staked = ntoy(500);
    contract.total_stake_shares = ntoy(500);
    contract.last_reconcilation_epoch = 8;
    contract.user_amount_to_unstake_in_epoch = ntoy(60);

    let mut user1_account = Account::default();
    user1_account.stake_shares = ntoy(50);
    user1_account.unstaked_amount = ntoy(0);
    update_account(&mut contract, user1.clone(), &user1_account);

    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.unstake(U128(49999000000000000000000000));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(0));
    assert_eq!(user1_account.unstaked_amount, ntoy(50));
    assert_eq!(user1_account.withdrawable_epoch_height, 14);

    assert_eq!(contract.total_staked, ntoy(450));
    assert_eq!(contract.total_stake_shares, ntoy(450));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(110));
}

#[test]
fn test_unstake_success_diff_epoch_than_reconcilation_epoch() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();
    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    context.epoch_height = 10;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(300);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.total_staked = ntoy(100);
    contract.total_stake_shares = ntoy(100);
    contract.last_reconcilation_epoch = 8;
    contract.user_amount_to_unstake_in_epoch = ntoy(60);

    let mut user1_account = Account::default();
    user1_account.stake_shares = ntoy(50);
    user1_account.unstaked_amount = ntoy(10);
    update_account(&mut contract, user1.clone(), &user1_account);

    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.unstake(U128(ntoy(10)));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(40));
    assert_eq!(user1_account.unstaked_amount, ntoy(20));
    assert_eq!(user1_account.withdrawable_epoch_height, 14);

    assert_eq!(contract.total_staked, ntoy(90));
    assert_eq!(contract.total_stake_shares, ntoy(90));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(70));
}

#[test]
fn test_unstake_success_same_epoch_as_reconcilation_epoch() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();
    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();

    context.epoch_height = 10;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(300);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.total_staked = ntoy(100);
    contract.total_stake_shares = ntoy(100);
    contract.last_reconcilation_epoch = 10;
    contract.user_amount_to_unstake_in_epoch = ntoy(60);

    let mut user1_account = Account::default();
    user1_account.stake_shares = ntoy(50);
    user1_account.unstaked_amount = ntoy(10);
    update_account(&mut contract, user1.clone(), &user1_account);

    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.unstake(U128(ntoy(10)));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(40));
    assert_eq!(user1_account.unstaked_amount, ntoy(20));
    assert_eq!(user1_account.withdrawable_epoch_height, 15);

    assert_eq!(contract.total_staked, ntoy(90));
    assert_eq!(contract.total_stake_shares, ntoy(90));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(70));
}

#[test]
fn test_unstake_success_without_validators_to_unstake_from() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1 = AccountId::from_str("user1").unwrap();
    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();

    context.epoch_height = 10;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 9;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    let mut val2_info = get_validator(&contract, validator2.clone());
    val2_info.staked = ntoy(100);
    val2_info.unstaked_amount = ntoy(0);
    val2_info.unstake_start_epoch = 4;
    update_validator(&mut contract, validator2.clone(), &val2_info);

    contract.total_staked = ntoy(200);
    contract.total_stake_shares = ntoy(200);
    contract.last_reconcilation_epoch = 9;
    contract.user_amount_to_unstake_in_epoch = ntoy(60);

    let mut user1_account = Account::default();
    user1_account.stake_shares = ntoy(150);
    user1_account.unstaked_amount = ntoy(10);
    update_account(&mut contract, user1.clone(), &user1_account);

    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.unstake(U128(ntoy(80)));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(70));
    assert_eq!(user1_account.unstaked_amount, ntoy(90));
    assert_eq!(user1_account.withdrawable_epoch_height, 14);

    assert_eq!(contract.total_staked, ntoy(120));
    assert_eq!(contract.total_stake_shares, ntoy(120));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(140));

    context.epoch_height = 11;
    context.predecessor_account_id = user1.clone();
    testing_env!(context.clone());

    contract.unstake(U128(ntoy(40)));

    let user1_account = get_account(&contract, user1.clone());
    assert_eq!(user1_account.stake_shares, ntoy(30));
    assert_eq!(user1_account.unstaked_amount, ntoy(130));
    assert_eq!(user1_account.withdrawable_epoch_height, 19);

    assert_eq!(contract.total_staked, ntoy(80));
    assert_eq!(contract.total_stake_shares, ntoy(80));
    assert_eq!(contract.user_amount_to_unstake_in_epoch, ntoy(180));
}

#[test]
fn test_epoch_unstake_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    val1_info.unstaked_amount = ntoy(0);
    val1_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    let mut val2_info = get_validator(&contract, validator2.clone());
    val2_info.staked = ntoy(200);
    val2_info.unstaked_amount = ntoy(0);
    val2_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator2.clone(), &val2_info);

    let mut val3_info = get_validator(&contract, validator3.clone());
    val3_info.staked = ntoy(300);
    val3_info.unstaked_amount = ntoy(0);
    val3_info.unstake_start_epoch = 3;
    update_validator(&mut contract, validator3.clone(), &val3_info);

    contract.last_reconcilation_epoch = 99;
    contract.user_amount_to_stake_in_epoch = ntoy(100);
    contract.user_amount_to_unstake_in_epoch = ntoy(150);
    contract.reconciled_epoch_stake_amount = ntoy(10);
    contract.reconciled_epoch_unstake_amount = ntoy(10);

    contract.unstaking_epoch();

    assert_eq!(contract.last_reconcilation_epoch, 100);
    let val3_info = get_validator(&contract, validator3.clone());
    assert_eq!(val3_info.staked, ntoy(250));
    assert_eq!(val3_info.unstake_start_epoch, 100);
    assert_eq!(val3_info.last_unstake_start_epoch, 3);
    assert_eq!(contract.reconciled_epoch_unstake_amount, 0);
}

#[test]
#[should_panic]
fn test_drain_unstake_fail_validator_not_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.drain_unstake(validator1);
}

#[test]
#[should_panic]
fn test_drain_unstake_fail_validator_pending_release() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.unstake_start_epoch = 99;
    val1_info.weight = 0;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.drain_unstake(validator1);
}

#[test]
#[should_panic]
fn test_drain_unstake_fail_validator_has_unstake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.unstake_start_epoch = 33;
    val1_info.weight = 0;
    val1_info.unstaked_amount = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.drain_unstake(validator1);
}

#[test]
fn test_drain_unstake_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1_info = get_validator(&contract, validator1.clone());
    val1_info.staked = ntoy(100);
    val1_info.unstake_start_epoch = 33;
    val1_info.weight = 0;
    update_validator(&mut contract, validator1.clone(), &val1_info);

    contract.drain_unstake(validator1.clone());

    let val1_info = get_validator(&contract, validator1.clone());
    assert_eq!(val1_info.staked, ntoy(0));
    assert_eq!(val1_info.unstake_start_epoch, 100);
    assert_eq!(val1_info.last_unstake_start_epoch, 33);
}

#[test]
fn test_on_stake_pool_drain_unstake_promise_fail() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    testing_env_with_promise_results(context.clone(), PromiseResult::Failed);

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.last_unstake_start_epoch = 33;
    val1.unstake_start_epoch = 100;
    val1.staked = 0;
    update_validator(&mut contract, validator1.clone(), &val1);

    contract.on_stake_pool_drain_unstake(validator1.clone(), ntoy(100));

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 33;
    val1.staked = ntoy(100);
}

#[test]
fn test_on_stake_pool_drain_unstake_promise_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    testing_env_with_promise_results(context.clone(), PromiseResult::Successful(Vec::default()));

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.last_unstake_start_epoch = 33;
    val1.unstake_start_epoch = 100;
    val1.staked = 0;
    val1.unstaked_amount = 0;
    update_validator(&mut contract, validator1.clone(), &val1);

    contract.on_stake_pool_drain_unstake(validator1.clone(), ntoy(100));

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 100;
    val1.staked = 0;
    val1.unstaked_amount = ntoy(100);
}

#[test]
#[should_panic]
fn test_drain_withdraw_fail_validator_not_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.drain_withdraw(validator1);
}

#[test]
#[should_panic]
fn test_drain_withdraw_fail_validator_has_non_zero_staked() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 100;
    val1.staked = ntoy(100);
    val1.unstaked_amount = 0;
    update_validator(&mut contract, validator1.clone(), &val1);

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.drain_withdraw(validator1);
}

#[test]
#[should_panic]
fn test_drain_withdraw_fail_validator_pending_unstake() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 99;
    val1.staked = ntoy(0);
    val1.unstaked_amount = ntoy(100);
    update_validator(&mut contract, validator1.clone(), &val1);

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.drain_withdraw(validator1);
}

#[test]
fn test_drain_withdraw_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 23;
    val1.staked = ntoy(0);
    val1.unstaked_amount = ntoy(100);
    val1.weight = 0;
    update_validator(&mut contract, validator1.clone(), &val1);

    contract.drain_withdraw(validator1.clone());

    let mut val1 = get_validator(&contract, validator1.clone());
    assert_eq!(val1.unstaked_amount, 0);
}

#[test]
fn test_on_stake_pool_drain_withdraw_failure() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 88;
    val1.staked = ntoy(0);
    val1.unstaked_amount = ntoy(0);
    update_validator(&mut contract, validator1.clone(), &val1);

    testing_env_with_promise_results(context.clone(), PromiseResult::Failed);

    contract.on_stake_pool_drain_withdraw(validator1.clone(), ntoy(100));

    let mut val1 = get_validator(&contract, validator1.clone());
    assert_eq!(val1.unstaked_amount, ntoy(100));
}

#[test]
fn test_on_stake_pool_drain_withdraw_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.user_amount_to_stake_in_epoch = ntoy(100);

    let mut val1 = get_validator(&contract, validator1.clone());
    val1.unstake_start_epoch = 88;
    val1.staked = ntoy(0);
    val1.unstaked_amount = ntoy(0);
    update_validator(&mut contract, validator1.clone(), &val1);

    testing_env_with_promise_results(context.clone(), PromiseResult::Successful(Vec::default()));

    contract.on_stake_pool_drain_withdraw(validator1.clone(), ntoy(100));

    assert_eq!(contract.user_amount_to_stake_in_epoch, ntoy(200));
}

#[test]
#[should_panic]
fn test_sync_balance_from_validator_paused() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    contract.operations_control.sync_validator_balance_paused = true;

    contract.sync_balance_from_validator(AccountId::from_str("abc").unwrap());
}

#[test]
fn test_sync_balance_from_validator_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    contract.sync_balance_from_validator(validator1);
}

#[test]
#[should_panic]
fn test_on_stake_pool_get_account_total_balance_off() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut validator1_info = get_validator(&contract, validator1.clone());
    validator1_info.staked = 99000000000000000000000000;
    validator1_info.unstaked_amount = 9000000000000000000000000;
    update_validator(&mut contract, validator1.clone(), &validator1_info);

    contract.on_stake_pool_get_account(
        validator1.clone(),
        HumanReadableAccount {
            account_id: validator1.clone(),
            unstaked_balance: U128(9000000000000000000000008),
            staked_balance: U128(98999999999999999999999996),
            can_withdraw: false,
        },
    );

    let mut validator1_info = get_validator(&contract, validator1.clone());
    assert_eq!(validator1_info.staked, 98999999999999999999999996);
    assert_eq!(validator1_info.unstaked_amount, 9000000000000000000000004);
}

#[test]
fn test_on_stake_pool_get_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let validator1 = AccountId::from_str("stake_public_key_1").unwrap();
    let validator2 = AccountId::from_str("stake_public_key_2").unwrap();
    let validator3 = AccountId::from_str("stake_public_key_3").unwrap();

    context.epoch_height = 100;
    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.add_validator(validator1.clone(), 10);
    contract.add_validator(validator2.clone(), 10);
    contract.add_validator(validator3.clone(), 10);

    let mut validator1_info = get_validator(&contract, validator1.clone());
    validator1_info.staked = 99000000000000000000000000;
    validator1_info.unstaked_amount = 9000000000000000000000000;
    update_validator(&mut contract, validator1.clone(), &validator1_info);

    contract.on_stake_pool_get_account(
        validator1.clone(),
        HumanReadableAccount {
            account_id: validator1.clone(),
            unstaked_balance: U128(9000000000000000000000004),
            staked_balance: U128(98999999999999999999999996),
            can_withdraw: false,
        },
    );

    let mut validator1_info = get_validator(&contract, validator1.clone());
    assert_eq!(validator1_info.staked, 98999999999999999999999996);
    assert_eq!(validator1_info.unstaked_amount, 9000000000000000000000004);
}

#[test]
#[should_panic]
fn test_set_owner_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = AccountId::from_str("user").unwrap();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    contract.set_owner(new_owner);
}

#[test]
#[should_panic]
fn test_set_owner_same_as_operator() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();
    contract.operator_account_id = new_owner.clone();

    contract.set_owner(new_owner);
}

#[test]
#[should_panic]
fn test_set_owner_same_as_treasury() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();
    contract.treasury_account_id = new_owner.clone();

    contract.set_owner(new_owner);
}

#[test]
#[should_panic]
fn test_set_owner_same_as_current_contract() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_owner(context.current_account_id);
}

#[test]
fn test_set_owner() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    contract.set_owner(new_owner.clone());

    assert_eq!(contract.temp_owner, Some(new_owner));
}

#[test]
#[should_panic]
fn test_commit_owner_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    contract.temp_owner = Some(new_owner.clone());

    contract.commit_owner();
}

#[test]
fn test_commit_owner() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    context.predecessor_account_id = new_owner.clone();
    context.signer_account_id = new_owner.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.temp_owner = Some(new_owner.clone());

    contract.commit_owner();

    assert_eq!(contract.owner_account_id, new_owner);
    assert_eq!(contract.temp_owner, None);
}

#[test]
fn set_commit_owner() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    let new_owner = AccountId::from_str("new_owner").unwrap();

    contract.set_owner(new_owner.clone());

    assert_eq!(contract.temp_owner, Some(new_owner.clone()));

    context.predecessor_account_id = new_owner.clone();
    context.signer_account_id = new_owner.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.temp_owner = Some(new_owner.clone());

    contract.commit_owner();

    assert_eq!(contract.owner_account_id, new_owner);
    assert_eq!(contract.temp_owner, None);
}

#[test]
#[should_panic]
fn test_set_operator_account_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_operator_account = AccountId::from_str("new_operator").unwrap();

    context.predecessor_account_id = AccountId::from_str("user").unwrap();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_operator_id(new_operator_account);
}

#[test]
#[should_panic]
fn test_set_operator_account_same_as_owner() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_operator_id(owner_account());
}

#[test]
#[should_panic]
fn test_set_operator_account_same_as_treasury() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_operator_id(treasury_account());
}

#[test]
#[should_panic]
fn test_set_operator_account_same_as_current_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_operator_id(context.current_account_id);
}

#[test]
#[should_panic]
fn test_set_treasury_account_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_treasury_account = AccountId::from_str("new_treasury").unwrap();

    context.predecessor_account_id = AccountId::from_str("user").unwrap();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_treasury_id(new_treasury_account);
}

#[test]
#[should_panic]
fn test_set_treasury_account_same_as_owner() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_treasury_id(owner_account());
}

#[test]
#[should_panic]
fn test_set_treasury_account_same_as_operator() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_treasury_id(operator_account());
}

#[test]
#[should_panic]
fn test_set_treasury_account_same_as_current_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_treasury_id(context.current_account_id);
}

#[test]
fn test_set_operator_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_operator_account = AccountId::from_str("new_operator").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_operator_id(new_operator_account.clone());

    contract.operator_account_id = new_operator_account;
}

#[test]
#[should_panic]
fn test_commit_operator_account_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.commit_operator_id();
}

#[test]
#[should_panic]
fn test_commit_operator_account_not_set() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = operator_account();
    context.signer_account_id = operator_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.commit_operator_id();
}

#[test]
fn test_commit_operator_account_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_operator_account = AccountId::from_str("new_operator").unwrap();

    context.predecessor_account_id = new_operator_account.clone();
    context.signer_account_id = new_operator_account.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.temp_operator = Some(new_operator_account.clone());

    contract.commit_operator_id();

    assert_eq!(contract.operator_account_id, new_operator_account);
    assert!(contract.temp_operator.is_none());
}

#[test]
fn test_set_treasury_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_treasury_account = AccountId::from_str("new_treasury").unwrap();

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_treasury_id(new_treasury_account);
}

#[test]
#[should_panic]
fn test_commit_treasury_account_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.commit_treasury_id();
}

#[test]
#[should_panic]
fn test_commit_treasury_account_not_set() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = treasury_account();
    context.signer_account_id = treasury_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.commit_treasury_id();
}

#[test]
fn test_commit_treasury_account_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let new_treasury_account = AccountId::from_str("new_treasury").unwrap();

    context.predecessor_account_id = new_treasury_account.clone();
    context.signer_account_id = new_treasury_account.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.temp_treasury = Some(new_treasury_account.clone());

    contract.commit_treasury_id();

    assert_eq!(contract.treasury_account_id, new_treasury_account);
    assert!(contract.temp_treasury.is_none());
}

#[test]
#[should_panic]
fn test_set_min_deposit_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = AccountId::from_str("user").unwrap();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_min_deposit(U128(ntoy(10)));
}

#[test]
#[should_panic]
fn test_set_min_deposit_less_than_one_near() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_min_deposit(U128(10000));
}

#[test]
#[should_panic]
fn test_set_min_deposit_more_than_100_near() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_min_deposit(U128(ntoy(200)));
}

#[test]
fn test_set_min_deposit() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.set_min_deposit(U128(ntoy(50)));

    assert_eq!(contract.min_deposit_amount, ntoy(50));
}

#[test]
#[should_panic]
fn test_pause_validator_unauthorized() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 100;
    testing_env!(context.clone());

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 20);
    contract.add_validator(stake_public_key_3.clone(), 30);

    assert_eq!(contract.total_validator_weight, 60);

    context.predecessor_account_id = AccountId::from_str("user_1").unwrap();
    testing_env!(context.clone());

    contract.pause_validator(stake_public_key_1.clone());

    let val1 = get_validator(&contract, stake_public_key_1);
    assert_eq!(val1.weight, 0);

    assert_eq!(contract.total_validator_weight, 50);
}

#[test]
fn test_pause_validator() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    context.predecessor_account_id = owner_account();
    context.signer_account_id = owner_account();
    context.attached_deposit = 1;
    context.epoch_height = 100;
    testing_env!(context.clone());

    let stake_public_key_1 = AccountId::from_str("stake_public_key_1").unwrap();
    let stake_public_key_2 = AccountId::from_str("stake_public_key_2").unwrap();
    let stake_public_key_3 = AccountId::from_str("stake_public_key_3").unwrap();

    contract.add_validator(stake_public_key_1.clone(), 10);
    contract.add_validator(stake_public_key_2.clone(), 20);
    contract.add_validator(stake_public_key_3.clone(), 30);

    assert_eq!(contract.total_validator_weight, 60);

    contract.pause_validator(stake_public_key_1.clone());

    let val1 = get_validator(&contract, stake_public_key_1);
    assert_eq!(val1.weight, 0);

    assert_eq!(contract.total_validator_weight, 50);
}

#[test]
#[should_panic]
fn test_ft_transfer_same_user() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1_account_id = AccountId::from_str("user1").unwrap();

    let user1_account = Account {
        stake_shares: ntoy(10),
        unstaked_amount: 0,
        withdrawable_epoch_height: 0,
    };

    update_account(&mut contract, user1_account_id.clone(), &user1_account);

    context.predecessor_account_id = user1_account_id.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.ft_transfer(user1_account_id.clone(), U128(ntoy(5)), None);
}

#[test]
fn test_ft_transfer() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1_account_id = AccountId::from_str("user1").unwrap();
    let user2_account_id = AccountId::from_str("user2").unwrap();

    let user1_account = Account {
        stake_shares: ntoy(10),
        unstaked_amount: 0,
        withdrawable_epoch_height: 0,
    };

    update_account(&mut contract, user1_account_id.clone(), &user1_account);

    context.predecessor_account_id = user1_account_id.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    contract.ft_transfer(user2_account_id.clone(), U128(ntoy(5)), None);

    let user1_account = get_account(&contract, user1_account_id.clone());
    assert_eq!(
        user1_account,
        Account {
            stake_shares: ntoy(5),
            unstaked_amount: 0,
            withdrawable_epoch_height: 0
        }
    );

    let user2_account = get_account(&contract, user2_account_id.clone());
    assert_eq!(
        user2_account,
        Account {
            stake_shares: ntoy(5),
            unstaked_amount: 0,
            withdrawable_epoch_height: 0
        }
    );
}

#[test]
fn test_storage_unregister_no_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1_account = AccountId::from_str("user1").unwrap();

    context.predecessor_account_id = user1_account;
    context.attached_deposit = 1;
    testing_env!(context.clone());

    assert!(!contract.storage_unregister(None));
}

#[test]
#[should_panic]
fn test_storage_unregister_account_non_empty_account() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1_account_id = AccountId::from_str("user1").unwrap();

    context.predecessor_account_id = user1_account_id.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    update_account(
        &mut contract,
        user1_account_id.clone(),
        &Account {
            stake_shares: ntoy(10),
            unstaked_amount: ntoy(10),
            withdrawable_epoch_height: 100,
        },
    );

    contract.storage_unregister(None);
}

#[test]
fn test_storage_unregister_account_success() {
    let (mut context, mut contract) =
        contract_setup(owner_account(), operator_account(), treasury_account());

    let user1_account_id = AccountId::from_str("user1").unwrap();

    context.predecessor_account_id = user1_account_id.clone();
    context.attached_deposit = 1;
    testing_env!(context.clone());

    update_account(
        &mut contract,
        user1_account_id.clone(),
        &Account {
            stake_shares: ntoy(0),
            unstaked_amount: ntoy(0),
            withdrawable_epoch_height: 100,
        },
    );

    contract.storage_unregister(None);

    let user1_account = get_account_option(&contract, user1_account_id);
    assert!(user1_account.is_none());
}

'''
'''--- scripts/deploy.sh ---
ID=staderlabs-test.near
CONTRACT_NAME=testing-token.$ID

# Create contract account
near create-account $CONTRACT_NAME --masterAccount=$ID

# Deploy the contract
near deploy $CONTRACT_NAME --wasmFile=res/near_x.wasm

# Init
near call $CONTRACT_NAME new '{"owner_account_id": "staderlabs.testnet", "operator_account_id": "bchain99.testnet", "treasury_account_id": "bchaina.testnet"}' --accountId=$ID
'''
'''--- scripts/dev-deploy.sh ---
rm -rf neardev; near dev-deploy --wasmFile res/near_x.wasm; sleep 2; source neardev/dev-account.env;
'''
'''--- scripts/dev-testing.sh ---
# add some validators
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_0"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_1"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_2"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;

# manager deposit
near call $CONTRACT_NAME manager_deposit_and_stake '{"validator": "'"$STAKE_POOL_0"'"}'  --accountId=$ID --amount=1 --gas=300000000000000;
near call $CONTRACT_NAME manager_deposit_and_stake '{"validator": "'"$STAKE_POOL_1"'"}'  --accountId=$ID --amount=1 --gas=300000000000000;
near call $CONTRACT_NAME manager_deposit_and_stake '{"validator": "'"$STAKE_POOL_12"'"}'  --accountId=$ID --amount=0.1 --gas=300000000000000;

# 10 deposits
for i in {1..3};
do
  near call $CONTRACT_NAME storage_deposit --accountId=$ID --amount=0.1 --gas=300000000000000;
  near call $CONTRACT_NAME deposit_and_stake --accountId=$ID --amount=5 --gas=300000000000000;
done;

near call $CONTRACT_NAME storage_unregister --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME unstake '{"amount": "1000000000000000000000000"}' --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME unstake_all --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME withdraw_all --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME withdraw '{"amount": "3997500000000000000000000"}' --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME storage_deposit --accountId=$ID --gas=300000000000000 --depositYocto=3000000000000000000000;

near view $CONTRACT_NAME ft_balance_of '{"account_id": "'"$ID"'"}'
near view $CONTRACT_NAME ft_total_supply

# Checking stake in the stake pool contract
near view $STAKE_POOL_0 get_account_total_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_total_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

near view $STAKE_POOL_10 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_2 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

near view $STAKE_POOL_0 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_2 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

'''
'''--- scripts/env/mainnet.env ---
CONTRACT_NAME=nearx.stader-labs.near
ID=stader-operator.near

# validators
STAKE_POOL_0=epic.poolv1.near
STAKE_POOL_1=rekt.poolv1.near
STAKE_POOL_2=stakin.poolv1.near
STAKE_POOL_3=smart-stake.poolv1.near
STAKE_POOL_4=stakesabai.poolv1.near
STAKE_POOL_5=fresh.poolv1.near
STAKE_POOL_6=dexagon.poolv1.near
STAKE_POOL_7=pandateam.poolv1.near
STAKE_POOL_8=infiniteloop.poolv1.near
STAKE_POOL_9=optimusvalidatornetwork.poolv1.near
STAKE_POOL_10=galactic.poolv1.near
STAKE_POOL_11=pathrocknetwork.poolv1.near
STAKE_POOL_12=cryptogarik.poolv1.near
STAKE_POOL_13=cryptoblossom.poolv1.near

'''
'''--- scripts/env/testnet.env ---
CONTRACT_NAME=v2-nearx.staderlabs.testnet
ID=staderlabs.testnet

# validators
STAKE_POOL_0=omnistake_v5.factory01.littlefarm.testnet
STAKE_POOL_1=pathrocknetwork.pool.f863973.m0
STAKE_POOL_2=phet90testnet.pool.f863973.m0
'''
'''--- scripts/ft_transfer.sh ---
near call $CONTRACT_NAME ft_transfer '{"receiver_id": "'"$ID"'", "amount": "20659988951999999999999999"}' --accountId=$ID --depositYocto=1 --gas=300000000000000;

near call $CONTRACT_NAME ft_transfer_call '{"receiver_id": "'"$ID"'", "amount": "3000000000000000000000000", "msg": "" }' --depositYocto=1 --accountId=$ID --gas=300000000000000;

'''
'''--- scripts/owner_update.sh ---
near call $CONTRACT_NAME set_owner '{"new_owner": "'"$ID"'"}' --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME set_operator_id '{"new_operator_account_id": "'"$ID"'"}' --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME set_treasury_id '{"new_treasury_account_id": "'"$ID"'"}' --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME commit_owner --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME commit_operator_id --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME commit_treasury_id --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME set_reward_fee '{"numerator": 10, "denominator": 100}' --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME commit_reward_fee --accountId=$ID --gas=300000000000000 --depositYocto=1;

near call $CONTRACT_NAME add_min_storage_reserve --accountId=$ID --gas=300000000000000 --amount=10;

near call $CONTRACT_NAME update_rewards_buffer --accountId=$ID --gas=300000000000000 --depositYocto=1596381189754760206691;

near call $CONTRACT_NAME transfer_funds '{"account_id": "'"$ID"'", "amount": "1000000000000000000000000"}' --accountId=$ID --gas=300000000000000 --amount=10;
'''
'''--- scripts/ref_finance.sh ---

# add pool
near call $CONTRACT_ID add_simple_pool "{\"tokens\": [\"$TOKEN1\", \"$TOKEN2\"], \"fee\": 25}" --accountId $USER_ID --amount 0.1

# register for storage
near call $CONTRACT_ID storage_deposit '' --accountId $USER_ID --amount 1

# register tokens
near call $CONTRACT_ID register_tokens '{"token_ids": ["'"$TOKEN1"'", "'"$TOKEN2"'"]}' --accountId $USER_ID --depositYocto 1

# token transfer

# our token
near call $TOKEN1 ft_transfer_call '{"receiver_id": "'"$CONTRACT_ID"'", "amount": "2000000000000000000000000", "msg": ""}' --accountId $USER_ID --amount 0.000000000000000000000001 --gas=300000000000000;
# wrapped near
near call $WRAPPED_NEAR_CONTRACT ft_transfer_call '{"receiver_id": "'"$CONTRACT_ID"'", "amount": "2000000000000000000000000", "msg": ""}' --accountId $USER_ID --amount 0.000000000000000000000001 --gas=300000000000000;

# get wrapped near
near call $WRAPPED_NEAR_CONTRACT near_deposit --accountId $USER_ID --amount 5

# add liquidity
near call $CONTRACT_ID add_liquidity '{"pool_id": 181, "amounts": ["1", "1"]}' --accountId $USER_ID --amount 0.000000000000000000000001 --gas=300000000000000;

near view $CONTRACT_ID get_pool_shares '{"pool_id": 181, "account_id": "'"$USER_ID"'"}'
'''
'''--- scripts/run_epoch.sh ---
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_0"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_1"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_2"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_3"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_4"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_5"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_6"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_7"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_8"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_9"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_10"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_11"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_12"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME autocompounding_epoch '{"validator": "'"$STAKE_POOL_13"'"}' --accountId=$ID --gas=300000000000000

near call $CONTRACT_NAME staking_epoch --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME update_rewards_buffer --accountId=$ID --gas=300000000000000 --amount=2;

# run till false is returned
near call $CONTRACT_NAME unstaking_epoch --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME withdraw_epoch '{"validator": "'"$STAKE_POOL_0"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME withdraw_epoch '{"validator": "'"$STAKE_POOL_1"'"}' --accountId=$ID --gas=300000000000000
near call $CONTRACT_NAME withdraw_epoch '{"validator": "'"$STAKE_POOL_2"'"}' --accountId=$ID --gas=300000000000000

near call $CONTRACT_NAME sync_balance_from_validator '{"validator_id": "'"$STAKE_POOL_0"'"}' --accountId=$ID --gas=300000000000000;
near call $CONTRACT_NAME sync_balance_from_validator '{"validator_id": "'"$STAKE_POOL_1"'"}' --accountId=$ID --gas=300000000000000;
near call $CONTRACT_NAME sync_balance_from_validator '{"validator_id": "'"$STAKE_POOL_2"'"}' --accountId=$ID --gas=300000000000000;
'''
'''--- scripts/state_view.sh ---
near view $CONTRACT_NAME get_nearx_pool_state

near view $CONTRACT_NAME get_nearx_price

near view $CONTRACT_NAME get_total_staked_balance

near view $CONTRACT_NAME get_validators

near view $CONTRACT_NAME get_total_validator_weight

near view $CONTRACT_NAME get_validator_info '{"validator": "'"$STAKE_POOL_0"'"}'

near view $CONTRACT_NAME get_account '{"account_id": "'"$ID"'"}'
near view $CONTRACT_NAME get_user_account '{"account_id": "'"$ID"'"}'

near view $CONTRACT_NAME get_number_of_accounts

near view $CONTRACT_NAME storage_balance_of '{"account_id": "'"$ID"'"}'

near view $CONTRACT_NAME get_accounts '{"from_index": 20, "limit": 40}'

near view $CONTRACT_NAME get_current_epoch

near view $CONTRACT_NAME get_reward_fee_fraction

near view $CONTRACT_NAME get_roles

near view $CONTRACT_NAME get_operations_control

# Storage deposit
near view $CONTRACT_NAME storage_balance_of '{"account_id": "'"$ID"'"}'

# FT queries
near view $CONTRACT_NAME ft_balance_of '{"account_id": "'"$ID"'"}'

near view $CONTRACT_NAME ft_total_supply

# Direct stake pool querying
near view $STAKE_POOL_0 get_account_total_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_total_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_total_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

near view $STAKE_POOL_0 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_13 get_account_staked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

near view $STAKE_POOL_0 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_1 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'
near view $STAKE_POOL_2 get_account_unstaked_balance '{"account_id": "'"$CONTRACT_NAME"'"}'

near view $CONTRACT_NAME storage_balance_of '{"account_id": "'"$ID"'"}'
'''
'''--- scripts/user_actions.sh ---

# deposits
for i in {1..10};
  do near call $CONTRACT_NAME deposit_and_stake --accountId=$ID --amount=2 --gas=300000000000000;
done;

# unstaking
near call $CONTRACT_NAME unstake '{"amount": "2000130228351042603620956"}' --accountId=$ID --gas=300000000000000;
near call $CONTRACT_NAME unstake_all --accountId=$ID --gas=300000000000000;

# withdraw
near call $CONTRACT_NAME withdraw '{"amount": "3000000000000000000000000"}' --accountId=$ID --gas=300000000000000;
near call $CONTRACT_NAME withdraw_all --accountId=$ID --gas=300000000000000;

'''
'''--- scripts/validator_draining.sh ---
near call $CONTRACT_NAME drain_unstake '{"validator": "'"$STAKE_POOL_1"'"}' --accountId=$ID --gas=300000000000000;

near call $CONTRACT_NAME drain_withdraw '{"validator": "'"$STAKE_POOL_14"'"}' --accountId=$ID --gas=300000000000000;
'''
'''--- scripts/validators_operations.sh ---
# add some validators
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_0"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_1"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_2"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_3"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_4"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_5"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_6"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_7"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_8"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_9"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_10"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_11"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_12"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;
near call $CONTRACT_NAME add_validator '{"validator": "'"$STAKE_POOL_13"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;

# update validator weight
near call $CONTRACT_NAME update_validator '{"validator": "'"$STAKE_POOL_2"'", "weight": 10}' --accountId=$ID --depositYocto=1 --gas=300000000000000;

# pause validator
near call $CONTRACT_NAME pause_validator '{"validator": "'"$STAKE_POOL_0"'"}' --accountId=$ID  --gas=300000000000000 --depositYocto=1;
'''