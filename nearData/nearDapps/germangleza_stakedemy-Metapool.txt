*GitHub Repository "germangleza/stakedemy-Metapool"*

'''--- FinalModule (1).txt ---
// Contracts
const nearContract = "dev-1687559106965-31298632135911";

const nearusd = fetch(
  "https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd"
);

const precio = nearusd.body["near"].usd;
const dollar2near = Math.round((100 / precio) * 100) / 100;

const aurora2usd = fetch(
  "https://api.coingecko.com/api/v3/simple/price?ids=aurora-near&vs_currencies=usd"
);
const precioAU = aurora2usd.body["aurora-near"].usd;
const dollar2AU = Math.round((100 / precioAU) * 100) / 100;

State.init({
  selected: "NEAR",
  balance: 0,
});

const handleSelect2 = (data) => {
  State.update({ selected: data.target.value });
  if (state.selected === "NEAR") {
    State.update({ balance: dollar2near });
  } else if (state.selected === "AUR") {
    State.update({ balance: dollar2AU });
  }
};

// Calls

const onBtnClick = () => {
  if (!state.stAmount) {
    return;
  }

  const amount = state.stAmount * 1000000000000000000000000;

  Near.call(nearContract, "deposit", {}, 0, amount);
};

// Contracts

const lidoContract = "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F";

const mainnetLidoContract = "0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f";
const gorliLidoContract = "0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506";
const tokenDecimals = 18;
const contract = "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2";

//const network = "gorli"; // "gorli" // "rinkeby" // "mainnet"

const network = "mainnet";
switch (network) {
  case "gorli":
    lidoContract = gorliLidoContract;
    break;
  case "mainnet":
    lidoContract = mainnetLidoContract;
    break;
  case "ropsten":
    lidoContract = mainnetLidoContract;
    break;
  default:
    lidoContract = mainnetLidoContract;
    break;
}

const handleSelect = (data) => {
  console.log(data.target.value);
  let info = data.target.value.split("-");
  State.update({ tokenTo: info[1] });
  if (info[0] == "near") {
    State.update({ tokenSelected: 0 });
  } else if (info[0] == "aurora") {
    State.update({ tokenSelected: 1 });
  }
  console.log(state.tokenSelected);
  contract = data.target.value;
};

const lidoAbi = fetch(
  "https://raw.githubusercontent.com/cloudmex/sushiswap-bos/main/abi-sushi.json"
);

console.log(lidoAbi);

if (!lidoAbi.ok) {
  return "Loading";
}

const iface = new ethers.utils.Interface(lidoAbi.body);

const submitEthers = (stAmount, _referral) => {
  if (!stAmount) {
    console.log("contrato: ", state.tokenTo);
    return console.log("Amount is missing");
  }

  const erc20 = new ethers.Contract(
    lidoContract,
    lidoAbi.body,
    Ethers.provider().getSigner()
  );
  console.log("11111", erc20);
  let amount = ethers.utils.parseUnits(stAmount, tokenDecimals).toHexString();

  let ARR = ["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", state.tokenTo];

  console.log("contract: ", contract);

  console.log("amountlol", amount);
  console.log("ARRlol", ARR);
  console.log(
    "Ethers.provider().getSigner()l",
    Ethers.provider().getSigner().getAddress()
  );
  console.log("Sender:", state.sender);
  console.log("block.timestamp + 60 1678849571");
  console.log("token to swap: ", state.tokenTo);
  erc20
    .swapExactETHForTokens(
      amount,
      ARR,
      //Ethers.provider().getSigner(),
      state.sender,
      Date.now() + 180,
      { value: amount, gasLimit: 3e5 }
    )
    .then((transactionHash) => {
      console.log("transactionHash is " + transactionHash);
    });
};

// DETECT SENDER

if (state.sender === undefined) {
  const accounts = Ethers.send("eth_requestAccounts", []);
  if (accounts.length) {
    State.update({ sender: accounts[0] });
    console.log("set sender", accounts[0]);
  }
}

// FETCH CSS

const cssFont = fetch(
  "https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800"
).body;

const css = `
.LidoContainer{
    box-sizing: border-box;
    margin: 0px auto;
    min-width: 320px;
    width: 100%;
    padding: 0px 32px;
    max-width: 560px;
    position: relative;
    margin-top: 8px;
    margin-bottom: 8px;
}

.Header{
    font-weight: 800;
    font-size: 26px;
    margin-bottom: 0.2em;
    line-height: 1.2em;
    text-align: center;
}

.SubHeader{
    font-weight: 500;
    color: #FF79D8;
    margin-bottom: 16px;
    font-size: 12px;
    line-height: 1.5em;
    text-align: center;
};

.LidoForm{
    background: linear-gradient(65.21deg, rgb(255, 94, 88) 19.1%, rgb(255, 212, 84) 100%);
    margin-bottom: -20px;
    border-bottom-left-radius: 0px;
    border-bottom-right-radius: 0px;
    padding-bottom: 52px;
    font-weight: 400;
    font-size: 12px;
    line-height: 1.6em;
    border-radius: 20px;
    margin: 0px;
    padding: 32px;
    box-shadow: none;
    color: #fff;    
}

.LidoFormTopContainer{
    margin-top: 0px;
    display: flex;
    margin: 20px 0px;
}

.LidoFormTopContainerLeft{
    margin-right: 18px;
    flex-basis: 50%;
    -webkit-box-flex: 1;
    flex-grow: 1;
    font-size: 12px;
    line-height: 1.6em;
}

.LidoFormTopContainerLeftContent1{
    display: flex;
    flex-direction: row;
    -webkit-box-pack: start;
    justify-content: flex-start;
    -webkit-box-align: center;
    align-items: center;
}

.LidoFormTopContainerLeftContent1Container{
    display: flex;
    -webkit-box-align: center;
    align-items: center;
}

.LidoFormTopContainerLeftContent1Circle{
    background-color: #53BA95;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-left: 8px;
}

.LidoFormTopContainerLeftContent2{
    margin-top: 2px;
    font-size: 18px;
    line-height: 1.4em;
    font-weight: 800;
    white-space: nowrap;
    display: block;
}

.LidoFormTopContainerRight{
    align-self: stretch;
    display: flex;
    flex: 1 1 50%;
    -webkit-box-flex: 1;
    overflow: hidden;
    -webkit-box-align: center;
    align-items: center;
    -webkit-box-pack: end;
    justify-content: flex-end;
    margin-left: auto;
}

.LidoFormTopContainerRightContent1{
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    margin: 0px;
    border-radius: 1000px;
    padding: 4px;
    display: inline-flex;
    -webkit-box-align: center;
    align-items: center;
    background: rgba(0, 0, 0, .2);
    color: #fff;    
}

.LidoFormTopContainerRightContent1Text{
    padding: 0px 6px;
    font-weight: 400;
}

.LidoSplitter{
    box-sizing: border-box;
    list-style: none;
    opacity: 0.1;
    padding: 0px;
    flex-shrink: 0;
    -webkit-box-flex: 0;
    flex-grow: 0;
    border-top: 1px solid currentcolor;
    width: 100%;
    height: 0px;
    margin: 0px;
}

.LidoFormBottomContainer{
    margin-bottom: 0px;
    display: flex;
    margin: 20px 0px;
}

.LidoAprContainer{
    margin-right: 0px;
    flex-basis: 50%;
    -webkit-box-flex: 1;
    flex-grow: 1;
    font-size: 12px;
    line-height: 1.6em;
}

.LidoAprTitle{
    display: flex;
    flex-direction: row;
    -webkit-box-pack: start;
    justify-content: flex-start;
    -webkit-box-align: center;
    align-items: center;
}

.LidoAprValue{
    margin-top: 2px;
    font-size: 16px;
    line-height: 1.4em;
    font-weight: 800;
    white-space: nowrap;
    color: rgb(97, 183, 95);
    font-size: 16px;
    line-height: 1.4em;
    font-weight: 800;
    white-space: nowrap;
}        
}

.LidoStakeForm{
    font-weight: 400;
    font-size: 12px;
    line-height: 1.6em;
    border-radius: 0px 0px 20px 20px;
    margin: 0px;
    padding: 32px;
    box-shadow: none;
    background: #eee;
    color: #7a8aa0;
    margin-top: -30px;
}

.LidoStakeFormInputContainer{
    margin-bottom: 16px;
    z-index: 2;
    position: relative;
    display: inline-flex;
    border-width: 1px;
    border-style: solid;
    border-image: initial;
    border-radius: 10px;
    -webkit-box-align: stretch;
    align-items: stretch;
    box-sizing: border-box;
    padding: 0px 15px;
    cursor: text;
    transition: border-color 100ms ease 0s;
    width: 100%;
    background: #fff;
    border-color: rgba(0,10,61,.12);
    color: #273852;
}

.LidoStakeFormInputContainerSpan1{
    -webkit-box-flex: 0;
    flex-grow: 0;
    flex-shrink: 0;
    cursor: inherit;
    display: flex;
    -webkit-box-align: center;
    align-items: center;
    padding-right: 16px;
}

.selectCSS{
    font-weight: 400;
    font-size: 14px;
    display: flex;
    border: none;
    -webkit-box-flex: 1;
    flex-grow: 1;
    position: relative;
    padding: 17px 0px;
    color: #273852;
}

.LidoStakeFormInputContainerSpan2{
    font-weight: 400;
    font-size: 14px;
    display: flex;
    -webkit-box-flex: 1;
    flex-grow: 1;
    position: relative;
    padding: 17px 0px;
}

.LidoStakeFormInputContainerSpan2Input{
    width: 100%;
    font-family: inherit;
    font-weight: 400;
    font-size: 1em;
    line-height: 1.43em;
    padding: 0px;
    border-radius: 0px;
    background: transparent;
    box-shadow: none;
    border: none;
    outline: none;
    position: relative;
    top: 0px;
    color: #273852;
}

.LidoStakeFormInputContainerSpan3{
    -webkit-box-flex: 0;
    flex-grow: 0;
    flex-shrink: 0;
    cursor: inherit;
    display: flex;
    -webkit-box-align: center;
    align-items: center;
    padding-left: 16px;
}

.LidoStakeFormInputContainerSpan3Content{
    cursor: pointer;
    letter-spacing: 0.4px;
    box-sizing: border-box;
    margin: 0px;
    border: none;
    outline: none;
    white-space: nowrap;
    overflow: hidden;
    position: relative;
    background: transparent;
    font-family: inherit;
    font-weight: 700;
    width: auto;
    line-height: 1em;
    font-size: 10px;
    border-radius: 6px;
    padding: 11px 16px;
    min-width: 50px;
    color: #fa7aad;
    &::before {
            display: block;
            background-color: #f72277;
            transition: opacity 100ms ease 0s;
            opacity: 0.1;
            content: "";
            position: absolute;
            inset: 0px;
            pointer-events: none;
            border-radius: inherit;
        }    
}

.LidoStakeFormInputContainerSpan3Max{
    position: relative;
    pointer-events: none;
    visibility: visible;
}

.LidoStakeFormSubmitContainer{
    cursor: pointer;
    box-sizing: border-box;
    margin: 0px;
    border: none;
    outline: none;
    white-space: nowrap;
    overflow: hidden;
    position: relative;
    background-image: initial;
    background-position: initial;
    background-size: initial;
    background-repeat: initial;
    background-attachment: initial;
    background-origin: initial;
    background-clip: initial;
    font-family: inherit;
    font-weight: 700;
    width: 100%;
    line-height: 1em;
    font-size: 14px;
    border-radius: 10px;
    padding: 21px 44px;
    min-width: 120px;
    color: #fff;
    background-color: #FF5E58;
    transition: background-color 100ms ease 0s;
    &:hover {
        background-color: #FFD454;
    }
}

.LidoFooterContainer{
    font-weight: 400;
    font-size: 12px;
    line-height: 1.6em;
}

.LidoFooterRaw{
    margin-top: 0px;
    display: flex;
    margin: 16px 0px;
    font-weight: 400;
    font-size: 12px;
    line-height: 1.6em;
}

.LidoFooterRawLeft{
    color: #7a8aa0;
    -webkit-box-flex: 1;
    flex-grow: 1;
}

.LidoFooterRawRight{
    color: #273852;
    text-align: right;
    margin-left: 32px;
    -webkit-box-flex: 1;
    flex-grow: 1;
}
`;

const Main = styled.div`
  display: grid;
  gap: 20px;
  grid-template-columns: 352px minmax(0, 1fr);
  align-items: start;

  @media (max-width: 1200px) {
    grid-template-columns: minmax(0, 1fr);
  }
`;
const LogoImage = styled.img`
  width: 252px; 
  margin-right: 12px;
  margin-top: 1px; 
`;
const SidebarWrapper = styled.div`
  position: relative;
  z-index: 5;
  margin-top: -55px;

  @media (max-width: 900px) {
    margin-top: -40px;
  }
`;

const Content = styled.div`
  .post {
    padding-left: 0;
    padding-right: 0;
  }
`;

const Title = styled.h1`
  font-weight: 600;
  font-size: ${(p) => p.size || "25px"};
  line-height: 1.2em;
  color: #11181c;
  margin: ${(p) => (p.margin ? "0 0 24px" : "0")};
  overflow-wrap: anywhere;
`;

const Tabs = styled.div`
  display: flex;
  height: 48px;
  border-bottom: 1px solid #eceef0;
  margin-bottom: 72px;
  overflow: auto;
  scroll-behavior: smooth;

  @media (max-width: 1200px) {
    background: #f8f9fa;
    border-top: 1px solid #eceef0;
    margin: 0 -12px 48px;

    > * {
      flex: 1;
    }
  }
`;

const TabsButton = styled.a`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  font-weight: 600;
  font-size: 22px;
  padding: 0 12px;
  position: relative;
  color: ${(p) => (p.selected ? "#11181C" : "#687076")};
  background: none;
  border: none;
  outline: none;
  text-align: center;
  text-decoration: none !important;

  &:hover {
    color: #11181c;
  }

  &::after {
    content: "";
    display: ${(p) => (p.selected ? "block" : "none")};
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: #59e692;
  }
`;

if (!cssFont || !css) return "";

if (!state.theme) {
  State.update({
    theme: styled.div`
    font-family: Manrope, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
    ${cssFont}
    ${css}
`,
  });
}
const Theme = state.theme;

// OUTPUT UI

const getSender = () => {
  return !state.sender
    ? ""
    : state.sender.substring(0, 6) +
        "..." +
        state.sender.substring(state.sender.length - 4, state.sender.length);
};

return (
  <Theme>
    <div
      className="container-fluid bg-warning py-4"
      style={{
        backgroundImage:
          'url("https://somoscryptomx.com/wp-content/uploads/2023/05/stakedemy.png")',
        backgroundPosition: "center",
        backgroundSize: "cover",
        backgroundAttachment: "fixed",
        perspective: "1px",
        overflowX: "hidden",
        overflowY: "auto",
      }}
    >
      <div className="d-flex justify-content-start">
        <img
          src="https://raw.githubusercontent.com/Davitcoin/OpenWeb-CryptoMX/main/logoNegro.png"
          alt="Logo del proyecto"
          style={{ width: "50px" }}
        />
      </div>
      <LogoImage
        src="https://somoscryptomx.com/wp-content/uploads/2023/05/Recurso-1@4x-8-2048x519.png"
        alt="Company Logo"
      />
      <Tabs>
        <TabsButton
          href={`${url}&tab=inicio`}
          selected={state.selectedTab === "inicio"}
        >
          Inicio
        </TabsButton>

        <TabsButton
          href={`${url}&tab=nosotros`}
          selected={state.selectedTab === "nosotros"}
        >
          Nosotros
        </TabsButton>

        <TabsButton
          href={`${url}&tab=waitlist`}
          selected={state.selectedTab === "waitlist"}
        >
          Waitlist
        </TabsButton>

        <TabsButton
          href={`${url}&tab=whitepaper`}
          selected={state.selectedTab === "whitepaper"}
        >
          Whitepaper
        </TabsButton>

        <TabsButton
          href={`${url}&tab=comenzar`}
          selected={state.selectedTab === "comenzar"}
        >
          Comenzar
        </TabsButton>
      </Tabs>
      <h1 className="text-center text-danger mb-4">
        √önete y comienza a aprender y ganar
      </h1>
      <p>.</p>
      <div className="LidoContainer">
        <div className="LidoForm">
          {context.accountId && (
            <>
              <div className="LidoFormTopContainer">
                <div className="LidoFormTopContainerLeft">
                  <div className="LidoFormTopContainerLeftContent1"></div>
                  <div className="LidoFormTopContainerLeftContent2">
                    <span>
                      {state.selected === "NEAR" && (
                        <p>Precio en NEAR:{dollar2near}</p>
                      )}
                      {state.selected === "AUR" && (
                        <p>Precio en AURORA:{dollar2AU}</p>
                      )}
                    </span>
                  </div>
                </div>
                <div className="LidoFormTopContainerRight">
                  <div className="LidoFormTopContainerRightContent1">
                    <div className="LidoFormTopContainerRightContent1Text">
                      <span>
                        <b>Account:</b> {context.accountId}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
              <div className="LidoSplitter" />
            </>
          )}
        </div>
        <div className="LidoStakeForm">
          <div className="mb-2 LidoStakeFormInputContainer">
            {/* Select and Images */}
            <select
              name="currency"
              id="token"
              className="selectCSS"
              onChange={handleSelect2}
            >
              <option value="NEAR">NEAR</option>
              <option value="AUR">AURORA</option>
            </select>
          </div>

          <div className="LidoStakeFormInputContainer">
            <span className="LidoStakeFormInputContainerSpan1">
              {state.selected == "NEAR" ? (
                <img
                  src="https://aurora.dev/_next/image?url=https%3A%2F%2Fwww.datocms-assets.com%2F50156%2F1661863968-icon_nm.svg%3Fh%3D40%26w%3D40&w=48&q=75"
                  alt="NEAR"
                  style={{
                    background: "white",
                    padding: "5px",
                    borderRadius: "10px",
                    height: "30px",
                  }}
                />
              ) : (
                <img
                  src="https://auroracloud.dev/static/new-landing/aurora-business-big.svg"
                  alt="NEAR"
                  style={{
                    background: "white",
                    padding: "5px",
                    borderRadius: "10px",
                    height: "30px",
                  }}
                />
              )}
            </span>
            <span className="LidoStakeFormInputContainerSpan2">
              <input
                disabled={!state.sender && !context.accountId}
                className="LidoStakeFormInputContainerSpan2Input"
                value={state.stAmount}
                onChange={(e) => State.update({ stAmount: e.target.value })}
                placeholder="Amount"
              />
            </span>
            <span
              class="LidoStakeFormInputContainerSpan3"
              onClick={() => {
                State.update({
                  stAmount: parseFloat(state.balance).toFixed(2),
                });
              }}
            >
              <button
                className="LidoStakeFormInputContainerSpan3Content"
                disabled={!state.sender && !context.accountId}
              >
                <span className="LidoStakeFormInputContainerSpan3Max">MAX</span>
              </button>
            </span>
          </div>
          {!!state.sender || context.accountId ? (
            <button
              className="LidoStakeFormSubmitContainer"
              onClick={() => onBtnClick()}
            >
              <span>Stake</span>
            </button>
          ) : (
            <Web3Connect
              className="LidoStakeFormSubmitContainer"
              connectLabel="Connect with Web3"
            />
          )}
        </div>
      </div>
    </div>

    {/* fin */}
  </Theme>
);
'''
'''--- README.md ---
# STAKEDEMY
![Logotipo](https://github.com/germangleza/stakedemy-Metapool/assets/91810556/2da861d9-e4a9-4cc0-873e-04eab1ccf764)
Stake to learn & earn academy 

### Team 
Germ√°n Gonz√°lez 
Project Manager 
 
Kryzia Garc√≠a 
Front End Developer 

Edward Vergel 
Solidity Blockchain Developer
 
Joe Hank 
Rust Blockchain Developer
 
Adrian Hern√°ndez 
Designer 
 
### Description
We are aware that education is key and necessary to build a better decentralized world, and what better way to provide this education than for free. However, free content is sometimes not valued or fully utilized.

That's why we developed Stakedemy: Stake to Learn and Earn academy, a gamified educational platform powered by liquid staking protocol tokens. Users must lock Near or Aurora tokens for a duration of 12 months to gain access. Our contract goes and stakes the tokens in MetaPool, taking the stNear or stAurora tokens and locking them for 12 months to grant access to the academy to the user. The rewards generated are used to gamify the educational platform and as a source of income for Stakedemy. 

![image](https://github.com/germangleza/stakedemy-Metapool/assets/91810556/cfe8488e-562f-4254-aa46-82cf5955b805)

Here's how it works:
1.	Access to the academy is set in either $Near or $Aurora.
2.	Users need to lock the required amount of tokens for 12 months on our platform.
3.	Our contract takes those tokens and stakes them in the Metapool protocol to obtain $stNear or $stAurora, depending on the token the user deposited.
4.	The liquid staking tokens are locked in our vault, and the rewards will be received by Stakedemy.
5.	70% of the rewards will be allocated to the gamification and incentive ecosystem for learning and development within the community.
6.	30% will go to Stakedemy.
7.	At the end of the 12-month period, users can retrieve the tokens they had locked in our vault, minus a 3% commission, in addition to all the rewards earned within Stakedemy.

At the end of the 12 months, users retrieve the tokens they had locked in our vault. With this model, you can continue to learn without spending capital, but by locking your tokens, you increase your commitment level to learning and could earn money based on your efforts.

![stakedemy map](https://github.com/germangleza/stakedemy-Metapool/assets/91810556/dc2f7753-1cd2-4130-875c-24d5e9dae3e1)

We also developed a decentralized frontend component using BOS. The implementation allows the user to select which token to lock, either Near or Aurora, connect their wallet, and lock the tokens to gain access to the academy.

![image](https://github.com/germangleza/stakedemy-Metapool/assets/91810556/fce89910-226d-4874-b32b-03f70ccedf15)

'''
'''--- stAurora/stakedemy-aur-main/README.md ---
# Stakedemy üìö
Stakedemy the first Learn-to-earn platform in the Aurora Ecosystem. 
Stake your $Aurora and start learning all the Stakedemy content.
## Subscriber Contract 
- This contract handle the user subscription within the Aurora EVM. 
- Interface between Stakedemy and Metapool StakedAuroraVault contract.

## Technical Aspects 
- [Metapool Contract](https://github.com/Meta-Pool/staking-pool-aurora)
- We are using the release [v0.1.0 San Francisco](https://github.com/Meta-Pool/staking-pool-aurora/releases/tag/v0.1.0)

## Operation 
<img src="stakedemy.png" alt="price" width="800"/>

## How it works
1.	Access to the academy is set in either $Near or $Aurora.
2.	Users need to lock the required amount of tokens for 12 months on our platform.
3.	Our contract takes those tokens and stakes them in the Metapool protocol to obtain $stNear or $stAurora, depending on the token the user deposited.
4.	The liquid staking tokens are locked in our vault, and the rewards will be received by Stakedemy.
5.	70% of the rewards will be allocated to the gamification and incentive ecosystem for learning and development within the community.
6.	30% will go to Stakedemy.
7.	At the end of the 12-month period, users can retrieve the tokens they had locked in our vault, minus a 3% commission, in addition to all the rewards earned within Stakedemy.

## Quick run 
`
forge test 
`

'''
'''--- stAurora/stakedemy-aur-main/foundry.toml ---
[profile.default]
src = "src"
out = "out"
libs = ["lib"]

# See more config options https://github.com/foundry-rs/foundry/tree/master/config
'''
'''--- stAurora/stakedemy-aur-main/lib/forge-std/README.md ---
# Forge Standard Library ‚Ä¢ [![CI status](https://github.com/foundry-rs/forge-std/actions/workflows/ci.yml/badge.svg)](https://github.com/foundry-rs/forge-std/actions/workflows/ci.yml)

Forge Standard Library is a collection of helpful contracts and libraries for use with [Forge and Foundry](https://github.com/foundry-rs/foundry). It leverages Forge's cheatcodes to make writing tests easier and faster, while improving the UX of cheatcodes.

**Learn how to use Forge-Std with the [üìñ Foundry Book (Forge-Std Guide)](https://book.getfoundry.sh/forge/forge-std.html).**

## Install

```bash
forge install foundry-rs/forge-std
```

## Contracts
### stdError

This is a helper contract for errors and reverts. In Forge, this contract is particularly helpful for the `expectRevert` cheatcode, as it provides all compiler builtin errors.

See the contract itself for all error codes.

#### Example usage

```solidity

import "forge-std/Test.sol";

contract TestContract is Test {
    ErrorsTest test;

    function setUp() public {
        test = new ErrorsTest();
    }

    function testExpectArithmetic() public {
        vm.expectRevert(stdError.arithmeticError);
        test.arithmeticError(10);
    }
}

contract ErrorsTest {
    function arithmeticError(uint256 a) public {
        uint256 a = a - 100;
    }
}
```

### stdStorage

This is a rather large contract due to all of the overloading to make the UX decent. Primarily, it is a wrapper around the `record` and `accesses` cheatcodes. It can *always* find and write the storage slot(s) associated with a particular variable without knowing the storage layout. The one _major_ caveat to this is while a slot can be found for packed storage variables, we can't write to that variable safely. If a user tries to write to a packed slot, the execution throws an error, unless it is uninitialized (`bytes32(0)`).

This works by recording all `SLOAD`s and `SSTORE`s during a function call. If there is a single slot read or written to, it immediately returns the slot. Otherwise, behind the scenes, we iterate through and check each one (assuming the user passed in a `depth` parameter). If the variable is a struct, you can pass in a `depth` parameter which is basically the field depth.

I.e.:
```solidity
struct T {
    // depth 0
    uint256 a;
    // depth 1
    uint256 b;
}
```

#### Example usage

```solidity
import "forge-std/Test.sol";

contract TestContract is Test {
    using stdStorage for StdStorage;

    Storage test;

    function setUp() public {
        test = new Storage();
    }

    function testFindExists() public {
        // Lets say we want to find the slot for the public
        // variable `exists`. We just pass in the function selector
        // to the `find` command
        uint256 slot = stdstore.target(address(test)).sig("exists()").find();
        assertEq(slot, 0);
    }

    function testWriteExists() public {
        // Lets say we want to write to the slot for the public
        // variable `exists`. We just pass in the function selector
        // to the `checked_write` command
        stdstore.target(address(test)).sig("exists()").checked_write(100);
        assertEq(test.exists(), 100);
    }

    // It supports arbitrary storage layouts, like assembly based storage locations
    function testFindHidden() public {
        // `hidden` is a random hash of a bytes, iteration through slots would
        // not find it. Our mechanism does
        // Also, you can use the selector instead of a string
        uint256 slot = stdstore.target(address(test)).sig(test.hidden.selector).find();
        assertEq(slot, uint256(keccak256("my.random.var")));
    }

    // If targeting a mapping, you have to pass in the keys necessary to perform the find
    // i.e.:
    function testFindMapping() public {
        uint256 slot = stdstore
            .target(address(test))
            .sig(test.map_addr.selector)
            .with_key(address(this))
            .find();
        // in the `Storage` constructor, we wrote that this address' value was 1 in the map
        // so when we load the slot, we expect it to be 1
        assertEq(uint(vm.load(address(test), bytes32(slot))), 1);
    }

    // If the target is a struct, you can specify the field depth:
    function testFindStruct() public {
        // NOTE: see the depth parameter - 0 means 0th field, 1 means 1st field, etc.
        uint256 slot_for_a_field = stdstore
            .target(address(test))
            .sig(test.basicStruct.selector)
            .depth(0)
            .find();

        uint256 slot_for_b_field = stdstore
            .target(address(test))
            .sig(test.basicStruct.selector)
            .depth(1)
            .find();

        assertEq(uint(vm.load(address(test), bytes32(slot_for_a_field))), 1);
        assertEq(uint(vm.load(address(test), bytes32(slot_for_b_field))), 2);
    }
}

// A complex storage contract
contract Storage {
    struct UnpackedStruct {
        uint256 a;
        uint256 b;
    }

    constructor() {
        map_addr[msg.sender] = 1;
    }

    uint256 public exists = 1;
    mapping(address => uint256) public map_addr;
    // mapping(address => Packed) public map_packed;
    mapping(address => UnpackedStruct) public map_struct;
    mapping(address => mapping(address => uint256)) public deep_map;
    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;
    UnpackedStruct public basicStruct = UnpackedStruct({
        a: 1,
        b: 2
    });

    function hidden() public view returns (bytes32 t) {
        // an extremely hidden storage slot
        bytes32 slot = keccak256("my.random.var");
        assembly {
            t := sload(slot)
        }
    }
}
```

### stdCheats

This is a wrapper over miscellaneous cheatcodes that need wrappers to be more dev friendly. Currently there are only functions related to `prank`. In general, users may expect ETH to be put into an address on `prank`, but this is not the case for safety reasons. Explicitly this `hoax` function should only be used for address that have expected balances as it will get overwritten. If an address already has ETH, you should just use `prank`. If you want to change that balance explicitly, just use `deal`. If you want to do both, `hoax` is also right for you.

#### Example usage:
```solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Inherit the stdCheats
contract StdCheatsTest is Test {
    Bar test;
    function setUp() public {
        test = new Bar();
    }

    function testHoax() public {
        // we call `hoax`, which gives the target address
        // eth and then calls `prank`
        hoax(address(1337));
        test.bar{value: 100}(address(1337));

        // overloaded to allow you to specify how much eth to
        // initialize the address with
        hoax(address(1337), 1);
        test.bar{value: 1}(address(1337));
    }

    function testStartHoax() public {
        // we call `startHoax`, which gives the target address
        // eth and then calls `startPrank`
        //
        // it is also overloaded so that you can specify an eth amount
        startHoax(address(1337));
        test.bar{value: 100}(address(1337));
        test.bar{value: 100}(address(1337));
        vm.stopPrank();
        test.bar(address(this));
    }
}

contract Bar {
    function bar(address expectedSender) public payable {
        require(msg.sender == expectedSender, "!prank");
    }
}
```

### Std Assertions

Expand upon the assertion functions from the `DSTest` library.

### `console.log`

Usage follows the same format as [Hardhat](https://hardhat.org/hardhat-network/reference/#console-log).
It's recommended to use `console2.sol` as shown below, as this will show the decoded logs in Forge traces.

```solidity
// import it indirectly via Test.sol
import "forge-std/Test.sol";
// or directly import it
import "forge-std/console2.sol";
...
console2.log(someValue);
```

If you need compatibility with Hardhat, you must use the standard `console.sol` instead.
Due to a bug in `console.sol`, logs that use `uint256` or `int256` types will not be properly decoded in Forge traces.

```solidity
// import it indirectly via Test.sol
import "forge-std/Test.sol";
// or directly import it
import "forge-std/console.sol";
...
console.log(someValue);
```

## License

Forge Standard Library is offered under either [MIT](LICENSE-MIT) or [Apache 2.0](LICENSE-APACHE) license.

'''
'''--- stAurora/stakedemy-aur-main/lib/forge-std/foundry.toml ---
[profile.default]
fs_permissions = [{ access = "read-write", path = "./"}]

[rpc_endpoints]
# The RPC URLs are modified versions of the default for testing initialization.
mainnet = "https://mainnet.infura.io/v3/b1d3925804e74152b316ca7da97060d3" # Different API key.
optimism_goerli = "https://goerli.optimism.io/" # Adds a trailing slash.
arbitrum_one_goerli = "https://goerli-rollup.arbitrum.io/rpc/" # Adds a trailing slash.
needs_undefined_env_var = "${UNDEFINED_RPC_URL_PLACEHOLDER}"

[fmt]
# These are all the `forge fmt` defaults.
line_length = 120
tab_width = 4
bracket_spacing = false
int_types = 'long'
multiline_func_header = 'attributes_first'
quote_style = 'double'
number_underscore = 'preserve'
single_line_statement_blocks = 'preserve'
ignore = ["src/console.sol", "src/console2.sol"]
'''
'''--- stAurora/stakedemy-aur-main/lib/forge-std/lib/ds-test/package.json ---
{
  "name": "ds-test",
  "version": "1.0.0",
  "description": "Assertions, equality checks and other test helpers ",
  "bugs": "https://github.com/dapphub/ds-test/issues",
  "license": "GPL-3.0",
  "author": "Contributors to ds-test",
  "files": [
    "src/*"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/dapphub/ds-test.git"
  }
}

'''
'''--- stAurora/stakedemy-aur-main/lib/forge-std/package.json ---
{
  "name": "forge-std",
  "version": "1.5.6",
  "description": "Forge Standard Library is a collection of helpful contracts and libraries for use with Forge and Foundry.",
  "homepage": "https://book.getfoundry.sh/forge/forge-std",
  "bugs": "https://github.com/foundry-rs/forge-std/issues",
  "license": "(Apache-2.0 OR MIT)",
  "author": "Contributors to Forge Standard Library",
  "files": [
    "src/**/*"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/foundry-rs/forge-std.git"
  }
}

'''
'''--- stAurora/stakedemy-aur-main/lib/forge-std/test/fixtures/broadcast.log.json ---
{
  "transactions": [
    {
      "hash": "0xc6006863c267735a11476b7f15b15bc718e117e2da114a2be815dd651e1a509f",
      "type": "CALL",
      "contractName": "Test",
      "contractAddress": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
      "function": "multiple_arguments(uint256,address,uint256[]):(uint256)",
      "arguments": ["1", "0000000000000000000000000000000000001337", "[3,4]"],
      "tx": {
        "type": "0x02",
        "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
        "to": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
        "gas": "0x73b9",
        "value": "0x0",
        "data": "0x23e99187000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000013370000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004",
        "nonce": "0x3",
        "accessList": []
      }
    },
    {
      "hash": "0xedf2b38d8d896519a947a1acf720f859bb35c0c5ecb8dd7511995b67b9853298",
      "type": "CALL",
      "contractName": "Test",
      "contractAddress": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
      "function": "inc():(uint256)",
      "arguments": [],
      "tx": {
        "type": "0x02",
        "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
        "to": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
        "gas": "0xdcb2",
        "value": "0x0",
        "data": "0x371303c0",
        "nonce": "0x4",
        "accessList": []
      }
    },
    {
      "hash": "0xa57e8e3981a6c861442e46c9471bd19cb3e21f9a8a6c63a72e7b5c47c6675a7c",
      "type": "CALL",
      "contractName": "Test",
      "contractAddress": "0x7c6b4bbe207d642d98d5c537142d85209e585087",
      "function": "t(uint256):(uint256)",
      "arguments": ["1"],
      "tx": {
        "type": "0x02",
        "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
        "to": "0x7c6b4bbe207d642d98d5c537142d85209e585087",
        "gas": "0x8599",
        "value": "0x0",
        "data": "0xafe29f710000000000000000000000000000000000000000000000000000000000000001",
        "nonce": "0x5",
        "accessList": []
      }
    }
  ],
  "receipts": [
    {
      "transactionHash": "0x481dc86e40bba90403c76f8e144aa9ff04c1da2164299d0298573835f0991181",
      "transactionIndex": "0x0",
      "blockHash": "0xef0730448490304e5403be0fa8f8ce64f118e9adcca60c07a2ae1ab921d748af",
      "blockNumber": "0x1",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": null,
      "cumulativeGasUsed": "0x13f3a",
      "gasUsed": "0x13f3a",
      "contractAddress": "0x5fbdb2315678afecb367f032d93f642f64180aa3",
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0x6a187183545b8a9e7f1790e847139379bf5622baff2cb43acf3f5c79470af782",
      "transactionIndex": "0x0",
      "blockHash": "0xf3acb96a90071640c2a8c067ae4e16aad87e634ea8d8bbbb5b352fba86ba0148",
      "blockNumber": "0x2",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": null,
      "cumulativeGasUsed": "0x45d80",
      "gasUsed": "0x45d80",
      "contractAddress": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0x064ad173b4867bdef2fb60060bbdaf01735fbf10414541ea857772974e74ea9d",
      "transactionIndex": "0x0",
      "blockHash": "0x8373d02109d3ee06a0225f23da4c161c656ccc48fe0fcee931d325508ae73e58",
      "blockNumber": "0x3",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": "0x4e59b44847b379578588920ca78fbf26c0b4956c",
      "cumulativeGasUsed": "0x45feb",
      "gasUsed": "0x45feb",
      "contractAddress": null,
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0xc6006863c267735a11476b7f15b15bc718e117e2da114a2be815dd651e1a509f",
      "transactionIndex": "0x0",
      "blockHash": "0x16712fae5c0e18f75045f84363fb6b4d9a9fe25e660c4ce286833a533c97f629",
      "blockNumber": "0x4",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
      "cumulativeGasUsed": "0x5905",
      "gasUsed": "0x5905",
      "contractAddress": null,
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0xedf2b38d8d896519a947a1acf720f859bb35c0c5ecb8dd7511995b67b9853298",
      "transactionIndex": "0x0",
      "blockHash": "0x156b88c3eb9a1244ba00a1834f3f70de735b39e3e59006dd03af4fe7d5480c11",
      "blockNumber": "0x5",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
      "cumulativeGasUsed": "0xa9c4",
      "gasUsed": "0xa9c4",
      "contractAddress": null,
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0xa57e8e3981a6c861442e46c9471bd19cb3e21f9a8a6c63a72e7b5c47c6675a7c",
      "transactionIndex": "0x0",
      "blockHash": "0xcf61faca67dbb2c28952b0b8a379e53b1505ae0821e84779679390cb8571cadb",
      "blockNumber": "0x6",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": "0x7c6b4bbe207d642d98d5c537142d85209e585087",
      "cumulativeGasUsed": "0x66c5",
      "gasUsed": "0x66c5",
      "contractAddress": null,
      "logs": [
        {
          "address": "0x7c6b4bbe207d642d98d5c537142d85209e585087",
          "topics": [
            "0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b"
          ],
          "data": "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000046865726500000000000000000000000000000000000000000000000000000000",
          "blockHash": "0xcf61faca67dbb2c28952b0b8a379e53b1505ae0821e84779679390cb8571cadb",
          "blockNumber": "0x6",
          "transactionHash": "0xa57e8e3981a6c861442e46c9471bd19cb3e21f9a8a6c63a72e7b5c47c6675a7c",
          "transactionIndex": "0x1",
          "logIndex": "0x0",
          "transactionLogIndex": "0x0",
          "removed": false
        }
      ],
      "status": "0x1",
      "logsBloom": "0x00000000000800000000000000000010000000000000000000000000000180000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100",
      "effectiveGasPrice": "0xee6b2800"
    },
    {
      "transactionHash": "0x11fbb10230c168ca1e36a7e5c69a6dbcd04fd9e64ede39d10a83e36ee8065c16",
      "transactionIndex": "0x0",
      "blockHash": "0xf1e0ed2eda4e923626ec74621006ed50b3fc27580dc7b4cf68a07ca77420e29c",
      "blockNumber": "0x7",
      "from": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
      "to": "0x0000000000000000000000000000000000001337",
      "cumulativeGasUsed": "0x5208",
      "gasUsed": "0x5208",
      "contractAddress": null,
      "logs": [],
      "status": "0x1",
      "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "effectiveGasPrice": "0xee6b2800"
    }
  ],
  "libraries": [
    "src/Broadcast.t.sol:F:0x5fbdb2315678afecb367f032d93f642f64180aa3"
  ],
  "pending": [],
  "path": "broadcast/Broadcast.t.sol/31337/run-latest.json",
  "returns": {},
  "timestamp": 1655140035
}

'''
'''--- stAurora/stakedemy-aur-main/remappings.txt ---
ds-test/=lib/forge-std/lib/ds-test/src/
erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/
forge-std/=lib/forge-std/src/
openzeppelin-contracts/=lib/openzeppelin-contracts/
openzeppelin/=lib/openzeppelin-contracts/contracts/

'''
'''--- stNEAR/contract/Cargo.toml ---
[package]
name = "contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- stNEAR/contract/README.md ---
# Donation Contract

The smart contract exposes multiple methods to handle locked $stNear tokens for 12 months to gain access to our educational program. The rewards generated are used to gamify the educational platform and as a source of income for Stakedemy. At the end of the 12 months, users retrieve the tokens they had locked in our vault.

## 1. Build and Deploy the Contract
You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
./deploy.sh
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

## 1. Subscribe

`subscribe` forwards any attached money to the `vault` while keeping track of it.

`subscribe` is a payable method for which can only be invoked using a NEAR account. The account needs to attach money and pay GAS for the transaction.

```bash
# Use near-cli to deposit 3 NEAR
near call <dev-account> subscribe --amount 3 --accountId <account>
```

**Tip:** If you would like to `subscribe` using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.

## 2. Unatake & Withdraw

Once a year the 12 months past you can `unstake` your NEARs and after a few days you can `withdraw` that money without 3% commission for the academy.

```bash
# After 12 months and at least with 3 NEARs in the susbcription method
near call <dev-account> unstake --accountId <your-account>

# A few days later to withdraw your stake NEARs
near call <dev-account> withdraw -- accountId <your-account>
```

## 3. Get Methods

```bash
## Get amount staked from a member
near view <dev-account> get_amount_for_account '{"account_id":"<your-account>"}'

## Get amount to unstake from a member once you called the method "unstake"
near view <dev-account> get_amount_to_unstake '{"account_id":"<your-account>"}'

## Get numbers of members
near view <dev-account> number_of_members 

## Get a list of members
near view <dev-account>9 get_memberships '{"from_index":"0","limit":5}'
```

### Methods for stNEAR from Metapool
````
near call meta-v2.pool.testnet deposit_and_stake '{"amount":}' --accountId ejemplo.testnet --deposit 1

near call meta-v2.pool.testnet ft_transfer '{}' --accountId ejemplo.testnet

near view meta-v2.pool.testnet ft_balance_of '{"account_id": "ejemplo.testnet"}'

near call meta-v2.pool.testnet ft_transfer '{"receiver_id": "joehank.testnet", "amount": "1000000000000000000000000", "msg": ""}' --accountId ejemplo.testnet --depositYocto 1 --gas 300000000000000
````
'''
'''--- stNEAR/contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- stNEAR/contract/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm
#near deploy stakedemy.testnet --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm
'''
'''--- stNEAR/contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    // Public - get donation by account ID
  pub fn get_amount_for_account(&self, account_id: AccountId) -> Membership {
    Membership {
      account_id: account_id.clone(),
      total_amount: U128(self.total_deposit.get(&account_id).unwrap_or(0))
    }
  }

  pub fn get_amount_to_unstake(&self, account_id: AccountId) -> Membership {
    Membership {
      account_id: account_id.clone(),
      total_amount: U128(self.deposit_to_withdraw.get(&account_id).unwrap_or(0))
    }
  }

  // Public - get total number of donors
  pub fn number_of_members(&self) -> u64 {
    self.total_deposit.len()
  }

  // Public - paginate through all donations on the contract
  pub fn get_memberships(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Membership> {
    //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    let start = u128::from(from_index.unwrap_or(U128(0)));

    //iterate through donation
    self.total_deposit.keys()
      //skip to the index we specified in the start variable
      .skip(start as usize) 
      //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
      .take(limit.unwrap_or(50) as usize) 
      .map(|account| self.get_amount_for_account(account))
      //since we turned map into an iterator, we need to turn it back into a vector to return
      .collect()
  }

    //get the total supply of NFTs for a given owner
    pub fn deposit_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of tokens for the passed in owner
        let deposit_for_owner_set = self.deposits_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(deposit_for_owner_set) = deposit_for_owner_set {
            U128(deposit_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }
}
'''
'''--- stNEAR/contract/src/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};
use std::mem::size_of;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_deposit_to_owner(
        &mut self,
        account_id: &AccountId,
        timestamp: &Timestamp,
    ) {
        //get the set of tokens for the given account
        let mut deposit_set = self.deposits_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::DepositsPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        deposit_set.insert(timestamp);

        //we insert that set for the given account ID. 
        self.deposits_per_owner.insert(account_id, &deposit_set);
    }

    
    
} 
'''
'''--- stNEAR/contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::collections::HashMap;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::U128;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;
/// Raw type for 32 bytes of the hash.
pub type CryptoHash = [u8; 32];

use crate::internal::*;
pub use crate::xcc::*;
pub use crate::subscribe::*;
pub use crate::enumeration::*;

mod internal;
mod subscribe;
mod xcc;
mod enumeration;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
  pub vault: AccountId,
  pub total_deposit: UnorderedMap<AccountId, u128>,
  pub timelocked: UnorderedMap<AccountId, Timestamp>,
  pub deposit_to_withdraw: UnorderedMap<AccountId, u128>,
  pub deposits_per_owner: LookupMap<AccountId, UnorderedSet<Timestamp>>,
  pub metapoolcontract: String
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    DepositsPerOwner,
    DepositsPerOwnerInner { account_id_hash: CryptoHash },
}

impl Default for Contract {
  fn default() -> Self {
    Self{
      vault: "stakedemy.testnet".parse().unwrap(),
      metapoolcontract: "meta-v2.pool.testnet".parse().unwrap(),
      total_deposit: UnorderedMap::new(b"a"),
      timelocked: UnorderedMap::new(b"d"),
      deposit_to_withdraw: UnorderedMap::new(b"c"),
      deposits_per_owner: LookupMap::new(StorageKey::DepositsPerOwner.try_to_vec().unwrap()),
    }
  }
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn init(vault: AccountId) -> Self {
    Self {
      vault,
      metapoolcontract: "meta-v2.pool.testnet".parse().unwrap(),
      deposit_to_withdraw: UnorderedMap::new(b"c"),
      timelocked: UnorderedMap::new(b"d"),
      total_deposit: UnorderedMap::new(b"a"),
      deposits_per_owner: LookupMap::new(StorageKey::DepositsPerOwner.try_to_vec().unwrap()),
    }
  }

  // Public - vault getter
  pub fn get_vault(&self) -> AccountId {
    self.vault.clone()
  }

  // Public - but only callable by env::current_account_id(). Sets the vault
  #[private]
  pub fn change_vault(&mut self, vault: AccountId) {
    self.vault = vault;
  }
}
'''
'''--- stNEAR/contract/src/subscribe.rs ---
use crate::Contract;
use crate::ContractExt;
use crate::Timestamp;
use crate::*;

use near_sdk::serde::Serialize;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Promise, Balance, Gas};
use near_sdk::json_types::U128;

pub const STORAGE_COST: u128 = 1_000_000_000_000_000_000_000;
//const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(300000000000000);

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Membership {
  pub account_id: AccountId, 
  pub total_amount: U128,
}

#[near_bindgen]
impl Contract {
  #[payable] // Public - People can attach money
  pub fn subscribe(&mut self) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let member: AccountId = env::predecessor_account_id();
    let time: Timestamp = env::block_timestamp();
    let deposit_amount: Balance = env::attached_deposit();
    let mut deposit_so_far = self.total_deposit.get(&member).unwrap_or(0);
    let end_time_stake = time + 31556926000000000;

    log!("Tiempo recibido {}, tiempo al finalizar {}", time, end_time_stake);
    let to_transfer: Balance = if deposit_so_far == 0 {
      // This is the user's first donation, lets register it, which increases storage
      assert!(deposit_amount > 2000000000000000000000000, "Attach at least 2 NEARs");

      // Subtract the storage cost to the amount to transfer
      deposit_amount - STORAGE_COST
    }else{
      deposit_amount
    };

    // Send the money to the vault
    Promise::new(self.vault.clone()).transfer(to_transfer);

    // Persist in storage the amount donated so far
    deposit_so_far += deposit_amount;
    self.total_deposit.insert(&member, &deposit_so_far);
    self.internal_add_deposit_to_owner(&member, &time);
    self.timelocked.insert(&member, &end_time_stake);

    //stake the deposit
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .with_attached_deposit(deposit_amount)
    .deposit_and_stake();
    
    log!("Thank you {} for deposit {}! You donated a total of {}, your NEARs will be staked until {}", 
    member.clone(), deposit_amount, deposit_so_far, end_time_stake.clone());

    // Return the total amount donated so far
    U128(deposit_so_far)
  }

  pub fn unstake(&mut self) -> U128 {

    let member: AccountId = env::predecessor_account_id();
    let time: Timestamp = env::block_timestamp();
    let mut end_time_stake = self.timelocked.get(&member).unwrap_or(0);
    let mut amount: Balance = self.total_deposit.get(&member).unwrap_or(0);

    assert!(
      amount > 2000000000000000000000000,
      "Deposit at least 2 NEAR",
    );

    assert!(
      time >= end_time_stake,
      "locked until {}",end_time_stake
    );

    let mut float_amount: f64 = amount as f64;
    let tesorery = float_amount * 0.03;
    float_amount = float_amount - tesorery;
    amount = float_amount as u128;
    end_time_stake = end_time_stake + 259200000000000;

    // unstake the deposit
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .unstake(amount);

    //log!("Tiempo recibido {}, tiempo al finalizar {}", &time, &end_time_stake);
    self.timelocked.insert(&member, &end_time_stake);
    self.total_deposit.insert(&member, &0);
    self.deposit_to_withdraw.insert(&member, &amount);

    U128(amount)
  }

  pub fn withdraw(&mut self) -> U128 {
    
    let time: Timestamp = env::block_timestamp();
    let member: AccountId = env::predecessor_account_id();
    let amount = self.deposit_to_withdraw.get(&member).unwrap_or(0);
    let amount_unstaked = self.total_deposit.get(&member).unwrap_or(0);
    let end_time_stake = self.timelocked.get(&member).unwrap_or(0);

    assert!(
      amount == 0,
      "You don't have amount unstaked to withdraw",
    );

    assert!(
      amount_unstaked > 2000000000000000000000000,
      "Unstake at least 2 NEAR",
    );

    assert!(
      time >= end_time_stake,
      "locked until {}",end_time_stake
    );

    // withdraw the amount unstaked
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .withdraw_unstaked();

    //transfer amount unstaked
    Promise::new(member.clone()).transfer(amount_unstaked);

    U128(amount)

  }

}
'''
'''--- stNEAR/contract/src/xcc.rs ---
use crate::*;
use near_sdk::{ext_contract};

// const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
// const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
// const MIN_GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(100_000_000_000_000);

#[ext_contract(ext_transfer)]
pub trait ExtTransfer {
    //fn ft_transfer(&self, receiver_id: AccountId, amount: String) -> String;
    fn deposit_and_stake(&self) -> String;
    fn unstake(&self, amount: u128) -> String;
    fn withdraw_unstaked(&self) -> String;
}
'''
'''--- stNEAR/package.json ---
{
    "name": "stakedemy",
    "version": "1.0.0",
    "license": "(MIT AND Apache-2.0)",
    "scripts": {
      "start": "cd frontend && npm run start",
      "deploy": "cd contract && ./deploy.sh",
      "build": "npm run build:contract",
      "build:web": "cd frontend && npm run build",
      "build:contract": "cd contract && ./build.sh"
    },
    "devDependencies": {
      "near-cli": "^3.3.0"
    },
    "dependencies": {}
  }
'''