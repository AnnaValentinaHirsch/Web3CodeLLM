*GitHub Repository "evgenykuzyakov/dacha"*

'''--- README.md ---
# NEAR Place

Draw with pixels. Your pixels earn you more pixels, so better artists get more pixels to draw.

'''
'''--- config/paths.js ---
const path = require("path");

const srcPath = path.resolve(__dirname, "../src");
const distPath = path.resolve(__dirname, "../dist");
const publicPath = path.resolve(__dirname, "../public");
const nodeModulesPath = path.resolve(__dirname, "../node_modules");

module.exports = {
  srcPath,
  distPath,
  publicPath,
  nodeModulesPath,
};

'''
'''--- config/presets/loadPreset.js ---
const { merge } = require("webpack-merge");

const loadPresets = (env = { presets: [] }) => {
  const presets = env.presets || [];
  /** @type {string[]} */
  const mergedPresets = [].concat(...[presets]);
  const mergedConfigs = mergedPresets.map((presetName) =>
    require(`./webpack.${presetName}.js`)(env)
  );

  return merge({}, ...mergedConfigs);
};
module.exports = loadPresets;

'''
'''--- config/presets/webpack.analyze.js ---
const WebpackBundleAnalyzer =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;

module.exports = () => ({
  plugins: [new WebpackBundleAnalyzer()],
});

'''
'''--- config/webpack.development.js ---
const path = require("path");
const { HotModuleReplacementPlugin } = require("webpack");

module.exports = () => ({
  devtool: false,
  module: {
    rules: [
      {
        test: /\.(scss|css)$/,
        use: [
          {
            // inject CSS to page
            loader: "style-loader",
          },
          {
            // translates CSS into CommonJS modules
            loader: "css-loader",
          },
          {
            // Run postcss actions
            loader: "postcss-loader",
            options: {
              // `postcssOptions` is needed for postcss 8.x;
              // if you use postcss 7.x skip the key
              postcssOptions: {
                // postcss plugins, can be exported to postcss.config.js
                plugins: function () {
                  return [require("autoprefixer")];
                },
              },
            },
          },
          {
            // compiles Sass to CSS
            loader: "sass-loader",
            options: {
              // Prefer `dart-sass`
              implementation: require("sass"),
              sassOptions: {
                quietDeps: true,
              },
            },
          },
        ],
      },
    ],
  },
  devServer: {
    open: true,
    static: path.resolve(__dirname, "../dist"),
    port: 3000,
    compress: true,
    historyApiFallback: {
      disableDotRule: true,
    },
  },
  plugins: [new HotModuleReplacementPlugin()],
});

'''
'''--- config/webpack.production.js ---
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
const path = require("path");

module.exports = () => {
  return {
    output: {
      path: path.resolve(__dirname, "../dist"),
      publicPath: "/",
      filename: "[name].[contenthash].bundle.js",
    },
    devtool: false,
    module: {
      rules: [
        // {
        //   test: /\.(css)$/,
        //   use: [MiniCssExtractPlugin.loader, "css-loader"],
        //   //   options: {
        //   //     sourceMap: false,
        //   //   },
        // },
        {
          test: /\.(scss|css)$/,
          use: [
            {
              // inject CSS to page
              loader: "style-loader",
            },
            {
              // translates CSS into CommonJS modules
              loader: "css-loader",
            },
            {
              // Run postcss actions
              loader: "postcss-loader",
              options: {
                // `postcssOptions` is needed for postcss 8.x;
                // if you use postcss 7.x skip the key
                postcssOptions: {
                  // postcss plugins, can be exported to postcss.config.js
                  plugins: function () {
                    return [require("autoprefixer")];
                  },
                },
              },
            },
            {
              // compiles Sass to CSS
              loader: "sass-loader",
              options: {
                // Prefer `dart-sass`
                implementation: require("sass"),
                sassOptions: {
                  quietDeps: true,
                },
              },
            },
          ],
        },
      ],
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: "styles/[name].[contenthash].css",
        chunkFilename: "[id].css",
      }),
    ],
    optimization: {
      minimize: true,
      minimizer: [new CssMinimizerPlugin(), "..."],
      runtimeChunk: {
        name: "runtime",
      },
    },
    performance: {
      hints: false,
      maxEntrypointSize: 512000,
      maxAssetSize: 512000,
    },
  };
};

'''
'''--- contract-rs/dacha/Cargo.toml ---
[package]
name = "dacha"
version = "1.2.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract-rs/dacha/README.md ---
# Dacha Fi

Farm potatos - trade potatos

Based on berryclub fork

## Building

```bash
./build.sh
```

'''
'''--- contract-rs/dacha/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/dacha.wasm ./res/

'''
'''--- contract-rs/dacha/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_dacha"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install 1.69.0; rustup default 1.69.0; rustup target add wasm32-unknown-unknown; cargo build --package dacha --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/dacha.wasm $DIR/res/dacha_release.wasm

'''
'''--- contract-rs/dacha/deploy.sh ---
#!/bin/bash
set -e

WNEAR_AMOUNT=10000000000000000000000000
AMOUNT=10000000000000000000000

echo "Account ID: $ACCOUNT_ID"
echo "Wrap NEAR account ID: $WNEAR"
echo "REF Exchange account ID: $CONTRACT_ID"
echo "Correct?"

read CORRECT

near deploy $ACCOUNT_ID res/dacha.wasm new '{}' --initGas=200000000000000
near call $WNEAR --accountId=$ACCOUNT_ID ft_transfer_call '{"receiver_id": "'$CONTRACT_ID'", "amount": "'$WNEAR_AMOUNT'", "msg": ""}' --gas=100000000000000 --depositYocto=1
near call $CONTRACT_ID add_simple_pool '{"tokens": ["'$ACCOUNT_ID'", "'$WNEAR'"], "fee": 25}' --account_id=$ACCOUNT_ID --amount=0.01

echo "What's POOL_ID?"
read POOL_ID

near call $ACCOUNT_ID --accountId=$ACCOUNT_ID set_pool_id '{"potato_pool_id": '$POOL_ID'}'

near call $CONTRACT_ID add_liquidity --accountId=$ACCOUNT_ID '{"pool_id": '$POOL_ID', "amounts": ["'$AMOUNT'", "'$WNEAR_AMOUNT'"]}'  --amount=0.01

'''
'''--- contract-rs/dacha/rust-toolchain.toml ---
[toolchain]
channel = "1.69"

'''
'''--- contract-rs/dacha/src/account.rs ---
use crate::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, near_bindgen, AccountId};

pub const PIXEL_COST: Balance = 1_000_000_000_000_000_000_000;
pub const ONE_NEAR: Balance = 1_000_000_000_000_000_000_000_000;
pub const DEFAULT_POTATO_BALANCE: Balance = 0;
/// Current reward is 1/10 pixel per day per pixel.
pub const REWARD_PER_PIXEL_PER_NANOSEC: Balance = PIXEL_COST / (24 * 60 * 60 * 1_000_000_000) / 10;

pub type AccountIndex = u32;

#[derive(BorshDeserialize, BorshSerialize)]
pub enum UpgradableAccount {
    Current(Account),
}

impl From<UpgradableAccount> for Account {
    fn from(account: UpgradableAccount) -> Self {
        match account {
            UpgradableAccount::Current(account) => account,
        }
    }
}

impl From<Account> for UpgradableAccount {
    fn from(account: Account) -> Self {
        UpgradableAccount::Current(account)
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub account_id: AccountId,
    pub account_index: AccountIndex,
    pub balances: Vec<Balance>,
    pub num_pixels: u32,
    pub claim_timestamp: u64,
    pub farmed: Vec<Balance>,
    pub burned: Vec<Balance>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanAccount {
    pub account_id: AccountId,
    pub account_index: AccountIndex,
    pub potato_balance: U128,
    pub farmed_balance: U128,
    pub burned_balance: U128,
    pub num_pixels: u32,
}

impl From<Account> for HumanAccount {
    fn from(account: Account) -> Self {
        Self {
            account_id: account.account_id,
            account_index: account.account_index,
            potato_balance: account.balances[TokenType::Potato as usize].into(),
            farmed_balance: account.farmed[TokenType::Potato as usize].into(),
            burned_balance: account.burned[TokenType::Potato as usize].into(),
            num_pixels: account.num_pixels,
        }
    }
}

impl Account {
    pub fn new(account_id: AccountId, account_index: AccountIndex) -> Self {
        Self {
            account_id,
            account_index,
            balances: vec![DEFAULT_POTATO_BALANCE],
            num_pixels: 0,
            claim_timestamp: env::block_timestamp(),
            farmed: vec![0],
            burned: vec![0],
        }
    }

    pub fn touch(&mut self) -> Balance {
        let block_timestamp = env::block_timestamp();
        let time_diff = block_timestamp - self.claim_timestamp;
        let farmed = Balance::from(self.num_pixels)
            * Balance::from(time_diff)
            * REWARD_PER_PIXEL_PER_NANOSEC;
        self.claim_timestamp = block_timestamp;
        self.balances[TokenType::Potato as usize] += farmed;
        self.farmed[TokenType::Potato as usize] += farmed;
        farmed
    }

    pub fn charge(&mut self, berry: TokenType, num_pixels: u32) -> Balance {
        let cost = Balance::from(num_pixels) * PIXEL_COST;
        assert!(
            self.balances[berry as usize] >= cost,
            "Not enough balance to draw pixels"
        );
        self.balances[berry as usize] -= cost;
        self.burned[berry as usize] += cost;
        cost
    }
}

impl Contract {
    pub fn get_internal_account_by_id(&self, account_id: &AccountId) -> Option<Account> {
        self.account_indices
            .get(&account_id)
            .and_then(|account_index| self.get_internal_account_by_index(account_index))
    }

    pub fn get_mut_account(&mut self, account_id: AccountId, create: bool) -> Account {
        let mut account = self
            .get_internal_account_by_id(&account_id)
            .unwrap_or_else(|| {
                assert!(create, "Account doesn't exist");
                Account::new(account_id, self.num_accounts)
            });
        self.touch(&mut account);
        account
    }

    pub fn get_internal_account_by_index(&self, account_index: AccountIndex) -> Option<Account> {
        self.accounts
            .get(&account_index)
            .map(|account| account.into())
    }

    pub fn touch(&mut self, account: &mut Account) {
        self.farmed_balances[TokenType::Potato as usize] += account.touch();
    }

    pub fn save_account(&mut self, account: Account) {
        let account_index = account.account_index;
        if account_index >= self.num_accounts {
            self.account_indices
                .insert(&account.account_id, &account_index);
            self.num_accounts += 1;
        }
        self.accounts.insert(&account_index, &account.into());
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_pixel_cost(&self) -> U128 {
        PIXEL_COST.into()
    }

    pub fn get_account_by_index(&self, account_index: AccountIndex) -> Option<HumanAccount> {
        self.get_internal_account_by_index(account_index)
            .map(|mut account| {
                account.touch();
                account.into()
            })
    }

    pub fn get_account(&self, account_id: ValidAccountId) -> Option<HumanAccount> {
        self.get_internal_account_by_id(account_id.as_ref())
            .map(|mut account| {
                account.touch();
                account.into()
            })
    }

    pub fn get_account_balance(&self, account_id: ValidAccountId) -> U128 {
        self.get_internal_account_by_id(account_id.as_ref())
            .map(|mut account| {
                account.touch();
                account.balances[TokenType::Potato as usize]
            })
            .unwrap_or(DEFAULT_POTATO_BALANCE)
            .into()
    }

    pub fn get_account_num_pixels(&self, account_id: ValidAccountId) -> u32 {
        self.get_internal_account_by_id(account_id.as_ref())
            .map(|account| account.num_pixels)
            .unwrap_or(0)
    }

    pub fn get_account_id_by_index(&self, account_index: AccountIndex) -> Option<AccountId> {
        self.get_internal_account_by_index(account_index)
            .map(|account| account.account_id)
    }
}

'''
'''--- contract-rs/dacha/src/board.rs ---
use crate::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::json_types::Base64VecU8;
use near_sdk::near_bindgen;
use near_sdk::serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub const BOARD_WIDTH: u32 = 50;
pub const BOARD_HEIGHT: u32 = 50;
pub const TOTAL_NUM_PIXELS: u32 = BOARD_WIDTH * BOARD_HEIGHT;

#[derive(BorshDeserialize, BorshSerialize, Copy, Clone)]
pub struct Pixel {
    pub color: u32,
    pub owner_id: AccountIndex,
}

impl Default for Pixel {
    fn default() -> Self {
        Self {
            color: 0xffffff,
            owner_id: 0,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PixelLine(pub Vec<Pixel>);

impl Default for PixelLine {
    fn default() -> Self {
        Self(vec![Pixel::default(); BOARD_WIDTH as usize])
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PixelBoard {
    pub lines: Vector<PixelLine>,
    pub line_versions: Vec<u32>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SetPixelRequest {
    pub x: u32,
    pub y: u32,
    pub color: u32,
}

impl SetPixelRequest {
    pub fn assert_valid(&self) {
        assert!(self.x < BOARD_WIDTH, "X is out of bounds");
        assert!(self.y < BOARD_HEIGHT, "Y is out of bounds");
        assert!(self.color <= 0xffffff, "Color is out of bounds");
    }
}

impl PixelBoard {
    pub fn new() -> Self {
        let mut board = Self {
            lines: Vector::new(StorageKey::Pixels),
            line_versions: vec![0; BOARD_HEIGHT as usize],
        };
        let default_line = PixelLine::default();
        for _ in 0..BOARD_HEIGHT {
            board.lines.push(&default_line);
        }
        board
    }

    pub fn get_line(&self, index: u32) -> PixelLine {
        self.lines.get(u64::from(index)).unwrap()
    }

    /// Returns the list of the old owner IDs for the replaced pixels
    pub fn set_pixels(
        &mut self,
        new_owner_id: u32,
        pixels: &[SetPixelRequest],
    ) -> HashMap<AccountIndex, u32> {
        let mut lines = HashMap::new();
        let mut old_owners = HashMap::new();
        for request in pixels {
            request.assert_valid();
            let line = lines
                .entry(request.y)
                .or_insert_with(|| self.lines.get(u64::from(request.y)).unwrap());
            let old_owner = line.0[request.x as usize].owner_id;
            line.0[request.x as usize] = Pixel {
                owner_id: new_owner_id,
                color: request.color,
            };
            *old_owners.entry(old_owner).or_default() += 1;
        }
        for (i, line) in lines {
            self.save_line(i, &line);
        }
        old_owners
    }

    fn save_line(&mut self, index: u32, line: &PixelLine) {
        self.lines.replace(u64::from(index), line);
        self.line_versions[index as usize] += 1;
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_lines(&self, lines: Vec<u32>) -> Vec<Base64VecU8> {
        lines
            .into_iter()
            .map(|i| {
                let line = self.board.get_line(i);
                line.try_to_vec().unwrap().into()
            })
            .collect()
    }

    pub fn get_line_versions(&self) -> Vec<u32> {
        self.board.line_versions.clone()
    }
}

'''
'''--- contract-rs/dacha/src/fungible_token_core.rs ---
use crate::*;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{assert_one_yocto, ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
pub const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

const NO_DEPOSIT: Balance = 0;

pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128;
}

#[ext_contract(ext_fungible_token_receiver)]
trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> Promise;
}

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
        // Initiating receiver's call and the callback
        ext_fungible_token_receiver::ft_on_transfer(
            sender_id.clone(),
            amount.into(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::ft_resolve_transfer(
            sender_id,
            receiver_id.into(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
    }

    fn ft_total_supply(&self) -> U128 {
        (self.farmed_balances[TokenType::Potato as usize]
            + self.minted_balances[TokenType::Potato as usize]
            - self.burned_balances[TokenType::Potato as usize])
            .into()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.get_internal_account_by_id(account_id.as_ref())
            .map(|mut account| {
                account.touch();
                account.balances[TokenType::Potato as usize]
            })
            .unwrap_or(0)
            .into()
    }
}

#[near_bindgen]
impl FungibleTokenResolver for Contract {
    #[private]
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let mut receiver = self.get_mut_account(receiver_id.clone(), false);
            let receiver_balance = receiver.balances[TokenType::Potato as usize];
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                receiver.balances[TokenType::Potato as usize] -= refund_amount;
                self.save_account(receiver);

                return if let Some(mut sender) = self.get_internal_account_by_id(&sender_id) {
                    self.touch(&mut sender);
                    sender.balances[TokenType::Potato as usize] += refund_amount;
                    self.save_account(sender);
                    log!(
                        "Refund {} from {} to {}",
                        refund_amount,
                        receiver_id,
                        sender_id
                    );
                    (amount - refund_amount).into()
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.burned_balances[TokenType::Potato as usize] += refund_amount;
                    log!("The account of the sender was deleted");
                    amount.into()
                };
            }
        }
        amount.into()
    }
}

'''
'''--- contract-rs/dacha/src/fungible_token_metadata.rs ---
use super::*;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};

const ICON: &str = "data:image/jpeg;base64,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";

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: String::from("Potato ðŸ¥”"),
            symbol: String::from("POTATO"),
            icon: Some(String::from(ICON)),
            reference: None,
            reference_hash: None,
            decimals: 21,
        }
    }
}

'''
'''--- contract-rs/dacha/src/fungible_token_storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use std::convert::TryInto;
use std::mem::size_of;

const STORAGE_AMOUNT_BYTES: usize = size_of::<UpgradableAccount>() + 68 + 40 + 100;

#[allow(unused_variables)]
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(env::predecessor_account_id);
        let attached_deposit = env::attached_deposit();
        let refund_amount = if self.account_indices.contains_key(&account_id) {
            attached_deposit
        } else {
            let amount = self.storage_balance_bounds().min.0;
            assert!(attached_deposit >= amount);
            let account = self.get_mut_account(account_id.clone(), true);
            self.save_account(account);
            attached_deposit - amount
        };
        if refund_amount > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund_amount);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        env::panic(b"Unimplemented");
    }

    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic(b"Unimplemented");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        let v = STORAGE_AMOUNT_BYTES as Balance * env::storage_byte_cost();
        StorageBalanceBounds {
            min: v.into(),
            max: Some(v.into()),
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        if self.account_indices.contains_key(account_id.as_ref()) {
            Some(StorageBalance {
                total: self.storage_balance_bounds().min,
                available: 0.into(),
            })
        } else {
            None
        }
    }
}

'''
'''--- contract-rs/dacha/src/internal.rs ---
use crate::*;
use near_sdk::Timestamp;

pub(crate) fn ns_to_ms(ns: Timestamp) -> Timestamp {
    ns / 10u64.pow(6)
}

impl Contract {
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.get_mut_account(account_id.clone(), amount >= PIXEL_COST);
        let balance = account.balances[TokenType::Potato as usize];

        if let Some(new_balance) = balance.checked_add(amount) {
            account.balances[TokenType::Potato as usize] = new_balance;
            self.save_account(account);
        } else {
            env::panic(b"Balance overflow");
        }
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.get_mut_account(account_id.clone(), false);
        let balance = account.balances[TokenType::Potato as usize];

        if let Some(new_balance) = balance.checked_sub(amount) {
            account.balances[TokenType::Potato as usize] = new_balance;
            self.save_account(account);
        } else {
            env::panic(b"The account doesn't have enough balance");
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        assert_ne!(
            sender_id, receiver_id,
            "Sender and receiver should be different"
        );
        assert!(amount > 0, "The amount should be a positive number");
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        env::log(format!("Transfer {} from {} to {}", amount, sender_id, receiver_id).as_bytes());
        if let Some(memo) = memo {
            env::log(format!("Memo: {}", memo).as_bytes());
        }
    }
}

'''
'''--- contract-rs/dacha/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, Duration, PanicOnDefault, Promise,
    PromiseOrValue,
};

const TIME_FROM_LAST_PING_NS: Duration = 1 * 60 * 10u64.pow(9);
const ONE_DAY_MS: Duration = 24 * 60 * 60 * 1000;

const MINT_PER_DAY: u128 = 100 * PIXEL_COST;

pub mod account;
pub use crate::account::*;

pub mod board;
pub use crate::board::*;

mod fungible_token_core;
mod fungible_token_metadata;
mod fungible_token_storage;
mod internal;
mod mint;

pub use crate::fungible_token_core::*;
pub use crate::fungible_token_metadata::*;
pub use crate::fungible_token_storage::*;
use crate::internal::ns_to_ms;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum TokenType {
    Potato,
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    AccountIndices,
    Accounts,
    Pixels,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub account_indices: LookupMap<AccountId, u32>,
    pub board: board::PixelBoard,
    pub last_ping_timestamp: u64,
    pub num_accounts: u32,
    pub accounts: LookupMap<u32, UpgradableAccount>,
    pub burned_balances: Vec<Balance>,
    pub farmed_balances: Vec<Balance>,
    pub minted_balances: Vec<Balance>,
    pub potato_pool_id: u32,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut place = Self {
            account_indices: LookupMap::new(StorageKey::AccountIndices),
            board: PixelBoard::new(),
            num_accounts: 0,
            accounts: LookupMap::new(StorageKey::Accounts),
            last_ping_timestamp: env::block_timestamp(),
            burned_balances: vec![0, 0],
            farmed_balances: vec![0, 0],
            minted_balances: vec![0, 0],
            potato_pool_id: 0,
        };

        let mut account = Account::new(env::current_account_id(), 0);
        account.num_pixels = TOTAL_NUM_PIXELS;
        place.save_account(account);

        place.mint_initial_deposit();

        place
    }

    #[private]
    pub fn set_pool_id(&mut self, potato_pool_id: u32) {
        self.potato_pool_id = potato_pool_id;
    }

    pub fn get_pool_id(&self) -> u32 {
        self.potato_pool_id
    }

    pub fn account_exists(&self, account_id: ValidAccountId) -> bool {
        self.account_indices.contains_key(account_id.as_ref())
    }

    pub fn draw(&mut self, pixels: Vec<SetPixelRequest>) {
        if pixels.is_empty() {
            return;
        }
        let mut account = self.get_mut_account(env::predecessor_account_id(), false);
        let new_pixels = pixels.len() as u32;
        let cost = account.charge(TokenType::Potato, new_pixels);
        self.burned_balances[TokenType::Potato as usize] += cost;

        let mut old_owners = self.board.set_pixels(account.account_index, &pixels);
        let replaced_pixels = old_owners.remove(&account.account_index).unwrap_or(0);
        account.num_pixels += new_pixels - replaced_pixels;
        self.save_account(account);

        for (account_index, num_pixels) in old_owners {
            let mut account = self.get_internal_account_by_index(account_index).unwrap();
            self.touch(&mut account);
            account.num_pixels -= num_pixels;
            self.save_account(account);
        }

        self.maybe_ping();
    }

    pub fn get_num_accounts(&self) -> u32 {
        self.num_accounts
    }

    pub fn get_unminted_amount(&self) -> U128 {
        let current_time = env::block_timestamp();
        let duration = current_time - self.last_ping_timestamp;
        if duration == 0 {
            return 0.into();
        }
        (MINT_PER_DAY * ns_to_ms(duration) as u128 / ONE_DAY_MS as u128).into()
    }

    pub fn ping(&mut self) -> PromiseOrValue<()> {
        let current_time = env::block_timestamp();
        let unminted_amount: Balance = self.get_unminted_amount().into();
        if unminted_amount == 0 {
            return PromiseOrValue::Value(());
        }
        self.last_ping_timestamp = current_time;
        self.mint(unminted_amount).into()
    }
}

impl Contract {
    fn maybe_ping(&mut self) {
        let current_time = env::block_timestamp();
        let next_ping = self.last_ping_timestamp + TIME_FROM_LAST_PING_NS;
        if next_ping > current_time {
            return;
        }
        self.ping();
    }
}

'''
'''--- contract-rs/dacha/src/mint.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas};

// Mainnet config
const REF_FINANCE_ACCOUNT_ID: &str = "v2.ref-finance.near";
const WRAP_NEAR_TOKEN_ID: &str = "wrap.near";

// Testnet config
// const REF_FINANCE_ACCOUNT_ID: &str = "ref-finance-101.testnet";
// const WRAP_NEAR_TOKEN_ID: &str = "wrap.testnet";

const GAS_FOR_SWAP: Gas = 20 * 10u64.pow(12);
const GAS_FOR_STORAGE_DEPOSIT: Gas = 5 * 10u64.pow(12);
const GAS_FOR_DEPOSIT: Gas = 5 * 10u64.pow(12);

const GAS_FOR_WITHDRAW: Gas = 55 * 10u64.pow(12);
const GAS_FOR_NEAR_UNWRAP: Gas = 10 * 10u64.pow(12);

const GAS_FOR_REF_GET_DEPOSIT: Gas = GAS_FOR_WITHDRAW + GAS_FOR_NEAR_UNWRAP + 25 * 10u64.pow(12);

// 100 years supply.
const INITIAL_REF_AMOUNT: u128 = MINT_PER_DAY * 365 * 100;

/// Single swap action.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapAction {
    /// Pool which should be used for swapping.
    pub pool_id: u32,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

#[ext_contract(ext_ref_finance)]
pub trait ExtRefFinance {
    fn swap(&mut self, actions: Vec<SwapAction>, referral_id: Option<AccountId>);
    fn withdraw(&mut self, token_id: AccountId, amount: U128);
    fn get_deposit(&self, account_id: AccountId, token_id: AccountId) -> U128;
}

#[near_bindgen]
impl Contract {
    pub fn withdraw_ref_near(&mut self) -> Promise {
        let ref_account_id = REF_FINANCE_ACCOUNT_ID.to_string();

        ext_ref_finance::get_deposit(
            env::current_account_id(),
            WRAP_NEAR_TOKEN_ID.to_string(),
            &ref_account_id,
            0,
            GAS_FOR_DEPOSIT,
        )
        .then(Promise::new(env::current_account_id()).function_call(
            b"on_ref_get_deposit".to_vec(),
            b"{}".to_vec(),
            0,
            GAS_FOR_REF_GET_DEPOSIT,
        ))
    }

    #[private]
    pub fn on_ref_get_deposit(&mut self, #[callback] amount: U128) -> Promise {
        let ref_account_id = REF_FINANCE_ACCOUNT_ID.to_string();

        ext_ref_finance::withdraw(
            WRAP_NEAR_TOKEN_ID.to_string(),
            amount,
            &ref_account_id,
            1,
            GAS_FOR_WITHDRAW,
        )
        .then(Promise::new(WRAP_NEAR_TOKEN_ID.to_string()).function_call(
            b"near_withdraw".to_vec(),
            b"{}".to_vec(),
            1,
            GAS_FOR_NEAR_UNWRAP,
        ))
    }
}

impl Contract {
    pub(crate) fn mint(&mut self, amount: Balance) -> Promise {
        let ref_account_id = REF_FINANCE_ACCOUNT_ID.to_string();
        self.internal_deposit(&ref_account_id, amount);
        self.minted_balances[TokenType::Potato as usize] += amount;

        ext_ref_finance::swap(
            vec![SwapAction {
                pool_id: self.potato_pool_id,
                token_in: env::current_account_id(),
                amount_in: Some(U128(amount)),
                token_out: WRAP_NEAR_TOKEN_ID.to_string(),
                min_amount_out: U128(1),
            }],
            Some(env::current_account_id()),
            &ref_account_id,
            1,
            GAS_FOR_SWAP,
        )
    }

    pub(crate) fn mint_initial_deposit(&mut self) {
        let ref_account_id = REF_FINANCE_ACCOUNT_ID.to_string();
        self.internal_deposit(&ref_account_id, 10000 * PIXEL_COST);
        self.minted_balances[TokenType::Potato as usize] += 10000 * PIXEL_COST;

        Promise::new(WRAP_NEAR_TOKEN_ID.to_string())
            .function_call(
                b"storage_deposit".to_vec(),
                b"{}".to_vec(),
                125 * env::storage_byte_cost(),
                GAS_FOR_STORAGE_DEPOSIT,
            )
            .function_call(
                b"near_deposit".to_vec(),
                b"{}".to_vec(),
                10 * ONE_NEAR,
                GAS_FOR_STORAGE_DEPOSIT,
            );

        Promise::new(ref_account_id)
            .function_call(
                b"storage_deposit".to_vec(),
                b"{}".to_vec(),
                ONE_NEAR / 10,
                GAS_FOR_STORAGE_DEPOSIT,
            )
            .function_call(
                b"register_tokens".to_vec(),
                format!("{{\"token_ids\": [\"{}\"]}}", env::current_account_id(),).into_bytes(),
                1,
                GAS_FOR_DEPOSIT,
            )
            .function_call(
                b"ft_on_transfer".to_vec(),
                format!(
                    "{{\"sender_id\": \"{}\", \"amount\": \"{}\", \"msg\": \"\"}}",
                    env::current_account_id(),
                    INITIAL_REF_AMOUNT
                )
                .into_bytes(),
                0,
                GAS_FOR_DEPOSIT,
            );
    }
}

'''
'''--- package.json ---
{
  "name": "frontend",
  "version": "0.3.0",
  "homepage": "https://dacha.finance",
  "private": true,
  "engines": {
    "node": "18.x"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^8.9.3",
    "@near-wallet-selector/here-wallet": "^8.9.3",
    "@near-wallet-selector/ledger": "^8.9.3",
    "@near-wallet-selector/math-wallet": "^8.9.3",
    "@near-wallet-selector/meteor-wallet": "^8.9.3",
    "@near-wallet-selector/mintbase-wallet": "^8.9.3",
    "@near-wallet-selector/modal-ui": "^8.9.3",
    "@near-wallet-selector/my-near-wallet": "^8.9.3",
    "@near-wallet-selector/near-mobile-wallet": "^8.9.3",
    "@near-wallet-selector/near-snap": "^8.9.3",
    "@near-wallet-selector/nightly": "^8.9.3",
    "@near-wallet-selector/sender": "^8.9.3",
    "@near-wallet-selector/wallet-utils": "^8.9.3",
    "@near-wallet-selector/welldone-wallet": "^8.9.3",
    "@testing-library/jest-dom": "^4.2.4",
    "@testing-library/react": "^9.3.2",
    "@testing-library/user-event": "^7.1.2",
    "big.js": "^6.1.1",
    "js-sha256": "^0.9.0",
    "local-storage": "^2.0.0",
    "near-api-js": "^0.44.0",
    "react": "^18.2.0",
    "react-bootstrap": "^2.5.0",
    "react-color": "^2.18.1",
    "react-compound-timer": "^1.2.0",
    "react-dom": "^18.2.0",
    "react-files": "^3.0.0",
    "react-switch": "^5.0.1"
  },
  "scripts": {
    "serve": "webpack serve",
    "webpack": "webpack",
    "dev": "yarn run serve -- --env mode=development",
    "prod": "yarn run webpack -- --env mode=production",
    "prod:analyze": "yarn run prod -- --env presets=analyze",
    "build": "yarn run prod",
    "start": "yarn run dev"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/cli": "^7.15.4",
    "@babel/core": "^7.15.5",
    "@babel/preset-env": "^7.15.4",
    "@babel/preset-react": "^7.14.5",
    "assert": "^2.0.0",
    "babel-loader": "^8.2.2",
    "browserify-zlib": "^0.2.0",
    "buffer": "^6.0.3",
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^9.0.1",
    "cross-env": "^7.0.3",
    "crypto-browserify": "^3.12.0",
    "css-loader": "^6.2.0",
    "css-minimizer-webpack-plugin": "^3.0.2",
    "html-webpack-plugin": "^5.3.2",
    "https-browserify": "^1.0.0",
    "mini-css-extract-plugin": "^2.2.2",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "postcss-loader": "^7.0.1",
    "process": "^0.11.10",
    "raw-loader": "^4.0.2",
    "sass": "^1.66.1",
    "sass-loader": "^13.1.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "style-loader": "^3.2.1",
    "url": "^0.11.0",
    "webpack": "^5.52.0",
    "webpack-bundle-analyzer": "^4.4.2",
    "webpack-cli": "^4.8.0",
    "webpack-dev-server": "^4.1.0",
    "webpack-manifest-plugin": "^5.0.0",
    "webpack-merge": "^5.8.0"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Dacha Finance - buy ðŸ¥” - plant ðŸ¥” - farm ðŸ¥” - sell ðŸ¥”"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:image" content="https://dacha.finance/favicon.png"/>
    <meta property="og:url" content="https://dacha.finance/" />
    <meta property="og:title" content="Dacha Finance" />
    <meta property="og:description" content="Dacha Finance - buy ðŸ¥” - plant ðŸ¥” - farm ðŸ¥” - sell ðŸ¥”" />
    <link rel="apple-touch-icon" href="/favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Dacha Finance</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "Dacha Finance",
  "name": "Dacha Finance - buy \uD83E\uDD54 - plant \uD83E\uDD54 - farm \uD83E\uDD54 - sell \uD83E\uDD54",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/App.js ---
import "./App.scss";
import "./gh-fork-ribbon.css";
import "@near-wallet-selector/modal-ui/styles.css";
import React from "react";
import Big from "big.js";
import * as nearAPI from "near-api-js";
import { HuePicker, GithubPicker } from "react-color";
import { Weapons } from "./Weapons";
import { sha256 } from "js-sha256";
import { setupWalletSelector } from "@near-wallet-selector/core";
import { setupHereWallet } from "@near-wallet-selector/here-wallet";
import { setupSender } from "@near-wallet-selector/sender";
import { setupMathWallet } from "@near-wallet-selector/math-wallet";
import { setupNightly } from "@near-wallet-selector/nightly";
import { setupMeteorWallet } from "@near-wallet-selector/meteor-wallet";
import { setupNearSnap } from "@near-wallet-selector/near-snap";
import { setupWelldoneWallet } from "@near-wallet-selector/welldone-wallet";
import { setupLedger } from "@near-wallet-selector/ledger";
import { setupNearMobileWallet } from "@near-wallet-selector/near-mobile-wallet";
import { setupMintbaseWallet } from "@near-wallet-selector/mintbase-wallet";
import { setupMyNearWallet } from "@near-wallet-selector/my-near-wallet";
import { setupModal } from "@near-wallet-selector/modal-ui";
import ls from "local-storage";

const defaultCodeHash = "11111111111111111111111111111111";

export const LsKey = "dacha:v01:";
const LsKeyAccountId = LsKey + ":accountId:";

const TGas = Big(10).pow(12);
const MaxGasPerTransaction = TGas.mul(300);
const MaxGasPerTransaction2FA = TGas.mul(220);
const randomPublicKey = nearAPI.utils.PublicKey.from(
  "ed25519:8fWHD35Rjd78yeowShh9GwhRudRtLLsGCRjZtgPjAtw9"
);
const StorageCostPerByte = Big(10).pow(19);
const OneNear = Big(10).pow(24);
const AccountSafetyMargin = OneNear.div(2);
const OnePotato = Big(10).pow(21);
const OneDacha = Big(10).pow(18);

const IsMainnet = window.location.hostname === "dacha.finance";
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  contractName: "dev-1638904065122-71210869985191",
  walletUrl: "https://wallet.testnet.near.org",
  refContractName: "ref-finance-101.testnet",
  wrapNearContractName: "wrap.testnet",
};
const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  contractName: "v1.dacha-finance.near",
  walletUrl: "https://wallet.near.org",
  refContractName: "v2.ref-finance.near",
  wrapNearContractName: "wrap.near",
};
const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

async function setupSelector() {
  return setupWalletSelector({
    network: NearConfig.networkId,
    modules: [setupHereWallet(), setupMintbaseWallet(), setupMyNearWallet()],
  });
}

function setupContract(near, contractId, options) {
  const { viewMethods = [], changeMethods = [] } = options;
  const contract = {
    near,
    contractId,
  };
  viewMethods.forEach((methodName) => {
    contract[methodName] = (args) =>
      near.viewCall(contractId, methodName, args);
  });
  changeMethods.forEach((methodName) => {
    contract[methodName] = (args, gas, deposit) =>
      near.functionCall(contractId, methodName, args || {}, gas, deposit);
  });
  return contract;
}

async function viewCall(
  provider,
  blockId,
  contractId,
  methodName,
  args,
  finality
) {
  args = args || {};
  const result = await provider.query({
    request_type: "call_function",
    account_id: contractId,
    method_name: methodName,
    args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
    block_id: blockId,
    finality,
  });

  return (
    result.result &&
    result.result.length > 0 &&
    JSON.parse(Buffer.from(result.result).toString())
  );
}

const UseLegacyFunctionCallCreator = true;
const functionCallCreator = UseLegacyFunctionCallCreator
  ? (methodName, args, gas, deposit) => ({
      type: "FunctionCall",
      params: {
        methodName,
        args,
        gas,
        deposit,
      },
    })
  : nearAPI.transactions.functionCall;

async function functionCall(
  near,
  contractName,
  methodName,
  args,
  gas,
  deposit
) {
  try {
    const wallet = await (await near.selector).wallet();

    return await wallet.signAndSendTransaction({
      receiverId: contractName,
      actions: [
        functionCallCreator(
          methodName,
          args,
          gas ?? TGas.mul(30).toFixed(0),
          deposit ?? "0"
        ),
      ],
    });
  } catch (e) {
    // const msg = e.toString();
    // if (msg.indexOf("does not have enough balance") !== -1) {
    //   return await refreshAllowanceObj.refreshAllowance();
    // }
    throw e;
  }
}

async function accountState(near, accountId) {
  const account = new nearAPI.Account(
    near.nearConnection.connection,
    accountId
  );
  return await account.state();
}

const defaultAccount = {
  loading: true,
  signedAccountId: ls.get(LsKeyAccountId) ?? undefined,
  accountId: ls.get(LsKeyAccountId) ?? undefined,
  state: null,
  near: null,
};

async function updateAccount(near, walletState) {
  near.connectedContractId = walletState?.contract?.contractId;
  if (
    near.connectedContractId &&
    near.connectedContractId !== NearConfig.contractName
  ) {
    const selector = await near.selector;
    const wallet = await selector.wallet();
    await wallet.signOut();
    near.connectedContractId = null;
    walletState = selector.store.getState();
  }
  near.accountId = walletState?.accounts?.[0]?.accountId ?? null;
  if (near.accountId) {
    near.publicKey = null;
    try {
      if (walletState?.selectedWalletId === "here-wallet") {
        const hereKeystore = ls.get("herewallet:keystore");
        near.publicKey = nearAPI.KeyPair.fromString(
          hereKeystore[NearConfig.networkId].accounts[near.accountId]
        ).getPublicKey();
      }
    } catch (e) {
      console.error(e);
    }
    if (!near.publicKey) {
      try {
        near.publicKey = nearAPI.KeyPair.fromString(
          ls.get(
            walletState?.selectedWalletId === "meteor-wallet"
              ? `_meteor_wallet${near.accountId}:${NearConfig.networkId}`
              : `near-api-js:keystore:${near.accountId}:${NearConfig.networkId}`
          )
        ).getPublicKey();
      } catch (e) {
        console.error(e);
      }
    }
  }
}

const loadAccount = async (near, setAccount) => {
  const signedAccountId = near.accountId;
  if (signedAccountId) {
    ls.set(LsKeyAccountId, signedAccountId);
  } else {
    ls.remove(LsKeyAccountId);
  }
  const account = {
    loading: false,
    signedAccountId,
    accountId: signedAccountId,
    state: null,
    near,
    refresh: async () => await loadAccount(near, setAccount),
  };
  if (signedAccountId) {
    const [state] = await Promise.all([
      // near.contract.storage_balance_of({
      //   account_id: signedAccountId,
      // }),
      near.accountState(signedAccountId),
    ]);
    // account.storageBalance = storageBalance;
    account.state = state;
  }

  setAccount(account);
};

export const Potato = (
  <span role="img" aria-label="potato" className="berry">
    ðŸ¥”
  </span>
);

export const Dacha = (
  <span role="img" aria-label="dacha" className="berry">
    ðŸ¡
  </span>
);

// const Berry = {
//   Potato: "Potato",
// };

const BoardHeight = 50;
const BoardWidth = 50;
const NumLinesPerFetch = 50;
const ExpectedLineLength = 4 + 8 * BoardWidth;
const CellWidth = 12;
const CellHeight = 12;
const MaxNumColors = 31;
const BatchOfPixels = 100;
// 500 ms
const BatchTimeout = 500;
const RefreshBoardTimeout = 1000;
const MaxWorkTime = 10 * 60 * 1000;
// const OneDayMs = 24 * 60 * 60 * 1000;

const intToColor = (c) => `#${c.toString(16).padStart(6, "0")}`;
const intToColorWithAlpha = (c, a) =>
  `#${c.toString(16).padStart(6, "0")}${Math.round(255 * a)
    .toString(16)
    .padStart(2, "0")}`;

const rgbaToInt = (cr, cg, cb, ca, bgColor) => {
  const bb = bgColor & 255;
  const bg = (bgColor >> 8) & 255;
  const br = (bgColor >> 16) & 255;

  const r = Math.round(cr * ca + br * (1 - ca));
  const g = Math.round(cg * ca + bg * (1 - ca));
  const b = Math.round(cb * ca + bb * (1 - ca));
  return (r << 16) + (g << 8) + b;
};

const imgColorToInt = (c, bgColor) => {
  const cr = c & 255;
  const cg = (c >> 8) & 255;
  const cb = (c >> 16) & 255;
  const ca = ((c >> 24) & 255) / 255;
  return rgbaToInt(cr, cg, cb, ca, bgColor);
};

const int2hsv = (cInt) => {
  cInt = intToColor(cInt).substr(1);
  const r = parseInt(cInt.substr(0, 2), 16) / 255;
  const g = parseInt(cInt.substr(2, 2), 16) / 255;
  const b = parseInt(cInt.substr(4, 2), 16) / 255;
  let v = Math.max(r, g, b),
    c = v - Math.min(r, g, b);
  let h =
    c && (v === r ? (g - b) / c : v === g ? 2 + (b - r) / c : 4 + (r - g) / c);
  return [60 * (h < 0 ? h + 6 : h), v && c / v, v];
};
const transparentColor = (c, a) =>
  `rgba(${c >> 16}, ${(c >> 8) & 0xff}, ${c & 0xff}, ${a})`;
const generateGamma = (hue) => {
  const gammaColors = [];
  for (let i = 0; i < MaxNumColors; ++i) {
    gammaColors.push(`hsl(${hue}, 100%, ${(100 * i) / (MaxNumColors - 1)}%)`);
  }
  return gammaColors;
};
const decodeLine = (line) => {
  let buf = Buffer.from(line, "base64");
  if (buf.length !== ExpectedLineLength) {
    throw new Error("Unexpected encoded line length");
  }
  let pixels = [];
  for (let i = 4; i < buf.length; i += 8) {
    let color = buf.readUInt32LE(i);
    let ownerIndex = buf.readUInt32LE(i + 4);
    pixels.push({
      color,
      ownerIndex,
    });
  }
  return pixels;
};

const WeaponsCheat = "3RsmJFsbD5JeiRFCCDJVFPnVrux83hgURbWArpghHBD6";
const CodeLength = 9;

export class App extends React.Component {
  constructor(props) {
    super(props);

    const colors = [
      "#000000",
      "#666666",
      "#aaaaaa",
      "#FFFFFF",
      "#F44E3B",
      "#D33115",
      "#9F0500",
      "#FE9200",
      "#E27300",
      "#C45100",
      "#FCDC00",
      "#FCC400",
      "#FB9E00",
      "#DBDF00",
      "#B0BC00",
      "#808900",
      "#A4DD00",
      "#68BC00",
      "#194D33",
      "#68CCCA",
      "#16A5A5",
      "#0C797D",
      "#73D8FF",
      "#009CE0",
      "#0062B1",
      "#AEA1FF",
      "#7B64FF",
      "#653294",
      "#FDA1FF",
      "#FA28FF",
      "#AB149E",
    ].map((c) => c.toLowerCase());
    const currentColor = parseInt(
      colors[Math.floor(Math.random() * colors.length)].substring(1),
      16
    );
    const defaultAlpha = 1; // 0.25;

    // const timeMs = new Date().getTime();

    this.state = {
      connected: false,
      signedIn: false,
      accountId: null,
      pendingPixels: 0,
      boardLoaded: false,
      selectedCell: null,
      alpha: defaultAlpha,
      currentColor,
      pickerColor: intToColorWithAlpha(currentColor, defaultAlpha),
      colors,
      gammaColors: generateGamma(0),
      pickingColor: false,
      owners: [],
      accounts: {},
      highlightedAccountIndex: -1,
      selectedOwnerIndex: false,
      weaponsOn: false,
      weaponsCodeKeys: [],
      watchMode: false,
      refPool: false,
      unmintedAmount: Big(0),
      loading: false,
      totalSupply: Big(0),
      dachaSupply: Big(10000).mul(OneDacha),
      accountBalance: Big(0),
      refBalance: Big(0),
    };

    this._buttonDown = false;
    this._oldCounts = {};
    this._numFailedTxs = 0;
    this._balanceRefreshTimer = null;
    this.canvasRef = React.createRef();
    this._context = false;
    this._lines = false;
    this._queue = [];
    this._pendingPixels = [];
    this._refreshBoardTimer = null;
    this._sendQueueTimer = null;
    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    this._accounts = {};

    this._initNear().then(() => {
      this.setState(
        {
          connected: true,
          signedIn: !!this._accountId,
          accountId: this._accountId,
          ircAccountId: this._accountId?.replace(".", "_"),
        },
        () => {
          if (window.location.hash.indexOf("watch") >= 0) {
            setTimeout(() => this.enableWatchMode(), 500);
          }
        }
      );
    });
  }

  componentDidMount() {
    const canvas = this.canvasRef.current;
    this._context = canvas.getContext("2d");

    const click = async () => {
      if (this.state.watchMode) {
        return;
      }
      if (this.state.rendering) {
        await this.drawImg(this.state.selectedCell);
      } else if (this.state.pickingColor) {
        this.pickColor(this.state.selectedCell);
      } else {
        this.saveColor();
        await this.drawPixel(this.state.selectedCell);
      }
    };

    const mouseMove = (e) => {
      let x, y;
      if ("touches" in e) {
        if (e.touches.length > 1) {
          return true;
        } else {
          const rect = e.target.getBoundingClientRect();
          x = e.targetTouches[0].clientX - rect.left;
          y = e.targetTouches[0].clientY - rect.top;
        }
      } else {
        x = e.offsetX;
        y = e.offsetY;
      }
      x = Math.trunc((x / e.target.clientWidth) * BoardWidth);
      y = Math.trunc((y / e.target.clientHeight) * BoardWidth);
      let cell = null;
      if (x >= 0 && x < BoardWidth && y >= 0 && y < BoardHeight) {
        cell = { x, y };
      }
      if (JSON.stringify(cell) !== JSON.stringify(this.state.selectedCell)) {
        this.setState(
          {
            selectedCell: cell,
            selectedOwnerIndex:
              this._lines &&
              cell &&
              this._lines[cell.y] &&
              this._lines[cell.y][cell.x].ownerIndex,
          },
          async () => {
            this.renderCanvas();
            if (this.state.selectedCell !== null && this._buttonDown) {
              await click();
            }
          }
        );
      }
      e.preventDefault();
      return false;
    };

    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("touchmove", mouseMove);

    const mouseDown = async (e) => {
      this._buttonDown = true;
      if (this.state.selectedCell !== null) {
        await click();
      }
    };

    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("touchstart", mouseDown);

    const unselectCell = () => {
      this.setState(
        {
          selectedCell: null,
        },
        () => this.renderCanvas()
      );
    };

    const mouseUp = async (e) => {
      this._buttonDown = false;
      if ("touches" in e) {
        unselectCell();
      }
    };

    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("touchend", mouseUp);

    canvas.addEventListener("mouseleave", unselectCell);

    canvas.addEventListener("mouseenter", (e) => {
      if (this._buttonDown) {
        if (!("touches" in e) && !(e.buttons & 1)) {
          this._buttonDown = false;
        }
      }
    });

    document.addEventListener("keydown", (e) => {
      e.altKey && this.enablePickColor();
    });

    document.addEventListener("keyup", (e) => {
      const weaponsCodeKeys = [
        e.key.toLowerCase().charCodeAt(0),
        ...this.state.weaponsCodeKeys,
      ].slice(0, CodeLength);
      const codeHash = nearAPI.utils.serialize.base_encode(
        new Uint8Array(sha256.array(weaponsCodeKeys))
      );
      this.setState({
        weaponsCodeKeys,
        weaponsOn: this.state.weaponsOn || codeHash === WeaponsCheat,
      });
      !e.altKey && this.disablePickColor();
    });
  }

  enablePickColor() {
    this.setState(
      {
        pickingColor: true,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  disablePickColor() {
    this.setState(
      {
        pickingColor: false,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  pickColor(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const color = this._lines[cell.y][cell.x].color;

    this.setState(
      {
        currentColor: color,
        alpha: 1,
        pickerColor: intToColorWithAlpha(color, 1),
        gammaColors: generateGamma(int2hsv(color)[0]),
        pickingColor: false,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  async refreshAllowance() {
    alert(
      "You're out of access key allowance. Need sign in again to refresh it"
    );
    await this.logOut();
    await this.requestSignIn();
  }

  async _sendQueue() {
    const pixels = this._queue.slice(0, BatchOfPixels);
    this._queue = this._queue.slice(BatchOfPixels);
    this._pendingPixels = pixels;

    try {
      await this._contract.draw(
        {
          pixels,
        },
        "75000000000000"
      );
      this._numFailedTxs = 0;
    } catch (error) {
      const msg = error.toString();
      if (msg.indexOf("does not have enough balance") !== -1) {
        await this.refreshAllowance();
        return;
      }
      console.log("Failed to send a transaction", error);
      this._numFailedTxs += 1;
      if (this._numFailedTxs < 3) {
        this._queue = this._queue.concat(this._pendingPixels);
        this._pendingPixels = [];
      } else {
        this._pendingPixels = [];
        this._queue = [];
      }
    }
    try {
      await Promise.all([this.refreshBoard(true), this.refreshAccountStats()]);
    } catch (e) {
      // ignore
    }
    this._pendingPixels.forEach((p) => {
      if (this._pending[p.y][p.x] === p.color) {
        this._pending[p.y][p.x] = -1;
      }
    });
    this._pendingPixels = [];
  }

  async _pingQueue(ready) {
    if (this._sendQueueTimer) {
      clearTimeout(this._sendQueueTimer);
      this._sendQueueTimer = null;
    }

    if (
      this._pendingPixels.length === 0 &&
      (this._queue.length >= BatchOfPixels || ready)
    ) {
      await this._sendQueue();
    }
    if (this._queue.length > 0) {
      this._sendQueueTimer = setTimeout(async () => {
        await this._pingQueue(true);
      }, BatchTimeout);
    }
  }

  async drawImg(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.potatoBalance : 0;

    if (balance - this.state.pendingPixels < this.state.potatoNeeded) {
      return;
    }

    const img = this.imageData;
    const w = img.width;
    const h = img.height;
    const x = cell.x - Math.trunc(w / 2);
    const y = cell.y - Math.trunc(h / 2);
    const d = new Uint32Array(this.imageData.data.buffer);
    for (let i = 0; i < h; ++i) {
      for (let j = 0; j < w; ++j) {
        const imgColor = d[i * w + j];
        if (
          imgColor &&
          y + i >= 0 &&
          y + i < BoardHeight &&
          x + j >= 0 &&
          x + j < BoardWidth
        ) {
          const bgColor = this._lines[y + i]
            ? this._lines[y + i][x + j].color
            : 0;
          const color = imgColorToInt(imgColor, bgColor);
          if (color !== bgColor) {
            this._queue.push({
              x: x + j,
              y: y + i,
              color,
            });
          }
        }
      }
    }
    this.setState({
      rendering: false,
    });

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  async drawPixel(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.potatoBalance : 0;
    if (balance - this.state.pendingPixels < 1) {
      return;
    }

    const bgColor = this._lines[cell.y] ? this._lines[cell.y][cell.x].color : 0;
    const cb = this.state.currentColor & 255;
    const cg = (this.state.currentColor >> 8) & 255;
    const cr = (this.state.currentColor >> 16) & 255;
    const color = rgbaToInt(cr, cg, cb, this.state.alpha, bgColor);

    if (
      this._pending[cell.y][cell.x] !== color &&
      this._lines[cell.y][cell.x].color !== color
    ) {
      this._pending[cell.y][cell.x] = color;
    } else {
      return;
    }

    this._queue.push({
      x: cell.x,
      y: cell.y,
      color,
    });

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  parseAccount(account, accountId) {
    if (!account) {
      account = {
        accountId,
        accountIndex: -1,
        potatoBalance: 0.0,
        numPixels: 0,
      };
    } else {
      account = {
        accountId: account.account_id,
        accountIndex: account.account_index,
        potatoBalance: parseFloat(account.potato_balance) / this._pixelCost,
        numPixels: account.num_pixels,
      };
    }
    account.startTime = new Date().getTime();
    account.potatoPixels = account.numPixels;
    account.potatoRewardPerDay = account.potatoPixels / 10;
    account.potatoRewardPerMs =
      account.potatoRewardPerDay / (24 * 60 * 60 * 1000);
    return account;
  }

  async getAccount(accountId) {
    return this.parseAccount(
      await this._contract.get_account({ account_id: accountId }),
      accountId
    );
  }

  async getAccountByIndex(accountIndex) {
    return this.parseAccount(
      await this._contract.get_account_by_index({
        account_index: accountIndex,
      }),
      "unknown"
    );
  }

  async refreshAccountStats() {
    let account = await this.getAccount(this._accountId);
    if (this._balanceRefreshTimer) {
      clearInterval(this._balanceRefreshTimer);
      this._balanceRefreshTimer = null;
    }

    this.setState({
      pendingPixels: this._pendingPixels.length + this._queue.length,
      account,
    });

    this._balanceRefreshTimer = setInterval(() => {
      const t = new Date().getTime() - account.startTime;
      this.setState({
        account: Object.assign({}, account, {
          potatoBalance: account.potatoBalance + t * account.potatoRewardPerMs,
        }),
        pendingPixels: this._pendingPixels.length + this._queue.length,
      });
    }, 100);
  }

  async _initNear() {
    const selector = await setupSelector();
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const nearConnection = await nearAPI.connect(
      Object.assign({ deps: { keyStore } }, NearConfig)
    );
    this._selector = selector;
    this._keyStore = keyStore;
    const _near = (this._near = {
      selector,
      keyStore,
      nearConnection,
    });

    const setAccount = (account) => {
      this._account = account;
      this._accountId = account.accountId;
      this.setState({ account });
    };

    selector.store.observable.subscribe(async (walletState) => {
      await updateAccount(_near, walletState);
      try {
        await loadAccount(_near, setAccount);
      } catch (e) {
        console.error(e);
      }
    });

    const transformBlockId = (blockId) =>
      blockId === "optimistic" || blockId === "final"
        ? {
            finality: blockId,
            blockId: undefined,
          }
        : blockId !== undefined && blockId !== null
        ? {
            finality: undefined,
            blockId: parseInt(blockId),
          }
        : {
            finality: "optimistic",
            blockId: undefined,
          };

    _near.viewCall = (contractId, methodName, args, blockHeightOrFinality) => {
      const { blockId, finality } = transformBlockId(blockHeightOrFinality);
      return viewCall(
        _near.nearConnection.connection.provider,
        blockId ?? undefined,
        contractId,
        methodName,
        args,
        finality
      );
    };
    _near.functionCall = (contractName, methodName, args, gas, deposit) =>
      functionCall(_near, contractName, methodName, args, gas, deposit);
    _near.accountState = (accountId) => accountState(_near, accountId);

    // this._accountId = this._walletConnection.getAccountId();
    //
    // this._account = this._walletConnection.account();
    this._contract = setupContract(this._near, NearConfig.contractName, {
      viewMethods: [
        "get_account",
        "get_account_by_index",
        "get_lines",
        "get_line_versions",
        "get_pixel_cost",
        "get_pool_id",
        "get_account_balance",
        "get_account_num_pixels",
        "get_account_id_by_index",
        "get_unminted_amount",
        "ft_total_supply",
      ],
      changeMethods: ["draw", "ping"],
    });
    this._refFinanceContract = setupContract(
      this._near,
      NearConfig.refContractName,
      {
        viewMethods: ["get_pool", "get_deposit"],
        changeMethods: [],
      }
    );
    this._wrapNearContract = setupContract(
      this._near,
      NearConfig.wrapNearContractName,
      {
        viewMethods: ["storage_balance_of", "ft_balance_of"],
        changeMethods: ["storage_deposit", "near_deposit", "ft_transfer_call"],
      }
    );

    this._sendTransactions = async (items) => {
      const maxGasPerTransaction = MaxGasPerTransaction;

      const transactions = [];
      let actions = [];
      let currentReceiverId = null;
      let currentTotalGas = Big(0);
      items.push([null, null]);
      console.log("Sending items", items);
      items.forEach(([receiverId, action]) => {
        const actionGas =
          action && action.type === "FunctionCall"
            ? Big(action.params?.gas || "0")
            : Big(0);
        const newTotalGas = currentTotalGas.add(actionGas);
        if (
          receiverId !== currentReceiverId ||
          newTotalGas.gt(maxGasPerTransaction)
        ) {
          if (currentReceiverId !== null) {
            transactions.push({
              receiverId: currentReceiverId,
              actions,
            });
            actions = [];
          }
          currentTotalGas = actionGas;
          currentReceiverId = receiverId;
        } else {
          currentTotalGas = newTotalGas;
        }
        actions.push(action);
      });
      console.log("Sending transactions", transactions);
      const wallet = await (await _near.selector).wallet();
      return await wallet.signAndSendTransactions({ transactions });
    };
    this._modal = setupModal(await selector, {
      contractId: NearConfig.contractName,
    });

    const [rawPixelCost, potatoPoolId] = await Promise.all([
      this._contract.get_pixel_cost(),
      this._contract.get_pool_id(),
    ]);

    this._potatoPoolId = potatoPoolId;
    this._pixelCost = parseFloat(rawPixelCost);
    if (this._accountId) {
      await this.refreshAccountStats();
    }
    this._lineVersions = Array(BoardHeight).fill(-1);
    this._lines = Array(BoardHeight).fill(false);
    this._pending = Array(BoardHeight).fill(false);
    this._pending.forEach((v, i, a) => (a[i] = Array(BoardWidth).fill(-1)));
    await this.refreshBoard(true);
  }

  async refreshBoard(forced) {
    if (this._refreshBoardTimer) {
      clearTimeout(this._refreshBoardTimer);
      this._refreshBoardTimer = null;
    }
    const t = new Date().getTime();
    if (this.state.watchMode || t < this._stopRefreshTime) {
      this._refreshBoardTimer = setTimeout(async () => {
        await this.refreshBoard(false);
      }, RefreshBoardTimeout);
    }

    if (!forced && document.hidden) {
      return;
    }

    const lineVersions = await this._contract.get_line_versions();
    let needLines = [];
    for (let i = 0; i < BoardHeight; ++i) {
      if (lineVersions[i] !== this._lineVersions[i]) {
        needLines.push(i);
      }
    }
    let requestLines = [];
    for (let i = 0; i < needLines.length; i += NumLinesPerFetch) {
      requestLines.push(needLines.slice(i, i + NumLinesPerFetch));
    }

    let results = await Promise.all(
      requestLines.map((lines) => this._contract.get_lines({ lines }))
    );
    results = results.flat();
    requestLines = requestLines.flat();
    for (let i = 0; i < requestLines.length; ++i) {
      let lineIndex = requestLines[i];
      this._lines[lineIndex] = decodeLine(results[i]);
    }

    this._lineVersions = lineVersions;
    if (!this.state.watchMode) {
      this._refreshRef();
      this._refreshOwners();
    }
    this.renderCanvas();
  }

  async _fetchRefPool() {
    const rawPool = await this._refFinanceContract.get_pool({
      pool_id: this._potatoPoolId,
    });
    const potato = Big(rawPool.amounts[0]);
    const near = Big(rawPool.amounts[1]);
    const fee = rawPool.total_fee;
    return { potato, near, fee };
  }

  async _refreshRef() {
    const [
      refPool,
      rawUnmintedAmount,
      rawTotalSupply,
      rawRefBalance,
    ] = await Promise.all([
      this._fetchRefPool(),
      this._contract.get_unminted_amount(),
      this._contract.ft_total_supply(),
      this._refFinanceContract.get_deposit({
        account_id: NearConfig.contractName,
        token_id: NearConfig.wrapNearContractName,
      }),
    ]);
    const unmintedAmount = Big(rawUnmintedAmount);
    const totalSupply = Big(rawTotalSupply);
    const refBalance = Big(rawRefBalance);
    this.setState({
      unmintedAmount,
      totalSupply,
      refPool,
      refBalance,
    });
  }

  _refreshOwners() {
    const counts = {};
    this._lines.flat().forEach((cell) => {
      counts[cell.ownerIndex] = (counts[cell.ownerIndex] || 0) + 1;
    });
    delete counts[0];
    const sortedKeys = Object.keys(counts).sort(
      (a, b) => counts[b] - counts[a]
    );
    this.setState({
      owners: sortedKeys.map((accountIndex) => {
        accountIndex = parseInt(accountIndex);
        return {
          accountIndex,
          numPixels: counts[accountIndex],
        };
      }),
    });
    sortedKeys.forEach(async (accountIndex) => {
      accountIndex = parseInt(accountIndex);
      if (
        !(accountIndex in this._accounts) ||
        counts[accountIndex] !== (this._oldCounts[accountIndex] || 0)
      ) {
        try {
          this._accounts[accountIndex] = await this.getAccountByIndex(
            accountIndex
          );
        } catch (err) {
          console.log("Failed to fetch account index #", accountIndex, err);
        }
        this.setState({
          accounts: Object.assign({}, this._accounts),
        });
      }
    });
    this.setState({
      accounts: Object.assign({}, this._accounts),
    });
    this._oldCounts = counts;
  }

  renderCanvas() {
    if (!this._context || !this._lines) {
      return;
    }

    const ctx = this._context;

    for (let i = 0; i < BoardHeight; ++i) {
      const line = this._lines[i];
      if (!line) {
        continue;
      }
      for (let j = 0; j < BoardWidth; ++j) {
        const p = line[j];
        ctx.fillStyle = intToColor(p.color);
        ctx.fillRect(j * CellWidth, i * CellHeight, CellWidth, CellHeight);
        if (this.state.highlightedAccountIndex >= 0) {
          if (p.ownerIndex !== this.state.highlightedAccountIndex) {
            ctx.fillStyle = "rgba(32, 32, 32, 0.8)";
            ctx.fillRect(
              j * CellWidth,
              i * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillRect(
              (j + 0.5) * CellWidth,
              (i + 0.5) * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(
              j * CellWidth,
              (i + 0.5) * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillRect(
              (j + 0.5) * CellWidth,
              i * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
          } else {
            ctx.beginPath();
            ctx.strokeStyle = ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 0.5;
            ctx.rect(
              j * CellWidth + 0.5,
              i * CellHeight + 0.5,
              CellWidth - 1,
              CellHeight - 1
            );
            ctx.stroke();
            ctx.closePath();
          }
        }
      }
    }

    this._pendingPixels.concat(this._queue).forEach((p) => {
      ctx.fillStyle = intToColor(p.color);
      ctx.fillRect(p.x * CellWidth, p.y * CellHeight, CellWidth, CellHeight);
    });

    if (this.state.selectedCell && !this.state.watchMode) {
      const c = this.state.selectedCell;
      if (this.state.rendering) {
        const img = this.imageData;
        const w = img.width;
        const h = img.height;
        const x = c.x - Math.trunc(w / 2);
        const y = c.y - Math.trunc(h / 2);
        const d = new Uint32Array(this.imageData.data.buffer);
        for (let i = 0; i < h; ++i) {
          for (let j = 0; j < w; ++j) {
            const color = d[i * w + j];
            if (
              color &&
              y + i >= 0 &&
              y + i < BoardHeight &&
              x + j >= 0 &&
              x + j < BoardWidth
            ) {
              const bgColor = this._lines[y + i]
                ? this._lines[y + i][x + j].color
                : 0;
              ctx.fillStyle = intToColor(imgColorToInt(color, bgColor));
              ctx.fillRect(
                (x + j) * CellWidth,
                (y + i) * CellHeight,
                CellWidth,
                CellHeight
              );
            }
          }
        }
      } else if (this.state.pickingColor) {
        const color = this._lines[c.y] ? this._lines[c.y][c.x].color : 0;
        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 0.5);
        ctx.lineWidth = CellWidth * 4;
        ctx.arc(
          (c.x + 0.5) * CellWidth,
          (c.y + 0.5) * CellHeight,
          CellWidth * 4,
          0,
          2 * Math.PI
        );
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 1);
        ctx.lineWidth = CellWidth * 2;
        ctx.arc(
          (c.x + 0.5) * CellWidth,
          (c.y + 0.5) * CellHeight,
          CellWidth * 4,
          0,
          2 * Math.PI
        );
        ctx.stroke();
        ctx.closePath();
      } else {
        ctx.fillStyle = transparentColor(this.state.currentColor, 0.2);
        ctx.fillRect(c.x * CellWidth, 0, CellWidth, c.y * CellHeight);
        ctx.fillRect(
          c.x * CellWidth,
          (c.y + 1) * CellHeight,
          CellWidth,
          (BoardHeight - c.y - 1) * CellHeight
        );
        ctx.fillRect(0, c.y * CellHeight, c.x * CellWidth, CellHeight);
        ctx.fillRect(
          (c.x + 1) * CellWidth,
          c.y * CellHeight,
          (BoardWidth - c.x - 1) * CellWidth,
          CellHeight
        );

        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.fillStyle = intToColor(this.state.currentColor);
        ctx.strokeStyle = intToColor(this.state.currentColor);
        ctx.rect(c.x * CellWidth, c.y * CellHeight, CellWidth, CellHeight);
        ctx.stroke();
        ctx.closePath();
      }
    }

    if (!this.state.boardLoaded) {
      this.setState({
        boardLoaded: true,
      });
    }
  }

  async requestSignIn() {
    const appTitle = "Dacha Finance";
    this._modal.show();
  }

  async logOut() {
    this._accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      accountId: this._accountId,
    });
  }

  // async alphaColorChange(c) {
  //   this.setState(
  //     {
  //       alpha: c.rgb.a,
  //     },
  //     () => {
  //       this.changeColor(c, c.rgb.a);
  //     }
  //   );
  // }

  hueColorChange(c) {
    this.setState({
      gammaColors: generateGamma(c.hsl.h),
    });
    this.changeColor(c);
  }

  saveColor() {
    const newColor = intToColor(this.state.currentColor);
    const index = this.state.colors.indexOf(newColor);
    if (index >= 0) {
      this.state.colors.splice(index, 1);
    }
    this.setState({
      colors: [newColor].concat(this.state.colors).slice(0, MaxNumColors),
    });
  }

  changeColor(c, alpha) {
    alpha = alpha || 1.0;
    const currentColor = c.rgb.r * 0x010000 + c.rgb.g * 0x000100 + c.rgb.b;
    c.hex = intToColorWithAlpha(currentColor, alpha);
    c.rgb.a = alpha;
    c.hsl.a = alpha;
    c.hsv.a = alpha;
    this.setState(
      {
        pickerColor: c,
        alpha,
        currentColor,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  async isTokenRegistered() {
    const storageBalance = await this._near.viewCall(
      NearConfig.wrapNearContractName,
      "storage_balance_of",
      {
        account_id: this._accountId,
      }
    );
    return storageBalance && storageBalance.total !== "0";
  }

  async tokenRegisterStorageAction(actions) {
    if (!(await this.isTokenRegistered())) {
      actions.push([
        NearConfig.wrapNearContractName,
        functionCallCreator(
          "storage_deposit",
          {
            account_id: this._accountId,
            registration_only: true,
          },
          TGas.mul(5).toFixed(0),
          Big(125).mul(StorageCostPerByte).toFixed(0)
        ),
      ]);
    }
  }

  adjustRefPool(refPool, unmintedAmount) {
    if (!unmintedAmount || unmintedAmount.eq(0)) {
      return refPool;
    }
    const { fee, near, potato } = refPool;

    const amountWithFee = Big(unmintedAmount).mul(Big(10000 - fee));
    const nearOut = amountWithFee
      .mul(near)
      .div(Big(10000).mul(potato).add(amountWithFee))
      .round(0, 0);
    return {
      fee,
      potato: potato.add(unmintedAmount),
      near: near.sub(nearOut),
    };
  }

  nearPotato(refPool, unmintedAmount, near, potato) {
    refPool = this.adjustRefPool(refPool, unmintedAmount);

    let nearIn, potatoOut;
    if (near) {
      nearIn = Big(near).mul(OneNear).round(0, 0);
      potatoOut = this.getRefReturn(refPool, nearIn);
    } else {
      potatoOut = Big(potato).mul(OnePotato).round(0, 0);
      nearIn = this.getRefInverseReturn(refPool, potatoOut);
    }
    return { nearIn, potatoOut };
  }

  async availableNearBalance() {
    const accountState = await this._near.accountState(this._accountId);
    const balance = Big(accountState.amount).sub(
      Big(accountState.storage_usage).mul(Big(StorageCostPerByte))
    );
    if (balance.gt(AccountSafetyMargin)) {
      return balance.sub(AccountSafetyMargin);
    }
    return Big(0);
  }

  async buyTokens(near, potato) {
    this.setState({
      loading: true,
    });

    const actions = [];

    console.log(await this._contract.ping());

    const [nearBalance, rawTokenBalance] = await Promise.all([
      this.availableNearBalance(),
      this._wrapNearContract.ft_balance_of({
        account_id: this._accountId,
      }),
      this.tokenRegisterStorageAction(actions),
      this._contract.ping(),
    ]);
    const tokenBalance = Big(rawTokenBalance);

    const refPool = await this._fetchRefPool();

    const { nearIn, potatoOut } = this.nearPotato(
      refPool,
      Big(0),
      near,
      potato
    );

    if (nearIn.gt(tokenBalance)) {
      const needDeposit = nearIn.sub(tokenBalance);
      if (nearBalance.lt(nearBalance)) {
        alert("Not enough NEAR balance");
        return;
      }
      actions.push([
        NearConfig.wrapNearContractName,
        functionCallCreator(
          "near_deposit",
          {},
          TGas.mul(5).toFixed(0),
          needDeposit.toFixed(0)
        ),
      ]);
    }

    actions.push([
      NearConfig.wrapNearContractName,
      functionCallCreator(
        "ft_transfer_call",
        {
          receiver_id: NearConfig.refContractName,
          amount: nearIn.toFixed(0),
          msg: JSON.stringify({
            actions: [
              {
                pool_id: this._potatoPoolId,
                token_in: NearConfig.wrapNearContractName,
                token_out: NearConfig.contractName,
                min_amount_out: potatoOut.mul(0.995).round(0, 0).toFixed(0),
              },
            ],
          }),
        },
        TGas.mul(180).toFixed(0),
        1
      ),
    ]);

    await this._sendTransactions(actions);
  }

  setHover(accountIndex, v) {
    if (v) {
      this.setState(
        {
          highlightedAccountIndex: accountIndex,
        },
        () => {
          this.renderCanvas();
        }
      );
    } else if (this.state.highlightedAccountIndex === accountIndex) {
      this.setState(
        {
          highlightedAccountIndex: -1,
        },
        () => {
          this.renderCanvas();
        }
      );
    }
  }

  async renderImg(img, potatoNeeded) {
    this.imageData = img;
    this.setState({
      weaponsOn: false,
      rendering: true,
      pickingColor: false,
      potatoNeeded,
    });
  }

  enableWatchMode() {
    this.setState({
      watchMode: true,
      weaponsOn: false,
    });
    document.body.style.transition = "3s";
    document.body.style.backgroundColor = "#333";
  }

  getRefReturn(refPool, amountIn) {
    let amountWithFee = Big(amountIn).mul(Big(10000 - refPool.fee));
    return amountWithFee
      .mul(refPool.potato)
      .div(Big(10000).mul(refPool.near).add(amountWithFee))
      .round(0, 0);
  }

  getRefInverseReturn(refPool, amountOut) {
    if (amountOut.gte(refPool.potato)) {
      return null;
    }
    return Big(10000)
      .mul(refPool.near)
      .mul(amountOut)
      .div(Big(10000 - refPool.fee).mul(refPool.potato.sub(amountOut)))
      .round(0, 3);
  }

  buyButton(near, potato) {
    const { nearIn, potatoOut } = this.nearPotato(
      this.state.refPool,
      this.state.unmintedAmount,
      near,
      potato
    );
    return (
      <button
        className="btn btn-primary"
        disabled={!nearIn || this.state.loading}
        onClick={() => this.buyTokens(near, potato)}
      >
        Buy{" "}
        <span className="font-weight-bold">
          {potatoOut.div(OnePotato).toFixed(1)}
          {Potato}
        </span>{" "}
        for{" "}
        <span className="font-weight-bold">
          {nearIn?.div(OneNear)?.toFixed(2)}â“ƒ
        </span>
      </button>
    );
  }

  async pingContract(e) {
    e.preventDefault();

    this.setState({
      loading: true,
    });

    await this._contract.ping();
    await this._refreshRef();

    this.setState({
      loading: false,
    });
  }

  rules(watchClass, dachaToken) {
    return (
      <div className={`container${watchClass}`}>
        <div>
          <h3>Dacha Rules</h3>
          <div>{dachaToken}</div>
          <p>
            Dacha Finance is an evolution of the berryclub project with improved
            tokenomics.
          </p>
          <p>
            The biggest change is the limited supply of the main token $POTATO{" "}
            {Potato} which makes the price of {Potato} dynamic.
            <li>
              100 {Potato} per day is minted by the contract and given to the
              REF pool.
            </li>
            <li>250 {Potato} per day is farmed from the pixel board.</li>
            <li>1 {Potato} is burned by drawing a pixel.</li>
          </p>
          <p>
            In order to draw a pixel you need to consume one {Potato} token,
            which removes it from circulation.
            <br /> To get {Potato} you can either farm them (by having your
            pixels on the board) or buy them from the market.
            <br /> The token is listed on REF Finance.
          </p>
          <p>
            There are few for you to attempt to make a profit:
            <li>Trade {Potato}</li>
            <li>
              Plant {Potato} to farm {Potato}
            </li>
            <li>Add {Potato} liquidity and earn fees</li>
            It's up to you.
          </p>
        </div>
      </div>
    );
  }

  computePotatoPrice() {
    const refPool = this.adjustRefPool(
      this.state.refPool,
      this.state.unmintedAmount
    );

    return refPool.potato
      .mul(OneNear.div(OnePotato))
      .div(refPool.near)
      .toFixed(3);
  }

  render() {
    const watchClass = this.state.watchMode ? " hidden" : "";

    const prices =
      !this.state.watchMode && this.state.refPool ? (
        <div>
          <div>
            <div>
              Price:{" "}
              <span className="balances">
                <span className="font-weight-bold">
                  1â“ƒ = {this.computePotatoPrice()}
                </span>
              </span>
              {Potato}
            </div>
            <div>
              Circulating supply:{" "}
              <span className="balances">
                <span className="font-weight-bold">
                  {this.state.totalSupply
                    .add(this.state.unmintedAmount)
                    .div(OnePotato)
                    .toFixed(2)}
                  {Potato}
                </span>
              </span>
            </div>
          </div>
          {this.state.signedIn && (
            <div className={`buttons${watchClass}`}>
              <div>
                {this.buyButton(0.1, null)}
                {this.buyButton(1, null)}
                {this.buyButton(5, null)}
              </div>
              <div>
                {this.buyButton(null, 40)}
                {this.buyButton(null, 200)}
                {this.buyButton(null, 1000)}
              </div>
            </div>
          )}
        </div>
      ) : (
        ""
      );
    const dachaToken =
      !this.state.watchMode && this.state.refPool ? (
        <div>
          <div>
            <div>
              {Dacha} Treasury:{" "}
              <span className="balances">
                <span className="font-weight-bold">
                  {this.state.refBalance
                    .add(this.state.accountBalance)
                    .div(OneNear)
                    .toFixed(2)}
                  â“ƒ
                </span>
              </span>
            </div>
            <div>
              Circulating supply:{" "}
              <span className="balances">
                <span className="font-weight-bold">
                  {this.state.dachaSupply.div(OneDacha).toFixed(2)}
                  {Dacha}
                </span>
              </span>
            </div>
          </div>
        </div>
      ) : (
        ""
      );

    const content = !this.state.connected ? (
      <div>
        Connecting...{" "}
        <span
          className="spinner-grow spinner-grow-sm"
          role="status"
          aria-hidden="true"
        />
      </div>
    ) : this.state.signedIn ? (
      <div>
        <div className={`float-right${watchClass}`}>
          <button
            className="ms-2 btn btn-outline-secondary"
            onClick={() => this.logOut()}
          >
            Log out ({this.state.accountId})
          </button>
        </div>
        <div className={`your-balance${watchClass}`}>
          Balance:{" "}
          <Balance
            account={this.state.account}
            pendingPixels={this.state.pendingPixels}
            detailed={true}
          />
        </div>
        {prices}
        <div className={`color-picker${watchClass}`}>
          <HuePicker
            color={this.state.pickerColor}
            width="100%"
            onChange={(c) => this.hueColorChange(c)}
          />
          {/*<AlphaPicker*/}
          {/*  color={this.state.pickerColor}*/}
          {/*  width="100%"*/}
          {/*  onChange={(c) => this.alphaColorChange(c)}*/}
          {/*/>*/}

          <GithubPicker
            className="circle-picker"
            colors={this.state.gammaColors}
            color={this.state.pickerColor}
            triangle="hide"
            width="100%"
            onChangeComplete={(c) => this.changeColor(c)}
          />
          <GithubPicker
            className="circle-picker"
            colors={this.state.colors}
            color={this.state.pickerColor}
            triangle="hide"
            width="100%"
            onChangeComplete={(c) => this.hueColorChange(c)}
          />
        </div>
      </div>
    ) : (
      <div style={{ marginBottom: "10px" }}>
        <div>
          <button
            className="btn btn-primary"
            onClick={() => this.requestSignIn()}
          >
            Log in with NEAR Wallet
          </button>
        </div>
        {prices}
      </div>
    );
    const weapons = this.state.weaponsOn ? (
      <div>
        <Weapons
          account={this.state.account}
          renderIt={(img, potatoNeeded) => this.renderImg(img, potatoNeeded)}
          enableWatchMode={() => this.enableWatchMode()}
        />
      </div>
    ) : (
      ""
    );

    return (
      <div>
        <div className={`header${watchClass}`}>
          <h2>
            {Potato} Dacha Finance
            {this.state.loading ? (
              <span className="text-muted"> (Loading...)</span>
            ) : (
              ""
            )}
          </h2>{" "}
          <a
            className="btn btn-outline-none"
            href={`https://app.skyward.finance/swap/${NearConfig.wrapNearContractName}/${NearConfig.contractName}`}
          >
            Trade {Potato}
          </a>
          <a
            className="btn btn-outline-none"
            href={`https://app.ref.finance/pool/${this._potatoPoolId}`}
          >
            REF Pool {Potato}
          </a>
          {content}
        </div>
        <div className="container">
          <div className="row">
            <div>
              <div>
                <canvas
                  ref={this.canvasRef}
                  width={600}
                  height={600}
                  className={
                    this.state.boardLoaded
                      ? `pixel-board${
                          this.state.watchMode ? " watch-mode" : ""
                        }`
                      : "pixel-board c-animated-background"
                  }
                />
              </div>
            </div>
            <div className={`leaderboard${watchClass}`}>
              <div>
                <Leaderboard
                  owners={this.state.owners}
                  accounts={this.state.accounts}
                  setHover={(accountIndex, v) => this.setHover(accountIndex, v)}
                  selectedOwnerIndex={this.state.selectedOwnerIndex}
                  highlightedAccountIndex={this.state.highlightedAccountIndex}
                />
              </div>
            </div>
          </div>
        </div>
        {this.rules(watchClass, dachaToken)}
        {weapons}
        <a
          className={`github-fork-ribbon right-bottom fixed${watchClass}`}
          href="https://github.com/evgenykuzyakov/dacha"
          data-ribbon="Fork me on GitHub"
          title="Fork me on GitHub"
        >
          Fork me on GitHub
        </a>
      </div>
    );
  }
}

const Balance = (props) => {
  const account = props.account;
  if (!account) {
    return "";
  }
  const fraction = props.detailed ? 3 : 1;
  const potatoBalance = account.potatoBalance - (props.pendingPixels || 0);
  const potatoFarm =
    account.potatoRewardPerDay > 0 ? (
      <span>
        {"(+"}
        <span className="font-weight-bold">{account.potatoRewardPerDay}</span>
        {Potato}
        {"/day)"}
      </span>
    ) : (
      ""
    );
  return (
    <span className="balances font-small">
      <span className="font-weight-bold">
        {potatoBalance.toFixed(fraction)}
      </span>
      {Potato} {potatoFarm}
      {props.pendingPixels ? <span> ({props.pendingPixels} pending)</span> : ""}
    </span>
  );
};

const Leaderboard = (props) => {
  const owners = props.owners.map((owner) => {
    if (owner.accountIndex in props.accounts) {
      owner.account = props.accounts[owner.accountIndex];
    }
    return (
      <Owner
        key={owner.accountIndex}
        {...owner}
        isSelected={owner.accountIndex === props.selectedOwnerIndex}
        setHover={(v) => props.setHover(owner.accountIndex, v)}
        isHighlighted={owner.accountIndex === props.highlightedAccountIndex}
      />
    );
  });
  return (
    <table className="table table-hover table-sm">
      <tbody>{owners}</tbody>
    </table>
  );
};

const Owner = (props) => {
  const account = props.account;
  return (
    <tr
      onMouseEnter={() => props.setHover(true)}
      onMouseLeave={() => props.setHover(false)}
      className={props.isSelected ? "selected" : ""}
    >
      <td>{account ? <Account accountId={account.accountId} /> : "..."}</td>
      <td className="text-nowrap">
        <small>
          <Balance account={account} />
        </small>
      </td>
    </tr>
  );
};

const Account = (props) => {
  const accountId = props.accountId;
  const shortAccountId =
    accountId.length > 6 + 6 + 3
      ? accountId.slice(0, 6) + "..." + accountId.slice(-6)
      : accountId;
  return (
    // <a className="account" href={`https://wayback.berryclub.io/${accountId}`}>
    <span>{shortAccountId}</span>
    // </a>
  );
};

'''
'''--- src/Weapons.js ---
import "./Weapons.scss";
import React from "react";
import Files from "react-files";
import { Potato } from "./App";

export class Weapons extends React.Component {
  constructor(props) {
    super(props);
    this.canvasRef = React.createRef();
    this.state = {
      width: 48,
      height: 28,
      potatoNeeded: 100,
      lockedAspect: true,
    };
  }

  componentDidMount() {
    this.canvas = this.canvasRef.current;
    this.ctx = this.canvas.getContext("2d");
    this.sourceImage = new Image();
    this.sourceImage.onload = () => {
      this.draw();
    };
    this.sourceImage.src = "/bfg.png";
  }

  draw() {
    const sourceImage = this.sourceImage;
    const canvas = this.canvas;
    const ctx = this.ctx;
    const width = this.state.width;
    const height = this.state.height;

    // Create a canvas with the desired dimensions
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = width * 10 + "px";
    canvas.style.height = height * 10 + "px";

    // Scale and draw the source image to the canvas
    ctx.clearRect(0, 0, width, height);
    ctx.imageSmoothingQuality = "low";
    ctx.drawImage(sourceImage, 0, 0, width, height);

    const imageData = ctx.getImageData(0, 0, width, height);
    this.imageData = imageData;
    this.setState({
      potatoNeeded: new Uint32Array(imageData.data.buffer).reduce(
        (sum, v) => sum + (v ? 1 : 0),
        0
      ),
    });
  }

  async onFilesChange(f) {
    const sourceImage = this.sourceImage;
    let reader = new FileReader();

    reader.readAsDataURL(f[0]);

    sourceImage.onload = () => {
      let width = sourceImage.naturalWidth;
      let height = sourceImage.naturalHeight;
      if (sourceImage.naturalWidth > 50 || sourceImage.naturalHeight > 50) {
        const aspect = width / height;
        width = Math.round(20 * Math.min(1, aspect));
        height = Math.round(20 * Math.min(1, 1 / aspect));
      }
      this.setState({
        width: Math.min(50, Math.max(1, width)),
        height: Math.min(50, Math.max(1, height)),
      });
      this.draw();
    };

    reader.onload = function (event) {
      sourceImage.src = event.target.result;
    };
  }

  async onFilesError(e, f) {
    console.log(e, f);
  }

  updateVal(key, value) {
    value = Math.min(50, Math.max(1, value));
    if (this.state.lockedAspect) {
      const aspect =
        this.sourceImage.naturalWidth / this.sourceImage.naturalHeight;
      let width, height;
      if (key === "width") {
        width = value;
        height = Math.round(width / aspect);
      } else {
        height = value;
        width = Math.round(height * aspect);
      }
      this.setState(
        {
          width: Math.min(50, Math.max(1, width)),
          height: Math.min(50, Math.max(1, height)),
        },
        () => {
          this.draw();
        }
      );
    } else {
      this.setState(
        {
          [key]: value,
        },
        () => {
          this.draw();
        }
      );
    }
  }

  changeLockedAspect() {
    this.setState({
      lockedAspect: !this.state.lockedAspect,
    });
  }

  render() {
    return (
      <div className="weapons-popup">
        <div className="weapons-content">
          <h2>So you need a BFG?</h2>
          <div>
            <Files
              type="button"
              className="btn"
              onChange={(f) => this.onFilesChange(f)}
              onError={(e, f) => this.onFilesError(e, f)}
              multiple={false}
              accepts={["image/*"]}
              minFileSize={1}
              clickable
            >
              Click to upload an image
            </Files>
          </div>
          <div>
            <label>Width</label>
            <input
              type="number"
              value={this.state.width}
              min={1}
              max={50}
              onChange={(e) => this.updateVal("width", e.target.value)}
            />{" "}
            <button
              className={
                "btn btn-outline-secondary low-right-margin" +
                (this.state.lockedAspect ? " btn-pressed" : " btn-not-pressed")
              }
              onClick={() => this.changeLockedAspect()}
            >
              <span role="img" aria-label="link" className="berry">
                ðŸ”—
              </span>
            </button>
            <label>Height</label>
            <input
              type="number"
              value={this.state.height}
              min={1}
              max={50}
              onChange={(e) => this.updateVal("height", e.target.value)}
            />
          </div>
          <button
            className="btn btn-success btn-large"
            disabled={
              !this.props.account ||
              this.props.account.avocadoBalance < this.state.potatoNeeded
            }
            onClick={() =>
              this.props.renderIt(this.imageData, this.state.potatoNeeded)
            }
          >
            Render on the board using {this.state.potatoNeeded} {Potato}
          </button>
          <button
            className="btn btn-primary btn-large"
            onClick={() => this.props.enableWatchMode()}
          >
            Enable watch mode
          </button>
          <div className="canvas-wrapper">
            <canvas
              ref={this.canvasRef}
              width={480}
              height={280}
              className="draw-preview"
            ></canvas>
          </div>
        </div>
      </div>
    );
  }
}

'''
'''--- src/gh-fork-ribbon.css ---
/*!
 * "Fork me on GitHub" CSS ribbon v0.2.3 | MIT License
 * https://github.com/simonwhitaker/github-fork-ribbon-css
*/

.github-fork-ribbon {
  width: 12.1em;
  height: 12.1em;
  position: absolute;
  overflow: hidden;
  top: 0;
  right: 0;
  z-index: 9999;
  pointer-events: none;
  font-size: 13px;
  text-decoration: none;
  text-indent: -999999px;
}

.github-fork-ribbon.fixed {
  position: fixed;
}

.github-fork-ribbon:hover, .github-fork-ribbon:active {
  background-color: rgba(0, 0, 0, 0.0);
}

.github-fork-ribbon:before, .github-fork-ribbon:after {
  /* The right and left classes determine the side we attach our banner to */
  position: absolute;
  display: block;
  width: 15.38em;
  height: 1.54em;

  top: 3.23em;
  right: -3.23em;

  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;

  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  -o-transform: rotate(45deg);
  transform: rotate(45deg);
}

.github-fork-ribbon:before {
  content: "";

  /* Add a bit of padding to give some substance outside the "stitching" */
  padding: .38em 0;

  /* Set the base colour */
  background-color: #a00;

  /* Set a gradient: transparent black at the top to almost-transparent black at the bottom */
  background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(0, 0, 0, 0.15)));
  background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -ms-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));

  /* Add a drop shadow */
  -webkit-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);

  pointer-events: auto;
}

.github-fork-ribbon:after {
  /* Set the text from the data-ribbon attribute */
  content: attr(data-ribbon);

  /* Set the text properties */
  color: #fff;
  font: 700 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.54em;
  text-decoration: none;
  text-shadow: 0 -.08em rgba(0, 0, 0, 0.5);
  text-align: center;
  text-indent: 0;

  /* Set the layout properties */
  padding: .15em 0;
  margin: .15em 0;

  /* Add "stitching" effect */
  border-width: .08em 0;
  border-style: dotted;
  border-color: #fff;
  border-color: rgba(255, 255, 255, 0.7);
}

.github-fork-ribbon.left-top, .github-fork-ribbon.left-bottom {
  right: auto;
  left: 0;
}

.github-fork-ribbon.left-bottom, .github-fork-ribbon.right-bottom {
  top: auto;
  bottom: 0;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after {
  right: auto;
  left: -3.23em;
}

.github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  top: auto;
  bottom: 3.23em;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  -webkit-transform: rotate(-45deg);
  -moz-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  -o-transform: rotate(-45deg);
  transform: rotate(-45deg);
}

'''
'''--- src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- src/index.js ---
import React from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import {App} from "./App";

const container = document.getElementById("root");
const root = createRoot(container);
root.render(<App />);

'''
'''--- webpack.config.js ---
const webpack = require("webpack");
const paths = require("./config/paths");
const path = require("path");
const ManifestPlugin = require("webpack-manifest-plugin");
const { CleanWebpackPlugin } = require("clean-webpack-plugin");
const HTMLWebpackPlugin = require("html-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const { merge } = require("webpack-merge");
const loadPreset = require("./config/presets/loadPreset");
const loadConfig = (mode) => require(`./config/webpack.${mode}.js`)(mode);

module.exports = function (env) {
  const { mode = "production" } = env || {};
  return merge(
    {
      mode,
      entry: `${paths.srcPath}/index.js`,
      output: {
        path: paths.distPath,
        filename: "[name].bundle.js",
        publicPath: "/",
      },
      module: {
        rules: [
          {
            test: /\.m?js/,
            resolve: {
              fullySpecified: false,
            },
          },
          {
            test: /\.js$/,
            use: ["babel-loader"],
            exclude: path.resolve(__dirname, "node_modules"),
          },
          // Images: Copy image files to build folder
          { test: /\.(?:ico|gif|png|jpg|jpeg)$/i, type: "asset/resource" },

          // Fonts and SVGs: Inline files
          { test: /\.(woff(2)?|eot|ttf|otf|svg|)$/, type: "asset/inline" },
        ],
      },
      resolve: {
        modules: [paths.srcPath, "node_modules"],
        extensions: [".js", ".jsx", ".json"],
        fallback: {
          crypto: require.resolve("crypto-browserify"),
          stream: require.resolve("stream-browserify"),
          http: require.resolve("stream-http"),
          https: require.resolve("https-browserify"),
          fs: false,
          path: require.resolve("path-browserify"),
          zlib: require.resolve("browserify-zlib"),
        },
        // Fix for using `yarn link "near-social-vm"`
        alias: {
          react: path.resolve(__dirname, "./node_modules/react"),
          "react-dom": path.resolve(__dirname, "./node_modules/react-dom"),
          "near-api-js": path.resolve(__dirname, "./node_modules/near-api-js"),
        },
      },
      plugins: [
        new webpack.EnvironmentPlugin({
          // Configure environment variables here.
          ENVIRONMENT: "browser",
        }),
        new CleanWebpackPlugin(),
        // Copies files from target to destination folder
        new CopyWebpackPlugin({
          patterns: [
            {
              from: paths.publicPath,
              to: "./",
              globOptions: {
                ignore: ["**/*.DS_Store", "**/index.html", "**/favicon.png"],
              },
              noErrorOnMissing: true,
            },
          ],
        }),
        new HTMLWebpackPlugin({
          template: `${paths.publicPath}/index.html`,
          favicon: `${paths.publicPath}/favicon.png`,
          publicPath: "/",
        }),
        new webpack.ProgressPlugin(),
        new webpack.ProvidePlugin({
          process: "process/browser",
          Buffer: [require.resolve("buffer/"), "Buffer"],
        }),
        // new ManifestPlugin.WebpackManifestPlugin(),
      ],
    },
    loadConfig(mode),
    loadPreset(env)
  );
};

'''