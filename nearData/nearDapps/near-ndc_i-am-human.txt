*GitHub Repository "near-ndc/i-am-human"*

'''--- .github/workflows/lint.yml ---
name: Lint

on:
  pull_request:
    branches: [master, main]
  merge_group:

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  markdown-lint:
    name: markdown-lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      # lint only changed files
      - uses: tj-actions/changed-files@v35
        id: changed-files
        with:
          files: "**/*.md"
          separator: ","
      - uses: DavidAnson/markdownlint-cli2-action@v9
        if: steps.changed-files.outputs.any_changed == 'true'
        with:
          globs: ${{ steps.changed-files.outputs.all_changed_files }}
          separator: ","

  markdown-link-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - uses: gaurav-nelson/github-action-markdown-link-check@v1
        with:
          use-quiet-mode: "yes"

'''
'''--- .github/workflows/rust.yml ---
name: Rust

on:
  pull_request:
    branches: [master, main]
  merge_group:
  push:
    branches: ["master"]

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            contracts/Cargo.lock
      - name: Install latest nightly
        if: env.GIT_DIFF
        uses: actions-rs/toolchain@v1
        with:
          toolchain: 1.73.0
          override: true
          components: rustfmt, clippy

      - name: Install wasm32 toolchain
        if: env.GIT_DIFF
        run: rustup target add wasm32-unknown-unknown
      - name: Build
        if: env.GIT_DIFF
        working-directory: ./contracts
        run: make build
      - name: Create near dirs
        if: env.GIT_DIFF
        working-directory: ./contracts
        run: make create-near-dirs
      - name: Clippy
        if: env.GIT_DIFF
        working-directory: ./contracts
        run: cargo clippy
      - name: Run tests
        if: env.GIT_DIFF
        working-directory: ./contracts
        run: cargo test --verbose

'''
'''--- .markdownlint.json ---
{
    "default": true,
    "MD001": false,
    "MD013": false,
    "MD024": { "siblings_only": true },
    "MD025": false,
    "MD033": false,
    "MD034": false,
    "whitespace": false
}

'''
'''--- README.md ---
# I am Human -- Proof of Humanity

Monorepository of contracts for the I am Human: proof of humanity protocol.

List of contracts:

- `registry`: implements the SBT Registry, documented in the [NEP-393](https://github.com/near/NEPs/pull/393/).
  See [Registry README](./contracts/README.md) for a detailed documentation about the I Am Human registry, examples and information about extra queries and methods.

Helper crates:

- `sbt`: set of traits, events and common functions for [NEP-393](https://github.com/near/NEPs/pull/393/) SBT Standard.
- `cost`: Common functions and constants to calculate gas and storage deposit for IAH registry calls.
- `human_checker`: Helper contract for integration tests. Notably, used for `is_human_call`.

Issuers:

- `demo-issuer`: basic SBT Issuer: contains a list of admins who are authorized to issue SBTs.
- `community-sbt`: Permissioned Community Issuer of SBT tokens.
- `community-open`: Permissionless Community Issuer of SBT tokens.
- `oracle`: SBT Issuer which relays on an off-chain authority signing claims for issuing SBTs.

work in progress:

- `soulbound-class`: An algebraic class of tokens to efficiently query if a user have required subset of tokens.
- `ubi`: demo use case implementing universal basic income.

## Example Flow

For details about creating and querying SBTs, and flow diagrams, see the [NEP-393](https://github.com/near/NEPs/pull/393/).

Actors:

- user: someone who wants to hold SBT
- issuer: a contract or an account which can issue SBTs and is whitelisted in a registry. Issuer is usually an entity which makes validation to mint a specific class of SBTs.
- registry: a contract which keeps balance of SBTs.

Whenever a new issuer is created, it needs a registry to mint tokens. Today, IAH registry is permissioned: the IAH Registry admin has to add a new issuer willing to mint tokens within IAH registry. In the future this may change and the process can be permission-less (any issuer will be able to mint tokens in the IAH registry).

Issuer calls `registry.sbt_mint` to mint new tokens. Each token must have specified class in it's metadata. See NEP-393 to learn more about SBT classes. The mint call panics, if a recipient already holds a token with a same class of a given issuer.

Anyone can query registry to check token supply or query tokens by issuer or by owner.

## Deployed contracts

### Mainnet

Production:

- **SBT registry**: `registry.i-am-human.near` @ registry/v1.8.0
- **Fractal**: `fractal.i-am-human.near` @ oracle/v1.2.0
  - verification pubkey base64: `"zqMwV9fTRoBOLXwt1mHxBAF3d0Rh9E9xwSAXR3/KL5E="`
- **Community SBTs**: `community.i-am-human.near` @ community-sbt/v5.0.0
  Max and default [TTL](./contracts/community-sbt/README.md#ttl) = 1year.
  classes: 1=OG, 2=NDC_Contributor, 3=NDC_Core_Contributors, 4=NDC_Champion, 5=NDC_Mod, 6=NDC_TechWG, 7=Creatives_DAO
- **Regens SBTs**: `issuer.regens.near` @ community-sbt/v5.0.0
  Max and default [TTL](./contracts/community-sbt/README.md#ttl) = 1year.
  classes: ProofOfRegen=1
- **Proof of Vibes**: `issuer.proofofvibes.near` @ community-sbt/v5.0.0
  Max and default [TTL](./contracts/community-sbt/README.md#ttl) = 1year.
  classes: Vibes=1

Mainnet Testing:

- `registry-v1.gwg-testing.near` @ registry/v1.8.0
  IAH issuer: `(fractal.i-am-human.near, [1])`

Deprecated:

- GoodDollar-SBT: `gooddollar-v1.i-am-human.near`.
  verification pubkey base64: `"zqMwV9fTRoBOLXwt1mHxBAF3d0Rh9E9xwSAXR3/KL5E="`

### Testnet

- **SBT registry**:
  Testnet registry is used to test the issuer behavior. For testing other integrations (eg polling, elections) use the testing-unstable version. Consult issuer contracts to validate which issuer is linked to which registry. We may consider adding migration to `registry-1` to make it compatible with the latest version.
  - `registry-v2.i-am-human.testnet` @ registry/v1.8.0 (same as the prod version)
  - `registry-unstable-v2.i-am-human.testnet` @ registry/v1.8.0
- **Demo SBT**: `sbt1.i-am-human.testnet` (the `demo_issuer` contract)
- **Fractal**: `fractal-v2.i-am-human.testnet` @ oracle/v1.2.0
  registry: `registry-1.i-am-human.testnet`; Verification pubkey base64: `FGoAI6DXghOSK2ZaKVT/5lSP4X4JkoQQphv1FD4YRto=`, `claim_ttl`: 3600ms, FV class: 1
- **Community-SBT**: `community-v2.i-am-human.testnet` @ community-sbt/v5.0.0
  registry: `registry-v2.i-am-human.testnet`
  classes: 1=OG, 2=NDC_Contributor, 3=NDC_Core_Contributors, 4=NDC_Champion, 5=NDC_Mod, 6=NDC_TechWG, 7=Creatives_DAO
  Max and default [TTL](./contracts/community-sbt/README.md#ttl) = 1year.
- **Open Community SBTs**: `CTR open-v1.i-am-human.testnet` @ community-open/v1.0.0

Deprecated:

- SBT Registry:
  - `registry.i-am-human.testnet`
  - `registry-1.i-am-human.testnet` @ release/v0.2
  - `registry-unstable.i-am-human.testnet` @ registry/v1.6.0
- **Fractal**: `i-am-human-staging.testnet` @ oracle/v1.0.1
  registry: `registry-1.i-am-human.testnet`; Verification pubkey base64: `FGoAI6DXghOSK2ZaKVT/5lSP4X4JkoQQphv1FD4YRto=`, `claim_ttl`: 3600ms, FV class: 1
- **Community-SBT**: `community-v1.i-am-human.testnet` @ community-sbt/v4.3.0
  registry: `registry-1.i-am-human.testnet`
  classes: 1=OG, 2=NDC_Contributor, 3=NDC_Core_Contributors, 4=NDC_Champion, 5=NDC_Mod, 6=NDC_TechWG, 7=Creatives_DAO
- GoodDollar SBT: `gooddollar-v1.i-am-human.testnet`

'''
'''--- contracts/.clippy.toml ---
msrv = "1.61"

'''
'''--- contracts/Cargo.toml ---
[workspace]
resolver = "1"
members = [
    "sbt",
    "cost",
    "community-sbt",
    "community-open",
    "oracle",
    "registry",
    "soulbound-class",
    "kudos",
    "easy-poll",
    "human_checker",
    "ubi",
    "demo-issuer",
]

[workspace.package]
edition = "2021"
license = "Mozilla Public License Version 2.0"
repository = "https://github.com/near-ndc/i-am-human"

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization), z is recommended usually
# 3  all optimiations
opt-level = "s"
# link time optimization
lto = true
panic = "abort"
# overflow-checks = true
# debug = false
# debug-assertions = false
# rpath = false

[profile.test]
panic = "abort"
overflow-checks = true
rpath = false

[workspace.dependencies]
anyhow = "1.0.71"
assert_matches = "1.5.0"
cid = "0.10.1"
ed25519-dalek = "1"
near-abi = "0.4.0"
near-contract-standards = "^4.1.1"
near-crypto = "0.17"
near-primitives = "0.17.0"
near-sandbox-utils = "0.7.0"
near-sdk = { version = "^4.1.1", features = ["unstable"] }
near-units = "0.2.0"
pretty_assertions = "1.4.0"
schemars = "0.8.12"
serde_json = { version = "^1.0", features = ["raw_value"] }
tokio = { version = "1.28", features = ["full"] }
tracing = "0.1.37"
uint = { version = "^0.9.5", default-features = false }
near-workspaces = { version = "0.8.0", features = ["unstable"] }

'''
'''--- contracts/README.md ---
# Contracts

## Requirements

- Rust v1.69.
  Note: near-sdk doesn't work with Rust v1.70: https://github.com/near/nearcore/issues/9143
- Cargo
- [cargo-near](https://github.com/near/cargo-near)

## Building

To create release WASM and ABI in the `res` directory, run:

```shell
cd <contract>
make build
```

'''
'''--- contracts/community-open/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>
-->

# CHANGELOG: Community SBT

## Unreleased

### Features

### Breaking Changes

### Bug Fixes

## v5.0.0 (2024-01-25)

### Breaking Changes

- The registry method `sbt_revoke_by_owner` now returns `boolean` indicating if all the tokens were revoked. `true` if all the tokens were revoked successfully or `false` if not and the method needs to be called again.
- `class_metadata` has been renamed to `sbt_class_metadata` to unify the SBT Issuer interface.

## v4.3.0 (2023-09-07)

### Features

- Added support for multiple admins authorized to manage issuers.

### Breaking Changes

- Contract field type for `admin` changed from `AccoundId` -> `LazyOption<Vec<AccountId>>`
- Recommended `cost.mint_deposit` is decreased by 0.001 miliNEAR (in total).

## v4.2.0 (2023-08-25)

The release introduces more class level customizations.

### Features

- Admin can set `max_ttl` per class rather than per contract.
- Allow minters to revoke tokens (previously, only contract admin DAO could do that).
- Allows minters to define class level metadata. So, now you can set meatadata for the whole issuer (contract), class and for every token. Class common stuff (like icons) should go on the class metadata level.
- New sbt_mint_many function allowing minter DAO to mint many tokens at once.

### Deployments

- `community.i-am-human.near`: tx: `6NEz1NASdExWF5wRzwiAHoHkCxWctgK96rJPGFHgoQz5`, migration: `Z8cH2vFT229av5z28xpFiX8wPZcx6N1UZs3fyFfwPLy`

'''
'''--- contracts/community-open/Cargo.toml ---
[package]
name = "community-open"
version = "1.0.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

cost = { path = "../cost" }
sbt = { path = "../sbt" }

[dev-dependencies]
pretty_assertions.workspace = true
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
tracing.workspace = true

'''
'''--- contracts/community-open/README.md ---
# Open Community SBT issuer

Based on SBT NEP: https://github.com/near/NEPs/pull/393. Early Design: https://hackmd.io/ZvgUeoF4SMGM4InswH0Dsg

This is a permissionless version of the [Community SBT](../community-sbt/README.md) contract: anyone can acquire a class to be a minter and designate other minters.

See root [README](../../README.md#testnet) for deployed smart contract addresses.

## Usage

Community SBT contract is designed for a communities with authority.
The contract is an SBT issuer and allows anyone to be a minter by acquiring a new class. The class restriction is implemented in the `sbt_mint` function.

The SBT minting and revoking can be only executed by an account which has _Minting Authority_, hence ideally, minter should be a DAO. Minting Authorities are set per class ID. Each class ID can has one more minter.

Only class admin can add or revoke minting authority.

### Become an Issuer

Anyone can become an issuer by acquiring permissionlessly a class. Class is just an ID associated to the account that acquired it. Any account can acquire many classes.

Once you acquire a class, you can add more admins and add or remove minters, update [class metadata](https://github.com/near/NEPs/blob/master/neps/nep-0393.md#smart-contract-interface). A minter will have a permission to mint on your behalves, but won't be able to add nor remove other minters.

To prevent spam, a payment is required, that is defined by the `const REGISTRATION_COST`.

```shell
# acquire a new class, set initial set of minters, and set max_ttl (maximum time for expire of
# newly minted SBTs to 100 days) attaching 2N payment.
near call CTR_ADDRESS acquire_next_class \
  '{"requires_iah": true, "minters": [MINTER_ADDRESS], "max_ttl": 8640000000, "metadata": {"name": "YOUR CLASS NAME"}}' \
  --deposit 0.1 --accountId ADMIN

near call CTR_ADDRESS set_class_metadata \
  '{"class": ClassId, "metadata": "{<Metadata JSON>}"}' --accountId ADMIN

near call CTR_ADDRESS add_minters \
  '{"class": ClassId, "minters": [MINTER2]' --accountId ADMIN

```

And anyone can query the class metadata:

```shell
near view CTR_ADDRESS class_metadata '{"class": ClassId}'
```

#### TTL

See [Community SBT](../community-sbt/README.md#ttl).

#### Minting

The mint function requires a deposit which is computed by the [`required_sbt_mint_deposit`](https://github.com/alpha-fi/i-am-human/blob/master/contracts/community-sbt/src/lib.rs#L158) function. The whole deposit is passed to the registry to cover the storage costs.
Metadata attributes:

- `expires_at` is be overwritten to `now + ttl`.
- `issued_at` is be overwritten to "now".
- `reference` and `reference_hash` are optional - it should be related to token characteristics. See [memo and metadata](#memo-and-metadata) guidelines.

```shell
near call CTR_ADDRESS sbt_mint \
  '{"receiver": "receipient.near",
    "metadata": {"class": 1, "reference": "link to token characteristics"},
    "memo": "optional operation info"}'  \
  --deposit 0.01 --accountId ADMIN
```

It is also possible to mint few tokens at once. In the example below, `recipient1` will get 1 token, `recipient2` will get 3 tokens. Note that one account can have at most one token of a give class (SBT standard doesn't allow one account to hold more than one token of the same class).

```shell
near call CTR_ADDRESS sbt_mint_many \
  '{"token_spec": [
       ["receipient1.near",
        [{"class": 1, "reference": "token1 ref"}]],
       ["receipient2.near",
        [{"class": 1, "reference": "token2 ref"}, {"class": 2, "reference": "token3 ref"}, {"class": 3, "reference": "token4 ref"}]]
    ],
    "memo": "optional operation info"}'  \
  --deposit 0.04 --gas 100000000000000 --accountId ADMIN
```

To query minting authorities of a given class call:

```shell
near view CTR_ADDRESS minting_authorities \
  '{"class": CLASS_ID}'
```

#### Query Registry

``` shell
near view $REGISTRY sbt_tokens_by_owner '{"account": "YOU", "issuer":"CTR_ADDRESS"}'
```

### Memo and Metadata

See [Guidelines for using metadata and minting memo field](../community-sbt/README.md#memo-and-metadata).

'''
'''--- contracts/community-open/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::FunctionError;

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum Error {
    NotAdmin,
    NotMinter,
    RequiredDeposit(u128),
    ClassNotFound,
}

impl FunctionError for Error {
    fn panic(&self) -> ! {
        match self {
            Error::NotAdmin => panic_str("not authorized: required admin"),
            Error::NotMinter => panic_str("not authorized: required minter"),
            Error::RequiredDeposit(min_deposit) => {
                panic_str(&format!("deposit must be at least {}yN", min_deposit))
            }
            Error::ClassNotFound => panic_str("class not found"),
        }
    }
}

'''
'''--- contracts/community-open/src/lib.rs ---
use std::collections::HashMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault, Promise, ONE_NEAR};

use cost::{calculate_iah_mint_gas, calculate_mint_gas, mint_deposit};
use sbt::*;

pub use crate::errors::*;
pub use crate::storage::*;

mod errors;
pub mod migrate;
mod storage;

const MIN_TTL: u64 = 86_400_000; // 24 hours in miliseconds
const MILI_NEAR: u128 = ONE_NEAR / 1000;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// map of classId -> to set of accounts authorized to mint
    pub classes: LookupMap<ClassId, ClassMinters>,
    pub next_class: ClassId,
    /// SBT registry.
    pub registry: AccountId,
    /// contract metadata
    pub metadata: LazyOption<ContractMetadata>,
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
    pub registration_cost: u64, // cost in milinear
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    /// @admin: account authorized to add new minting authority
    #[init]
    pub fn new(registry: AccountId, metadata: ContractMetadata) -> Self {
        Self {
            classes: LookupMap::new(StorageKey::MintingAuthority),
            next_class: 1,
            registry,
            metadata: LazyOption::new(StorageKey::ContractMetadata, Some(&metadata)),
            class_metadata: LookupMap::new(StorageKey::ClassMetadata),
            registration_cost: 100, // 0.1 Near
        }
    }

    /**********
     * QUERIES
     **********/

    /// Returns minting authorities by class. Returns none if the class is not enabled.
    pub fn class_minter(&self, class: ClassId) -> Option<ClassMinters> {
        self.classes.get(&class)
    }

    /// Returns registry address.
    pub fn registry(&self) -> AccountId {
        self.registry.clone()
    }

    /**********
     * Transactions
     **********/

    /// Mints a new SBT for the given receiver.
    /// If `metadata.expires_at` is None then we set it to max: ` now+max_ttl`.
    /// Panics if `metadata.expires_at > now+max_ttl` or when ClassID is not set or not 1.
    #[payable]
    #[handle_result]
    pub fn sbt_mint(
        &mut self,
        receiver: AccountId,
        #[allow(unused_mut)] mut metadata: TokenMetadata,
        memo: Option<String>,
    ) -> Result<Promise, Error> {
        let token_spec = vec![(receiver, vec![metadata])];
        self.sbt_mint_many(token_spec, memo)
    }

    /// Similar to `sbt_mint`, but allows to mint many tokens at once. See `sbt_mint` doc for
    /// more details.
    /// * `tokens` is list of pairs: token recipient and token metadata to mint for given recipient.
    #[payable]
    #[handle_result]
    pub fn sbt_mint_many(
        &mut self,
        #[allow(unused_mut)] mut token_spec: Vec<(AccountId, Vec<TokenMetadata>)>,
        memo: Option<String>,
    ) -> Result<Promise, Error> {
        let now_ms = env::block_timestamp_ms();
        let mut requires_iah = false;
        let mut class_info_map: HashMap<ClassId, (bool, u64)> = HashMap::new();
        let mut total_len = 0;
        for (_, token_metadatas) in &mut token_spec {
            total_len += token_metadatas.len();
            for m in token_metadatas {
                let (cls_requires_iah, ttl) = match class_info_map.get(&m.class) {
                    Some(ci) => (ci.0, ci.1),
                    None => {
                        let ci = self.class_info_minter(m.class)?;
                        class_info_map.insert(m.class, ci);
                        ci
                    }
                };
                requires_iah = requires_iah || cls_requires_iah;
                m.expires_at = Some(now_ms + ttl);
                m.issued_at = Some(now_ms);
            }
        }

        let required_deposit = mint_deposit(total_len);
        let attached_deposit = env::attached_deposit();
        if attached_deposit < required_deposit {
            return Err(Error::RequiredDeposit(required_deposit));
        }

        if let Some(memo) = memo {
            env::log_str(&format!("SBT mint memo: {}", memo));
        }

        let sbt_reg =
            ext_registry::ext(self.registry.clone()).with_attached_deposit(attached_deposit);
        let promise = if requires_iah {
            let gas = calculate_iah_mint_gas(total_len, token_spec.len());
            sbt_reg.with_static_gas(gas).sbt_mint_iah(token_spec)
        } else {
            sbt_reg
                .with_static_gas(calculate_mint_gas(total_len))
                .sbt_mint(token_spec)
        };

        Ok(promise)
    }

    /// Updates the expire time of provided tokens.
    /// `ttl` is duration in milliseconds to set expire time: `now+ttl`.
    /// Panics if `ttl > self.minters[class].max_ttl` or ttl < `MIN_TTL` or `tokens` is an empty list.
    /// Only minters are allowed to renew the tokens.
    pub fn sbt_renew(&mut self, tokens: Vec<TokenId>, ttl: u64, memo: Option<String>) -> Promise {
        require!(!tokens.is_empty(), "tokens must be a non empty list");
        let caller = env::predecessor_account_id();
        let ctr = env::current_account_id();
        ext_registry::ext(self.registry.clone())
            .sbt_classes(ctr.clone(), tokens.clone())
            .then(Self::ext(ctr).on_sbt_renew_callback(&caller, tokens, ttl, memo))
    }

    /// Callback for sbt_renew. Checks the return value from `sbts` and if any of the tokens
    /// does not exist, the ttl value is invalid or the caller is not a minter panics.
    #[private]
    pub fn on_sbt_renew_callback(
        &self,
        caller: &AccountId,
        tokens: Vec<TokenId>,
        ttl: u64,
        memo: Option<String>,
        #[callback_result] token_classes: Result<Vec<Option<ClassId>>, near_sdk::PromiseError>,
    ) -> Promise {
        let ts = token_classes.expect("error while retrieving tokens data from registry");
        let mut cached_class_info: HashMap<u64, (Vec<AccountId>, u64)> = HashMap::new();
        for token_class in ts {
            let max_ttl: u64;
            let class_id: u64 = token_class.expect("token not found");
            if let Some((cached_minters, cached_ttl)) = cached_class_info.get(&class_id) {
                max_ttl = *cached_ttl;
                self.assert_minter(caller, cached_minters);
            } else {
                max_ttl = self.get_ttl(class_id);
                let minters = self
                    .class_minter(class_id)
                    .expect("class not found")
                    .minters;
                self.assert_minter(caller, &minters);
                cached_class_info.insert(class_id, (minters, max_ttl));
            }
            self.assert_ttl(ttl, max_ttl);
        }
        if let Some(memo) = memo {
            env::log_str(&format!("SBT renew memo: {}", memo));
        }

        let expires_at_ms = env::block_timestamp_ms() + ttl;
        ext_registry::ext(self.registry.clone()).sbt_renew(tokens, expires_at_ms)
    }

    /// Revokes list of tokens. If `burn==true`, the tokens are burned (removed). Otherwise,
    /// the token expire_at is set to now, making the token expired. See `registry.sbt_revoke`
    /// for more details.
    /// Only class minters are allowed to revoke tokens
    pub fn sbt_revoke(
        &mut self,
        tokens: Vec<TokenId>,
        burn: bool,
        memo: Option<String>,
    ) -> Promise {
        require!(!tokens.is_empty(), "tokens must be a non empty list");
        let caller = env::predecessor_account_id();
        let ctr = env::current_account_id();
        ext_registry::ext(self.registry.clone())
            .sbt_classes(ctr.clone(), tokens.clone())
            .then(Self::ext(ctr).on_sbt_revoke_callback(&caller, tokens, burn, memo))
    }

    /// sbt_revoke callback. Checks if all the the tokens can be revoked by the caller
    /// based on the return value from registry.sbts. If not panics with a error message
    #[private]
    pub fn on_sbt_revoke_callback(
        &self,
        caller: &AccountId,
        tokens: Vec<TokenId>,
        burn: bool,
        memo: Option<String>,
        #[callback_result] token_classes: Result<Vec<Option<ClassId>>, near_sdk::PromiseError>,
    ) -> Promise {
        let ts = token_classes.expect("error while retrieving tokens data from registry");
        let mut cached_class_minters: HashMap<u64, Vec<AccountId>> = HashMap::new();
        for token_class in ts {
            let class_id: u64 = token_class.expect("token not found");
            if let Some(cached_minter) = cached_class_minters.get(&class_id) {
                self.assert_minter(caller, cached_minter);
            } else {
                let minters = self
                    .class_minter(class_id)
                    .expect("class not found")
                    .minters;
                self.assert_minter(caller, &minters);
                cached_class_minters.insert(class_id, minters);
            }
        }
        if let Some(memo) = memo {
            env::log_str(&format!("SBT revoke memo: {}", memo));
        }
        ext_registry::ext(self.registry.clone()).sbt_revoke(tokens, burn)
    }

    /// Admin: remove SBT from the given accounts.
    /// Panics if `accounts` is an empty list.
    pub fn revoke_for(
        &mut self,
        accounts: Vec<AccountId>,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        require!(!accounts.is_empty(), "accounts must be a non empty list");
        env::panic_str("not implemented");
        // todo: requires registry update.
        // let mut tokens = Vec::with_capacity(accounts.len());
        // for a in accounts {
        //     tokens.push(t);
        // }
        // if !tokens.is_empty() {
        //     SbtTokensEvent { tokens, memo }.emit_revoke();
        // }
    }

    /**********
     * Admin
     **********/
    /// Allows admin to change if the specific class requires IAH verification.
    /// Panics if class is not found or not called by a class admin.
    #[handle_result]
    pub fn set_requires_iah(&mut self, class: ClassId, requires_iah: bool) -> Result<(), Error> {
        let mut c = self.class_info_admin(class)?;
        if c.requires_iah != requires_iah {
            c.requires_iah = requires_iah;
            self.classes.insert(&class, &c);
        }
        Ok(())
    }

    /// Allows admin to change Max TTL, expected time duration in miliseconds.
    #[handle_result]
    pub fn set_max_ttl(&mut self, class: ClassId, max_ttl: u64) -> Result<(), Error> {
        let mut c = self.class_info_admin(class)?;
        c.max_ttl = max_ttl;
        self.classes.insert(&class, &c);
        Ok(())
    }

    /// Allows admin to update class metadata.
    /// Panics if class is not enabled.
    #[handle_result]
    pub fn set_sbt_class_metadata(
        &mut self,
        class: ClassId,
        metadata: ClassMetadata,
    ) -> Result<(), Error> {
        self.class_info_admin(class)?;
        self.class_metadata.insert(&class, &metadata);
        Ok(())
    }

    /// Acquires a new, unused class and authorizes minter to issue SBTs of that class.
    /// Caller will become an admin of the class.
    /// Must attach at least REGISTRATION_COST yNEAR to cover storage and bond cost.
    /// Returns the new class ID.
    #[payable]
    pub fn acquire_next_class(
        &mut self,
        requires_iah: bool,
        minters: Vec<AccountId>,
        max_ttl: u64,
        metadata: ClassMetadata,
        #[allow(unused_variables)] memo: Option<String>,
    ) -> ClassId {
        require!(
            MIN_TTL <= max_ttl,
            format!("ttl must be at least {}ms", MIN_TTL)
        );
        require!(
            MIN_TTL <= max_ttl,
            format!(
                "deposit must be at least {}yNEAR",
                self.registration_cost as u128 * MILI_NEAR
            )
        );
        let cls = self.next_class;
        self.next_class += 1;
        self.classes.insert(
            &cls,
            &ClassMinters {
                admins: vec![env::predecessor_account_id()],
                requires_iah,
                minters,
                max_ttl,
            },
        );
        self.class_metadata.insert(&cls, &metadata);
        cls
    }

    /// Admin: authorize `minter` to mint tokens of a `class`.
    /// Must be called by a class admin, panics otherwise.
    #[handle_result]
    pub fn add_minters(
        &mut self,
        class: ClassId,
        minters: Vec<AccountId>,
        #[allow(unused_variables)] memo: Option<String>,
    ) -> Result<(), Error> {
        let mut c = self.class_info_admin(class)?;
        let mut ok = false;
        for m in minters {
            if !c.minters.contains(&m) {
                c.minters.push(m);
                ok = true;
            }
        }
        if ok {
            self.classes.insert(&class, &c);
        }
        Ok(())
    }

    /// admin: revokes `class` minting for `minter`.
    /// Must be called by a class admin, panics otherwise.
    #[handle_result]
    pub fn remove_minters(
        &mut self,
        class: ClassId,
        minters: Vec<AccountId>,
        #[allow(unused_variables)] memo: Option<String>,
    ) -> Result<(), Error> {
        let mut c = self.class_info_admin(class)?;
        let mut ok = false;
        for m in minters {
            if let Some(idx) = c.minters.iter().position(|x| x == &m) {
                c.minters.swap_remove(idx);
                ok = true;
            }
        }
        if ok {
            self.classes.insert(&class, &c);
        }
        Ok(())
    }

    /// admin: updates this SBT ContractMetadata
    /// Must be called by a contract admin, panics otherwise.
    #[handle_result]
    #[private]
    pub fn update_metadata(&mut self, metadata: ContractMetadata) {
        self.metadata.replace(&metadata);
    }

    /**********
     * INTERNAL
     **********/

    /// Returns error if class is not found or not called by an admin.
    fn class_info_admin(&self, class: ClassId) -> Result<ClassMinters, Error> {
        match self.class_minter(class) {
            None => Err(Error::ClassNotFound),
            Some(cm) => {
                if cm.admins.contains(&env::predecessor_account_id()) {
                    Ok(cm)
                } else {
                    Err(Error::NotAdmin)
                }
            }
        }
    }

    /// Returns (requires_iah, max_ttl).
    /// Returns error if class is not found or not called by a minter nor an admin.
    fn class_info_minter(&self, class: ClassId) -> Result<(bool, u64), Error> {
        match self.class_minter(class) {
            None => Err(Error::ClassNotFound),
            Some(cm) => {
                let a = &env::predecessor_account_id();
                if cm.minters.contains(a) || cm.admins.contains(a) {
                    Ok((cm.requires_iah, cm.max_ttl))
                } else {
                    Err(Error::NotMinter)
                }
            }
        }
    }

    /// returns ttl for a given token class
    fn get_ttl(&self, class: ClassId) -> u64 {
        match self.class_minter(class) {
            None => panic!("class not found"),
            Some(cm) => cm.max_ttl,
        }
    }

    fn assert_ttl(&self, ttl: u64, max_ttl: u64) {
        require!(
            ttl <= max_ttl,
            format!("ttl must be smaller or equal than {}ms", max_ttl)
        );
    }

    fn assert_minter(&self, caller: &AccountId, minters: &Vec<AccountId>) {
        require!(minters.contains(caller), "caller must be a minter");
    }
}

#[near_bindgen]
impl SBTIssuer for Contract {
    fn sbt_metadata(&self) -> ContractMetadata {
        self.metadata.get().unwrap()
    }

    /// Returns `ClassMetadata` by class. Returns none if the class is not enabled.
    fn sbt_class_metadata(&self, class: ClassId) -> Option<ClassMetadata> {
        self.class_metadata.get(&class)
    }
}

#[cfg(test)]
mod tests {
    use cost::mint_deposit;
    use near_sdk::{
        test_utils::{
            test_env::{alice, bob, carol},
            VMContextBuilder,
        },
        testing_env, AccountId, Balance, VMContext,
    };
    use sbt::{ClassId, ClassMetadata, ContractMetadata, SBTIssuer, TokenMetadata};

    use crate::{ClassMinters, Contract, Error, MIN_TTL};

    const START: u64 = 10;

    fn registry() -> AccountId {
        AccountId::new_unchecked("registry.near".to_string())
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("sbt.near".to_string())
    }

    fn auth(i: u8) -> AccountId {
        AccountId::new_unchecked(format!("authority{}.near", i))
    }

    fn contract_metadata() -> ContractMetadata {
        ContractMetadata {
            spec: "community-sbt-0.0.1".to_string(),
            name: "community-sbt".to_string(),
            symbol: "COMMUNITY_SBT".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn class_minter(requires_iah: bool, minters: Vec<AccountId>, max_ttl: u64) -> ClassMinters {
        ClassMinters {
            admins: vec![admin()],
            requires_iah,
            minters,
            max_ttl,
        }
    }

    fn class_metadata(c: ClassId) -> ClassMetadata {
        ClassMetadata {
            name: format!("cls-{}", c),
            symbol: None,
            icon: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn setup(predecessor: &AccountId, deposit: Option<Balance>) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(admin())
            .block_timestamp(START)
            .is_view(false)
            .build();
        ctx.attached_deposit = deposit.unwrap_or(mint_deposit(1));
        testing_env!(ctx.clone());
        let mut ctr = Contract::new(registry(), contract_metadata());
        let c = ctr.acquire_next_class(true, vec![auth(1)], MIN_TTL, class_metadata(1), None);
        assert_eq!(c, 1);
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        (ctx, ctr)
    }

    #[test]
    fn class_info() -> Result<(), Error> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let expect_not_authorized = |cls, ctr: &Contract| match ctr.class_info_minter(cls) {
            Err(Error::NotMinter) => (),
            x => panic!("expected NotAuthorized for cls {}, got: {:?}", cls, x),
        };

        ctr.class_info_minter(1)?; // admin can mint

        let cls2 = ctr.acquire_next_class(true, vec![auth(2)], MIN_TTL, class_metadata(2), None);
        let cls3 = ctr.acquire_next_class(true, vec![auth(10)], MIN_TTL, class_metadata(3), None);
        ctr.add_minters(cls2, vec![auth(3)], None)?;

        ctr.class_info_minter(cls2)?; // admin can mint

        // authority(1) is a default minter for class 1 in the test setup
        ctx.predecessor_account_id = auth(1);
        testing_env!(ctx.clone());
        ctr.class_info_minter(1)?;
        expect_not_authorized(cls2, &ctr);
        expect_not_authorized(cls3, &ctr);
        match ctr.class_info_minter(1122) {
            Err(Error::ClassNotFound) => (),
            x => panic!("expected ClassNotEnabled, got: {:?}", x),
        };

        // check authority(2)
        ctx.predecessor_account_id = auth(2);
        testing_env!(ctx);
        expect_not_authorized(1, &ctr);
        ctr.class_info_minter(cls2)?;
        expect_not_authorized(cls3, &ctr);

        Ok(())
    }

    #[test]
    fn add_minter() -> Result<(), Error> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        // class not found
        matches!(
            ctr.add_minters(2, vec![auth(2)], None),
            Err(Error::ClassNotFound)
        );

        assert_eq!(ctr.sbt_class_metadata(1), Some(class_metadata(1)));
        assert_eq!(ctr.sbt_class_metadata(0), None);
        assert_eq!(ctr.sbt_class_metadata(2), None);
        assert_eq!(ctr.sbt_class_metadata(322), None);

        assert_eq!(ctr.class_minter(0), None);
        assert_eq!(ctr.class_minter(2), None);
        assert_eq!(ctr.class_minter(2415), None);

        let cls = ctr.acquire_next_class(false, vec![auth(4)], MIN_TTL, class_metadata(2), None);
        assert_eq!(cls, 2);
        assert_eq!(ctr.next_class, cls + 1);
        let cls = ctr.acquire_next_class(false, vec![auth(4)], MIN_TTL, class_metadata(3), None);
        assert_eq!(cls, 3);
        assert_eq!(ctr.next_class, 4);

        ctr.add_minters(1, vec![auth(2)], None)?;
        ctr.add_minters(2, vec![auth(2), auth(2)], None)?;

        // verify class minters
        assert_eq!(
            ctr.class_minter(1),
            Some(class_minter(true, vec![auth(1), auth(2)], MIN_TTL))
        );
        assert_eq!(
            ctr.class_minter(2),
            Some(class_minter(false, vec![auth(4), auth(2)], MIN_TTL))
        );
        assert_eq!(
            ctr.class_minter(3),
            Some(class_minter(false, vec![auth(4)], MIN_TTL))
        );
        assert_eq!(ctr.class_minter(4), None);

        // verify class metadata
        assert_eq!(ctr.sbt_class_metadata(1), Some(class_metadata(1)));
        assert_eq!(ctr.sbt_class_metadata(2), Some(class_metadata(2)));
        assert_eq!(ctr.sbt_class_metadata(3), Some(class_metadata(3)));
        assert_eq!(ctr.class_minter(0), None);
        assert_eq!(ctr.class_minter(4), None);
        assert_eq!(ctr.class_minter(5), None);
        assert_eq!(ctr.class_minter(2412), None);

        // not an admin
        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());
        matches!(
            ctr.add_minters(1, vec![auth(200)], None),
            Err(Error::NotAdmin)
        );

        ctx.predecessor_account_id = auth(1);
        testing_env!(ctx.clone());
        matches!(
            ctr.add_minters(1, vec![auth(200)], None),
            Err(Error::NotAdmin)
        );

        Ok(())
    }

    #[test]
    fn remove_minter() -> Result<(), Error> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        matches!(
            ctr.remove_minters(2, vec! {auth(1)}, None),
            Err(Error::ClassNotFound)
        );

        ctr.acquire_next_class(false, vec![auth(3)], MIN_TTL, class_metadata(2), None);

        ctr.add_minters(1, vec![auth(2), auth(3), auth(4)], None)?;
        ctr.add_minters(2, vec![auth(2)], None)?;

        ctr.remove_minters(1, vec![auth(2)], None)?;

        assert_eq!(
            ctr.class_minter(1),
            Some(class_minter(true, vec![auth(1), auth(4), auth(3)], MIN_TTL))
        );
        assert_eq!(
            ctr.class_minter(2),
            Some(class_minter(false, vec![auth(3), auth(2)], MIN_TTL))
        );

        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());
        matches!(
            ctr.remove_minters(1, vec![auth(1)], None),
            Err(Error::NotAdmin)
        );

        Ok(())
    }

    fn mk_meteadata(class: ClassId) -> TokenMetadata {
        TokenMetadata {
            class,
            issued_at: None,
            expires_at: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn mint() -> Result<(), Error> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let cls2 = ctr.acquire_next_class(true, vec![auth(2)], MIN_TTL, class_metadata(2), None);

        ctx.predecessor_account_id = auth(1);
        testing_env!(ctx);

        ctr.sbt_mint(alice(), mk_meteadata(1), None)?;
        match ctr.sbt_mint(alice(), mk_meteadata(cls2), None) {
            Err(Error::NotMinter) => (),
            Ok(_) => panic!("expected NotAuthorized, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        match ctr.sbt_mint(alice(), mk_meteadata(1122), None) {
            Err(Error::ClassNotFound) => (),
            Ok(_) => panic!("expected ClassNotEnabled, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        Ok(())
    }

    #[test]
    #[should_panic(expected = "ttl must be smaller or equal than 1ms")]
    fn assert_ttl() {
        let (_, ctr) = setup(&admin(), None);
        ctr.assert_ttl(10, 1);
    }

    #[test]
    #[should_panic(expected = "caller must be a minter")]
    fn assert_minter() {
        let (_, ctr) = setup(&admin(), None);
        ctr.assert_minter(&alice(), &vec![bob()]);
    }

    #[test]
    fn mint_many() -> Result<(), Error> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let cls2 = ctr.acquire_next_class(true, vec![auth(1)], MIN_TTL, class_metadata(2), None);
        let cls3 = ctr.acquire_next_class(true, vec![auth(2)], MIN_TTL, class_metadata(3), None);

        ctx.predecessor_account_id = auth(1);
        testing_env!(ctx.clone());

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
            ],
            None,
        ) {
            Err(Error::RequiredDeposit(36000000000000000000000)) => (),
            Ok(_) => panic!("expected RequiredDeposit, got: Ok"),
            Err(x) => panic!("expected RequiredDeposit, got: {:?}", x),
        };

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls3)]),
            ],
            None,
        ) {
            Err(Error::NotMinter) => (),
            Ok(_) => panic!("expected NotAuthorized, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1122), mk_meteadata(cls2)]),
            ],
            None,
        ) {
            Err(Error::ClassNotFound) => (),
            Ok(_) => panic!("expected ClassNotEnabled, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        ctx.attached_deposit = 19000000000000000000000;
        testing_env!(ctx.clone());
        ctr.sbt_mint_many(
            vec![(alice(), vec![mk_meteadata(1), mk_meteadata(cls2)])],
            None,
        )?;

        // deposit increases because we are minting more tokens
        ctx.attached_deposit = 37000000000000000000000;
        testing_env!(ctx);
        ctr.sbt_mint_many(
            vec![
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (carol(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
            ],
            None,
        )?;

        Ok(())
    }

    #[test]
    fn assert_admin() {
        let (mut ctx, ctr) = setup(&admin(), None);

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        matches!(ctr.class_info_admin(1), Err(Error::NotAdmin));
    }
}

'''
'''--- contracts/community-open/src/migrate.rs ---
use crate::*;

// community-open/v1.0.0 structs

#[derive(BorshDeserialize)]
pub struct OldContract {
    pub classes: LookupMap<ClassId, ClassMinters>,
    pub next_class: ClassId,
    pub registry: AccountId,
    pub metadata: LazyOption<ContractMetadata>,
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
    pub registration_cost: u64,
}

// migration to community-open/v...
#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldContract = env::state_read().expect("can't deserialize contract");

        // changed fields:
        // -

        Self {
            classes: old_state.classes,
            next_class: old_state.next_class,
            registry: old_state.registry,
            metadata: old_state.metadata,
            class_metadata: old_state.class_metadata,
            registration_cost: old_state.registration_cost,
        }
    }
}

'''
'''--- contracts/community-open/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, BorshStorageKey};

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Admins, // deprecated, required for migration
    ContractMetadata,
    MintingAuthority,
    ClassMetadata,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ClassMinters {
    /// if true only iah verifed accounts can obrain the SBT
    pub requires_iah: bool,
    /// admin is an account that can mint and change the admin and minter list.
    pub admins: Vec<AccountId>,
    /// accounts allowed to mint the SBT
    pub minters: Vec<AccountId>,
    /// time to live in ms. Overwrites metadata.expire_at.
    pub max_ttl: u64,
    // TODO handle "dynamic" storage
}

'''
'''--- contracts/community-open/tests/workspaces.rs ---
use anyhow::Ok;
use near_units::parse_near;
use near_workspaces::{network::Sandbox, Account, AccountId, Contract, Worker};
use sbt::{ClassMetadata, Token, TokenMetadata};
use serde_json::json;

const MAINNET_REGISTRY_ID: &str = "registry-v1.gwg-testing.near";
const MAINNET_COMMUNITY_SBT_ID: &str = "community.i-am-human.near";

async fn init(
    worker: &Worker<Sandbox>,
    migration: bool,
) -> anyhow::Result<(Account, Account, Contract, Account, Account)> {
    let registry_contract: Contract;
    let community_contract: Contract;
    if migration {
        // import the registry contract from mainnet
        let worker_mainnet = near_workspaces::mainnet().await?;
        let contract_id: AccountId = MAINNET_REGISTRY_ID.parse()?;
        registry_contract = worker
            .import_contract(&contract_id, &worker_mainnet)
            .initial_balance(parse_near!("10000000 N"))
            .transact()
            .await?;

        // import the community-sbt contract from mainnet
        let contract_id: AccountId = MAINNET_COMMUNITY_SBT_ID.parse()?;
        community_contract = worker
            .import_contract(&contract_id, &worker_mainnet)
            .initial_balance(parse_near!("10000000 N"))
            .transact()
            .await?;
    } else {
        registry_contract = worker
            .dev_deploy(include_bytes!("../../res/registry.wasm"))
            .await?;
        community_contract = worker
            .dev_deploy(include_bytes!("../../res/community_sbt.wasm"))
            .await?;
    }

    let registry_mainnet = registry_contract.as_account();
    let community_mainnet = community_contract.as_account();
    let authority = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;
    let minter = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;

    // init the registry
    let res = registry_contract
        .call("new")
        .args_json(json!({"authority": authority.id(),
                          "iah_issuer": iah_issuer.id(), "iah_classes": [1],
                          "authorized_flaggers": vec![auth_flagger.id()] }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // init the community-sbt
    let res = community_contract
        .call("new")
        .args_json(
            json!({"registry": registry_mainnet.id(), "admin": authority.id(), "metadata": {
            "spec": "sbt-1.0.0",
            "name": "Community SBT",
            "symbol": "CoSBT"
          }, "ttl": 2147483647 }),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // add iah_issuer
    let res = authority
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": iah_issuer.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // add community_issuer
    let res = authority
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": community_mainnet.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    if migration {
        // authorize authority to mint tokens
        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-1".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());
    } else {
        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-1".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());

        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-2".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());
    }

    // mint mocked community tokens
    let token_metadata = TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: None,
        reference: None,
        reference_hash: None,
    };

    let res = minter
        .call(community_mainnet.id(), "sbt_mint")
        .args_json(json!({"receiver": alice.id(), "metadata": token_metadata, "memo": "test"}))
        .deposit(parse_near!("0.01 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    let res = minter
        .call(community_mainnet.id(), "sbt_mint")
        .args_json(json!({"receiver": bob.id(), "metadata": token_metadata, "memo": "test"}))
        .deposit(parse_near!("0.01 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok((
        registry_mainnet.clone(),
        community_mainnet.clone(),
        community_contract,
        authority.clone(),
        minter.clone(),
    ))
}

#[ignore = "This test is not valid after the migration"]
#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (_, community_sbt, _, admin, _) = init(&worker, true).await?;

    // deploy the new contract
    let new_community_contract = community_sbt
        .deploy(include_bytes!("../../res/community_sbt.wasm"))
        .await?
        .into_result()?;

    // call the migrate method
    let res = new_community_contract
        .call("migrate")
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // call the migration again should fail
    let res = new_community_contract
        .call("migrate")
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    // call the contract after the migration
    let res: AccountId = new_community_contract
        .call("registry")
        .max_gas()
        .transact()
        .await?
        .json()?;
    let expected_res: AccountId = "registry-v1.gwg-testing.near".parse().unwrap();
    assert_eq!(expected_res, res);

    // change admin list
    let res = admin
        .call(new_community_contract.as_account().id(), "set_admin_list")
        .args_json(json!({"new_admin_list": ["test.near", admin.id()]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    Ok(())
}

#[tokio::test]
async fn sbt_renew() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    let sbt1_ttl_before_renew = sbts[0].as_ref().unwrap().metadata.expires_at.unwrap();
    let sbt2_ttl_before_renew = sbts[1].as_ref().unwrap().metadata.expires_at.unwrap();

    let res = minter
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [1,2], "ttl": 100000000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // check if the renew updated the ttl
    assert!(sbts[0].as_ref().unwrap().metadata.expires_at.unwrap() > sbt1_ttl_before_renew);
    assert!(sbts[1].as_ref().unwrap().metadata.expires_at.unwrap() > sbt2_ttl_before_renew);

    // renew non existing tokens
    let res = minter
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [3,4], "ttl": 200000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_renew_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, _) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    let sbt1_ttl_before_renew = sbts[0].as_ref().unwrap().metadata.expires_at.unwrap();
    let sbt2_ttl_before_renew = sbts[1].as_ref().unwrap().metadata.expires_at.unwrap();

    // should fail since the admin is not a minter
    let res = admin
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [1,2], "ttl": 100000000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // check if the ttl is still the same
    assert_eq!(
        sbts[0].as_ref().unwrap().metadata.expires_at.unwrap(),
        sbt1_ttl_before_renew
    );
    assert_eq!(
        sbts[1].as_ref().unwrap().metadata.expires_at.unwrap(),
        sbt2_ttl_before_renew
    );

    // renew non existing tokens
    let res = admin
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [3,4], "ttl": 200000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_revoke() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    // Should pass since community_sbt is minter
    let res = minter
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [1,2], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_none());
    assert!(sbts[1].is_none());

    // revoke non existing tokens
    let res = admin
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [3,4], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_revoke_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, _) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    // should fail since the admin is not a minter
    let res = admin
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [1,2], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    Ok(())
}

#[tokio::test]
async fn sbt_mint_many() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let bob = worker.dev_create_account().await?;
    let charlie = worker.dev_create_account().await?;

    let supply: u64 = admin
        .call(registry.id(), "sbt_supply")
        .args_json(json!({"issuer": community_sbt.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, 2);

    let token_metadata = vec![
        TokenMetadata {
            class: 1,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
        TokenMetadata {
            class: 2,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
    ];

    // sbt_mint_many
    let res = minter
        .call(community_sbt.id(), "sbt_mint_many")
        .args_json(json!({
            "token_spec":
                vec![
                    (bob.id(), token_metadata.clone()),
                    (charlie.id(), token_metadata),
                ]
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let supply: u64 = admin
        .call(registry.id(), "sbt_supply")
        .args_json(json!({"issuer": community_sbt.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, 6);

    Ok(())
}

'''
'''--- contracts/community-sbt/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>
-->

# CHANGELOG: Community SBT

## Unreleased

### Features

### Breaking Changes

### Bug Fixes

## v5.0.0 (2024-01-25)

### Breaking Changes

- The registry method `sbt_revoke_by_owner` now returns `boolean` indicating if all the tokens were revoked. `true` if all the tokens were revoked successfully or `false` if not and the method needs to be called again.
- `class_metadata` has been renamed to `sbt_class_metadata` to unify the SBT Issuer interface.

## v4.3.0 (2023-09-07)

### Features

- Added support for multiple admins authorized to manage issuers.

### Breaking Changes

- Contract field type for `admin` changed from `AccoundId` -> `LazyOption<Vec<AccountId>>`
- Recommended `cost.mint_deposit` is decreased by 0.001 miliNEAR (in total).

## v4.2.0 (2023-08-25)

The release introduces more class level customizations.

### Features

- Admin can set `max_ttl` per class rather than per contract.
- Allow minters to revoke tokens (previously, only contract admin DAO could do that).
- Allows minters to define class level metadata. So, now you can set meatadata for the whole issuer (contract), class and for every token. Class common stuff (like icons) should go on the class metadata level.
- New sbt_mint_many function allowing minter DAO to mint many tokens at once.

### Deployments

- `community.i-am-human.near`: tx: `6NEz1NASdExWF5wRzwiAHoHkCxWctgK96rJPGFHgoQz5`, migration: `Z8cH2vFT229av5z28xpFiX8wPZcx6N1UZs3fyFfwPLy`

'''
'''--- contracts/community-sbt/Cargo.toml ---
[package]
name = "community-sbt"
version = "5.0.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

cost = { path = "../cost" }
sbt = { path = "../sbt" }

[dev-dependencies]
pretty_assertions.workspace = true
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
tracing.workspace = true

'''
'''--- contracts/community-sbt/README.md ---
# Proof of concept for Community SBT

Based on SBT NEP: https://github.com/near/NEPs/pull/393. Early Design: https://hackmd.io/ZvgUeoF4SMGM4InswH0Dsg

This is a permissioned version of the [Community Open](../community-open/README.md) contract: only contract admins can acquire a new class and designate minters.

See root [README](../../README.md#testnet) for deployed smart contract addresses.

## Usage

Community SBT contract is designed for a communities with authority.
The contract is an SBT issuer and allows admins to acquire new classes and set minters to mint new SBTs. The class restriction is implemented in the `sbt_mint` function.

The SBT minting and revoking can be only executed by an account which has _Minting Authority_, hence ideally, minter should be a DAO. Minting Authorities are set per class ID. Each class ID can has one more minter.

Only contract admin can add or revoke minting authority.

#### TTL

Time To Live (TTL) is a duration in milliseconds used to define token expire time: `expires_at = now + ttl`.
Every token class has its own `MAX_TTL` value which is being set when enabling new class for minting.
The `max_ttl` value can be changed by an admin by calling the `set_max_ttl` method.

#### SBT classes

SBT contract supports multiple token classes: one issuer can mint tokens of many classes.
The `community-sbt` contract requires an admin to enable a token class and set if minting of SBT of that class requires IAH humanity check. Moreover, admin must assign a minting authority (an address which is authorized to mint).

```shell
near call CTR_ADDRESS enable_next_class \
  '{"requires_iah": true, "minter": MINTER_ADDRESS}' --accountId ADMIN
```

Contract admin should set the [class metadata](https://github.com/near/NEPs/blob/master/neps/nep-0393.md#smart-contract-interface) using:

```shell
near call CTR_ADDRESS set_class_metadata \
  '{"class": ClassId, "metadata": "Metadata JSON"}' --accountId ADMIN
```

And anyone can query the class metadata:

```shell
near view CTR_ADDRESS class_metadata '{"class": ClassId}'
```

#### Minting

The mint function requires a deposit which is computed by the [`required_sbt_mint_deposit`](https://github.com/alpha-fi/i-am-human/blob/master/contracts/community-sbt/src/lib.rs#L158) function. The whole deposit is passed to the registry to cover the storage costs.
Metadata attributes:

- `expires_at` is be overwritten to `now + ttl`.
- `issued_at` is be overwritten to "now".
- `reference` and `reference_hash` are optional - it should be related to token characteristics. See [memo and metadata](#memo-and-metadata) guidelines.

```shell
near call CTR_ADDRESS sbt_mint \
  '{"receiver": "receipient.near",
    "metadata": {"class": 1, "reference": "link to token characteristics"},
    "memo": "optional operation info"}'  \
  --deposit 0.01 --accountId MINTER
```

It is also possible to mint few tokens at once. In the example below, `recipient1` will get 1 token, `recipient2` will get 3 tokens. Note that one account can have at most one token of a give class (SBT standard doesn't allow one account to hold more than one token of the same class).

```shell
near call CTR_ADDRESS sbt_mint_many \
  '{"token_spec": [
       ["receipient1.near",
        [{"class": 1, "reference": "token1 ref"}]],
       ["receipient2.near",
        [{"class": 1, "reference": "token2 ref"}, {"class": 2, "reference": "token3 ref"}, {"class": 3, "reference": "token4 ref"}]]
    ],
    "memo": "optional operation info"}'  \
  --deposit 0.04 --gas 100000000000000 --accountId MINTER
```

To query minting authorities of a given class call:

```shell
near view CTR_ADDRESS minting_authorities \
  '{"class": CLASS_ID}'
```

### Memo and Metadata

Guidelines for using metadata and minting memo field.

Both `sbt_mint` and `sbt_mint_many` provide an optional `memo` argument which should be used as a reference for minting (operation data), usually a justification for a minting or a link to a Near Social post for justification. `memo` is not going to be recorded in the token.

If you want to record extra data to the token, then you should set it as a token `metadata.reference` (usually a JSON or a link to a JSON document). That should be related to a token, hence be a part of the token characteristic rather then the mint operation.

There is also contract metadata and class metadata - both are managed by the contract admin.

- [Contract Metadata](https://github.com/alpha-fi/i-am-human/blob/master/contracts/sbt/src/metadata.rs) should describe the contract and the issuer as well as common data to all token classes.
- [Class Metadata](https://github.com/alpha-fi/i-am-human/blob/master/contracts/sbt/src/metadata.rs) should describe the class and all common data for all tokens of that class. For example, token characteristics shared by all tokens of a given class should be set in the class metadata, rather than copied over all token metadata. Examples include icon, symbol etc...

'''
'''--- contracts/community-sbt/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::FunctionError;

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum MintError {
    NotMinter,
    RequiredDeposit(u128),
    ClassNotEnabled,
}

impl FunctionError for MintError {
    fn panic(&self) -> ! {
        match self {
            MintError::NotMinter => panic_str("not authorized to mint"),
            MintError::RequiredDeposit(min_deposit) => {
                panic_str(&format!("deposit must be at least {}yN", min_deposit))
            }
            MintError::ClassNotEnabled => panic_str("class not enabled"),
        }
    }
}

'''
'''--- contracts/community-sbt/src/lib.rs ---
use std::collections::HashMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault, Promise};

use cost::{calculate_iah_mint_gas, calculate_mint_gas, mint_deposit};
use sbt::*;

pub use crate::errors::*;
pub use crate::storage::*;

mod errors;
pub mod migrate;
mod storage;

const MIN_TTL: u64 = 86_400_000; // 24 hours in miliseconds

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Accounts authorized to add new minting authority
    pub admins: LazyOption<Vec<AccountId>>,
    /// map of classId -> to set of accounts authorized to mint
    pub classes: LookupMap<ClassId, ClassMinters>,
    pub next_class: ClassId,
    /// SBT registry.
    pub registry: AccountId,
    /// contract metadata
    pub metadata: LazyOption<ContractMetadata>,
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    /// @admin: account authorized to add new minting authority
    #[init]
    pub fn new(registry: AccountId, admin: AccountId, metadata: ContractMetadata) -> Self {
        Self {
            admins: LazyOption::new(StorageKey::Admins, Some(&vec![admin])),
            classes: LookupMap::new(StorageKey::MintingAuthority),
            next_class: 1,
            registry,
            metadata: LazyOption::new(StorageKey::ContractMetadata, Some(&metadata)),
            class_metadata: LookupMap::new(StorageKey::ClassMetadata),
        }
    }

    /**********
     * QUERIES
     **********/

    /// Returns minting authorities by class. Returns none if the class is not enabled.
    pub fn class_minter(&self, class: ClassId) -> Option<ClassMinters> {
        self.classes.get(&class)
    }

    /// Returns registry address.
    pub fn registry(&self) -> AccountId {
        self.registry.clone()
    }

    /**********
     * Transactions
     **********/

    /// Mints a new SBT for the given receiver.
    /// If `metadata.expires_at` is None then we set it to max: ` now+max_ttl`.
    /// Panics if `metadata.expires_at > now+max_ttl` or when ClassID is not set or not 1.
    #[payable]
    #[handle_result]
    pub fn sbt_mint(
        &mut self,
        receiver: AccountId,
        #[allow(unused_mut)] mut metadata: TokenMetadata,
        memo: Option<String>,
    ) -> Result<Promise, MintError> {
        let token_spec = vec![(receiver, vec![metadata])];
        self.sbt_mint_many(token_spec, memo)
    }

    /// Similar to `sbt_mint`, but allows to mint many tokens at once. See `sbt_mint` doc for
    /// more details.
    /// * `tokens` is list of pairs: token recipient and token metadata to mint for given recipient.
    #[payable]
    #[handle_result]
    pub fn sbt_mint_many(
        &mut self,
        #[allow(unused_mut)] mut token_spec: Vec<(AccountId, Vec<TokenMetadata>)>,
        memo: Option<String>,
    ) -> Result<Promise, MintError> {
        let now_ms = env::block_timestamp_ms();
        let mut requires_iah = false;
        let mut class_info_map: HashMap<ClassId, (bool, u64)> = HashMap::new();
        let mut total_len = 0;
        for (_, token_metadatas) in &mut token_spec {
            total_len += token_metadatas.len();
            for m in token_metadatas {
                let (cls_requires_iah, ttl) = match class_info_map.get(&m.class) {
                    Some(ci) => (ci.0, ci.1),
                    None => {
                        let ci = self.class_info_minter(m.class)?;
                        class_info_map.insert(m.class, ci);
                        ci
                    }
                };
                requires_iah = requires_iah || cls_requires_iah;
                m.expires_at = Some(now_ms + ttl);
                m.issued_at = Some(now_ms);
            }
        }

        let required_deposit = mint_deposit(total_len);
        let attached_deposit = env::attached_deposit();
        if attached_deposit < required_deposit {
            return Err(MintError::RequiredDeposit(required_deposit));
        }

        if let Some(memo) = memo {
            env::log_str(&format!("SBT mint memo: {}", memo));
        }

        let sbt_reg =
            ext_registry::ext(self.registry.clone()).with_attached_deposit(attached_deposit);
        let promise = if requires_iah {
            let gas = calculate_iah_mint_gas(total_len, token_spec.len());
            sbt_reg.with_static_gas(gas).sbt_mint_iah(token_spec)
        } else {
            sbt_reg
                .with_static_gas(calculate_mint_gas(total_len))
                .sbt_mint(token_spec)
        };

        Ok(promise)
    }

    /// Updates the expire time of provided tokens.
    /// `ttl` is duration in milliseconds to set expire time: `now+ttl`.
    /// Panics if `ttl > self.minters[class].max_ttl` or ttl < `MIN_TTL` or `tokens` is an empty list.
    /// Only minters are allowed to renew the tokens.
    pub fn sbt_renew(&mut self, tokens: Vec<TokenId>, ttl: u64, memo: Option<String>) -> Promise {
        require!(!tokens.is_empty(), "tokens must be a non empty list");
        let caller = env::predecessor_account_id();
        let ctr = env::current_account_id();
        ext_registry::ext(self.registry.clone())
            .sbt_classes(ctr.clone(), tokens.clone())
            .then(Self::ext(ctr).on_sbt_renew_callback(&caller, tokens, ttl, memo))
    }

    /// Callback for sbt_renew. Checks the return value from `sbts` and if any of the tokens
    /// does not exist, the ttl value is invalid or the caller is not a minter panics.
    #[private]
    pub fn on_sbt_renew_callback(
        &self,
        caller: &AccountId,
        tokens: Vec<TokenId>,
        ttl: u64,
        memo: Option<String>,
        #[callback_result] token_classes: Result<Vec<Option<ClassId>>, near_sdk::PromiseError>,
    ) -> Promise {
        let ts = token_classes.expect("error while retrieving tokens data from registry");
        let mut cached_class_info: HashMap<u64, (Vec<AccountId>, u64)> = HashMap::new();
        for token_class in ts {
            let max_ttl: u64;
            let class_id: u64 = token_class.expect("token not found");
            if let Some((cached_minters, cached_ttl)) = cached_class_info.get(&class_id) {
                max_ttl = *cached_ttl;
                self.assert_minter(caller, cached_minters);
            } else {
                max_ttl = self.get_ttl(class_id);
                let minters = self
                    .class_minter(class_id)
                    .expect("class not found")
                    .minters;
                self.assert_minter(caller, &minters);
                cached_class_info.insert(class_id, (minters, max_ttl));
            }
            self.assert_ttl(ttl, max_ttl);
        }
        if let Some(memo) = memo {
            env::log_str(&format!("SBT renew memo: {}", memo));
        }

        let expires_at_ms = env::block_timestamp_ms() + ttl;
        ext_registry::ext(self.registry.clone()).sbt_renew(tokens, expires_at_ms)
    }

    /// Revokes list of tokens. If `burn==true`, the tokens are burned (removed). Otherwise,
    /// the token expire_at is set to now, making the token expired. See `registry.sbt_revoke`
    /// for more details.
    /// Only class minters are allowed to revoke tokens
    pub fn sbt_revoke(
        &mut self,
        tokens: Vec<TokenId>,
        burn: bool,
        memo: Option<String>,
    ) -> Promise {
        require!(!tokens.is_empty(), "tokens must be a non empty list");
        let caller = env::predecessor_account_id();
        let ctr = env::current_account_id();
        ext_registry::ext(self.registry.clone())
            .sbt_classes(ctr.clone(), tokens.clone())
            .then(Self::ext(ctr).on_sbt_revoke_callback(&caller, tokens, burn, memo))
    }

    /// sbt_revoke callback. Checks if all the the tokens can be revoked by the caller
    /// based on the return value from registry.sbts. If not panics with a error message
    #[private]
    pub fn on_sbt_revoke_callback(
        &self,
        caller: &AccountId,
        tokens: Vec<TokenId>,
        burn: bool,
        memo: Option<String>,
        #[callback_result] token_classes: Result<Vec<Option<ClassId>>, near_sdk::PromiseError>,
    ) -> Promise {
        let ts = token_classes.expect("error while retrieving tokens data from registry");
        let mut cached_class_minters: HashMap<u64, Vec<AccountId>> = HashMap::new();
        for token_class in ts {
            let class_id: u64 = token_class.expect("token not found");
            if let Some(cached_minter) = cached_class_minters.get(&class_id) {
                self.assert_minter(caller, cached_minter);
            } else {
                let minters = self
                    .class_minter(class_id)
                    .expect("class not found")
                    .minters;
                self.assert_minter(caller, &minters);
                cached_class_minters.insert(class_id, minters);
            }
        }
        if let Some(memo) = memo {
            env::log_str(&format!("SBT revoke memo: {}", memo));
        }
        ext_registry::ext(self.registry.clone()).sbt_revoke(tokens, burn)
    }

    /// Admin: remove SBT from the given accounts.
    /// Panics if `accounts` is an empty list.
    pub fn revoke_for(
        &mut self,
        accounts: Vec<AccountId>,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        self.assert_admin();
        require!(!accounts.is_empty(), "accounts must be a non empty list");
        env::panic_str("not implemented");
        // todo: requires registry update.
        // let mut tokens = Vec::with_capacity(accounts.len());
        // for a in accounts {
        //     tokens.push(t);
        // }
        // if !tokens.is_empty() {
        //     SbtTokensEvent { tokens, memo }.emit_revoke();
        // }
    }

    /**********
     * Admin
     **********/

    /// Allows admin to change if the specific class requires IAH verification.
    /// Panics if class is not found.
    pub fn set_requires_iah(&mut self, class: ClassId, requires_iah: bool) {
        self.assert_admin();
        let mut c = self.classes.get(&class).expect("class not found");
        if c.requires_iah != requires_iah {
            c.requires_iah = requires_iah;
            self.classes.insert(&class, &c);
        }
    }

    /// Allows admin to change Max TTL, expected time duration in miliseconds.
    pub fn set_max_ttl(&mut self, class: ClassId, max_ttl: u64) {
        self.assert_admin();
        let mut cm = self.classes.get(&class).expect("class not found");
        cm.max_ttl = max_ttl;
        self.classes.insert(&class, &cm);
    }

    /// Allows admin to update class metadata.
    /// Panics if class is not enabled.
    pub fn set_sbt_class_metadata(&mut self, class: ClassId, metadata: ClassMetadata) {
        self.assert_admin();
        require!(class < self.next_class, "class not found");
        self.class_metadata.insert(&class, &metadata);
    }

    /// Enables a new, unused class and authorizes minter to issue SBTs of that class.
    /// Returns the new class ID.
    pub fn enable_next_class(
        &mut self,
        requires_iah: bool,
        minter: AccountId,
        max_ttl: u64,
        metadata: ClassMetadata,
        #[allow(unused_variables)] memo: Option<String>,
    ) -> ClassId {
        self.assert_admin();
        require!(
            MIN_TTL <= max_ttl,
            format!("ttl must be at least {}ms", MIN_TTL)
        );
        let cls = self.next_class;
        self.next_class += 1;
        self.classes.insert(
            &cls,
            &ClassMinters {
                requires_iah,
                minters: vec![minter],
                max_ttl,
            },
        );
        self.class_metadata.insert(&cls, &metadata);
        cls
    }

    /// Admin: authorize `minter` to mint tokens of a `class`.
    /// Must be called by admin, panics otherwise.
    pub fn authorize(
        &mut self,
        class: ClassId,
        minter: AccountId,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        self.assert_admin();
        let mut c = self.classes.get(&class).expect("class not found");
        if !c.minters.contains(&minter) {
            c.minters.push(minter);
            self.classes.insert(&class, &c);
        }
    }

    /// admin: revokes `class` minting for `minter`.
    /// Must be called by admin, panics otherwise.
    pub fn unauthorize(
        &mut self,
        class: ClassId,
        minter: AccountId,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        self.assert_admin();
        let mut c = self.classes.get(&class).expect("class not found");
        if let Some(idx) = c.minters.iter().position(|x| x == &minter) {
            c.minters.swap_remove(idx);
            self.classes.insert(&class, &c);
        }
    }

    pub fn set_admin_list(&mut self, new_admin_list: Vec<AccountId>) {
        self.assert_admin();
        self.admins.set(&new_admin_list);
    }

    /// admin: authorize `minter` to mint tokens of a `class`.
    /// Must be called by admin, panics otherwise.
    pub fn update_metadata(&mut self, metadata: ContractMetadata) {
        self.assert_admin();
        self.metadata.replace(&metadata);
    }

    /**********
     * INTERNAL
     **********/

    fn assert_admin(&self) {
        if let Some(admins) = self.admins.get() {
            require!(
                admins.contains(&env::predecessor_account_id()),
                "not an admin"
            );
        } else {
            env::panic_str("admins list not found");
        }
    }

    /// Returns (requires_iah, max_ttl).
    /// Returns error if class is not found  or not called by a minter.
    fn class_info_minter(&self, class: ClassId) -> Result<(bool, u64), MintError> {
        match self.class_minter(class) {
            None => Err(MintError::ClassNotEnabled),
            Some(cm) => {
                if cm.minters.contains(&env::predecessor_account_id()) {
                    Ok((cm.requires_iah, cm.max_ttl))
                } else {
                    Err(MintError::NotMinter)
                }
            }
        }
    }

    /// returns ttl for a given token class
    fn get_ttl(&self, class: ClassId) -> u64 {
        match self.class_minter(class) {
            None => panic!("class not found"),
            Some(cm) => cm.max_ttl,
        }
    }

    fn assert_ttl(&self, ttl: u64, max_ttl: u64) {
        require!(
            ttl <= max_ttl,
            format!("ttl must be smaller or equal than {}ms", max_ttl)
        );
    }

    fn assert_minter(&self, caller: &AccountId, minters: &Vec<AccountId>) {
        require!(minters.contains(caller), "caller must be a minter");
    }
}

#[near_bindgen]
impl SBTIssuer for Contract {
    fn sbt_metadata(&self) -> ContractMetadata {
        self.metadata.get().unwrap()
    }

    /// Returns `ClassMetadata` by class. Returns none if the class is not enabled.
    fn sbt_class_metadata(&self, class: ClassId) -> Option<ClassMetadata> {
        self.class_metadata.get(&class)
    }
}

#[cfg(test)]
mod tests {
    use cost::mint_deposit;
    use near_sdk::{
        test_utils::{
            test_env::{alice, bob, carol},
            VMContextBuilder,
        },
        testing_env, AccountId, Balance, VMContext,
    };
    use sbt::{ClassId, ClassMetadata, ContractMetadata, SBTIssuer, TokenMetadata};

    use crate::{ClassMinters, Contract, MintError, MIN_TTL};

    const START: u64 = 10;

    fn registry() -> AccountId {
        AccountId::new_unchecked("registry.near".to_string())
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("sbt.near".to_string())
    }

    fn authority(i: u8) -> AccountId {
        AccountId::new_unchecked(format!("authority{}.near", i))
    }

    fn contract_metadata() -> ContractMetadata {
        ContractMetadata {
            spec: "community-sbt-0.0.1".to_string(),
            name: "community-sbt".to_string(),
            symbol: "COMMUNITY_SBT".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn class_minter(requires_iah: bool, minters: Vec<AccountId>, max_ttl: u64) -> ClassMinters {
        ClassMinters {
            requires_iah,
            minters,
            max_ttl,
        }
    }

    fn class_metadata(c: ClassId) -> ClassMetadata {
        ClassMetadata {
            name: format!("cls-{}", c),
            symbol: None,
            icon: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn setup(predecessor: &AccountId, deposit: Option<Balance>) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(admin())
            .block_timestamp(START)
            .is_view(false)
            .build();
        ctx.attached_deposit = deposit.unwrap_or(mint_deposit(1));
        testing_env!(ctx.clone());
        let mut ctr = Contract::new(registry(), admin(), contract_metadata());
        let c = ctr.enable_next_class(true, authority(1), MIN_TTL, class_metadata(1), None);
        assert_eq!(c, 1);
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        (ctx, ctr)
    }

    #[test]
    fn class_info() -> Result<(), MintError> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let expect_not_authorized = |cls, ctr: &Contract| match ctr.class_info_minter(cls) {
            Err(MintError::NotMinter) => (),
            x => panic!("expected NotAuthorized, got: {:?}", x),
        };

        // admin is not a minter
        expect_not_authorized(1, &ctr);

        let new_cls = ctr.enable_next_class(true, authority(2), MIN_TTL, class_metadata(2), None);
        let other_cls =
            ctr.enable_next_class(true, authority(10), MIN_TTL, class_metadata(3), None);
        ctr.authorize(new_cls, authority(3), None);

        match ctr.class_info_minter(new_cls) {
            Err(MintError::NotMinter) => (),
            x => panic!("admin should not be a minter of the new class, {:?}", x),
        };

        // authority(1) is a default minter for class 1 in the test setup
        ctx.predecessor_account_id = authority(1);
        testing_env!(ctx.clone());
        ctr.class_info_minter(1)?;
        expect_not_authorized(new_cls, &ctr);
        expect_not_authorized(other_cls, &ctr);
        match ctr.class_info_minter(1122) {
            Err(MintError::ClassNotEnabled) => (),
            x => panic!("expected ClassNotEnabled, got: {:?}", x),
        };

        // check authority(2)
        ctx.predecessor_account_id = authority(2);
        testing_env!(ctx);
        expect_not_authorized(1, &ctr);
        ctr.class_info_minter(new_cls)?;
        expect_not_authorized(other_cls, &ctr);

        Ok(())
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn authorize_only_admin() {
        let (_, mut ctr) = setup(&alice(), None);
        ctr.authorize(1, authority(2), None);
    }

    #[test]
    #[should_panic(expected = "class not found")]
    fn authorize_class_not_found() {
        let (_, mut ctr) = setup(&admin(), None);
        ctr.authorize(2, authority(2), None);
    }

    #[test]
    fn authorize() {
        let (_, mut ctr) = setup(&admin(), None);

        assert_eq!(ctr.sbt_class_metadata(1), Some(class_metadata(1)));
        assert_eq!(ctr.sbt_class_metadata(0), None);
        assert_eq!(ctr.sbt_class_metadata(2), None);
        assert_eq!(ctr.sbt_class_metadata(322), None);

        assert_eq!(ctr.class_minter(0), None);
        assert_eq!(ctr.class_minter(2), None);
        assert_eq!(ctr.class_minter(2415), None);

        let cls = ctr.enable_next_class(false, authority(4), MIN_TTL, class_metadata(2), None);
        assert_eq!(cls, 2);
        assert_eq!(ctr.next_class, cls + 1);
        let cls = ctr.enable_next_class(false, authority(4), MIN_TTL, class_metadata(3), None);
        assert_eq!(cls, 3);
        assert_eq!(ctr.next_class, 4);

        ctr.authorize(1, authority(2), None);
        ctr.authorize(1, authority(2), None);
        ctr.authorize(2, authority(2), None);

        // verify class minters
        assert_eq!(
            ctr.class_minter(1),
            Some(class_minter(
                true,
                vec![authority(1), authority(2)],
                MIN_TTL
            ))
        );
        assert_eq!(
            ctr.class_minter(2),
            Some(class_minter(
                false,
                vec![authority(4), authority(2)],
                MIN_TTL
            ))
        );
        assert_eq!(
            ctr.class_minter(3),
            Some(class_minter(false, vec![authority(4)], MIN_TTL))
        );
        assert_eq!(ctr.class_minter(4), None);

        // verify class metadata
        assert_eq!(ctr.sbt_class_metadata(1), Some(class_metadata(1)));
        assert_eq!(ctr.sbt_class_metadata(2), Some(class_metadata(2)));
        assert_eq!(ctr.sbt_class_metadata(3), Some(class_metadata(3)));
        assert_eq!(ctr.class_minter(0), None);
        assert_eq!(ctr.class_minter(4), None);
        assert_eq!(ctr.class_minter(5), None);
        assert_eq!(ctr.class_minter(2412), None);
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn unauthorize_only_admin() {
        let (_, mut ctr) = setup(&alice(), None);
        ctr.unauthorize(1, authority(1), None);
    }

    #[test]
    #[should_panic(expected = "class not found")]
    fn unauthorize_class_not_found() {
        let (_, mut ctr) = setup(&admin(), None);
        ctr.unauthorize(2, authority(1), None);
    }

    #[test]
    fn unauthorize() {
        let (_, mut ctr) = setup(&admin(), None);
        ctr.enable_next_class(false, authority(3), MIN_TTL, class_metadata(2), None);

        ctr.authorize(1, authority(2), None);
        ctr.authorize(1, authority(3), None);
        ctr.authorize(1, authority(4), None);
        ctr.authorize(2, authority(2), None);

        ctr.unauthorize(1, authority(2), None);

        assert_eq!(
            ctr.class_minter(1),
            Some(class_minter(
                true,
                vec![authority(1), authority(4), authority(3)],
                MIN_TTL
            ))
        );
        assert_eq!(
            ctr.class_minter(2),
            Some(class_minter(
                false,
                vec![authority(3), authority(2)],
                MIN_TTL
            ))
        );
    }

    fn mk_meteadata(class: ClassId) -> TokenMetadata {
        TokenMetadata {
            class,
            issued_at: None,
            expires_at: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn mint() -> Result<(), MintError> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let cls2 = ctr.enable_next_class(true, authority(2), MIN_TTL, class_metadata(2), None);

        ctx.predecessor_account_id = authority(1);
        testing_env!(ctx);

        ctr.sbt_mint(alice(), mk_meteadata(1), None)?;
        match ctr.sbt_mint(alice(), mk_meteadata(cls2), None) {
            Err(MintError::NotMinter) => (),
            Ok(_) => panic!("expected NotAuthorized, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        match ctr.sbt_mint(alice(), mk_meteadata(1122), None) {
            Err(MintError::ClassNotEnabled) => (),
            Ok(_) => panic!("expected ClassNotEnabled, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        Ok(())
    }

    #[test]
    #[should_panic(expected = "ttl must be smaller or equal than 1ms")]
    fn assert_ttl() {
        let (_, ctr) = setup(&admin(), None);
        ctr.assert_ttl(10, 1);
    }

    #[test]
    #[should_panic(expected = "caller must be a minter")]
    fn assert_minter() {
        let (_, ctr) = setup(&admin(), None);
        ctr.assert_minter(&alice(), &vec![bob()]);
    }

    #[test]
    fn mint_many() -> Result<(), MintError> {
        let (mut ctx, mut ctr) = setup(&admin(), None);

        let cls2 = ctr.enable_next_class(true, authority(1), MIN_TTL, class_metadata(2), None);
        let cls3 = ctr.enable_next_class(true, authority(2), MIN_TTL, class_metadata(3), None);

        ctx.predecessor_account_id = authority(1);
        testing_env!(ctx.clone());

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
            ],
            None,
        ) {
            Err(MintError::RequiredDeposit(36000000000000000000000)) => (),
            Ok(_) => panic!("expected RequiredDeposit, got: Ok"),
            Err(x) => panic!("expected RequiredDeposit, got: {:?}", x),
        };

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls3)]),
            ],
            None,
        ) {
            Err(MintError::NotMinter) => (),
            Ok(_) => panic!("expected NotAuthorized, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        match ctr.sbt_mint_many(
            vec![
                (alice(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (bob(), vec![mk_meteadata(1122), mk_meteadata(cls2)]),
            ],
            None,
        ) {
            Err(MintError::ClassNotEnabled) => (),
            Ok(_) => panic!("expected ClassNotEnabled, got: Ok"),
            Err(x) => panic!("expected NotAuthorized, got: {:?}", x),
        };

        ctx.attached_deposit = 19000000000000000000000;
        testing_env!(ctx.clone());
        ctr.sbt_mint_many(
            vec![(alice(), vec![mk_meteadata(1), mk_meteadata(cls2)])],
            None,
        )?;

        // deposit increases because we are minting more tokens
        ctx.attached_deposit = 37000000000000000000000;
        testing_env!(ctx);
        ctr.sbt_mint_many(
            vec![
                (bob(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
                (carol(), vec![mk_meteadata(1), mk_meteadata(cls2)]),
            ],
            None,
        )?;

        Ok(())
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn assert_admin() {
        let (mut ctx, ctr) = setup(&admin(), None);

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);

        ctr.assert_admin();
    }

    #[test]
    fn set_admin_list() {
        let (_, mut ctr) = setup(&admin(), None);

        ctr.set_admin_list(vec![admin(), alice()]);
        ctr.assert_admin();

        assert_eq!(ctr.admins.get().unwrap(), vec![admin(), alice()]);
    }
}

'''
'''--- contracts/community-sbt/src/migrate.rs ---
use crate::*;

// community-sbt/v4.2.0 old structs

#[derive(BorshDeserialize)]
pub struct OldContract {
    pub admin: AccountId,
    pub classes: LookupMap<ClassId, ClassMinters>,
    pub next_class: ClassId,
    pub registry: AccountId,
    pub metadata: LazyOption<ContractMetadata>,
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
}

// migration to community-sbt/v4.2.0
#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldContract = env::state_read().expect("can't deserialize contract");

        // changed fields:
        // ttl -- removed
        // pub admin: AccountId,
        //   changed to ->  pub admins: LazyOption<Vec<AccountId>>,

        Self {
            admins: LazyOption::new(StorageKey::Admins, Some(&vec![old_state.admin])),
            classes: old_state.classes,
            next_class: old_state.next_class,
            registry: old_state.registry,
            metadata: old_state.metadata,
            class_metadata: old_state.class_metadata,
        }
    }
}

'''
'''--- contracts/community-sbt/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, BorshStorageKey};

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Admins, // deprecated, required for migration
    ContractMetadata,
    MintingAuthority,
    ClassMetadata,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ClassMinters {
    /// if true only iah verifed accounts can obrain the SBT
    pub requires_iah: bool,
    /// accounts allowed to mint the SBT
    pub minters: Vec<AccountId>,
    /// time to live in ms. Overwrites metadata.expire_at.
    pub max_ttl: u64,
}

'''
'''--- contracts/community-sbt/tests/workspaces.rs ---
use anyhow::Ok;
use near_units::parse_near;
use near_workspaces::{network::Sandbox, Account, AccountId, Contract, Worker};
use sbt::{ClassMetadata, Token, TokenMetadata};
use serde_json::json;

const MAINNET_REGISTRY_ID: &str = "registry-v1.gwg-testing.near";
const MAINNET_COMMUNITY_SBT_ID: &str = "community.i-am-human.near";

async fn init(
    worker: &Worker<Sandbox>,
    migration: bool,
) -> anyhow::Result<(Account, Account, Contract, Account, Account)> {
    let registry_contract: Contract;
    let community_contract: Contract;
    if migration {
        // import the registry contract from mainnet
        let worker_mainnet = near_workspaces::mainnet().await?;
        let contract_id: AccountId = MAINNET_REGISTRY_ID.parse()?;
        registry_contract = worker
            .import_contract(&contract_id, &worker_mainnet)
            .initial_balance(parse_near!("10000000 N"))
            .transact()
            .await?;

        // import the community-sbt contract from mainnet
        let contract_id: AccountId = MAINNET_COMMUNITY_SBT_ID.parse()?;
        community_contract = worker
            .import_contract(&contract_id, &worker_mainnet)
            .initial_balance(parse_near!("10000000 N"))
            .transact()
            .await?;
    } else {
        registry_contract = worker
            .dev_deploy(include_bytes!("../../res/registry.wasm"))
            .await?;
        community_contract = worker
            .dev_deploy(include_bytes!("../../res/community_sbt.wasm"))
            .await?;
    }

    let registry_mainnet = registry_contract.as_account();
    let community_mainnet = community_contract.as_account();
    let authority = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;
    let minter = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;

    // init the registry
    let res = registry_contract
        .call("new")
        .args_json(json!({"authority": authority.id(),
                          "iah_issuer": iah_issuer.id(), "iah_classes": [1],
                          "authorized_flaggers": vec![auth_flagger.id()] }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // init the community-sbt
    let res = community_contract
        .call("new")
        .args_json(
            json!({"registry": registry_mainnet.id(), "admin": authority.id(), "metadata": {
            "spec": "sbt-1.0.0",
            "name": "Community SBT",
            "symbol": "CoSBT"
          }, "ttl": 2147483647 }),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // add iah_issuer
    let res = authority
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": iah_issuer.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // add community_issuer
    let res = authority
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": community_mainnet.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    if migration {
        // authorize authority to mint tokens
        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-1".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());
    } else {
        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-1".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());

        let res = authority
            .call(community_mainnet.id(), "enable_next_class")
            .args_json(
                json!({"requires_iah": false, "minter": minter.id(),"max_ttl": 100000000,
                       "metadata": ClassMetadata {
                           name: "cls-2".to_string(),
                           symbol: None,
                           icon: None,
                           reference: None,
                           reference_hash: None},
                       "memo": "test"}),
            )
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res.receipt_failures());
    }

    // mint mocked community tokens
    let token_metadata = TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: None,
        reference: None,
        reference_hash: None,
    };

    let res = minter
        .call(community_mainnet.id(), "sbt_mint")
        .args_json(json!({"receiver": alice.id(), "metadata": token_metadata, "memo": "test"}))
        .deposit(parse_near!("0.01 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    let res = minter
        .call(community_mainnet.id(), "sbt_mint")
        .args_json(json!({"receiver": bob.id(), "metadata": token_metadata, "memo": "test"}))
        .deposit(parse_near!("0.01 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok((
        registry_mainnet.clone(),
        community_mainnet.clone(),
        community_contract,
        authority.clone(),
        minter.clone(),
    ))
}

#[ignore = "This test is not valid after the migration"]
#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (_, community_sbt, _, admin, _) = init(&worker, true).await?;

    // deploy the new contract
    let new_community_contract = community_sbt
        .deploy(include_bytes!("../../res/community_sbt.wasm"))
        .await?
        .into_result()?;

    // call the migrate method
    let res = new_community_contract
        .call("migrate")
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // call the migration again should fail
    let res = new_community_contract
        .call("migrate")
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    // call the contract after the migration
    let res: AccountId = new_community_contract
        .call("registry")
        .max_gas()
        .transact()
        .await?
        .json()?;
    let expected_res: AccountId = "registry-v1.gwg-testing.near".parse().unwrap();
    assert_eq!(expected_res, res);

    // change admin list
    let res = admin
        .call(new_community_contract.as_account().id(), "set_admin_list")
        .args_json(json!({"new_admin_list": ["test.near", admin.id()]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    Ok(())
}

#[tokio::test]
async fn sbt_renew() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    let sbt1_ttl_before_renew = sbts[0].as_ref().unwrap().metadata.expires_at.unwrap();
    let sbt2_ttl_before_renew = sbts[1].as_ref().unwrap().metadata.expires_at.unwrap();

    let res = minter
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [1,2], "ttl": 100000000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // check if the renew updated the ttl
    assert!(sbts[0].as_ref().unwrap().metadata.expires_at.unwrap() > sbt1_ttl_before_renew);
    assert!(sbts[1].as_ref().unwrap().metadata.expires_at.unwrap() > sbt2_ttl_before_renew);

    // renew non existing tokens
    let res = minter
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [3,4], "ttl": 200000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_renew_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, _) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    let sbt1_ttl_before_renew = sbts[0].as_ref().unwrap().metadata.expires_at.unwrap();
    let sbt2_ttl_before_renew = sbts[1].as_ref().unwrap().metadata.expires_at.unwrap();

    // should fail since the admin is not a minter
    let res = admin
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [1,2], "ttl": 100000000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // check if the ttl is still the same
    assert_eq!(
        sbts[0].as_ref().unwrap().metadata.expires_at.unwrap(),
        sbt1_ttl_before_renew
    );
    assert_eq!(
        sbts[1].as_ref().unwrap().metadata.expires_at.unwrap(),
        sbt2_ttl_before_renew
    );

    // renew non existing tokens
    let res = admin
        .call(community_sbt.id(), "sbt_renew")
        .args_json(json!({"tokens": [3,4], "ttl": 200000, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_revoke() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    // Should pass since community_sbt is minter
    let res = minter
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [1,2], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_none());
    assert!(sbts[1].is_none());

    // revoke non existing tokens
    let res = admin
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [3,4], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    Ok(())
}

#[tokio::test]
async fn sbt_revoke_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, _) = init(&worker, false).await?;

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    // should fail since the admin is not a minter
    let res = admin
        .call(community_sbt.id(), "sbt_revoke")
        .args_json(json!({"tokens": [1,2], "burn": true, "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());

    let sbts: Vec<Option<Token>> = admin
        .call(registry.id(), "sbts")
        .args_json(json!({"issuer": community_sbt.id(), "tokens": [1,2]}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert!(sbts.len() == 2);
    assert!(sbts[0].is_some());
    assert!(sbts[1].is_some());

    Ok(())
}

#[tokio::test]
async fn sbt_mint_many() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, community_sbt, _, admin, minter) = init(&worker, false).await?;

    let bob = worker.dev_create_account().await?;
    let charlie = worker.dev_create_account().await?;

    let supply: u64 = admin
        .call(registry.id(), "sbt_supply")
        .args_json(json!({"issuer": community_sbt.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, 2);

    let token_metadata = vec![
        TokenMetadata {
            class: 1,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
        TokenMetadata {
            class: 2,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
    ];

    // sbt_mint_many
    let res = minter
        .call(community_sbt.id(), "sbt_mint_many")
        .args_json(json!({
            "token_spec":
                vec![
                    (bob.id(), token_metadata.clone()),
                    (charlie.id(), token_metadata),
                ]
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let supply: u64 = admin
        .call(registry.id(), "sbt_supply")
        .args_json(json!({"issuer": community_sbt.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, 6);

    Ok(())
}

'''
'''--- contracts/cost/Cargo.toml ---
[package]
name = "cost"
version = "1.0.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[dependencies]
near-sdk.workspace = true

'''
'''--- contracts/cost/README.md ---
# Cost

Small package with util functions to calculate Gas and Storage cost for the i-am-human registry.

'''
'''--- contracts/cost/src/lib.rs ---
use near_sdk::{Balance, Gas};

pub const MICRO_NEAR: Balance = 1_000_000_000_000_000_000;
pub const MILI_NEAR: Balance = 1000 * MICRO_NEAR;

pub const MINT_COST: Balance = 9 * MILI_NEAR; // 0.009 NEAR. Storage cost is 0.843N from running contract
pub const BAN_COST: Balance = 5 * MILI_NEAR;

pub const MINT_GAS: Gas = Gas(7 * Gas::ONE_TERA.0);
pub const IS_HUMAN_GAS: Gas = Gas(2 * Gas::ONE_TERA.0);
pub const BLACKLIST_GAS: Gas = Gas(6 * Gas::ONE_TERA.0);

/// calculates amount of gas required by registry for `sbt_renew` call.
#[inline]
pub const fn renew_gas(num_tokens: usize) -> Gas {
    // 2tera + num_tokens * 0.2tera * num_tokens
    Gas(2 * Gas::ONE_TERA.0 + num_tokens as u64 * 200_000_000_000)
}

pub const fn calculate_mint_gas(num_tokens: usize) -> Gas {
    Gas((num_tokens as u64 + 1) * MINT_GAS.0)
}

pub const fn calculate_iah_mint_gas(num_tokens: usize, accounts: usize) -> Gas {
    Gas(calculate_mint_gas(num_tokens).0 + accounts as u64 * IS_HUMAN_GAS.0)
}

pub const fn mint_deposit(num_tokens: usize) -> Balance {
    num_tokens as u128 * MINT_COST
}

'''
'''--- contracts/demo-issuer/Cargo.toml ---
[package]
name = "demo-issuer"
version = "1.0.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

cost = { path = "../cost" }
sbt = { path = "../sbt" }

'''
'''--- contracts/demo-issuer/README.md ---
# Demo SBT Issuer

Minimum implementation of SBT.
NEP: https://github.com/near/NEPs/pull/393

Functions:

- `sbt_mint(receiver: AccountId, memo?: string)` -- requests registry to mint a new SBT. Only admin can call it.
- `add_admin(account: AccountId, memo?: string)` -- registers new admin. Any admin can add new admins.

To query SBTs, you have to query the registry contract directly.

'''
'''--- contracts/demo-issuer/deploy.sh ---
#!/bin/sh

./build.sh

if [ $? -ne 0 ]; then
  echo ">> Error building contract"
  exit 1
fi

echo ">> Deploying contract"

# https://docs.near.org/tools/near-cli#near-dev-deploy
near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/hello_near.wasm

'''
'''--- contracts/demo-issuer/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::{env, near_bindgen, require, AccountId, Gas, PanicOnDefault, Promise};

use cost::{MINT_COST, MINT_GAS};
use sbt::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // contract metadata
    pub metadata: LazyOption<ContractMetadata>,

    /// registry of burned accounts.
    pub registry: AccountId,

    /// max duration (in seconds) a claim is valid for processing
    pub claim_ttl: u64,
    /// SBT ttl until expire in miliseconds (expire=issue_time+sbt_ttl)
    pub sbt_ttl_ms: u64,

    /// used for backend key rotation
    pub admins: UnorderedSet<AccountId>,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        metadata: ContractMetadata,
        registry: AccountId,
        claim_ttl: u64,
        admin: AccountId,
    ) -> Self {
        let claim_ttl = if claim_ttl == 0 {
            3600 * 24 // 1 day
        } else {
            claim_ttl
        };
        let mut admins = UnorderedSet::new(b"1");
        admins.insert(&admin);
        Self {
            registry,
            metadata: LazyOption::new(b"m", Some(&metadata)),
            claim_ttl,
            sbt_ttl_ms: 1000 * 3600 * 24 * 365, // 1year in ms
            admins,
        }
    }

    /**********
     * QUERIES
     **********/

    // token queries should go through the registry contract

    /**********
     * ADMIN
     **********/

    #[payable]
    pub fn sbt_mint(&mut self, receiver: AccountId, memo: Option<String>) -> Promise {
        self.assert_admin();
        require!(
            env::attached_deposit() == MINT_COST,
            format!("Requires attached deposit of exactly {} yNEAR", MINT_COST)
        );

        let now_ms = env::block_timestamp_ms();
        let metadata = TokenMetadata {
            class: 1,
            issued_at: Some(now_ms),
            expires_at: Some(now_ms + self.sbt_ttl_ms),
            reference: None,
            reference_hash: None,
        };

        if let Some(memo) = memo {
            env::log_str(&format!("SBT mint memo: {}", memo));
        }

        ext_registry::ext(self.registry.clone())
            .with_attached_deposit(MINT_COST)
            .with_static_gas(MINT_GAS)
            .sbt_mint(vec![(receiver, vec![metadata])])
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 3)
                    .sbt_mint_callback(),
            )
    }

    #[private]
    pub fn sbt_mint_callback(
        &mut self,
        #[callback_result] last_result: Result<Vec<TokenId>, near_sdk::PromiseError>,
    ) -> Vec<TokenId> {
        match last_result {
            Err(_) => env::panic_str("ERR: Mint failed"),
            Ok(res) => res,
        }
    }

    pub fn add_admin(
        &mut self,
        account: AccountId,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        self.assert_admin();
        self.admins.insert(&account);
    }

    /**********
     * INTERNAL
     **********/

    #[inline]
    fn assert_admin(&self) {
        require!(
            self.admins.contains(&env::predecessor_account_id()),
            "not an admin"
        );
    }
}

#[near_bindgen]
impl SBTIssuer for Contract {
    fn sbt_metadata(&self) -> ContractMetadata {
        self.metadata.get().unwrap()
    }

    /// Returns `ClassMetadata` by class. Dummy implementation for demo purposes.
    fn sbt_class_metadata(&self, class: ClassId) -> Option<ClassMetadata> {
        Some({
            ClassMetadata {
                name: format!("class-{}", class),
                symbol: None,
                icon: None,
                reference: None,
                reference_hash: None,
            }
        })
    }
}

'''
'''--- contracts/easy-poll/Cargo.toml ---
[package]
name = "easy-poll"
version = "0.0.1"
authors = [
    "NDC GWG (https://near.social/#/mob.near/widget/ProfilePage?accountId=govworkinggroup.near)",
]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

cost = { path = "../cost" }
sbt = { path = "../sbt" }

[dev-dependencies]
pretty_assertions.workspace = true
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
tracing.workspace = true
test-util = { path = "../test-util" }

'''
'''--- contracts/easy-poll/README.md ---
# Easy Poll

Proof of concept

Based on https://www.notion.so/near-ndc/EasyPoll-v2-f991a29781ca452db154c64922717d19#35d9a363be34495bb13ad5fa4b73cafe

## Usage

## Deployed contracts

'''
'''--- contracts/easy-poll/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::FunctionError;

use crate::MAX_TEXT_ANSWER_LEN;

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum PollError {
    RequiredAnswer(usize),
    NotIAH,
    NotFound,
    NotActive,
    OpinionRange,
    WrongAnswer,
    IncorrectAnswerVector,
    AlredyAnswered,
    AnswerTooLong(usize),
    InsufficientDeposit(u128),
}

impl FunctionError for PollError {
    fn panic(&self) -> ! {
        match self {
            PollError::RequiredAnswer(index) => {
                panic_str(&format!("Answer to a required question index={} was not provided",index))
            }
            PollError::NotIAH => panic_str("voter is not a verified human"),
            PollError::NotFound => panic_str("poll not found"),
            PollError::NotActive => panic_str("poll is not active"),
            PollError::OpinionRange => panic_str("opinion must be between 1 and 10"),
            PollError::WrongAnswer => {
                panic_str("answer provied does not match the expected question")
            },
            PollError::IncorrectAnswerVector => panic_str("the answer vector provided is incorrect and does not match the questions in the poll"),
            PollError::AlredyAnswered => panic_str("user has already answered"),
            PollError::AnswerTooLong(len) => {panic_str(&format!("the answer too long, max_len:{}, got:{}", MAX_TEXT_ANSWER_LEN, len))},
            PollError::InsufficientDeposit(req_deposit) => {panic_str(&format!("not enough storage deposit, required: {}", req_deposit))}
        }
    }
}

'''
'''--- contracts/easy-poll/src/events.rs ---
use near_sdk::{serde::Serialize, AccountId};
use serde_json::json;

use sbt::{EventPayload, NearEvent};

use crate::PollId;

fn emit_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "ndc-easy-poll",
        version: "1.0.0",
        event,
    }
    .emit();
}

pub(crate) fn emit_create_poll(poll_id: PollId) {
    emit_event(EventPayload {
        event: "create_poll",
        data: json!({ "poll_id": poll_id }),
    });
}

pub(crate) fn emit_respond(poll_id: PollId, responder: AccountId) {
    emit_event(EventPayload {
        event: "respond",
        data: json!({ "poll_id": poll_id, "responder": responder }),
    });
}

#[cfg(test)]
mod unit_tests {
    use near_sdk::{test_utils, AccountId};

    use super::*;

    fn acc(idx: u8) -> AccountId {
        AccountId::new_unchecked(format!("user-{}.near", idx))
    }

    #[test]
    fn log_vote() {
        let expected1 = r#"EVENT_JSON:{"standard":"ndc-easy-poll","version":"1.0.0","event":"create_poll","data":{"poll_id":21}}"#;
        let expected2 = r#"EVENT_JSON:{"standard":"ndc-easy-poll","version":"1.0.0","event":"respond","data":{"poll_id":22,"responder":"user-1.near"}}"#;
        emit_create_poll(21);
        assert_eq!(vec![expected1], test_utils::get_logs());
        emit_respond(22, acc(1));
        assert_eq!(vec![expected1, expected2], test_utils::get_logs());
    }
}

'''
'''--- contracts/easy-poll/src/ext.rs ---
pub use crate::storage::*;
use near_sdk::{ext_contract, AccountId};
use sbt::TokenId;

#[ext_contract(ext_registry)]
trait ExtRegistry {
    // queries
    fn is_human(&self, account: AccountId) -> Vec<(AccountId, Vec<TokenId>)>;
}

'''
'''--- contracts/easy-poll/src/lib.rs ---
pub use crate::errors::PollError;
use crate::events::emit_create_poll;
use crate::events::emit_respond;
pub use crate::ext::*;
pub use crate::storage::*;
use ext::ext_registry;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::collections::LookupSet;
use near_sdk::Gas;
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault};

mod errors;
mod events;
mod ext;
mod storage;

pub const RESPOND_CALLBACK_GAS: Gas = Gas(2 * Gas::ONE_TERA.0);
pub const MAX_TEXT_ANSWER_LEN: usize = 500; // TODO: decide on the maximum length of the text answers to

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// map of all polls
    pub polls: LookupMap<PollId, Poll>,
    /// map of all results summarized
    pub results: LookupMap<PollId, Results>,
    /// lookup set of (poll_id, responder)
    pub participants: LookupSet<(PollId, AccountId)>,
    /// SBT registry.
    pub sbt_registry: AccountId,
    /// next poll id
    pub next_poll_id: PollId,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(sbt_registry: AccountId) -> Self {
        Self {
            polls: LookupMap::new(StorageKey::Polls),
            results: LookupMap::new(StorageKey::Results),
            participants: LookupSet::new(StorageKey::Participants),
            sbt_registry,
            next_poll_id: 1,
        }
    }

    /**********
     * QUERIES
     **********/

    /// Returns the poll details. If poll not found returns None.
    pub fn poll(&self, poll_id: PollId) -> Option<Poll> {
        self.polls.get(&poll_id)
    }

    /// Returns poll results (except for text answers), if poll not found returns None.
    pub fn results(&self, poll_id: u64) -> Option<Results> {
        self.results.get(&poll_id)
    }

    /**********
     * TRANSACTIONS
     **********/

    /// User can update the poll if starts_at > now
    /// it panics if
    /// - user tries to create an invalid poll
    /// - if poll aready exists and starts_at < now
    /// emits create_poll event
    pub fn create_poll(
        &mut self,
        iah_only: bool,
        questions: Vec<Question>,
        starts_at: u64,
        ends_at: u64,
        title: String,
        tags: Vec<String>,
        description: String,
        link: String,
    ) -> PollId {
        let created_at = env::block_timestamp_ms();
        require!(created_at < starts_at, "poll start must be in the future");
        let poll_id = self.next_poll_id;
        self.next_poll_id += 1;
        self.initialize_results(poll_id, &questions);
        self.polls.insert(
            &poll_id,
            &Poll {
                iah_only,
                questions,
                starts_at,
                ends_at,
                title,
                tags,
                description,
                link,
                created_at,
            },
        );
        emit_create_poll(poll_id);
        poll_id
    }

    /// Allows user to respond to a poll, once the answers are submited they cannot be changed.
    /// it panics if
    /// - poll not found
    /// - poll not active
    /// - user alredy answered
    /// - poll.verified_humans_only is true, and user is not verified on IAH
    /// - user tries to vote with an invalid answer to a question
    /// emits repond event
    #[payable]
    #[handle_result]
    pub fn respond(
        &mut self,
        poll_id: PollId,
        answers: Vec<Option<Answer>>,
    ) -> Result<(), PollError> {
        let caller = env::predecessor_account_id();
        let storage_start = env::storage_usage();
        let storage_deposit = env::attached_deposit();

        self.assert_active(poll_id)?;

        self.assert_not_answered(poll_id, &caller)?;
        let poll = match self.polls.get(&poll_id) {
            None => return Err(PollError::NotFound),
            Some(poll) => poll,
        };
        // if iah calls the registry to verify the iah sbt
        if poll.iah_only {
            ext_registry::ext(self.sbt_registry.clone())
                .is_human(caller.clone())
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(RESPOND_CALLBACK_GAS)
                        .on_human_verifed(true, caller, poll_id, answers),
                );
        } else {
            self.on_human_verifed(vec![], false, caller, poll_id, answers)?
        }

        let required_deposit =
            (env::storage_usage() - storage_start) as u128 * env::storage_byte_cost();
        if storage_deposit < required_deposit {
            return Err(PollError::InsufficientDeposit(required_deposit));
        }
        Ok(())
    }

    /**********
     * PRIVATE
     **********/

    /// Callback for the respond method.
    #[private]
    #[handle_result]
    pub fn on_human_verifed(
        &mut self,
        #[callback_unwrap] tokens: Vec<(AccountId, Vec<sbt::TokenId>)>,
        iah_only: bool,
        caller: AccountId,
        poll_id: PollId,
        answers: Vec<Option<Answer>>,
    ) -> Result<(), PollError> {
        // Check for IAH requirement if iah_only is set
        if iah_only && tokens.is_empty() {
            return Err(PollError::NotIAH);
        }

        // Retrieve questions and poll results
        let questions = match self.polls.get(&poll_id) {
            Some(poll) => poll.questions,
            None => return Err(PollError::NotFound),
        };
        let mut poll_results = match self.results.get(&poll_id) {
            Some(results) => results,
            None => return Err(PollError::NotFound),
        };

        // Check if the number of answers matches the number of questions
        if questions.len() != answers.len() {
            return Err(PollError::IncorrectAnswerVector);
        }

        for i in 0..questions.len() {
            let q = &questions[i];
            let a = &answers[i];

            match (a, &mut poll_results.results[i]) {
                (Some(Answer::YesNo(response)), PollResult::YesNo((yes_count, no_count))) => {
                    if *response {
                        *yes_count += 1;
                    } else {
                        *no_count += 1;
                    }
                }
                (Some(Answer::TextChoices(choices)), PollResult::TextChoices(results))
                | (Some(Answer::PictureChoices(choices)), PollResult::PictureChoices(results)) => {
                    for choice in choices {
                        results[*choice as usize] += 1;
                    }
                }
                (Some(Answer::OpinionRange(opinion)), PollResult::OpinionRange(results)) => {
                    if *opinion < 1 || *opinion > 10 {
                        return Err(PollError::OpinionRange);
                    }
                    results.sum += *opinion as u64;
                    results.num += 1;
                }
                (Some(Answer::TextAnswer(answer)), PollResult::TextAnswer) => {
                    if answer.len() > MAX_TEXT_ANSWER_LEN {
                        return Err(PollError::AnswerTooLong(answer.len()));
                    }
                }
                // if the answer is not provided do nothing
                (None, _) => {
                    if q.required {
                        return Err(PollError::RequiredAnswer(i));
                    }
                }
                (_, _) => return Err(PollError::WrongAnswer),
            }
        }

        // Update the participants lookupset to ensure user cannot answer twice
        self.participants.insert(&(poll_id, caller.clone()));
        poll_results.participants_num += 1;
        self.results.insert(&poll_id, &poll_results);
        emit_respond(poll_id, caller);

        Ok(())
    }

    /**********
     * INTERNAL
     **********/

    fn assert_active(&self, poll_id: PollId) -> Result<(), PollError> {
        let poll = match self.polls.get(&poll_id) {
            Some(poll) => poll,
            None => return Err(PollError::NotFound),
        };
        let current_timestamp = env::block_timestamp_ms();
        if poll.starts_at > current_timestamp || poll.ends_at < current_timestamp {
            return Err(PollError::NotActive);
        }
        Ok(())
    }

    fn assert_not_answered(&self, poll_id: PollId, caller: &AccountId) -> Result<(), PollError> {
        if self.participants.contains(&(poll_id, caller.clone())) {
            return Err(PollError::AlredyAnswered);
        }
        Ok(())
    }

    fn initialize_results(&mut self, poll_id: PollId, questions: &[Question]) {
        let mut index = 0;
        let results: Vec<PollResult> = questions
            .iter()
            .map(|question| {
                let result = match &question.question_type {
                    Answer::YesNo(_) => PollResult::YesNo((0, 0)),
                    Answer::TextChoices(choices) => PollResult::TextChoices(vec![0; choices.len()]),
                    Answer::PictureChoices(_) => PollResult::PictureChoices(Vec::new()),
                    Answer::OpinionRange(_) => {
                        PollResult::OpinionRange(OpinionRangeResult { sum: 0, num: 0 })
                    }
                    Answer::TextAnswer(_) => PollResult::TextAnswer,
                };
                index += 1;
                result
            })
            .collect();

        self.results.insert(
            &poll_id,
            &Results {
                status: Status::NotStarted,
                participants_num: 0,
                results,
            },
        );
    }
}

#[cfg(test)]
mod tests {
    use cost::MILI_NEAR;
    use near_sdk::{
        test_utils::{self, VMContextBuilder},
        testing_env, AccountId, Balance, VMContext,
    };

    use crate::{
        Answer, Contract, OpinionRangeResult, PollError, PollResult, Question, Results, Status,
    };

    pub const RESPOND_COST: Balance = MILI_NEAR;
    const MILI_SECOND: u64 = 1000000; // nanoseconds

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob.near".to_string())
    }

    fn charlie() -> AccountId {
        AccountId::new_unchecked("charlie.near".to_string())
    }

    fn registry() -> AccountId {
        AccountId::new_unchecked("registry.near".to_string())
    }

    fn tags() -> Vec<String> {
        vec![String::from("tag1"), String::from("tag2")]
    }

    fn question_text_answers(required: bool) -> Question {
        Question {
            question_type: Answer::TextAnswer(String::from("")),
            required,
            title: String::from("Opinion test!"),
            description: None,
            image: None,
            labels: None,
            choices: None,
            max_choices: None,
        }
    }

    fn question_yes_no(required: bool) -> Question {
        Question {
            question_type: Answer::YesNo(true),
            required,
            title: String::from("Yes and no test!"),
            description: None,
            image: None,
            labels: None,
            choices: None,
            max_choices: None,
        }
    }

    fn question_text_choices(required: bool) -> Question {
        Question {
            question_type: Answer::TextChoices(vec![0, 1, 2]),
            required,
            title: String::from("Yes and no test!"),
            description: None,
            image: None,
            labels: None,
            choices: Some(vec![
                String::from("agree"),
                String::from("disagree"),
                String::from("no opinion"),
            ]),
            max_choices: Some(1),
        }
    }

    fn question_opinion_range(required: bool) -> Question {
        Question {
            question_type: Answer::OpinionRange(0),
            required,
            title: String::from("Opinion test!"),
            description: None,
            image: None,
            labels: None,
            choices: None,
            max_choices: None,
        }
    }

    fn setup(predecessor: &AccountId) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(alice())
            .block_timestamp(MILI_SECOND)
            .is_view(false)
            .build();
        testing_env!(ctx.clone());
        let ctr = Contract::new(registry());
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        return (ctx, ctr);
    }

    #[test]
    #[should_panic(expected = "poll start must be in the future")]
    fn create_poll_wrong_time() {
        let (_, mut ctr) = setup(&alice());
        ctr.create_poll(
            false,
            vec![question_yes_no(true)],
            1,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
    }

    #[test]
    fn create_poll() {
        let (_, mut ctr) = setup(&alice());
        ctr.create_poll(
            false,
            vec![question_yes_no(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        let expected_event = r#"EVENT_JSON:{"standard":"ndc-easy-poll","version":"1.0.0","event":"create_poll","data":{"poll_id":1}}"#;
        assert!(test_utils::get_logs().len() == 1);
        assert_eq!(test_utils::get_logs()[0], expected_event);
    }

    #[test]
    fn results_poll_not_found() {
        let (_, ctr) = setup(&alice());
        assert!(ctr.results(1).is_none());
    }

    #[test]
    fn results() {
        let (_, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_yes_no(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        let res = ctr.results(poll_id);
        let expected = Results {
            status: Status::NotStarted,
            participants_num: 0,
            results: vec![PollResult::YesNo((0, 0))],
        };
        assert_eq!(res.unwrap(), expected);
    }

    #[test]
    fn respond_poll_not_active() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_yes_no(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.attached_deposit = RESPOND_COST;
        testing_env!(ctx.clone());
        // too early
        match ctr.respond(poll_id, vec![Some(Answer::YesNo(true))]) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::NotActive => println!("Expected error: PollError::NotActive"),
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
        ctx.block_timestamp = MILI_SECOND * 101;
        testing_env!(ctx);
        // too late
        match ctr.respond(poll_id, vec![Some(Answer::YesNo(true))]) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::NotActive => println!("Expected error: PollError::NotActive"),
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
    }

    #[test]
    fn yes_no_flow() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_yes_no(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.attached_deposit = RESPOND_COST;
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx.clone());
        let mut res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::YesNo(true))],
        );
        assert!(res.is_ok());

        let expected_event = r#"EVENT_JSON:{"standard":"ndc-easy-poll","version":"1.0.0","event":"respond","data":{"poll_id":1,"responder":"alice.near"}}"#;
        assert!(test_utils::get_logs().len() == 1);
        assert_eq!(test_utils::get_logs()[0], expected_event);

        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::YesNo(true))],
        );
        assert!(res.is_ok());

        assert!(test_utils::get_logs().len() == 1);

        ctx.predecessor_account_id = charlie();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::YesNo(false))],
        );
        assert!(res.is_ok());

        assert!(test_utils::get_logs().len() == 1);

        let results = ctr.results(poll_id);
        assert_eq!(
            results.unwrap(),
            Results {
                status: Status::NotStarted,
                participants_num: 3,
                results: vec![PollResult::YesNo((2, 1)),]
            }
        )
    }

    #[test]
    fn opinion_range_out_of_range() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_opinion_range(false)],
            2,
            100,
            String::from("Multiple questions test!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx);
        match ctr.on_human_verifed(
            vec![],
            false,
            alice(),
            poll_id,
            vec![Some(Answer::OpinionRange(11))],
        ) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::OpinionRange => println!("Expected error: PollError::OpinionRange"),
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
    }

    #[test]
    fn respond_wrong_answer_vector() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_opinion_range(false)],
            2,
            100,
            String::from("Multiple questions test!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx);
        match ctr.on_human_verifed(
            vec![],
            false,
            alice(),
            poll_id,
            vec![
                Some(Answer::OpinionRange(10)),
                Some(Answer::OpinionRange(10)),
            ],
        ) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::IncorrectAnswerVector => {
                        println!("Expected error: PollError::IncorrectAnswerVector")
                    }
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
    }

    #[test]
    fn opinion_range_flow() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_opinion_range(false)],
            2,
            100,
            String::from("Multiple questions test!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.attached_deposit = RESPOND_COST;
        ctx.predecessor_account_id = alice();
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx.clone());
        let mut res = ctr.on_human_verifed(
            vec![],
            false,
            alice(),
            poll_id,
            vec![Some(Answer::OpinionRange(5))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            bob(),
            poll_id,
            vec![Some(Answer::OpinionRange(10))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = charlie();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            charlie(),
            poll_id,
            vec![Some(Answer::OpinionRange(2))],
        );
        assert!(res.is_ok());
        let results = ctr.results(poll_id);
        assert_eq!(
            results.unwrap(),
            Results {
                status: Status::NotStarted,
                participants_num: 3,
                results: vec![PollResult::OpinionRange(OpinionRangeResult {
                    sum: 17,
                    num: 3
                }),]
            }
        )
    }
    #[test]
    fn text_chocies_flow() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_text_choices(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.attached_deposit = RESPOND_COST;
        ctx.predecessor_account_id = alice();
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx.clone());
        let mut res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextChoices(vec![0]))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextChoices(vec![0]))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = charlie();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextChoices(vec![1]))],
        );
        assert!(res.is_ok());
        let results = ctr.results(poll_id);
        assert_eq!(
            results.unwrap(),
            Results {
                status: Status::NotStarted,
                participants_num: 3,
                results: vec![PollResult::TextChoices(vec![2, 1, 0]),]
            }
        )
    }

    #[test]
    fn text_answers_flow() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            false,
            vec![question_text_answers(true)],
            2,
            100,
            String::from("Hello, world!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.attached_deposit = RESPOND_COST;
        ctx.predecessor_account_id = alice();
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx.clone());
        let answer1: String = "Answer 1".to_string();
        let answer2: String = "Answer 2".to_string();
        let answer3: String = "Answer 3".to_string();
        let mut res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextAnswer(answer1.clone()))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextAnswer(answer2.clone()))],
        );
        assert!(res.is_ok());
        ctx.predecessor_account_id = charlie();
        testing_env!(ctx.clone());
        res = ctr.on_human_verifed(
            vec![],
            false,
            ctx.predecessor_account_id,
            poll_id,
            vec![Some(Answer::TextAnswer(answer3.clone()))],
        );
        assert!(res.is_ok());
        let results = ctr.results(poll_id);
        assert_eq!(
            results.unwrap(),
            Results {
                status: Status::NotStarted,
                participants_num: 3,
                results: vec![PollResult::TextAnswer]
            }
        );
    }

    #[test]
    fn respond_iah_only_not_human() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            true,
            vec![question_opinion_range(false)],
            2,
            100,
            String::from("Multiple questions test!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx);
        match ctr.on_human_verifed(
            vec![],
            true,
            alice(),
            poll_id,
            vec![Some(Answer::OpinionRange(10))],
        ) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::NotIAH => {
                        println!("Expected error: PollError::NotIAH")
                    }
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
    }

    #[test]
    fn respond_required_answer_not_provided() {
        let (mut ctx, mut ctr) = setup(&alice());
        let poll_id = ctr.create_poll(
            true,
            vec![question_opinion_range(false), question_opinion_range(true)],
            2,
            100,
            String::from("Multiple questions test!"),
            tags(),
            String::from(""),
            String::from(""),
        );
        ctx.block_timestamp = MILI_SECOND * 3;
        testing_env!(ctx);
        match ctr.on_human_verifed(
            vec![],
            false,
            alice(),
            poll_id,
            vec![Some(Answer::OpinionRange(10)), None],
        ) {
            Err(err) => {
                println!("Received error: {:?}", err);
                match err {
                    PollError::RequiredAnswer(1) => {
                        println!("Expected error: PollError::RequiredAnswer")
                    }
                    _ => panic!("Unexpected error: {:?}", err),
                }
            }
            Ok(_) => panic!("Received Ok result, but expected an error"),
        }
    }
}

'''
'''--- contracts/easy-poll/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::BorshStorageKey;

pub type PollId = u64;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum Answer {
    YesNo(bool),
    TextChoices(Vec<u32>),    // should respect the min_choices, max_choices
    PictureChoices(Vec<u32>), // should respect the min_choices, max_choices
    OpinionRange(u8),         // should be a number between 0 and 10
    TextAnswer(String),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum PollResult {
    YesNo((u32, u32)),                // yes, no
    TextChoices(Vec<u32>),            // should respect the min_choices, max_choices
    PictureChoices(Vec<u32>),         // should respect the min_choices, max_choices
    OpinionRange(OpinionRangeResult), // mean value
    TextAnswer, // indicates whether the question exist or not, the answers are stored in a different struct called `TextAnswers`
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct OpinionRangeResult {
    pub sum: u64,
    pub num: u64,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Question {
    pub question_type: Answer,                    // required
    pub required: bool, // required, if true users can't vote without having an answer for this question
    pub title: String,  // required
    pub description: Option<String>, // optional
    pub image: Option<String>, // optional
    pub labels: Option<(String, String, String)>, // if applicable, labels for the opinion scale question
    pub choices: Option<Vec<String>>, // if applicable, choices for the text and picture choices question TODO: make sure we dont need it
    pub max_choices: Option<u32>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Poll {
    pub iah_only: bool, // required, if true only verified humans can vote, if false anyone can vote
    pub questions: Vec<Question>, // required, a poll can have any number of questions
    pub starts_at: u64, // required, time in milliseconds
    pub ends_at: u64,   // required, time in milliseconds
    pub title: String,  // required
    pub tags: Vec<String>, // can be an empty vector
    pub description: String, // can be an empty string
    pub link: String,   // can be an empty string
    pub created_at: u64, // time in milliseconds, should be assigned by the smart contract not a user.
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Results {
    pub status: Status,
    pub participants_num: u64,    // number of participants
    pub results: Vec<PollResult>, // question_id, result (sum of yes etc.)
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    NotStarted,
    Active,
    Finished,
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Polls,
    Results,
    Participants,
}

'''
'''--- contracts/easy-poll/tests/workspaces.rs ---
use anyhow::Ok;
use easy_poll::{PollResult, Results, Status};
use near_sdk::serde_json::json;
use near_units::parse_near;
use near_workspaces::{network::Sandbox, Account, AccountId, Contract, Worker};
use test_util::{deploy_contract, get_block_timestamp, registry_default};

async fn respond(
    easy_poll_contract: &AccountId,
    responder: &Account,
    poll_id: u64,
) -> anyhow::Result<()> {
    let res = responder
        .call(easy_poll_contract, "respond")
        .args_json(json!({"poll_id": poll_id, "answers": [{"YesNo": true}]}))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());
    Ok(())
}

async fn init(worker: &Worker<Sandbox>) -> anyhow::Result<(Contract, Account, Account)> {
    let authority_acc = worker.dev_create_account().await?;
    let flagger = worker.dev_create_account().await?;
    let alice_acc = worker.dev_create_account().await?;
    let bob_acc = worker.dev_create_account().await?;

    // Setup registry contract and issue iah to alice
    let (registry_contract, _) = registry_default(
        &worker,
        authority_acc.id(),
        vec![flagger.id()],
        vec![alice_acc.id()],
    )
    .await?;

    // Setup easy-poll contract
    let easy_poll_contract = deploy_contract(
        &worker,
        "./",
        "new",
        json!({"sbt_registry": registry_contract.id()}),
    )
    .await?;

    Ok((easy_poll_contract, alice_acc, bob_acc))
}

#[tokio::test]
async fn flow1() -> anyhow::Result<()> {
    // 1. create non-human gated poll
    // 2. create human gated poll
    // 3. vote for both polls with a human verified account
    // 4. vote for both polls with a non-human account
    // 5. check the responds were recorded correctly

    // import the registry contract from mainnet with data
    let worker = near_workspaces::sandbox().await?;
    let (easy_poll_contract, alice, bob) = init(&worker).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;
    // create a poll
    let poll_id_non_human_gated: u64 = bob.call(easy_poll_contract.id(), "create_poll")
        .args_json(json!({"iah_only": false, "questions": [{"question_type": {"YesNo": false}, "required": true,
            "title": "non-human gated"}], "starts_at": now_ms + 20000, "ends_at": now_ms + 300000,
            "title": "Testing Poll 1", "tags": ["test"], "description": "poll desc", "link": "test.io"}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // create a poll
    let poll_id_human_gated: u64 = bob.call(easy_poll_contract.id(), "create_poll")
        .args_json(json!({"iah_only": true, "questions": [{"question_type": {"YesNo": false}, "required": true,
            "title": "human gated"}], "starts_at": now_ms + 5000, "ends_at": now_ms + 86400000,
            "title": "Testing Poll 1", "tags": ["test"], "description": "poll desc", "link": "test.io"}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // fast forward
    worker.fast_forward(100).await?;

    respond(easy_poll_contract.id(), &bob, poll_id_non_human_gated).await?;
    respond(easy_poll_contract.id(), &alice, poll_id_non_human_gated).await?;

    // This vote should not be registered since the poll is human gated and bob is not human
    respond(easy_poll_contract.id(), &bob, poll_id_human_gated).await?;
    respond(easy_poll_contract.id(), &alice, poll_id_human_gated).await?;

    // assert the results are correct
    let res: Option<Results> = bob
        .call(easy_poll_contract.id(), "results")
        .args_json(json!({ "poll_id": poll_id_non_human_gated }))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(
        res.unwrap(),
        Results {
            status: Status::NotStarted,
            participants_num: 2,
            results: vec![PollResult::YesNo((2, 0))]
        }
    );

    let res: Option<Results> = bob
        .call(easy_poll_contract.id(), "results")
        .args_json(json!({ "poll_id": poll_id_human_gated }))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(
        res.unwrap(),
        Results {
            status: Status::NotStarted,
            participants_num: 1,
            results: vec![PollResult::YesNo((1, 0))]
        }
    );

    Ok(())
}

'''
'''--- contracts/human_checker/Cargo.toml ---
[package]
name = "human_checker"
version = "1.0.0"
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

sbt = { path = "../sbt" }
registry = { path = "../registry" }

[dev-dependencies]
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-units.workspace = true

'''
'''--- contracts/human_checker/README.md ---
# Human Checker

Contract for SBT registry integration tests.

'''
'''--- contracts/human_checker/src/ext.rs ---
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::Deserialize;
use near_sdk::{ext_contract, AccountId, PromiseOrValue};

use registry::errors::IsHumanCallErr;

// imports needed for conditional derive (required for tests)
#[allow(unused_imports)]
use near_sdk::serde::Serialize;

#[ext_contract(ext_sbtreg)]
pub trait ExtSbtRegistry {
    fn is_human_call(
        &mut self,
        account: AccountId,
        ctr: AccountId,
        function: String,
        payload: String,
    ) -> PromiseOrValue<bool>;

    fn is_human_call_lock(
        &mut self,
        ctr: AccountId,
        function: String,
        payload: String,
        lock_duration: u64,
        with_proof: bool,
    ) -> Result<Promise, IsHumanCallErr>;
}

'''
'''--- contracts/human_checker/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, require, AccountId, Balance, PanicOnDefault};

use sbt::*;

pub const MILI_NEAR: Balance = 1_000_000_000_000_000_000_000;
pub const REG_HUMAN_DEPOSIT: Balance = 3 * MILI_NEAR;
/// maximum time for proposal voting in milliseconds.
pub const VOTING_DURATION: u64 = 20_000;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Accounts authorized to issue new SBT
    pub used_tokens: LookupMap<AccountId, SBTs>,
    /// SBT registry.
    pub registry: AccountId,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    /// @admins: initial set of admins
    /// @ttl: time to live for SBT expire. Must be number in miliseconds.
    #[init]
    pub fn new(registry: AccountId) -> Self {
        Self {
            used_tokens: LookupMap::new(b"1"),
            registry,
        }
    }

    #[payable]
    pub fn register_human_token(
        &mut self,
        caller: AccountId,
        iah_proof: SBTs,
        payload: RegisterHumanPayload,
    ) -> bool {
        env::log_str(&format!(
            "register token for {}, memo={}",
            caller, payload.memo
        ));
        require!(
            env::predecessor_account_id() == self.registry,
            "must be called by registry"
        );
        assert_eq!(payload.numbers, expected_vec_payload(), "wrong payload");
        require!(!iah_proof.is_empty(), "not a human");
        for (_, tokens) in &iah_proof {
            require!(
                !tokens.is_empty(),
                "bad response, expected non empty token list"
            );
        }
        if self.used_tokens.contains_key(&caller) {
            return false;
        }
        self.used_tokens.insert(&caller, &iah_proof);
        true
    }

    pub fn recorded_sbts(&self, user: AccountId) -> Option<SBTs> {
        self.used_tokens.get(&user)
    }

    /// Simulates a governance voting. Every valid human (as per IAH registry) can vote.
    /// To avoid double voting by an account who is doing soul_transfer while a proposal is
    /// active, we require that voing must be called through `iah_registry.is_human_call_lock`.
    /// We check that the caller set enough `lock_duration` for soul transfers.
    /// Arguments:
    /// * `caller`: account ID making a vote (passed by `iah_registry.is_human_call`)
    /// * `locked_until`: time in milliseconds, untile when the caller is locked for soul
    ///   transfers (reported by `iah_registry.is_human_call`).
    /// * `iah_proof`: proof of humanity. It's not required and will be ignored.
    /// * `payload`: the proposal ID and the vote (approve or reject).
    #[payable]
    pub fn vote(
        &mut self,
        caller: AccountId,
        locked_until: u64,
        #[allow(unused_variables)] iah_proof: Option<SBTs>,
        payload: VotePayload,
    ) {
        // for this simulation we imagine that every proposal ID is valid and it's finishing
        // at "now" + VOTING_DURATION
        require!(
            env::predecessor_account_id() == self.registry,
            "must be called by registry"
        );
        require!(
            locked_until >= env::block_timestamp_ms() + VOTING_DURATION,
            "account not locked for soul transfer for sufficient amount of time"
        );
        require!(payload.prop_id > 0, "invalid proposal id");
        require!(
            payload.vote == "approve" || payload.vote == "reject",
            "invalid vote: must be either 'approve' or 'reject'"
        );

        env::log_str(&format!(
            "VOTED: voter={}, proposal={}, vote={}",
            caller, payload.prop_id, payload.vote,
        ));
    }
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct RegisterHumanPayload {
    pub memo: String,
    pub numbers: Vec<u32>,
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct VotePayload {
    pub prop_id: u32,
    pub vote: String,
}

pub(crate) fn expected_vec_payload() -> Vec<u32> {
    vec![2, 3, 5, 7, 11]
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{test_utils::VMContextBuilder, testing_env, VMContext};

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn issuer1() -> AccountId {
        AccountId::new_unchecked("sbt.n".to_string())
    }

    fn registry() -> AccountId {
        AccountId::new_unchecked("registry".to_string())
    }

    fn setup(predecessor: AccountId, deposit: Balance) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(predecessor)
            .is_view(false)
            .build();
        if deposit > 0 {
            ctx.attached_deposit = deposit
        }
        testing_env!(ctx.clone());
        let ctr = Contract::new(registry());
        (ctx, ctr)
    }

    #[test]
    fn register_human_token() {
        let (_, mut ctr) = setup(registry(), REG_HUMAN_DEPOSIT);

        let tokens = vec![(issuer1(), vec![1, 4])];
        let payload = RegisterHumanPayload {
            memo: "checking alice".to_owned(),
            numbers: expected_vec_payload(),
        };
        assert!(ctr.register_human_token(alice(), tokens.clone(), payload.clone()));
        assert_eq!(ctr.used_tokens.get(&alice()).unwrap(), tokens);

        assert!(
            !ctr.register_human_token(alice(), vec![(issuer1(), vec![2])], payload),
            "second call for the same user should return false"
        );
        assert_eq!(
            ctr.used_tokens.get(&alice()).unwrap(),
            tokens,
            "should not overwrite previous call"
        );
    }

    #[test]
    #[should_panic(expected = "must be called by registry")]
    fn register_human_token_non_registry() {
        let (_, mut ctr) = setup(issuer1(), REG_HUMAN_DEPOSIT);

        let tokens = vec![(issuer1(), vec![1, 4])];
        ctr.register_human_token(
            alice(),
            tokens,
            RegisterHumanPayload {
                memo: "registering alice".to_owned(),
                numbers: expected_vec_payload(),
            },
        );
    }
}

'''
'''--- contracts/human_checker/tests/workspaces.rs ---
use anyhow::Ok;
use near_units::parse_near;
use near_workspaces::{network::Sandbox, result::ExecutionFinalResult, Account, Contract, Worker};
use sbt::{SBTs, TokenMetadata};
use serde_json::json;

use human_checker::{RegisterHumanPayload, VotePayload, VOTING_DURATION};

const REGISTER_HUMAN_TOKEN: &str = "register_human_token";
const MSECOND : u64 = 1000;

struct Suite {
    registry: Contract,
    human_checker: Contract,
}

impl Suite {
    pub async fn is_human_call(
        &self,
        caller: &Account,
        payload: &RegisterHumanPayload,
    ) -> anyhow::Result<ExecutionFinalResult> {
        let res = caller
        .call(self.registry.id(), "is_human_call")
        .args_json(json!({"ctr": self.human_checker.id(), "function": REGISTER_HUMAN_TOKEN, "payload": serde_json::to_string(payload).unwrap()}))
        .max_gas()
        .transact()
        .await?;
        println!(">>> is_human_call logs {:?}\n", res.logs());
        Ok(res)
    }

    pub async fn is_human_call_lock(
        &self,
        caller: &Account,
        lock_duration: u64,
        payload: &VotePayload,
    ) -> anyhow::Result<ExecutionFinalResult> {
        let res = caller
        .call(self.registry.id(), "is_human_call_lock")
        .args_json(json!({"ctr": self.human_checker.id(), "function": "vote", "payload": serde_json::to_string(payload).unwrap(), "lock_duration": lock_duration, "with_proof": false}))
        .max_gas()
        .transact()
        .await?;
        println!(">>> is_human_call_lock logs {:?}\n", res.logs());
        Ok(res)
    }

    pub async fn query_sbts(&self, user: &Account) -> anyhow::Result<Option<SBTs>> {
        // check the key does not exists in human checker
        let r = self
            .human_checker
            .call("recorded_sbts")
            .args_json(json!({"user": user.id()}))
            .max_gas()
            .transact()
            .await?;
        let result: Option<SBTs> = r.json()?;
        Ok(result)
    }
}

async fn init(
    worker: &Worker<Sandbox>,
) -> anyhow::Result<(Contract, Contract, Account, Account, Account, Account)> {
    // import the contract from mainnet
    let registry = worker
        .dev_deploy(include_bytes!("../../res/registry.wasm"))
        .await?;
    let human_checker = worker
        .dev_deploy(include_bytes!("../../res/human_checker.wasm"))
        .await?;

    let authority = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let john = worker.dev_create_account().await?;

    // init the contracts
    let res1 = registry
        .call("new")
        .args_json(json!({"authority": authority.id(),
                   "iah_issuer": iah_issuer.id(), "iah_classes": [1],
                   "authorized_flaggers": vec![auth_flagger.id()]}))
        .max_gas()
        .transact();

    let res2 = human_checker
        .call("new")
        .args_json(json!({"registry": registry.id()}))
        .max_gas()
        .transact();

    assert!(res1.await?.is_success() && res2.await?.is_success());

    // add iah_issuer
    let res = authority
        .call(registry.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": iah_issuer.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // populate registry with mocked data
    let iah_token_spec = vec![
        (
            alice.id(),
            vec![TokenMetadata {
                class: 1,
                issued_at: Some(0),
                expires_at: None,
                reference: None,
                reference_hash: None,
            }],
        ),
        (
            bob.id(),
            vec![TokenMetadata {
                class: 2,
                issued_at: Some(0),
                expires_at: None,
                reference: None,
                reference_hash: None,
            }],
        ),
    ];

    let res = iah_issuer
        .call(registry.id(), "sbt_mint")
        .args_json(json!({ "token_spec": iah_token_spec }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok((
        registry,
        human_checker.clone(),
        alice,
        bob,
        john,
        iah_issuer,
    ))
}

#[tokio::test]
async fn is_human_call() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, human_checker, alice, bob, john, issuer) = init(&worker).await?;
    let issuer_id = near_sdk::AccountId::try_from(issuer.id().as_str().to_owned())?;

    let payload = RegisterHumanPayload {
        memo: "registering alice".to_owned(),
        numbers: vec![2, 3, 5, 7, 11],
    };

    let suite = Suite {
        registry,
        human_checker,
    };

    // Call using Alice. Should register tokens, because Alice is a human
    let r = suite.is_human_call(&alice, &payload).await?;
    assert!(r.is_success());
    let result: bool = r.json()?; // the final receipt is register_human_token, which return boolean
    assert!(result, "should register tokens to alice");

    let mut tokens = suite.query_sbts(&alice).await?;
    assert_eq!(tokens, Some(vec![(issuer_id, vec![1])]));

    // call the is_human_call method with bob (has sbts but not a human)
    // should panic in the human_checker
    let r = suite.is_human_call(&bob, &payload).await?;
    assert!(r.is_failure());

    tokens = suite.query_sbts(&bob).await?;
    assert_eq!(tokens, None);

    // call the is_human_call method john (doesn't have sbts)
    // should panic in the registry
    let r = suite.is_human_call(&john, &payload).await?;
    assert!(r.is_failure());

    tokens = suite.query_sbts(&john).await?;
    assert_eq!(tokens, None);

    //
    // Test Vote with lock duration
    //

    //
    // test1: too short lock duration: should fail
    let mut payload = VotePayload{prop_id: 10, vote: "approve".to_string()};
    let r = suite.is_human_call_lock(&alice, VOTING_DURATION / 3 *2,  &payload).await?;
    assert!(r.is_failure());
    let failure_str = format!("{:?}",r.failures());
    assert!(failure_str.contains("sufficient amount of time"), "{}", failure_str);

    //
    // test2: second call, should not change
    let r = suite.is_human_call_lock(&alice, VOTING_DURATION / 3*2,  &payload).await?;
    assert!(r.is_failure());
    let failure_str = format!("{:?}",r.failures());
    assert!(failure_str.contains("sufficient amount of time"), "{}", failure_str);

    //
    // test3: longer call should be accepted, but should fail on wrong payload (vote option)
    payload.vote = "wrong-wrong".to_string();
    let r = suite.is_human_call_lock(&alice, VOTING_DURATION +MSECOND,  &payload).await?;
    assert!(r.is_failure());
    let failure_str = format!("{:?}",r.failures());
    assert!(failure_str.contains("invalid vote: must be either"), "{}", failure_str);

    //
    // test4: should work with correct input
    payload.vote = "approve".to_string();
    let r = suite.is_human_call_lock(&alice, VOTING_DURATION +MSECOND,  &payload).await?;
    assert!(r.is_success());

    //
    // test5: should fail with not a human
    let r = suite.is_human_call_lock(&john, VOTING_DURATION + MSECOND,  &payload).await?;
    assert!(r.is_failure());
    let failure_str = format!("{:?}",r.failures());
    assert!(failure_str.contains("is not a human"), "{}", failure_str);

    Ok(())
}

'''
'''--- contracts/kudos/Cargo.toml ---
[package]
name = "kudos-contract"
version = "0.1.0"
authors = [
    "NDC GWG (https://near.social/#/mob.near/widget/ProfilePage?accountId=govworkinggroup.near)",
]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk.workspace = true
near-contract-standards.workspace = true
cid.workspace = true

[dev-dependencies]
assert_matches.workspace = true
near-workspaces.workspace = true
near-sandbox-utils.workspace = true
near-units.workspace = true
tokio.workspace = true
anyhow.workspace = true
test-util = { path = "../test-util" }

'''
'''--- contracts/kudos/README.md ---
# Kudos

Kudos contract for NDC

## Setup [Testnet]

- Init contract

  ```sh
  near call $CONRTACT_ID init '{"iah_registry": "registry-unstable.i-am-human.testnet"}' --accountId YOUR_ACCOUNT.testnet
  near call $CONRTACT_ID set_external_db '{"external_db_id": "v1.social08.testnet"}' --accountId YOUR_ACCOUNT.testnet --amount 5
  ```

- Deploy it on testnet

  ```sh
  near dev-deploy target/wasm32-unknown-unknown/release/kudos_contract.wasm
  ```

## Public methods

### Give kudos

Enables the caller to award kudos to a recipient's account.

#### Requirements

User must be human verified (should have a valid i-am-human SBT)
Minimum gas required: 67 TGas (300 TGas recommended)
Deposit required: 0.1 

#### Interface

```js
give_kudos(receiver_id, message, icon_cid, hashtags): kudos id

- receiver_id: user's account id that should be awarded the kudos
- message: comment message on the kudos. Max character limit is 1000
- icon_cid: optional valid CID for icon (image) at ipfs
- hashtags: optional array of user-specified tags (limited to 32 characters by default, and allows to use only alphanumeric characters, underscores and gyphens). By default maximum allowed number of hashtags is 10
```

#### Output

Returns unique kudos identifier or panics with an error message

Example JSON written to SocialDB:

```js
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "created_at": "1689976833613",
          "sender_id": "alex.near",
          "kind": "k",
          "message": "that user is awesome",
          "icon": "bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa",
          "upvotes": {},
          "comments": {},
          "tags": "[\"firstkudos\",\"awesomework\"]",
        }
      }
    },
    "hashtags": {
      "firstkudos": {
        "1": "alex.near"
      },
      "awesomework": {
        "1": "alex.near"
      }
    }
  }
}
```

### Upvote kudos

Allows caller to upvote kudos by unique id granted to a receiver account

#### Requirements

- User must be human verified (should have a valid i-am-human SBT)
- Caller can't be a account which granted kudos
- Caller can't be a receiver account
- Caller could upvote specified kudos only once
- Minimum gas required: 92 TGas (300 TGas recommended)
- Deposit required: 0.004 

#### Interface

```js
upvote_kudos(receiver_id, kudos_id): timestamp

- receiver_id: user's account id whos unique kudos should be upvoted
- kudos_id: unique kudos identified granted to a receiver account
```

#### Output

Returns stringified timestamp of block when kudos was upvoted or panics with an error message

Example JSON written to SocialDB:

```js
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "upvotes": {
            "bob.near": ""
          }
        }
      }
    }
  }
}
```

### Leave commentary message to kudos

Allows caller to leave a commentary message to kudos by unique id granted to a receiver account

#### Requirements

- User must be human verified (should have a valid i-am-human SBT)
- User can't leave a comment for his kudos, but it can reply to other comments
- Minimum gas required: 92 TGas (300 TGas recommended)
- Deposit required: 0.017 

#### Interface

```js
leave_comment(receiver_id, kudos_id, parent_comment_id, message): commentary id

- receiver_id: user's NEAR account id whos unique kudos should be upvoted
- kudos_id: unique kudos identified granted to a receiver NEAR account
- parent_comment_id: optional parent commentary id which this new comment is a reply for. By default, if not specified, every commentary relates to kudos id
- message: followed commentary message text to the kudos. By default limits to 1000 characters
```

#### Output

Returns unique commentary identifier or panics with an error message

Example JSON written to SocialDB:

```js
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "comments": {
            "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
          }
        }
      }
    }
  }
}
```

### Exchange upvoted kudos for ProofOfKudos SBT

Allows caller to exchange his upvoted kudos by unique id for a ProofOfKudos SBT

#### Requirements

- User must be human verified (should have minted and valid i-am-human SBT)
- Caller should be granted with kudos by provided unique identifier
- Caller can exchange his upvoted kudos only once
- Kudos should have minimum required number of upvotes. By default is 3 upvotes
- Minimum gas required: 87 TGas (300 TGas recommended)
- Deposit required: 0.008 

#### Interface

```js
exchange_kudos_for_sbt(kudos_id): array of minted SBTs

- kudos_id: unique kudos identified granted to a caller account
```

#### Output

Returns an array of minted ProofOfKudos SBTs in exchange for kudos or panics with an error message

'''
'''--- contracts/kudos/clippy.toml ---
too-many-arguments-threshold = 10
'''
'''--- contracts/kudos/src/callbacks/common.rs ---
use crate::{Contract, ContractExt};
use near_sdk::{env, near_bindgen};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn on_failure(&mut self, error: String) {
        env::panic_str(&error)
    }
}

'''
'''--- contracts/kudos/src/callbacks/exchange_kudos_for_sbt.rs ---
use super::utils::parse_kudos_and_verify_if_allowed_to_exchange;
use crate::consts::*;
use crate::external_db::ext_db;
use crate::registry::{ext_sbtreg, TokenId};
use crate::settings::Settings;
use crate::types::KudosId;
use crate::utils::*;
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {

    /// This function is used to acquire number of upvotes, if successful and user have enough upvotes
    /// sbt minting process will be initiated else return deposit
    #[private]
    pub fn acquire_number_of_upvotes(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() result: Not a human".to_owned());
                }

                let receiver_id = env::signer_account_id();
                let root_id = env::current_account_id();
                let kudos_upvotes_path =
                    build_kudos_upvotes_path(&root_id, &receiver_id, &kudos_id);
                let acquire_upvotes_req = [&kudos_upvotes_path, "/*"].concat();
                let kudos_kind_path = build_kudos_kind_path(&root_id, &receiver_id, &kudos_id);

                let upvotes_acquired_callback_gas = KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS
                    + PROOF_OF_KUDOS_SBT_MINT_GAS
                    + PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                let acquire_upvotes_gas = env::prepaid_gas()
                    - (ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS + upvotes_acquired_callback_gas);

                Ok(ext_db::ext(external_db_id)
                    .with_static_gas(acquire_upvotes_gas)
                    .get(vec![acquire_upvotes_req, kudos_kind_path.clone()], None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(upvotes_acquired_callback_gas)
                            .on_kudos_upvotes_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                kudos_id,
                                kudos_upvotes_path,
                                kudos_kind_path,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    /// Callback for fetching data from kudos upvotes
    #[private]
    pub fn on_kudos_upvotes_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        kudos_upvotes_path: String,
        kudos_kind_path: String,
        #[callback_result] kudos_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;
        let settings = Settings::from(&self.settings);

        match parse_kudos_and_verify_if_allowed_to_exchange(
            kudos_result,
            kudos_upvotes_path,
            kudos_kind_path,
            settings.min_number_of_upvotes_to_exchange_kudos as usize,
        )
        .and_then(|_| {
            let issued_at = env::block_timestamp_ms();
            let expires_at = settings.acquire_pok_sbt_expire_at_ts(issued_at)?;

            Ok(build_pok_sbt_metadata(issued_at, expires_at))
        }) {
            Ok(metadata) => {
                self.exchanged_kudos.insert(kudos_id.clone());

                ext_sbtreg::ext(self.iah_registry.clone())
                    .with_attached_deposit(PROOF_OF_KUDOS_SBT_MINT_COST)
                    .with_static_gas(PROOF_OF_KUDOS_SBT_MINT_GAS)
                    .sbt_mint(vec![(env::signer_account_id(), vec![metadata])])
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(
                                PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS + FAILURE_CALLBACK_GAS,
                            )
                            .on_pok_sbt_mint(
                                predecessor_account_id,
                                attached_deposit.into(),
                                kudos_id,
                            ),
                    )
            }
            Err(e) => {
                // Return leave comment deposit back to sender if failed
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(e),
                    )
            }
        }
    }

    /// This function handles callback from proof of kudos sbt mint.
    /// Returns deposit amount if failed
    #[private]
    #[handle_result]
    pub fn on_pok_sbt_mint(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<u64>, PromiseError>,
    ) -> Result<PromiseOrValue<Vec<u64>>, &'static str> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(minted_tokens_ids) if minted_tokens_ids.is_empty() => {
                // If IAHRegistry contract succeeds but returns an empty tokens list,
                // we treat is an unexpected failure and panic. No user deposit returns for this case.
                Err("IAHRegistry::sbt_mint() responses with an empty tokens array")
            }
            Ok(minted_tokens_ids) => Ok(PromiseOrValue::Value(minted_tokens_ids)),
            Err(e) => {
                // If tokens weren't minted, remove kudos from exchanged table
                self.exchanged_kudos.remove(&kudos_id);

                // Return deposit back to sender if IAHRegistry::sbt_mint fails
                Ok(Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("IAHRegistry::sbt_mint() call failure: {:?}", e)),
                    )
                    .into())
            }
        }
    }
}

'''
'''--- contracts/kudos/src/callbacks/give_kudos.rs ---
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::KudosId;
use crate::{consts::*, Hashtag, KudosKind};
use crate::{utils::*, WrappedCid};
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {

    /// This function is used to save kudos to near social,
    /// if it fails return deposit
    #[private]
    pub fn save_kudos(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kind: KudosKind,
        message: String,
        icon_cid: Option<WrappedCid>,
        hashtags: Option<Vec<Hashtag>>,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let sender_id = env::signer_account_id();
                let root_id = env::current_account_id();
                let created_at = env::block_timestamp_ms();
                let kudos_id = KudosId::from(self.last_incremental_id.inc());
                let kudos_json = build_give_kudos_request(
                    &root_id,
                    &sender_id,
                    &receiver_id,
                    &kudos_id,
                    created_at,
                    kind,
                    &message,
                    icon_cid.as_ref(),
                    hashtags.as_deref(),
                )?;

                let save_kudos_gas = env::prepaid_gas()
                    - (SAVE_KUDOS_RESERVED_GAS + KUDOS_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS);

                Ok(ext_db::ext(external_db_id)
                    .with_static_gas(save_kudos_gas)
                    .with_attached_deposit(attached_deposit)
                    .set(kudos_json)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_kudos_saved(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                kudos_id,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    /// This is callback function after kudos is saved,
    /// if it fails return deposit
    #[private]
    pub fn on_kudos_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<KudosId> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(kudos_id),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- contracts/kudos/src/callbacks/leave_comment.rs ---
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::{CommentId, KudosId};
use crate::utils::*;
use crate::{consts::*, EncodedCommentary};
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {
    
    /// This function is used to acquire kudos info, if successful callback for acquire_kudos is called
    /// if it fails return deposit
    #[private]
    pub fn acquire_kudos_info(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kudos_id: KudosId,
        parent_comment_id: Option<CommentId>,
        comment: EncodedCommentary,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let root_id = env::current_account_id();
                let comment_id = CommentId::from(self.last_incremental_id.inc());
                let leave_comment_req = build_leave_comment_request(
                    &root_id,
                    &receiver_id,
                    &kudos_id,
                    &comment_id,
                    &comment,
                )?;
                let get_kudos_by_id_req =
                    build_get_kudos_by_id_request(&root_id, &receiver_id, &kudos_id);
                let mut get_req = vec![get_kudos_by_id_req.clone()];

                if let Some(comment_id) = parent_comment_id.as_ref() {
                    get_req.push(build_get_kudos_comment_by_id_request(
                        &root_id,
                        &receiver_id,
                        &kudos_id,
                        comment_id,
                    ));
                }

                // Compute minimum required gas and split the remaining gas by two equal parts for
                // NEAR Social db subsequent calls
                let get_kudos_by_id_gas = (env::prepaid_gas()
                    - (ACQUIRE_KUDOS_INFO_RESERVED_GAS
                        + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
                        + KUDOS_COMMENT_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS))
                    / 2;
                let get_kudos_by_id_callback_gas = get_kudos_by_id_gas
                    + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
                    + KUDOS_COMMENT_SAVED_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                Ok(ext_db::ext(external_db_id.clone())
                    .with_static_gas(get_kudos_by_id_gas)
                    .get(get_req, None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(get_kudos_by_id_callback_gas)
                            .on_kudos_info_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                external_db_id,
                                get_kudos_by_id_req,
                                leave_comment_req,
                                parent_comment_id,
                                comment_id,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    /// This is callback function for kudos info,
    /// if it fails return deposit
    #[private]
    pub fn on_kudos_info_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        get_kudos_by_id_req: String,
        leave_comment_req: Value,
        parent_comment_id: Option<CommentId>,
        comment_id: CommentId,
        #[callback_result] callback_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let Err(e) = callback_result
            .map_err(|e| {
                format!(
                    "SocialDB::get({get_kudos_by_id_req}) call failure: {e:?}"
                )
            })
            .and_then(|mut kudos_by_id_res| {
                if let Some(comment_id) = parent_comment_id.as_ref() {
                    // We do not verify if extracted base64-encoded commentary is valid, we assume 
                    // that data stored in social db is not corrupted.
                    let _ = extract_kudos_encoded_comment_by_id_from_response(&get_kudos_by_id_req, comment_id, &mut kudos_by_id_res)
                        .ok_or_else(|| {
                            "Unable to verify parent commentary id".to_owned()
                        })?;
                }

                extract_kudos_id_sender_from_response(&get_kudos_by_id_req, &mut kudos_by_id_res)
                    .ok_or_else(|| {
                        "Unable to acquire a Kudos sender account id".to_owned()
                    })
            }) else {
                let gas_left = env::prepaid_gas()
                    - (KUDOS_INFO_ACQUIRED_CALLBACK_GAS + KUDOS_COMMENT_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS);

                return ext_db::ext(external_db_id)
                    .with_attached_deposit(attached_deposit)
                    .with_static_gas(gas_left)
                    .set(leave_comment_req)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_COMMENT_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_commentary_saved(
                                predecessor_account_id,
                                attached_deposit.into(),
                                comment_id,
                            ),
                    );
            };

        // Return leave comment deposit back to sender if failed
        Promise::new(predecessor_account_id)
            .transfer(attached_deposit)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(FAILURE_CALLBACK_GAS)
                    .on_failure(e),
            )
    }

    /// This is callback funtion when kudos is acquired,
    /// If not deposit will be refunded
    #[private]
    pub fn on_commentary_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        comment_id: CommentId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<CommentId> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(comment_id),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- contracts/kudos/src/callbacks/mod.rs ---
mod common;
mod exchange_kudos_for_sbt;
mod give_kudos;
mod leave_comment;
mod upvote_kudos;
mod utils;

'''
'''--- contracts/kudos/src/callbacks/upvote_kudos.rs ---
use crate::consts::*;
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::KudosId;
use crate::utils::*;
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::json_types::U64;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {

    /// This funtion is used to acquire kudos info,
    /// If failed deposit will be refunded
    #[private]
    pub fn acquire_kudos_sender(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let root_id = env::current_account_id();
                let sender_id = env::signer_account_id();
                let upvote_kudos_req =
                    build_upvote_kudos_request(&root_id, &sender_id, &receiver_id, &kudos_id)?;
                let get_kudos_by_id_req =
                    build_get_kudos_by_id_request(&root_id, &receiver_id, &kudos_id);

                // Compute minimum required gas and split the remaining gas by two equal parts for
                // NEAR Social db subsequent calls
                let get_kudos_by_id_gas = (env::prepaid_gas()
                    - (ACQUIRE_KUDOS_SENDER_RESERVED_GAS
                        + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                        + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS))
                    / 2;
                let get_kudos_by_id_callback_gas = get_kudos_by_id_gas
                    + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                    + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                Ok(ext_db::ext(external_db_id.clone())
                    .with_static_gas(get_kudos_by_id_gas)
                    .get(vec![get_kudos_by_id_req.clone()], None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(get_kudos_by_id_callback_gas)
                            .on_kudos_sender_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                external_db_id,
                                get_kudos_by_id_req,
                                upvote_kudos_req,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    /// This is callback funtion for kudos info,
    /// If failed deposit will be refunded
    #[private]
    pub fn on_kudos_sender_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        get_kudos_by_id_req: String,
        upvote_kudos_req: Value,
        #[callback_result] callback_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let Err(e) = callback_result
            .map_err(|e| format!("SocialDB::get({get_kudos_by_id_req}) call failure: {e:?}"))
            .and_then(|mut kudos_by_id_res| {
                match extract_kudos_id_sender_from_response(&get_kudos_by_id_req, &mut kudos_by_id_res) {
                    Some(sender_id) if sender_id == env::signer_account_id() => {
                        Err("User is not eligible to upvote this kudos".to_owned())
                    }
                    Some(_) => Ok(()),
                    None => Err("Unable to acquire a Kudos sender account id".to_owned())
                }
            }) else {
                let gas_left = env::prepaid_gas()
                    - (KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                        + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS);

                return ext_db::ext(external_db_id)
                    .with_attached_deposit(attached_deposit)
                    .with_static_gas(gas_left)
                    .set(upvote_kudos_req)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_UPVOTE_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_kudos_upvote_saved(
                                predecessor_account_id,
                                attached_deposit.into(),
                            ),
                    );
            };

        // Return upvote kudos deposit back to sender if failed
        Promise::new(predecessor_account_id)
            .transfer(attached_deposit)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(FAILURE_CALLBACK_GAS)
                    .on_failure(e),
            )
    }

    /// Once kudos is acquired use it to upvote
    /// If failed deposit will be refunded
    #[private]
    pub fn on_kudos_upvote_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<U64> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(env::block_timestamp_ms().into()),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- contracts/kudos/src/callbacks/utils.rs ---
use crate::{utils::*, KudosKind};
use near_sdk::serde_json::{self, Value};
use near_sdk::{AccountId, PromiseError};
use std::collections::HashMap;

pub fn parse_kudos_and_verify_if_allowed_to_exchange(
    res: Result<Value, PromiseError>,
    kudos_upvotes_path: String,
    kudos_kind_path: String,
    required_min_number_of_upvotes: usize,
) -> Result<(), String> {
    let mut kudos_json = res.map_err(|e| {
        format!("SocialDB::get({kudos_upvotes_path}/*,{kudos_kind_path}) call failure: {e:?}")
    })?;

    let kudos_kind = match remove_key_from_json(&mut kudos_json, &kudos_kind_path) {
        Some(kudos_kind_raw) => serde_json::from_value::<KudosKind>(kudos_kind_raw.clone())
            .map_err(|e| format!("Failed to parse kudos kind type `{kudos_kind_raw:?}`: {e:?}"))?,
        None => KudosKind::Kudos,
    };

    if kudos_kind == KudosKind::Ding {
        return Err("Dings can't be exchanged".to_owned());
    }

    let upvotes_raw = remove_key_from_json(&mut kudos_json, &kudos_upvotes_path)
        .ok_or_else(|| format!("No upvotes found for kudos: {kudos_json:?}"))?;

    let upvoters = serde_json::from_value::<HashMap<AccountId, Value>>(upvotes_raw.clone())
        .map_err(|e| format!("Failed to parse kudos upvotes data `{upvotes_raw:?}`: {e:?}"))?;

    let number_of_upvotes = upvoters.keys().len();

    if number_of_upvotes < required_min_number_of_upvotes {
        Err(format!(
            "Minimum required number ({}) of upvotes has not been reached",
            required_min_number_of_upvotes
        ))
    } else {
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::{build_kudos_kind_path, build_kudos_upvotes_path};
    use crate::{IncrementalUniqueId, KudosId};
    use near_sdk::serde_json::json;
    use near_sdk::test_utils::accounts;

    #[test]
    fn test_parse_kudos_and_verify_upvotes() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        let receiver_id = accounts(0);
        let kudos_upvotes_path = build_kudos_upvotes_path(&root_id, &receiver_id, &kudos_id);
        let kudos_kind_path = build_kudos_kind_path(&root_id, &receiver_id, &kudos_id);

        struct TestCase<'a> {
            name: &'a str,
            input: Result<Value, PromiseError>,
            output: &'a str,
        }

        let test_cases = [
            TestCase {
                name: "Dings exchange",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "d",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Dings can't be exchanged",
            },
            TestCase {
                name: "Minimum upvotes requirement",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "k",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Minimum required number (3) of upvotes has not been reached",
            },
            TestCase {
                name: "Upvotes parse failure",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "upvotes": "invalid_data"
                          }
                        }
                      }
                    }
                })),
                output: "Failed to parse kudos upvotes data `String(\"invalid_data\")`: Error(\"invalid type: string \\\"invalid_data\\\", expected a map\", line: 0, column: 0)",
            },
            TestCase {
                name: "Unknown kudos kind",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "unknown",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Failed to parse kudos kind type `String(\"unknown\")`: Error(\"unknown variant `unknown`, expected `k` or `d`\", line: 0, column: 0)",
            },
            TestCase {
                name: "Invalid response",
                input: Ok(json!({})),
                output: "No upvotes found for kudos: Object {}",
            },
            TestCase {
                name: "Promise error",
                input: Err(near_sdk::PromiseError::Failed),
                output: "SocialDB::get(kudos.near/kudos/alice/1/upvotes/*,kudos.near/kudos/alice/1/kind) call failure: Failed",
            },
        ];

        for test_case in test_cases {
            assert_eq!(
                parse_kudos_and_verify_if_allowed_to_exchange(
                    test_case.input,
                    kudos_upvotes_path.clone(),
                    kudos_kind_path.clone(),
                    3
                )
                .unwrap_err()
                .as_str(),
                test_case.output,
                "Test case `{} failure`",
                test_case.name
            );
        }
    }
}

'''
'''--- contracts/kudos/src/consts.rs ---
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::{Balance, Gas, StorageUsage};

pub(crate) const U64_STORAGE: StorageUsage = 8;
pub(crate) const U8_STORAGE: StorageUsage = 1;

/// Every contract storage key/value entry always uses 40 bytes when stored via `env::storage_write`
/// - key len as u64,
/// - key ptr as u64,
/// - value len as u64,
/// - value ptr as u64,
/// - register as u64
pub(crate) const STORAGE_ENTRY: StorageUsage = 5 * U64_STORAGE;

/// enum::StorageKey size [1 byte]
const ENUM_STORAGE_KEY: StorageUsage = U8_STORAGE;

/// Internal class id of ProofOfKudos SBT used by i-am-human-registry for this smart contract
pub const PROOF_OF_KUDOS_SBT_CLASS_ID: u64 = 1;

/// Required  deposit to mint ProofOfKudos SBT by i-am-human-registry smart contract
///
/// This value should be updated if mentioned contract will require different amount of deposit
pub const PROOF_OF_KUDOS_SBT_MINT_COST: Balance = 9_000_000_000_000_000_000_000;

/// Required storage to memorise exchanged [`KudosId`] in [`LookupSet`] of this smart contract storage
///
/// The [`KudosId`] is represented by [`u64`] value which is serialized to 8 bytes plus [`STORAGE_ENTRY`] required
/// to store anything in contract storage
pub const EXCHANGE_KUDOS_STORAGE: StorageUsage = STORAGE_ENTRY + ENUM_STORAGE_KEY + U64_STORAGE;

/// Deposit required to exchange upvoted Kudos for ProofOfKudos SBT
///
/// This value includes a storage amount required to memorise exchanged [`KudosId`] and
/// the minting cost of a ProofOfKudos SBT by i-am-human-registry smart contract. This value
/// should be changed if any of the above will be changed
pub const EXCHANGE_KUDOS_COST: Balance =
    EXCHANGE_KUDOS_STORAGE as Balance * STORAGE_PRICE_PER_BYTE + PROOF_OF_KUDOS_SBT_MINT_COST;

/// Required storage for this contract registered as user at SocialDB to grant write permission to IAH Registry contract
///
/// This value was pre-computed by using maximum (64 characters) account id length for IAH Registry and this contracts.
pub const SOCIAL_DB_GRANT_WRITE_PERMISSION_COST: Balance = 3_100_000_000_000_000_000_000;

/// Deposit required to give kudos to user.
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// grants kudos with maximum provided commentary text length (1000 escaped ascii characters),
/// icon CID for ipfs and maximum number of allowed hashtags (10) with a hashtag of maximum
/// text length (limited to 32 characters, and allows to use only alphanumeric ascii characters, underscores and gyphens)
/// to a user with maximum account name length (64 characters). The exact value of this computation is 0.0961  and
/// it is rounded to 0.1 . This value should be recomputed if the above restrications will be changed.
pub const GIVE_KUDOS_COST: Balance = 100_000_000_000_000_000_000_000; // 0.1  (0.09802)

/// Deposit required to leave a commentary message for kudos
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// leaves a commentary message text with maximum length (1000 escaped ascii characters)
/// to a user with maximum account name length (64 characters). The exact value of this computation when
/// no parent commentary id provided is 0.01653  and it is rounded to 0.017 . This value should be recomputed
/// if the above restrications will be changed.
pub const LEAVE_COMMENT_COST: Balance = 17_000_000_000_000_000_000_000; // 0.017  (0.01653 when no parent commentary id)

/// Deposit required to upvote kudos
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// upvotes kudos. The exact value of this computation is 0.00311  and it is rounded to 0.004 .
/// This value should be recomputed if the above restrications will be changed.
pub const UPVOTE_KUDOS_COST: Balance = 4_000_000_000_000_000_000_000; // 0.004  (0.00311)

/// Gas reserved for final failure callback which panics if one of the callback fails.
pub const FAILURE_CALLBACK_GAS: Gas = Gas(5 * Gas::ONE_TERA.0);

/// Gas required for a [`save_kudos`](kudos_contract::callbacks::give_kudos::ContractExt::save_kudos) callback
pub const SAVE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_saved`](kudos_contract::callbacks::give_kudos::ContractExt::on_kudos_saved) callback
pub const KUDOS_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub const GIVE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_kudos_sender`](kudos_contract::callbacks::upvote_kudos::ContractExt::acquire_kudos_sender) callback
pub const ACQUIRE_KUDOS_SENDER_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_sender_acquired`](kudos_contract::callbacks::upvote_kudos::ContractExt::on_kudos_sender_acquired) callback
pub const KUDOS_SENDER_ACQUIRED_CALLBACK_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_upvote_saved`](kudos_contract::callbacks::upvote_kudos::ContractExt::on_kudos_upvote_saved) callback
pub const KUDOS_UPVOTE_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`upvote_kudos`](kudos_contract::public::Contract::upvote_kudos)
pub const UPVOTE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_kudos_info`](kudos_contract::callbacks::leave_comment::ContractExt::acquire_kudos_info) callback
pub const ACQUIRE_KUDOS_INFO_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_info_acquired`](kudos_contract::callbacks::leave_comment::ContractExt::on_kudos_info_acquired) callback
pub const KUDOS_INFO_ACQUIRED_CALLBACK_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_commentary_saved`](kudos_contract::callbacks::leave_comment::ContractExt::on_commentary_saved) callback
pub const KUDOS_COMMENT_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`leave_comment`](kudos_contract::public::Contract::leave_comment)
pub const LEAVE_COMMENT_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_number_of_upvotes`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::acquire_number_of_upvotes) callback
pub const ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_upvotes_acquired`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::on_kudos_upvotes_acquired) callback
pub const KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas required for a [`sbt_mint`](kudos_contract::registry::ExtSbtRegistry::sbt_mint) cross contract call
pub const PROOF_OF_KUDOS_SBT_MINT_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas required for a [`on_pok_sbt_mint`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::on_pok_sbt_mint) callback
pub const PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`exchange_kudos_for_sbt`](kudos_contract::public::Contract::exchange_kudos_for_sbt)
pub const EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required minimum for `get` and `set` methods of NEAR social db smart contract.
///
/// All remainder gas will be passed additionally for these calls.
pub const SOCIAL_DB_REQUEST_MIN_RESERVED_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);

'''
'''--- contracts/kudos/src/contract.rs ---
use crate::external_db::ext_db;
use crate::misc::RunningState;
use crate::settings::{Settings, SettingsView, VSettings};
use crate::types::{KudosId, StorageKey};
use crate::utils::build_initial_json_for_socialdb;
use crate::IncrementalUniqueId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::store::LookupSet;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise, PromiseError,
    ONE_YOCTO,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// A valid [`AccountId`] which represents a contract's owner/admin
    pub(crate) owner_id: AccountId,
    /// Contract's state [`RunningState`], e.g. running, paused
    pub(crate) running_state: RunningState,
    /// Last unique incremenetal identifier [`IncrementalUniqueId`] used to get next incremented unique [`KudosId`] and [`CommentId`]
    pub(crate) last_incremental_id: IncrementalUniqueId,
    /// A valid [`AccountId`] of NEAR social db smart contract, should be set by calling `set_external_db` method.
    /// Used to store and read saved kudos information.
    pub(crate) external_db_id: Option<AccountId>,
    /// A valid [`AccountId`] of i-am-human-registry smart contract, set during a contract initialization.
    /// Used to check for humanity and to exchange upvoted kudos for a ProofOfKudos SBT
    pub(crate) iah_registry: AccountId,
    /// Upgradable [`VSettings`] for this smart contract, which represents some configurable settings,
    /// e.g. max commentary message length, etc.
    pub(crate) settings: VSettings,
    /// [`LookupSet`] of unique [`KudosId`] to memorise exchanged kudos for ProofOfKudos SBT.
    /// Used to guarantee upvotes kudos to be exchanged only once.
    pub(crate) exchanged_kudos: LookupSet<KudosId>,
}

#[near_bindgen]
impl Contract {
    /// Initializes contract with default values, allows to set a valid [`AccountId`] as an owner of a contract initially.
    /// Requires a valid [`AccountId`] for i-am-human-registry smart contract.
    #[init]
    pub fn init(owner_id: Option<AccountId>, iah_registry: AccountId) -> Self {
        Self {
            owner_id: owner_id.unwrap_or_else(env::predecessor_account_id),
            running_state: RunningState::Running,
            last_incremental_id: IncrementalUniqueId::default(),
            external_db_id: None,
            iah_registry,
            settings: Settings::default().into(),
            exchanged_kudos: LookupSet::new(StorageKey::Kudos),
        }
    }

    /// Replaces [`AccountId`] of i-am-human-registry smart contract which is used to verify humanity and
    /// to exchange kudos for ProofOfKudos SBT. Restricted to be used only by an owner/admin of this contract.
    #[payable]
    #[handle_result]
    pub fn update_iah_registry(&mut self, iah_registry: AccountId) -> Result<Promise, String> {
        self.assert_owner();

        let external_db_id = self.external_db_id()?.clone();

        self.grant_write_permission(external_db_id, iah_registry, env::attached_deposit())
    }

    /// Sets [`AccoundId`] of NEAR social db smart contract as an external storage for kudos.
    /// Restricted to be used only by an owner/admin of this contract.
    #[payable]
    #[handle_result]
    pub fn set_external_db(&mut self, external_db_id: AccountId) -> Result<Promise, &'static str> {
        self.assert_owner();
        // Do not allow to change SocialDB address, because there is no data migration possible.
        // It should be initialized only once.
        require!(
            self.external_db_id.is_none(),
            "External database already set"
        );

        let root_id = env::current_account_id();
        let initial_json = build_initial_json_for_socialdb(&root_id)?;

        // This will require a minimum amount of deposit to register a user for Kudos contract.
        // Minimum amount of deposit required could be priorly acquired by calling a view method
        // `storage_balance_bounds` to Social-Db contract and one yocto additionally should be added
        // to request `grant_write_permission` method
        Ok(ext_db::ext(external_db_id.clone())
            .with_attached_deposit(env::attached_deposit() - ONE_YOCTO)
            .set(initial_json)
            .then(Self::ext(env::current_account_id()).on_ext_db_init(external_db_id, ONE_YOCTO)))
    }

    /// Public view method to read current settings [`SettingsView`] of this contract
    pub fn view_settings(&self) -> SettingsView {
        Settings::from(&self.settings).into()
    }

    /// Updates specified settings [`SettingsView`] for this smart contract.
    /// Restricted to be used only by an owner/admin of this contract.
    #[payable]
    pub fn update_settings(&mut self, settings_json: SettingsView) {
        self.assert_owner();

        self.settings = self.settings.apply_changes(settings_json);
    }

    /// Internal helper method to grant write permission to IAH Registry
    ///
    /// Write permissions required to be able to use `IAHRegistry::is_human_call`, because SocialDB checks for a predecessor_id.
    ///
    /// ATTENTION: `is_human_call` is not being used by this smart contract right now, but we still want to be able
    /// to use it in future, so the code below is necessary.
    fn grant_write_permission(
        &mut self,
        external_db_id: AccountId,
        iah_registry: AccountId,
        deposit: Balance,
    ) -> Result<Promise, String> {
        Ok(ext_db::ext(external_db_id.clone())
            .with_attached_deposit(deposit)
            .grant_write_permission(
                Some(iah_registry.clone()),
                None,
                vec![format!("{}", env::current_account_id())],
            )
            .then(
                Self::ext(env::current_account_id())
                    .on_ext_db_write_permission_granted(external_db_id, iah_registry),
            ))
    }

    #[private]
    #[handle_result]
    pub fn on_ext_db_init(
        &mut self,
        external_db_id: AccountId,
        deposit: Balance,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> Result<Promise, String> {
        callback_result.map_err(|e| format!("SocialDB::set() call failure: {:?}", e))?;

        self.grant_write_permission(external_db_id, self.iah_registry.clone(), deposit)
    }

    #[private]
    #[handle_result]
    pub fn on_ext_db_write_permission_granted(
        &mut self,
        external_db_id: AccountId,
        iah_registry: AccountId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> Result<(), String> {
        callback_result.map_err(|e| {
            format!(
                "SocialDB::grant_write_permission(`{iah_registry}`) call failure: {:?}",
                e
            )
        })?;

        self.iah_registry = iah_registry;
        self.external_db_id = Some(external_db_id);

        Ok(())
    }
}

impl Contract {
    /// Check and panic if contract state [`RunningState`] is not set to [`RunningState::Running`]
    pub(crate) fn assert_contract_running(&self) {
        require!(
            self.running_state == RunningState::Running,
            "Contract paused"
        );
    }

    /// Asserts if the caller is not an owner/admin of this contract
    pub(crate) fn assert_owner(&self) {
        require!(self.is_owner(&env::predecessor_account_id()), "Not allowed");
    }

    /// Return [`bool`] which represents if [`AccountId`] is an owner/admin of this contract or not
    pub(crate) fn is_owner(&self, account_id: &AccountId) -> bool {
        account_id == &self.owner_id
    }

    /// Return [`AccountId`] of NEAR social db smart contract used by this contract or an error if not set
    pub(crate) fn external_db_id(&self) -> Result<&AccountId, &'static str> {
        self.external_db_id.as_ref().ok_or("External db is not set")
    }
}

'''
'''--- contracts/kudos/src/external_db.rs ---
use near_sdk::serde::Serialize;
use near_sdk::serde_json::Value;
use near_sdk::{ext_contract, AccountId, Promise, PromiseOrValue, PublicKey};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GetOptions {
    pub with_block_height: Option<bool>,
    pub with_node_id: Option<bool>,
    pub return_deleted: Option<bool>,
}

#[allow(unused)]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum KeysReturnType {
    True,
    BlockHeight,
    NodeId,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct KeysOptions {
    pub return_type: Option<KeysReturnType>,
    pub return_deleted: Option<bool>,
}

#[ext_contract(ext_db)]
pub trait DatabaseProvider {
    fn set(&mut self, data: Value) -> Result<Promise, &'static str>;

    fn get(&self, keys: Vec<String>, options: Option<GetOptions>) -> PromiseOrValue<Value>;

    fn keys(&self, keys: Vec<String>, options: Option<KeysOptions>) -> PromiseOrValue<Value>;

    fn grant_write_permission(
        &mut self,
        predecessor_id: Option<AccountId>,
        public_key: Option<PublicKey>,
        keys: Vec<String>,
    ) -> Result<Promise, &'static str>;
}

'''
'''--- contracts/kudos/src/lib.rs ---
mod callbacks;
mod consts;
mod contract;
mod external_db;
mod misc;
mod public;
pub mod registry;
mod settings;
#[cfg(test)]
pub mod tests;
mod types;
pub mod utils;

pub use consts::*;
pub use contract::*;
pub use types::*;

'''
'''--- contracts/kudos/src/misc.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

/// This type represents this contract state
///
/// Public methods are available only while this contract is in [`Running`](RunningState::Running) state
#[derive(BorshDeserialize, BorshSerialize, PartialEq)]
pub enum RunningState {
    Running,
    Paused,
}

'''
'''--- contracts/kudos/src/public.rs ---
use crate::registry::{ext_sbtreg, IS_HUMAN_GAS};
use crate::settings::Settings;
use crate::types::{Commentary, KudosId, KudosKind, WrappedCid};
use crate::{consts::*, CommentId, EncodedCommentary};
use crate::{utils::*, GIVE_KUDOS_COST};
use crate::{Contract, ContractExt};
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, require, AccountId, Promise};

#[near_bindgen]
impl Contract {
    /// Allows caller to exchange kudos associated with [`KudosId`] for ProofOfKudos SBT.
    /// Caller should have a valid i-am-human SBT. Every unique [`KudosId`] could be exchanged only once and
    /// only if it has sufficient amount of upvotes. Calls `sbt_mint` of i-am-human-registry contract.
    #[payable]
    #[handle_result]
    pub fn exchange_kudos_for_sbt(&mut self, kudos_id: KudosId) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let minimum_gas_requirement = EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS
            + PROOF_OF_KUDOS_SBT_MINT_GAS
            + PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == EXCHANGE_KUDOS_COST,
            &display_deposit_requirement_in_near(EXCHANGE_KUDOS_COST)
        );

        if self.exchanged_kudos.contains(&kudos_id) {
            return Err("Kudos is already exchanged");
        }

        let predecessor_account_id = env::predecessor_account_id();
        let external_db_id = self.external_db_id()?.clone();

        let gas_remaining = env::prepaid_gas()
            - (env::used_gas() + IS_HUMAN_GAS + EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_number_of_upvotes(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        kudos_id,
                    ),
            ))
    }

    /// Allows caller to leave a commentary message [`String`] to a kudos associated with [`KudosId`]
    /// for a user by [`AccountId`]. Caller should have a valid i-am-human SBT and can't leave
    /// commentary message for his own kudos.
    #[payable]
    #[handle_result]
    pub fn leave_comment(
        &mut self,
        receiver_id: AccountId,
        kudos_id: KudosId,
        parent_comment_id: Option<CommentId>,
        message: String,
    ) -> Result<Promise, String> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();

        let minimum_gas_requirement = LEAVE_COMMENT_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_KUDOS_INFO_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_COMMENT_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == LEAVE_COMMENT_COST,
            &display_deposit_requirement_in_near(LEAVE_COMMENT_COST)
        );

        if message.len() > Settings::from(&self.settings).commentary_message_max_length  as usize {
            return Err("Message max length exceeded".to_string());
        }
        let external_db_id = self.external_db_id()?.clone();
        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &sender_id,
            message: &Value::String(message),
            timestamp: env::block_timestamp_ms().into(),
            parent_comment_id: parent_comment_id.as_ref(),
        })?;

        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + LEAVE_COMMENT_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_kudos_info(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kudos_id,
                        parent_comment_id,
                        comment,
                    ),
            ))
    }

    /// Allows caller to upvote kudos associated with [`KudosId`] for a user by [`AccountId`].
    /// Caller should have a valid i-am-human SBT and can't upvote his own kudos.
    #[payable]
    #[handle_result]
    pub fn upvote_kudos(
        &mut self,
        receiver_id: AccountId,
        kudos_id: KudosId,
    ) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();
        require!(
            receiver_id != sender_id,
            "User is not eligible to upvote this kudos"
        );

        let minimum_gas_requirement = UPVOTE_KUDOS_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_KUDOS_SENDER_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == UPVOTE_KUDOS_COST,
            &display_deposit_requirement_in_near(UPVOTE_KUDOS_COST)
        );

        let external_db_id = self.external_db_id()?.clone();
        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + UPVOTE_KUDOS_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_kudos_sender(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kudos_id,
                    ),
            ))
    }

    /// Allows caller to give kudos for a user by [`AccountId`].
    /// Caller should have a valid i-am-human SBT and can't give kudos to himself.
    /// Hashtags is an array of [`String`] for which only alphanumeric characters, underscores and gyphens are allowed to use.
    #[payable]
    #[handle_result]
    pub fn give_kudos(
        &mut self,
        receiver_id: AccountId,
        kind: Option<KudosKind>,
        message: String,
        icon_cid: Option<WrappedCid>,
        hashtags: Option<Vec<String>>,
    ) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();
        require!(
            receiver_id != sender_id,
            "User is not eligible to upvote this kudos"
        );

        let minimum_gas_requirement = GIVE_KUDOS_RESERVED_GAS
            + IS_HUMAN_GAS
            + SAVE_KUDOS_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == GIVE_KUDOS_COST,
            &display_deposit_requirement_in_near(GIVE_KUDOS_COST)
        );

        let settings = Settings::from(&self.settings);
        let kind = kind.unwrap_or_default();
        let hashtags = settings.validate_hashtags(hashtags.as_deref())?;
        if message.len() > Settings::from(&self.settings).commentary_message_max_length  as usize {
            return Err("Message max length exceeded");
        }

        let external_db_id = self.external_db_id()?.clone();

        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + GIVE_KUDOS_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(sender_id)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .save_kudos(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kind,
                        message,
                        icon_cid,
                        hashtags,
                    ),
            ))
    }
}

'''
'''--- contracts/kudos/src/registry.rs ---
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{ext_contract, AccountId, Gas, Promise};

pub type TokenId = u64;

pub const IS_HUMAN_GAS: Gas = Gas(12 * Gas::ONE_TERA.0);

/// TokenMetadata defines attributes for each SBT token.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub class: u64,                          // token class
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OwnedToken {
    pub token: u64,
    pub metadata: TokenMetadata,
}

#[ext_contract(ext_sbtreg)]
pub trait ExtSbtRegistry {
    /*
    fn is_human_call(
        &mut self,
        account: AccountId,
        ctr: AccountId,
        function: String,
        args: Base64VecU8,
    ) -> PromiseOrValue<bool>;
    */

    fn is_human(&self, account: AccountId) -> Vec<(AccountId, Vec<TokenId>)>;

    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Promise;
}

'''
'''--- contracts/kudos/src/settings.rs ---
use crate::utils::opt_default;
use crate::Hashtag;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

/// Settings for this contract
#[derive(BorshDeserialize, BorshSerialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Settings {
    pub commentary_message_max_length: u16,
    pub max_number_of_hashtags_per_kudos: u8,
    pub hashtag_text_max_length: u8,
    pub min_number_of_upvotes_to_exchange_kudos: u8,
    pub pok_sbt_ttl: u64,
}

#[derive(BorshDeserialize, BorshSerialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum VSettings {
    // Add old versions here, keep ordering, the oldest on top, most recent at bottom
    // e.g. V0(SettingsV0),
    Current(Settings), // most recent version
}

/// View JSON serializable representation of `Settings` data struct
#[derive(Default, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct SettingsView {
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub commentary_message_max_length: Option<u16>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub max_number_of_hashtags_per_kudos: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub hashtag_text_max_length: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub min_number_of_upvotes_to_exchange_kudos: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub pok_sbt_ttl: Option<u64>,
}

impl Settings {
    /// Apply optionally provided changes to settings
    fn apply_changes(mut self, settings_json: SettingsView) -> Self {
        if let Some(commentary_message_max_length) = settings_json.commentary_message_max_length {
            self.commentary_message_max_length = commentary_message_max_length;
        }

        if let Some(max_number_of_hashtags_per_kudos) =
            settings_json.max_number_of_hashtags_per_kudos
        {
            self.max_number_of_hashtags_per_kudos = max_number_of_hashtags_per_kudos;
        }

        if let Some(hashtag_text_max_length) = settings_json.hashtag_text_max_length {
            self.hashtag_text_max_length = hashtag_text_max_length;
        }

        if let Some(min_number_of_upvotes_to_exchange_kudos) =
            settings_json.min_number_of_upvotes_to_exchange_kudos
        {
            self.min_number_of_upvotes_to_exchange_kudos = min_number_of_upvotes_to_exchange_kudos;
        }

        if let Some(pok_sbt_ttl) = settings_json.pok_sbt_ttl {
            self.pok_sbt_ttl = pok_sbt_ttl;
        }

        self
    }

    /// Validate and convert array slice of [String] to an array of [Hashtag]
    pub(crate) fn validate_hashtags(
        &self,
        hashtags: Option<&[String]>,
    ) -> Result<Option<Vec<Hashtag>>, &'static str> {
        let Some(hashtags) = hashtags else { return Ok(None) };

        if hashtags.len() > self.max_number_of_hashtags_per_kudos as usize {
            return Err("Maximum number of hashtags per Kudos exceeded");
        }

        hashtags
            .iter()
            .map(|ht_text| Hashtag::new(ht_text, self.hashtag_text_max_length as usize))
            .collect::<Result<Vec<_>, _>>()
            .map(Some)
    }

    pub(crate) fn acquire_pok_sbt_expire_at_ts(&self, issued_at: u64) -> Result<u64, &'static str> {
        issued_at
            .checked_add(self.pok_sbt_ttl)
            .ok_or("ProofOfKudos SBT expiration date overflow")
    }
}

impl VSettings {
    /// Helper function to migrate settings to the current version and apply changes
    pub(crate) fn apply_changes(&self, settings_json: SettingsView) -> Self {
        Settings::from(self).apply_changes(settings_json).into()
    }
}

fn default_commentary_message_max_length() -> u16 {
    1000
}

fn default_max_number_of_hashtags_per_kudos() -> u8 {
    10
}

fn default_hashtag_text_max_length() -> u8 {
    32
}

fn default_min_number_of_upvotes_to_exchange_kudos() -> u8 {
    3
}

fn default_pok_sbt_ttl() -> u64 {
    365 * 86_400_000
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            commentary_message_max_length: default_commentary_message_max_length(),
            max_number_of_hashtags_per_kudos: default_max_number_of_hashtags_per_kudos(),
            hashtag_text_max_length: default_hashtag_text_max_length(),
            min_number_of_upvotes_to_exchange_kudos:
                default_min_number_of_upvotes_to_exchange_kudos(),
            pok_sbt_ttl: default_pok_sbt_ttl(),
        }
    }
}

impl From<&VSettings> for Settings {
    fn from(v_settings: &VSettings) -> Self {
        match v_settings {
            VSettings::Current(settings) => settings.clone(),
            // TODO: add any migration stuff below
            // e.g. VSettings::V0(settings_v0) => Settings::from(settings_v0),
        }
    }
}

// TODO: impl From<&OLD_VERSION_STRUCT> for CURRENT_VERSION_STRUCT
// e.g. impl From<&SettingsV0> for Settings

impl From<Settings> for VSettings {
    fn from(settings: Settings) -> Self {
        Self::Current(settings)
    }
}

impl From<Settings> for SettingsView {
    fn from(settings: Settings) -> Self {
        Self {
            commentary_message_max_length: Some(settings.commentary_message_max_length),
            max_number_of_hashtags_per_kudos: Some(settings.max_number_of_hashtags_per_kudos),
            hashtag_text_max_length: Some(settings.hashtag_text_max_length),
            min_number_of_upvotes_to_exchange_kudos: Some(
                settings.min_number_of_upvotes_to_exchange_kudos,
            ),
            pok_sbt_ttl: Some(settings.pok_sbt_ttl),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{settings::Settings, Hashtag};
    use assert_matches::assert_matches;

    #[test]
    fn test_validate_hashtags() {
        let settings = Settings::default();
        assert_matches!(settings.validate_hashtags(None), Ok(None));
        assert_matches!(settings.validate_hashtags(Some(&[])), Ok(_));
        assert_eq!(
            settings.validate_hashtags(Some(vec!["abc".to_owned(), "1Def".to_owned()].as_slice())),
            Ok(Some(vec![
                Hashtag::new_unchecked("abc"),
                Hashtag::new_unchecked("1Def")
            ]))
        );
        assert_matches!(
            settings.validate_hashtags(Some(vec!["abc".to_owned(), "@ABC".to_owned()].as_slice())),
            Err(_)
        );
        assert_matches!(
            settings.validate_hashtags(Some(vec!["a".repeat(33)].as_slice())),
            Err(_)
        );
    }
}

'''
'''--- contracts/kudos/src/tests/mod.rs ---
mod tests_exchange_kudos_for_sbt;
mod utils;

'''
'''--- contracts/kudos/src/tests/tests_exchange_kudos_for_sbt.rs ---
use crate::consts::{EXCHANGE_KUDOS_COST, EXCHANGE_KUDOS_STORAGE};
use crate::tests::utils::{build_default_context, promise_or_value_result_into_result, MAX_GAS};
use crate::utils::{build_kudos_kind_path, build_kudos_upvotes_path};
use crate::{Contract, IncrementalUniqueId, KudosId, PROOF_OF_KUDOS_SBT_MINT_COST};
use near_sdk::borsh::BorshSerialize;
use near_sdk::serde_json::json;
use near_sdk::test_utils::accounts;
use near_sdk::{
    env, testing_env, AccountId, Gas, PromiseError, PromiseResult, RuntimeFeesConfig, VMConfig,
};
use std::collections::HashMap;

#[test]
fn test_required_storage_to_exchange_kudos() {
    testing_env!(build_default_context(accounts(0), None, Some(Gas::ONE_TERA)).build());

    let mut kudos_contract = Contract::init(
        Some(accounts(0)),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let initial_storage = env::storage_usage();
    kudos_contract
        .exchanged_kudos
        .insert(IncrementalUniqueId::default().next().into());
    assert_eq!(
        env::storage_usage() - initial_storage,
        EXCHANGE_KUDOS_STORAGE
    );
}

#[test]
fn test_required_deposit_to_exchange_kudos() -> anyhow::Result<()> {
    let contract_id = AccountId::new_unchecked("kudos.near".to_owned());
    testing_env!(
        build_default_context(contract_id.clone(), None, Some(MAX_GAS),)
            .attached_deposit(EXCHANGE_KUDOS_COST)
            .prepaid_gas(MAX_GAS)
            .build(),
        VMConfig::test(),
        RuntimeFeesConfig::test(),
        HashMap::default(),
        vec![PromiseResult::Successful(vec![1u64].try_to_vec().unwrap())],
    );

    let initial_balance = env::account_balance();
    let mut kudos_contract = Contract::init(
        Some(contract_id.clone()),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let kudos_id = KudosId::from(IncrementalUniqueId::default().next());
    let receiver_id = accounts(0);
    let sender_id = accounts(1);
    let kudos_upvotes_path = build_kudos_upvotes_path(&contract_id, &receiver_id, &kudos_id);
    let kudos_kind_path = build_kudos_kind_path(&contract_id, &receiver_id, &kudos_id);
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id.clone(),
        EXCHANGE_KUDOS_COST.into(),
        kudos_id.clone(),
        kudos_upvotes_path.clone(),
        kudos_kind_path.clone(),
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "kind": "k",
                    "upvotes": {
                      "charlie": "",
                      "danny": "",
                      "eugene": ""
                    }
                  }
                }
              }
            }
        })),
    );
    // There is no way to verify if callback failed or not, because it never panics and
    // calls another failure callback in case of failure. So we verify balance change,
    // if we get full refund then it's an error, otherwise we attach `PROOF_OF_KUDOS_SBT_MINT_COST`
    // to next XCC
    let used_deposit = initial_balance - env::account_balance();
    assert_eq!(used_deposit, PROOF_OF_KUDOS_SBT_MINT_COST);

    let initial_balance = env::account_balance();
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id.clone(),
        EXCHANGE_KUDOS_COST.into(),
        kudos_id.clone(),
        kudos_upvotes_path.clone(),
        kudos_kind_path.clone(),
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "upvotes": {}
                  }
                }
              }
            }
        })),
    );
    // Not enough upvotes, full attached deposit returned
    let transferred_deposit = initial_balance - env::account_balance();
    assert_eq!(transferred_deposit, EXCHANGE_KUDOS_COST);

    let initial_balance = env::account_balance();
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id,
        EXCHANGE_KUDOS_COST.into(),
        kudos_id,
        kudos_upvotes_path,
        kudos_kind_path,
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "kind": "d",
                    "upvotes": {
                      "charlie": "",
                      "danny": "",
                      "eugene": ""
                    }
                  }
                }
              }
            }
        })),
    );
    // Ding kind couldn't be exchanged, full attached deposit returned
    let transferred_deposit = initial_balance - env::account_balance();
    assert_eq!(transferred_deposit, EXCHANGE_KUDOS_COST);

    Ok(())
}

#[test]
fn test_on_pok_sbt_mint() {
    let contract_id = AccountId::new_unchecked("kudos.near".to_owned());
    let context = build_default_context(contract_id.clone(), None, Some(MAX_GAS))
        .attached_deposit(EXCHANGE_KUDOS_COST)
        .build();

    let mut kudos_contract = Contract::init(
        Some(contract_id),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let sender_id = accounts(0);
    let kudos_id = KudosId::from(IncrementalUniqueId::default().next());

    struct TestCase<'a> {
        name: &'a str,
        input: Result<Vec<u64>, PromiseError>,
        output: Result<String, String>,
    }

    let test_cases = [
        TestCase {
            name: "SBT mint successful",
            input: Ok(vec![1u64]),
            output: Ok("[1]".to_owned()),
        },
        TestCase {
            name: "SBT mint failure",
            input: Ok(vec![]),
            output: Err("IAHRegistry::sbt_mint() responses with an empty tokens array".to_owned()),
        },
        TestCase {
            name: "Promise error",
            input: Err(near_sdk::PromiseError::Failed),
            output: Ok("Promise".to_owned()),
        },
    ];

    for test_case in test_cases {
        testing_env!(context.clone());

        assert_eq!(
            promise_or_value_result_into_result(kudos_contract.on_pok_sbt_mint(
                sender_id.clone(),
                EXCHANGE_KUDOS_COST.into(),
                kudos_id.clone(),
                test_case.input
            )),
            test_case.output,
            "Test case `{} failure`",
            test_case.name
        );
    }
}

'''
'''--- contracts/kudos/src/tests/utils.rs ---
use near_sdk::PromiseOrValue;
use near_sdk::{test_utils::VMContextBuilder, AccountId, Balance, Gas};

pub const MAX_GAS: Gas = Gas(300_000_000_000_000);

pub fn build_default_context(
    predecessor_account_id: AccountId,
    deposit: Option<Balance>,
    prepaid_gas: Option<Gas>,
) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
        .signer_account_id(predecessor_account_id.clone())
        .predecessor_account_id(predecessor_account_id)
        .prepaid_gas(prepaid_gas.unwrap_or(MAX_GAS))
        .attached_deposit(deposit.unwrap_or_default());
    builder
}

pub fn promise_or_value_result_into_result<T: std::fmt::Debug>(
    value: Result<PromiseOrValue<T>, &'static str>,
) -> Result<String, String> {
    match value {
        Ok(PromiseOrValue::Promise(_)) => Ok("Promise".to_owned()),
        Ok(PromiseOrValue::Value(res)) => Ok(format!("{res:?}")),
        Err(e) => Err(e.to_owned()),
    }
}

'''
'''--- contracts/kudos/src/types.rs ---
use cid::Cid;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{self, de, Deserialize, Deserializer, Serialize, Serializer};
use near_sdk::serde_json::Value;
use near_sdk::{serde_json, AccountId, BorshStorageKey};
use std::fmt::Display;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

/// This type represents a unique incremental identifier
#[derive(BorshDeserialize, BorshSerialize)]
pub struct IncrementalUniqueId(U64);

impl IncrementalUniqueId {
    /// Return [`u64`] representation of this [`IncrementalUniqueId`]
    pub fn as_u64(&self) -> u64 {
        self.0 .0
    }

    /// Increment self-stored value and returns self-reference
    pub fn inc(&mut self) -> &Self {
        self.0 = self.next().0;
        self
    }

    /// Compute the next identifier
    pub fn next(&self) -> Self {
        Self((self.as_u64() + 1).into())
    }
}

impl Default for IncrementalUniqueId {
    fn default() -> Self {
        Self(0.into())
    }
}

/// This type represents a unique identifier of the kudos.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct KudosId(U64);

impl From<IncrementalUniqueId> for KudosId {
    fn from(value: IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl From<&IncrementalUniqueId> for KudosId {
    fn from(value: &IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl Display for KudosId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0 .0, f)
    }
}

/// This type represents a unique identifier of the commentary message.
#[derive(Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Eq, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct CommentId(U64);

impl CommentId {
    /// Creates [`CommentId`] from identifier without guarantee for validness & uniqueness
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(id: u64) -> Self {
        Self(id.into())
    }
}

impl Hash for CommentId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0 .0.hash(state);
    }
}

impl From<IncrementalUniqueId> for CommentId {
    fn from(value: IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl From<&IncrementalUniqueId> for CommentId {
    fn from(value: &IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl Display for CommentId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0 .0, f)
    }
}

/// The type of storage key used as key prefix in contract storage
#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Kudos,
}

/// Commentary message data struct which serializes to base64-encoded [`String`] for subsequent store in NEAR social db
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Commentary<'a> {
    /// A message with escaped characters to guarantee safety of stringification
    pub message: &'a Value,
    /// A valid [`AccountId`] of a message sender
    pub sender_id: &'a AccountId,
    /// The timestamp in milliseconds when commentary message were prepared
    pub timestamp: U64,
    /// Parent commentary id which were replied
    pub parent_comment_id: Option<&'a CommentId>,
}

/// Raw commentary message data struct which serializes to [`Value`](near_sdk::serde_json::Value)
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CommentaryRaw<'a> {
    /// A message with escaped characters to guarantee safety of stringification
    #[serde(rename = "m")]
    pub message: &'a Value,
    /// A valid [`AccountId`] of a message sender
    #[serde(rename = "s")]
    pub sender_id: &'a AccountId,
    /// The timestamp in milliseconds when commentary message were prepared
    #[serde(rename = "t")]
    pub timestamp: U64,
    /// Parent commentary id which were replied
    #[serde(rename = "p", skip_serializing_if = "Option::is_none")]
    pub parent_comment_id: Option<&'a CommentId>,
}

impl Serialize for Commentary<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: near_sdk::serde::Serializer,
    {
        let encoded = near_sdk::base64::encode(
            serde_json::to_string(&CommentaryRaw {
                message: self.message,
                sender_id: self.sender_id,
                timestamp: self.timestamp,
                parent_comment_id: self.parent_comment_id,
            })
            .map_err(near_sdk::serde::ser::Error::custom)?,
        );

        serializer.serialize_str(&encoded)
    }
}

/// This type represents a [`String`] for which only ascii alphanumeric characters, underscores and gyphens are allowed to use
#[derive(Deserialize, Serialize, Ord, PartialOrd, PartialEq, Eq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Hashtag(String);

impl Hashtag {
    /// Create [`Hashtag`] from ascii ref string, verify maximum length and check for allowed characters
    pub fn new(hashtag: &str, max_lenth: usize) -> Result<Self, &'static str> {
        if hashtag.len() > max_lenth {
            return Err("Hashtag max text length exceeded");
        }

        if hashtag.contains(|c: char| !c.is_ascii_alphanumeric() && !matches!(c, '_' | '-')) {
            return Err(
                "Only alphanumeric characters, underscores and gyphens are allowed for hashtag",
            );
        }

        Ok(Self(hashtag.to_owned()))
    }

    /// Creates [`Hashtag`] from ref string without length and characters check
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(hashtag: &str) -> Self {
        Self(hashtag.to_owned())
    }
}

/// This type represents a JSON [`String`] view of [`Commentary`]
#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct EncodedCommentary(String);

impl EncodedCommentary {
    pub fn as_str(&self) -> &str {
        self.0.as_str()
    }

    /// Creates [`EncodedCommentary`] from [`String`] without verification if it can be deserialized
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(encoded: String) -> Self {
        Self(encoded)
    }
}

impl TryFrom<&Commentary<'_>> for EncodedCommentary {
    type Error = String;

    fn try_from(value: &Commentary<'_>) -> Result<Self, Self::Error> {
        serde_json::to_value(value)
            .and_then(|val| {
                val.as_str()
                    .map(|s| Self(s.to_owned()))
                    .ok_or(serde::ser::Error::custom("Not a string"))
            })
            .map_err(|e| format!("Unable to encode commentary: {e}"))
    }
}

impl Display for EncodedCommentary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0, f)
    }
}

/// This type represents a wrapped serializable version of [`Cid`]
pub struct WrappedCid(Cid);

impl WrappedCid {
    /// Creates [`WrappedCid`] from ref string
    pub fn new(cid: &str) -> Result<Self, &'static str> {
        if cid.len() > 64 {
            return Err("Cid is too long");
        }
        Cid::from_str(cid)
            .map_err(|_| "Not a valid Cid")
            .map(WrappedCid)
    }
}

impl Display for WrappedCid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl<'de> Deserialize<'de> for WrappedCid {
    fn deserialize<D>(deserializer: D) -> Result<WrappedCid, D::Error>
    where
        D: Deserializer<'de>,
    {
        let cid_text = <String as Deserialize>::deserialize(deserializer)?;

        Cid::from_str(&cid_text)
            .map(WrappedCid)
            .map_err(|e| de::Error::custom(format!("Failed to deserialize CID: {e:?}")))
    }
}

impl Serialize for WrappedCid {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0.to_string())
    }
}

/// The type of a kudos given
///
/// [`Kudos`](KudosKind::Kudos) represents a positive kudos, while [`Ding`](KudosKind::Ding) represents a negative one
#[derive(Serialize, Deserialize, Default, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum KudosKind {
    #[default]
    #[serde(rename = "k")]
    Kudos,
    #[serde(rename = "d")]
    Ding,
}

impl Display for KudosKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let kind = match self {
            Self::Kudos => "k",
            Self::Ding => "d",
        };

        write!(f, "{kind}")
    }
}

#[cfg(test)]
mod tests {
    use crate::{CommentId, Commentary, EncodedCommentary, Hashtag, WrappedCid};
    use near_sdk::json_types::U64;
    use near_sdk::AccountId;
    use near_sdk::serde_json::Value;

    #[test]
    fn test_commentary_encoding() {
        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &AccountId::new_unchecked("user.near".to_owned()),
            message: &Value::String("commentary test".to_string()),
            timestamp: U64(1234567890),
            parent_comment_id: None,
        })
        .unwrap();
        assert_eq!(
            comment.as_str(),
            "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
        );

        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &AccountId::new_unchecked("user.near".to_owned()),
            message: &Value::String("commentary test".to_string()),
            timestamp: U64(1234567890),
            parent_comment_id: Some(&CommentId::new_unchecked(1u64)),
        })
        .unwrap();
        assert_eq!(
            comment.as_str(),
            "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIiwicCI6IjEifQ=="
        );
    }

    #[test]
    fn test_hashtag_from_str() {
        assert!(Hashtag::new("validhashtag", 32).is_ok());
        assert!(Hashtag::new("val1dhAshta9", 32).is_ok());
        assert!(Hashtag::new("va-li-d_hashtag", 32).is_ok());
        assert!(Hashtag::new("invalid+hashtag", 32).is_err());
        assert!(Hashtag::new("invalidha$ht@g", 32).is_err());
        assert!(Hashtag::new("toolonghashtag", 8).is_err());
    }

    #[test]
    fn test_wrapped_cid() {
        assert!(WrappedCid::new("invalid_cid").is_err());
        // Verify V1 CID
        assert_eq!(
            WrappedCid::new("bafkreieq5jui4j25lacwomsqgjeswwl3y5zcdrresptwgmfylxo2depppq")
                .unwrap()
                .to_string()
                .as_str(),
            "bafkreieq5jui4j25lacwomsqgjeswwl3y5zcdrresptwgmfylxo2depppq"
        );
        // Verify V0 CID
        assert_eq!(
            &format!(
                "{}",
                WrappedCid::new("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n").unwrap()
            ),
            "QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"
        );
    }
}

'''
'''--- contracts/kudos/src/utils.rs ---
use crate::consts::PROOF_OF_KUDOS_SBT_CLASS_ID;
use crate::registry::TokenMetadata;
use crate::types::KudosId;
use crate::{CommentId, EncodedCommentary, Hashtag, KudosKind, WrappedCid};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::serde_json::{self, Value};
use near_sdk::{AccountId, Balance, Gas};

/// Return initial object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {},
///     "hashtags": {}
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for all public methods
pub fn build_initial_json_for_socialdb(root_id: &AccountId) -> Result<Value, &'static str> {
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{}},
            "hashtags": {{}}
          }}
        }}"#
    ))
    .map_err(|_| "Internal serialization error")
}

/// Return hashtags relationship to kudos and it's owner as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "lovendc": {
///     "1": "ndc.near",
///     ...
///   },
///   ...
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn build_hashtags(
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    hashtags: Option<&[Hashtag]>,
) -> Result<String, &'static str> {
    hashtags
        .map(|hashtags| {
            hashtags
                .iter()
                .map(|ht| {
                    serde_json::from_str::<Value>(&format!(
                        r#"{{
                          "{kudos_id}": "{receiver_id}"
                        }}"#
                    ))
                    .map(|v| (ht, v))
                })
                .collect::<Result<std::collections::BTreeMap<_, _>, _>>()
                .and_then(|map| serde_json::to_string(&map))
                .map_err(|_| "Internal serialization error")
        })
        .unwrap_or_else(|| Ok("{}".to_owned()))
}

/// Return hashtags array as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// [
///   "nearcommunity",
///   "ndckudos",
///   ...
/// ]
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn hashtags_to_json_array(hashtags: &[Hashtag]) -> Result<String, &'static str> {
    serde_json::to_string(&hashtags)
        .map(|s| s.escape_default().to_string())
        .map_err(|_| "Internal hashtags serialization error")
}

/// Return kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "created_at": "1689976833613",
///           "sender_id": "alex.near",
///           "kind": "k",
///           "message": "that user is awesome",
///           "icon": "bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa",
///           "upvotes": {},
///           "comments": {},
///           "tags": "[\"firstkudos\",\"awesomework\"]",
///         }
///       }
///     },
///     "hashtags": {
///       "firstkudos": {
///         "1": "alex.near"
///       },
///       "awesomework": {
///         "1": "alex.near"
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn build_give_kudos_request(
    root_id: &AccountId,
    sender_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    created_at: u64,
    kind: KudosKind,
    message: &str,
    icon_cid: Option<&WrappedCid>,
    hashtags: Option<&[Hashtag]>,
) -> Result<Value, &'static str> {
    let hashtags_as_array_json = hashtags_to_json_array(hashtags.unwrap_or(&[]))?;
    let hashtags_with_kudos = build_hashtags(receiver_id, kudos_id, hashtags)?;
    let icon_cid = icon_cid.map(|cid| cid.to_string()).unwrap_or_default();

    let mes = near_sdk::serde_json::Value::String(message.to_string());
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "created_at": "{created_at}",
                  "sender_id": "{sender_id}",
                  "kind": "{kind}",
                  "message": {mes},
                  "icon": "{icon_cid}",
                  "upvotes": {{}},
                  "comments": {{}},
                  "tags": "{hashtags_as_array_json}"
                }}
              }}
            }},
            "hashtags": {hashtags_with_kudos}
          }}
        }}"#
    ))
    .map_err(|e| {
        println!("{e:?}");
        "Internal serialization error"
    })
}

/// Return upvotes for kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "upvotes": {
///             "bob.near": ""
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`upvote_kudos`](kudos_contract::public::Contract::upvote_kudos)
pub fn build_upvote_kudos_request(
    root_id: &AccountId,
    sender_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> Result<Value, &'static str> {
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "upvotes": {{
                    "{sender_id}": ""
                  }}
                }}
              }}
            }}
          }}
        }}"#
    ))
    .map_err(|_| "Internal serialization error")
}

/// Return base64-encoded commentary for kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "comments": {
///             "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`leave_comment`](kudos_contract::public::Contract::leave_comment)
pub fn build_leave_comment_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    comment_id: &CommentId,
    comment: &EncodedCommentary,
) -> Result<Value, &'static str> {
    let comment = comment.as_str();
    let json = format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "comments": {{
                    "{comment_id}": "{comment}"
                  }}
                }}
              }}
            }}
          }}
        }}"#
    );
    serde_json::from_str::<Value>(&json).map_err(|_| "Internal serialization error")
}

/// Return [`String`] path to a stored kudos JSON with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/*"
pub fn build_get_kudos_by_id_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/*")
}

/// Return [`String`] path to a stored kudos base64-encoded comment with unique [`KudosId`] and [`CommentId`]
/// for a valid [`AccountId`] used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/comments/2"
pub fn build_get_kudos_comment_by_id_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    comment_id: &CommentId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/comments/{comment_id}")
}

/// Return [`String`] path to a stored upvotes information JSON with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/upvotes"
pub fn build_kudos_upvotes_path(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/upvotes")
}

/// Return [`String`] path to a stored kudos kind type with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/bob.near/1/kind"
pub fn build_kudos_kind_path(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/kind")
}

/// Return [`TokenMetadata`] used as an argument for call [`sbt_mint`](kudos_contract::registry::ExtSbtRegistry::sbt_mint)
/// to mint ProofOfKudos SBT
pub fn build_pok_sbt_metadata(issued_at: u64, expires_at: u64) -> TokenMetadata {
    TokenMetadata {
        class: PROOF_OF_KUDOS_SBT_CLASS_ID,
        issued_at: Some(issued_at),
        expires_at: Some(expires_at),
        reference: None,
        reference_hash: None,
    }
}

/// Extract sender [`AccountId`] from stored kudos JSON acquired from NEAR social db
pub fn extract_kudos_id_sender_from_response(req: &str, res: &mut Value) -> Option<AccountId> {
    remove_key_from_json(res, &req.replace('*', "sender_id"))
        .and_then(|val| serde_json::from_value::<AccountId>(val).ok())
}

/// Extract kudos base64-encoded comment [`EncodedCommentary`] by [`CommentId`] from stored kudos JSON acquired from NEAR social db
pub fn extract_kudos_encoded_comment_by_id_from_response(
    req: &str,
    comment_id: &CommentId,
    res: &mut Value,
) -> Option<EncodedCommentary> {
    remove_key_from_json(res, &req.replace('*', &format!("comments/{comment_id}")))
        .and_then(|val| serde_json::from_value::<EncodedCommentary>(val).ok())
}

/// Remove and return (if removed) [`serde_json::Value`] by key name [`str`] from JSON [`serde_json::Value`]
///
/// # Example:
/// ```
/// use kudos_contract::utils::remove_key_from_json;
/// use near_sdk::serde_json;
///
/// let mut initial_value = serde_json::json!({
///   "key1": {
///     "key2": {
///       "key3": {
///         "key4": "value"
///       }
///     }
///   }
/// });
/// let removed_value = remove_key_from_json(&mut initial_value, "key1/key2/key3");
/// assert_eq!(
///     initial_value,
///     serde_json::json!({
///       "key1": {
///         "key2": {}
///       }
///     })
/// );
/// assert_eq!(
///     removed_value,
///     Some(serde_json::json!({
///       "key4": "value"
///     }))
/// );
/// ```
pub fn remove_key_from_json(json: &mut Value, key: &str) -> Option<Value> {
    let mut json = Some(json);
    let mut keys = key.split('/').peekable();

    while let Some(key) = keys.next() {
        match json {
            Some(Value::Object(obj)) if keys.peek().is_none() => {
                return obj.remove(key);
            }
            Some(Value::Object(obj)) => json = obj.get_mut(key),
            _ => break,
        }
    }

    None
}

/// Checks if provided value of type T is equal to T::default()
// pub(crate) fn is_default<T: Default + PartialEq>(t: &T) -> bool {
//     t == &T::default()
// }

pub(crate) fn opt_default<T>() -> Option<T> {
    Option::<T>::None
}

/// Return [`String`] message which represents human-readable attached TGas requirements for a call
pub(crate) fn display_gas_requirement_in_tgas(gas: Gas) -> String {
    format!(
        "Requires minimum amount of attached gas {} TGas",
        gas.0 / Gas::ONE_TERA.0
    )
}

/// Return [`String`] message which represents human-readable attached  deposit requirements for a call
pub(crate) fn display_deposit_requirement_in_near(value: Balance) -> String {
    format!(
        "Requires exact amount of attached deposit {} NEAR",
        (value / STORAGE_PRICE_PER_BYTE) as f64 / 100_000f64
    )
}

/// Return [`String`] which represents human-readable  amount
pub fn display_deposit_in_near(value: Balance) -> String {
    format!(
        "{} NEAR",
        (value / STORAGE_PRICE_PER_BYTE) as f64 / 100_000f64
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::EncodedCommentary;
    use crate::{types::IncrementalUniqueId, Commentary};
    use near_sdk::json_types::U64;
    use near_sdk::serde_json::json;
    use near_units::parse_near;

    #[test]
    fn test_build_initial_json_for_socialdb() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());

        let json_text = super::build_initial_json_for_socialdb(&root_id).unwrap();
        assert_eq!(
            json_text,
            json!({
                "kudos.near": {
                  "kudos": {},
                  "hashtags": {}
                }
            })
        )
    }

    #[test]
    fn test_build_hashtags() {
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());

        let json_text = super::build_hashtags(
            &receiver_id,
            &next_kudos_id,
            Some(&[Hashtag::new("hashtaga", 32).unwrap(),
                Hashtag::new("hashtagb", 32).unwrap(),
                Hashtag::new("hashtagc", 32).unwrap()]),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"hashtaga":{"1":"test2.near"},"hashtagb":{"1":"test2.near"},"hashtagc":{"1":"test2.near"}}"#
        );
    }

    #[test]
    fn test_hashtags_to_json_array() {
        assert_eq!(
            hashtags_to_json_array(&[
                Hashtag::new("a1", 32).unwrap(),
                Hashtag::new("b1", 32).unwrap(),
                Hashtag::new("c1", 32).unwrap(),
            ])
            .unwrap(),
            r#"[\"a1\",\"b1\",\"c1\"]"#
        );
        assert_eq!(hashtags_to_json_array(&[]).unwrap(), r#"[]"#);
    }

    #[test]
    fn test_build_kudos_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        //let message = EscapedMessage::new(r#""a","b":{"t":"multi\nline"},"#, 1000).unwrap();
        let message = r#""a","b":{"t":"multi\nline"},"#;
        let icon_cid =
            WrappedCid::new("bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa").unwrap();

        let json_text = serde_json::to_string(
            &super::build_give_kudos_request(
                &root_id,
                &sender_id,
                &receiver_id,
                &next_kudos_id,
                1234567890u64,
                KudosKind::Kudos,
                message,
                Some(&icon_cid),
                Some(&[
                    Hashtag::new("abc", 32).unwrap(),
                    Hashtag::new("def", 32).unwrap(),
                ]),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"hashtags":{"abc":{"1":"test2.near"},"def":{"1":"test2.near"}},"kudos":{"test2.near":{"1":{"comments":{},"created_at":"1234567890","icon":"bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa","kind":"k","message":"\"a\",\"b\":{\"t\":\"multi\\nline\"},","sender_id":"test1.near","tags":"[\"abc\",\"def\"]","upvotes":{}}}}}}"#
        );

        let json_text = serde_json::to_string(
            &super::build_give_kudos_request(
                &root_id,
                &sender_id,
                &receiver_id,
                &next_kudos_id,
                1234567890u64,
                KudosKind::Ding,
                message,
                None,
                Some(&[
                    Hashtag::new("abc", 32).unwrap(),
                    Hashtag::new("def", 32).unwrap(),
                ]),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"hashtags":{"abc":{"1":"test2.near"},"def":{"1":"test2.near"}},"kudos":{"test2.near":{"1":{"comments":{},"created_at":"1234567890","icon":"","kind":"d","message":"\"a\",\"b\":{\"t\":\"multi\\nline\"},","sender_id":"test1.near","tags":"[\"abc\",\"def\"]","upvotes":{}}}}}}"#
        );
    }

    #[test]
    fn test_build_upvote_kudos_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());

        let json_text = serde_json::to_string(
            &super::build_upvote_kudos_request(&root_id, &sender_id, &receiver_id, &next_kudos_id)
                .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"kudos":{"test2.near":{"1":{"upvotes":{"test1.near":""}}}}}}"#
        );
    }

    #[test]
    fn test_build_leave_comment_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let mut unique_id = IncrementalUniqueId::default();
        let kudos_id = KudosId::from(unique_id.inc());
        let comment_id = CommentId::from(unique_id.inc());

        let json_text = serde_json::to_string(
            &super::build_leave_comment_request(
                &root_id,
                &receiver_id,
                &kudos_id,
                &comment_id,
                &EncodedCommentary::try_from(&Commentary {
                    sender_id: &sender_id,
                    message: &Value::String("some commentary text".to_string()),
                    timestamp: U64(1234567890),
                    parent_comment_id: None,
                })
                .unwrap(),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"kudos":{"test2.near":{"1":{"comments":{"2":"eyJtIjoic29tZSBjb21tZW50YXJ5IHRleHQiLCJzIjoidGVzdDEubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="}}}}}}"#
        );
    }

    #[test]
    fn test_build_get_kudos_by_id_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        assert_eq!(
            &super::build_get_kudos_by_id_request(&root_id, &receiver_id, &next_kudos_id),
            "kudos.near/kudos/test2.near/1/*"
        );
    }

    #[test]
    fn test_build_get_kudos_comment_by_id_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let mut id = IncrementalUniqueId::default();
        let next_kudos_id = KudosId::from(id.inc());
        let next_comment_id = CommentId::from(id.inc());
        assert_eq!(
            &super::build_get_kudos_comment_by_id_request(
                &root_id,
                &receiver_id,
                &next_kudos_id,
                &next_comment_id
            ),
            "kudos.near/kudos/test2.near/1/comments/2"
        );
    }

    #[test]
    fn test_extract_kudos_id_sender_from_response() {
        // valid kudos response
        assert_eq!(
            super::extract_kudos_id_sender_from_response(
                "test.near/kudos/user1.near/1/*",
                &mut json!({
                    "test.near": {
                      "kudos": {
                        "user1.near": {
                          "1": {
                            "sender_id": "user2.near"
                          }
                        }
                      }
                    }
                })
            ),
            Some(AccountId::new_unchecked("user2.near".to_owned()))
        );
        // invalid kudos response
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {}
                    }
                  }
                }
            })
        )
        .is_none());
        // different kudos root id
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({
                "test1.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "sender_id": "user2.near"
                      }
                    }
                  }
                }
            })
        )
        .is_none());
        // no response
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({})
        )
        .is_none());
    }

    #[test]
    fn test_extract_kudos_encoded_comment_by_id_from_response() {
        // valid kudos base64-encoded comment response
        assert_eq!(
            super::extract_kudos_encoded_comment_by_id_from_response(
                "test.near/kudos/user1.near/1/*",
                &CommentId::new_unchecked(2),
                &mut json!({
                    "test.near": {
                      "kudos": {
                        "user1.near": {
                          "1": {
                            "comments": {
                              "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ"
                            }
                          }
                        }
                      }
                    }
                })
            ),
            Some(EncodedCommentary::new_unchecked("eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ".to_owned()))
        );
        // invalid kudos base64-encoded comment response
        assert!(super::extract_kudos_encoded_comment_by_id_from_response(
            "test.near/kudos/user1.near/1/*",
            &CommentId::new_unchecked(2),
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "comments": {}
                      }
                    }
                  }
                }
            })
        )
        .is_none());
        // different parent commentary id
        assert!(super::extract_kudos_encoded_comment_by_id_from_response(
            "test.near/kudos/user1.near/1/*",
            &CommentId::new_unchecked(3),
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "comments": {
                          "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ"
                        }
                      }
                    }
                  }
                }
            })
        )
        .is_none());
    }

    #[test]
    fn test_remove_key_from_json() {
        let mut json = json!({
            "abc": "test",
            "remove_me": "test2",
            "test": {
                "remove_me": "test3",
                "test1": {
                    "remove_me": "test4"
                }
            }
        });

        // key not exist or nothing to remove
        assert!(remove_key_from_json(&mut json, "").is_none());
        assert!(remove_key_from_json(&mut json, "testtest").is_none());
        assert!(remove_key_from_json(&mut json, "test_abc/test_def").is_none());
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","remove_me":"test2","test":{"remove_me":"test3","test1":{"remove_me":"test4"}}}"#
        );
        // remove key from root
        assert_eq!(
            remove_key_from_json(&mut json, "remove_me"),
            Some(json!("test2"))
        );
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","test":{"remove_me":"test3","test1":{"remove_me":"test4"}}}"#
        );
        // remove nested key
        assert_eq!(
            remove_key_from_json(&mut json, "test/remove_me"),
            Some(json!("test3"))
        );
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","test":{"test1":{"remove_me":"test4"}}}"#
        );
        // remove deeply nested key
        assert_eq!(
            remove_key_from_json(&mut json, "test/test1/remove_me"),
            Some(json!("test4"))
        );
        assert_eq!(json.to_string(), r#"{"abc":"test","test":{"test1":{}}}"#);
    }

    #[test]
    fn test_display_deposit_requirement_in_near() {
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.0005 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.0005 NEAR"
        );
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.00051 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.00051 NEAR"
        );
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.000553 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.00055 NEAR"
        );
    }
}

'''
'''--- contracts/kudos/tests/test_kudos.rs ---
mod types;
mod utils;

use crate::types::*;
use crate::utils::*;
use kudos_contract::WrappedCid;
use kudos_contract::{utils::*, CommentId};
use kudos_contract::{Commentary, PROOF_OF_KUDOS_SBT_CLASS_ID};
use near_sdk::serde_json::{self, json, Value};
use near_sdk::AccountId;
use near_units::parse_near;
use std::collections::{BTreeMap, HashMap};
use test_util::{deploy_contract, gen_user_account, get_block_timestamp, transfer_near};

#[tokio::test]
async fn test_give_kudos() -> anyhow::Result<()> {
    let worker_mainnet = ::near_workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::near_workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = deploy_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Register users' accounts
    let user1_account = gen_user_account(&worker, "user1.test.near").await?;
    let _ = transfer_near(&worker, user1_account.id(), parse_near!("50 N")).await?;

    let user2_account = gen_user_account(&worker, "user2.test.near").await?;
    let _ = transfer_near(&worker, user2_account.id(), parse_near!("50 N")).await?;

    let user3_account = gen_user_account(&worker, "user3.test.near").await?;
    let _ = transfer_near(&worker, user3_account.id(), parse_near!("50 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let minted_tokens: Vec<u64> = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[user1_account.id(), user2_account.id(), user3_account.id()],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;
    assert!(verify_is_human(
        &iah_registry_id,
        admin_account.id(),
        &[&user1_account, &user2_account, &user3_account],
        &minted_tokens
    )
    .await
    .is_ok());

    // User1 gives kudos to User2
    let hashtags = (0..3).map(|n| format!("ht_{n}")).collect::<Vec<_>>();
    let kudos_message = "test\",\n\"a\":{\"b\":\"test2\"},\"c\":\"msg";
    let kudos_id = give_kudos(
        kudos_contract.id(),
        &user1_account,
        user2_account.id(),
        kudos_message,
        Some(
            &WrappedCid::new("bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku")
                .unwrap(),
        ),
        hashtags.iter().map(|s| s.as_str()).collect(),
    )
    .await?;

    let get_kudos_by_id_req = build_get_kudos_by_id_request(
        &AccountId::new_unchecked(kudos_contract.id().to_string()),
        &AccountId::new_unchecked(user2_account.id().to_string()),
        &kudos_id,
    );

    let hashtags_req = format!("{}/hashtags/**", kudos_contract.id());

    // Verify kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({ "keys": [get_kudos_by_id_req, hashtags_req] }))
        .await?
        .json()?;
    // remove `created_at` nested key to be able compare with static stringified json and verify that removed key were exist
    assert!(remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "created_at")
    )
    .is_some());
    let extracted_hashtags = remove_key_from_json(
        &mut kudos_data,
        &format!("{}/hashtags", kudos_contract.id()),
    )
    .and_then(|val| serde_json::from_value::<BTreeMap<String, Value>>(val).ok())
    .map(|map| map.keys().cloned().collect::<Vec<_>>());
    assert_eq!(extracted_hashtags, Some(hashtags.clone()));

    let escaped_kudos_message = kudos_message.escape_default().to_string();
    assert_eq!(
        kudos_data.to_string(),
        format!(
            r#"{{"{}":{{"kudos":{{"{}":{{"{kudos_id}":{{"icon":"bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku","kind":"k","message":"{escaped_kudos_message}","sender_id":"{}","tags":"{}"}}}}}}}}}}"#,
            kudos_contract.id(),
            user2_account.id(),
            user1_account.id(),
            serde_json::to_string(&hashtags).unwrap().escape_default(),
        )
    );

    // User3 upvotes kudos given to User2 by User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
    )
    .await?;

    // Verify upvoted kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({
            "keys": [get_kudos_by_id_req.replace('*', "upvotes/**")]
        }))
        .await?
        .json()?;

    // remove `/upvotes` nested key and check for it's value, which should contain User3 who upvoted kudos
    let upvotes_json = remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "upvotes"),
    )
    .unwrap()
    .to_string();
    assert_eq!(upvotes_json, format!(r#"{{"{}":""}}"#, user3_account.id()));

    // User3 leaves a comment to kudos given to User2 by User1
    let comment1_id = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        None,
        "amazing",
    )
    .await?;

    // User2 leaves a reply to a comment from User3
    let comment2_id = leave_comment(
        kudos_contract.id(),
        &user2_account,
        user2_account.id(),
        &kudos_id,
        Some(comment1_id.clone()),
        "wow",
    )
    .await?;

    // User3 leaves a reply to a comment from User2
    let comment3_id = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        Some(comment2_id.clone()),
        "you are the best",
    )
    .await?;

    // User3 fails to leave a reply to an invalid comment id
    let err = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        Some(CommentId::new_unchecked(123456789)),
        "failure",
    )
    .await
    .unwrap_err();
    assert_eq!(
        &err.to_string(),
        r#"Leave comment failure: Action #0: ExecutionError("Smart contract panicked: Unable to verify parent commentary id")"#
    );

    // Verify comment left for kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({
            "keys": [get_kudos_by_id_req.replace('*', "comments/**")]
        }))
        .await?
        .json()?;

    // remove `/comments` nested key and check for it's value, which should contain User3 who left a comment and a message for kudos
    let comments_json = remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "comments"),
    )
    .unwrap();
    let comments =
        serde_json::from_value::<HashMap<CommentId, CommentaryOwned>>(comments_json).unwrap();

    // verify first comment
    let comment = Commentary::from(comments.get(&comment1_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user3_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "amazing");

    // verify a reply comment
    let comment = Commentary::from(comments.get(&comment2_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user2_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "wow");
    assert_eq!(comment.parent_comment_id, Some(&comment1_id));

    // verify a reply comment
    let comment = Commentary::from(comments.get(&comment3_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user3_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "you are the best");
    assert_eq!(comment.parent_comment_id, Some(&comment2_id));

    Ok(())
}

#[tokio::test]
async fn test_mint_proof_of_kudos_sbt() -> anyhow::Result<()> {
    let worker_mainnet = ::near_workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::near_workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;
    let iah_registry_id = "registry.i-am-human.near".parse()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = deploy_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Initialize NDC i-am-human registry contract
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    // Set Kudos contract as an SBT issuer
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": kudos_contract.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Register users' accounts
    let user1_account = gen_user_account(&worker, "user1.test.near").await?;
    let _ = transfer_near(&worker, user1_account.id(), parse_near!("10 N")).await?;

    let user2_account = gen_user_account(&worker, "user2.test.near").await?;
    let _ = transfer_near(&worker, user2_account.id(), parse_near!("10 N")).await?;
    let user3_account = gen_user_account(&worker, "user3.test.near").await?;
    let _ = transfer_near(&worker, user3_account.id(), parse_near!("10 N")).await?;

    let user4_account = gen_user_account(&worker, "user4.test.near").await?;
    let _ = transfer_near(&worker, user4_account.id(), parse_near!("10 N")).await?;

    let user5_account = gen_user_account(&worker, "user5.test.near").await?;
    let _ = transfer_near(&worker, user5_account.id(), parse_near!("10 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users
    let _ = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[
            user1_account.id(),
            user2_account.id(),
            user3_account.id(),
            user4_account.id(),
            user5_account.id(),
        ],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;

    // User2 gives kudos to User1
    let kudos_id = give_kudos(
        kudos_contract.id(),
        &user2_account,
        user1_account.id(),
        "blablabla sdfsdfsd\nfsdfsdfs \n",
        None,
        vec!["ht-a", "ht_b"],
    )
    .await?;

    // User3 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user3_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User4 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user4_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User5 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user5_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User1 exchanges his Kudos for ProofOfKudos SBT
    let tokens_ids = exchange_kudos_for_sbt(kudos_contract.id(), &user1_account, &kudos_id).await?;
    assert_eq!(tokens_ids, vec![PROOF_OF_KUDOS_SBT_CLASS_ID]);

    verify_kudos_sbt_tokens_by_owner(
        &iah_registry_id,
        kudos_contract.id(),
        &user1_account,
        &tokens_ids,
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_mass_give_kudos() -> anyhow::Result<()> {
    let worker_mainnet = ::near_workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::near_workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = deploy_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Register users' accounts
    let number_of_users: usize = 5;
    let mut users_accounts = Vec::with_capacity(number_of_users);

    for i in 0..number_of_users {
        let user_account = gen_user_account(&worker, &format!("user{}.test.near", &i)).await?;
        let _ = transfer_near(&worker, user_account.id(), parse_near!("5 N")).await?;
        users_accounts.push(user_account);
    }

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let _ = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &users_accounts
            .iter()
            .map(|user| user.id())
            .collect::<Vec<_>>(),
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;

    let mut kudos = vec![];

    for user_account in &users_accounts[1..] {
        // UserX gives kudos to User1
        let hashtags = (0..3).map(|n| format!("ht{n}")).collect::<Vec<_>>();
        let kudos_message = "amazing message".repeat(32);
        let kudos_id = give_kudos(
            kudos_contract.id(),
            user_account,
            users_accounts.first().unwrap().id(),
            &kudos_message,
            None,
            hashtags.iter().map(|s| s.as_str()).collect(),
        )
        .await?;
        kudos.push(kudos_id);
    }

    for (user_account, kudos_id) in users_accounts[1..].iter().rev().zip(&kudos) {
        println!("{} upvotes kudos {}", user_account.id(), kudos_id);
        // UserX upvotes kudos of User1
        let _ = upvote_kudos(
            kudos_contract.id(),
            user_account,
            users_accounts.first().unwrap().id(),
            kudos_id,
        )
        .await?;
    }

    Ok(())
}

'''
'''--- contracts/kudos/tests/test_required_deposit.rs ---
mod types;
mod utils;

use crate::utils::*;
use kudos_contract::{utils::*, WrappedCid};
use kudos_contract::{GIVE_KUDOS_COST, LEAVE_COMMENT_COST, UPVOTE_KUDOS_COST};
use near_sdk::serde_json::json;
use near_units::parse_near;
use test_util::{deploy_contract, gen_user_account, get_block_timestamp, transfer_near};

#[tokio::test]
async fn test_required_deposit() -> anyhow::Result<()> {
    let worker_mainnet = ::near_workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::near_workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = deploy_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id, "owner_id": admin_account.id() }),
    )
    .await?;

    set_external_db(kudos_contract.id(), &admin_account, &near_social).await?;

    // Register users' accounts
    let test1_account =
        gen_user_account(&worker, &[&"a".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test1_account.id(), parse_near!("10 N")).await?;
    let test2_account =
        gen_user_account(&worker, &[&"b".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test2_account.id(), parse_near!("10 N")).await?;
    let test3_account =
        gen_user_account(&worker, &[&"c".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test3_account.id(), parse_near!("10 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let minted_tokens = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[test1_account.id(), test2_account.id(), test3_account.id()],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;
    assert!(verify_is_human(
        &iah_registry_id,
        admin_account.id(),
        &[&test1_account, &test2_account, &test3_account],
        &minted_tokens
    )
    .await
    .is_ok());

    let hashtags = (0..10)
        .map(|n| format!("{}{n}", "a".repeat(31)))
        .collect::<Vec<_>>();
    let kudos_text = "a".repeat(1000);

    // Give kudos
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let kudos_id = give_kudos(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_text,
        Some(
            WrappedCid::new("bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi").unwrap(),
        )
        .as_ref(),
        hashtags.iter().map(|s| s.as_str()).collect(),
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= GIVE_KUDOS_COST,
        "`give_kudos` call should cost at least {} ",
        display_deposit_in_near(consumed)
    );

    // Leave comment (no parent)
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let comment_id = leave_comment(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_id,
        None,
        &kudos_text,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= LEAVE_COMMENT_COST,
        "`leave_comment` call should cost at least {} ",
        display_deposit_in_near(consumed)
    );

    // Leave comment (with parent)
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let _ = leave_comment(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_id,
        Some(comment_id),
        &kudos_text,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    println!("{}", display_deposit_in_near(consumed));
    assert!(
        consumed <= LEAVE_COMMENT_COST,
        "`leave_comment` call should cost at least {} ",
        display_deposit_in_near(consumed)
    );

    // Upvote kudos
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let _ = upvote_kudos(
        kudos_contract.id(),
        &test3_account,
        test2_account.id(),
        &kudos_id,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= UPVOTE_KUDOS_COST,
        "`upvote_kudos` call should cost at least {} ",
        display_deposit_in_near(consumed)
    );

    Ok(())
}

'''
'''--- contracts/kudos/tests/test_social_db.rs ---
mod types;
mod utils;

use crate::utils::*;
use kudos_contract::utils::*;
use kudos_contract::SOCIAL_DB_GRANT_WRITE_PERMISSION_COST;
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::U128;
use near_sdk::serde_json::{self, json, Value};
use near_sdk::ONE_YOCTO;
use near_units::parse_near;
use test_util::{deploy_contract, gen_user_account, transfer_near};

#[tokio::test]
async fn test_social_db_required_deposit() -> anyhow::Result<()> {
    let worker_mainnet = ::near_workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::near_workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = deploy_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id, "owner_id": admin_account.id() }),
    )
    .await?;

    let social_db_balance_bounds: StorageBalanceBounds = near_social
        .view("storage_balance_bounds")
        .args_json(json!({}))
        .await?
        .json()?;

    let contract_with_max_name =
        gen_user_account(&worker, &[&"y".repeat(54), ".test.near"].concat()).await?;
    let initial_json = serde_json::from_str::<Value>(&format!(
        r#"{{
          "{}": {{
            "kudos": {{}},
            "hashtags": {{}}
          }}
        }}"#,
        contract_with_max_name.id()
    ))?;
    let _ = contract_with_max_name
        .call(&near_social_id, "set")
        .args_json(json!({ "data": initial_json }))
        .deposit(social_db_balance_bounds.min.0)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let StorageBalance {
        total: U128(total_before),
        available: U128(available_before),
    } = storage_balance_of(&near_social_id, &contract_with_max_name)
        .await?
        .unwrap();

    let grant_permissions_for =
        gen_user_account(&worker, &[&"z".repeat(54), ".test.near"].concat()).await?;

    let _ = contract_with_max_name
        .call(&near_social_id, "grant_write_permission")
        .args_json(json!({
          "predecessor_id": grant_permissions_for.id(),
          "keys": vec![format!("{}", contract_with_max_name.id())]
        }))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let StorageBalance {
        total: U128(total_after),
        available: U128(available_after),
    } = storage_balance_of(&near_social_id, &contract_with_max_name)
        .await?
        .unwrap();

    assert_eq!(
        total_before + ONE_YOCTO,
        total_after,
        "Initital total deposit before & after `SocialDB::grant_write_permission` call should diff only by 1 yocto!"
    );

    let required_deposit_for_grant_write_permission = available_before - available_after;
    assert!(
        required_deposit_for_grant_write_permission <= SOCIAL_DB_GRANT_WRITE_PERMISSION_COST,
        "Pre-computed deposit requirements for `SocialDB::grant_write_permission` call is less than required ({} < {})!",
        display_deposit_in_near(SOCIAL_DB_GRANT_WRITE_PERMISSION_COST),
        display_deposit_in_near(required_deposit_for_grant_write_permission)
    );

    set_external_db(kudos_contract.id(), &admin_account, &near_social).await?;

    let StorageBalance {
        total: U128(kudos_contract_total),
        available: U128(kudos_contract_available),
    } = storage_balance_of(&near_social_id, kudos_contract.as_account())
        .await?
        .unwrap();

    assert_eq!(
        kudos_contract_total, total_after,
        "Kudos contract initialized at SocialDB initially deposits incorrect amount!"
    );
    assert!(
        kudos_contract_available >= available_after,
        "Kudos contract initialized at SocialDB uses storage more than expected (available: {}, expected: {})!",
        display_deposit_in_near(kudos_contract_available),
        display_deposit_in_near(available_after),
    );

    let fake_iah_registry =
        gen_user_account(&worker, &[&"x".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, fake_iah_registry.id(), parse_near!("5 N")).await?;

    update_iah_registry(kudos_contract.id(), &admin_account, fake_iah_registry.id()).await?;

    let StorageBalance {
        total: U128(kudos_contract_total_after_iah_update),
        available: U128(kudos_contract_available_after_iah_update),
    } = storage_balance_of(&near_social_id, kudos_contract.as_account())
        .await?
        .unwrap();

    assert!(
        kudos_contract_total <= kudos_contract_total_after_iah_update,
        "Kudos contract initialized at SocialDB total storage deposit can't be less than before call `update_iah_registry` method!"
    );
    assert!(
        kudos_contract_available <= kudos_contract_available_after_iah_update,
        "Kudos contract initialized at SocialDB available storage deposit can't be less than before call `update_iah_registry` method ({} < {})!",
        display_deposit_in_near(kudos_contract_available_after_iah_update),
        display_deposit_in_near(kudos_contract_available),
    );

    // Check that permission were granted
    let updated_data = serde_json::from_str::<Value>(&format!(
        r#"{{
          "{}": {{
            "test": "test_value"
          }}
        }}"#,
        kudos_contract.id()
    ))?;
    let _ = fake_iah_registry
        .call(&near_social_id, "set")
        .args_json(json!({ "data": updated_data }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(())
}

'''
'''--- contracts/kudos/tests/types.rs ---
use kudos_contract::{CommentId, Commentary};
use near_sdk::json_types::U64;
use near_sdk::serde::{self, Deserialize};
use near_sdk::serde_json::Value;
use near_sdk::{serde_json, AccountId};

#[derive(Debug, PartialEq)]
pub struct CommentaryOwned {
    pub message: Value,
    pub sender_id: AccountId,
    pub timestamp: U64,
    pub parent_comment_id: Option<CommentId>,
}

impl<'a> From<&'a CommentaryOwned> for Commentary<'a> {
    fn from(value: &'a CommentaryOwned) -> Self {
        Self {
            message: &value.message,
            sender_id: &value.sender_id,
            timestamp: value.timestamp,
            parent_comment_id: value.parent_comment_id.as_ref(),
        }
    }
}

impl<'de> Deserialize<'de> for CommentaryOwned {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let encoded = <String as Deserialize>::deserialize(deserializer)?;

        let raw = near_sdk::base64::decode(&encoded).map_err(|e| {
            serde::de::Error::custom(format!(
                "Unable to deserialize commentary from base64 encoded data: {encoded}. {e:?}"
            ))
        })?;

        serde_json::from_slice::<serde_json::Value>(&raw)
            .map_err(|e| {
                serde::de::Error::custom(format!(
                    "Unable to deserialize commentary json from decoded data: {encoded}. {e:?}"
                ))
            })?
            .as_object_mut()
            .and_then(|map| {
                let message = map
                    .remove("m")
                    .and_then(|v| serde_json::from_value::<String>(v).ok())?;
                let sender_id = map
                    .remove("s")
                    .and_then(|v| serde_json::from_value::<AccountId>(v).ok())?;
                let timestamp = map
                    .remove("t")
                    .and_then(|v| serde_json::from_value::<U64>(v).ok())?;
                let parent_comment_id = map
                    .remove("p")
                    .and_then(|v| serde_json::from_value::<CommentId>(v).ok());

                Some(Self {
                    sender_id,
                    message: Value::String(message),
                    timestamp,
                    parent_comment_id,
                })
            })
            .ok_or_else(|| serde::de::Error::custom("Failure to deserialize commentary from json"))
    }
}

'''
'''--- contracts/kudos/tests/utils.rs ---
use anyhow::anyhow;
use kudos_contract::registry::{OwnedToken, TokenMetadata};
use kudos_contract::{
    CommentId, KudosId, WrappedCid, EXCHANGE_KUDOS_COST, GIVE_KUDOS_COST, LEAVE_COMMENT_COST,
    PROOF_OF_KUDOS_SBT_MINT_COST, SOCIAL_DB_GRANT_WRITE_PERMISSION_COST, UPVOTE_KUDOS_COST,
};
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::U64;
use near_sdk::serde_json::json;
use near_sdk::{AccountId, ONE_YOCTO};
use near_workspaces::result::ExecutionOutcome;

pub async fn mint_fv_sbt(
    iah_registry_id: &near_workspaces::AccountId,
    issuer: &near_workspaces::Account,
    receivers: &[&near_workspaces::AccountId],
    issued_at: u64,  // SBT issued at in millis
    expires_at: u64, // SBT expires at in millis
) -> anyhow::Result<Vec<u64>> {
    let res = issuer
        .call(iah_registry_id, "sbt_mint")
        .args_json(json!({
          "token_spec": receivers.iter().map(|receiver_id| (receiver_id, [
              TokenMetadata {
                  class: 1, // FV SBT
                  issued_at: Some(issued_at),
                  expires_at: Some(expires_at),
                  reference: None,
                  reference_hash: None,
              }
            ])
            ).collect::<Vec<_>>()
        }))
        .deposit(PROOF_OF_KUDOS_SBT_MINT_COST * receivers.len() as u128)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Mint FV SBT failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize sbt_mint response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn verify_is_human(
    iah_registry_id: &near_workspaces::AccountId,
    issuer_id: &near_workspaces::AccountId,
    users_accounts: &[&near_workspaces::Account],
    tokens: &Vec<u64>,
) -> anyhow::Result<()> {
    for (i, &user_account) in users_accounts.iter().enumerate() {
        let res = user_account
            .view(iah_registry_id, "is_human")
            .args_json(json!({
              "account": user_account.id()
            }))
            .await?
            .json::<Vec<(AccountId, Vec<u64>)>>()?;

        match res.first() {
            Some((issuer_id_result, tokens_result))
                if issuer_id_result.as_str() != issuer_id.as_str()
                    && tokens_result[0] != tokens[i] =>
            {
                return Err(anyhow::Error::msg(format!(
                    "User `{}` not verified",
                    user_account.id()
                )));
            }
            _ => (),
        };
    }

    Ok(())
}

pub async fn verify_kudos_sbt_tokens_by_owner(
    iah_registry_id: &near_workspaces::AccountId,
    issuer_id: &near_workspaces::AccountId,
    owner: &near_workspaces::Account,
    tokens_ids: &[u64],
) -> anyhow::Result<()> {
    let res = owner
        .view(iah_registry_id, "sbt_tokens_by_owner")
        .args_json(json!({
          "account": owner.id(),
          "issuer": issuer_id,
        }))
        .await?
        .json::<Vec<(AccountId, Vec<OwnedToken>)>>()?;

    match res.first() {
        Some((issuer_id_result, tokens_result))
            if issuer_id_result.as_str() != issuer_id.as_str()
                && compare_slices(
                    &tokens_result
                        .iter()
                        .map(|token_res| token_res.token)
                        .collect::<Vec<_>>(),
                    tokens_ids,
                ) =>
        {
            Err(anyhow::Error::msg(format!(
                "User `{}` do not have ProofOfKudos SBT",
                owner.id()
            )))
        }
        _ => Ok(()),
    }
}

pub async fn give_kudos(
    kudos_contract_id: &near_workspaces::AccountId,
    sender: &near_workspaces::Account,
    receiver_id: &near_workspaces::AccountId,
    message: &str,
    icon_cid: Option<&WrappedCid>,
    hashtags: Vec<&str>,
) -> anyhow::Result<KudosId> {
    let res = sender
        .call(kudos_contract_id, "give_kudos")
        .args_json(json!({
            "receiver_id": receiver_id,
            "message": message,
            "hashtags": hashtags,
            "icon_cid": icon_cid
        }))
        .deposit(GIVE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Give kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize give kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn upvote_kudos(
    kudos_contract_id: &near_workspaces::AccountId,
    sender: &near_workspaces::Account,
    receiver_id: &near_workspaces::AccountId,
    kudos_id: &KudosId,
) -> anyhow::Result<U64> {
    let res = sender
        .call(kudos_contract_id, "upvote_kudos")
        .args_json(json!({
            "receiver_id": receiver_id,
            "kudos_id": kudos_id,
        }))
        .deposit(UPVOTE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Upvote kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize upvote kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn leave_comment(
    kudos_contract_id: &near_workspaces::AccountId,
    sender: &near_workspaces::Account,
    receiver_id: &near_workspaces::AccountId,
    kudos_id: &KudosId,
    parent_comment_id: Option<CommentId>,
    message: &str,
) -> anyhow::Result<CommentId> {
    let res = sender
        .call(kudos_contract_id, "leave_comment")
        .args_json(json!({
            "receiver_id": receiver_id,
            "kudos_id": kudos_id,
            "parent_comment_id": parent_comment_id,
            "message": message,
        }))
        .deposit(LEAVE_COMMENT_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Leave comment failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize leave comment response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn exchange_kudos_for_sbt(
    kudos_contract_id: &near_workspaces::AccountId,
    requestor: &near_workspaces::Account,
    kudos_id: &KudosId,
) -> anyhow::Result<Vec<u64>> {
    let res = requestor
        .call(kudos_contract_id, "exchange_kudos_for_sbt")
        .args_json(json!({
            "kudos_id": kudos_id,
        }))
        .deposit(EXCHANGE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Exchange kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize exchange kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn set_external_db(
    kudos_contract_id: &near_workspaces::AccountId,
    owner: &near_workspaces::Account,
    near_social: &near_workspaces::Contract,
) -> anyhow::Result<()> {
    let balance_bounds: StorageBalanceBounds = near_social
        .view("storage_balance_bounds")
        .args_json(json!({}))
        .await?
        .json()?;

    let _ = owner
        .call(kudos_contract_id, "set_external_db")
        .args_json(json!({
            "external_db_id": near_social.id()
        }))
        .deposit(balance_bounds.min.0 + ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Set external database failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        })?;

    Ok(())
}

pub async fn update_iah_registry(
    kudos_contract_id: &near_workspaces::AccountId,
    owner: &near_workspaces::Account,
    iah_registry: &near_workspaces::AccountId,
) -> anyhow::Result<()> {
    let _ = owner
        .call(kudos_contract_id, "update_iah_registry")
        .args_json(json!({ "iah_registry": iah_registry }))
        .deposit(SOCIAL_DB_GRANT_WRITE_PERMISSION_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Update IAH registry failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        })?;

    Ok(())
}

pub async fn storage_balance_of(
    contract_id: &near_workspaces::AccountId,
    user: &near_workspaces::Account,
) -> anyhow::Result<Option<StorageBalance>> {
    user.view(contract_id, "storage_balance_of")
        .args_json(json!({
          "account_id": user.id()
        }))
        .await?
        .json()
        .map_err(|e| {
            anyhow::Error::msg(format!("Storage balance of `{}` failure: {e:?}", user.id(),))
        })
}

// TODO: pass iterators instead
fn compare_slices<T: PartialEq>(sl1: &[T], sl2: &[T]) -> bool {
    let count = sl1
        .iter()
        .zip(sl2)
        .filter(|&(item1, item2)| item1 == item2)
        .count();

    count == sl1.len() && count == sl2.len()
}

pub fn extract_error<'a, I>(mut outcomes: I) -> anyhow::Error
where
    I: Iterator<Item = &'a ExecutionOutcome>,
{
    outcomes
        .find(|&outcome| outcome.is_failure())
        //.and_then(|outcome| outcome.clone().into_result().err())
        .map(|outcome| {
            outcome
                .clone()
                .into_result()
                .map_err(|e| anyhow!(e.into_inner().unwrap()))
                .unwrap_err()
        })
        .unwrap()
}

'''
'''--- contracts/minifier/README.md ---
# Minifier

Minifier is a post-processing tool that allows to reduce the size of a contract by minifying it. For more details see the [documentation](https://docs.near.org/sdk/rust/building/post-processing).

## Usage

To use the provided script the following tools must be installed:

- `wasm-snip`
- `wasm-gc`
- `binaryen`
- `wabt`

To minify all the contracts run: `./minify_contracts.sh`.

The script will build all the contracts, then copy them to `out/base` directory.
The stripped and minified files will be placed directly in `out` directory.

'''
'''--- contracts/minifier/minify.sh ---
#!/usr/bin/env bash

for p in "$@"; do
  w=$(basename -- $p)
  echo "Minifying $w, make sure it is not stripped"
  wasm-snip $p --snip-rust-fmt-code --snip-rust-panicking-code -p core::num::flt2dec::.* -p core::fmt::float::.*  \
     --output temp-$w
  wasm-gc temp-$w
  wasm-strip temp-$w
  wasm-opt -Oz temp-$w --output minified-$w
  rm temp-$w
  echo $w `stat -f %z $p` "bytes ->" `stat -f %z minified-$w` "bytes, see minified-$w"
done

'''
'''--- contracts/minifier/minify_contracts.sh ---
#!/usr/bin/env bash
pushd ..
make build
popd
mkdir -p ./res-min/base/
cp ../res/* ./res-min/base/

cd res-min
for p in ./base/*.wasm ; do
  w=$(basename -- $p)
  ../minify.sh $p
  cp $p stripped-$w
  wasm-strip stripped-$w
  echo $w `stat -f %z stripped-$w` " -> " `stat -f %z minified-$w`
done

'''
'''--- contracts/oracle/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>
-->

# CHANGELOG: Registry

## Unreleased

### Features

### Breaking Changes

### Bug Fixes

## v1.2.0 (2024-01-25)

### Breaking Changes

- `class_metadata` has been renamed to `sbt_class_metadata` to unify the SBT Issuer interface.

## v1.1.0 (2023-12-20)

### Features

- `admin_mint` to allow manual verification and manual mint by the admin / dao.
- `get_admins` query.
- Added `ClassMetadata` to the Oracle contract and the `class_metadata` query.

## Improvements

- Decrease `sbt_mint` recommended storage deposit.

## v1.0.1 (2023-08-17)

## v1.0.0 (2023-05-20)

'''
'''--- contracts/oracle/Cargo.toml ---
[package]
name = "oracle-sbt"
version = "1.2.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

cost = { path = "../cost" }
sbt = { path = "../sbt" }

[dev-dependencies]
rand = "^0.7"
near-primitives.workspace = true
ed25519-dalek.workspace = true

# integration tests
pretty_assertions.workspace = true
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-units.workspace = true
tracing.workspace = true
near-crypto = "^0"
chrono = "0.4.26"

test-util = { path = "../test-util" }

'''
'''--- contracts/oracle/README.md ---
# Oracle SBT

Status: Proof of Concept
Based on SBT NEP: https://github.com/near/NEPs/pull/393

See root [README](../../README.md#testnet) for deployed smart contract addresses.

The Oracle SBT mints SBT based on an authority oracle. This is used to provide NEAR SBT as a representation of externally verified identity (Fractal, Verisoul, GoodDollar, KYC...).

Overview:

- During contract initialization, authority public key (`authority_pubkey`) is set. It's used to verify signatures.
- User requests an SBT off-chain by interacting with the oracle authority to obtain a valid `Claim`.
- The `Claim` contains his AccountId and associated ID related to his external identity.
- authority, off chain, upon user authentication, signs the `Claim` with a private key associated to the `authority_pubkey`.
- Once having signed `Claim`, user makes `sbt_issue` transaction with base64 borsh serialized Claim to self mint SBT.
- Upon successful `Claim` verification SBT is minted:
  - `Claim` signature is correct
  - `Claim.user == transaction signer`
  - `Claim.timestamp` is not later than `now + claim_ttl`
  - `Claim.external_id` nor `Claim.user` has not been used.

## Design

Currently the Oracle smart contract is used to mint SBTs based Fractal ID verification. User can receive Fractal FV SBT (class=1) if s/he passed Fractal Face Scan verification, and additionally Fractal KYC (class=2) if s/he passed KYC check.

The goal of the oracle contract is to attest off chain fact, and mint SBT. The general logic is following:

1. User has an external (off the NEAR blockchain) account, with properties we want to attest. Examples:

   - [GoodDollar verified account](https://help.gooddollar.org/kb/getting-started/how-to-complete-face-verification-process), used for verifying unique humans to receive $GD UBI
   - Twitter blue checkmark
   - GitCoin passport
   - Fractal ID, attesting various verification levels: Face Scan, Proof of Address...

2. The `oracle` smart contract provides a logic to attest property of an externally owned account in order to validate SBT minting request. The [`sbt_mint`](https://github.com/alpha-fi/i-am-human/blob/master/contracts/oracle/src/lib.rs#L120) function requires a [`Claim`](https://github.com/alpha-fi/i-am-human/blob/master/contracts/oracle/src/util.rs#L14) and `claim_sig`

3. `claim_sig` is the ed25519 signature of the Claim bytes (using Borsh serialization).

   - Smart contract contains `authority_pubkey`, which is used to validate the signature. Only Claim signed by the approved authority are accepted by the smart contract.
   - For Fractal ID verification, we are using the [verification oracle](https://github.com/near-ndc/verification-oracle) as the service creating and signing the claims.

4. The Claim is created (and signed) by an external service, and provided to `sbt_mint` function as Borsh serialized and then base64 into the string format. The `Claim` provides all data required to properly attest an external account:

   - `claimer`: a NEAR account that is a subject of the claim.
   - `external_id`: an external account identity. The oracle contract makes sure that each external identity is used only once. - `timestamp`: Unix Timestamp (in seconds) when the claim is made.
   - `verified_kyc`: property custom to the application of the oracle contract for NDC GWG: flag checking if the claim

5. In the current version of the oracle, the property we are attesting is implicit - meaning we don't explicitly set it in the Claim. Instead it's subsumed by the flow and the `Claim.verified_kyc`. The smart contract checks that `external_id` is used only once, hence the current version doesn't support claims attesting different properties.
   So, it's not possible to make a 2 different claims about the same external account.

6. The `sbt_mint` function must be called by the account which is a subject of the Claim. In other words, predecessor account ID must equal to `Claim.claimer`. The function will:

   - checks if the predecessor is a root account or an implicit account
   - deserializes Claim
   - validates signature
   - validates that the external identity was not used
   - checks if there is enough deposit required to cover minting storage cost
   - request the IAH registry to mint FV SBT and KYC SBT (only when `verified_kyc` is set in the Claim)

## Example Flow

Consider Alice who wants to get Fractal FV SBT.

1. Alice logs in to the Fractal ID system to obtain FV credential (off chain). She is using [i-am-human.app](https://i-am-human.app) (IAH app) to facilitate the whole process.
2. The IAH app will request authentication token from the Fractal ID and pass it to the IAH Verification Oracle to authenticate Alice and check if she has Face Scan credential.
3. IAH Verification Oracle creates and signs a Claim and returns it to the IAH app.
4. IAH app prepares a transaction with the Claim and the Claim signature.
5. Alice sends the signs and sends the transaction to the IAH oracle smart contract.
6. IAH oracle smart contract validates the Claim, and once everything is all right, will mint SBT through the IAH Registry.

NOTE: SBT tokens are minted through a SBT registry - a separate contract responsible for registering SBTs. Basically, the issuer and token registry are separated to provide expected functionality of Soul Bound Tokens.
See the [NEP-393](https://github.com/near/NEPs/pull/393) standard for more details.

## Decentralization

The smart contract can be easily extended to assure Fractal Oracle decentralization

- select multiple, verified parties who will provide oracle service. Each oracle has to provide a security stake.

'''
'''--- contracts/oracle/babel.config.json ---
{
    "plugins": [
        "near-sdk-js/lib/build-tools/near-bindgen-exporter",
        [
            "@babel/plugin-proposal-decorators",
            {
                "version": "legacy"
            }
        ]
    ],
    "presets": [
        "@babel/preset-typescript"
    ]
}
'''
'''--- contracts/oracle/integration/test-oracle.ava.js ---
import { Worker, NEAR, Gas } from "near-workspaces";
import test from "ava";

const claim_b64 = "EQAAAGNsYWltZXIudGVzdC5uZWFyBAAAADB4MWELAAAAAAAAAAA="; //base64 of Claim 
const sig_b64 = "6163iDaU8LNe+uiihqs+cwXQHd/wPwBcXBHiD02Bdp/Y/+/R8/Ev1kMwNZPRTKXb/q84zNy7eOdoljIM2i0nCw=="; //base64 of signature of Claim 

const claim_b64_with_kyc = "EQAAAGNsYWltZXIudGVzdC5uZWFyBAAAADB4MWELAAAAAAAAAAE="; //base64 of Claim 
const sig_b64_with_kyc = "jwjzUJYiIsCSsnxbNhV8zXrjY7UvWN4e3d9nQePJohbwYw7iaMen65zShn3DO7r1C+ZQv179KoJabduSxCbzDw=="; //base64 of signature of Claim 

const external_id = "0x1a";

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etc.
  const root = worker.rootAccount;
  const registry = await root.createSubAccount('registry')
  const oracle = await root.createSubAccount('oracle');
  const admin = await root.createSubAccount('admin');
  const claimer = await root.createSubAccount('claimer');
  // Deploy and initialize registry
  await registry.deploy("../res/registry.wasm");
  await registry.call(registry, "new", {'authority': admin.accountId });

  // Deploy and initialize oracle
  await oracle.deploy("../res/oracle_sbt.wasm");
  const sbtMetadata = {spec: "v1.0.0", name: "test-sbt", symbol: "SBT"};
  await oracle.call(oracle, "new", 
   {'authority': "1npXqp38AmvmWL3ZkC4Y/Cts5yb3od7ZnHeQUxWWpDU=", //base64 of authority pub key used for claim signature authorization
    'metadata': sbtMetadata,
    'registry': registry.accountId,
    'claim_ttl': 100000000000,
    'admin': admin.accountId, });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { registry_contract: registry, oracle_contract: oracle, admin, claimer };
});

test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed tear down the worker:", error);
  });
});

test("Should fail: mint sbt, oracle is not an issuer", async (t) => {
  const {oracle_contract, claimer } = t.context.accounts;
  const mint_result = await claimer.call(oracle_contract, "sbt_mint",
    { 'claim_b64': claim_b64,
      'claim_sig' : sig_b64 },
    { attachedDeposit: NEAR.parse("0.008 N").toString() },
    { gas: Gas.parse('20 Tgas') }).catch((error) => { console.log('Transaction error:', error);});
  t.deepEqual(mint_result, {Err: 'registry.sbt_mint failed'});
  const is_used_identity = await oracle_contract.view("is_used_identity", { 'external_id': external_id});
  t.false(is_used_identity);
});

test("Should pass: mint sbt, oracle is an issuer", async (t) => {
  const { registry_contract, oracle_contract, admin, claimer } = t.context.accounts;
  const add_issuer_result = await admin.call(registry_contract, "admin_add_sbt_issuer", {'issuer': oracle_contract.accountId});
  t.is(add_issuer_result, true);
  const mint_result =  await claimer.call(oracle_contract, "sbt_mint",
    { 'claim_b64': claim_b64,
      'claim_sig' : sig_b64 },
    { attachedDeposit: NEAR.parse("0.008 N").toString() },
    { gas: Gas.parse('20 Tgas') }).catch((error) => { console.log('Transaction error:', error);});
  t.not(mint_result, undefined);
  const is_used_identity = await oracle_contract.view("is_used_identity", { 'external_id': external_id});
  t.true(is_used_identity);
});

test("Should pass: mint sbt token and revoke (burn)", async (t) => {
  const { registry_contract, oracle_contract, admin, claimer } = t.context.accounts;
  const add_issuer_result = await admin.call(registry_contract, "admin_add_sbt_issuer", {'issuer': oracle_contract.accountId});
  t.is(add_issuer_result, true);
  let supply_by_issuer = await registry_contract.view("sbt_supply", {'issuer': oracle_contract.accountId});
  t.assert(supply_by_issuer === 0);
  const mint_result =  await claimer.call(oracle_contract, "sbt_mint",
    { 'claim_b64': claim_b64,
      'claim_sig' : sig_b64 },
    { attachedDeposit: NEAR.parse("0.008 N").toString() },
    { gas: Gas.parse('20 Tgas') }).catch((error) => { console.log('Transaction error:', error);});
  t.not(mint_result, undefined);
  const is_used_identity = await oracle_contract.view("is_used_identity", { 'external_id': external_id});
  t.true(is_used_identity);
  supply_by_issuer = await registry_contract.view("sbt_supply", {'issuer': oracle_contract.accountId});
  t.assert(supply_by_issuer === 1);
  await admin.call(oracle_contract, "sbt_revoke", {'tokens': [mint_result.Ok], 'burn': true}, { gas: Gas.parse('20 Tgas') });
  supply_by_issuer = await registry_contract.view("sbt_supply", {'issuer': oracle_contract.accountId});
  t.assert(supply_by_issuer === 0);
})

test("Should pass: mint sbt token and kyc token", async (t) => {
  //TODO: add integration test when verified_kyc == true
  const { registry_contract, oracle_contract, admin, claimer } = t.context.accounts;
  const add_issuer_result = await admin.call(registry_contract, "admin_add_sbt_issuer", {'issuer': oracle_contract.accountId});
  t.is(add_issuer_result, true);
  let supply_by_issuer = await registry_contract.view("sbt_supply", {'issuer': oracle_contract.accountId});
  t.assert(supply_by_issuer === 0);
  const mint_result =  await claimer.call(oracle_contract, "sbt_mint",
    { 'claim_b64': claim_b64_with_kyc,
      'claim_sig' : sig_b64_with_kyc },
    { attachedDeposit: NEAR.parse("0.015 N").toString() },
    { gas: Gas.parse('20 Tgas') }).catch((error) => { console.log('Transaction error:', error);});
  t.not(mint_result, undefined);
  console.log("mint result",mint_result.Ok);
  const is_used_identity = await oracle_contract.view("is_used_identity", { 'external_id': external_id});
  t.true(is_used_identity);
  supply_by_issuer = await registry_contract.view("sbt_supply", {'issuer': oracle_contract.accountId});
  t.assert(supply_by_issuer === 2);
})
'''
'''--- contracts/oracle/package.json ---
{
    "name": "oracle-integration-tests",
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "build": "make build-all",
        "rebuild": "rm -rf node_modules && rm -rf build && yarn install && yarn run build",
        "test": "ava --verbose --timeout=10m"
    },
    "dependencies": {
        "js-base64": "^3.7.5",
        "lodash-es": "^4.17.21",
        "near-sdk-js": "^1.0"
    },
    "devDependencies": {
        "ava": "^5.2.0",
        "near-workspaces": "^3.3.0"
    },
    "private": true
}
'''
'''--- contracts/oracle/src/checks.rs ---
#[cfg(all(test, not(target_arch = "wasm32")))]
pub mod tests {
    use crate::*;

    pub fn deserialize_claim(claim_b64: &str) -> Claim {
        let c_bz = crate::b64_decode("claim", claim_b64.to_string()).unwrap();
        let c = Claim::try_from_slice(&c_bz).unwrap();
        println!("claim: {:?}", c);
        c
    }

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    #[test]
    fn borsh_simple() {
        let borsh_input = Claim {
            claimer: alice(),
            external_id: "0xb4bf0f23c702efb8a9da87a94095e28de3d21cc3".to_owned(),
            timestamp: 0,
            verified_kyc: false,
        };

        let borsh_serialized: Vec<u8> = borsh_input.try_to_vec().unwrap();
        let base64_encoded = near_primitives::serialize::to_base64(borsh_serialized.as_slice());
        println!(
            "Using NEAR CLI, this is the base64-encoded value to use: {:?}",
            base64_encoded
        );
    }

    #[test]
    fn claim_deserialization_check() {
        let c = deserialize_claim(
            "CgAAAGFsaWNlLm5lYXIqAAAAMHhiNGJmMGYyM2M3MDJlZmI4YTlkYTg3YTk0MDk1ZTI4ZGUzZDIxY2MzAAAAAAAAAAAA",
        );
        println!("claim: {:?}", c);
        assert_eq!(
            c.external_id, "0xb4bf0f23c702efb8a9da87a94095e28de3d21cc3",
            "deserialization check"
        );
    }
}

'''
'''--- contracts/oracle/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::{base64, FunctionError};

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq))]
#[derive(Debug)]
pub enum CtrError {
    Borsh(String),
    B64Err {
        /// name of the argument being decoded
        arg: String,
        err: base64::DecodeError,
    },
    BadRequest(String),
    DuplicatedID(String),
    Signature(String),
    Registry,
}

impl FunctionError for CtrError {
    fn panic(&self) -> ! {
        // check how we can do this:
        // panic_str(match self {
        //     CtrError::Borsh(e) => &format!("can't borsh decode {}", e),
        //     CtrError::B64Err { arg, .. } => &format!("can't base64 decode {}", arg),
        //     CtrError::BadRequest(s) => s.as_ref(),
        // });

        match self {
            CtrError::Borsh(e) => panic_str(&format!("can't borsh-decode {}", e)),
            CtrError::B64Err { arg, .. } => panic_str(&format!("can't base64-decode {}", arg)),
            CtrError::BadRequest(s) => panic_str(s.as_ref()),
            CtrError::DuplicatedID(s) => panic_str(&format!("duplicated id: {}", s)),
            CtrError::Signature(s) => panic_str(&format!("signature error: {}", s)),
            CtrError::Registry => panic_str("registry operation failed"),
        }
    }
}

'''
'''--- contracts/oracle/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::serde::Serialize;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault, Promise, PromiseError,
};

#[allow(unused_imports)]
use near_sdk::__private::schemars;

use cost::*;
use sbt::*;
use uint::hex;

// TODO
// use near_sdk::bs58 -- use public key in the base58 format

pub use crate::errors::*;
pub use crate::storage::*;
pub use crate::util::*;

mod errors;
mod migrate;
mod storage;
mod util;

pub const CLASS_FV_SBT: ClassId = 1;
pub const CLASS_KYC_SBT: ClassId = 2;

// Total storage deposit cost without KYC
pub const MINT_TOTAL_COST: Balance = mint_deposit(1);
pub const MINT_TOTAL_COST_WITH_KYC: Balance = mint_deposit(2);

pub const ELECTIONS_START: u64 = 1693612799000; // Fri, 1 Sep 2023 23:59:59 UTC in ms
pub const ELECTIONS_END: u64 = 1695427199000; // Fri, 22 Sep 2023 23:59:59 UTC in ms

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // contract metadata
    pub metadata: LazyOption<ContractMetadata>,

    /// SBT registry
    pub registry: AccountId,

    /// max duration (in seconds) a claim is valid for processing
    pub claim_ttl: u64,
    /// SBT ttl until expire in miliseconds (expire=issue_time+sbt_ttl)
    pub sbt_ttl_ms: u64,
    /// ed25519 pub key (could be same as a NEAR pub key)
    pub authority_pubkey: [u8; PUBLIC_KEY_LEN], // Vec<u8>,
    pub used_identities: UnorderedSet<Vec<u8>>,

    /// used for backend key rotation
    pub admins: UnorderedSet<AccountId>,

    /// class metadata
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    /// @authority: base64 of authority pub key used for claim signature authorization.
    /// @metadata: NFT like metadata about the contract.
    /// @registry: the SBT registry responsable for the "soul transfer".
    /// @claim_ttl: max duration (in seconds) a claim is valid for processing.
    ///   If zero default (1 day) is used.
    #[init]
    pub fn new(
        authority: String,
        metadata: ContractMetadata,
        registry: AccountId,
        claim_ttl: u64,
        admin: AccountId,
    ) -> Self {
        let claim_ttl = if claim_ttl == 0 {
            3600 * 24 // 1 day
        } else {
            claim_ttl
        };
        let mut admins = UnorderedSet::new(StorageKey::Admins);
        admins.insert(&admin);
        Self {
            registry,
            metadata: LazyOption::new(StorageKey::ContractMetadata, Some(&metadata)),
            claim_ttl,
            sbt_ttl_ms: 1000 * 3600 * 24 * 548, // 1.5years in ms
            authority_pubkey: pubkey_from_b64(authority),
            used_identities: UnorderedSet::new(StorageKey::UsedIdentities),
            admins,
            class_metadata: LookupMap::new(StorageKey::ClassMetadata),
        }
    }

    /**********
     * QUERIES
     *
     * Note: all SBT queries should be done through registry
     **********/

    /// Returns list of admins
    pub fn get_admins(&self) -> Vec<AccountId> {
        self.admins.iter().collect()
    }

    #[inline]
    pub fn required_sbt_mint_deposit(is_verified_kyc: bool) -> Balance {
        if is_verified_kyc {
            return MINT_TOTAL_COST_WITH_KYC;
        };
        MINT_TOTAL_COST
    }

    /// Checks if the given id was already used to mint an sbt
    pub fn is_used_identity(&self, external_id: String) -> bool {
        let normalised_id = normalize_external_id(external_id).expect("failed to normalize id");
        self.used_identities.contains(&normalised_id)
    }

    /**********
     * FUNCTIONS
     **********/

    /// Mints a new SBT for the transaction signer.
    /// @claim_b64: standard base64 borsh serialized Claim (same bytes as used for the claim signature).
    /// @claim_sig: standard base64 serialized ed25519 signature.
    /// If `metadata.expires_at` is None then we set it to ` now+self.ttl`.
    /// Panics if `metadata.expires_at > now+self.ttl`.
    /// Throws an error if trying to mint during the elections period.
    // TODO: update result to return TokenId
    #[handle_result]
    #[payable]
    pub fn sbt_mint(
        &mut self,
        claim_b64: String,
        claim_sig: String,
        memo: Option<String>,
    ) -> Result<Promise, CtrError> {
        let now_ms = env::block_timestamp_ms();
        let this_acc = env::current_account_id();
        // only stop in prod
        if this_acc.as_str().ends_with("i-am-human.near")
            && now_ms > ELECTIONS_START
            && now_ms <= ELECTIONS_END
        {
            return Err(CtrError::BadRequest(
                "IAH SBT cannot be mint during the elections period".to_owned(),
            ));
        }

        let user = env::signer_account_id();
        if !is_supported_account(user.as_ref().chars()) {
            return Err(CtrError::BadRequest(
                "only root and implicit accounts are allowed to get SBT".to_owned(),
            ));
        }

        let claim_bytes = b64_decode("claim_b64", claim_b64)?;
        let claim = Claim::try_from_slice(&claim_bytes)
            .map_err(|_| CtrError::Borsh("claim".to_string()))?;
        let signature = b64_decode("claim_sig", claim_sig)?;
        verify_claim(&signature, &claim_bytes, &self.authority_pubkey)?;

        let storage_deposit = Self::required_sbt_mint_deposit(claim.verified_kyc);
        require!(
            env::attached_deposit() >= storage_deposit,
            format!(
                "Requires attached deposit at least {} yoctoNEAR",
                storage_deposit
            )
        );
        let num_tokens = if claim.verified_kyc { 2 } else { 1 };

        let now = now_ms / 1000;
        if claim.timestamp > now {
            return Err(CtrError::BadRequest(
                "claim.timestamp in the future".to_string(),
            ));
        }
        if now >= claim.timestamp + self.claim_ttl {
            return Err(CtrError::BadRequest("claim expired".to_string()));
        }

        if claim.claimer != user {
            return Err(CtrError::BadRequest(
                "claimer is not the transaction signer".to_string(),
            ));
        }
        let external_id = normalize_external_id(claim.external_id)?;

        if self.used_identities.contains(&external_id) {
            return Err(CtrError::DuplicatedID("external_id".to_string()));
        }

        let mut tokens_metadata: Vec<TokenMetadata> = Vec::new();
        tokens_metadata.push(TokenMetadata {
            class: CLASS_FV_SBT,
            issued_at: Some(now_ms),
            expires_at: Some(now_ms + self.sbt_ttl_ms),
            reference: None,
            reference_hash: None,
        });
        //KYC token to be minted. Class is set to `2` to differentiate the token
        if claim.verified_kyc {
            tokens_metadata.push(TokenMetadata {
                class: CLASS_KYC_SBT,
                issued_at: Some(now_ms),
                expires_at: Some(now_ms + self.sbt_ttl_ms),
                reference: None,
                reference_hash: None,
            });
        }

        self.used_identities.insert(&external_id);

        if let Some(memo) = memo {
            env::log_str(&format!("SBT mint memo: {}", memo));
        }

        let result = ext_registry::ext(self.registry.clone())
            .with_attached_deposit(storage_deposit)
            .with_static_gas(calculate_mint_gas(num_tokens))
            .sbt_mint(vec![(claim.claimer, tokens_metadata)])
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 3)
                    .sbt_mint_callback(hex::encode(external_id)),
            );

        Ok(result)
    }

    // We use our own result type, because NEAR stopped to support standard `Result` return
    // type without `handle_result`. With `handle_result` we would need to make an ugly wrap
    // to always return Ok at the outer layer:
    //     Result<Result<TokenId, &str>, near_sdk::Abort>
    // The problem is that NEAR explorer considers transaction successfull if the last receipt
    // didn't panic. However, if we do so, then we can't panic in this function in order to
    // preserve the state change (rollback for `used_identities`).
    // Other solution (probably the right one) is to schedule another callback to "self" which
    // will panic.
    // Ideally, though, NEAR will start considering Result types again.
    #[private]
    pub fn sbt_mint_callback(
        &mut self,
        external_id: String,
        #[callback_result] last_result: Result<Vec<TokenId>, PromiseError>,
    ) -> CallbackResult<TokenId, &str> {
        match last_result {
            Ok(v) => CallbackResult::Ok(v[0]),
            Err(_) => {
                // registry mint failed, need to rollback. We can't panic here in order to
                // preserve state change.
                // We are safe to remove the external identity, because we only call registry
                // if the external_id was not used before.
                self.used_identities
                    .remove(&hex::decode(external_id).unwrap());
                CallbackResult::Err("registry.sbt_mint failed")
            }
        }
    }

    // Revokes the provided token list from the registry.
    // Must be called by an admin
    pub fn sbt_revoke(&mut self, tokens: Vec<TokenId>, burn: bool) -> Promise {
        self.assert_admin();
        ext_registry::ext(self.registry.clone())
            .with_static_gas(MINT_GAS * tokens.len() as u64)
            .sbt_revoke(tokens, burn)
    }

    /**********
     * ADMIN
     **********/

    /* for testing the callback
        #[payable]
        pub fn admin_mint(&mut self, recipient: AccountId, external_id: String) -> Promise {
            let external_id = normalize_external_id(external_id).ok().unwrap();
            let now = env::block_timestamp_ms();
            let metadata = TokenMetadata {
                class: 2,
                issued_at: Some(now),
                expires_at: Some(now + self.sbt_ttl_ms),
                reference: None,
                reference_hash: None,
            };
            ext_registry::ext(self.registry.clone())
                .with_attached_deposit(MINT_COST)
                .with_static_gas(MINT_GAS)
                .sbt_mint(vec![(recipient, vec![metadata])])
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(Gas::ONE_TERA * 3)
                        .sbt_mint_callback(hex::encode(external_id)),
                )
        }
    */

    /// @authority: pubkey used to verify claim signature
    pub fn admin_change_authority(&mut self, authority: String) {
        self.assert_admin();
        self.authority_pubkey = pubkey_from_b64(authority);
    }

    pub fn add_admin(&mut self, admin: AccountId) {
        self.assert_admin();
        self.admins.insert(&admin);
    }

    pub fn remove_admin(&mut self, admin: AccountId) {
        self.assert_admin();
        self.admins.remove(&admin);
    }

    #[inline]
    fn assert_admin(&self) {
        require!(
            self.admins.contains(&env::predecessor_account_id()),
            "not an admin"
        );
    }

    /// Allows admin to update class metadata.
    /// Panics if not admin or the class is not found (Currently oracle only supports classes: [1,2])
    #[handle_result]
    pub fn set_class_metadata(
        &mut self,
        class: ClassId,
        metadata: ClassMetadata,
    ) -> Result<(), CtrError> {
        self.assert_admin();
        if class != 1 && class != 2 {
            return Err(CtrError::BadRequest("class not found".to_string()));
        }
        self.class_metadata.insert(&class, &metadata);
        Ok(())
    }

    /// Alows admin to mint SBTs with a of the `class_id` to the provided list of pairs:
    /// `(recipient_account, expire_timestamp_ms)`.
    /// Panics if not called by an admin or the attached deposit is insufficient.
    #[payable]
    pub fn admin_mint(
        &mut self,
        mint_data: Vec<(AccountId, u64)>,
        class: ClassId,
        memo: Option<String>,
    ) -> Promise {
        self.assert_admin();

        let num_tokens = mint_data.len();
        let deposit = env::attached_deposit();
        let required_deposit = mint_deposit(num_tokens);
        require!(
            deposit >= required_deposit,
            format!("Requires min {}yoctoNEAR storage deposit", required_deposit)
        );
        require!(
            class == CLASS_FV_SBT || class == CLASS_KYC_SBT,
            "wrong request, class must be either 1 (FV) or 2 (KYC)"
        );

        if deposit > required_deposit {
            Promise::new(env::predecessor_account_id()).transfer(deposit - required_deposit);
        }

        let now: u64 = env::block_timestamp_ms();
        let mut tokens_metadata: Vec<(AccountId, Vec<TokenMetadata>)> =
            Vec::with_capacity(num_tokens);
        for (acc, end) in mint_data {
            tokens_metadata.push((
                acc,
                vec![TokenMetadata {
                    class,
                    issued_at: Some(now),
                    expires_at: Some(end),
                    reference: None,
                    reference_hash: None,
                }],
            ));
        }

        if let Some(memo) = memo {
            env::log_str(&format!("SBT mint memo: {}", memo));
        }

        ext_registry::ext(self.registry.clone())
            .with_attached_deposit(required_deposit)
            .with_static_gas(calculate_mint_gas(num_tokens))
            .sbt_mint(tokens_metadata)
    }

    // TODO:
    // - fn sbt_renew
}

#[near_bindgen]
impl SBTIssuer for Contract {
    fn sbt_metadata(&self) -> ContractMetadata {
        self.metadata.get().unwrap()
    }
    /// Returns `ClassMetadata` by class. Returns none if the class is not found.
    fn sbt_class_metadata(&self, class: ClassId) -> Option<ClassMetadata> {
        self.class_metadata.get(&class)
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(schemars::JsonSchema, borsh::BorshSchema)
)]
pub enum CallbackResult<T, E> {
    Ok(T),
    Err(E),
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod checks;

#[cfg(all(test, not(target_arch = "wasm32")))]
pub mod tests {
    use crate::*;
    use ed25519_dalek::Keypair;
    use near_sdk::test_utils::test_env::{alice, bob};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    use crate::util::tests::{acc_claimer, b64_encode, gen_key, mk_claim_sign};

    fn acc_u1() -> AccountId {
        "user2.near".parse().unwrap()
    }

    fn acc_registry() -> AccountId {
        "registry".parse().unwrap()
    }

    fn acc_admin() -> AccountId {
        "admin".parse().unwrap()
    }

    fn acc_implicit() -> AccountId {
        "061b1dd17603213b00e1a1e53ba060ad427cef4887bd34a5e0ef09010af23b0a"
            .parse()
            .unwrap()
    }

    // wrong implicit account
    fn acc_bad_implicit() -> AccountId {
        "061b1dd17603213b00e1a1e53ba060ad427cef4887bd34a5e0ef09010af23b0"
            .parse()
            .unwrap()
    }

    fn start() -> u64 {
        11 * SECOND
    }

    fn class_metadata() -> ClassMetadata {
        ClassMetadata {
            name: "test_1".to_string(),
            symbol: None,
            icon: None,
            reference: None,
            reference_hash: None,
        }
    }

    /// SBT claim ttl in seconds
    const CLAIM_TTL: u64 = 2;

    fn setup(signer: &AccountId, predecessor: &AccountId) -> (VMContext, Contract, Keypair) {
        let ctx = VMContextBuilder::new()
            .signer_account_id(signer.clone())
            .predecessor_account_id(predecessor.clone())
            .attached_deposit(MINT_TOTAL_COST * 5)
            .block_timestamp(start())
            .current_account_id("oracle.near".parse().unwrap())
            .is_view(false)
            .build();

        let keypair = gen_key();
        let ctr = Contract::new(
            b64_encode(keypair.public.to_bytes().to_vec()),
            ContractMetadata {
                spec: STANDARD_NAME.to_string(),
                name: "name".to_string(),
                symbol: "symbol".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
            acc_registry(),
            CLAIM_TTL,
            acc_admin(),
        );
        testing_env!(ctx.clone());

        (ctx, ctr, keypair)
    }

    fn assert_bad_request(resp: Result<Promise, CtrError>, expected_msg: &str) {
        match resp {
            Err(CtrError::BadRequest(s)) => {
                assert_eq!(s, expected_msg)
            }
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }
    }

    // TODO: find out how to test out of gas.
    /*
    #[test]
    #[should_panic(expected = "todo")]
    fn mint_not_enough_gas() {
        let signer = acc_claimer();
        let (mut ctx, mut ctr, k) = setup(&signer, &acc_u1());

        ctx.prepaid_gas = MINT_GAS - Gas(1);
        testing_env!(ctx);
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k);
        let _ = ctr.sbt_mint(c_str.clone(), sig.clone(), None);
    }
    */

    #[test]
    fn add_admin() {
        let (_, mut ctr, _) = setup(&acc_claimer(), &acc_admin());
        ctr.add_admin(acc_u1());
        assert_eq!(ctr.get_admins(), vec![acc_admin(), acc_u1()]);

        ctr.remove_admin(acc_admin());
        assert_eq!(ctr.get_admins(), vec![acc_u1()]);
    }

    #[test]
    #[should_panic(
        expected = "Requires attached deposit at least 9000000000000000000000 yoctoNEAR"
    )]
    fn mint_not_enough_storage_deposit() {
        let signer = acc_claimer();
        let (mut ctx, mut ctr, k) = setup(&signer, &acc_u1());

        // fail: not enough storage deposit
        ctx.attached_deposit = MINT_TOTAL_COST - 1;
        testing_env!(ctx);
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, false);
        let _ = ctr.sbt_mint(c_str, sig, None).expect("must panic");
    }

    #[test]
    #[should_panic(
        expected = "Requires attached deposit at least 18000000000000000000000 yoctoNEAR"
    )]
    fn mint_with_kyc_not_enough_storage_deposit() {
        let signer = acc_claimer();
        let (mut ctx, mut ctr, k) = setup(&signer, &acc_u1());

        // fail: not enough storage deposit
        ctx.attached_deposit = MINT_TOTAL_COST_WITH_KYC - 1;
        testing_env!(ctx);
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, true);
        let _ = ctr.sbt_mint(c_str, sig, None).expect("must panic");
    }

    #[test]
    fn mint_no_root_account() {
        let signer: AccountId = "user1.near.org".parse().unwrap();
        let predecessor: AccountId = "some.other".parse().unwrap();
        let (mut ctx, mut ctr, k) = setup(&signer, &predecessor);

        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, false);
        assert_bad_request(
            ctr.sbt_mint(c_str.clone(), sig.clone(), None),
            "only root and implicit accounts are allowed to get SBT",
        );

        ctx.signer_account_id = "sub.user1.near".parse().unwrap();
        testing_env!(ctx.clone());
        assert_bad_request(
            ctr.sbt_mint(c_str.clone(), sig.clone(), None),
            "only root and implicit accounts are allowed to get SBT",
        );

        ctx.signer_account_id = "sub.sub.user1.near".parse().unwrap();
        testing_env!(ctx.clone());
        assert_bad_request(
            ctr.sbt_mint(c_str.clone(), sig.clone(), None),
            "only root and implicit accounts are allowed to get SBT",
        );

        ctx.signer_account_id = acc_bad_implicit();
        testing_env!(ctx.clone());
        assert_bad_request(
            ctr.sbt_mint(c_str.clone(), sig.clone(), None),
            "only root and implicit accounts are allowed to get SBT",
        );

        ctx.signer_account_id = acc_implicit();
        testing_env!(ctx);
        assert_bad_request(
            ctr.sbt_mint(c_str, sig, None),
            "claimer is not the transaction signer",
        );
    }

    #[test]
    fn claim_sig_and_sbt_mint() {
        let signer = "myaccount123.testnet".parse().unwrap();
        let (mut ctx, mut ctr, _) = setup(&signer, &signer);

        // test case based on
        // https://explorer.testnet.near.org/transactions/GobWuBgA9HLsUk4UTtVqrSiyy24P6B2cnywLfeh9mdtv

        ctr.claim_ttl = 100;
        ctx.block_timestamp = 1689675340 * SECOND;
        ctr.authority_pubkey =
            pubkey_from_b64("zqMwV9fTRoBOLXwt1mHxBAF3d0Rh9E9xwSAXR3/KL5E=".to_owned());
        testing_env!(ctx);

        let claim_b64 = "FAAAAG15YWNjb3VudDEyMy50ZXN0bmV0IAAAAGFmZWU5MmYwNzEyMjQ2NGU4MzEzYWFlMjI1Y2U1YTNmSGa2ZAAAAAAA".to_owned();
        let claim_sig_b64 = "38X2TnWgc6moc4zReAJFQ7BjtOUlWZ+i3YQl9gSMOXwnm5gupfHV/YGmGPOek6SSkotT586d4zTTT2U8Qh3GBw==".to_owned();

        let claim_bytes = b64_decode("claim_b64", claim_b64.clone()).unwrap();
        let signature = b64_decode("sig_b64", claim_sig_b64.clone()).unwrap();
        verify_claim(&signature, &claim_bytes, &ctr.authority_pubkey).unwrap();

        let r = ctr.sbt_mint(claim_b64, claim_sig_b64, None);
        match r {
            Ok(_) => (),
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
        }
    }

    #[test]
    fn flow1() {
        let signer = acc_claimer();
        let predecessor = acc_u1();
        let (mut ctx, mut ctr, k) = setup(&signer, &predecessor);
        // fail: tx signer is not claimer
        ctx.signer_account_id = acc_u1();
        testing_env!(ctx.clone());
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, false);
        match ctr.sbt_mint(c_str.clone(), sig.clone(), None) {
            Err(CtrError::BadRequest(s)) => assert_eq!(s, "claimer is not the transaction signer"),

            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }

        // fail: claim_ttl passed
        ctx.signer_account_id = signer.clone();
        ctx.block_timestamp = start() + CLAIM_TTL * SECOND;
        testing_env!(ctx.clone());
        match ctr.sbt_mint(c_str.clone(), sig.clone(), None) {
            Err(CtrError::BadRequest(s)) => {
                assert_eq!("claim expired", s, "wrong BadRequest: {}", s)
            }
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }

        // fail: claim_ttl passed way more
        ctx.signer_account_id = signer;
        ctx.block_timestamp = start() + CLAIM_TTL * 10 * SECOND;
        testing_env!(ctx.clone());
        match ctr.sbt_mint(c_str.clone(), sig.clone(), None) {
            Err(CtrError::BadRequest(s)) => {
                assert_eq!("claim expired", s, "wrong BadRequest: {}", s)
            }
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }

        // test case: claim.timestamp can't be in the future
        ctx.block_timestamp = start() - SECOND;
        testing_env!(ctx.clone());
        match ctr.sbt_mint(c_str.clone(), sig.clone(), None) {
            Err(CtrError::BadRequest(s)) => assert_eq!("claim.timestamp in the future", s),
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }

        // should create a SBT for a valid claim
        ctx.block_timestamp = start() + SECOND;
        testing_env!(ctx);
        let resp = ctr.sbt_mint(c_str.clone(), sig.clone(), None);
        assert!(resp.is_ok(), "should accept valid claim");

        // fail: signer already has SBT
        match ctr.sbt_mint(c_str, sig, None) {
            Err(CtrError::DuplicatedID(_)) => (),
            Err(error) => panic!("expected DuplicatedID, got: {:?}", error),
            Ok(_) => panic!("expected DuplicatedID, got: Ok"),
        }
    }

    #[test]
    fn mint_during_elections() {
        let signer = acc_claimer();
        let (mut ctx, mut ctr, k) = setup(&signer, &acc_u1());

        ctx.block_timestamp = (ELECTIONS_START + 1) * 1_000_000;
        ctx.current_account_id = "fractal.i-am-human.near".parse().unwrap();
        testing_env!(ctx.clone());
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, false);
        let res = ctr.sbt_mint(c_str, sig, None);
        assert!(res.is_err());
        assert_bad_request(res, "IAH SBT cannot be mint during the elections period");

        ctx.block_timestamp = ELECTIONS_END * 1_000_000;
        testing_env!(ctx);
        let (_, c_str, sig) = mk_claim_sign(start() / SECOND, "0x1a", &k, false);
        let res = ctr.sbt_mint(c_str, sig, None);
        assert!(res.is_err());
        assert_bad_request(res, "IAH SBT cannot be mint during the elections period");
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn set_class_metadata_not_admin() {
        let (_, mut ctr, _) = setup(&alice(), &alice());
        let _ = ctr.set_class_metadata(1, class_metadata());
    }

    #[test]
    fn set_class_metadata_wrong_class() {
        let (_, mut ctr, _) = setup(&alice(), &acc_admin());
        match ctr.set_class_metadata(3, class_metadata()) {
            Err(CtrError::BadRequest(_)) => (),
            Err(error) => panic!("expected BadRequest, got: {:?}", error),
            Ok(_) => panic!("expected BadRequest, got: Ok"),
        }
    }

    #[test]
    fn set_class_metadata() {
        let (_, mut ctr, _) = setup(&alice(), &acc_admin());
        match ctr.set_class_metadata(1, class_metadata()) {
            Ok(_) => (),
            Err(error) => panic!("expected Ok, got: {:?}", error),
        }
        assert_eq!(ctr.sbt_class_metadata(1).unwrap(), class_metadata());
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_mint_not_admin() {
        let (_, mut ctr, _) = setup(&alice(), &alice());
        let _ = ctr.admin_mint(vec![(bob(), 100)], CLASS_FV_SBT, None);
    }

    #[test]
    #[should_panic(expected = "Requires min")]
    fn admin_mint_wrong_deposit() {
        let (mut ctx, mut ctr, _) = setup(&alice(), &acc_admin());
        ctx.attached_deposit = 0;
        testing_env!(ctx);
        let _ = ctr.admin_mint(vec![(bob(), 100), (alice(), 100)], CLASS_FV_SBT, None);
    }

    #[test]
    fn admin_mint() {
        let (_, mut ctr, _) = setup(&alice(), &acc_admin());
        let _ = ctr.admin_mint(vec![(bob(), 100), (alice(), 100)], CLASS_KYC_SBT, None);
        let _ = ctr.admin_mint(vec![(bob(), 100), (alice(), 100)], CLASS_FV_SBT, None);
    }
}

'''
'''--- contracts/oracle/src/migrate.rs ---
use crate::*;

// registry/v1.3.0
#[derive(BorshDeserialize, PanicOnDefault)]
pub struct OldState {
    pub metadata: LazyOption<ContractMetadata>,
    pub registry: AccountId,
    pub claim_ttl: u64,
    pub sbt_ttl_ms: u64,
    pub authority_pubkey: [u8; PUBLIC_KEY_LEN],
    pub used_identities: UnorderedSet<Vec<u8>>,
    pub admins: UnorderedSet<AccountId>,
}

#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    /* pub  */
    pub fn migrate(class_metadata: Vec<(ClassId, ClassMetadata)>) -> Self {
        let old_state: OldState = env::state_read().expect("failed");
        // new field in the smart contract :
        // + class_metadata: LookupMap<ClassId, ClassMetadata>

        let mut c_metadata = LookupMap::new(StorageKey::ClassMetadata);
        for (class_id, class_metadata) in class_metadata {
            c_metadata.insert(&class_id, &class_metadata);
        }

        Self {
            metadata: old_state.metadata,
            registry: old_state.registry,
            claim_ttl: old_state.claim_ttl,
            sbt_ttl_ms: old_state.sbt_ttl_ms,
            authority_pubkey: old_state.authority_pubkey,
            used_identities: old_state.used_identities,
            admins: old_state.admins,
            class_metadata: c_metadata,
        }
    }
}

'''
'''--- contracts/oracle/src/storage.rs ---
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::BorshStorageKey;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Balances,
    TokenData,
    ContractMetadata,
    UsedIdentities,
    Admins,
    ClassMetadata,
}

'''
'''--- contracts/oracle/src/util.rs ---
use std::str::Chars;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{base64, env, AccountId};
use uint::hex;

pub use crate::errors::*;

pub const PUBLIC_KEY_LEN: usize = 32;
pub const SIGNATURE_LEN: usize = 64;

type CtrResult<T> = Result<T, CtrError>;

#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct Claim {
    pub claimer: AccountId,
    /// external, Ethereum compatible address. Must be a hex string, can start with "0x".
    pub external_id: String,
    /// unix time (seconds) when the claim was signed
    pub timestamp: u64,
    /// indicates whether the user has passed a KYC or not
    pub verified_kyc: bool,
}

pub(crate) fn normalize_external_id(id: String) -> Result<Vec<u8>, CtrError> {
    let id = id.strip_prefix("0x").unwrap_or(&id).to_lowercase();
    hex::decode(id).map_err(|s| CtrError::BadRequest(format!("claim.external_id: {}", s)))
}

pub fn b64_decode(arg: &str, data: String) -> CtrResult<Vec<u8>> {
    base64::decode(data).map_err(|e| CtrError::B64Err {
        arg: arg.to_string(),
        err: e,
    })
}

pub fn pubkey_from_b64(pubkey: String) -> [u8; PUBLIC_KEY_LEN] {
    let pk_bz = base64::decode(pubkey).expect("authority_pubkey is not a valid standard base64");
    pk_bz.try_into().expect("authority pubkey must be 32 bytes")
}

mod sys {
    extern "C" {
        #[allow(dead_code)]
        pub fn ed25519_verify(
            sig_len: u64,
            sig_ptr: u64,
            msg_len: u64,
            msg_ptr: u64,
            pub_key_len: u64,
            pub_key_ptr: u64,
        ) -> u64;
    }
}

#[cfg(not(all(test, not(target_arch = "wasm32"))))]
pub fn ed25519_verify(signature: &[u8; 64], message: &[u8], pubkey: &[u8; 32]) -> bool {
    unsafe {
        sys::ed25519_verify(
            signature.len() as _,
            signature.as_ptr() as _,
            message.len() as _,
            message.as_ptr() as _,
            pubkey.len() as _,
            pubkey.as_ptr() as _,
        ) == 1
    }
}

#[cfg(test)]
use ed25519_dalek::{PublicKey, Signature, Verifier};

#[cfg(all(test, not(target_arch = "wasm32")))]
pub fn ed25519_verify(signature: &[u8; 64], message: &[u8], pubkey: &[u8; 32]) -> bool {
    let pk = PublicKey::from_bytes(pubkey).unwrap();
    match Signature::from_bytes(signature) {
        Ok(sig) => pk.verify(message, &sig).is_ok(),
        Err(_) => false,
    }
}

pub fn verify_claim(
    claim_sig: &Vec<u8>,
    claim: &Vec<u8>,
    pubkey: &[u8; PUBLIC_KEY_LEN],
) -> Result<(), CtrError> {
    let claim_sig: &[u8; SIGNATURE_LEN] = claim_sig
        .as_slice()
        .try_into()
        .expect("signature must be 64 bytes");
    match ed25519_verify(claim_sig, claim, pubkey) {
        true => Ok(()),
        false => Err(CtrError::Signature("invalid signature".to_string())),
    }
}

/// only root accounts and implicit accounts are supported
pub(crate) fn is_supported_account(account: Chars) -> bool {
    let mut num_dots = 0;
    let mut len = 0;
    let mut all_hex = true;
    for c in account {
        len += 1;
        if c == '.' {
            num_dots += 1;
        }
        all_hex = all_hex && c.is_ascii_hexdigit();
    }
    if num_dots == 1 {
        return true;
    }
    // check if implicit account only for mainnet and testnet
    if num_dots == 0 {
        let a = env::current_account_id();
        let a = a.as_str();
        if a.ends_with(".near") || a.ends_with(".testnet") {
            return len == 64 && all_hex;
        }
        return true;
    }
    false
}

#[cfg(all(test, not(target_arch = "wasm32")))]
pub mod tests {
    extern crate ed25519_dalek;
    extern crate rand;
    use ed25519_dalek::{Keypair, Signer};
    use rand::rngs::OsRng;

    use uint::hex::FromHexError;

    use super::*;
    use crate::checks::tests::deserialize_claim;

    pub fn gen_key() -> Keypair {
        let mut csprng = OsRng {};
        Keypair::generate(&mut csprng)
    }

    pub fn acc_claimer() -> AccountId {
        "user1.near".parse().unwrap()
    }

    pub fn b64_encode(data: Vec<u8>) -> String {
        near_sdk::base64::encode(data)
    }

    /// @timestamp: in seconds
    pub fn mk_claim(timestamp: u64, external_id: &str, is_verified_kyc: bool) -> Claim {
        Claim {
            claimer: acc_claimer(),
            external_id: external_id.to_string(),
            timestamp,
            verified_kyc: is_verified_kyc,
        }
    }

    // returns b64 serialized claim and signature
    pub fn sign_claim(c: &Claim, k: &Keypair) -> (String, String) {
        let c_bz = c.try_to_vec().unwrap();
        let sig = k.sign(&c_bz);
        let sig_bz = sig.to_bytes();
        (b64_encode(c_bz), b64_encode(sig_bz.to_vec()))
    }

    pub fn mk_claim_sign(
        timestamp: u64,
        external_id: &str,
        k: &Keypair,
        is_verified_kyc: bool,
    ) -> (Claim, String, String) {
        let c = mk_claim(timestamp, external_id, is_verified_kyc);
        let (c_str, sig) = sign_claim(&c, k);
        (c, c_str, sig)
    }

    fn check_hex(s: &str, r: Vec<u8>) -> Result<(), FromHexError> {
        let b = hex::decode(s)?;
        assert_eq!(b.len(), r.len());
        assert_eq!(b, r);
        Ok(())
    }

    #[test]
    fn test_hex_decode() {
        check_hex("08", vec![8]).unwrap();
        check_hex("10", vec![16]).unwrap();
        check_hex("aa", vec![170]).unwrap();
        check_hex("1203", vec![18, 3]).unwrap();
        check_hex("1223", vec![18, 35]).unwrap();

        let h = "b4bf0f23c702efb8a9da87a94095e28de3d21cc3";
        let b = hex::decode(h).unwrap();
        assert_eq!(b.len(), 20);
        assert_eq!(b[0], 11 * 16 + 4);

        assert_eq!(hex::decode("8").unwrap_err(), FromHexError::OddLength);
        assert_eq!(hex::decode("123").unwrap_err(), FromHexError::OddLength);
        assert_eq!(
            hex::decode("0x").unwrap_err(),
            FromHexError::InvalidHexCharacter { c: 'x', index: 1 }
        );
        assert_eq!(
            hex::decode("xx").unwrap_err(),
            FromHexError::InvalidHexCharacter { c: 'x', index: 0 },
        );
        assert_eq!(
            hex::decode("1w").unwrap_err(),
            FromHexError::InvalidHexCharacter { c: 'w', index: 1 },
        );
    }

    #[test]
    fn claim_serialization() {
        let c = mk_claim(1677621259142, "some_111#$!", false);
        let claim_bz = c.try_to_vec().unwrap();
        let claim_str = b64_encode(claim_bz);
        let claim2 = deserialize_claim(&claim_str);
        assert_eq!(c, claim2, "serialization should work");
    }

    #[test]
    fn check_pub_key_len() {
        assert_eq!(ed25519_dalek::PUBLIC_KEY_LENGTH, PUBLIC_KEY_LEN);
        assert_eq!(ed25519_dalek::SIGNATURE_LENGTH, SIGNATURE_LEN);
    }

    #[test]
    fn test_verify_claim() {
        let k = gen_key();
        let (_, c_str, sig) = mk_claim_sign(10000, "0x12", &k, false);
        let claim_bytes = b64_decode("claim_b64", c_str).unwrap();
        let signature = b64_decode("sign_b64", sig).unwrap();
        let res = verify_claim(&signature, &claim_bytes, &k.public.to_bytes());
        assert!(res.is_ok(), "verification result: {:?}", res);

        let pk2 = gen_key().public;
        // let pk_bs58 = near_sdk::bs58::encode(k.public).into_string();
        // println!(">>> pub {:?}", b64_encode(pk2.as_bytes().to_vec()));
        let res = verify_claim(&signature, &claim_bytes, pk2.as_bytes());
        assert!(res.is_err(), "verification result: {:?}", res);

        let pk3_bytes = pubkey_from_b64("FGoAI6DXghOSK2ZaKVT/5lSP4X4JkoQQphv1FD4YRto=".to_string());
        assert_ne!(pk3_bytes[0], 0);
        let res = verify_claim(&signature, &claim_bytes, &pk3_bytes);
        assert!(res.is_err(), "verification result: {:?}", res);
    }
}

'''
'''--- contracts/oracle/tests/integration_test.rs ---
use std::str::FromStr;

use chrono::Utc;
use near_crypto::{SecretKey, Signature};
use near_sdk::ONE_NEAR;
use near_units::parse_near;
use near_workspaces::{types::Balance, Account, AccountId, Contract, DevNetwork, Worker};
use serde_json::json;
use test_util::{
    deploy_contract, gen_user_account,
    oracle::{ExternalAccountId, SignedClaim},
    utils::{generate_keys, sign_bytes},
};

use near_sdk::borsh::BorshSerialize;
use oracle_sbt::{Claim, MINT_TOTAL_COST, CLASS_KYC_SBT};
use sbt::{ClassMetadata, ContractMetadata};

const AUTHORITY_KEY: &str = "zqMwV9fTRoBOLXwt1mHxBAF3d0Rh9E9xwSAXR3/KL5E=";
const CLAIM_TTL: u64 = 3600 * 24 * 365 * 100;

async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Contract, Account, Account, Account)> {
    // deploy contracts
    let registry = worker.dev_deploy(include_bytes!("../../res/registry.wasm"));

    let registry = registry.await?;

    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let admin = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;

    //
    // we are usign same setup as in claim_sig_and_sbt_mint unit test
    //
    let oracle = deploy_oracle(
        &worker,
        &String::from(AUTHORITY_KEY),
        registry.id(),
        admin.id(),
    )
    .await?;

    let res2 = registry
        .call("new")
        .args_json(json!({
            "authority": admin.id(),
            "iah_issuer": oracle.id(), "iah_classes": [1],
            "authorized_flaggers": vec![auth_flagger.id()]}))
        .max_gas()
        .transact()
        .await?;

    assert!(res2.is_success(), "res registry {:?}", res2);

    // get current block time
    // let block = worker.view_block().await?;
    // let now = block.timestamp() / MSECOND; // timestamp in seconds

    Ok((oracle.to_owned(), registry.to_owned(), admin, alice, bob))
}

#[tokio::test]
async fn check_arithmetic_exception_dev() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (oracle, _, _, alice, _) = init(&worker).await?;
    check_arithmetic_exception(oracle, alice).await?;

    Ok(())
}

#[ignore]
#[tokio::test]
async fn check_arithmetic_exception_mainnet() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let worker_mainnet = near_workspaces::mainnet_archival().await?;

    let oracle_id: AccountId = "fractal.i-am-human.near".parse()?;
    const BLOCK_HEIGHT: u64 = 97933983; // this is around when the claims start to fail in the mainnet

    let oracle = worker
        .import_contract(&oracle_id, &worker_mainnet)
        .initial_balance(1000 * ONE_NEAR)
        .block_height(BLOCK_HEIGHT)
        //.with_data()
        .transact()
        .await?;

    // we can't import data because it's too big, so we need to initialize the contract
    let res1 = oracle
        .call("new")
        .args_json(json!({
            "authority": AUTHORITY_KEY,
            "admin": "admin.near",
            "registry": "registry.near",
            "claim_ttl": CLAIM_TTL,
            "metadata": ContractMetadata{spec: "sbt".to_owned(), name: "oracle".to_owned(), symbol: "iah".to_owned(), icon: None, base_uri: None, reference: None, reference_hash: None},
        }))
        .max_gas()
        .transact().await?;
    assert!(res1.is_success(), "res oracle {:?}", res1);

    // create and fund alice account
    let alice_root = worker.dev_create_account().await?;
    let alice_tx = alice_root.create_subaccount("alice").transact().await?;
    assert!(
        alice_tx.is_success(),
        "alice tx: {:?}\n",
        alice_tx.details.receipt_failures()
    );
    let alice = alice_tx.result;
    let tx = alice_root.transfer_near(alice.id(), ONE_NEAR).await?;
    assert!(tx.is_success(), "transfer: {:?}\n", tx.outcomes());

    check_arithmetic_exception(oracle, alice).await?;

    Ok(())
}

#[tokio::test]
async fn test_mint_sbt() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (sec_key, pub_key) = generate_keys();
    let authority = gen_user_account(&worker, "admin.test.near").await?;
    let iah_issuer = gen_user_account(&worker, "iah_issuer.test.near").await?;
    let flagger = gen_user_account(&worker, "flagger.test.near").await?;

    let registry_contract = deploy_contract(
        &worker,
        "../registry/",
        "new",
        json!({"authority": authority.id(), "authorized_flaggers": [flagger.id()], "iah_issuer": iah_issuer.id(), "iah_classes": [1]})
    )
    .await?;

    let oracle_contract = deploy_oracle(
        &worker,
        &near_sdk::base64::encode(pub_key.unwrap_as_ed25519().as_ref()),
        registry_contract.id(),
        authority.id(),
    )
    .await?;

    let user_account = gen_user_account(&worker, "user.test.near").await?;
    let signed_claim = build_signed_claim(
        near_sdk::AccountId::from_str(user_account.id().as_str())?,
        ExternalAccountId::gen(),
        false,
        &sec_key,
    )?;

    try_sbt_mint(
        &user_account,
        oracle_contract.id(),
        json!(signed_claim),
        MINT_TOTAL_COST,
        "only root and implicit accounts are allowed to get SBT",
    )
    .await?;

    let user_account = worker.root_account()?;
    let signed_claim = build_signed_claim(
        near_sdk::AccountId::from_str(user_account.id().as_str())?,
        ExternalAccountId::gen(),
        false,
        &sec_key,
    )?;

    try_sbt_mint(
        &user_account,
        oracle_contract.id(),
        json!(signed_claim),
        0,
        "Requires attached deposit at least 9000000000000000000000 yoctoNEAR",
    )
    .await?;

    let signed_claim = build_signed_claim(
        near_sdk::AccountId::from_str(user_account.id().as_str())?,
        ExternalAccountId::gen(),
        true,
        &sec_key,
    )?;

    try_sbt_mint(
        &user_account,
        oracle_contract.id(),
        json!(signed_claim),
        0,
        "Requires attached deposit at least 18000000000000000000000 yoctoNEAR",
    )
    .await?;

    try_sbt_mint(
        &user_account,
        oracle_contract.id(),
        json!({
            "claim_b64": signed_claim.claim_b64,
            "claim_sig": format!("a{}", &signed_claim.claim_sig),
        }),
        0,
        "can't base64-decode claim_sig",
    )
    .await?;

    let user_account = worker.root_account()?;
    let signed_claim = build_signed_claim(
        near_sdk::AccountId::from_str(user_account.id().as_str())?,
        ExternalAccountId::gen(),
        false,
        &sec_key,
    )?;

    let res = user_account
        .call(oracle_contract.id(), "sbt_mint")
        .args_json(signed_claim)
        .deposit(MINT_TOTAL_COST)
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok(())
}

#[tokio::test]
async fn test_admin_mint() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (oracle, registry, admin, alice, bob) = init(&worker).await?;

    // get current block time
    let block = worker.view_block().await?;
    let one_day_in_milliseconds: u64 = 24 * 60 * 60 * 1000;
    let now = block.timestamp() / 1_000_000; // timestamp in miliseconds
    let expires_at = now + one_day_in_milliseconds;

    let mint_data = vec![(alice.id(), expires_at), (bob.id(), expires_at)];

    let res = admin
        .call(oracle.id(), "admin_mint")
        .args_json(json!({"mint_data":mint_data, "class": CLASS_KYC_SBT, "memo": "kyc_test"}))
        .deposit(2 * MINT_TOTAL_COST)
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let res: u64 = admin
        .call(registry.id(), "sbt_supply_by_class")
        .args_json(json!({"issuer":oracle.id(), "class": CLASS_KYC_SBT}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(res, 2);

    Ok(())
}

async fn check_arithmetic_exception(oracle: Contract, alice: Account) -> anyhow::Result<()> {
    //
    // replicating claim_sig_and_sbt_mint unit test
    // in testnet it fails with with "WebAssembly trap: An arithmetic exception, e.g. divided by zero."
    //   https://explorer.testnet.near.org/transactions/GobWuBgA9HLsUk4UTtVqrSiyy24P6B2cnywLfeh9mdtv
    // however, the claim and transactions are correctly signed.
    // If verification is correct it should fail with "claimer is not a transaction signer" because
    // we are submitting the claim using a different account.

    println!(">>>> account: {}\n", alice.id());

    let claim_b64 = "FAAAAG15YWNjb3VudDEyMy50ZXN0bmV0IAAAAGFmZWU5MmYwNzEyMjQ2NGU4MzEzYWFlMjI1Y2U1YTNmSGa2ZAAAAAAA";
    let claim_sig_b64 =
        "38X2TnWgc6moc4zReAJFQ7BjtOUlWZ+i3YQl9gSMOXwnm5gupfHV/YGmGPOek6SSkotT586d4zTTT2U8Qh3GBw==";
    let res = alice
        .call(oracle.id(), "sbt_mint")
        .args_json(json!({"claim_b64": claim_b64, "claim_sig": claim_sig_b64}))
        .deposit(MINT_TOTAL_COST)
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure());
    let output = format!("{:?}", res.receipt_failures());
    assert!(
        output
            .as_str()
            .contains("claimer is not the transaction signer"),
        "{}",
        output
    );

    Ok(())
}

// Helper function to deploy, initalize and mint iah sbts to the `iah_accounts`.
pub async fn deploy_oracle<T>(
    worker: &Worker<T>,
    authority: &String,
    registry: &AccountId,
    admin: &AccountId,
) -> anyhow::Result<Contract>
where
    T: DevNetwork + Send + Sync,
{
    let oracle_contract = deploy_contract(
        &worker,
        "./../oracle",
        "new",
        json!({
            "authority": authority,
            "admin": admin,
            "registry": registry,
            "claim_ttl": CLAIM_TTL,
            "metadata": ContractMetadata{spec: "sbt".to_owned(), name: "oracle".to_owned(), symbol: "iah".to_owned(), icon: None, base_uri: None, reference: None, reference_hash: None},
        }),
    ).await?;

    Ok(oracle_contract)
}

pub fn build_signed_claim(
    claimer: near_sdk::AccountId,
    external_id: ExternalAccountId,
    verified_kyc: bool,
    sec_key: &SecretKey,
) -> anyhow::Result<SignedClaim> {
    let claim_raw = Claim {
        claimer,
        external_id: external_id.to_string(),
        verified_kyc,
        timestamp: Utc::now().timestamp() as u64,
    }
    .try_to_vec()?;

    let sign = sign_bytes(&claim_raw, sec_key);

    assert!(
        Signature::ED25519(ed25519_dalek::Signature::from_bytes(&sign)?)
            .verify(&claim_raw, &sec_key.public_key())
    );

    Ok(SignedClaim {
        claim_b64: near_sdk::base64::encode(claim_raw),
        claim_sig: near_sdk::base64::encode(sign),
    })
}

async fn try_sbt_mint(
    caller: &Account,
    oracle: &AccountId,
    args: serde_json::Value,
    deposit: Balance,
    expected_err: &str,
) -> anyhow::Result<()> {
    let result = caller
        .call(oracle, "sbt_mint")
        .args_json(args)
        .deposit(deposit)
        .max_gas()
        .transact()
        .await?;

    match result.into_result() {
        Ok(_) => Err(anyhow::Error::msg(format!(
            "Expected: {}, got: Ok()",
            expected_err
        ))),
        Err(e) => {
            let e_string = e.to_string();
            if !e_string.contains(expected_err) {
                Err(anyhow::Error::msg(format!(
                    "Expected: {}, got: {}",
                    expected_err, e_string
                )))
            } else {
                Ok(())
            }
        }
    }
}

#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker_sandbox = near_workspaces::sandbox().await?;
    let worker_mainnet = near_workspaces::mainnet().await?;
    let oracle_address: AccountId = "fractal.i-am-human.near".parse()?;
    let oracle = worker_sandbox
        .import_contract(&oracle_address, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .transact()
        .await?;

    let admin = worker_sandbox.dev_create_account().await?;
    let registry = worker_sandbox.dev_create_account().await?;

    // init the contract
    let res = oracle
        .call("new")
        .args_json(json!({
            "authority": &String::from(AUTHORITY_KEY),
            "admin": admin.id(),
            "registry": registry.id(),
            "claim_ttl": CLAIM_TTL,
            "metadata": ContractMetadata{spec: "sbt".to_owned(), name: "oracle".to_owned(), symbol: "iah".to_owned(), icon: None, base_uri: None, reference: None, reference_hash: None},
        }))
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // deploy the new contract
    let res = oracle
        .as_account()
        .deploy(include_bytes!("../../res/oracle_sbt.wasm"))
        .await?;

    assert!(res.is_success());

    let new_oracle = res.into_result()?;

    let class_metadata_1 = ClassMetadata {
        name: "test_1".to_string(),
        symbol: None,
        icon: None,
        reference: None,
        reference_hash: None,
    };
    let class_metadata_2 = ClassMetadata {
        name: "test_2".to_string(),
        symbol: None,
        icon: None,
        reference: None,
        reference_hash: None,
    };

    // call the migrate method
    let res = new_oracle
        .call("migrate")
        .args_json(json!({"class_metadata": [[1, class_metadata_1], [2, class_metadata_2]]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let class_metdata: Option<ClassMetadata> = new_oracle
        .call("class_metadata")
        .args_json(json!({"class": 1}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(class_metdata, Some(class_metadata_1));

    let class_metdata: Option<ClassMetadata> = new_oracle
        .call("class_metadata")
        .args_json(json!({"class": 2}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(class_metdata, Some(class_metadata_2));

    Ok(())
}

'''
'''--- contracts/registry/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>
-->

# CHANGELOG: Registry

## Unreleased

### Features

### Breaking Changes

### Bug Fixes

## v1.8.0 (2024-01-30)

### Features

- New `is_human_bool` function. Returns `true` if an account is considered human, and `false` otherwise. We do not recommend using this function. You SHOULD use `is_human` instead. Returning bool may create wrong practices. Humanity will be a metric, not a true/false. Each "client" should have his own criteria and asses the humanity proof (e.g. check for KYC SBTs, liveness, ...).

## v1.7.0 (2023-11-02)

### Features

- Added `authorized_flaggers` query.
- Added `admin_add_authorized_flagger` method.
- added `is_human_call_lock` method: allows dapp to lock an account for soul transfers and calls a recipient contract when the predecessor has a proof of personhood.

### Breaking Changes

- New contract field: `transfer_lock`.
- `sbt_soul_transfer` will fail if an account has an active transfer lock.

## v1.6.0 (2023-10-08)

### Features

- New `GovBan` flag. Reserved for accounts with a history of misconduct, limiting their governance role while maintaining their voting rights as valued members of the Voting Body.
- `sbt_revoke_by_owner` returns true if the issuer should continue to call the method to revoke all tokens. Otherwise the function return false. Moreover, the method has been improved and optimized.

### Breaking Changes

- `sbt_mint` will set `issue_at` to the current time in milliseconds, if the value was not provided.

## v1.5.0 (2023-09-07)

### Features

- Added `sbt_update_token_references` into the registry and SBT trait.
- Added `token_reference` event (`Nep393Event::TokenReference`).

### Breaking Changes

- Recommended `cost.mint_deposit` is decreased by 0.001 milliNEAR (in total).
- `soul_transfer` conflict resolution is updated to panic.
- Default `registry.sbt_soul_transfer` limit is decreased from 25 to 20.

## v1.4.0 (2023-08-23)

### Features

- Account flagging feature (blacklist / whitelist=verified). Note: account flag is transferred during the `soul_transfer`.
- Moving `registry.is_human_call` method out of experimental.
- New `registry.sbts` method.
- New `registry.sbt_classes` method.
- `ClassSet` and `SBTs` types have been moved to the sbt crate to reuse it in other contract (eg elections)

### Breaking Changes

Required storage deposits have been updated -> see the `cost` crate.

### Deployments

- `registry.i-am-human.near`: tx: `EdWfAeqKaAJ5iUnH1PjizmZRchywTeFQp2shumKsDqoa`, migration: `AhDC8Vku52rv67j8W3CgdRhKwo27ryvbZ3jt8WdRooau`

'''
'''--- contracts/registry/Cargo.toml ---
[package]
name = "registry"
version = "1.8.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true

sbt = { path = "../sbt" }
cost = { path = "../cost" }

[dev-dependencies]
pretty_assertions.workspace = true
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
tracing.workspace = true

'''
'''--- contracts/registry/README.md ---
# SBT Registry

The Registry smart contract is a balance book for all associated SBT tokens. The registry enables atomic `soul_transfers` and provides an efficient way to ban a smart contract (issuer). For more details check the [nep-393](https://github.com/near/NEPs/pull/393).

## Issuing SBTs

Usually we have 4 entities involved in the minting process:

1. Issuer entity: a smart contract representing an issuer, opted-in to the registry contract, allowed to issue new SBTs. Issuer should implement authorization methods for minters to call mint functions.
   Issuer must provide an interface, to allowed minters, to call registry functions: `sbt_mint`, `sbt_mint_iah`, `sbt_renew`, `sbt_revoke`. It must also implement the [`SBTIssuer`](../sbt/src/lib.rs) trait to provide metadata information about the issuer and each token class.
   NOTE: each SBT is issued under the issuer namespace. So if we have two issuers: A and B, each one can issue SBTs independently. SBTs are queried by issuer and token ID pair. This assures correct separation between issuers.
2. Minter: an account (usually a DAO, but can be any contract or account) authorized to call Issuer mint functions. Authorization is handled by the _Issuer entity_. For example, Issuer entity can implement a role based authorization: allow different minters per class, or different accounts to handle renew.
3. Registry: a smart contract described in this library. It implements the SBT Registry as per [nep-393](https://github.com/near/NEPs/pull/393).
4. Recipient: account receiving an SBT.

The diagram below outlines different entities involved in minting process. Issuers always mints tokens under his own namespace.

![Issuers and minting](./issuers.jpg)

### Registering an issuer

As noted above, every SBT is minted by an issuer, and it is recorded in the Registry contract, within an issuer namespace. An issuer, to be allowed to mint tokens, must firstly opt-in to the registry. Different registries may implement different mechanisms for opt-in. This implementation requires an admin account (could be a DAO) to add an issuer to the registry. The issuer opt-in mechanism is planned to be fully permissionless, once we will have more established governance and the protocol will get enough stability.

### Minting

The minting process is a procedure where an opt-in Issuer calls registry to mint a new token. Registry exposes two functions:

- `sbt_mint(token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>` -- creates a new, unique tokens and assigns it to the `receiver`. `token_spec` is a vector of pairs: owner AccountId and TokenMetadata. Each TokenMetadata must specify non zero `class`.
- `sbt_mint_iah(token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>` -- a wrapper around `sbt_mint` and `is_human`. It mints SBTs only when all recipients are humans. Panics if one of the recipients is not a human.

When calling the registry `sbt_mint*` functions, enough `Near` must be attached to cover the registry storage cost.

The functions will emit the [`Mint`](https://github.com/alpha-fi/i-am-human/blob/master/contracts/sbt/src/events.rs#L69) event when successful. There might be a case when the token vector provided is too long, and the gas is not enough to cover the minting process. In such case, the registry call will panic with `out of gas`.

## NDC Community Issuer

For NDC community SBTs, please see the [`community-sbt`](../community-sbt/README.md) contract and check with NDC leaders to be added as a minter and have your own class. The `community-sbt` contract allows to have unique set of minters per class. This way, there is no need to create a new contract for each new community, and every community will have it's own autonomy of issuing SBTs under their own class.

## Additional Queries

The IAH Registry supports the following extra queries, which are not part of the NEP-393 standard. See the function docs for more complete documentation.

- `is_human(account: AccountId) -> Proof`, where proof is list of SBTs (represented as a list of issuers and issuer minted tokens). The registry has a property `iah_sbts` that specifies which tokens from which issuers are required from an account to be considered a human. In case the account is missing any of the required tokens, or is considered a fake account (through the registry `blacklist`) an empty proof will be returned (empty list).
  For example, if `alice` is a human because she has `fractal: class 1` token with `tokenID=24`, then the function returns `["<fractal issuer account>", [24]]`. If the account is not a human, then an empty proof is returned (empty list). If the `iah_sbts` property contains more tokens, for example `fratcal: [1,2]` the `is_human` will return the proof with the tokens only if the account has both of the SBTs. Otherwise an empty proof will be returned. Eg: for `alice` with two tokens `class=1, tokenID=24` and `class=2, tokenID=40` the method will return `["<fractal issuer account>", [24, 40]]`. for `bob` with one token `class=1, tokenID=26` the method will return an empty list.

- `is_human_bool(account: AccountId) -> bool`: similar to `is_human`, but returns `true` if an account is considered human, and `false` otherwise. We DO NOT RECOMMEND using this function. You SHOULD use `is_human` instead. Returning bool may create wrong practices. Humanity will be a metric, not a true/false. Each "client" should have his own criteria and asses the humanity proof (e.g. check for KYC SBTs, liveness, ...). 
  Moreover, for some transactions it is critical to record the proof or acquire a lock (using `is_human_call_lock`) to protect from repeating action by the same human. Example scenario: consider Alice uses her humanity proof to vote, then she transfers her "soul" to another account, and votes again.

- `account_flagged(account: AccountId) -> Option<AccountFlag>` - returns account status if it was flagged. Returns None if the account was not flagged. More context about account flagging is specified in the [IAH Flag Accounts](https://near-ndc.notion.site/IAH-Flag-Accounts-b5b9c2ff72d14328834e2a0effa22938?pvs=4).

- `iah_class_set() -> ClassSet` - returns IAH class set: required token classes to be approved as a human by the `is_human`.

## Additional Transactions

See the function docs for more complete documentation.

- `sbt_mint_iah(token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>` is a wrapper around `sbt_mint` and `is_human`. It mints SBTs only when all recipients are humans.

- `sbt_burn(issuer: AccountId, tokens: Vec<TokenId>, memo: Option<String>)` - every holder can burn some of his tokens.

- `sbt_burn_all()` - method to burn all caller tokens (from all issuers). To efficiently burn all tokens, the method must be called repeatedly until true is returned.

- `is_human_call(ctr: AccountId, function: String, payload: JSONString)` checks if the predecessor account (_caller_) account is human (using `is_human` method). If it's not, then it panics and returns the deposit. Otherwise it makes a cross contract call passing the provided deposit:

  ```python
  ctr.function(caller=predecessor_account_id,
               iah_proof=tokens_prooving_caller_humanity,
               payload)
  ```

  Classical example will registering an action (for poll participation), only when a user is a human.
  Instead of `Poll --is_human--> Registry -> Poll`, we can simplify and do `Registry.is_human_call --> Poll`.

  See the function documentation for more details and [integration test](https://github.com/near-ndc/i-am-human/blob/780e8cf8326fd0a7976c48afbbafd4553cc7b639/contracts/human_checker/tests/workspaces.rs#L131) for usage.

- `is_human_call_lock(ctr: AccountId, function: String, lock_duration: u64, with_proof: bool)` checks if the predecessor account (_caller_) account is human (using `is_human` method). If it's not, then it panics and returns the deposit. Otherwise it will extend the _account soul transfer lock_ (blocking account ability to execute soul transfers) and make a cross contract call passing the provided deposit:

  ```python
  ctr.function(caller=predecessor_account_id,
               locked_until: time_in_ms_until_when_the_account_is_locked,
               iah_proof=tokens_prooving_caller_humanity,
               payload)
  ```

  Classical example will be a voting: we need to assure that an account won't migrate to other one using a soul transfer, and vote from two different accounts. Alternative would be to records humanity proof (SBTs) - this approach
  may be more difficult to implement, especially if we are going to supply more humanity proofs.

### Admin functions

- `admin_flag_accounts(flag: AccountFlag, accounts: Vec<AccountId>, memo: String)` - sets a flag for every account in the `accounts` list, overwriting if needed. Must be called by an authorized flagger.
- `admin_flag_accounts(flag: AccountFlag, accounts: Vec<AccountId>, memo: String)` - removes a flag for every account in the `accounts` list, overwriting if needed. Must be called by an authorized flagger.
  Valid account flags are: "Verified", "Blacklisted", "GovBan".
- `admin_add_sbt_issuer(issuer: AccountId)` - authorizes new issuer to issue SBTs.

## Soul transfer

The registry enables atomic `soul_transfers`. It Transfers all SBT tokens from one account to another account.
Additionally, it attempts to transfer the associated account flags. For example, if the 'from' account is blacklisted and initiates a soul transfer, the recipient account will also be flagged as blacklisted. If a conflict arises between the caller's and recipient's flags, the transfer will fail.

Soul transfer is blocked, if there is an active soul transfer lock. The lock may be requested by dapps, that relay on unique personhood linked to an account over a period of time (for example: voting, games).

'''
'''--- contracts/registry/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::FunctionError;

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum IsHumanCallErr {
    NotHuman,
}

impl FunctionError for IsHumanCallErr {
    fn panic(&self) -> ! {
        match self {
            IsHumanCallErr::NotHuman => panic_str("caller is not a human"),
        }
    }
}

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum SoulTransferErr {
    TransferLocked,
}

impl FunctionError for SoulTransferErr {
    fn panic(&self) -> ! {
        match self {
            SoulTransferErr::TransferLocked => {
                panic_str("soul transfer not possible: owner has a transfer lock")
            }
        }
    }
}

'''
'''--- contracts/registry/src/events.rs ---
use near_sdk::{serde::Serialize, serde_json::json, AccountId};
use sbt::{EventPayload, NearEvent};

use crate::storage::AccountFlag;

fn emit_iah_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "i_am_human",
        version: "1.0.0",
        event,
    }
    .emit();
}

pub(crate) fn emit_iah_flag_accounts(flag: crate::AccountFlag, accounts: Vec<AccountId>) {
    let event = match flag {
        AccountFlag::Blacklisted => "flag_blacklisted",
        AccountFlag::Verified => "flag_verified",
        AccountFlag::GovBan => "flag_govban",
    };
    emit_iah_event(EventPayload {
        event,
        data: accounts, // data is a simple list of accounts to flag (Verify or Blacklist)
    });
}

pub(crate) fn emit_iah_unflag_accounts(accounts: Vec<AccountId>) {
    emit_iah_event(EventPayload {
        event: "unflag",
        data: accounts, // data is a simple list of accounts to unflag
    });
}

/// `locked_until`: time in milliseconds until when the new account lock is established.
pub(crate) fn emit_transfer_lock(account: AccountId, locked_until: u64) {
    emit_iah_event(EventPayload {
        event: "transfer_lock",
        data: json!({ "account": account, "locked_until": locked_until}),
    });
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils;

    use super::*;

    fn acc(idx: u8) -> AccountId {
        AccountId::new_unchecked(format!("user-{}.near", idx))
    }

    #[test]
    fn log_flag_account() {
        let expected1 = r#"EVENT_JSON:{"standard":"i_am_human","version":"1.0.0","event":"flag_blacklisted","data":["user-1.near"]}"#;
        emit_iah_flag_accounts(AccountFlag::Blacklisted, vec![acc(1)]);
        assert_eq!(vec![expected1], test_utils::get_logs());

        let expected2 = r#"EVENT_JSON:{"standard":"i_am_human","version":"1.0.0","event":"flag_verified","data":["user-4.near","user-2.near"]}"#;
        emit_iah_flag_accounts(AccountFlag::Verified, vec![acc(4), acc(2)]);
        assert_eq!(vec![expected1, expected2], test_utils::get_logs());

        let expected3 = r#"EVENT_JSON:{"standard":"i_am_human","version":"1.0.0","event":"unflag","data":["user-4.near","user-3.near"]}"#;
        emit_iah_unflag_accounts(vec![acc(4), acc(3)]);
        assert_eq!(
            vec![expected1, expected2, expected3],
            test_utils::get_logs()
        );
    }
}

'''
'''--- contracts/registry/src/lib.rs ---
use std::collections::{HashMap, HashSet};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, TreeMap, UnorderedMap, UnorderedSet};
use near_sdk::serde_json::value::RawValue;
use near_sdk::{env, near_bindgen, require, serde_json, AccountId, Gas, PanicOnDefault, Promise};

use sbt::*;

use crate::errors::*;
use crate::storage::*;

pub mod errors;
pub mod events;
pub mod migrate;
pub mod registry;
pub mod storage;

const IS_HUMAN_GAS: Gas = Gas(12 * Gas::ONE_TERA.0);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Registry admin, expected to be a DAO.
    pub authority: AccountId,

    /// registry of approved SBT contracts to issue tokens
    pub sbt_issuers: UnorderedMap<AccountId, IssuerId>,
    pub issuer_id_map: LookupMap<IssuerId, AccountId>, // reverse index
    /// store ongoing soul transfers by "old owner"
    pub(crate) ongoing_soul_tx: LookupMap<AccountId, IssuerTokenId>,

    /// map accounts -> unix timestamp in milliseconds until when any soul transfer is blocked
    /// for the given account.
    pub(crate) transfer_lock: LookupMap<AccountId, u64>,
    /// registry of banned accounts created through `Nep393Event::Ban` (eg: soul transfer).
    pub(crate) banlist: UnorderedSet<AccountId>,
    /// Map of accounts that are marked by a committee to have a special status (eg: blacklist,
    /// whitelist).
    pub(crate) flagged: LookupMap<AccountId, AccountFlag>,
    /// list of admins that can manage flagged accounts map.
    pub(crate) authorized_flaggers: LazyOption<Vec<AccountId>>,

    pub(crate) supply_by_owner: LookupMap<(AccountId, IssuerId), u64>,
    pub(crate) supply_by_class: LookupMap<(IssuerId, ClassId), u64>,
    pub(crate) supply_by_issuer: LookupMap<IssuerId, u64>,

    /// maps user balance key to tokenID
    pub(crate) balances: TreeMap<BalanceKey, TokenId>,
    pub(crate) issuer_tokens: LookupMap<IssuerTokenId, TokenData>,

    /// map of SBT contract -> next available token_id
    pub(crate) next_token_ids: LookupMap<IssuerId, TokenId>,
    pub(crate) next_issuer_id: IssuerId,

    /// tuple of (required issuer, [required list of classes]) that represents mandatory
    /// requirements to be verified as human for `is_human` and `is_human_call` methods.
    pub(crate) iah_sbts: (AccountId, Vec<ClassId>),
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    /// Contract constructor.
    /// `iah_issuer`: required issuer for is_human check.
    /// `iah_classes`: required list of classes for is_human check.
    #[init]
    pub fn new(
        authority: AccountId,
        iah_issuer: AccountId,
        iah_classes: Vec<ClassId>,
        authorized_flaggers: Vec<AccountId>,
    ) -> Self {
        require!(
            !iah_classes.is_empty(),
            "iah_classes must be a non empty list"
        );
        let mut contract = Self {
            authority,
            sbt_issuers: UnorderedMap::new(StorageKey::SbtIssuers),
            issuer_id_map: LookupMap::new(StorageKey::SbtIssuersRev),
            transfer_lock: LookupMap::new(StorageKey::TransferLock),
            banlist: UnorderedSet::new(StorageKey::Banlist),
            supply_by_owner: LookupMap::new(StorageKey::SupplyByOwner),
            supply_by_class: LookupMap::new(StorageKey::SupplyByClass),
            supply_by_issuer: LookupMap::new(StorageKey::SupplyByIssuer),
            balances: TreeMap::new(StorageKey::Balances),
            issuer_tokens: LookupMap::new(StorageKey::IssuerTokens),
            next_token_ids: LookupMap::new(StorageKey::NextTokenId),
            next_issuer_id: 1,
            ongoing_soul_tx: LookupMap::new(StorageKey::OngoingSoultTx),
            iah_sbts: (iah_issuer.clone(), iah_classes),
            flagged: LookupMap::new(StorageKey::Flagged),
            authorized_flaggers: LazyOption::new(
                StorageKey::AdminsFlagged,
                Some(&authorized_flaggers),
            ),
        };
        contract._add_sbt_issuer(&iah_issuer);
        contract
    }

    //
    // Queries
    //

    pub fn sbt_issuers(&self) -> Vec<AccountId> {
        self.sbt_issuers.keys().collect()
    }

    /// Returns IAH class set: required token classes to be approved as a human by the
    /// `is_human`.
    pub fn iah_class_set(&self) -> ClassSet {
        vec![self.iah_sbts.clone()]
    }

    #[inline]
    fn _is_banned(&self, account: &AccountId) -> bool {
        self.banlist.contains(account)
    }

    /// Returns account status if it was flagged. Returns None if the account was not flagged.
    pub fn account_flagged(&self, account: AccountId) -> Option<AccountFlag> {
        self.flagged.get(&account)
    }

    /// Returns empty list if the account is NOT a human according to the IAH protocol.
    /// Otherwise returns list of SBTs (identifed by issuer and list of token IDs) proving
    /// the `account` humanity.
    pub fn is_human(&self, account: AccountId) -> SBTs {
        self._is_human(&account)
    }

    /// Returns `true` if an account is considered human, and `false` otherwise.
    /// We DO NOT RECOMMEND using this function. You SHOULD use `is_human` instead. Returning
    /// bool may create wrong practices. Humanity will be a metric, not a true/false.
    /// Each "client" should have his own criteria and asses the humanity proof
    /// (e.g. check for KYC SBTs, liveness, ...).
    pub fn is_human_bool(&self, account: AccountId) -> bool {
        !self._is_human(&account).is_empty()
    }

    fn _is_human(&self, account: &AccountId) -> SBTs {
        if self.flagged.get(account) == Some(AccountFlag::Blacklisted) || self._is_banned(account) {
            return vec![];
        }
        let issuer = Some(self.iah_sbts.0.clone());
        let mut proof: Vec<TokenId> = Vec::new();
        // check if user has tokens from all classes
        for cls in &self.iah_sbts.1 {
            let tokens = self.sbt_tokens_by_owner(
                account.clone(),
                issuer.clone(),
                Some(*cls),
                Some(1),
                None,
            );
            // we need to check class, because the query can return a "next" token if a user
            // doesn't have the token of requested class.
            if tokens.is_empty() || tokens[0].1[0].metadata.class != *cls {
                return vec![];
            }
            proof.push(tokens[0].1[0].token)
        }
        vec![(self.iah_sbts.0.clone(), proof)]
    }

    pub fn get_authority(self) -> AccountId {
        self.authority
    }

    pub fn authorized_flaggers(self) -> Vec<AccountId> {
        self.authorized_flaggers.get().unwrap_or_default()
    }

    //
    // Transactions
    //

    /// sbt_mint_iah is a wrapper around `sbt_mint` and `is_human`. It mints SBTs only when
    /// all recipients are humans. Panics if one of the recipients is not a human.
    #[payable]
    pub fn sbt_mint_iah(
        &mut self,
        token_spec: Vec<(AccountId, Vec<TokenMetadata>)>,
    ) -> Vec<TokenId> {
        let issuer = &env::predecessor_account_id();
        for ts in &token_spec {
            require!(
                !self._is_human(&ts.0).is_empty(),
                format!("{} is not a human", &ts.0)
            );
        }
        self._sbt_mint(issuer, token_spec)
    }

    /// Transfers atomically all SBT tokens from one account to another account.
    /// The caller must be an SBT holder and the `recipient` must not be a banned account.
    /// Transfers the account flag from the owner to the recipient.
    /// Fails when:
    /// + `recipient` is banned;
    /// + there is a potential conflict between the caller's and recipient's flag,
    ///   specifically when one account is `Blacklisted` and the other is `Verified`;
    /// Bans the caller account. NOTE: call can try to do soul_transfer to himself. This
    /// sounds irrationally, and allows to ban himself/herself.
    /// Emits:
    /// + `Ban` event for the caller at the beginning of the process.
    /// + `SoulTransfer` event only once all the tokens from the caller were transferred
    ///    and at least one token was transferred (caller had at least 1 sbt).
    /// Returns the amount of tokens transferred and a boolean: `true` if the whole
    /// process has finished, `false` when the process has not finished and should be
    /// continued by a subsequent call.
    /// + User must keep calling the `sbt_soul_transfer` until `true` is returned.
    /// + If caller does not have any tokens, nothing will be transfered, the caller
    ///   will be banned and `Ban` event will be emitted.
    /// See https://github.com/near/NEPs/pull/393 for more details and rationality about
    /// soul transfer.
    #[payable]
    #[handle_result]
    pub fn sbt_soul_transfer(
        &mut self,
        recipient: AccountId,
        #[allow(unused_variables)] memo: Option<String>,
    ) -> Result<(u32, bool), SoulTransferErr> {
        // TODO: test what is the max safe amount of updates
        self._sbt_soul_transfer(recipient, 20)
    }

    pub(crate) fn _transfer_flag(&mut self, from: &AccountId, recipient: &AccountId) {
        if let Some(flag_from) = self.flagged.get(from) {
            if let Some(flag_to) = self.flagged.get(recipient) {
                require!(
                    flag_from == flag_to,
                    "can't transfer soul when there is a flag conflict"
                )
            } else {
                self.flagged.insert(recipient, &flag_from);
            }
        }
    }

    // execution of the sbt_soul_transfer in this function to parametrize `max_updates` in
    // order to facilitate tests.
    #[handle_result]
    pub(crate) fn _sbt_soul_transfer(
        &mut self,
        recipient: AccountId,
        limit: usize,
    ) -> Result<(u32, bool), SoulTransferErr> {
        let owner = env::predecessor_account_id();
        let transfer_lock = self.transfer_lock.get(&owner).unwrap_or(0);
        if transfer_lock >= env::block_timestamp_ms() {
            return Err(SoulTransferErr::TransferLocked);
        }

        let (resumed, start) = self.transfer_continuation(&owner, &recipient, true);
        if !resumed {
            self._transfer_flag(&owner, &recipient);
        }

        let batch: Vec<(BalanceKey, TokenId)> = self
            .balances
            .iter_from(BalanceKey {
                owner: owner.clone(),
                issuer_id: start.issuer_id,
                class_id: start.token,
            })
            .take(limit)
            .collect();

        let mut key_new = BalanceKey {
            owner: recipient.clone(),
            issuer_id: 0,
            class_id: 0,
        };
        let mut prev_issuer: IssuerId = 0;
        let mut token_counter = 0;
        for (key, token_id) in &batch {
            if key.owner != owner {
                break;
            }
            token_counter += 1;

            if prev_issuer != key.issuer_id {
                prev_issuer = key.issuer_id;
                // update user token supply map
                if let Some(s) = self.supply_by_owner.remove(&(owner.clone(), prev_issuer)) {
                    let key = &(recipient.clone(), prev_issuer);
                    let supply_to = self.supply_by_owner.get(key).unwrap_or(0);
                    self.supply_by_owner.insert(key, &(s + supply_to));
                }
            }

            key_new.issuer_id = key.issuer_id;
            key_new.class_id = key.class_id;
            // One use can have max one toke of a (issuer, class) pair. We don't allow users
            // to overwrite each other tokens. Recipient or sender should firstly burn his SBT
            // to avoid conflicts.
            if self.balances.insert(&key_new, token_id).is_some() {
                env::panic_str(&format!(
                    "recipient already has an SBT of issuer={}, class={}; source_token_id={}",
                    self.issuer_by_id(key.issuer_id),
                    key.class_id,
                    token_id
                ));
            }
            self.balances.remove(key);

            let i_key = IssuerTokenId {
                issuer_id: key.issuer_id,
                token: *token_id,
            };
            let mut td = self.issuer_tokens.get(&i_key).unwrap();
            td.owner = recipient.clone();
            self.issuer_tokens.insert(&i_key, &td);
        }

        let completed = token_counter != limit;
        if completed {
            if resumed {
                // insert is happening when we need to continue, so don't need to remove if
                // the process finishes in the same transaction.
                self.ongoing_soul_tx.remove(&owner);
            }
            // we emit the event only once the operation is completed and only if some tokens were
            // transferred
            if resumed || token_counter > 0 {
                emit_soul_transfer(&owner, &recipient);
            }
        } else {
            let last = &batch[token_counter - 1];
            self.ongoing_soul_tx.insert(
                &owner,
                &IssuerTokenId {
                    issuer_id: last.0.issuer_id,
                    token: last.0.class_id, // we reuse IssuerTokenId type here (to not generate new code), but we store class_id instead of token here.
                },
            );
        }

        Ok((token_counter as u32, completed))
    }

    /// Checks if the `predecessor_account_id` is a human. If yes, then calls, passing the
    /// provided deposit:
    ///
    ///    ctr.function({caller: predecessor_account_id(),
    ///                 iah_proof: SBTs,
    ///                 payload: payload})
    ///
    /// `payload` must be a JSON string, and it will be passed through the default interface,
    /// hence it will be JSON deserialized when using SDK.
    /// Panics if the predecessor is not a human.
    #[payable]
    #[handle_result]
    pub fn is_human_call(
        &mut self,
        ctr: AccountId,
        function: String,
        payload: String,
    ) -> Result<Promise, IsHumanCallErr> {
        let caller = env::predecessor_account_id();
        let iah_proof = self._is_human(&caller);
        if iah_proof.is_empty() {
            return Err(IsHumanCallErr::NotHuman);
        }

        let args = IsHumanCallbackArgs {
            caller,
            iah_proof,
            payload: &RawValue::from_string(payload).unwrap(),
        };
        Ok(Promise::new(ctr).function_call(
            function,
            serde_json::to_vec(&args).unwrap(),
            env::attached_deposit(),
            env::prepaid_gas() - IS_HUMAN_GAS,
        ))
    }

    /// Apps should use this function to ask a user to lock his account for soul transfer.
    /// This is useful when a dapp relays on user account ID (rather set of potential SBTs)
    /// being a unique human over a period of time (there is no soul transfer in between).
    /// Example use cases: voting, staking, games.
    /// Dapps should make it clear that they extend user lock for a given amount of time.
    /// Parameters are similar to `is_human_call`:
    /// * `ctr` and `function`: the contract function we will call, passing the provided deposit,
    ///   if and only if the caller has a valid humanity proof.
    ///
    ///    ctr.function({caller: predecessor_account_id(),
    ///                 locked_until: time_in_ms_until_when_the_account_is_locked,
    ///                 iah_proof: SBTs,
    ///                 payload: payload})
    ///
    ///   Note the additional arguments provided to the recipient function call, that are not
    ///   present in `is_human_call`:
    ///   - `locked_until`: time in milliseconds (duration) until when the account is locked for soul
    ///      transfers. It may be bigger than `now + lock_duration` (this is a case when there
    ///      is already an existing lock with a longer duration).
    ///   - `iah_proof` will be set to an empty list if `with_proof=false`.
    /// * `payload`: must be a JSON string, and it will be passed through the default interface.
    /// * `lock_duration`: duration in milliseconds to extend the predecessor account lock for
    ///    soul transfers. Can be zero, if no lock is needed.
    /// * `with_proof`: when false - doesn't send iah_proof (SBTs) to the contract call.
    /// Emits transfer_lock if the transfer_lock is extended.
    /// Panics if the predecessor is not a human.
    #[payable]
    #[handle_result]
    pub fn is_human_call_lock(
        &mut self,
        ctr: AccountId,
        function: String,
        payload: String,
        lock_duration: u64,
        with_proof: bool,
    ) -> Result<Promise, IsHumanCallErr> {
        let caller = env::predecessor_account_id();
        let proof = self._is_human(&caller);
        if proof.is_empty() {
            return Err(IsHumanCallErr::NotHuman);
        }

        let now = env::block_timestamp_ms();
        let mut lock = self.transfer_lock.get(&caller).unwrap_or(now);
        if lock_duration > 0 && lock < now + lock_duration {
            lock = now + lock_duration;
            self.transfer_lock.insert(&caller, &lock);
            events::emit_transfer_lock(caller.clone(), lock)
        }

        let args = IsHumanLockCallbackArgs {
            caller,
            locked_until: lock,
            iah_proof: if with_proof { Some(proof) } else { None },
            payload: &RawValue::from_string(payload).unwrap(),
        };

        Ok(Promise::new(ctr).function_call(
            function,
            serde_json::to_vec(&args).unwrap(),
            env::attached_deposit(),
            env::prepaid_gas() - IS_HUMAN_GAS,
        ))
    }

    // NOTE: we are using IssuerTokenId to return Issuer and ClassId. This works as expected
    // and doesn't create API conflict because this is a crate private function. The reason we
    // do it is to avoid another struct creation and save the bytes.
    pub(crate) fn start_transfer_with_continuation(
        &mut self,
        owner: &AccountId,
        recipient: &AccountId,
        ban_owner: bool,
    ) -> IssuerTokenId {
        self.assert_not_banned(recipient);
        if ban_owner {
            // we only ban the source account in the soul transfer
            // insert into banlist and assure the owner is not already banned.
            require!(
                self.banlist.insert(owner),
                "from account is banned. Cannot start the transfer"
            );
            Nep393Event::Ban(vec![owner]).emit();
        }

        IssuerTokenId {
            issuer_id: 0,
            token: 0, // NOTE: this is class ID
        }
    }

    // If it is the first iteration of the soul transfer, bans the source account, otherwise returns the last transfered token
    fn transfer_continuation(
        &mut self,
        from: &AccountId,
        to: &AccountId,
        ban_owner: bool,
    ) -> (bool, IssuerTokenId) {
        match self.ongoing_soul_tx.get(from) {
            // starting the process
            None => (
                false,
                self.start_transfer_with_continuation(from, to, ban_owner),
            ),
            // resuming sbt_recover process
            Some(s) => (true, s),
        }
    }

    // sbt_recover execution with `limit` parameter in
    // order to facilitate tests.
    fn _sbt_recover(&mut self, from: AccountId, to: AccountId, limit: usize) -> (u32, bool) {
        let storage_start = env::storage_usage();
        let issuer = env::predecessor_account_id();
        let issuer_id = self.assert_issuer(&issuer);
        self.assert_not_banned(&to);
        // get the last transfered token and don't ban the owner.
        let (resumed, start) = self.transfer_continuation(&from, &to, false);

        let mut tokens_recovered = 0;
        let mut class_ids = Vec::new();

        let mut last_token_transfered = BalanceKey {
            owner: from.clone(),
            issuer_id,
            class_id: 0,
        };

        for (key, token) in self
            .balances
            .iter_from(balance_key(from.clone(), issuer_id, start.token))
            .take(limit)
        {
            if key.owner != from || key.issuer_id != issuer_id {
                break;
            }
            tokens_recovered += 1;
            let mut t = self.get_token(key.issuer_id, token);

            class_ids.push(t.metadata.class_id());

            t.owner = to.clone();
            self.issuer_tokens
                .insert(&IssuerTokenId { issuer_id, token }, &t);
            last_token_transfered = key;
        }

        // update user balances
        let mut old_balance_key = balance_key(from.clone(), issuer_id, 0);
        let mut new_balance_key = balance_key(to.clone(), issuer_id, 0);
        for class_id in class_ids {
            old_balance_key.class_id = class_id;
            let token_id = self.balances.remove(&old_balance_key).unwrap();
            new_balance_key.class_id = class_id;
            self.balances.insert(&new_balance_key, &token_id);
        }

        // update supply_by_owner map. We can't do it in the loop above becuse we can't modify
        // self.balances while iterating over it
        let supply_key = &(from.clone(), issuer_id);
        let old_supply_from = self.supply_by_owner.remove(supply_key).unwrap_or(0);
        if old_supply_from != tokens_recovered {
            self.supply_by_owner.insert(
                &(from.clone(), issuer_id),
                &(old_supply_from - tokens_recovered),
            );
        }
        let supply_key = &(to.clone(), issuer_id);
        let old_supply_to = self.supply_by_owner.get(supply_key).unwrap_or(0);
        self.supply_by_owner
            .insert(supply_key, &(old_supply_to + tokens_recovered));

        let completed = tokens_recovered != limit as u64;
        if completed {
            if resumed {
                // insert is happening when we need to continue, so don't need to remove if
                // the process finishes in the same transaction.
                self.ongoing_soul_tx.remove(&from);
            }
            // we emit the event only once the operation is completed and only if some tokens were
            // recovered
            if resumed || tokens_recovered > 0 {
                // emit Recover event
                SbtRecover {
                    issuer: &issuer,
                    old_owner: &from,
                    new_owner: &to,
                }
                .emit();
            }
        } else {
            self.ongoing_soul_tx.insert(
                &from,
                &IssuerTokenId {
                    issuer_id: last_token_transfered.issuer_id,
                    token: last_token_transfered.class_id, // we reuse IssuerTokenId type here (to not generate new code), but we store class_id instead of token here.
                },
            );
        }
        // storage check
        // we are using checked_sub, since the storage can decrease and we are running of risk of underflow
        let storage_usage = env::storage_usage();
        if storage_usage > storage_start {
            let required_deposit =
                (storage_usage - storage_start) as u128 * env::storage_byte_cost();
            require!(
                env::attached_deposit() >= required_deposit,
                format!(
                    "not enough NEAR storage depost, required: {}",
                    required_deposit
                )
            );
        }
        (tokens_recovered as u32, completed)
    }

    /// Method to burn all caller tokens (from all issuers).
    /// The method must be called repeatedly until true is returned.
    /// Not all tokens may be burned in a single call due to the gas limitation - in that case
    /// `false` is returned.
    /// The burn event is emitted for all the tokens burned.
    pub fn sbt_burn_all(&mut self) -> bool {
        self._sbt_burn_all(25)
    }

    /// Allows user to burn any of his tokens.
    /// The burn event is emitted for all  tokens burned.
    /// Panics if user has ongoing soul transfer or ongoing recovery or doesn't own a listed
    /// token.
    pub fn sbt_burn(
        &mut self,
        issuer: AccountId,
        tokens: Vec<TokenId>,
        #[allow(unused_variables)] memo: Option<String>,
    ) {
        let owner = env::predecessor_account_id();
        require!(
            !self.ongoing_soul_tx.contains_key(&owner),
            "can't burn tokens while in soul_transfer"
        );

        let issuer_id = self.assert_issuer(&issuer);
        let token_len = tokens.len() as u64;
        let mut token_ids = HashSet::new();
        for tid in tokens.iter() {
            require!(
                !token_ids.contains(tid),
                format!("duplicated token_id in tokens: {}", tid)
            );
            token_ids.insert(tid);

            let ct_key = &IssuerTokenId {
                issuer_id,
                token: *tid,
            };
            let t = self
                .issuer_tokens
                .get(ct_key)
                .unwrap_or_else(|| panic!("tokenID={} not found", tid));
            require!(
                t.owner == owner,
                &format!("not an owner of tokenID={}", tid)
            );

            self.issuer_tokens.remove(ct_key);
            let class_id = t.metadata.v1().class;
            self.balances
                .remove(&balance_key(owner.clone(), issuer_id, class_id));

            // update supply by class
            let key = (issuer_id, class_id);
            let mut supply = self.supply_by_class.get(&key).unwrap();
            supply -= 1;
            self.supply_by_class.insert(&key, &supply);
        }

        // update supply by owner
        let key = (owner, issuer_id);
        let mut supply = self.supply_by_owner.get(&key).unwrap();
        supply -= token_len;
        self.supply_by_owner.insert(&key, &supply);

        // update total supply by issuer
        let mut supply = self.supply_by_issuer.get(&issuer_id).unwrap();
        supply -= token_len;
        self.supply_by_issuer.insert(&issuer_id, &supply);

        SbtTokensEvent { issuer, tokens }.emit_burn();
    }

    //
    // Authority
    //

    /// returns false if the `issuer` contract was already registered.
    pub fn admin_add_sbt_issuer(&mut self, issuer: AccountId) -> bool {
        self.assert_authority();
        self._add_sbt_issuer(&issuer)
    }

    pub fn change_admin(&mut self, new_admin: AccountId) {
        self.assert_authority();
        self.authority = new_admin;
    }

    pub fn admin_set_authorized_flaggers(&mut self, authorized_flaggers: Vec<AccountId>) {
        self.assert_authority();
        self.authorized_flaggers.set(&authorized_flaggers);
    }

    /// Returns true if account was added. Returns false if account was already authorized.
    pub fn admin_add_authorized_flagger(&mut self, account: AccountId) -> bool {
        self.assert_authority();
        match self.authorized_flaggers.get() {
            None => {
                self.authorized_flaggers.set(&vec![account]);
                true
            }
            Some(mut a) => {
                if a.contains(&account) {
                    false
                } else {
                    a.push(account);
                    self.authorized_flaggers.set(&a);
                    true
                }
            }
        }
    }

    /// Sets a flag for every account in the `accounts` list, overwriting if needed.
    /// Panics if a caller is not flagged.
    /// Panics if any of the account is blacklisted.
    pub fn admin_flag_accounts(
        &mut self,
        flag: AccountFlag,
        accounts: Vec<AccountId>,
        #[allow(unused_variables)] memo: String,
    ) {
        self.assert_authorized_flagger();
        for a in &accounts {
            self.assert_not_banned(a);
            self.flagged.insert(a, &flag);
        }
        events::emit_iah_flag_accounts(flag, accounts);
    }

    /// removes flag from the provided account list.
    /// Panics if an account is not currently flagged.
    pub fn admin_unflag_accounts(
        &mut self,
        accounts: Vec<AccountId>,
        #[allow(unused_variables)] memo: String,
    ) {
        self.assert_authorized_flagger();
        for a in &accounts {
            require!(self.flagged.remove(a).is_some());
        }
        events::emit_iah_unflag_accounts(accounts);
    }

    //
    // Internal
    //

    /// Queries a given token. Panics if token doesn't exist
    pub(crate) fn get_token(&self, issuer_id: IssuerId, token: TokenId) -> TokenData {
        self.issuer_tokens
            .get(&IssuerTokenId { issuer_id, token })
            .unwrap_or_else(|| panic!("token {} not found", token))
    }

    /// updates the internal token counter based on how many tokens we want to mint (num), and
    /// returns the first valid TokenId for newly minted tokens.
    pub(crate) fn next_token_id(&mut self, issuer_id: IssuerId, num: u64) -> TokenId {
        let tid = self.next_token_ids.get(&issuer_id).unwrap_or(0);
        self.next_token_ids.insert(&issuer_id, &(tid + num));
        tid + 1
    }

    #[inline]
    pub(crate) fn assert_authorized_flagger(&self) {
        let caller = env::predecessor_account_id();
        let a = self.authorized_flaggers.get();
        if a.is_none() || !a.unwrap().contains(&caller) {
            env::panic_str("not authorized");
        }
    }

    #[inline]
    pub(crate) fn assert_not_banned(&self, owner: &AccountId) {
        require!(
            !self.banlist.contains(owner),
            format!("account {} is banned", owner)
        );
    }

    /// note: use issuer_id() if you need issuer_id
    pub(crate) fn assert_issuer(&self, issuer: &AccountId) -> IssuerId {
        // TODO: use Result rather than panic
        self.sbt_issuers
            .get(issuer)
            .expect("must be called by a registered SBT Issuer")
    }

    pub(crate) fn issuer_by_id(&self, id: IssuerId) -> AccountId {
        self.issuer_id_map
            .get(&id)
            .expect("internal error: inconsistent sbt issuer map")
    }

    pub(crate) fn assert_authority(&self) {
        require!(
            self.authority == env::predecessor_account_id(),
            "not an admin"
        )
    }

    fn _add_sbt_issuer(&mut self, issuer: &AccountId) -> bool {
        if self.sbt_issuers.get(issuer).is_some() {
            return false;
        }
        self.sbt_issuers.insert(issuer, &self.next_issuer_id);
        self.issuer_id_map.insert(&self.next_issuer_id, issuer);
        self.next_issuer_id += 1;
        true
    }

    fn _sbt_renew(&mut self, issuer: AccountId, tokens: Vec<TokenId>, expires_at: u64) {
        let issuer_id = self.assert_issuer(&issuer);
        for token in &tokens {
            let token = *token;
            let mut t = self.get_token(issuer_id, token);
            self.assert_not_banned(&t.owner);
            let mut m = t.metadata.v1();
            m.expires_at = Some(expires_at);
            t.metadata = m.into();
            self.issuer_tokens
                .insert(&IssuerTokenId { issuer_id, token }, &t);
        }
        SbtTokensEvent { issuer, tokens }.emit_renew();
    }

    fn _sbt_mint(
        &mut self,
        issuer: &AccountId,
        token_spec: Vec<(AccountId, Vec<TokenMetadata>)>,
    ) -> Vec<TokenId> {
        let storage_start = env::storage_usage();
        let storage_deposit = env::attached_deposit();

        let issuer_id = self.assert_issuer(issuer);
        let mut num_tokens = 0;
        for el in token_spec.iter() {
            num_tokens += el.1.len() as u64;
        }
        let mut token = self.next_token_id(issuer_id, num_tokens);
        let ret_token_ids = (token..token + num_tokens).collect();
        let mut supply_by_class = HashMap::new();
        let mut per_recipient: HashMap<AccountId, Vec<TokenId>> = HashMap::new();
        let now = env::block_timestamp_ms();

        for (owner, metadatas) in token_spec {
            // no need to check ongoing_soult_tx, because it will automatically ban the source account
            self.assert_not_banned(&owner);

            let recipient_tokens = per_recipient.entry(owner.clone()).or_default();
            let metadatas_len = metadatas.len();

            for mut metadata in metadatas {
                require!(metadata.class > 0, "Class must be > 0");
                if metadata.issued_at.is_none() {
                    metadata.issued_at = Some(now);
                }
                let prev = self.balances.insert(
                    &balance_key(owner.clone(), issuer_id, metadata.class),
                    &token,
                );
                require!(
                    prev.is_none(),
                    format! {"{} already has SBT of class {}", owner, metadata.class}
                );

                // update supply by class
                match supply_by_class.get_mut(&metadata.class) {
                    None => {
                        supply_by_class.insert(metadata.class, 1);
                    }
                    Some(s) => *s += 1,
                };

                self.issuer_tokens.insert(
                    &IssuerTokenId { issuer_id, token },
                    &TokenData {
                        owner: owner.clone(),
                        metadata: metadata.into(),
                    },
                );
                recipient_tokens.push(token);

                token += 1;
            }

            // update supply by owner
            let skey = (owner, issuer_id);
            let sowner = self.supply_by_owner.get(&skey).unwrap_or(0) + metadatas_len as u64;
            self.supply_by_owner.insert(&skey, &sowner);
        }

        for (cls, new_supply) in supply_by_class {
            let key = (issuer_id, cls);
            let s = self.supply_by_class.get(&key).unwrap_or(0) + new_supply;
            self.supply_by_class.insert(&key, &s);
        }

        let new_supply = self.supply_by_issuer.get(&issuer_id).unwrap_or(0) + num_tokens;
        self.supply_by_issuer.insert(&issuer_id, &new_supply);

        let mut minted: Vec<(&AccountId, &Vec<TokenId>)> = per_recipient.iter().collect();
        minted.sort_by(|a, b| a.0.cmp(b.0));
        SbtMint {
            issuer,
            tokens: minted,
        }
        .emit();

        let required_deposit =
            (env::storage_usage() - storage_start) as u128 * env::storage_byte_cost();
        require!(
            storage_deposit >= required_deposit,
            format!(
                "not enough NEAR storage deposit, required: {}",
                required_deposit
            )
        );

        ret_token_ids
    }

    /// Method to help parametrize the sbt_burn_all.
    /// limit indicates the number of tokens that will be burned in one call
    pub(crate) fn _sbt_burn_all(&mut self, limit: u32) -> bool {
        let owner = env::predecessor_account_id();
        require!(
            !self.ongoing_soul_tx.contains_key(&owner),
            "can't burn tokens while in soul_transfer"
        );
        let mut tokens_burned: u32 = 0;

        let issuer_token_pair_vec =
            self.sbt_tokens_by_owner(owner.clone(), None, None, Some(limit), Some(true));
        for (issuer, tokens) in issuer_token_pair_vec.iter() {
            let mut token_ids = Vec::new();
            let issuer_id = self.assert_issuer(issuer);
            let mut tokens_burned_per_issuer: u64 = 0;
            for t in tokens.iter() {
                token_ids.push(t.token);
                self.issuer_tokens.remove(&IssuerTokenId {
                    issuer_id,
                    token: t.token,
                });
                let class_id = t.metadata.class;
                self.balances
                    .remove(&balance_key(owner.clone(), issuer_id, class_id));

                // update supply by class
                let key = (issuer_id, class_id);
                let mut supply = self.supply_by_class.get(&key).unwrap();
                supply -= 1;
                self.supply_by_class.insert(&key, &supply);
                tokens_burned_per_issuer += 1;
                tokens_burned += 1;
                if tokens_burned >= limit {
                    break;
                }
            }

            // update supply by owner
            let key = (owner.clone(), issuer_id);
            let mut supply = self.supply_by_owner.get(&key).unwrap();
            supply -= tokens_burned_per_issuer;
            self.supply_by_owner.insert(&key, &supply);

            // update total supply by issuer
            let mut supply = self.supply_by_issuer.get(&issuer_id).unwrap();
            supply -= tokens_burned_per_issuer;
            self.supply_by_issuer.insert(&issuer_id, &supply);

            SbtTokensEvent {
                issuer: issuer.to_owned(),
                tokens: token_ids.clone(),
            }
            .emit_burn();
            if tokens_burned >= limit {
                return false;
            }
        }
        true
    }

    /// Helper function for `sbt_revoke_by_owner`
    fn sbt_token_ids_by_owner(
        &self,
        account: AccountId,
        issuer_id: u32,
        limit: u32,
    ) -> Vec<(TokenId, ClassId)> {
        let first_key = balance_key(account.clone(), issuer_id, 0);

        assert!(limit > 0, "limit must be bigger than 0");

        self.balances
            .iter_from(first_key)
            .take_while(|(key, _)| key.owner == account && key.issuer_id == issuer_id)
            .map(|(key, token_id)| (token_id, key.class_id))
            .take(limit as usize)
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use std::ops::Mul;

    use cost::MILI_NEAR;
    use near_sdk::json_types::Base64VecU8;
    use near_sdk::test_utils::{self, VMContextBuilder};
    use near_sdk::{testing_env, Balance, Gas, VMContext};
    use sbt::*;

    use pretty_assertions::assert_eq;

    use super::*;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn alice2() -> AccountId {
        AccountId::new_unchecked("alice.nea".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob.near".to_string())
    }

    fn carol() -> AccountId {
        AccountId::new_unchecked("carol.near".to_string())
    }

    fn dan() -> AccountId {
        AccountId::new_unchecked("dan.near".to_string())
    }

    fn issuer1() -> AccountId {
        AccountId::new_unchecked("sbt.n".to_string())
    }

    fn issuer2() -> AccountId {
        AccountId::new_unchecked("sbt.ne".to_string())
    }

    fn issuer3() -> AccountId {
        AccountId::new_unchecked("sbt.nea".to_string())
    }

    fn issuer4() -> AccountId {
        AccountId::new_unchecked("sbt4.near".to_string())
    }

    fn admins_flagged() -> Vec<AccountId> {
        vec![AccountId::new_unchecked("admin_flagged.near".to_string())]
    }

    #[inline]
    fn fractal_mainnet() -> AccountId {
        AccountId::new_unchecked("fractal.i-am-human.near".to_string())
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("sbt.near".to_string())
    }

    fn mk_metadata(class: ClassId, expires_at: Option<u64>) -> TokenMetadata {
        TokenMetadata {
            class,
            issued_at: Some(START),
            expires_at,
            reference: Some("abc".to_owned()),
            reference_hash: Some(vec![61, 61].into()),
        }
    }

    fn mk_token(token: TokenId, owner: AccountId, metadata: TokenMetadata) -> Token {
        Token {
            token,
            owner,
            metadata,
        }
    }

    fn mk_owned_token(token: TokenId, metadata: TokenMetadata) -> OwnedToken {
        OwnedToken { token, metadata }
    }

    fn mk_balance_key(owner: AccountId, issuer_id: IssuerId, class_id: ClassId) -> BalanceKey {
        BalanceKey {
            owner,
            issuer_id,
            class_id,
        }
    }

    fn mk_batch_metadata(n: u64) -> Vec<TokenMetadata> {
        let mut batch_metadata: Vec<TokenMetadata> = Vec::new();
        for i in 1..=n {
            batch_metadata.push(mk_metadata(i, Some(START + i)))
        }
        batch_metadata
    }

    fn max_gas() -> Gas {
        Gas::ONE_TERA.mul(300)
    }

    const MSECOND: u64 = 1_000_000; // milisecond in ns
    const START: u64 = 10;
    const MINT_DEPOSIT: Balance = 9 * MILI_NEAR;

    fn setup(predecessor: &AccountId, deposit: Balance) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(admin())
            .block_timestamp(START * MSECOND) // multiplying by mili seconds for easier testing
            .is_view(false)
            .build();
        if deposit > 0 {
            ctx.attached_deposit = deposit
        }
        testing_env!(ctx.clone());
        let mut ctr = Contract::new(admin(), fractal_mainnet(), vec![1], admins_flagged());
        ctr.admin_add_sbt_issuer(issuer1());
        ctr.admin_add_sbt_issuer(issuer2());
        ctr.admin_add_sbt_issuer(issuer3());
        ctr.admin_set_authorized_flaggers([predecessor.clone()].to_vec());
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        (ctx, ctr)
    }

    #[test]
    fn init_method() {
        let ctr = Contract::new(admin(), fractal_mainnet(), vec![1], vec![]);
        // make sure the iah_issuer has been set as an issuer
        assert_eq!(1, ctr.assert_issuer(&fractal_mainnet()));
    }

    #[test]
    fn iah_class_set() {
        let (_, ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        assert_eq!(ctr.iah_class_set(), vec![ctr.iah_sbts]);
    }

    #[test]
    fn add_sbt_issuer() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        // in setup we add 4 issuers, so the next id will be 5.
        assert_eq!(5, ctr.next_issuer_id);
        assert_eq!(1, ctr.assert_issuer(&fractal_mainnet()));
        assert_eq!(2, ctr.assert_issuer(&issuer1()));
        assert_eq!(3, ctr.assert_issuer(&issuer2()));
        assert_eq!(4, ctr.assert_issuer(&issuer3()));

        assert_eq!(fractal_mainnet(), ctr.issuer_by_id(1));
        assert_eq!(issuer1(), ctr.issuer_by_id(2));
        assert_eq!(issuer2(), ctr.issuer_by_id(3));
        assert_eq!(issuer3(), ctr.issuer_by_id(4));

        ctx.predecessor_account_id = admin();
        testing_env!(ctx);
        let ok = ctr.admin_add_sbt_issuer(issuer1());
        assert!(
            !ok,
            "isser1 should be already added, so it should return false"
        );
        assert_eq!(5, ctr.next_issuer_id, "next_issuer_id should not change");
        assert_eq!(
            2,
            ctr.assert_issuer(&issuer1()),
            "issuer1 id should not change"
        );
    }

    #[test]
    fn mint_simple() {
        let (_, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));

        let minted_ids = ctr.sbt_mint(vec![
            (alice(), vec![m1_1.clone()]),
            (bob(), vec![m1_1.clone()]),
        ]);
        assert_eq!(minted_ids, vec![1, 2]);
        assert_eq!(2, ctr.sbt_supply(issuer1()));
        assert_eq!(0, ctr.sbt_supply(issuer2()));

        let sbt1_1 = ctr.sbt(issuer1(), 1).unwrap();
        let sbt1_1_e = mk_token(1, alice(), m1_1.clone());
        let sbt1_2_e = mk_token(2, bob(), m1_1.clone());
        assert_eq!(sbt1_1, sbt1_1_e);
        let sbt1_2 = ctr.sbt(issuer1(), 2).unwrap();
        assert_eq!(sbt1_2, sbt1_2_e);
        assert!(ctr.sbt(issuer2(), 1).is_none());
        assert!(ctr.sbt(issuer1(), 3).is_none());

        let sbts = ctr.sbts(issuer1(), vec![1, 2]);
        assert_eq!(sbts, vec![Some(sbt1_1_e.clone()), Some(sbt1_2_e.clone())]);
        assert_eq!(
            ctr.sbt_classes(issuer1(), vec![1, 1]),
            vec![Some(1), Some(1)]
        );

        let sbts = ctr.sbts(issuer1(), vec![2, 10, 3, 1]);
        assert_eq!(sbts, vec![Some(sbt1_2_e), None, None, Some(sbt1_1_e)]);
        assert_eq!(
            ctr.sbt_classes(issuer1(), vec![2, 10, 3, 1]),
            vec![Some(1), None, None, Some(1)]
        );

        assert_eq!(1, ctr.sbt_supply_by_owner(alice(), issuer1(), None));
        assert_eq!(1, ctr.sbt_supply_by_owner(alice(), issuer1(), Some(1)));
        assert_eq!(0, ctr.sbt_supply_by_owner(alice(), issuer1(), Some(2)));

        assert_eq!(1, ctr.sbt_supply_by_owner(bob(), issuer1(), None));
        assert_eq!(1, ctr.sbt_supply_by_owner(bob(), issuer1(), Some(1)));
        assert_eq!(0, ctr.sbt_supply_by_owner(bob(), issuer1(), Some(2)));

        let alice_sbts = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        let expected = vec![(issuer1(), vec![mk_owned_token(1, m1_1.clone())])];
        assert_eq!(alice_sbts, expected);

        let bob_sbts = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        let expected = vec![(issuer1(), vec![mk_owned_token(2, m1_1)])];
        assert_eq!(bob_sbts, expected);
    }

    #[test]
    fn mint() {
        let (mut ctx, mut ctr) = setup(&issuer1(), MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m1_2 = mk_metadata(1, Some(START + 12));
        let m2_1 = mk_metadata(2, Some(START + 14));
        let m4_1 = mk_metadata(4, Some(START + 16));

        // mint an SBT to a user with same prefix as alice
        let minted_ids = ctr.sbt_mint(vec![(alice2(), vec![m1_1.clone()])]);
        assert_eq!(minted_ids, vec![1]);
        assert_eq!(
            test_utils::get_logs(),
            mk_log_str(
                "mint",
                &format!(
                    r#"{{"issuer":"{}","tokens":[["{}",[1]]]}}"#,
                    issuer1(),
                    alice2()
                )
            )
        );

        ctx.predecessor_account_id = issuer2();
        ctx.attached_deposit = 4 * MINT_DEPOSIT;
        testing_env!(ctx.clone());
        let minted_ids = ctr.sbt_mint(vec![
            (alice(), vec![m1_1.clone()]),
            (bob(), vec![m1_2.clone()]),
            (alice2(), vec![m1_1.clone()]),
            (alice(), vec![m2_1.clone()]),
        ]);
        assert_eq!(minted_ids, vec![1, 2, 3, 4]);
        assert_eq!(test_utils::get_logs().len(), 1);
        assert_eq!(
            test_utils::get_logs(),
            mk_log_str(
                "mint",
                &format!(
                    r#"{{"issuer":"{}","tokens":[["{}",[3]],["{}",[1,4]],["{}",[2]]]}}"#,
                    issuer2(),
                    alice2(),
                    alice(),
                    bob()
                )
            )
        );

        // mint again for Alice
        let minted_ids = ctr.sbt_mint(vec![(alice(), vec![m4_1.clone()])]);
        assert_eq!(minted_ids, vec![5]);

        // change the issuer and mint new tokens for alice
        ctx.predecessor_account_id = issuer3();
        ctx.attached_deposit = 2 * MINT_DEPOSIT;
        testing_env!(ctx.clone());
        let minted_ids = ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m2_1.clone()])]);
        // since we minted with different issuer, the new SBT should start with 1
        assert_eq!(minted_ids, vec![1, 2]);

        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 0), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 2), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 1), 3);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 2), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 3), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 4), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 5), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer3(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer3(), 2), 1);

        let mut supply_by_issuer = vec![1, 5, 2, 0];
        assert_eq!(ctr.sbt_supply(issuer1()), supply_by_issuer[0]);
        assert_eq!(ctr.sbt_supply(issuer2()), supply_by_issuer[1]);
        assert_eq!(ctr.sbt_supply(issuer3()), supply_by_issuer[2]);
        assert_eq!(ctr.sbt_supply(issuer4()), supply_by_issuer[3]);

        assert_eq!(3, ctr.sbt_supply_by_owner(alice(), issuer2(), None));
        assert_eq!(2, ctr.sbt_supply_by_owner(alice(), issuer3(), None));
        assert_eq!(1, ctr.sbt_supply_by_owner(bob(), issuer2(), None));
        assert_eq!(0, ctr.sbt_supply_by_owner(bob(), issuer3(), None));
        assert_eq!(0, ctr.sbt_supply_by_owner(issuer2(), issuer2(), None));

        let t2_all = vec![
            mk_token(1, alice(), m1_1.clone()),
            mk_token(2, bob(), m1_2),
            mk_token(3, alice2(), m1_1.clone()),
            mk_token(4, alice(), m2_1.clone()),
            mk_token(5, alice(), m4_1.clone()),
        ];
        let t3_1 = mk_token(1, alice(), m1_1.clone());

        assert_eq!(ctr.sbt(issuer2(), 1).unwrap(), t2_all[0]);
        assert_eq!(ctr.sbt(issuer2(), 2).unwrap(), t2_all[1]);
        assert_eq!(ctr.sbt(issuer2(), 3).unwrap(), t2_all[2]);
        assert_eq!(ctr.sbt(issuer2(), 4).unwrap(), t2_all[3]);
        assert_eq!(ctr.sbt(issuer3(), 1).unwrap(), t3_1);

        // Token checks

        let a_tokens = vec![
            (issuer1(), vec![mk_owned_token(1, m1_1.clone())]),
            (issuer2(), vec![mk_owned_token(3, m1_1.clone())]),
        ];
        assert_eq!(
            &ctr.sbt_tokens_by_owner(alice2(), None, None, None, None),
            &a_tokens
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice2(), Some(issuer1()), None, None, None),
            vec![a_tokens[0].clone()],
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice2(), Some(issuer2()), None, None, None),
            vec![a_tokens[1].clone()]
        );

        let alice_issuer2 = (
            issuer2(),
            vec![
                mk_owned_token(1, m1_1.clone()),
                mk_owned_token(4, m2_1.clone()),
                mk_owned_token(5, m4_1.clone()),
            ],
        );
        let alice_issuer3 = (
            issuer3(),
            vec![
                mk_owned_token(1, m1_1.clone()),
                mk_owned_token(2, m2_1.clone()),
            ],
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), None, None, None, None),
            vec![alice_issuer2.clone(), alice_issuer3.clone()]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), None, None, None),
            vec![alice_issuer2.clone()]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer3()), None, None, None),
            vec![alice_issuer3.clone()]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), Some(1), None, None),
            vec![alice_issuer2]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), Some(4), None, None),
            vec![(issuer2(), vec![mk_owned_token(5, m4_1)])]
        );

        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), Some(5), None, None),
            vec![]
        );

        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), Some(5), None, None),
            vec![]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer3()), Some(1), None, None),
            vec![alice_issuer3.clone()]
        );

        // check by all tokens
        assert_eq!(
            ctr.sbt_tokens(issuer1(), Some(1), None, None),
            vec![mk_token(1, alice2(), m1_1.clone())]
        );
        assert_eq!(ctr.sbt_tokens(issuer2(), None, None, None), t2_all,);
        assert_eq!(ctr.sbt_tokens(issuer2(), None, Some(1), None), t2_all[..1]);
        assert_eq!(ctr.sbt_tokens(issuer2(), None, Some(2), None), t2_all[..2]);
        assert_eq!(
            ctr.sbt_tokens(issuer2(), Some(2), Some(2), None),
            t2_all[1..3]
        );
        assert_eq!(
            ctr.sbt_tokens(issuer2(), Some(5), Some(5), None),
            t2_all[4..5]
        );
        assert_eq!(ctr.sbt_tokens(issuer2(), Some(6), Some(2), None), vec![]);

        //
        // now let's test buring
        //
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);

        ctr.sbt_burn(issuer2(), vec![1, 5], Some("alice burning".to_owned()));
        assert_eq!(
            test_utils::get_logs(),
            mk_log_str("burn", r#"{"issuer":"sbt.ne","tokens":[1,5]}"#)
        );

        supply_by_issuer[1] -= 2;
        assert_eq!(ctr.sbt_supply(issuer1()), supply_by_issuer[0]);
        assert_eq!(ctr.sbt_supply(issuer2()), supply_by_issuer[1]);
        assert_eq!(ctr.sbt_supply(issuer3()), supply_by_issuer[2]);
        assert_eq!(ctr.sbt_supply(issuer4()), supply_by_issuer[3]);

        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 1);
        assert_eq!(
            ctr.sbt_supply_by_owner(alice(), issuer2(), Some(m2_1.class)),
            1
        );
        assert_eq!(
            ctr.sbt_supply_by_owner(alice(), issuer2(), Some(m1_1.class)),
            0
        );

        let alice_issuer2 = (issuer2(), vec![mk_owned_token(4, m2_1)]);
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), None, None, None, None),
            vec![alice_issuer2.clone(), alice_issuer3]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), None, None, None),
            vec![alice_issuer2]
        );
    }

    #[test]
    #[should_panic(expected = "bob.near is not a human")]
    fn mint_iah() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), 150 * MINT_DEPOSIT);
        // issue IAH SBTs for alice
        let m1_1 = mk_metadata(1, Some(START)); // class=1 is IAH
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);

        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);

        // alice is IAH verified, so mint_iah by issuer1 should work
        let sbts = ctr.sbt_mint_iah(vec![(alice(), vec![m1_1.clone()])]);
        assert!(!sbts.is_empty());

        // bob doesn't have IAH SBTs -> the mint below panics.
        ctr.sbt_mint_iah(vec![(bob(), vec![m1_1])]);
    }

    #[test]
    fn soul_transfer1() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        // test1: simple case: alice has one token and she owns alice2 account as well. She
        // will do transfer from alice -> alice2
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m2_1.clone()])]);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);

        // make soul transfer
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        assert_eq!(ctr.sbt_soul_transfer(alice2(), None).unwrap(), (3, true));

        let log1 = mk_log_str("ban", &format!(r#"["{}"]"#, alice()));
        let log2 = mk_log_str(
            "soul_transfer",
            &format!(r#"{{"from":"{}","to":"{}"}}"#, alice(), alice2()),
        );
        assert_eq!(test_utils::get_logs(), vec![log1, log2].concat());
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 2);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 1);

        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));

        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), None, None, None, None),
            vec![]
        );
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice2(), None, None, None, None),
            vec![
                (
                    issuer1(),
                    vec![mk_owned_token(1, m1_1.clone()), mk_owned_token(2, m2_1)]
                ),
                (issuer2(), vec![mk_owned_token(1, m1_1)]),
            ]
        );
    }

    #[test]
    fn soul_transfer_with_continuation() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        // test1: simple case: alice has one token and she owns alice2 account as well. She
        // will do transfer from alice -> alice2
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        let m3_1 = mk_metadata(3, Some(START + 12));
        let m4_1 = mk_metadata(4, Some(START + 13));
        ctr.sbt_mint(vec![(alice(), vec![m1_1, m2_1])]);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), vec![m3_1, m4_1])]);

        // make soul transfer
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        assert_eq!(ctr._sbt_soul_transfer(alice2(), 3).unwrap(), (3, false));
        assert!(test_utils::get_logs().len() == 1);
        assert_eq!(ctr._sbt_soul_transfer(alice2(), 3).unwrap(), (1, true));
        assert!(test_utils::get_logs().len() == 2);

        let log_soul_transfer = mk_log_str(
            "soul_transfer",
            &format!(r#"{{"from":"{}","to":"{}"}}"#, alice(), alice2()),
        );
        assert_eq!(test_utils::get_logs()[1], log_soul_transfer[0]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 2);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 2);
        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
    }

    #[test]
    fn soul_transfer_no_tokens_from_caller() {
        let (mut ctx, mut ctr) = setup(&issuer1(), MINT_DEPOSIT);
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        assert!(!ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
        ctr.sbt_soul_transfer(alice2(), None).unwrap();
        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
        // assert ban even is being emited after the caller with zero tokens has invoked the soul_transfer
        let log_ban = mk_log_str("ban", &format!("[\"{}\"]", alice()));
        assert_eq!(test_utils::get_logs(), log_ban);
    }

    fn soul_transfer_prepare() -> (VMContext, Contract) {
        let (mut ctx, mut ctr) = setup(&issuer1(), 150 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(110);
        assert_eq!(batch_metadata.len(), 110);

        // issuer_1
        ctr.sbt_mint(vec![(alice(), batch_metadata[..50].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 50);

        // issuer_2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[50..100].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 50);

        // add more tokens to issuer_1
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(bob(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 20);

        // mint non conflicting tokens
        ctr.sbt_mint(vec![(alice2(), batch_metadata[100..].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 10);

        testing_env!(ctx.clone()); // reset gas
        ctr.sbt_mint(vec![(carol(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(carol(), issuer1(), None), 20);

        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(dan(), batch_metadata[..10].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(dan(), issuer1(), None), 10);

        (ctx, ctr)
    }

    #[test]
    fn soul_transfer_limit() {
        let (mut ctx, mut ctr) = soul_transfer_prepare();

        // soul transfer alice->alice2
        ctx.predecessor_account_id = alice();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        let limit: u32 = 20; //anything above this limit will fail due to exceeding maximum gas usage per call

        let mut result = ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap();
        while !result.1 {
            testing_env!(ctx.clone()); // reset gas
            result = ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap();
        }

        // check all the balances afterwards
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 60);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 50);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 20);
        assert_eq!(ctr.sbt_supply_by_owner(carol(), issuer1(), None), 20);
        assert_eq!(ctr.sbt_supply_by_owner(dan(), issuer1(), None), 10);
    }

    #[test]
    #[should_panic(expected = "HostError(GasLimitExceeded)")]
    fn soul_transfer_exceeded_gas_limit() {
        let (mut ctx, mut ctr) = soul_transfer_prepare();

        // soul transfer alice->alice2
        ctx.predecessor_account_id = alice();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx);
        let limit: u32 = 30;
        ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap();
    }

    #[test]
    #[should_panic(
        expected = "recipient already has an SBT of issuer=sbt.n, class=1; source_token_id=1"
    )]
    fn soul_transfer_conflict() {
        let (mut ctx, mut ctr) = soul_transfer_prepare();

        // alice1 already has SBT of (issuer1, 1), so let's mint it to alice2 and try soul_transfer
        let batch_metadata = mk_batch_metadata(1);
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice2(), batch_metadata)]);

        ctx.predecessor_account_id = alice();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx);
        let limit: u32 = 30;
        ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap();
    }

    #[test]
    fn soul_transfer_limit_basics() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 60 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(40);
        assert!(batch_metadata.len() == 40);

        // issuer_1
        ctr.sbt_mint(vec![(alice(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 20);

        // issuer_2
        ctx.predecessor_account_id = issuer2();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[20..].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 20);

        ctx.predecessor_account_id = alice();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());

        let limit: usize = 10;
        assert_eq!(
            ctr._sbt_soul_transfer(alice2(), limit).unwrap(),
            (limit as u32, false)
        );

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        assert_eq!(
            ctr._sbt_soul_transfer(alice2(), limit).unwrap(),
            (limit as u32, false)
        );

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        assert_eq!(
            ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap(),
            (limit as u32, false)
        );

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        assert_eq!(
            ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap(),
            (limit as u32, false)
        );

        // resumed transfer but no more tokens to transfer
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx);
        assert_eq!(
            ctr._sbt_soul_transfer(alice2(), limit as usize).unwrap(),
            (0, true)
        );

        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 20);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 20);
    }

    #[test]
    fn test_mk_log() {
        let l = mk_log_str("abc", "[1,2,3]");
        assert_eq!(
            l,
            vec![
                r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"abc","data":[1,2,3]}"#
            ],
        )
    }

    fn mk_log_str(event: &str, data: &str) -> Vec<String> {
        vec![format!(
            "EVENT_JSON:{{\"standard\":\"nep393\",\"version\":\"1.0.0\",\"event\":\"{}\",\"data\":{}}}",
            event,data
        )]
    }

    #[test]
    fn check_tree_iterator() {
        let (_, mut ctr) = setup(&issuer1(), MINT_DEPOSIT);
        ctr.balances.insert(&mk_balance_key(alice2(), 1, 1), &101);
        ctr.balances.insert(&mk_balance_key(alice(), 1, 1), &102);
        ctr.balances.insert(&mk_balance_key(bob(), 1, 1), &103);

        let bs: Vec<(BalanceKey, u64)> = ctr
            .balances
            .iter_from(mk_balance_key(alice(), 0, 0))
            .collect();
        assert_eq!(bs.len(), 2, "bob must be included in the prefix scan");
        assert_eq!(
            bs[0].0.owner,
            alice(),
            "alice must be first in the iterator"
        );
        assert_eq!(bs[0].1, 102, "alice must be first in the iterator");
        assert_eq!(bs[1].0.owner, bob(), "bob must be second in the iterator");
        assert_eq!(bs[1].1, 103, "alice must be first in the iterator");
    }

    #[test]
    fn registry_renew_one_issuer() {
        let (_, mut ctr) = setup(&issuer1(), 3 * MINT_DEPOSIT);

        // mint two tokens
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        let tokens = ctr.sbt_mint(vec![(alice(), vec![m1_1, m2_1])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 2);

        // renvew the two tokens
        let new_expire = START + 100;
        ctr.sbt_renew(tokens, new_expire);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 2);
        let m1_1_renewed = mk_metadata(1, Some(new_expire));
        let m2_1_renewed = mk_metadata(2, Some(new_expire));

        // assert the two tokens have been renewed (new expire_at)
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, None),
            vec![(
                issuer1(),
                vec![
                    mk_owned_token(1, m1_1_renewed),
                    mk_owned_token(2, m2_1_renewed)
                ]
            ),]
        );
    }

    #[test]
    fn registry_renew_multiple_issuers() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 3 * MINT_DEPOSIT);

        // mint two tokens by issuer1
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m2_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 2);

        // mint two tokens by issuer2
        let m1_2 = mk_metadata(1, Some(START + 10));
        let m2_2: TokenMetadata = mk_metadata(2, Some(START + 12));
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx);
        let tokens_issuer2 = ctr.sbt_mint(vec![(alice(), vec![m1_2, m2_2])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 2);

        // renvew the two tokens
        ctr.sbt_renew(tokens_issuer2, START + 100);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 2);
        let m1_2_renewed = mk_metadata(1, Some(START + 100));
        let m2_2_renewed = mk_metadata(2, Some(START + 100));

        // assert tokens issued by issuer2 has been renewed (new expire_at)
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), None, None, None),
            vec![(
                issuer2(),
                vec![
                    mk_owned_token(1, m1_2_renewed),
                    mk_owned_token(2, m2_2_renewed)
                ]
            ),]
        );

        // assert tokens issued by issuer1 has not been renewed (new expire_at)
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, None),
            vec![(
                issuer1(),
                vec![mk_owned_token(1, m1_1), mk_owned_token(2, m2_1)]
            ),]
        );
    }

    #[test]
    #[should_panic]
    fn registry_renew_basics() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 3 * MINT_DEPOSIT);

        // mint two tokens
        let m1_1 = mk_metadata(1, Some(START + 10));
        let tokens = ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 1);

        // check if only the issuer can renew the tokens (should panic)
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx);
        ctr.sbt_renew(tokens, START + 100);
    }

    #[test]
    fn registry_renew_event() {
        let (_, mut ctr) = setup(&issuer1(), 3 * MINT_DEPOSIT);

        // mint two tokens
        let m1_1 = mk_metadata(1, Some(START + 10));
        let tokens = ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        ctr.sbt_renew(tokens.clone(), START + 100);
        let log_mint = mk_log_str(
            "mint",
            &format!(
                r#"{{"issuer":"{}","tokens":[["{}",[1]]]}}"#,
                issuer1(),
                alice()
            ),
        );
        let log_renew = mk_log_str(
            "renew",
            &format!(r#"{{"issuer":"{}","tokens":[{}]}}"#, issuer1(), tokens[0]),
        );
        assert_eq!(test_utils::get_logs(), vec![log_mint, log_renew].concat());
    }

    #[test]
    fn sbt_recover_basics() {
        let (mut ctx, mut ctr) = setup(&issuer2(), 3 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 1);

        //issue tokens by a different issuer
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m2_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 2);

        ctr.sbt_recover(alice(), bob());
        let recover_log = mk_log_str(
            "recover",
            &format!(
                r#"{{"issuer":"{}","old_owner":"{}","new_owner":"{}"}}"#,
                issuer1(),
                alice(),
                bob()
            ),
        );
        assert_eq!(test_utils::get_logs().len(), 2);
        assert_eq!(test_utils::get_logs()[1], recover_log[0]);
        assert!(!ctr.is_banned(alice()));
        assert!(!ctr.is_banned(bob()));
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 2);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 1); //check if alice still holds the tokens issued by a different issuer
        assert_eq!(
            ctr.sbt_tokens_by_owner(bob(), Some(issuer1()), None, None, None),
            vec![(
                issuer1(),
                vec![
                    mk_owned_token(1, m1_1.clone()),
                    mk_owned_token(2, m2_1.clone())
                ]
            ),]
        );
        assert_eq!(ctr.sbt_supply(issuer1()), 2);
        assert_eq!(ctr.sbt_supply(issuer2()), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 2), 1);

        assert_eq!(
            ctr.sbt_tokens(issuer1(), None, None, None),
            vec![
                mk_token(1, bob(), m1_1.clone()),
                mk_token(2, bob(), m2_1.clone())
            ]
        );
        assert_eq!(
            ctr.sbt(issuer1(), 1).unwrap(),
            mk_token(1, bob(), m1_1.clone())
        );
        assert_eq!(ctr.sbt(issuer1(), 2).unwrap(), mk_token(2, bob(), m2_1));
        assert_eq!(ctr.sbt(issuer2(), 1).unwrap(), mk_token(1, alice(), m1_1));
    }

    #[test]
    #[should_panic(expected = "not enough NEAR storage depost")]
    fn sbt_recover_growing_storage_desposit_fail() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m1_2 = mk_metadata(2, Some(START + 10));
        let m1_3 = mk_metadata(3, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 1);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), vec![m1_1, m1_2, m1_3])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 3);

        //set attached deposit to zero, should fail since the storage grows and we do not cover it
        ctx.attached_deposit = 0;
        testing_env!(ctx);
        ctr._sbt_recover(alice(), bob(), 1);
    }

    #[test]
    fn sbt_recover_growing_storage_desposit_pass() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 1);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 1);

        // storage will grow so need to attach deposit.
        ctx.attached_deposit = MINT_DEPOSIT;
        testing_env!(ctx);
        ctr.sbt_recover(alice(), bob());
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer2(), None), 1);
    }

    #[test]
    fn sbt_recover_with_continuation_basics() {
        let (_, mut ctr) = setup(&issuer1(), 5 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        let m3_1 = mk_metadata(3, Some(START + 12));
        let m4_1 = mk_metadata(4, Some(START + 13));
        ctr.sbt_mint(vec![(alice(), vec![m1_1, m2_1, m3_1, m4_1])]);

        // sbt_recover
        let mut result = ctr._sbt_recover(alice(), alice2(), 3);
        assert_eq!((3, false), result);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 3);
        assert!(test_utils::get_logs().len() == 1);
        result = ctr._sbt_recover(alice(), alice2(), 3);
        assert_eq!((1, true), result);
        assert!(test_utils::get_logs().len() == 2);

        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 4);
    }

    #[test]
    fn sbt_revoke() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        let m3_1 = mk_metadata(3, Some(START + 21));

        let current_timestamp = ctx.block_timestamp / MSECOND; // convert nano to mili seconds

        let m1_1_revoked = mk_metadata(1, Some(current_timestamp));
        let m2_1_revoked = mk_metadata(2, Some(current_timestamp));
        let m3_1_revoked = mk_metadata(3, Some(current_timestamp));

        let tokens_issuer_1 = ctr.sbt_mint(vec![(
            alice(),
            vec![m1_1.clone(), m2_1.clone(), m3_1.clone()],
        )]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 3);

        //issue tokens by a different issuer
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(bob(), vec![m1_1.clone(), m2_1.clone()])]);
        ctr.sbt_mint(vec![(alice(), vec![m3_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer2(), None), 2);

        //revoke tokens issued by issuer1
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_revoke(tokens_issuer_1, false);

        let log_revoke = mk_log_str(
            "revoke",
            &format!(r#"{{"issuer":"{}","tokens":[1,2,3]}}"#, issuer1()),
        );
        assert_eq!(test_utils::get_logs().len(), 1);
        assert_eq!(test_utils::get_logs()[0], log_revoke[0]);

        assert_eq!(ctr.sbt_supply(issuer1()), 3);
        assert_eq!(ctr.sbt_supply(issuer2()), 3);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 3);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer2(), None), 2);
        assert_eq!(
            ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, None),
            vec![(
                issuer1(),
                vec![
                    mk_owned_token(1, m1_1_revoked.clone()),
                    mk_owned_token(2, m2_1_revoked.clone()),
                    mk_owned_token(3, m3_1_revoked.clone()),
                ]
            ),]
        );
        assert_eq!(
            ctr.sbt_tokens(issuer1(), None, None, None),
            vec![
                mk_token(1, alice(), m1_1_revoked),
                mk_token(2, alice(), m2_1_revoked),
                mk_token(3, alice(), m3_1_revoked)
            ]
        );
        assert_eq!(
            ctr.sbt_tokens(issuer2(), None, None, None),
            vec![
                mk_token(1, bob(), m1_1),
                mk_token(2, bob(), m2_1),
                mk_token(3, alice(), m3_1)
            ]
        )
    }

    #[test]
    fn sbt_revoke_burn() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START + 10));
        let m2_1 = mk_metadata(2, Some(START + 11));
        let m3_1 = mk_metadata(3, Some(START + 21));

        let tokens_to_burn = ctr.sbt_mint(vec![
            (alice(), vec![m1_1.clone(), m2_1.clone()]),
            (bob(), vec![m1_1.clone()]),
        ]);

        ctr.sbt_mint(vec![(alice(), vec![m3_1.clone()])]);

        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 3);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 1);

        //issue tokens by a different issuer
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(bob(), vec![m1_1.clone(), m2_1.clone()])]);
        ctr.sbt_mint(vec![(alice(), vec![m3_1.clone()])]);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer2(), None), 2);

        //revoke tokens issued by issuer1
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_revoke(tokens_to_burn, true);

        let log_burn = mk_log_str(
            "burn",
            &format!(r#"{{"issuer":"{}","tokens":[1,2,3]}}"#, issuer1()),
        );
        assert_eq!(test_utils::get_logs().len(), 2);
        assert_eq!(test_utils::get_logs()[0], log_burn[0]);
        assert_eq!(ctr.sbt_supply(issuer1()), 1);
        assert_eq!(ctr.sbt_supply(issuer2()), 3);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer1(), None), 1);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 1);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer2(), None), 2);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 1), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 2), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 3), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 2), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 3), 1);

        assert_eq!(
            ctr.sbt_tokens(issuer1(), None, None, None),
            vec![mk_token(4, alice(), m3_1.clone())],
        );
        assert_eq!(
            ctr.sbt_tokens(issuer2(), None, None, None),
            vec![
                mk_token(1, bob(), m1_1),
                mk_token(2, bob(), m2_1),
                mk_token(3, alice(), m3_1)
            ]
        )
    }

    // sbt_ban
    #[test]
    fn sbt_soul_transfer_ban() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert!(!ctr.is_banned(alice()));

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(alice2(), None).unwrap();

        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
    }

    #[test]
    fn sbt_recover_limit() {
        let (mut ctx, mut ctr) = setup(&issuer2(), 150 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(100);
        assert!(batch_metadata.len() == 100);

        // issuer_2
        ctr.sbt_mint(vec![(alice(), batch_metadata[..50].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 50);

        // // add more tokens to issuer_2
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[50..].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 100);

        // add more tokens to issuer_1
        ctx.predecessor_account_id = issuer1();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(bob(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice2(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(carol(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(carol(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(dan(), batch_metadata[..10].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(dan(), issuer1(), None), 10);

        // sbt_recover alice->alice2
        ctx.predecessor_account_id = issuer2();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        let limit: u32 = 20; //anything above this limit will fail due to exceeding maximum gas usage per call

        let mut result = ctr._sbt_recover(alice(), alice2(), limit as usize);
        while !result.1 {
            ctx.prepaid_gas = max_gas();
            testing_env!(ctx.clone());
            result = ctr._sbt_recover(alice(), alice2(), limit as usize);
        }

        // check all the balances afterwards
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 100);
    }

    #[test]
    #[should_panic(expected = "HostError(GasLimitExceeded)")]
    fn sbt_recover_limit_exceeded() {
        let (mut ctx, mut ctr) = setup(&issuer2(), 150 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(100);
        assert!(batch_metadata.len() == 100);

        // issuer_2
        ctr.sbt_mint(vec![(alice(), batch_metadata[..50].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 50);

        // // add more tokens to issuer_2
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[50..].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 100);

        // add more tokens to issuer_1
        ctx.predecessor_account_id = issuer1();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(bob(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(bob(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice2(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(carol(), batch_metadata[..20].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(carol(), issuer1(), None), 20);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(dan(), batch_metadata[..10].to_vec())]);
        assert_eq!(ctr.sbt_supply_by_owner(dan(), issuer1(), None), 10);

        // sbt_recover alice->alice2
        ctx.predecessor_account_id = issuer2();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        let limit: u32 = 25; // this value exceedes the gas limit allowed per call and should fail

        let mut result = ctr._sbt_recover(alice(), alice2(), limit as usize);
        while !result.1 {
            ctx.prepaid_gas = max_gas();
            testing_env!(ctx.clone());
            result = ctr._sbt_recover(alice(), alice2(), limit as usize);
        }

        // check all the balances afterwards
        assert_eq!(ctr.sbt_supply_by_owner(alice(), issuer2(), None), 0);
        assert_eq!(ctr.sbt_supply_by_owner(alice2(), issuer2(), None), 100);
    }

    #[test]
    #[should_panic(expected = "from account is banned. Cannot start the transfer")]
    fn sbt_soul_transfer_from_banned_account() {
        let (mut ctx, mut ctr) = setup(&issuer1(), MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert!(!ctr.is_banned(alice()));

        // ban the from account
        ctr.banlist.insert(&alice());
        assert!(ctr.is_banned(alice()));

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(alice2(), None).unwrap();
    }

    #[test]
    #[should_panic(expected = "account alice.nea is banned")]
    fn sbt_soul_transfer_to_banned_account() {
        let (mut ctx, mut ctr) = setup(&issuer1(), MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert!(!ctr.is_banned(alice()));

        // ban the reciver account
        ctr.banlist.insert(&alice2());
        assert!(ctr.is_banned(alice2()));

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(alice2(), None).unwrap();
    }

    #[test]
    fn sbt_soul_transfer_ban_with_continuation() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 50 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(50);
        ctr.sbt_mint(vec![(alice(), batch_metadata)]);
        assert!(!ctr.is_banned(alice()));

        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());
        assert!(!ctr.sbt_soul_transfer(alice2(), None).unwrap().1);

        // assert the from account is banned after the first soul transfer execution
        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(alice2(), None).unwrap();
        assert!(ctr.sbt_soul_transfer(alice2(), None).unwrap().1);

        // assert it stays banned after the soul transfer has been completed
        assert!(ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
    }

    #[test]
    fn sbt_recover_ban() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert!(!ctr.is_banned(alice()));

        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_recover(alice(), alice2());
        // sbt_recover should not ban the source account
        assert!(!ctr.is_banned(alice()));
        assert!(!ctr.is_banned(alice2()));
    }

    #[test]
    #[should_panic(expected = "account alice.near is banned")]
    fn sbt_mint_to_banned_account() {
        let (_, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START + 10));

        //ban alice account
        ctr.banlist.insert(&alice());
        assert!(ctr.is_banned(alice()));

        //try to mint to a banned account
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
    }

    #[test]
    fn sbt_tokens_by_owner_non_expired() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 4 * MINT_DEPOSIT);
        ctx.block_timestamp = START * MSECOND; // 11 seconds
        testing_env!(ctx.clone());

        let m1_1 = mk_metadata(1, Some(START));
        let m1_2 = mk_metadata(2, Some(START));
        let m1_3 = mk_metadata(3, Some(START + 100));
        let m1_4 = mk_metadata(4, Some(START + 100));
        ctr.sbt_mint(vec![(alice(), vec![m1_1, m1_2, m1_3, m1_4])]);

        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, Some(true));
        assert_eq!(res[0].1.len(), 4);
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 4);

        let res = ctr.sbt_tokens(issuer1(), None, None, Some(true));
        assert_eq!(res.len(), 4);
        let res = ctr.sbt_tokens(issuer1(), None, None, Some(false));
        assert_eq!(res.len(), 4);
        let res = ctr.sbt_tokens(issuer1(), None, None, None);
        assert_eq!(res.len(), 4);

        // fast forward so the first two sbts are expired
        ctx.block_timestamp = (START + 50) * MSECOND;
        testing_env!(ctx);

        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, Some(true));
        assert_eq!(res[0].1.len(), 4);
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, Some(false));
        assert_eq!(res[0].1.len(), 2);
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 2);

        let res = ctr.sbt_tokens(issuer1(), None, None, Some(true));
        assert_eq!(res.len(), 4);
        let res = ctr.sbt_tokens(issuer1(), None, None, Some(false));
        assert_eq!(res.len(), 2);
        let res = ctr.sbt_tokens(issuer1(), None, None, None);
        assert_eq!(res.len(), 2);
    }

    #[test]
    fn sbt_revoke_by_owner_basics() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START + 100));
        let m1_2 = mk_metadata(2, Some(START + 100));
        let m1_1_expired = mk_metadata(1, Some(START));
        let m1_2_expired = mk_metadata(2, Some(START));

        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m1_2.clone()])]);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());

        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone(), m1_2.clone()])]);

        let res = ctr.sbt_revoke_by_owner(alice(), true);
        assert!(res);

        let log_burn = mk_log_str(
            "burn",
            &format!(r#"{{"issuer":"{}","tokens":[1,2]}}"#, issuer2()),
        );
        let log_revoke = mk_log_str(
            "revoke",
            &format!(r#"{{"issuer":"{}","tokens":[1,2]}}"#, issuer2()),
        );
        assert_eq!(test_utils::get_logs().len(), 3);
        assert_eq!(test_utils::get_logs()[1], log_burn[0]);
        assert_eq!(test_utils::get_logs()[2], log_revoke[0]);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert!(res.len() == 1);
        assert_eq!(res[0].1.len(), 2);
        assert_eq!(ctr.sbt_supply(issuer1()), 2);
        assert_eq!(ctr.sbt_supply(issuer2()), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 2), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 1), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 2), 0);

        assert_eq!(
            ctr.sbt_tokens(issuer1(), None, None, None),
            vec![mk_token(1, alice(), m1_1), mk_token(2, alice(), m1_2),],
        );
        assert!(ctr.sbt_tokens(issuer2(), None, None, None).is_empty());

        // revoke (not burn) tokens minted for alice from issuer1
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx.clone());
        assert_eq!(test_utils::get_logs().len(), 0);
        let res = ctr.sbt_revoke_by_owner(alice(), false);
        assert!(res);

        let log_revoke = mk_log_str(
            "revoke",
            &format!(r#"{{"issuer":"{}","tokens":[1,2]}}"#, issuer1()),
        );
        assert_eq!(test_utils::get_logs().len(), 1);
        assert_eq!(test_utils::get_logs()[0], log_revoke[0]);

        // fast forward
        ctx.block_timestamp = (START + 50) * MSECOND;
        testing_env!(ctx);

        // make sure the balances are updated correctly
        let res_with_expired = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert!(res_with_expired.is_empty());
        let res_without_expired = ctr.sbt_tokens_by_owner(alice(), None, None, None, Some(true));
        assert!(res_without_expired.len() == 1);
        assert_eq!(res_without_expired[0].1.len(), 2);
        assert_eq!(ctr.sbt_supply(issuer1()), 2);
        assert_eq!(ctr.sbt_supply(issuer2()), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 1), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer1(), 2), 1);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 1), 0);
        assert_eq!(ctr.sbt_supply_by_class(issuer2(), 2), 0);

        assert_eq!(
            ctr.sbt_tokens(issuer1(), None, None, Some(true)),
            vec![
                mk_token(1, alice(), m1_1_expired),
                mk_token(2, alice(), m1_2_expired),
            ],
        );
        assert!(ctr.sbt_tokens(issuer1(), None, None, None).is_empty());
        assert!(ctr.sbt_tokens(issuer2(), None, None, None).is_empty());
    }

    #[test]
    fn sbt_revoke_by_owner_batch() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(20);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[10..].to_vec())]);

        // mint tokens to alice and bob from issuer2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[11..].to_vec())]);

        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 10);

        let res = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 9);

        assert_eq!(ctr.sbt_supply(issuer1()), 20);
        assert_eq!(ctr.sbt_supply(issuer2()), 19);

        // revoke (burn) tokens minted for alice from issuer2
        ctr.sbt_revoke_by_owner(alice(), true);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        // assert_eq!(res[1].1.len(), 0);

        let res = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 9);

        assert_eq!(ctr.sbt_supply(issuer1()), 20);
        assert_eq!(ctr.sbt_supply(issuer2()), 9);
    }

    #[test]
    fn sbt_revoke_by_owner_benchmark() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(20);
        ctr.sbt_mint(vec![(alice(), batch_metadata.clone())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata.clone())]);

        // mint tokens to alice and bob from issuer2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata.clone())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata.clone())]);

        // mint tokens to alice and bob from issuer3
        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata.clone())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata.clone())]);

        // add 4th issuer
        ctx.predecessor_account_id = admin();
        testing_env!(ctx.clone());
        ctr.admin_add_sbt_issuer(issuer4());

        // mint tokens to alice and bob from issuer4
        ctx.predecessor_account_id = issuer4();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata.clone())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata.clone())]);

        // revoke (burn) tokens minted for alice from issuer2
        ctx.predecessor_account_id = issuer2();
        ctx.prepaid_gas = Gas::ONE_TERA.mul(110);
        testing_env!(ctx);
        let res = ctr.sbt_revoke_by_owner(alice(), true);
        assert!(res);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), None, None, None);
        assert_eq!(res.len(), 0);
    }

    #[test]
    fn sbt_revoke_by_owner_burn_false() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(30);
        ctr.sbt_mint(vec![(alice(), batch_metadata.clone())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata.clone())]);

        // revoke (burn = false) tokens minted for alice from issuer2
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        let res = ctr.sbt_revoke_by_owner(alice(), false);
        assert!(!res);
        ctx.block_timestamp = (START + 1) * MSECOND;
        testing_env!(ctx.clone());

        let res = ctr.sbt_revoke_by_owner(alice(), false);
        assert!(res);

        ctx.block_timestamp = (START + 5) * MSECOND;
        testing_env!(ctx);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, Some(false));
        assert_eq!(res.len(), 0);
    }

    #[test]
    fn sbt_revoke_by_owner_limit() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 200 * MINT_DEPOSIT);

        // mint tokens to alice from issuer1
        let batch_metadata = mk_batch_metadata(100);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..50].to_vec())]);

        // mint tokens to alice from issuer2
        ctx.predecessor_account_id = issuer2();
        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..50].to_vec())]);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 50);
        assert_eq!(res[1].1.len(), 50);

        assert_eq!(ctr.sbt_supply(issuer1()), 50);
        assert_eq!(ctr.sbt_supply(issuer2()), 50);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx.clone());
        // revoke (burn) tokens minted for alice from issuer2
        let res = ctr.sbt_revoke_by_owner(alice(), true);
        assert!(!res);

        ctx.prepaid_gas = max_gas();
        testing_env!(ctx);
        // revoke (burn) tokens minted for alice from issuer2
        let res = ctr.sbt_revoke_by_owner(alice(), true);
        assert!(res);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 50);

        assert_eq!(ctr.sbt_supply(issuer1()), 50);
        assert_eq!(ctr.sbt_supply(issuer2()), 0);
    }

    #[test]
    fn is_human() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), 150 * MINT_DEPOSIT);
        ctx.current_account_id = AccountId::new_unchecked("registry.i-am-human.near".to_string());
        testing_env!(ctx.clone());

        let m1_1 = mk_metadata(1, Some(START));
        let m1_2 = mk_metadata(2, Some(START));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        ctr.sbt_mint(vec![(bob(), vec![m1_2])]);

        assert_eq!(ctr.is_human(alice()), vec![(fractal_mainnet(), vec![1])]);
        assert_eq!(ctr.is_human(bob()), vec![]);

        // step forward, so the tokens will expire
        ctx.block_timestamp = (START + 1) * MSECOND;
        testing_env!(ctx);
        assert_eq!(ctr.is_human(alice()), vec![]);
        assert_eq!(ctr.is_human(bob()), vec![]);
    }

    #[test]
    fn is_human_expires_at_none() {
        let (_, mut ctr) = setup(&fractal_mainnet(), 150 * MINT_DEPOSIT);

        // make sure is_human works as expected when the expiratoin date is set to None (the token never expires).
        let m1_1 = mk_metadata(1, None);
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);

        assert_eq!(ctr.is_human(alice()), vec![(fractal_mainnet(), vec![1])]);
    }

    #[test]
    fn is_human_multiple_classes() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), 150 * MINT_DEPOSIT);
        ctr.iah_sbts.1 = vec![1, 3];
        ctx.current_account_id = AccountId::new_unchecked("registry.i-am-human.near".to_string());
        testing_env!(ctx);

        let m1_1 = mk_metadata(1, Some(START));
        let m1_2 = mk_metadata(2, Some(START));
        let m1_3 = mk_metadata(3, Some(START));
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);
        ctr.sbt_mint(vec![(bob(), vec![m1_2.clone()])]);
        ctr.sbt_mint(vec![(carol(), vec![m1_2, m1_1.clone()])]);
        ctr.sbt_mint(vec![(dan(), vec![m1_3, m1_1])]);

        assert_eq!(ctr.is_human(alice()), vec![]);
        assert_eq!(ctr.is_human(bob()), vec![]);
        assert_eq!(ctr.is_human(carol()), vec![]);
        assert_eq!(ctr.is_human(dan()), vec![(fractal_mainnet(), vec![6, 5])]);
    }

    #[test]
    fn sbt_tokens_by_owner_per_issuer() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(30);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[10..20].to_vec())]);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[20..].to_vec())]);

        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res.len(), 3);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 10);
        assert_eq!(res[2].1.len(), 10);
        // assert that returns always in the ascending order (not minting order)
        assert_eq!(res[0].0, issuer1());
        assert_eq!(res[1].0, issuer2());
        assert_eq!(res[2].0, issuer3());

        let expected_tokens: Vec<u64> = (1..=10).collect();

        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, None);
        assert_eq!(res.len(), 1);
        assert_eq!(
            res[0].1.iter().map(|t| t.token).collect::<Vec<u64>>(),
            expected_tokens,
        );
        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer2()), None, None, None);
        assert_eq!(res.len(), 1);
        assert_eq!(
            res[0].1.iter().map(|t| t.token).collect::<Vec<u64>>(),
            expected_tokens,
        );
        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer3()), None, None, None);
        assert_eq!(res.len(), 1);
        assert_eq!(
            res[0].1.iter().map(|t| t.token).collect::<Vec<u64>>(),
            expected_tokens,
        );

        // mint more tokens for issuer1()
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_mint(vec![(alice(), batch_metadata[20..30].to_vec())]);
        let res = ctr.sbt_tokens_by_owner(alice(), Some(issuer1()), None, None, None);
        assert_eq!(res.len(), 1);
        assert_eq!(res[0].0, issuer1());
        assert_eq!(
            res[0].1.iter().map(|t| t.token).collect::<Vec<u64>>(),
            (1..=20).collect::<Vec<u64>>()
        );
    }

    #[test]
    fn sbt_token_ids_by_owner() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);
        let batch_metadata = mk_batch_metadata(20);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        let alice_tokens: Vec<(u64, u64)> = (1..=20).map(|i| (i, i)).collect();

        let res = ctr.sbt_token_ids_by_owner(alice(), ctr.assert_issuer(&issuer1()), 20);
        assert_eq!(res, &alice_tokens[0..10]);
        let res = ctr.sbt_token_ids_by_owner(alice(), ctr.assert_issuer(&issuer2()), 20);
        assert_eq!(res, &alice_tokens[0..10]);
        let res = ctr.sbt_token_ids_by_owner(alice(), ctr.assert_issuer(&issuer2()), 20);
        assert_eq!(res, &alice_tokens[0..10]);

        // mint more tokens for issuer1()
        ctx.predecessor_account_id = issuer1();
        testing_env!(ctx);
        ctr.sbt_mint(vec![(alice(), batch_metadata[10..20].to_vec())]);
        let res = ctr.sbt_token_ids_by_owner(alice(), ctr.assert_issuer(&issuer1()), 20);
        assert_eq!(res, alice_tokens);
    }

    #[test]
    fn is_human_multiple_classes_with_expired_tokens() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), 150 * MINT_DEPOSIT);
        ctr.iah_sbts.1 = vec![1, 3];
        ctx.current_account_id = AccountId::new_unchecked("registry.i-am-human.near".to_string());
        testing_env!(ctx.clone());

        let m1_1 = mk_metadata(1, Some(START + 100));
        let m1_2 = mk_metadata(2, Some(START + 100));
        let m1_3 = mk_metadata(3, Some(START));
        ctr.sbt_mint(vec![(alice(), vec![m1_1, m1_2, m1_3])]);

        assert_eq!(ctr.is_human(alice()), vec![(fractal_mainnet(), vec![1, 3])]);
        // step forward, so token class==3 will expire
        ctx.block_timestamp = (START + 1) * MSECOND;
        testing_env!(ctx);
        assert_eq!(ctr.is_human(alice()), vec![]);
    }

    #[test]
    fn sbt_revoke_events() {
        let (ctx, mut ctr) = setup(&fractal_mainnet(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START));
        let tokens = ctr.sbt_mint(vec![(alice(), vec![m1_1])]);

        // clear the events
        testing_env!(ctx.clone());

        // revoke (burn == false)
        ctr.sbt_revoke(vec![tokens[0]], false);

        let log_revoke = mk_log_str(
            "revoke",
            &format!(r#"{{"issuer":"{}","tokens":[1]}}"#, fractal_mainnet()),
        );
        let log_burn = mk_log_str(
            "burn",
            &format!(r#"{{"issuer":"{}","tokens":[1]}}"#, fractal_mainnet()),
        );

        // check only revoke event is emitted
        assert_eq!(test_utils::get_logs().len(), 1);
        assert_eq!(test_utils::get_logs(), log_revoke);

        // clear the events
        testing_env!(ctx);

        // revoke (burn == true)
        ctr.sbt_revoke(tokens, true);

        // check both burn and revoke events are emitted
        assert_eq!(test_utils::get_logs().len(), 2); // -> only 1 event is emmited
        assert_eq!(test_utils::get_logs(), vec![log_burn, log_revoke].concat());
        // -> missing revoke event
    }

    #[test]
    fn sbt_burn_all_more_users() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(20);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[10..].to_vec())]);

        // mint tokens to alice and bob from issuer2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[11..].to_vec())]);

        // mint tokens to alice and bob from issuer3
        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[10..].to_vec())]);

        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 10);
        assert_eq!(res[2].1.len(), 10);

        let res = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 9);
        assert_eq!(res[2].1.len(), 10);

        assert_eq!(ctr.sbt_supply(issuer1()), 20);
        assert_eq!(ctr.sbt_supply(issuer2()), 19);
        assert_eq!(ctr.sbt_supply(issuer3()), 20);

        // alice burn all her tokens from all the issuers
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        let res = ctr._sbt_burn_all(20);
        assert!(!res);
        let res = ctr._sbt_burn_all(20);
        assert!(res); // make sure that after the second call true is returned (all tokens have been burned)

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert!(res.is_empty());

        let res = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        assert_eq!(res[0].1.len(), 10);
        assert_eq!(res[1].1.len(), 9);
        assert_eq!(res[2].1.len(), 10);

        assert_eq!(ctr.sbt_supply(issuer1()), 10);
        assert_eq!(ctr.sbt_supply(issuer2()), 9);
        assert_eq!(ctr.sbt_supply(issuer3()), 10);
    }

    #[test]
    fn sbt_burn_all_basics() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 20 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(20);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        // mint tokens to alice and bob from issuer2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        // mint tokens to alice and bob from issuer3
        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..10].to_vec())]);

        // alice burn all her tokens from all the issuers
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        loop {
            if ctr._sbt_burn_all(10) {
                break;
            }
        }

        // check if the logs are correct
        assert_eq!(test_utils::get_logs().len(), 3);

        let log_burn_issuer_1 = mk_log_str(
            "burn",
            &format!(
                r#"{{"issuer":"{}","tokens":[1,2,3,4,5,6,7,8,9,10]}}"#,
                issuer1()
            ),
        );

        let log_burn_issuer_2 = mk_log_str(
            "burn",
            &format!(
                r#"{{"issuer":"{}","tokens":[1,2,3,4,5,6,7,8,9,10]}}"#,
                issuer2()
            ),
        );

        let log_burn_issuer_3 = mk_log_str(
            "burn",
            &format!(
                r#"{{"issuer":"{}","tokens":[1,2,3,4,5,6,7,8,9,10]}}"#,
                issuer3()
            ),
        );

        assert_eq!(test_utils::get_logs()[0], log_burn_issuer_1[0]);
        assert_eq!(test_utils::get_logs()[1], log_burn_issuer_2[0]);
        assert_eq!(test_utils::get_logs()[2], log_burn_issuer_3[0]);

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert!(res.is_empty());

        assert_eq!(ctr.sbt_supply(issuer1()), 0);
        assert_eq!(ctr.sbt_supply(issuer2()), 0);
        assert_eq!(ctr.sbt_supply(issuer3()), 0);
        for i in 1..=10 {
            print!("{}", i);
            assert_eq!(ctr.sbt_supply_by_class(issuer1(), i), 0);
        }
        for i in 1..=10 {
            assert_eq!(ctr.sbt_supply_by_class(issuer2(), i), 0);
        }
        for i in 1..=10 {
            assert_eq!(ctr.sbt_supply_by_class(issuer3(), i), 0);
        }
    }

    #[test]
    fn sbt_burn_all_limit() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 60 * MINT_DEPOSIT);

        // mint tokens to alice and bob from issuer1
        let batch_metadata = mk_batch_metadata(40);
        ctr.sbt_mint(vec![(alice(), batch_metadata[..20].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[20..].to_vec())]);

        // mint tokens to alice and bob from issuer2
        ctx.predecessor_account_id = issuer2();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..20].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[20..].to_vec())]);

        // mint tokens to alice and bob from issuer3
        ctx.predecessor_account_id = issuer3();
        testing_env!(ctx.clone());
        ctr.sbt_mint(vec![(alice(), batch_metadata[..20].to_vec())]);
        ctr.sbt_mint(vec![(bob(), batch_metadata[20..].to_vec())]);

        assert_eq!(ctr.sbt_supply(issuer1()), 40);
        assert_eq!(ctr.sbt_supply(issuer2()), 40);
        assert_eq!(ctr.sbt_supply(issuer3()), 40);

        // alice burn all her tokens from all the issuers
        ctx.predecessor_account_id = alice();
        loop {
            ctx.prepaid_gas = max_gas();
            testing_env!(ctx.clone());
            if ctr._sbt_burn_all(41) {
                //anything above 41 fails due to MaxGasLimitExceeded error
                break;
            }
        }

        // make sure the balances are updated correctly
        let res = ctr.sbt_tokens_by_owner(alice(), None, None, None, None);
        assert!(res.is_empty());

        let res = ctr.sbt_tokens_by_owner(bob(), None, None, None, None);
        assert_eq!(res[0].1.len(), 20);
        assert_eq!(res[1].1.len(), 20);
        assert_eq!(res[2].1.len(), 20);

        assert_eq!(ctr.sbt_supply(issuer1()), 20);
        assert_eq!(ctr.sbt_supply(issuer2()), 20);
        assert_eq!(ctr.sbt_supply(issuer3()), 20);
    }

    #[test]
    fn sbt_update_token_references() {
        let (ctx, mut ctr) = setup(&fractal_mainnet(), 2 * MINT_DEPOSIT);
        let m1_1 = mk_metadata(1, Some(START));
        let tid1 = ctr.sbt_mint(vec![(bob(), vec![m1_1.clone()])])[0];
        let tid2 = ctr.sbt_mint(vec![(alice(), vec![m1_1])])[0];

        let t1 = ctr.sbt(fractal_mainnet(), tid1).unwrap();
        assert_eq!(t1.metadata.reference, Some("abc".to_owned()));

        // reset logs
        testing_env!(ctx);
        let r = Some("ipfs://abc123".to_owned());
        let r_hash = Some(Base64VecU8(vec![1, 1, 2]));
        ctr.sbt_update_token_references(vec![(tid2, r.clone(), r_hash.clone())]);

        let t2 = ctr.sbt(fractal_mainnet(), tid2).unwrap();
        assert_eq!(t2.metadata.reference, r);
        assert_eq!(t2.metadata.reference_hash, r_hash);

        let t1_2 = ctr.sbt(fractal_mainnet(), tid1).unwrap();
        assert_eq!(t1, t1_2);

        let log = mk_log_str(
            "token_reference",
            &format!(
                r#"{{"issuer":"{}","tokens":[{}]}}"#,
                fractal_mainnet(),
                tid2
            ),
        );
        assert_eq!(test_utils::get_logs(), log);
    }

    #[test]
    fn is_human_call() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        assert_eq!(ctr.is_human(alice()), vec![(fractal_mainnet(), vec![1])]);

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);

        ctr.is_human_call(
            AccountId::new_unchecked("registry.i-am-human.near".to_string()),
            "function_name".to_string(),
            "{}".to_string(),
        )
        .unwrap();
    }

    #[test]
    fn is_human_call_fail() {
        let (_, mut ctr) = setup(&alice(), MINT_DEPOSIT);

        match ctr.is_human_call(
            AccountId::new_unchecked("registry.i-am-human.near".to_string()),
            "function_name".to_string(),
            "{}".to_string(),
        ) {
            Err(err) => assert_eq!(err, IsHumanCallErr::NotHuman),
            Ok(_) => panic!("expecting Err(IsHumanCallErr::NotHuman)"),
        };
    }

    #[test]
    fn admin_set_authorized_flaggers() {
        let (mut ctx, mut ctr) = setup(&admin(), MINT_DEPOSIT);

        let flaggers = [dan()].to_vec();
        ctr.admin_set_authorized_flaggers(flaggers);

        ctx.predecessor_account_id = dan();
        testing_env!(ctx);
        ctr.assert_authorized_flagger();
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_set_authorized_flaggers_fail() {
        let (mut ctx, mut ctr) = setup(&admin(), MINT_DEPOSIT);

        ctx.predecessor_account_id = dan();
        testing_env!(ctx);

        let flaggers = [dan()].to_vec();
        ctr.admin_set_authorized_flaggers(flaggers);
    }

    #[test]
    fn admin_flag_accounts() {
        let (_, mut ctr) = setup(&alice(), MINT_DEPOSIT);

        ctr.admin_flag_accounts(
            AccountFlag::Blacklisted,
            [dan(), issuer1()].to_vec(),
            "memo".to_owned(),
        );
        ctr.admin_flag_accounts(
            AccountFlag::Verified,
            [issuer2()].to_vec(),
            "memo".to_owned(),
        );

        let exp = r#"EVENT_JSON:{"standard":"i_am_human","version":"1.0.0","event":"flag_blacklisted","data":["dan.near","sbt.n"]}"#;
        // check only flag event is emitted
        assert_eq!(test_utils::get_logs().len(), 2);
        assert_eq!(test_utils::get_logs()[0], exp);

        assert_eq!(ctr.account_flagged(dan()), Some(AccountFlag::Blacklisted));
        assert_eq!(
            ctr.account_flagged(issuer1()),
            Some(AccountFlag::Blacklisted)
        );
        assert_eq!(ctr.account_flagged(issuer2()), Some(AccountFlag::Verified));

        ctr.admin_unflag_accounts([dan()].to_vec(), "memo".to_owned());

        let exp = r#"EVENT_JSON:{"standard":"i_am_human","version":"1.0.0","event":"unflag","data":["dan.near"]}"#;
        assert_eq!(test_utils::get_logs().len(), 3);
        assert_eq!(test_utils::get_logs()[2], exp);

        assert_eq!(ctr.account_flagged(dan()), None);
        assert_eq!(
            ctr.account_flagged(issuer1()),
            Some(AccountFlag::Blacklisted)
        );
    }

    #[test]
    #[should_panic(expected = "not authorized")]
    fn admin_flag_accounts_non_authorized() {
        let (mut ctx, mut ctr) = setup(&alice(), MINT_DEPOSIT);

        ctx.predecessor_account_id = dan();
        testing_env!(ctx);
        ctr.admin_flag_accounts(AccountFlag::Blacklisted, vec![dan()], "memo".to_owned());
    }

    #[test]
    #[should_panic(expected = "account bob.near is banned")]
    fn admin_flag_accounts_banned() {
        let (_, mut ctr) = setup(&alice(), MINT_DEPOSIT);

        ctr.banlist.insert(&bob());
        ctr.admin_flag_accounts(
            AccountFlag::Blacklisted,
            vec![dan(), bob()],
            "memo".to_owned(),
        );
    }

    #[test]
    #[should_panic(expected = "not authorized")]
    fn admin_unflag_accounts_non_authorized() {
        let (mut ctx, mut ctr) = setup(&alice(), MINT_DEPOSIT);

        ctr.admin_flag_accounts(
            AccountFlag::Blacklisted,
            vec![dan(), issuer1()],
            "memo".to_owned(),
        );
        assert_eq!(ctr.account_flagged(dan()), Some(AccountFlag::Blacklisted));

        ctx.predecessor_account_id = dan();
        testing_env!(ctx);
        ctr.admin_unflag_accounts(vec![dan()], "memo".to_owned());
    }

    #[test]
    fn is_human_flagged() {
        let (_, mut ctr) = setup(&fractal_mainnet(), MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START));
        ctr.sbt_mint(vec![(dan(), vec![m1_1])]);
        let human_proof = vec![(fractal_mainnet(), vec![1])];
        ctr.admin_flag_accounts(AccountFlag::Verified, [dan()].to_vec(), "memo".to_owned());
        assert_eq!(ctr.is_human(dan()), human_proof);

        ctr.admin_flag_accounts(
            AccountFlag::Blacklisted,
            [dan()].to_vec(),
            "memo".to_owned(),
        );
        assert_eq!(ctr.is_human(dan()), vec![]);

        ctr.admin_unflag_accounts([dan()].to_vec(), "memo".to_owned());
        assert_eq!(ctr.is_human(dan()), human_proof);
    }

    #[test]
    #[should_panic(expected = "can't transfer soul when there is a flag conflict")]
    fn flagged_soul_transfer() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        ctr.admin_flag_accounts(AccountFlag::Blacklisted, vec![alice()], "memo".to_owned());
        ctr.admin_flag_accounts(AccountFlag::Verified, vec![bob()], "memo".to_owned());

        // make soul transfer
        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());
        ctr.sbt_soul_transfer(alice2(), None).unwrap();

        assert_eq!(
            ctr.flagged.get(&alice()),
            Some(AccountFlag::Blacklisted),
            "flag must not be removed"
        );
        assert_eq!(
            ctr.flagged.get(&alice2()),
            Some(AccountFlag::Blacklisted),
            "flag is transferred"
        );
        assert_eq!(
            ctr.flagged.get(&bob()),
            Some(AccountFlag::Verified),
            "bob keeps his flag"
        );

        // transferring from blacklisted to verified account should fail
        ctx.predecessor_account_id = alice2();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(bob(), None).unwrap();
    }

    #[test]
    #[should_panic(expected = "can't transfer soul when there is a flag conflict")]
    fn flagged_soul_transfer2() {
        let (mut ctx, mut ctr) = setup(&issuer1(), 2 * MINT_DEPOSIT);

        let m1_1 = mk_metadata(1, Some(START + 10));
        ctr.sbt_mint(vec![(alice(), vec![m1_1])]);
        ctr.admin_flag_accounts(AccountFlag::Verified, vec![alice()], "memo".to_owned());
        ctr.admin_flag_accounts(AccountFlag::Blacklisted, vec![alice2()], "memo".to_owned());

        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        ctr.sbt_soul_transfer(alice2(), None).unwrap();
    }

    #[test]
    fn is_human_call_lock() {
        let (mut ctx, mut ctr) = setup(&fractal_mainnet(), MINT_DEPOSIT);
        ctx.prepaid_gas = ctx.prepaid_gas * 10; // add more gas

        let m1_1 = mk_metadata(1, None);
        ctr.sbt_mint(vec![(alice(), vec![m1_1.clone()])]);
        ctr.sbt_mint(vec![(bob(), vec![m1_1.clone()])]);

        let fun = || "call_me".to_owned();
        let payload = || "{}".to_owned();
        let lock_duration = 5000; // in ms

        //
        // Should fail on not a human
        ctx.predecessor_account_id = carol();
        testing_env!(ctx.clone());
        match ctr.is_human_call_lock(bob(), fun(), payload(), lock_duration, false) {
            Err(err) => assert_eq!(err, IsHumanCallErr::NotHuman),
            Ok(_) => panic!("expects Err(IsHumanCallErr::NotHuman)"),
        };

        //
        // Test transfer lock
        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());
        ctr.is_human_call_lock(bob(), fun(), payload(), lock_duration, false)
            .unwrap();
        assert_eq!(
            ctr.sbt_soul_transfer(alice2(), None),
            Err(SoulTransferErr::TransferLocked)
        );
        // at the lock_duration we should still fail
        ctx.block_timestamp += lock_duration * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(
            ctr.sbt_soul_transfer(alice2(), None),
            Err(SoulTransferErr::TransferLocked)
        );
        // add one more millisecond, now it transfer should work.
        ctx.block_timestamp += MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.sbt_soul_transfer(alice2(), None), Ok((1, true)));

        //
        // Test 2: is_human_call_lock should extend the lock
        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());
        ctr.is_human_call_lock(bob(), fun(), payload(), lock_duration, false)
            .unwrap();
        // call again -> should extend the lock to the max
        testing_env!(ctx.clone()); // reset gas
        ctr.is_human_call_lock(alice(), fun(), payload(), lock_duration * 3, false)
            .unwrap();

        // try to call after the initial lock, but before the extended lock
        ctx.block_timestamp += (2 * lock_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(
            ctr.sbt_soul_transfer(carol(), None),
            Err(SoulTransferErr::TransferLocked)
        );

        // move forward, now it should work
        ctx.block_timestamp += lock_duration * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.sbt_soul_transfer(carol(), None), Ok((1, true)));

        //
        // Test 3: is_human_call_lock should extend the lock only if it's bigger than the previous one
        // use carol to transfer dylan
        ctx.predecessor_account_id = carol();
        testing_env!(ctx.clone());
        ctr.is_human_call_lock(bob(), fun(), payload(), lock_duration, false)
            .unwrap();
        testing_env!(ctx.clone()); // reset gas
        ctr.is_human_call_lock(bob(), fun(), payload(), lock_duration / 2, false)
            .unwrap();
        ctx.block_timestamp += (lock_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.sbt_soul_transfer(dan(), None), Ok((1, true)));
    }
}

'''
'''--- contracts/registry/src/migrate.rs ---
use crate::*;

// registry/v1.6.0
#[derive(BorshDeserialize, PanicOnDefault)]
pub struct OldState {
    pub authority: AccountId,
    pub sbt_issuers: UnorderedMap<AccountId, IssuerId>,
    pub issuer_id_map: LookupMap<IssuerId, AccountId>, // reverse index
    pub(crate) ongoing_soul_tx: LookupMap<AccountId, IssuerTokenId>,
    pub(crate) banlist: UnorderedSet<AccountId>,
    pub(crate) flagged: LookupMap<AccountId, AccountFlag>,
    pub(crate) authorized_flaggers: LazyOption<Vec<AccountId>>,
    pub(crate) supply_by_owner: LookupMap<(AccountId, IssuerId), u64>,
    pub(crate) supply_by_class: LookupMap<(IssuerId, ClassId), u64>,
    pub(crate) supply_by_issuer: LookupMap<IssuerId, u64>,
    pub(crate) balances: TreeMap<BalanceKey, TokenId>,
    pub(crate) issuer_tokens: LookupMap<IssuerTokenId, TokenData>,
    pub(crate) next_token_ids: LookupMap<IssuerId, TokenId>,
    pub(crate) next_issuer_id: IssuerId,
    pub(crate) iah_sbts: (AccountId, Vec<ClassId>),
}

#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    // #[allow(dead_code)]
    pub fn migrate() -> Self {
        let old_state: OldState = env::state_read().expect("failed");
        // new field in the smart contract :
        // + transfer_lock: LookupMap<AccountId, u64>,

        Self {
            authority: old_state.authority.clone(),
            sbt_issuers: old_state.sbt_issuers,
            issuer_id_map: old_state.issuer_id_map,
            transfer_lock: LookupMap::new(StorageKey::TransferLock),
            banlist: old_state.banlist,
            supply_by_owner: old_state.supply_by_owner,
            supply_by_class: old_state.supply_by_class,
            supply_by_issuer: old_state.supply_by_issuer,
            balances: old_state.balances,
            issuer_tokens: old_state.issuer_tokens,
            next_token_ids: old_state.next_token_ids,
            next_issuer_id: old_state.next_issuer_id,
            ongoing_soul_tx: old_state.ongoing_soul_tx,
            iah_sbts: old_state.iah_sbts,
            flagged: old_state.flagged,
            authorized_flaggers: old_state.authorized_flaggers,
        }
    }
}

'''
'''--- contracts/registry/src/registry.rs ---
use std::collections::HashMap;

use near_sdk::{json_types::Base64VecU8, near_bindgen, AccountId};

use crate::*;

const MAX_LIMIT: u32 = 1000;
const MAX_REVOKE_PER_CALL: u32 = 25;

#[near_bindgen]
impl SBTRegistry for Contract {
    /**********
     * QUERIES
     **********/

    /// returns the token, if it does not exist returns None
    fn sbt(&self, issuer: AccountId, token: TokenId) -> Option<Token> {
        let issuer_id = self.assert_issuer(&issuer);
        self.issuer_tokens
            .get(&IssuerTokenId { issuer_id, token })
            .map(|td| td.to_token(token))
    }

    /// Get the information about list of token IDs issued by the SBT `issuer`.
    /// If token ID is not found, `None` is set in the specific return index.
    fn sbts(&self, issuer: AccountId, tokens: Vec<TokenId>) -> Vec<Option<Token>> {
        let issuer_id = self.assert_issuer(&issuer);
        tokens
            .into_iter()
            .map(|token| {
                self.issuer_tokens
                    .get(&IssuerTokenId { issuer_id, token })
                    .map(|td| td.to_token(token))
            })
            .collect()
    }

    /// Query class ID for each token ID issued by the SBT `issuer`.
    /// If token ID is not found, `None` is set in the specific return index.
    fn sbt_classes(&self, issuer: AccountId, tokens: Vec<TokenId>) -> Vec<Option<ClassId>> {
        let issuer_id = self.assert_issuer(&issuer);
        tokens
            .into_iter()
            .map(|token| {
                self.issuer_tokens
                    .get(&IssuerTokenId { issuer_id, token })
                    .map(|td| td.metadata.class_id())
            })
            .collect()
    }

    /// returns total amount of tokens minted by the given issuer
    fn sbt_supply(&self, issuer: AccountId) -> u64 {
        let issuer_id = match self.sbt_issuers.get(&issuer) {
            None => return 0,
            Some(id) => id,
        };
        self.supply_by_issuer.get(&issuer_id).unwrap_or(0)
    }

    /// returns total amount of tokens of given class minted by this contract
    fn sbt_supply_by_class(&self, issuer: AccountId, class: ClassId) -> u64 {
        let issuer_id = match self.sbt_issuers.get(&issuer) {
            None => return 0,
            Some(id) => id,
        };
        self.supply_by_class.get(&(issuer_id, class)).unwrap_or(0)
    }

    /// returns total supply of SBTs for a given owner.
    /// If class is specified, returns only owner supply of the given class -- must be 0 or 1.
    fn sbt_supply_by_owner(
        &self,
        account: AccountId,
        issuer: AccountId,
        class: Option<ClassId>,
    ) -> u64 {
        // we don't check banlist because we should still enable banned accounts to query their tokens
        if self.ongoing_soul_tx.contains_key(&account) {
            return 0;
        }

        let issuer_id = match self.sbt_issuers.get(&issuer) {
            // early return if the class is not registered
            None => return 0,
            Some(id) => id,
        };
        if let Some(class_id) = class {
            return match self
                .balances
                .contains_key(&balance_key(account, issuer_id, class_id))
            {
                true => 1,
                _ => 0,
            };
        }

        self.supply_by_owner.get(&(account, issuer_id)).unwrap_or(0)
    }

    /// Query sbt tokens issued by a given contract.
    /// If `from_token` is not specified, then `from_token` should be assumed
    /// to be the first valid token id.
    /// The function search tokens sequentially. So, if empty list is returned, then a user
    /// should continue querying the contract by setting `from_token = previous from_token + limit`
    /// until the `from_token > sbt_supply(issuer)`.
    /// If limit is not specified, default is used: 1000.
    fn sbt_tokens(
        &self,
        issuer: AccountId,
        from_token: Option<u64>,
        limit: Option<u32>,
        with_expired: Option<bool>,
    ) -> Vec<Token> {
        let issuer_id = match self.sbt_issuers.get(&issuer) {
            None => return vec![],
            Some(i) => i,
        };
        let from_token = from_token.unwrap_or(1);
        require!(from_token > 0, "from_token, if set, must be >= 1");
        let limit = limit.unwrap_or(MAX_LIMIT);
        require!(limit > 0, "limit must be bigger than 0");
        let mut max_id = self.next_token_ids.get(&issuer_id).unwrap_or(0);
        if max_id < from_token {
            return vec![];
        }
        max_id = std::cmp::min(max_id + 1, from_token + limit as u64);

        let now = env::block_timestamp_ms();
        let non_expired = !with_expired.unwrap_or(false);
        let mut resp = Vec::new();
        for token in from_token..max_id {
            if let Some(t) = self.issuer_tokens.get(&IssuerTokenId { issuer_id, token }) {
                if non_expired && t.metadata.expires_at().unwrap_or(now) < now {
                    continue;
                }
                resp.push(t.to_token(token))
            }
        }
        resp
    }

    /// Query SBT tokens by owner
    /// If `from_class` is not specified, then `from_class` should be assumed to be the first
    /// valid class id.
    /// If `issuer` is specified, then returns only tokens minted by that issuer.
    /// If limit is not specified, default is used: MAX_LIMIT.
    /// Returns list of pairs: `(Issuer address, list of token IDs)`.
    /// If `with_expired` is set to `true` then all the tokens are returned including expired ones
    /// otherwise only non-expired tokens are returned.
    fn sbt_tokens_by_owner(
        &self,
        account: AccountId,
        issuer: Option<AccountId>,
        from_class: Option<u64>,
        limit: Option<u32>,
        with_expired: Option<bool>,
    ) -> Vec<(AccountId, Vec<OwnedToken>)> {
        if from_class.is_some() {
            require!(
                issuer.is_some(),
                "issuer must be defined if from_class is defined"
            );
        }
        // we don't check banlist because we should still enable banned accounts to query their tokens
        if self.ongoing_soul_tx.contains_key(&account) {
            return vec![];
        }

        let issuer_id = match &issuer {
            None => 0,
            Some(addr) => self.assert_issuer(addr),
        };
        let from_class = from_class.unwrap_or(0);
        // iter_from starts from exclusive "left end". We need to iteretare from one before.
        let first_key = balance_key(account.clone(), issuer_id, from_class.saturating_sub(1));
        let now = env::block_timestamp_ms();
        let with_expired = with_expired.unwrap_or(false);

        let mut limit = limit.unwrap_or(MAX_LIMIT);
        require!(limit > 0, "limit must be bigger than 0");

        let mut resp = Vec::new();
        let mut tokens = Vec::new();
        let mut prev_issuer = issuer_id;

        for (key, token_id) in self.balances.iter_from(first_key) {
            if key.owner != account {
                break;
            }
            if prev_issuer != key.issuer_id {
                if issuer_id != 0 {
                    break;
                }
                if !tokens.is_empty() {
                    let issuer = self.issuer_by_id(prev_issuer);
                    resp.push((issuer, tokens));
                    tokens = Vec::new();
                }
                prev_issuer = key.issuer_id;
            }
            let t: TokenData = self.get_token(key.issuer_id, token_id);
            if !with_expired && t.metadata.expires_at().unwrap_or(now) < now {
                continue;
            }
            tokens.push(OwnedToken {
                token: token_id,
                metadata: t.metadata.v1(),
            });
            limit -= 1;
            if limit == 0 {
                break;
            }
        }
        if prev_issuer != 0 && !tokens.is_empty() {
            let issuer = self.issuer_by_id(prev_issuer);
            resp.push((issuer, tokens));
        }
        resp
    }

    /// checks if an `account` was banned by the registry.
    fn is_banned(&self, account: AccountId) -> bool {
        self._is_banned(&account)
    }

    /*************
     * Transactions
     *************/

    /// Creates a new, unique tokens and assigns it to the `receiver`.
    /// `token_spec` is a vector of pairs: owner AccountId and TokenMetadata.
    /// Each TokenMetadata must specify non zero `class`.
    /// Must be called by an SBT contract.
    /// Must emit `Mint` event.
    /// Must provide enough NEAR to cover registry storage cost.
    /// Panics with "out of gas" if token_spec vector is too long and not enough gas was
    /// provided.
    #[payable]
    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId> {
        let issuer = &env::predecessor_account_id();
        self._sbt_mint(issuer, token_spec)
    }

    /// sbt_recover reassigns all tokens issued by the caller, from the old owner to a new owner.
    /// Must be called by a valid SBT issuer.
    /// Must emit `Recover` event once all the tokens have been recovered.
    /// Requires attaching enough tokens to cover the storage growth.
    /// Returns the amount of tokens recovered and a boolean: `true` if the whole
    /// process has finished, `false` when the process has not finished and should be
    /// continued by a subsequent call. User must keep calling the `sbt_recover` until `true`
    /// is returned.
    #[payable]
    fn sbt_recover(&mut self, from: AccountId, to: AccountId) -> (u32, bool) {
        self._sbt_recover(from, to, 20)
    }

    /// sbt_renew will update the expire time of provided tokens.
    /// `expires_at` is a unix timestamp miliseconds.
    /// Must be called by an SBT contract.
    /// Must emit `Renew` event.
    /// Use `cost::renew_gas` to calculate expected amount of gas that should be assigned for this
    /// function
    fn sbt_renew(&mut self, tokens: Vec<TokenId>, expires_at: u64) {
        let issuer = env::predecessor_account_id();
        self._sbt_renew(issuer, tokens, expires_at);
    }

    /// Revokes SBT. If `burn==true`, the tokens are burned (removed). Otherwise, the token
    /// expire_at is set to now, making the token expired.
    /// Must be called by an SBT contract.
    /// Must emit `Revoke` event.
    /// Must also emit `Burn` event if the SBT tokens are burned (removed).
    fn sbt_revoke(&mut self, tokens: Vec<TokenId>, burn: bool) {
        let issuer = env::predecessor_account_id();
        let issuer_id = self.assert_issuer(&issuer);
        if burn {
            let mut revoked_per_class: HashMap<u64, u64> = HashMap::new();
            let mut revoked_per_owner: HashMap<AccountId, u64> = HashMap::new();
            let tokens_burned: u64 = tokens.len().try_into().unwrap();
            for token in tokens.clone() {
                // update balances
                let token_object = self.get_token(issuer_id, token);
                let owner = token_object.owner;
                let class_id = token_object.metadata.class_id();
                let balance_key = &BalanceKey {
                    issuer_id,
                    owner: owner.clone(),
                    class_id,
                };
                self.balances.remove(balance_key);

                // collect the info about the tokens revoked per owner and per class
                // to update the balances accordingly
                revoked_per_class
                    .entry(class_id)
                    .and_modify(|key_value| *key_value += 1)
                    .or_insert(1);
                revoked_per_owner
                    .entry(owner)
                    .and_modify(|key_value| *key_value += 1)
                    .or_insert(1);

                // remove from issuer_tokens
                self.issuer_tokens
                    .remove(&IssuerTokenId { issuer_id, token });
            }

            // update supply by owner
            for (owner_id, tokens_revoked) in revoked_per_owner {
                let old_supply = self
                    .supply_by_owner
                    .get(&(owner_id.clone(), issuer_id))
                    .unwrap();
                self.supply_by_owner
                    .insert(&(owner_id, issuer_id), &(old_supply - tokens_revoked));
            }

            // update supply by class
            for (class_id, tokens_revoked) in revoked_per_class {
                let old_supply = self.supply_by_class.get(&(issuer_id, class_id)).unwrap();
                self.supply_by_class
                    .insert(&(issuer_id, class_id), &(old_supply - tokens_revoked));
            }

            // update supply by issuer
            let supply_by_issuer = self.supply_by_issuer.get(&(issuer_id)).unwrap_or(0);
            self.supply_by_issuer
                .insert(&(issuer_id), &(supply_by_issuer - tokens_burned));

            // emit event
            SbtTokensEvent {
                issuer: issuer.clone(),
                tokens: tokens.clone(),
            }
            .emit_burn();
        } else {
            let current_timestamp_ms = env::block_timestamp_ms();
            // revoke
            for token in tokens.clone() {
                // update expire date for all tokens to current_timestamp
                let mut t = self.get_token(issuer_id, token);
                let mut m = t.metadata.v1();
                m.expires_at = Some(current_timestamp_ms);
                t.metadata = m.into();
                self.issuer_tokens
                    .insert(&IssuerTokenId { issuer_id, token }, &t);
            }
        }
        SbtTokensEvent { issuer, tokens }.emit_revoke();
    }

    /// Revokes owners SBTs issued by the caller either by burning or updating their expire
    /// time. The function will try to revoke at most `MAX_REVOKE_PER_CALL` tokens (to fit into the tx
    /// gas limit), so when an owner has many tokens from the issuer, the issuer may need to
    /// call this function multiple times, until all tokens are revoked.
    /// Retuns true if all the tokens were revoked, false otherwise.
    /// If false is returned issuer must call the method until true is returned
    /// Must be called by an SBT contract.
    /// Must emit `Revoke` event.
    /// Must also emit `Burn` event if the SBT tokens are burned (removed).
    fn sbt_revoke_by_owner(&mut self, owner: AccountId, burn: bool) -> bool {
        let issuer = env::predecessor_account_id();
        let issuer_id = self.assert_issuer(&issuer);

        if burn {
            let tokens_by_owner = self.sbt_token_ids_by_owner(owner.clone(), issuer_id, 25);

            if tokens_by_owner.is_empty() {
                return true;
            }
            let mut burned_per_class: HashMap<u64, u64> = HashMap::new();

            // Batch updates for balances and issuer_tokens
            for (token_id, class_id) in &tokens_by_owner {
                let balance_key = BalanceKey {
                    issuer_id,
                    owner: owner.clone(),
                    class_id: *class_id,
                };

                self.balances.remove(&balance_key);

                // Collect info about tokens revoked per class to update the balance accordingly
                burned_per_class
                    .entry(*class_id)
                    .and_modify(|key_value| *key_value += 1)
                    .or_insert(1);

                self.issuer_tokens.remove(&IssuerTokenId {
                    issuer_id,
                    token: *token_id,
                });
            }

            // Batch updates for supply values
            let supply_update = tokens_by_owner.len() as u64;

            // Update supply_by_owner
            let owner_key = &(owner.clone(), issuer_id);
            let supply_owner = self.supply_by_owner.get(owner_key).unwrap_or(0);
            let new_supply_owner = supply_owner - supply_update;
            self.supply_by_owner.insert(owner_key, &new_supply_owner);

            // Update supply_by_issuer
            let supply_issuer = self.supply_by_issuer.get(&issuer_id).unwrap_or(0);
            let new_supply_issuer = supply_issuer - supply_update;
            self.supply_by_issuer.insert(&issuer_id, &new_supply_issuer);

            // Update supply_by_class
            for (class_id, tokens_revoked) in burned_per_class {
                let class_key = &(issuer_id, class_id);
                let supply_class = self.supply_by_class.get(class_key).unwrap_or(0);
                let new_supply_class = supply_class - tokens_revoked;
                self.supply_by_class.insert(class_key, &new_supply_class);
            }

            let token_ids_burned: Vec<TokenId> = tokens_by_owner
                .iter()
                .map(|(token_id, _)| *token_id)
                .collect();

            SbtTokensEvent {
                issuer: issuer.clone(),
                tokens: token_ids_burned.clone(),
            }
            .emit_burn();

            SbtTokensEvent {
                issuer: issuer.clone(),
                tokens: token_ids_burned,
            }
            .emit_revoke();

            // Check if all tokens were burned
            return self.sbt_supply_by_owner(owner.clone(), issuer, None) == 0;
        }

        let (_, non_expired_tokens) = self
            .sbt_tokens_by_owner(
                owner.clone(),
                Some(issuer.clone()),
                None,
                Some(MAX_REVOKE_PER_CALL),
                Some(false),
            )
            .pop()
            .unwrap();

        if non_expired_tokens.is_empty() {
            return true;
        }

        let is_finished = non_expired_tokens.len() < MAX_REVOKE_PER_CALL as usize;

        let mut token_ids: Vec<TokenId> = Vec::new();

        // Revoke: Update expire date for all tokens to current_timestamp
        let now = env::block_timestamp_ms();
        for mut t in non_expired_tokens {
            token_ids.push(t.token);
            t.metadata.expires_at = Some(now);
            let token_data = TokenData {
                owner: owner.clone(),
                metadata: t.metadata.into(),
            };
            self.issuer_tokens.insert(
                &IssuerTokenId {
                    issuer_id,
                    token: t.token,
                },
                &token_data,
            );
        }

        SbtTokensEvent {
            issuer,
            tokens: token_ids,
        }
        .emit_revoke();

        // Check if all tokens were revoked
        is_finished
    }

    /// Allows issuer to update token metadata reference and reference_hash.
    /// * `updates` is a list of triples: (token ID, reference, reference base64-encoded sha256 hash).
    /// Must emit `token_reference` event.
    /// Panics if any of the token IDs don't exist.
    fn sbt_update_token_references(
        &mut self,
        updates: Vec<(TokenId, Option<String>, Option<Base64VecU8>)>,
    ) {
        let issuer = env::predecessor_account_id();
        let issuer_id = self.assert_issuer(&issuer);
        let mut token_ids = vec![0; updates.len()];
        let mut key = IssuerTokenId {
            issuer_id,
            token: 0,
        };
        let mut idx = 0;
        #[allow(clippy::explicit_counter_loop)]
        for (tid, reference, reference_hash) in updates {
            key.token = tid;
            let mut t = match self.issuer_tokens.get(&key) {
                None => env::panic_str(&format!("token {} not found", tid)),
                Some(t) => t,
            };
            let mut m = t.metadata.v1();
            m.reference = reference;
            m.reference_hash = reference_hash;
            t.metadata = m.into();
            self.issuer_tokens.insert(&key, &t);
            token_ids[idx] = tid;
            idx += 1;
        }

        SbtTokensEvent {
            issuer,
            tokens: token_ids,
        }
        .emit_token_reference();
    }
}

'''
'''--- contracts/registry/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::value::RawValue;
use near_sdk::{AccountId, BorshStorageKey};
use sbt::{ClassId, SBTs, TokenId};

/// Issuer contract ID based on the SBT Contract address -> u16 map.
pub type IssuerId = u32;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    SbtIssuers,
    SbtIssuersRev,
    Banlist,
    SupplyByOwner,
    SupplyByClass,
    SupplyByIssuer,
    Balances,
    IssuerTokens,
    NextTokenId,
    OngoingSoultTx,
    Flagged,
    AdminsFlagged,
    TransferLock,
}

#[derive(BorshSerialize, BorshDeserialize, BorshStorageKey, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum AccountFlag {
    /// Account is "blacklisted" when it was marked as a scam or suspectible to be a mnipulated account or not a human.
    Blacklisted,
    /// Manually verified account.
    Verified,
    /// Account misbehaved and should be refused to have a significant governance role. However
    /// it will be able to vote as a Voting Body member.
    GovBan,
}

/// Composition of issuer address and token id used for indexing
#[derive(BorshSerialize, BorshDeserialize)]
pub(crate) struct IssuerTokenId {
    pub issuer_id: IssuerId,
    pub token: TokenId,
}

#[derive(BorshSerialize, BorshDeserialize, Eq, Ord, PartialEq, PartialOrd, Clone)]
pub(crate) struct BalanceKey {
    pub owner: AccountId,
    pub issuer_id: IssuerId,
    pub class_id: ClassId,
}

#[inline]
pub(crate) fn balance_key(owner: AccountId, issuer_id: IssuerId, class_id: ClassId) -> BalanceKey {
    BalanceKey {
        owner,
        issuer_id,
        class_id,
    }
}

/// `is_human_call` wrapper for passing the payload args to the callback.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug,))]
#[serde(crate = "near_sdk::serde")]
pub struct IsHumanCallbackArgs<'a> {
    pub caller: AccountId,
    pub iah_proof: SBTs,
    pub payload: &'a RawValue,
}

/// `is_human_call_lock` wrapper for passing the payload args to the callback.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug,))]
#[serde(crate = "near_sdk::serde")]
pub struct IsHumanLockCallbackArgs<'a> {
    pub caller: AccountId,
    /// time in milliseconds,
    pub locked_until: u64,
    pub iah_proof: Option<SBTs>,
    pub payload: &'a RawValue,
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde_json::{self, json};

    #[test]
    fn is_human_callback_args_serialization() {
        let payload = json!({"nums": [200], "person": {"name": "john", "surname": "Sparrow"}});
        let payload_str = payload.to_string();

        let alice = AccountId::new_unchecked("alice.near".to_string());
        let issuer = AccountId::new_unchecked("issuer.near".to_string());

        let args = IsHumanCallbackArgs {
            caller: alice,
            iah_proof: vec![(issuer, vec![1, 2, 5])],
            payload: &RawValue::from_string(payload_str).unwrap(),
        };

        let args_str = serde_json::to_string(&args).unwrap();
        let expected = r#"{"caller":"alice.near","iah_proof":[["issuer.near",[1,2,5]]],"payload":{"nums":[200],"person":{"name":"john","surname":"Sparrow"}}}"#;

        assert_eq!(expected.to_owned(), args_str);
    }
}

// macro_rules! borsh_be_integer {
//     ($type: ident) => {
//         impl BorshSerialize for $type {
//             #[inline]
//             fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
//                 let bytes = self.to_be_bytes();
//                 writer.write_all(&bytes)
//             }
//         }
//     };
// }

// TODO: implement for
// borsh_be_integer!(CtrId);

// -----------
//
// use near_sdk::CryptoHash;
//
// #[derive(BorshSerialize)]
// pub enum StorageKey {
//     TokenPerOwnerInner { account_id_hash: CryptoHash },
// }
// StorageKey::TokenPerOwnerInner {
//     //we get a new unique prefix for the collection
//     account_id_hash: hash_account_id(&to),
// }
// .try_to_vec()
// .unwrap(),

/*
// used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    // get the default hasher
    let mut hash = CryptoHash::default();
    // we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

 */

'''
'''--- contracts/registry/tests/workspaces.rs ---
use anyhow::Ok;
use near_sdk::serde_json::json;
use near_units::parse_near;
use near_workspaces::{network::Sandbox, Account, AccountId, Contract, Worker};
use registry::storage::AccountFlag;
use sbt::{ClassSet, TokenMetadata};

const MAINNET_REGISTRY_ID: &str = "registry.i-am-human.near";
const BLOCK_HEIGHT: u64 = 92042705;
const IAH_CLASS: u64 = 1;
const OG_CLASS: u64 = 2;

async fn assert_data_consistency(
    registry: &Contract,
    iah_issuer: &Account,
    og_issuer: &Account,
    alice: &Account,
    bob: &Account,
) -> anyhow::Result<()> {
    // run queries before the migration
    let og_supply: u64 = registry
        .call("sbt_supply")
        .args_json(json!({"issuer": og_issuer.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(og_supply, 2);

    let iah_supply: u64 = registry
        .call("sbt_supply")
        .args_json(json!({"issuer": iah_issuer.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(iah_supply, 4);

    let og_supply_by_class: u64 = registry
        .call("sbt_supply_by_class")
        .args_json(json!({"issuer": og_issuer.id(), "class": OG_CLASS}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(og_supply_by_class, 2);

    let iah_supply_by_class: u64 = registry
        .call("sbt_supply_by_class")
        .args_json(json!({"issuer": iah_issuer.id(), "class": IAH_CLASS}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(iah_supply_by_class, 4);

    let alice_iah_supply: u64 = registry
        .call("sbt_supply_by_owner")
        .args_json(json!({"account": alice.id(), "issuer": iah_issuer.id(), "class": null}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(alice_iah_supply, 1);

    let alice_og_supply: u64 = registry
        .call("sbt_supply_by_owner")
        .args_json(json!({"account": alice.id(), "issuer": og_issuer.id(), "class": null}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(alice_og_supply, 1);

    let bob_iah_supply: u64 = registry
        .call("sbt_supply_by_owner")
        .args_json(json!({"account": bob.id(), "issuer": iah_issuer.id(), "class": null}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(bob_iah_supply, 1);

    let bob_og_supply: u64 = registry
        .call("sbt_supply_by_owner")
        .args_json(json!({"account": bob.id(), "issuer": og_issuer.id(), "class": null}))
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(bob_og_supply, 0);

    let iah_class_set: ClassSet = registry
        .call("iah_class_set")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(iah_class_set[0].0.to_string(), iah_issuer.id().to_string());
    assert_eq!(iah_class_set[0].1[0], 1);

    Ok(())
}

async fn init(
    worker: &Worker<Sandbox>,
) -> anyhow::Result<(Account, Account, Account, Contract, Account, Account)> {
    // import the contract from mainnet
    let worker_mainnet = near_workspaces::mainnet().await?;
    let contract_id: AccountId = MAINNET_REGISTRY_ID.parse()?;
    let registry_contract = worker
        .import_contract(&contract_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .transact()
        .await?;

    let registry_mainnet = registry_contract.as_account();
    let authority_acc = worker.dev_create_account().await?;
    let flagger = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let og_issuer = worker.dev_create_account().await?;
    let alice_acc = worker.dev_create_account().await?;
    let bob_acc = worker.dev_create_account().await?;
    let john_acc = worker.dev_create_account().await?;
    let elon_acc = worker.dev_create_account().await?;

    // init the contract
    let res = registry_contract
        .call("new")
        .args_json(json!({"authority": authority_acc.id(),
                          "authorized_flaggers": vec![flagger.id()],
                          "iah_issuer": iah_issuer.id(), "iah_classes": [1]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // add iah_issuer
    let res = authority_acc
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": iah_issuer.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // add og_issuer
    let res = authority_acc
        .call(registry_mainnet.id(), "admin_add_sbt_issuer")
        .args_json(json!({"issuer": og_issuer.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // populate registry with mocked data
    let mut token_metadata = vec![TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: None,
        reference: None,
        reference_hash: None,
    }];

    let iah_token_spec = vec![
        (alice_acc.id(), token_metadata.clone()),
        (bob_acc.id(), token_metadata.clone()),
        (john_acc.id(), token_metadata.clone()),
        (elon_acc.id(), token_metadata.clone()),
    ];

    let res = iah_issuer
        .call(registry_mainnet.id(), "sbt_mint")
        .args_json(json!({ "token_spec": iah_token_spec }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    token_metadata[0].class = 2;
    let og_token_spec = vec![
        (alice_acc.id(), token_metadata.clone()),
        (elon_acc.id(), token_metadata),
    ];

    let res = og_issuer
        .call(registry_mainnet.id(), "sbt_mint")
        .args_json(json!({ "token_spec": og_token_spec }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    Ok((
        registry_mainnet.clone(),
        iah_issuer,
        og_issuer,
        registry_contract,
        alice_acc,
        bob_acc,
    ))
}

#[ignore = "this test is not valid after the migration"]
#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (registry, iah_issuer, og_issuer, old_registry_contract, alice, bob) =
        init(&worker).await?;

    // run queries before the migration
    assert_data_consistency(
        &old_registry_contract,
        &iah_issuer,
        &og_issuer,
        &alice,
        &bob,
    )
    .await?;

    // deploy the new contract
    let new_registry_contract = registry
        .deploy(include_bytes!("../../deployed/registry.wasm"))
        .await?
        .into_result()?;

    // call the migrate method
    let res = new_registry_contract
        .call("migrate")
        .args_json(json!({"authorized_flaggers": [alice.id()]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // run queries after the migration
    assert_data_consistency(
        &new_registry_contract,
        &iah_issuer,
        &og_issuer,
        &alice,
        &bob,
    )
    .await?;

    let res = new_registry_contract
        .call("account_flagged")
        .args_json(json!({"account": "bob.near"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    let res: Option<AccountFlag> = res.json()?;
    assert!(res.is_none());

    let res = alice
        .call(new_registry_contract.id(), "admin_flag_accounts")
        .args_json(
            json!({"flag": AccountFlag::Blacklisted,"accounts": vec!["bob.near"], "memo": "test"}),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let res = new_registry_contract
        .call("account_flagged")
        .args_json(json!({"account": "bob.near"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    let res: Option<AccountFlag> = res.json()?;
    assert_eq!(res.unwrap(), AccountFlag::Blacklisted);

    Ok(())
}

#[ignore = "this test is not valid after the migration"]
// handler error: [State of contract registry.i-am-human.near is too large to be viewed]
// The current running registry contract is too large to be viewed.
// This test cannot be perfomed on real data anymore
#[tokio::test]
async fn migration_mainnet_real_data() -> anyhow::Result<()> {
    // import the registry contract from mainnet with data
    let worker = near_workspaces::sandbox().await?;
    let worker_mainnet = near_workspaces::mainnet_archival().await?;
    let contract_id: AccountId = MAINNET_REGISTRY_ID.parse()?;
    let old_registry_contract = worker
        .import_contract(&contract_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(BLOCK_HEIGHT)
        .with_data()
        .transact()
        .await?;

    // run queries before the migration
    let supply: u64 = old_registry_contract
        .call("sbt_supply")
        .args_json(json!({"issuer": "gooddollar-v1.i-am-human.near"}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    // deploy the new contract
    let new_registry_mainnet = old_registry_contract
        .as_account()
        .deploy(include_bytes!("../../deployed/registry.wasm"))
        .await?
        .into_result()?;

    // call the migrate method
    let res = new_registry_mainnet
        .call("migrate")
        .args_json(json!({"authorized_flaggers": ["alice.near"]}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // run queries after the migration
    let res: u64 = new_registry_mainnet
        .call("sbt_supply")
        .args_json(json!({"issuer": "gooddollar-v1.i-am-human.near"}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(supply, res);

    Ok(())
}

'''
'''--- contracts/sbt/Cargo.toml ---
[package]
name = "sbt"
version = "1.3.0"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true
near-contract-standards.workspace = true

[dev-dependencies]

'''
'''--- contracts/sbt/README.md ---
# SBT common types

'''
'''--- contracts/sbt/src/events.rs ---
use near_sdk::serde::Serialize;
use near_sdk::{env, AccountId};

use crate::SPEC_VERSION;
use crate::{TokenId, STANDARD_NAME};

/// Helper struct to create Standard NEAR Event JSON.
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NearEvent<T: Serialize> {
    pub standard: &'static str,
    pub version: &'static str,

    // `flatten` to not have "event": {<EventVariant>} in the JSON, just have the contents of {<EventVariant>}.
    #[serde(flatten)]
    pub event: T,
}

impl<T: Serialize> NearEvent<T> {
    pub fn to_json_event_string(&self) -> String {
        let s = serde_json::to_string(&self)
            .ok()
            .unwrap_or_else(|| env::abort());
        format!("EVENT_JSON:{}", s)
    }

    pub fn emit(self) {
        env::log_str(&self.to_json_event_string());
    }
}

/// Enum that represents the data type of a NEP-393 Event.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum Nep393Event<'a> {
    // no need to use vector for the event types below, because an event already has list of token IDs
    Mint(SbtMint<'a>),
    Recover(SbtRecover<'a>),
    Renew(SbtTokensEvent),
    Revoke(SbtTokensEvent),
    Burn(SbtTokensEvent),
    SoulTransfer(SoulTransfer<'a>),
    Ban(Vec<&'a AccountId>), // data is a simple list of accounts to ban
    TokenReference(SbtTokensEvent),
}

impl Nep393Event<'_> {
    // todo: maybe move to NearEvent
    pub fn emit(self) {
        NearEvent {
            standard: STANDARD_NAME,
            version: SPEC_VERSION,
            event: self,
        }
        .emit()
    }
}

/// An event emitted when an SBT token issuance succeeded.
/// Arguments:
/// * `issuer`: SBT smart contract initiating the token issuance.
/// * `tokens`: list of pairs (token owner, TokenId[])
/// * `memo`: optional message
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct SbtMint<'a> {
    pub issuer: &'a AccountId,
    pub tokens: Vec<(&'a AccountId, &'a Vec<TokenId>)>,
}
impl SbtMint<'_> {
    pub fn emit(self) {
        Nep393Event::Mint(self).emit();
    }
}

/// An event emitted when a recovery process succeeded to reassign SBT, usually due to account
/// access loss. This action is usually requested by the owner, but executed by an issuer,
/// and doesn't trigger Soul Transfer. Registry recovers all tokens assigned to `old_owner`,
/// hence we don't need to enumerate them.
/// Must be emitted by an SBT registry.
/// * `issuer`: SBT smart contract initiating the token recovery.
/// * `old_owner`: source account from which we recover the tokens.
/// * `new_owner`: destination account for recevered tokens.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct SbtRecover<'a> {
    pub issuer: &'a AccountId,
    pub old_owner: &'a AccountId,
    pub new_owner: &'a AccountId,
}

impl SbtRecover<'_> {
    pub fn emit(self) {
        Nep393Event::Recover(self).emit();
    }
}

/// A common structure for the following events:
/// renew, revoke, burn.
/// Arguments:
/// * `issuer`: SBT smart contract initiating the SBT state change.
/// * `tokens`: list of tokens concering the transaction emitting the event.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct SbtTokensEvent {
    pub issuer: AccountId, // SBT Contract account address
    pub tokens: Vec<TokenId>,
}

impl SbtTokensEvent {
    pub fn emit_renew(self) {
        Nep393Event::Renew(self).emit();
    }

    pub fn emit_revoke(self) {
        Nep393Event::Revoke(self).emit();
    }

    pub fn emit_burn(self) {
        Nep393Event::Burn(self).emit();
    }

    pub fn emit_token_reference(self) {
        Nep393Event::TokenReference(self).emit();
    }
}

/// An event emitted when soul transfer is happening: all SBTs owned by `from` are transferred
/// to `to`, and the `from` account is banned (can't receive any new SBT).
/// Must be emitted by an SBT registry.
/// Registry MUST also emit `Ban` whenever the soul transfer happens.
#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct SoulTransfer<'a> {
    pub from: &'a AccountId,
    pub to: &'a AccountId,
}

impl SoulTransfer<'_> {
    pub fn emit(self) {
        Nep393Event::SoulTransfer(self).emit();
    }
}

pub fn emit_soul_transfer(from: &AccountId, to: &AccountId) {
    SoulTransfer { from, to }.emit();
}

/// Helper struct to be used in `NearEvent.event` to construct NEAR Event compatible payload
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventPayload<T: Serialize> {
    /// event name
    pub event: &'static str,
    /// event payload
    pub data: T,
}

impl<T: Serialize> EventPayload<T> {
    pub fn emit(self, standard: &'static str, version: &'static str) {
        NearEvent {
            standard,
            version,
            event: self,
        }
        .emit()
    }
}

/// NEP-171 compatible Mint event structure. A light version of the Mint event from the
/// `near_contract_standards::non_fungible_token::events::NftMint` to reduce code dependency and size.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Nep171Mint<'a> {
    pub owner_id: &'a AccountId,
    pub token_ids: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

impl Nep171Mint<'_> {
    pub fn emit_many(data: &[Nep171Mint<'_>]) {
        NearEvent {
            standard: "nep171",
            version: "1.0.0",
            event: EventPayload {
                event: "nft_mint",
                data,
            },
        }
        .emit()
    }

    pub fn emit(self) {
        Nep171Mint::emit_many(&[self])
    }
}

#[cfg(test)]
mod tests {
    use near_contract_standards::non_fungible_token::events::NftMint;
    use near_sdk::test_utils;

    use super::*;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob.near".to_string())
    }

    fn charlie() -> AccountId {
        AccountId::new_unchecked("charlie.near".to_string())
    }

    fn sbt_issuer() -> AccountId {
        AccountId::new_unchecked("sbt.near".to_string())
    }

    fn from_nftmint<'a>(n: &NftMint<'a>) -> Nep171Mint<'a> {
        Nep171Mint {
            owner_id: n.owner_id,
            token_ids: n.token_ids.iter().map(|s| s.clone().to_owned()).collect(),
            memo: n.memo.map(|s| s.to_owned()),
        }
    }

    #[test]
    fn log_format_nep171_mint() {
        let alice = alice();
        let bob = bob();
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"bob.near","token_ids":["0","1"]},{"owner_id":"alice.near","token_ids":["4"],"memo":"something"}]}"#;
        let nft_log = vec![
            NftMint {
                owner_id: &bob,
                token_ids: &["0", "1"],
                memo: None,
            },
            NftMint {
                owner_id: &alice,
                token_ids: &["4"],
                memo: Some("something"),
            },
        ];
        NftMint::emit_many(&nft_log);
        assert_eq!(1, test_utils::get_logs().len());
        assert_eq!(expected, test_utils::get_logs()[0]);

        let sbt_log: Vec<Nep171Mint> = nft_log.iter().map(from_nftmint).collect();
        Nep171Mint::emit_many(&sbt_log);
        assert_eq!(2, test_utils::get_logs().len());
        assert_eq!(test_utils::get_logs()[1], expected);

        //
        // Check single event log
        //
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"alice.near","token_ids":["1123"],"memo":"something"}]}"#;
        let nft_log = NftMint {
            owner_id: &alice,
            token_ids: &["1123"],
            memo: Some("something"),
        };
        let log = from_nftmint(&nft_log);
        let log2 = from_nftmint(&nft_log);

        nft_log.emit();
        assert_eq!(3, test_utils::get_logs().len());
        assert_eq!(expected, test_utils::get_logs()[2]);

        log.emit();
        log2.emit();
        assert_eq!(5, test_utils::get_logs().len());
        assert_eq!(expected, test_utils::get_logs()[3]);
        assert_eq!(expected, test_utils::get_logs()[4]);
    }

    #[test]
    fn log_format_mint() {
        let bob = bob();
        let issuer = sbt_issuer();
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"mint","data":{"issuer":"sbt.near","tokens":[["bob.near",[821,10]],["bob.near",[1]]]}}"#;
        let bob1_tokens = vec![821, 10];
        let bob2_tokens = vec![1];
        let event = Nep393Event::Mint(SbtMint {
            issuer: &issuer,
            tokens: vec![(&bob, &bob1_tokens), (&bob, &bob2_tokens)],
        });
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
    }

    #[test]
    fn log_format_recovery() {
        let bob = bob();
        let charlie = charlie();
        let issuer = sbt_issuer();
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"recover","data":{"issuer":"sbt.near","old_owner":"bob.near","new_owner":"charlie.near"}}"#;
        let event = Nep393Event::Recover(SbtRecover {
            issuer: &issuer,
            old_owner: &bob,
            new_owner: &charlie,
        });
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
    }

    #[test]
    fn log_format_renew() {
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"renew","data":{"issuer":"sbt.near","tokens":[21,10,888]}}"#;
        let e = SbtTokensEvent {
            issuer: sbt_issuer(),
            tokens: vec![21, 10, 888],
        };
        let event = Nep393Event::Renew(e.clone());
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
        e.emit_renew();
        assert_eq!(expected, test_utils::get_logs()[1]);
    }

    #[test]
    fn log_format_revoke() {
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"revoke","data":{"issuer":"sbt.near","tokens":[19853,1]}}"#;
        let e = SbtTokensEvent {
            issuer: sbt_issuer(),
            tokens: vec![19853, 1],
        };
        let event = Nep393Event::Revoke(e.clone());
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
        e.emit_revoke();
        assert_eq!(expected, test_utils::get_logs()[1]);
    }

    #[test]
    fn log_format_burn() {
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"burn","data":{"issuer":"sbt.near","tokens":[19853,12]}}"#;
        let e = SbtTokensEvent {
            issuer: sbt_issuer(),
            tokens: vec![19853, 12],
        };
        let event = Nep393Event::Burn(e.clone());
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
        e.emit_burn();
        assert_eq!(expected, test_utils::get_logs()[1]);
    }

    #[test]
    fn log_format_token_reference() {
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"token_reference","data":{"issuer":"sbt.near","tokens":[19853,12]}}"#;
        let e = SbtTokensEvent {
            issuer: sbt_issuer(),
            tokens: vec![19853, 12],
        };
        let event = Nep393Event::TokenReference(e.clone());
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
        e.emit_token_reference();
        assert_eq!(expected, test_utils::get_logs()[1]);
    }

    #[test]
    fn log_format_ban() {
        let alice = alice();
        let bob = bob();
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"ban","data":["alice.near","bob.near"]}"#;
        let event = Nep393Event::Ban(vec![&alice, &bob]);
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
    }

    #[test]
    fn log_soul_transfer() {
        let alice = alice();
        let bob = bob();
        let expected = r#"EVENT_JSON:{"standard":"nep393","version":"1.0.0","event":"soul_transfer","data":{"from":"alice.near","to":"bob.near"}}"#;
        let e = SoulTransfer {
            from: &alice,
            to: &bob,
        };
        let event = Nep393Event::SoulTransfer(e.clone());
        event.emit();
        assert_eq!(expected, test_utils::get_logs()[0]);
        e.emit();
        assert_eq!(expected, test_utils::get_logs()[1]);
    }
}

'''
'''--- contracts/sbt/src/lib.rs ---
mod events;
mod metadata;

use near_sdk::json_types::Base64VecU8;
use near_sdk::{ext_contract, AccountId};

pub use crate::events::*;
pub use crate::metadata::*;

/// This spec can be treated like a version of the standard.
pub const SPEC_VERSION: &str = "1.0.0";
/// This is the name of the SBT standard we're using
pub const STANDARD_NAME: &str = "nep393";

/// 1s in nano seconds.
pub const SECOND: u64 = 1_000_000_000;

// u64 capacity is more than 1e19. If we will mint 10'000 SBTs per second, than it will take us
// 58'494'241 years to get into the capacity.
// Today, the JS integer limit is `2^53-1 ~ 9e15`. It will take us 28'561 years to fill that when minting
// 10'000 SBTs per second.
// So, we don't need to u128 nor a String type.
/// Identifier of a token. There must be no 2 same tokens issued by the same contract, even
/// if other token with same TokenId was burned, or the differe by the `ClassId`.
/// Minimum valid `TokenId` must be 1.
pub type TokenId = u64;

/// The `ClassId` defines a class (category) of SBT set issued from the same contract.
/// SBT tokens can't be fractionized. Also, by definition there should be only one of a token
/// per token class per user. We propose that the SBT Standard will support the multi-token
/// idea from the get go. In a traditional NFT scenario, one contract will only issue tokens
/// of the single class.
/// Minimum valid `ClassId` must be 1.
pub type ClassId = u64;

/// Collection of SBTs serialized as list of pairs: (Issuer Account, Vector of Token IDs).
/// This is used for code size and processing efficiency.
pub type SBTs = Vec<(AccountId, Vec<TokenId>)>;

/// List of pairs: (Issuer Account, Vector of Class IDs).
/// This is used to create class sets used to specify required token classes,
/// like set of tokens required to be verified as IAH
pub type ClassSet = Vec<(AccountId, Vec<ClassId>)>;

/// SBTIssuer is the minimum required interface to be implemented by issuer.
/// Other methods, such as a mint function, which requests the registry to proceed with token
/// minting, is specific to an Issuer implementation (similarly, mint is not part of the FT
/// standard).
pub trait SBTIssuer {
    /// returns contract metadata
    fn sbt_metadata(&self) -> ContractMetadata;
    /// returns sbt class metadata, or None if class is not found.
    fn sbt_class_metadata(&self, class: ClassId) -> Option<ClassMetadata>;
}

pub trait SBTRegistry {
    /**********
     * QUERIES
     **********/

    /// Get the information about specific token ID issued by the `issuer` SBT contract.
    fn sbt(&self, issuer: AccountId, token: TokenId) -> Option<Token>;

    /// Get the information about list of token IDs issued by the SBT `issuer`.
    /// If token ID is not found, `None` is set in the specific return index.
    fn sbts(&self, issuer: AccountId, token: Vec<TokenId>) -> Vec<Option<Token>>;

    /// Query class ID for each token ID issued by the SBT `issuer`.
    /// If token ID is not found, `None` is set in the specific return index.
    fn sbt_classes(&self, issuer: AccountId, tokens: Vec<TokenId>) -> Vec<Option<ClassId>>;

    /// Returns total amount of tokens issued by `issuer` SBT contract, including expired
    /// tokens. Depending on the implementation, if a revoke removes a token, then it should
    /// not be included in the supply.
    fn sbt_supply(&self, issuer: AccountId) -> u64;

    /// Returns total amount of tokens of given class minted by `issuer`. See `sbt_supply` for
    /// information about revoked tokens.
    fn sbt_supply_by_class(&self, issuer: AccountId, class: ClassId) -> u64;

    /// Returns total supply of SBTs for a given owner. See `sbt_supply` for information about
    /// revoked tokens.
    /// If class is specified, returns only owner supply of the given class -- must be 0 or 1.
    fn sbt_supply_by_owner(
        &self,
        account: AccountId,
        issuer: AccountId,
        class: Option<ClassId>,
    ) -> u64;

    /// Query sbt tokens issued by a given contract.
    /// `limit` specifies the upper limit of how many tokens we want to return.
    /// If `from_token` is not specified, then `from_token` should be assumed
    /// to be the first valid token id. If `with_expired` if is set to `false` or to `None` then
    /// all tokens are returned.
    fn sbt_tokens(
        &self,
        issuer: AccountId,
        from_token: Option<u64>,
        limit: Option<u32>,
        with_expired: Option<bool>,
    ) -> Vec<Token>;

    /// Query SBT tokens by owner.
    /// `limit` specifies the upper limit of how many tokens we want to return.
    /// If `from_class` is not specified, then `from_class` should be assumed to be the first
    /// valid class id. If `with_expired` if is set to `false` or `None` then all tokens are returned.
    /// Returns list of pairs: `(Contract address, list of token IDs)`.
    /// If `with_expired` is set to `true` then all the tokens are returned including expired ones
    /// otherwise only non-expired tokens are returned.
    fn sbt_tokens_by_owner(
        &self,
        account: AccountId,
        issuer: Option<AccountId>,
        from_class: Option<u64>,
        limit: Option<u32>,
        with_expired: Option<bool>,
    ) -> Vec<(AccountId, Vec<OwnedToken>)>;

    /// checks if an `account` was banned by the registry.
    fn is_banned(&self, account: AccountId) -> bool;

    /*************
     * Transactions
     *************/

    /// Creates a new, unique token and assigns it to the `receiver`.
    /// `token_spec` is a vector of pairs: owner AccountId and TokenMetadata.
    /// Each TokenMetadata must have non zero `class`.
    /// Must be called by an SBT contract.
    /// Must emit `Mint` event.
    /// Must provide enough NEAR to cover registry storage cost.
    // #[payable]
    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>;

    /// sbt_recover reassigns all tokens issued by the caller, from the old owner to a new owner.
    /// Must be called by a valid SBT issuer.
    /// Must emit `Recover` event once all the tokens have been recovered.
    /// Requires attaching enough tokens to cover the storage growth.
    /// Returns the amount of tokens recovered and a boolean: `true` if the whole
    /// process has finished, `false` when the process has not finished and should be
    /// continued by a subsequent call. User must keep calling the `sbt_recover` until `true`
    /// is returned.
    // #[payable]
    fn sbt_recover(&mut self, from: AccountId, to: AccountId) -> (u32, bool);

    /// sbt_renew will update the expire time of provided tokens.
    /// `expires_at` is a unix timestamp in miliseconds.
    /// Must be called by an SBT contract.
    /// Must emit `Renew` event.
    fn sbt_renew(&mut self, tokens: Vec<TokenId>, expires_at: u64);

    /// Revokes SBT by burning the token or updating its expire time.
    /// Must be called by an SBT contract.
    /// Must emit `Revoke` event.
    /// Must also emit `Burn` event if the SBT tokens are burned (removed).
    fn sbt_revoke(&mut self, tokens: Vec<TokenId>, burn: bool);

    /// Revokes all owners SBTs issued by the caller either by burning or updating their expire time.
    /// Must be called by an SBT contract.
    /// Must emit `Revoke` event.
    /// Must also emit `Burn` event if the SBT tokens are burned (removed).
    fn sbt_revoke_by_owner(&mut self, owner: AccountId, burn: bool) -> bool;

    /// Allows issuer to update token metadata reference and reference_hash.
    /// * `updates` is a list of triples: (token ID, reference, reference hash).
    /// Must emit `token_reference` event.
    /// Panics if any of the token IDs don't exist.
    fn sbt_update_token_references(
        &mut self,
        updates: Vec<(TokenId, Option<String>, Option<Base64VecU8>)>,
    );
}

// ext_registry is a helper to make cross contract registry calls
#[ext_contract(ext_registry)]
trait ExtRegistry {
    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>;
    fn sbt_mint_iah(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>;
    fn sbt_renew(&mut self, tokens: Vec<TokenId>, expires_at: u64);
    fn sbt_revoke(&mut self, tokens: Vec<TokenId>, burn: bool);

    // queries

    fn is_human(&self, account: AccountId) -> Vec<(AccountId, Vec<TokenId>)>;
    fn sbt(&self, issuer: AccountId, token: TokenId) -> Option<Token>;
    fn sbts(&self, issuer: AccountId, tokens: Vec<TokenId>) -> Vec<Option<Token>>;
    fn sbt_classes(&self, issuer: AccountId, tokens: Vec<TokenId>) -> Vec<Option<ClassId>>;
}

'''
'''--- contracts/sbt/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{require, AccountId};

#[allow(unused_imports)]
use near_sdk::NearSchema;

use crate::*;

/// ContractMetadata defines contract wide attributes, which describes the whole contract.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, NearSchema)
)]
pub struct ContractMetadata {
    /// Version with namespace, example: "sbt-1.0.0". Required.
    pub spec: String,
    /// Issuer Name, required, ex. "Mosaics"
    pub name: String,
    /// Issuer symbol which can be used as a token symbol, eg , , BTC, MOSAIC ...
    pub symbol: String,
    /// Icon content (SVG) or a link to an Icon. If it doesn't start with a scheme (eg: https://)
    /// then `base_uri` should be prepended.
    pub icon: Option<String>,
    /// URI prefix which will be prepended to other links which don't start with a scheme
    /// (eg: ipfs:// or https:// ...).
    pub base_uri: Option<String>,
    /// JSON or an URL to a JSON file with more info. If it doesn't start with a scheme
    /// (eg: https://) then base_uri should be prepended.
    pub reference: Option<String>,
    /// Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub reference_hash: Option<Base64VecU8>,
}

/// ClassMetadata describes an issuer class.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, NearSchema)
)]
pub struct ClassMetadata {
    /// Issuer class name. Required.
    pub name: String,
    /// If defined, should be used instead of `contract_metadata.symbol`.
    pub symbol: Option<String>,
    /// Icon content (SVG) or a link to an Icon. If it doesn't start with a scheme (eg: https://)
    /// then `contract_metadata.base_uri` should be prepended.
    pub icon: Option<String>,
    /// JSON or an URL to a JSON file with more info. If it doesn't start with a scheme
    /// (eg: https://) then base_uri should be prepended.
    pub reference: Option<String>,
    /// Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub reference_hash: Option<Base64VecU8>,
}

/// Versioned token metadata
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[cfg_attr(test, derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub enum VerTokenMetadata {
    V1(TokenMetadata),
}

/// TokenMetadata defines attributes for each SBT token.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, NearSchema)
)]
pub struct TokenMetadata {
    /// token class, must be non zero.
    pub class: ClassId,
    /// When the token was issued or minted, Unix time in milliseconds
    pub issued_at: Option<u64>,
    /// When the token expires, Unix time in milliseconds
    pub expires_at: Option<u64>,
    /// JSON or an URL to a JSON file with more info. If it doesn't start with a scheme
    /// (eg: https://) then base_uri should be prepended.
    pub reference: Option<String>,
    /// Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub reference_hash: Option<Base64VecU8>,
}

impl VerTokenMetadata {
    pub fn v1(self) -> TokenMetadata {
        match self {
            VerTokenMetadata::V1(x) => x,
        }
    }

    pub fn class_id(&self) -> ClassId {
        match self {
            VerTokenMetadata::V1(x) => x.class,
        }
    }

    pub fn expires_at(&self) -> Option<u64> {
        match self {
            VerTokenMetadata::V1(x) => x.expires_at,
        }
    }
}

impl From<TokenMetadata> for VerTokenMetadata {
    fn from(m: TokenMetadata) -> Self {
        VerTokenMetadata::V1(m)
    }
}

/// Full information about the token
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenData {
    pub owner: AccountId,
    pub metadata: VerTokenMetadata,
}

impl TokenData {
    pub fn to_token(self, token: TokenId) -> Token {
        let metadata: TokenMetadata = self.metadata.v1();
        Token {
            token,
            metadata,
            owner: self.owner,
        }
    }
}

/// token data for sbt_tokens_by_owner response
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, NearSchema)
)]
pub struct OwnedToken {
    pub token: TokenId,
    pub metadata: TokenMetadata,
}

/// Full information about the token
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, NearSchema)
)]
pub struct Token {
    pub token: TokenId,
    pub owner: AccountId,
    pub metadata: TokenMetadata,
}

impl ContractMetadata {
    pub fn assert_valid(&self) {
        require!(self.spec == crate::SPEC_VERSION, "Spec is not NFT metadata");
        require!(
            !self.name.is_empty() && !self.symbol.is_empty(),
            "name and spec must be a non empty string"
        );
        require!(
            self.reference.is_some() == self.reference_hash.is_some(),
            "Reference and reference hash must be present"
        );
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.0.len() == 32, "Hash has to be 32 bytes");
        }
    }
}

impl TokenMetadata {
    pub fn assert_valid(&self) {
        // require!(self.media.is_some() == self.media_hash.is_some());
        // if let Some(media_hash) = &self.media_hash {
        //     require!(media_hash.0.len() == 32, "Media hash has to be 32 bytes");
        // }

        require!(self.reference.is_some() == self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            require!(
                reference_hash.0.len() == 32,
                "Reference hash has to be 32 bytes"
            );
        }
    }
}

'''
'''--- contracts/soulbound-class/Cargo.toml ---
[package]
name = "soulbound-class"
version = "0.0.1"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

'''
'''--- contracts/soulbound-class/README.md ---
# Soulbound Class

Status: Draft

Implementing an algebraic class to express various SBT models.

'''
'''--- contracts/soulbound-class/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault, PromiseOrValue,
    PromiseResult,
};

/// Balance of one mili NEAR, which is 10^23 Yocto NEAR.
pub const MILI_NEAR: Balance = 1_000_000_000_000_000_000_000;
pub const BLACKLIST_COST: Balance = 5 * MILI_NEAR;
pub const GAS_SBT_QUERY: Gas = Gas(4 * Gas::ONE_TERA.0);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Required SBT smart contract
    pub required_sbt: AccountId,
    /// minium amount of tokens a user has to hold to qualify
    pub min_amount: u32,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(required_sbt: AccountId, min_amount: u32) -> Self {
        Self {
            required_sbt,
            min_amount,
        }
    }

    /// returns if given account meets the class criteria
    #[allow(unused_variables)]
    pub fn is_qualified(
        &self,
        account: AccountId,
        payload: Option<String>,
    ) -> PromiseOrValue<bool> {
        ext_sbt::ext(self.required_sbt.clone())
            .sbt_supply_by_owner(account)
            .then(Self::ext(env::current_account_id()).is_qualified_callback())
            .into()
    }

    #[private]
    pub fn is_qualified_callback(&self) -> bool {
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(num) = near_sdk::serde_json::from_slice::<U128>(&value) {
                return num.0 >= self.min_amount as u128;
            }
        }
        false
    }
}

#[ext_contract(ext_sbt)]
pub trait Sbt {
    fn sbt_supply_by_owner(&self, account: AccountId) -> U128;
}

'''
'''--- contracts/test-util/Cargo.toml ---
[package]
name = "test-util"
version = "1.0.0"
authors = [
    "NDC GWG (https://near.social/#/mob.near/widget/ProfilePage?accountId=govworkinggroup.near)",
]
edition = { workspace = true }
repository = { workspace = true }

[dependencies]
near-sdk.workspace = true
serde_json.workspace = true
near-workspaces.workspace = true
anyhow.workspace = true
near-units.workspace = true
ed25519-dalek.workspace = true
sbt = { path = "../sbt" }
uuid = { version = "1.3.3", features = ["v4", "fast-rng"] }
near-crypto = "^0"

[dev-dependencies]

'''
'''--- contracts/test-util/src/lib.rs ---
use anyhow::Ok;
use near_units::parse_near;
use near_workspaces::network::{NetworkClient, NetworkInfo, Sandbox};
use near_workspaces::result::ExecutionSuccess;
use near_workspaces::AccountId;
use near_workspaces::{
    types::{Balance, KeyType, SecretKey},
    Account, Contract, DevNetwork, Worker,
};
use sbt::TokenMetadata;
use serde_json::json;
use std::str::FromStr;

pub mod oracle;
pub mod utils;

/// Generate user sub-account
pub async fn gen_user_account<T>(worker: &Worker<T>, account_id: &str) -> anyhow::Result<Account>
where
    T: DevNetwork + Send + Sync,
{
    let id = near_workspaces::AccountId::from_str(account_id)?;
    let sk = SecretKey::from_random(KeyType::ED25519);

    let account = worker.create_tla(id, sk).await?.into_result()?;

    Ok(account)
}

pub async fn transfer_near(
    worker: &Worker<Sandbox>,
    account_id: &near_workspaces::AccountId,
    deposit: Balance,
) -> anyhow::Result<ExecutionSuccess> {
    Ok(worker
        .root_account()?
        .transfer_near(account_id, deposit)
        .await?
        .into_result()?)
}

/// Build contract from sources and initialize it
pub async fn deploy_contract<T>(
    worker: &Worker<T>,
    project_path: &str,
    init_method: &str,
    args: near_sdk::serde_json::Value,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = near_workspaces::compile_project(project_path).await?;

    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id.clone(), sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call(init_method)
        .args_json(args)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

/// Load already built contract and initialize it
pub async fn load_contract<T>(
    worker: &Worker<T>,
    contract_path: &str,
    init_method: &str,
    args: near_sdk::serde_json::Value,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = std::fs::read(contract_path)?;
    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id, sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call(init_method)
        .args_json(args)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

/// Get current block timestamp
pub async fn get_block_timestamp<T>(worker: &Worker<T>) -> anyhow::Result<u64>
where
    T: NetworkClient + Send + Sync,
{
    Ok(worker.view_block().await?.timestamp())
}

/// Helper function to issue tokens to the users for testing purposes
pub async fn registry_mint_iah_tokens(
    registry: &AccountId,
    issuer: &Account,
    class_id: u64,
    accounts: Vec<&AccountId>,
) -> anyhow::Result<()> {
    // populate registry with mocked data
    let token_metadata = vec![TokenMetadata {
        class: class_id,
        issued_at: Some(0),
        expires_at: None,
        reference: None,
        reference_hash: None,
    }];
    let mut iah_token_spec = Vec::new();

    for a in accounts {
        iah_token_spec.push((a, token_metadata.clone()));
    }

    let res = issuer
        .call(registry, "sbt_mint")
        .args_json(json!({ "token_spec": iah_token_spec }))
        .deposit(parse_near!("5 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    Ok(())
}

/// Helper function to add issuers to the registry
pub async fn registry_add_issuer(
    registry: &AccountId,
    authority: &Account,
    issuers: Vec<&AccountId>,
) -> anyhow::Result<()> {
    for i in issuers {
        let res = authority
            .call(registry, "admin_add_sbt_issuer")
            .args_json(json!({ "issuer": i }))
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success());
    }
    Ok(())
}

// Helper function to deploy, initalize and mint iah sbts to the `iah_accounts`.
pub async fn registry_default<T>(
    worker: &Worker<T>,
    authority: &AccountId,
    flaggers: Vec<&AccountId>,
    iah_accounts: Vec<&AccountId>,
) -> anyhow::Result<(Account, Account)>
where
    T: DevNetwork + Send + Sync,
{
    const IAH_CLASS: u64 = 1;
    let iah_issuer = worker.dev_create_account().await?;
    let registry_contract = deploy_contract(
        &worker,
        "./../registry",
        "new",
        json!({"authority": authority, "authorized_flaggers": flaggers, "iah_issuer": iah_issuer.id(), "iah_classes": [IAH_CLASS]}),
    ).await?;

    // issue iah tokens to iah_accounts
    registry_mint_iah_tokens(registry_contract.id(), &iah_issuer, 1, iah_accounts).await?;

    Ok((registry_contract.as_account().clone(), iah_issuer))
}

'''
'''--- contracts/test-util/src/oracle.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use uuid::Uuid;

/// External account id represented as hexadecimal string
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct ExternalAccountId(String);

impl std::fmt::Display for ExternalAccountId {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<Uuid> for ExternalAccountId {
    fn from(value: Uuid) -> Self {
        let mut buf = [0u8; uuid::fmt::Simple::LENGTH];
        Self(value.as_simple().encode_lower(&mut buf).to_owned())
    }
}

impl ExternalAccountId {
    pub fn gen() -> Self {
        Uuid::new_v4().into()
    }
}

#[derive(Debug, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SignedClaim {
    pub claim_b64: String,
    pub claim_sig: String,
}

'''
'''--- contracts/test-util/src/utils.rs ---
use ed25519_dalek::Signer;
use near_crypto::{PublicKey, SecretKey};
use near_sdk::{test_utils::VMContextBuilder, AccountId, Balance, Gas};

pub const MAX_GAS: Gas = Gas(300_000_000_000_000);

pub fn build_default_context(
    predecessor_account_id: AccountId,
    deposit: Option<Balance>,
    prepaid_gas: Option<Gas>,
) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
        .signer_account_id(predecessor_account_id.clone())
        .predecessor_account_id(predecessor_account_id)
        .prepaid_gas(prepaid_gas.unwrap_or(MAX_GAS))
        .attached_deposit(deposit.unwrap_or_default());
    builder
}

pub fn generate_keys() -> (SecretKey, PublicKey) {
    let seckey = SecretKey::from_random(near_crypto::KeyType::ED25519);
    let pubkey = seckey.public_key();

    (seckey, pubkey)
}

pub fn sign_bytes(bytes: &[u8], sec_key: &SecretKey) -> Vec<u8> {
    match sec_key {
        SecretKey::ED25519(secret_key) => {
            let keypair = ed25519_dalek::Keypair::from_bytes(&secret_key.0).unwrap();
            keypair.sign(bytes).to_bytes().to_vec()
        }
        _ => unimplemented!(),
    }
}

'''
'''--- contracts/ubi/Cargo.toml ---
[package]
name = "ubi"
version = "0.0.1"
authors = ["Robert Zaremba 'https://zaremba.ch/'"]
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
crate-type = ["cdylib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

'''
'''--- contracts/ubi/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault, Promise,
    PromiseOrValue, PromiseResult,
};

/// Balance of one mili NEAR, which is 10^23 Yocto NEAR.
pub const MILI_NEAR: Balance = 1_000_000_000_000_000_000_000;
pub const BLACKLIST_COST: Balance = 5 * MILI_NEAR;
pub const GAS_SBT_QUERY: Gas = Gas(4 * Gas::ONE_TERA.0);

/// DAY in seconds
pub const DAY: u64 = 3600 * 24;
/// TTL for proof of humanity check = 100 days
pub const TTL: u64 = DAY * 100;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// class verifying humanity
    pub class: AccountId,
    /// daily emission
    pub emission: u128,

    /// map of registered humans, and their record
    pub humans: UnorderedMap<AccountId, UbiCheck>,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct UbiCheck {
    /// last unix timestamp (in seconds) when last claim was made
    pub last_claim: u64,
    /// expire time of humanity verificaion as a unix timestamp (in seconds)
    pub expires_at: u64,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(human_class: AccountId, emission: U128) -> Self {
        Self {
            class: human_class,
            emission: emission.0,
            humans: UnorderedMap::new(b'h'),
        }
    }

    /// registers a new user
    pub fn register(&mut self) -> PromiseOrValue<bool> {
        let user = env::predecessor_account_id();
        ext_class::ext(self.class.clone())
            .is_qualified(user.clone(), None)
            .then(Self::ext(env::current_account_id()).register_callback(user))
            .into()
    }

    pub fn claim(&mut self) {
        let user = env::predecessor_account_id();
        let mut check = self.humans.get(&user).expect("user not registered");
        let now = env::block_timestamp_ms() / 1_000;
        require!(check.expires_at > now, "human proof expired");
        require!(
            check.last_claim + DAY < now,
            "UBI already claimed in past 24h"
        );

        check.last_claim = now;
        self.humans.insert(&user, &check);
        // transfer NEAR UBI
        Promise::new(user).transfer(self.emission);
    }

    #[private]
    pub fn register_callback(&mut self, account: AccountId) -> bool {
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(ok) = near_sdk::serde_json::from_slice::<bool>(&value) {
                if !ok {
                    return false;
                }
                let now = env::block_timestamp_ms() / 1_000;
                self.humans.insert(
                    &account,
                    &UbiCheck {
                        last_claim: now - DAY - 1,
                        expires_at: now + TTL,
                    },
                );
                return true;
            }
        }
        false
    }
}

#[ext_contract(ext_class)]
pub trait HumanClass {
    fn is_qualified(&self, account: AccountId, payload: Option<String>) -> PromiseOrValue<bool>;
}

'''
'''--- nearcon-hackathon-example.md ---
# Example Apps for NEARCon 2022 Hackathon

This document demonstrates the Soulbound Token reference implementation, Human Class basic implementation and 2 use cases: _Universal Basic Income_ and a _Farm Drop_.

### Deploy an example SBT contract and Human Class

```bash
B=blacklist_accounts.i-am-human.testnet
S=sbt1.i-am-human.testnet
C=class1.i-am-human.testnet

near create-account $B --masterAccount i-am-human.testnet --initialBalance 4
near deploy $B target/wasm32-unknown-unknown/release/blacklist_human_addresses.wasm  "new" '{}'

near create-account $S --masterAccount i-am-human.testnet --initialBalance 7
near deploy $S target/wasm32-unknown-unknown/release/soulbound.wasm "new"  '{"issuer": "robertz.testnet", "operators": ["robertz.testnet"], "metadata": {"spec":"sbt-1.0.0", "name": "fist-bump", "symbol": "fist-bump-sbt"}, "blacklist_registry": "'$B'"}'

near create-account $C --masterAccount i-am-human.testnet --initialBalance 6
near deploy $C target/wasm32-unknown-unknown/release/soulbound_class.wasm "new" '{"required_sbt": "'$S'", "min_amount": 2}'
```

Now, we will use 2 test accounts: `alice_star.testnet` and `bob_star.testnet`. We will issue 2 tokens to Alice and one to Bob.

```bash
> near call $S sbt_mint '{"metadata": {"name":"fist band with Robert"}, "receiver": "alice_star.testnet"}' --account_id robertz.testnet --depositYocto 1
https://explorer.testnet.near.org/transactions/4PczF4tPHhsFT5V8zoyGH3PuYV2V4zqD2kDFLsZga9e8

> near call $S sbt_mint '{"metadata": {"name":"fist band with Noak"}, "receiver": "alice_star.testnet"}' --account_id robertz.testnet --depositYocto 1
https://explorer.testnet.near.org/transactions/9cWPogZGNRuPQrkPAn1gEyGFzjE9ccNEZHbGTxhmqLPb

> near call $S sbt_mint '{"metadata": {"name":"fist band with Noak"}, "receiver": "bob_star.testnet"}' --account_id robertz.testnet --depositYocto 1
https://explorer.testnet.near.org/transactions/GtbjrBTb6iei9FeXyC9W3bQcXXZrn5R93CSYFGYZ8cDd
```

Now we can verify that Alice is qualified in class1 and Bob is not:

```bash
> near call $C is_qualified '{"account": "alice_star.testnet"}' --account_id robertz.testnet
true
https://explorer.testnet.near.org/transactions/8JK7iSrf4BxUcBSBhZVkNqmpc1Ss2FLyQzsMBqnfZsfz

> near call $C is_qualified '{"account": "bob_star.testnet"}' --account_id robertz.testnet
false
https://explorer.testnet.near.org/transactions/5HyCLKMsMwCYp7p3skoXNE6NTLwhRvwwKXnChmFDnGtY

> near call $C is_qualified '{"account": "unknown.testnet"}' --account_id robertz.testnet
false
https://explorer.testnet.near.org/transactions/8UqsAX8H9bwBj6b2kbRZbVUaLXP236rboF3YTHgjJ2JR
```

### UBI

We will utilize `class1` Human Class to create a simple [Universal Basic Income](https://www.investopedia.com/terms/b/basic-income.asp) (UBI) smart contract.
The UBI smart contract implemented for this demo is a naive implementation:

- user to claim an UBI must firstly register himself.
  - during registration, we check if a user is qualified in `class1`. If not, the registration will fail.
- once a user is registered, he can call `claim` method to receive daily UBI.
- we will set 0.02 NEAR emission / day / user
- enough NEAR must be provided to the contract to cover storage and UBI emissions.

```bash
UBI=ubi.i-am-human.testnet
> near deploy $UBI target/wasm32-unknown-unknown/release/ubi.wasm "new" '{"human_class": "'$C'", "emission": "20000000000000000000000"}'
https://explorer.testnet.near.org/transactions/5AQM5iAQRsCvX2nSd7wLguuRM9zMfQbuoiLXmgc8KQ9t

near send i-am-human.testnet $UBI 5
```

We firstly register Alice - registration should work because she is qualified in `class1`. Right after we will try to claim the UBI.

```bash
> near call $UBI register '{}' --account_id alice_star.testnet --gas=100000000000000
true
https://explorer.testnet.near.org/transactions/88z7Lj4SpyeUibuRNg1CHw8cPkYKsscvs2RH1zdgo8o3

> near state alice_star.testnet | grep amount
  amount: '199995118013366575500000000',

> near call $UBI claim '{}' --account_id alice_star.testnet
https://explorer.testnet.near.org/transactions/5niaa1JaZHNruUMFSDzCJS1jrqf8vDEoDcJt8Si4xxL1
> near state alice_star.testnet | grep amount
  amount: '200013390038916953900000000',
```

Registering Bob fails because he is not qualified in `class1`:

```bash
> near call $UBI register '{}' --account_id bob_star.testnet --gas=100000000000000
false
https://explorer.testnet.near.org/transactions/CGENd24zkKM9DkbVXhDLUm6H6L3Y8hH5iynTQ28HzhFK
```

### Social Graph

Social Graph can be used to generate SBT tokens, proving positive pass of a social graph algorithm.

### Cheddar Farm Drop

<!-- markdown-link-check-disable-line --> As an alternative to popular AirDrops, we are designing a [Cheddar Farm](https://cheddar.farm)

to stake community token and farm new token:

- Only users who pass a human criteria can register to a Cheddar Farm Drops.
- Each Farm Drop defines a staking token and a reward token. Staking token is usually
  one of the ecosystem tokens, while farmed tokens is a new token which is supposed to
  be distributed.
- This way we create loyalty network:
  - new tokens has an access to a community of doers and humans.
  - new token can be a staking token in the future (which can drive a demand).
  - cheddar can be additional minted to support new projects entering to the NEAER market.

'''