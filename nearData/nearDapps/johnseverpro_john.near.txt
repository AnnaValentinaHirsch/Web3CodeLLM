*GitHub Repository "johnseverpro/john.near"*

'''--- .gitpod.yml ---
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default && npm install near-shell -g --no-optional
    command: yarn && brew install tree && clear && echo Welcome to Exploring NEAR APIs
'''
'''--- README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

# NEAR Protocol Workshop :: Exploring NEAR Protocol APIs

This workshop includes several activities:

- a [**client-side playground**](#activityclient-side-playground) to better understand how `near-api-js` works
- a [**console-based challenge**](#activityhello-near-shell) to practice using NEAR Shell to manage keys, create accounts and deploy contracts
- a [**monitoring challenge**](#activityrealtime-dapp-monitoring-hack) to apply lessons about `near-api-js` and `JSON RPC API` into a single interface

**Prerequisites**

If you're already comfortable with JavaScript, the command line and JSON RPC APIs then this should be a breeze. If you're unfamiliar with the NEAR APIs and have limited or no experience with our network then this workshop will be very helpful. If you have no programming experience then this workshop will be challenging for you -- find someone to pair with so you can stay motivated and productive.

**Companion Presentation**

This hands-on workshop is paired with a presentation called [Hello, NEAR APIs](https://docs.google.com/presentation/d/1hD643Pfg4moFUBFNpAyiMJe2oFYQQuBjKAHg2Rq41kQ) which helps set the context for this work and clarifies a few key mental models.

Before diving into this workshop, have a look at the slides linked above.

**Orientation**

If you're totally new to NEAR you can [start here](https://docs.near.org/docs/concepts/new-to-near) with a high level overview.

NEAR Protocol (aka "NEAR") is a public peer-to-peer key-value database. Public as in open to everyone for reading anything and writing what you are allowed to. Write permissions are defined by access keys so only the owner of the data can give permissions to modify data they own.

Manipulation of data is controlled by stored procedures (smart contracts) executing as [WebAssembly (Wasm)](https://webassembly.org) which means they can be implemented in any programming language that compiles to Wasm (ie. Rust, AssemblyScript, Kotlin, C, C++, Nim, Zig, etc). Currently only the first two languages are supported for development on the NEAR platform.

_We will not be building dApps around any of these contracts since our focus is on learning AssemblyScript. Almost all of the contract code presented in this workshop is also running on [live examples](https://near.dev) where you will also find the frontend code that relies on these contracts._

## Environment Setup

### Using Gitpod

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/near-examples/workshop--exploring-near-apis)

### Local Setup

1. clone this repo locally
2. run `yarn` to install dependencies

## Available commands

### Building contracts

- `yarn build` builds all contracts
- `yarn clean` deletes the `out` folder containing built contracts

You can filter any of the tests by a specific contract name by appending the contract name

```text
yarn build greeting
```

### Testing contracts

- `yarn test:all` runs all tests for all contracts
- `yarn test:unit` runs only unit tests for all contracts
- `yarn test:simulate:runtime` runs only simulation tests for all contracts

You can filter any of the **unit tests** by a specific contract name by appending `-f <contract name>` to the command above, for example

```
yarn test:unit -f greeting
```

See `package.json` for more detail about these and other scripts.

You will find the following folder structure in this repository. Some files have been omitted for clarity

```text
README.md
â”‚
â”œâ”€â”€ bin
â”‚Â Â  â”œâ”€â”€ decode-state
â”‚Â Â  â”œâ”€â”€ deploy-contract
â”‚Â Â  â”œâ”€â”€ transcode
â”‚Â Â  â””â”€â”€ wasm-to-codehash
â”‚
â”œâ”€â”€ challenges
â”‚Â Â  â”œâ”€â”€ client-side-authentication.md
â”‚Â Â  â””â”€â”€ managing-keys-with-near-shell.md
â”‚
â””â”€â”€ contracts
 Â Â  â”œâ”€â”€ 01.greeting
 Â Â  â”œâ”€â”€ 02.counter
 Â Â  â”œâ”€â”€ 03.guestbook
 Â Â  â”œâ”€â”€ 04.cross-contract-calls
 Â Â  â””â”€â”€ compile.js
```

_Note the projects are ordered by increasing complexity so lower numbers roughly implies "easier to understand"._

## Fundamentals of NEAR Protocol

### Accounts

A few points are worth noting early about how accounts work on NEAR since they're likely different from other blockchain account naming systems you've worked with.

- Accounts are human readable names and may represent either a user, a contract or both.
  - Account names follow a DNS naming pattern segmented by periods (`.`)
    - Account IDs have a minimum length of 2 characters
    - NEAR deducts a recurrent tax from the account balance for short account IDs (up to 10 characters) with an exponentially decreasing rate based on length.
    - All accounts on a specific network end in the name of the network (ie. one of `mainnet`, `testnet`, `betanet`)
    - It is reasonable to create your user account as `username.testnet` and deploy contracts as sub-accounts (`guestbook.username.testnet`, `v2.guestbook.username.testnet`, etc)
  - Accounts maintain their own storage
    - Storage includes the account name, contract code (if a contract is deployed to the account) and any state storage
    - Rent is deducted from an account's balance of NEAR tokens
  - Each account may have 1 and only 1 contract deployed to its storage.
    - An account **without** a contract will report a `code_hash` of `11111111111111111111111111111111`
    - An account **with** a contract will report a `code_hash` of some value that is unique to the compiled `.wasm` of that contract
    - Subsequent deployments overwrite contract code _without_ affecting storage (except for the `STATE` key which holds the contract code)

_You can read [more about accounts here](https://docs.near.org/docs/concepts/account)_

## Contracts

- Contracts must be deployed to one (or more) specific account(s)

  - For a family of contracts, account names can be scoped as `contract1.myapp`, `contract2.myapp`

- To call methods on deployed contracts we have a choice of tools and interfaces
  - RPC ([see here](https://docs.near.org/docs/interaction/rpc))
  - `near-api-js` ([see here](https://near.github.io/near-api-js/classes/_account_.account.html#functioncall))
  - `NEAR Shell` ([see here](https://docs.near.org/docs/tools/near-cli))

## Activity::Client-Side Playground

> **_Instructions_**
>
> Open the [challenge page](challenges/client-side-authentication.md) and step through the instructions
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

`near-api-js` (our JavaScript API) wraps the NEAR JSON RPC API and exposes NEAR Wallet authentication. This challenge explores the bare minimum setup needed to connect to NEAR using `near-api-js` and authentication using NEAR Wallet.

## Activity::Hello, NEAR Shell!

> **_Instructions_**
>
> Open the [challenge page](challenges/managing-keys-with-near-shell.md) and step through the instructions
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

NEAR Shell serves as a console Swiss army knife with the ability to manage accounts, contracts and more. This challenge walks through installing NEAR Shell before using it to create accounts, deploy contracts and test them on the network.

## Activity::Realtime dApp Monitoring Hack

> **_Instructions_**
>
> Open the [challenge page](challenges/realtime-monitoring-of-dapps.md) and step through the instructions
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

NEAR's JSON RPC API provides a number of methods that make it easy for developers to query the network. Combining these methods with the `watch` command lets us refresh at regular intervals and create a realtime monitor for our dApps

## Getting Help

If you find yourself stuck with any of this, feel free to reach out to us via the following links:

- [near.org / help](http://near.org/help)
- [near.chat](http://near.chat)
- [documentation](http://docs.near.org)

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "contracts/01.greeting",
    "contracts/02.counter",
    "contracts/03.guestbook",
    "contracts/04.cross-contract-calls/assembly/sentences",
    "contracts/04.cross-contract-calls/assembly/words"
  ],
  "outDir": "./out"
}

'''
'''--- challenges/apps/playground/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting to the NEAR platform</title>
    <!-- to connect to the NEAR platform, include a reference to near-api-js -->
    <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.23.2/dist/near-api-js.min.js"></script>
    <script>
      // configure network settings and key storage
      const config = {
        networkId: "default", // this can be any label to namespace user accounts
        nodeUrl: "https://rpc.testnet.near.org", // this endpoint must point to the network you want to reach
        walletUrl: "http://wallet.testnet.near.org", // this endpoint must exist for the wallet to work
        deps: {
          keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(), // keys are stored as plaintext in LocalStorage
        },
      };

      // open a connection to the NEAR platform
      (async function () {
        window.near = await nearApi.connect(config); // connect to the NEAR platform
        window.wallet = new nearApi.WalletAccount(window.near); // instantiate a new wallet

        // ---------------------------------------------------------------------------
        // here you have access to `near-api-js` and a valid connection object `near`
        //
        // we've added them to the window object to make working in the console convenient
        // ---------------------------------------------------------------------------
      })(window);
    </script>
  </head>
  <body>
    <h2><code>near-api-js</code> client-side challenge</h2>

    To run through this demo you will need to open your
    <a href="https://javascript.info/devtools">JavaScript Developer Console</a
    ><br />
    <strong>(Press Cmd+Opt+J or, if youâ€™re on Windows, then F12)</strong>

    <blockquote>
      <em>
        "There are two ways to write error-free programs; only the third one
        works."<br />
        (Alan J. Perlis)
      </em>
    </blockquote>
  </body>
</html>

'''
'''--- challenges/client-side-authentication.md ---
# Challenge: Client-side Authentication with NEAR

In this challenge you will setup a simple playground in your browser that lets you connect to the NEAR network, authenticate using NEAR Wallet and interact with a small piece `near-api-js`

- [Setup your playground](#setup-your-playground)
- [Verify your setup](#verify-your-setup)
  - [Test 1: Do you you have a reference to near-api-js?](#test-1-do-you-you-have-a-reference-to-near-api-js)
  - [Test 2: Do you have a connection to the NEAR network?](#test-2-do-you-have-a-connection-to-the-near-network)
  - [Test 3: Do you have a reference to a wallet object?](#test-3-do-you-have-a-reference-to-a-wallet-object)
- [Sign in using NEAR Wallet](#sign-in-using-near-wallet)
- [Use the account](#use-the-account)

## Setup your playground

Open the file `challenges/apps/playground/index.html` in a browser

**Don't use the filesystem** (you should not see `file://` in the beginning of the URL in your browser)

- If you're using VSCode you can use the [LiveServer plugin](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) and right click on the `index.html` file to open with LiveServer
- If you prefer Node.js, the incantation is `npx serve .`
- If you prefer Python, the incantation is `python -m SimpleHTTPServer 8000`

## Verify your setup

Verify your playground is ready for maximum velocity fun -- try copying and pasting each of the following snippets into the browser's developer console:

### Test 1: Do you you have a reference to near-api-js?

Use `near-api-js` to generate a new keypair (no network connection is needed for this part)

```js
const keypair = nearApi.utils.KeyPair.fromRandom("ed25519");
console.log("public key: ", keypair.publicKey.toString());
console.warn("private key: ", keypair.secretKey);
```

**You'll know it worked** if you see a public key starting with `ed25519:` and a longer private key in the console.

```text
public key:   ed25519:2SNxoAeqRdmmSN4yxL7JwQgbmX7Xtw6ut59sEWn8LVTy
private key:  5RbTpitV6yDXji8i42S8tguM8kjBaye39gWoyYnvZHdYXjdkX3vvrXYh92hZ1tcKDNMT53EDugm82o
```

The private key appears yellow as a reminder to you that this is sensitive data. _Private keys are the source of truth in cryptographic identity schemes._

### Test 2: Do you have a connection to the NEAR network?

Try using `near-api-js` to inspect the state of the blockchain

```js
const networkStatus = await near.connection.provider.status();
const blockchainProgress = networkStatus.sync_info;
console.table(blockchainProgress);
```

You should see something like a table of key-value pairs including `latest_block_hash` and `latest_block_time`

### Test 3: Do you have a reference to a wallet object?

Try using it to confirm whether or not you are signed in.

```js
wallet.isSignedIn(); // => false
wallet.getAccountId(); // => ""
```

## Sign in using NEAR Wallet

Sign into NEAR Wallet right from your console

```js
// FYI, this is the method signature
// async requestSignIn(contractId: string, title: string, successUrl: string, failureUrl: string)
await wallet.requestSignIn(null, "near-api-js client-side challenge");
```

You should be immediately redirected to NEAR Wallet.

You'll know it worked when you land on the NEAR Wallet website, either being prompted to create a new account (if you've never logged into NEAR using the same web browser) or being prompted to authorize "near-api-js client-side challenge" on your account.

## Use the account

Explore the account state

```js
let account = await near.account(wallet.getAccountId());
let state = await account.state();
console.table(state);
```

And authorized apps

```js
let account = await near.account(wallet.getAccountId()); // this line is repeated here in case of browser refresh
let details = await account.getAccountDetails();
console.table(details.authorizedApps);
```

'''
'''--- challenges/managing-keys-with-near-shell.md ---
# Challenge: Managing keys with NEAR Shell

In this challenge you will authorize NEAR Shell to use to your (new or existing) account via NEAR Wallet.

Note that the pattern `<???>` is meant to represent the unique portion of your account name on the NEAR network to make this challenge easier to follow.

- [Challenge: Managing keys with NEAR Shell](#challenge-managing-keys-with-near-shell)
  - [Manage a single account](#manage-a-single-account)
    - [Login using NEAR Shell](#login-using-near-shell)
    - [Explore the account state](#explore-the-account-state)
    - [Explore the account access keys](#explore-the-account-access-keys)
  - [Manage sub-accounts](#manage-sub-accounts)
    - [Create a sub account](#create-a-sub-account)
    - [Deploy and test a contract](#deploy-and-test-a-contract)

## Manage a single account

Visit the [documentation for NEAR Shell](https://docs.near.org/docs/tools/near-cli) and install it locally.

_Using Gitpod?_

- This step is already done for you. You can jump to logging in.

```sh
npm i -g near-shell
```

### Login using NEAR Shell

Login with NEAR Shell to authorize it for `FullAccess` use with a new or existing NEAR account. You must create an account in this step if you don't already have one

_Using Gitpod?_

- Click **Open Preview** button (will appear in the middle of 3 blue buttons)

```sh
near login
```

Follow the prompts until you see something like this in your terminal

```text
Which account did you authorize for use with NEAR Shell?
Enter it here (if not redirected automatically):
Logged in as [ <???>.testnet ] with public key [ ed25519:Hyxp7i... ] successfully
```

At this point one of two things has happened depending on the contents of the folder where you ran `near login`.

**(A) If you were in a project** created using `create-near-app` for example ([see here for more details](https://docs.near.org/docs/quick-start/create-near-app)) then you will have a `neardev` subfolder with the private key providing full access to the account you just authorized for use with NEAR Shell

```text
neardev
â””â”€â”€ default
    â””â”€â”€ <???>.testnet.json
```

**(B) Otherwise** you will find a folder called `~/.near-credentials` in your home directory

```text
/Users/<???>/.near-credentials
â””â”€â”€ default
    â””â”€â”€ <???>.testnet.json
```

_Using Gitpod?_

Try the command `tree ~/.near-credentials/` to see your credentials

```
/home/gitpod/.near-credentials/
â””â”€â”€ default
    â””â”€â”€ <???>.testnet.json
```

### Explore the account state

_Using Gitpod?_
- Find and replace all instances of `<???>` on this page for a smooth workflow

_(These steps explore publicly available information for all accounts. We included them **after** login in case you just created a **new** account for yourself)_

View state on **any** account

```sh
near state <???>.testnet
```

You should see something like this, although your `block_height` and `block_hash` will be different

```js
{
  amount: '100000000000000000000000000',
  locked: '0',
  code_hash: '11111111111111111111111111111111',
  storage_usage: 182,
  storage_paid_at: 0,
  block_height: 2440833,
  block_hash: 'CU4ab5yAN5HYoakRDNiN4ERVRwYRNjiJaTGgrmkSF8yF',
  formattedAmount: '100'
}
```

If the account has a contract deployed to it, you will see a different `code_hash` that represents the sha256 digest of the contract Wasm code encoded as base58. See the file `bin/wasm-to-codehash` in this repository for Python code that calculates the code_hash given a path to a compiled contract file.

```js
{
  amount: '99999999948684219965170000',
  locked: '0',
  code_hash: '5KjqNZMPuZZoCuyYc1eHbBLCvCC9c1bh5NLvv3HsVcKH',  // <-- this will be different depending on the deployed contract
  storage_usage: 42513,                                       // <-- this includes deployed contract code and state stored by the account
  storage_paid_at: 0,
  block_height: 2440809,
  block_hash: '6kU6huk1YQ8SRNPVLTk71dFpDeg2sE9aWPH21HcWbzrR',
  formattedAmount: '99.99999994868421996517'
}
```

### Explore the account access keys

View access keys on **any** account

```sh
near keys <???>.testnet
```

You should see something like this representing an account with a single `FullAccess` key, the same one that NEAR Shell has been authorized to use and is now in your filesystem in either the local `neardev` folder or the global `~/.near-credentials` folder.

```js
[
  {
    public_key: "ed25519:GBut2CEV6wDmbeU4c6GjZjwZ52EepTSpiss72pfsG75g",
    access_key: { nonce: 0, permission: "FullAccess" },
  },
];
```

If the account was used to authorize an example app like Greeting or Counter available at http://near.dev then it will also have `FunctionCall` access keys

```js
[
  {
    public_key: "ed25519:CwSDTCU4HnpyqnphpWtjHSEYo16FaNZucWUs6Sgfy8Hn",
    access_key: { nonce: 0, permission: "FullAccess" },
  },
  {
    public_key: "ed25519:BNpJnLdbGY2PuXRL9jCxG6pzpLF1fR2iWcbuWymTDL37",
    access_key: {
      nonce: 0,
      permission: {
        // this is a restricted key for limited use by an application
        FunctionCall: {
          allowance: "10000000000000000000000",
          receiver_id: "null",
          method_names: [],
        },
      },
    },
  },
];
```

**A brief aside about `nonce` values**

In both examples of the access keys above, `FullAccess` keys and `FunctionCall` access keys, there is a `nonce` associated with each key which tracks how many times it has been used. This helps the NEAR runtime distinguish between transactions and avoid processing duplicate transactions. [See this page for more detail](https://nomicon.io/ChainSpec/Transactions.html#transaction-ordering-example-using-pool-iterator) about how NEAR uses `nonce` values.

## Manage sub-accounts

When working with contracts, you will create sub-accounts on your main account. These sub accounts are created using NEAR Shell

### Create a sub account

Let's create a new account that is controlled your main account. But let's do this in the context of deploying a contract

```bash
near create_account greeting.<???>.testnet --master-account <???>.testnet --helper-url https://helper.testnet.near.org
```

### Deploy and test a contract

**First build** one of the contracts from the root folder of the repository

```sh
yarn build greeting
```

**Then deploy** the contract

- We assume you already created `greeting.<???>.testnet` in a previous step

```text
near deploy --wasm-file out/greeting.wasm --account-id greeting.<???>.testnet
```

**Finally test** one of the contract methods: `sayMyName()`

```text
near call greeting.<???>.testnet sayMyName --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() was called
'Hello, <???>.testnet!'
```

**And cleanup** by deleting the contract account\*\*

```text
near delete greeting.<???>.testnet <???>.testnet
```

_Expected outcome_

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.
```

'''
'''--- challenges/realtime-monitoring-of-dapps.md ---
# Challenge: Realtime Monitoring of Contract State

In this challenge you will setup an interface to monitor the Guestbook example application. This challenge assumes the use of Gitpod but can be applied to any system that supports the commands included here. This challenge was testing on macOS and Gitpod.

- [Start with the Guestbook demo](#start-with-the-guestbook-demo)
- [Setup your monitors](#setup-your-monitors)
  - [Terminal (A)](#terminal-a)
  - [Terminal (B)](#terminal-b)

## Start with the Guestbook demo

1. Open http://near.dev and find the Guestbook demo (although this will work with any application on the NEAR platform)

2. Open the Guestbook example in Gitpod and let it settle

   - You may want to open the Guestbook interface in _Preview Mode_ when prompted since this provides a smooth experience for the steps that follow

3. Open 2 new terminals: (A) and (B), and arrange them side-by-side just above the bottom terminal, replacing the README (3 terminals all together)

```text
 +------------------------------------------------------------------+
 |                    |                   |                         |
 |                    |                   |                   Login |
 |                    |                   |                         |
 |     Terminal A     |     Terminal B    |                         |
 |                    |                   |        Guestbook        |
 |                    |                   |                         |
 |                    |                   |         open in         |
 |                    |                   |                         |
 |                    |                   |       Preview Mode      |
 |                    |                   |                         |
 |                    |                   |                         |
 +----------------------------------------+                         |
 |                                        |                         |
 |             Initial Terminal           |                         |
 |                                        |                         |
 +------------------------------------------------------------------+
```

4. `brew install httpie` (takes some time, several minutes)

5. `npm i -g near-shell` (if not already installed, check with `which near` in one of the terminals)

## Setup your monitors

In each of the 2 terminals, (A) and (B), run the following commands

### Terminal (A)

To view metadata for contract account and your own user account, first save the accounts to environment variables

```sh
MY_ACCOUNT=#<your new account>
CONTRACT_ACCOUNT=#<contract account>
```

And then use them in the following `watch` command (it refreshes twice per second and colorizes the changes between refreshes)

```
watch -d -c -n .5 "near state $MY_ACCOUNT; near state $CONTRACT_ACCOUNT"
```

### Terminal (B)

To view detailed contract state in real time

First save the contract account name to an environment variable

```sh
CONTRACT_ACCOUNT=#<contract account>
```

And then use it in the following `watch` command

```sh
watch -d -c -n .5 "http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query params:='{\"request_type\": \"view_state\", \"finality\": \"final\", \"account_id\": \"$CONTRACT_ACCOUNT\", \"prefix_base64\": \"\"}' | jq --color-output '.'"
```

If things are working, you should notice that everytime you add a message to the Guestbook, the contract state grows. Note that NEAR account state is encoded in `base64`.

## Notes

The `watch` command executes a program periodically, showing output fullscreen

```
Usage:
 watch [options] command

Options:
  -b, --beep             beep if command has a non-zero exit
  -c, --color            interpret ANSI color and style sequences
  -d, --differences[=<permanent>]
                         highlight changes between updates
  -e, --errexit          exit if command has a non-zero exit
  -g, --chgexit          exit when output from command changes
  -n, --interval <secs>  seconds to wait between updates
  -p, --precise          attempt run command in precise intervals
  -t, --no-title         turn off header
  -x, --exec             pass command to exec instead of "sh -c"

 -h, --help     display this help and exit
 -v, --version  output version information and exit

For more details see watch(1).
```

'''
'''--- contracts/01.greeting/README.md ---
## Design

### Interface

```ts
export function showYouKnow(): void;
```

- "View" function (ie. a function that does NOT alter contract state)
- Takes no parameters
- Returns nothing

```ts
export function sayHello(): string;
```

- View function
- Takes no parameters
- Returns a string

```ts
export function sayMyName(): string;
```

- "Call" function (although it does NOT alter state, it DOES read from `context`, [see docs for details](https://docs.near.org/docs/develop/contracts/as/intro))
- Takes no parameters
- Returns a string

```ts
export function saveMyName(): void;
```

- "Call" function (ie. a function that alters contract state)
- Takes no parameters
- Saves the sender account name to contract state
- Returns nothing

```ts
export function saveMyMessage(message: string): bool;
```

- Call function
- Takes a single parameter message of type string
- Saves the sender account name and message to contract state
- Returns nothing

```ts
export function getAllMessages(): Array<string>;
```

- View function
- Takes no parameters
- Reads all recorded messages from contract state (this can become expensive!)
- Returns an array of messages if any are found, otherwise empty array

**Notes**

- All of these methods append to the log for consistency

### Models

_This contract has no custom models_

_Using Gitpod?_

Please feel encouraged to edit any and all files in this repo while you explore. A reset of this environment is just a click away: just head back to the main `README` and reopen this workshop in Gitpod if you ever get stuck.

## Test

There are three classes of tests presented here:

- **Unit** tests exercise the methods and models of your contract
- **Simulation** tests provide fine-grained control over contract state, execution context and even network economics
- **Integration** tests get as close to production as possible with deployment to a local node, BetaNet or TestNet

We will explore each of these in turn.

### Unit Tests

Unit tests are written using [`as-pect`](https://github.com/jtenner/as-pect) which provides "blazing ðŸ”¥ fast testing with AssemblyScript".

To see unit tests for this contract run

```text
yarn test -f greeting.unit
```

You should see something like this (may be colorized depending on your terminal configuration)

```text
[Describe]: Greeting

 [Success]: âœ” should respond to showYouKnow()
 [Success]: âœ” should respond to sayHello()
 [Success]: âœ” should respond to sayMyName()
 [Success]: âœ” should respond to saveMyName()
 [Success]: âœ” should respond to saveMyMessage()
 [Success]: âœ” should respond to getAllMessages()

    [File]: 01.greeting/__tests__/greeting.unit.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: âœ” PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 6 pass,  0 fail, 6 total
    [Time]: 12.852ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: âœ” PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 6 pass, 0 fail, 6 total
    [Time]: 2350.078ms
âœ¨  Done in 3.01s.
```

You can explore the contents of `01.greeting/__tests__/greeting.spec.ts` for unit test details.

### Simulation Tests

There are two types of simulation tests we can expect to use:

- **`near-vm`** allows us to exercise contract methods inside an exact replica of the on-chain virtual machine
- **Runtime API** exposes interfaces for cross-contract calls and is compatible with popular testing frameworks

Only the first, using `near-vm`, will be addressed in depth here. It's key limitation is that we can only test one contract at a time, invoking methods, observing changes in state and getting a sense of the operating costs of the contract.

#### Simulation Testing with `near-vm`

Run the following commands to simulate calling the method `sayMyName` on this contract

1. First compile (or recompile after changes) the optimized `.wasm` file

   ```text
   yarn build greeting
   ```

2. Then run a simulation test

   ```text
   yarn test:simulate:vm:greeting --method-name sayMyName
   ```

You should see something like the following response

```text
{"outcome":{"balance":"10000000000000000000000000","storage_usage":100,"return_data":{"Value":"\"Hello, bob!\""},"burnt_gas":41812607821,"used_gas":41812607821,"logs":["sayMyName() was called"]},"err":null,"receipts":[],"state":{}}
âœ¨  Done in 1.75s.
```

Which can be reformatted for easier scanning

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 100,
    "return_data": {
      "Value": "\"Hello, bob!\""
    },
    "burnt_gas": 41812607821,
    "used_gas": 41812607821,
    "logs": ["sayMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {}
}
```

> **Notes**
>
> - The value in `return_data` is what we expect if our account name were "bob". But how did that get there? Run `near-vm --help` to see simulation options including control over contract state and execution context as well as network economics.
> - The amounts of `burnt_gas` and `used_gas` are the same, so why two different values? `used_gas` >= `burnt_gas` is always true. If ever a difference, it will be refunded back to the originating account. [See SO for more](https://stackoverflow.com/a/59146364).
> - The entry in `logs` is exactly what we would expect to see.
> - The contract `state` is empty.

Run the following command to simulate calling the method `saveMyName` on this contract

```text
yarn test:simulate:vm:greeting --method-name saveMyName
```

_(You only need to rebuild the contract if you've made changes)_

After reformatting, you should see something like the following response

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 149,
    "return_data": "None",
    "burnt_gas": 49055516114,
    "used_gas": 49055516114,
    "logs": ["saveMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {
    "c2VuZGVy": "Ym9i"
  }
}
```

> **Notes**
>
> - The absence of value in `return_data` since `saveMyName` has a return type of `void`.
> - The amount of `used_gas` is higher now, by about 7.2 billion units. This difference represents more compute time required to fetch an account name from the `context` object as well as reading and writing to storage
> - The entry in `logs` is exactly what we would expect to see.
> - This time the contract `state` is not empty. It has 1 entry, a `key : value` pair, that is encoded as Base64 and, when decoded looks like this: `{"sender":"bob"}`.

**A brief aside on decoding**

_Base Sixty What?_

Just like human languages encode our thoughts into spoken words and printed text, data is encoded in different formats on computer systems depending on the use case. If data is "at rest", say on a backup drive, it can be encoded using a compression algorithm for better storage efficiency. And when data is "in motion", say between machines over HTTP, base64 is a good choice since the data less likely to get corrupted during transfer.

The state "key" and "value" above were decoded using the code snippet below but we could just as easily have used a [website like this one](https://www.base64decode.org/).

```js
const key = "c2VuZGVy";
const value = "Ym9i";
const decodedKey = Buffer.from(key, "base64").toString("utf8");
const decodedValue = Buffer.from(value, "base64").toString("utf8");
console.log(decodedKey, decodedValue);
```

#### Simulation Testing with Runtime API

At a very high level, testing with the Runtime API allows us, using JavaScript, to create accounts for contracts, load them up with the Wasm binary, add user accounts and simulate their interaction.

To try this out:

1. **move to the _sample project_ folder** (where **this** `README.md` appears: `01.greeting/`)
2. run `yarn` inside that folder _(we will use Jest for this)_
3. run `yarn build` to build `greeting.wasm` locally (just as we did when browsing the `.wat` file earlier)
4. run `yarn test:simulate:runtime`

You should see something like

```text
 PASS  __tests__/greeting.simulate.spec.js
  Greeting
    View methods
      âœ“ responds to showYouKnow() (113ms)
      âœ“ responds to sayHello() (115ms)
      responds to getAllMessages()
        âœ“ works with 0 messages (133ms)
        âœ“ works with 1 message (229ms)
        âœ“ works with many messages (493ms)
    Call methods
      âœ“ responds to sayMyName() (128ms)
      âœ“ responds to saveMyName() (113ms)
      âœ“ responds to saveMyMessage() (106ms)
    Cross-contract calls()
      âœŽ todo add cross contract call examples

Test Suites: 1 passed, 1 total
Tests:       1 todo, 8 passed, 9 total
Snapshots:   0 total
Time:        3.313s
Ran all test suites matching /simulate.spec/i.
âœ¨  Done in 9.88s.
```

Feel free to explore the file `__tests__/greeting.simulate.spec.js` for details.

**A brief aside on contracts and accounts**

You may have noticed that the words `contract` and `account` are sometimes interchangeable. This is because NEAR accounts can only hold zero or one contracts while a contract can be deployed to multiple accounts.

In the previous sections, since we were only testing and simulating and had not deployed anything to the network, the words `contract` and `account` were basically the same, although you may have already noticed this distinction if you took a close look at the `simulate.spec` file a moment ago.

In the next section about integration tests where we will be working with a live network, the distinction between **contract accounts** vs. **user accounts** will become useful and important.

We will deploy the contract to a specific account (ie. the contract account) on the network (ie. TestNet) and call contract methods from a **different** account (ie. our user account).

You can read more about [accounts on NEAR Protocol here](https://docs.near.org/docs/concepts/account).

### Integration Tests

There are two types of integration tests we can expect to use:

- **NEAR Shell** serves as a console Swiss army knife with the ability to manage accounts, contracts and more
- **`near-api-js`** (our JavaScript API) wraps the NEAR JSON RPC API and exposes NEAR Wallet authentication

Only the first, using NEAR Shell, will be addressed here in any depth. Its key limitation is that we cannot orchestrate cross-contract calls.

We will use NEAR Shell to login to our own user account and then use it again to create a new account for our contract before we deploy, verify, and invoke methods on the contract. Finally, we will delete the contract account to clean up after ourselves. We will rely on other tools like [NEAR Explorer](https://explorer.near.org/) for transaction visibility, history and more.

#### Integration Tests with NEAR Shell

**HEADS UP** -- if this is your first time using NEAR Shell to deploy a contract to TestNet, this may feel like a long and confusing process but once you've done it 3 times, it should only take about a minute from end to end and can be automated in a shell script.

But first the tldr; for anyone who wants to start running before they walk.

---

**tldr;**

We use the symbol `<???>` to represent text that is **unique to your account name**, whatever that is (or will be when you make it up). After this brief list of steps, each of these commands is described in greater detail including expected output and possible errors.

Note that all of this happening **on the command line.**

**(0) Confirm NEAR Shell is installed**

```text
near --version
```

_Expected output_

```text
0.21.0    (or any higher version number)
```

**(1) Authorize NEAR Shell to use your account**

- You must create an account in this step if you don't already have one
- _Using Gitpod?_
  - Click **Open Preview** button (will appear in the middle of 3 blue buttons)

```text
near login
```

**(2) Create an account for the contract**

- By design there is a limit of max 1 contract per account
- Account names follow a pattern similar to DNS
- We assume you already created `<???>.testnet` in the previous step

```text
near create_account greeting.<???>.testnet --master-account <???>.testnet --helper-url https://helper.testnet.near.org
```

_Expected output_

```text
Account greeting.<???>.testnet for network "default" was created.
```

**(3) Build the contract**

- The Wasm file will appear as `out/greeting.wasm`
- To silence metrics reporting during compilation, comment out all (2) instances of `"--measure"` in the file `asconfig.js`

```text
yarn build greeting
```

_Expected output_

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
```

**(4) Deploy the contract to the contract account**

- We assume you already created `greeting.<???>.testnet` in a previous step

```text
near deploy --wasm-file out/greeting.wasm --account-id greeting.<???>.testnet
```

_Expected output_

```text
Starting deployment. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: out/greeting.wasm
```

**(5) Verify deployment of the correct contract to the intended**

- The account name `greeting.<???>.testnet` should match the intended contract account
- The value of `code_hash` should match _exactly_ (starting with `63tSDQ...`) **unless the contract code has changed**, in which case it will almost certainly be different.
- Other values in this response are unlikely to match

```text
near state greeting.<???>.testnet
```

_Expected output_

```text
Account greeting.<???>.testnet
```

```json
{
  "amount": "99999999949722583262485000",
  "locked": "0",
  "code_hash": "63tSDQc9K5Nt9C8b1HDkv3VBnMFev9hXB589dZ9adsKA",
  "storage_usage": 14912,
  "storage_paid_at": 0,
  "block_height": 2048367,
  "block_hash": "AbYg6aAbv4e1h2rwKG2vMsWphXm27Ehhde6xUKYzYjsT",
  "formattedAmount": "99.999999949722583262485"
}
```

**(6) For each method of the contract, test it and observe the response**

- _Using Gitpod?_
  - Replace all instances of `<???>` to make the lines below match your new account for a smooth workflow

**Test `showYouKnow()`**

```text
near view greeting.<???>.testnet showYouKnow
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.showYouKnow()
[greeting.<???>.testnet]: showYouKnow() was called
false
```

**Test `sayHello()`**

```text
near view greeting.<???>.testnet sayHello
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.sayHello()
[greeting.<???>.testnet]: sayHello() was called
'Hello!'
```

**Test `sayMyName()`**

```text
near call greeting.<???>.testnet sayMyName --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() was called
'Hello, <???>.testnet!'
```

**Test `saveMyName()`**

```text
near call greeting.<???>.testnet saveMyName --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyName()
[greeting.<???>.testnet]: saveMyName() was called
''
```

**Test `saveMyMessage()`**

```text
near call greeting.<???>.testnet saveMyMessage '{"message": "bob? you in there?"}' --accountId <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyMessage({"message": "bob? you in there?"})
[greeting.<???>.testnet]: saveMyMessage() was called
true
```

**Test `getAllMessages()`**

```text
near call greeting.<???>.testnet getAllMessages --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.getAllMessages()
[greeting.<???>.testnet]: getAllMessages() was called
[ '<???>.testnet says bob? you in there?' ]
```

**(7) Cleanup by deleting the contract account**

```text
near delete greeting.<???>.testnet <???>.testnet
```

_Expected outcome_

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.

```

**END tldr;**

For more support using the commands above, see [help with NEAR Shell integration tests](near-shell-help.md).

#### Integration Tests with `near-api-js`

`near-api-js` is a JavaScript / TypeScript library for development of dApps on the NEAR platform that can be used from any client or server-side JavaScript environment.

For context, it's worth knowing that the core NEAR platform API is a JSON-RPC interface. `near-api-js` wraps this RPC interface with convenience functions and exposes NEAR primitives as first class JavaScript objects.

We use `near-api-js` internally in tools like NEAR Shell and NEAR Wallet.

You would use `near-api-js` as your primary interface with the NEAR platform anytime you are writing JavaScript (client or server-side).

See our [documentation for more details](https://docs.near.org/docs/develop/front-end/introduction).

'''
'''--- contracts/01.greeting/__tests__/greeting.simulate.spec.js ---
const {
  Runtime
} = require("near-sdk-simulator")
const path = require("path");

const WASM_FILE = path.join(__dirname, "/../../../out/debug/01.greeting.wasm");

describe("Greeting ", () => {
  const users = ["alice", "bob", "carol"];
  const messages = ["awesomesauce!", "yashilsin!", "beleza!"];

  let runtime;
  let greeting;

  beforeAll(() => {
    runtime = new Runtime();
    greeting = runtime.newAccount("greeting", WASM_FILE);

    accounts = users
      .map((name) => runtime.newAccount(name))
      .reduce((acc, user) => {
        acc[user.account_id] = user;
        return acc;
      }, {});
  });

  afterEach(() => {
    greeting.state = {};
  });

  describe("View methods", () => {
    it("responds to showYouKnow()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "showYouKnow",
        },
      };

      const {
        result
      } = simulate(transaction);

      expectToFind("showYouKnow() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to sayHello()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "sayHello",
        },
      };

      const {
        result,
        data
      } = simulate(transaction);

      expect(data).toEqual("Hello!");
      expectToFind("sayHello() was called", {
        inArray: result.outcome.logs,
      });
    });

    describe("responds to getAllMessages()", () => {
      it("works with 0 messages", () => {
        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        const {
          result,
          data
        } = simulate(transaction);

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with 1 message", () => {
        sendMessage(accounts.alice, {
          message: messages[0]
        });

        const transaction = {
          signer: accounts.alice,
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const {
          result,
          data
        } = simulate(transaction);

        expectToFind("alice says awesomesauce!", {
          inArray: data,
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with many messages", () => {
        let expectedMessages = [];

        Object.keys(accounts).map((user, idx) => {
          let signer = accounts[user];
          let message = messages[idx];

          sendMessage(signer, {
            message
          });
          expectedMessages.push(`${signer.account_id} says ${message}`);
        });

        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const {
          result,
          data
        } = simulate(transaction);

        expectedMessages.map((message) => {
          expectToFind(message, {
            inArray: data,
          });
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });
    });
  });

  describe("Call methods", () => {
    it("responds to sayMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "sayMyName",
        },
      };

      const {
        data,
        result
      } = simulate(transaction);

      expect(data).toEqual(`Hello, ${accounts.alice.account_id}!`);
      expectToFind("sayMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyName",
        },
      };

      const {
        result
      } = simulate(transaction);

      // "c2VuZGVy" is " in base64
      // "YWxpY2U=" is "alice" in base64
      expect(result.state).toHaveProperty("sender", "alice");

      expectToFind("saveMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyMessage()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyMessage",
          params: {
            message: "awesomesauce"
          },
        },
      };

      const {
        data,
        result
      } = simulate(transaction);

      expect(data).toBeTruthy();

      // "bWVzc2FnZXM6Oi0x" is  in base64
      // "YWxpY2Ugc2F5cyBhd2Vzb21lc2F1Y2Uh" is "alice says awesomesauce" in base64
      expect(result.state).toHaveProperty(
        "messages::-1",
        "alice says awesomesauce"
      );

      expectToFind("saveMyMessage() was called", {
        inArray: result.outcome.logs,
      });
    });
  });

  // ---------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------

  function sendMessage(signer, params) {
    const transaction = {
      signer,
      contract: greeting,
      method: {
        type: "view",
        name: "saveMyMessage",
        params,
      },
    };

    const {
      data
    } = simulate(transaction);

    expect(data).toBeTruthy();
  }

  function expectToFind(target, {
    inArray
  }) {
    if (inArray) {
      expect(inArray).toEqual(expect.arrayContaining([target]));
    }
  }

  function simulate({
    signer,
    contract,
    method
  }, printResponse = false) {
    let response;

    if (signer) {
      response = signer.call_other(
        contract.account_id,
        method.name,
        method.params
      );
    } else {
      response = contract[method.type](method.name, method.params);
    }

    if (printResponse) {
      console.log("\n\n------ Near VM Response ------");
      console.log(JSON.stringify(response, null, 2));
    }

    return {
      data: response.return_data,
      error: response.err,
      result: response.result,
      results: response.results,
      calls: response.calls,
    };
  }

  function getContext() {
    return {
      input: "{}",
      output_data_receivers: [],
      prepaid_gas: 10 ** 15,
      attached_deposit: "0",
      is_view: false,
      block_index: 1,
      block_timestamp: 1585778575325000000,
      epoch_height: 1,
      storage_usage: 100,
      random_seed: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      current_account_id: "alice",
      signer_account_id: "alice",
      predecessor_account_id: "bob",
      account_balance: "1000",
      signer_account_pk: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      account_locked_balance: "10",
    };
  }
});

'''
'''--- contracts/01.greeting/__tests__/greeting.unit.spec.ts ---
import {
  showYouKnow,
  sayHello,
  sayMyName,
  saveMyName,
  saveMyMessage,
  getAllMessages,
} from "../assembly";
import { storage, PersistentDeque, VMContext, VM } from "near-sdk-as";

const contract = "greeting";
const alice = "alice";
const bob = "bob";
const carol = "carol";
const message1 = "awesomesauce!";
const message2 = "yashilsin!";
const message3 = "beleza!";

let messages: PersistentDeque<string>;

describe("01. Greeting", () => {
  beforeEach(() => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(alice);
    messages = new PersistentDeque<string>("messages");
  });

  it("should respond to showYouKnow()", () => {
    showYouKnow();
    expect(showYouKnow).not.toThrow();
    expect(VM.logs()).toContainEqual("showYouKnow() was called");
  });

  it("should respond to sayHello()", () => {
    expect(sayHello()).toStrictEqual("Hello!");
    expect(VM.logs()).toContainEqual("sayHello() was called");
  });

  it("should respond to sayMyName()", () => {
    expect(sayMyName()).toStrictEqual("Hello, " + alice + "!");
    expect(VM.logs()).toContainEqual("sayMyName() was called");
  });

  it("should respond to saveMyName()", () => {
    expect(saveMyName).not.toThrow();
    expect(storage.getString("sender")).toStrictEqual(alice);
    expect(VM.logs()).toContainEqual("saveMyName() was called");

    // as-pect requires that we restore contract state between tests in the same file
    storage.delete("sender");
  });

  it("should respond to saveMyMessage()", () => {
    const expected = alice + " says " + message1;
    expect(saveMyMessage(message1)).toBeTruthy();
    expect(messages.first).toStrictEqual(expected);
    expect(VM.logs()).toContainEqual("saveMyMessage() was called");

    // as-pect requires that we restore contract state between tests in the same file
    messages.popFront();
  });

  it("should respond to getAllMessages()", () => {
    messages.pushFront(message1);
    messages.pushFront(message2);
    messages.pushFront(message3);

    const output = getAllMessages();
    expect(output).toHaveLength(3);
    expect(messages).toHaveLength(0);

    expect(VM.logs()).toContainEqual("getAllMessages() was called");

    // as-pect requires that we restore contract state between tests in the same file
    while (!messages.isEmpty) {
      messages.popBack();
    }
  });
});

'''
'''--- contracts/01.greeting/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "options": {
    "measure": true
  }
}

'''
'''--- contracts/01.greeting/assembly/index.ts ---
import { context, logging, storage, PersistentDeque } from "near-sdk-as";

/**
 * showYouKnow is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function showYouKnow(): void {
  logging.log("showYouKnow() was called");
}

/**
 * saveMyName is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyName(): void {
  logging.log("saveMyName() was called");

  storage.setString("sender", context.sender);
}

/**
 * saveMyMessage is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name and message to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyMessage(message: string): bool {
  logging.log("saveMyMessage() was called");

  assert(message.length > 0, "Message can not be blank.");
  const messages = new PersistentDeque<string>("messages");
  messages.pushFront(context.sender + " says " + message);

  return true;
}

/**
 * getAllMessages is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - reads all recorded messages from contract state (this can become expensive!)
 * - and returns an array of messages if any are found, otherwise empty array
 *
 * - it has the side effect of appending to the log
 */
export function getAllMessages(): Array<string> {
  logging.log("getAllMessages() was called");

  const messages = new PersistentDeque<string>("messages");
  let results = new Array<string>();

  while (!messages.isEmpty) {
    results.push(messages.popBack());
  }

  return results;
}

'''
'''--- contracts/01.greeting/near-shell-help.md ---
To use NEAR Shell you'll first need to install it. Please refer to the [documentation](https://docs.near.org/docs/tools/near-cli).

Make sure you're in this folder then login to NEAR Shell and authorize it to use your account.

```
near login
```

A webpage will open to NEAR Wallet where you can create an account (if you don't already have one) and authorize NEAR Shell to use this account (by giving it a `FullAccess` key). If you're on a Windows computer you will need to copy and paste the link from your console into your browser.

The result of logging in will look something like this (it may also be colorized depending on your terminal).

```text
Please authorize NEAR Shell on at least one of your accounts.

If your browser doesn't automatically open, please visit this URL
https://wallet.testnet.near.org/login/?title=NEAR+Shell&public_key=ed25519%3A3KHz9owcKkcx9Q4P8VNCYyhXHaHJNjjxCadMx26CDTxB&success_url=http%3A%2F%2F127.0.0.1%3A5000
Please authorize at least one account at the URL above.

Which account did you authorize for use with NEAR Shell?
Enter it here (if not redirected automatically):
Logged in as [ <???>.testnet ] with public key [ ed25519:3KHz9o... ] successfully
```

If you check your filesystem you should see a new folder structured like this. Your private keys are in the JSON file so don't share that or commit it to a repo or **you risk losing control of your account** to anyone that finds it. This repository ignores all `neardev/` folders by default.

```text
neardev
â””â”€â”€ default
    â””â”€â”€ <???>.testnet.json
```

Whether you created a new account or used an existing one, you can always check the state of the account using NEAR SHell as well

```
near state <your account name>
```

This should report something like the following

```json
Account <???>.testnet
{
   "amount":"100000000000000000000000000",
   "locked":"0",
   "code_hash":"11111111111111111111111111111111",
   "storage_usage":182,
   "storage_paid_at":0,
   "block_height":2009726,
   "block_hash":"AmEJfazX6vb3LLKeQtPXUGyXto7V9SaGoU4AYRxY8MNe",
   "formattedAmount":"100"
}
```

**Notice**

- the value of `amount` is the number of NEAR tokens this account controls in a vanishingly small unit of measurement called yoctoNEAR (10^-24) (you will also notice that `formattedAmount` has brought the amount back down to a human friendly format).
- the value of `code_hash` will be all `1`s if this is an account with NO contract, otherwise this hash will be a fingerprint of the contract code (you can use this hash to check whether a contract is already deployed to an account, for example)
- the value of `storage_usage` will change depending on the size of a deployed contract (which consumes account state) and data in storage.

Having logged into NEAR Shell and verified your account state, we can now use this authorized account to create a _new account_ on the network just for the contract we want to test. We will also delete this account once we've finished testing with it.

---

> _A brief word about working with accounts_
>
> _To avoid counterproductive confusion, read this part carefully. You must make a few choices here before running this in your terminal._
>
> _Your current account is `<???>.testnet` -- this is the account you just authorized using NEAR Shell_
>
> _NEAR account names are scoped (like DNS for the web) so you can create any "sub-names" by prepending anything you like to your account name._
>
> _We're about to create an account for your contract named `greeting.<???>.testnet`._

```text
near create_account <CONTRACT ACCOUNT> --master-account <YOUR ACCOUNT> --helper-url https://helper.testnet.near.org
```

If your account was `bob.testnet` then the contract account would be `greeting.bob.testnet`.

```text
near create_account greeting.bob.testnet --master-account bob.testnet --helper-url https://helper.testnet.near.org
```

For this to work you must have already authorized NEAR Shell with `FullAccess` rights to the account listed after `--master-account` in the command above.

**If it works**, this should report something like the following

```text
Account greeting.<???>.testnet for network "default" was created.
```

**If it fails**, this will most likely report one of the following 3 errors:

(1) The `--master-account` **doesn't exist on the network**. To resolve, fix the account name.

```text
Server error: account <???> does not exist while viewing
```

(2) The `--master-account` **is not authorized for use by NEAR Shell**. To resolve, `near login` again.

```text
TypedError: Can not sign transactions for account <???>, no matching key pair found in Signer.
```

(3) The account named `<???>` already exists on the network. To resolve, either rename the account or recognize that you may have run this command twice, in which case, don't worry, be happy, you're ready to move on.

```text
AccountAlreadyExists [Error]: Can't create a new account <???>, because it already exists
```

---

At this point the contract should be deployed to the account `greeting.<???>.testnet`. Let's confirm

```
near state greeting.<???>.testnet
```

**If it works**, this should report something like the following

Account greeting.<???>.testnet

```json
{
  "amount": "100000000000000000000000000",
  "locked": "0",
  "code_hash": "11111111111111111111111111111111",
  "storage_usage": 182,
  "storage_paid_at": 0,
  "block_height": 2013415,
  "block_hash": "9cYMm5NtQ37RZDuHZKwCXKqKdsmLfMRuxtxoGGkfcXuZ",
  "formattedAmount": "100"
}
```

**If it fails** then take a minute to carefully create the contract account because it's required to move on.

Since the account is created we can compile and deploy the contract like this

```text
yarn build greeting
```

Which should report something like this

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
```

And then

```text
near deploy --wasm-file ./out/greeting.wasm --account-id greeting.<???>.testnet

```

Which should report something like this

```text
Starting deployment. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: ./out/greeting.wasm
```

And we can check the contract account state again to see if we've deployed it correctly.

Account greeting.<???>.testnet

```json
{
  "amount": "99999999983957639545840000",
  "locked": "0",
  "code_hash": "EiYRuKQaJtc61Rm7rffGqY4B4rEhNaCyz1VxLYAUq8oE",
  "storage_usage": 6415,
  "storage_paid_at": 0,
  "block_height": 2014205,
  "block_hash": "hSjzKCUsiuU6niEdFFoAwbLswUs5d55vaaHX4DRR46H",
  "formattedAmount": "99.99999998395763954584"
}
```

**Notice**

- the `account` balance went from 100 NEAR tokens to 99 tokens and change (deploying the contract cost a small amount of tokens (1.6 ^ 16 yoctoNEAR) to purchase the gas for processing the `DeployContract` action included in the deployment transaction.
- unless the contract code changed since time of writing, the `code_hash` in your output should start with `EiYRuK...`, matching the one in the snippet above. Recall this is like a contract fingerprint which can be used to verify if a contract has been deployed to an account.
- `storage_used` has increased from 182 to 6246 since we're not only storing the name of the account now but also the contract deployed to it

And now that the contract is deployed we can test it out (remember to replace `<???>` so both account names below match your own)

```text
near call greeting.<???>.testnet sayMyName --account-id <???>.testnet --gas 10000000000000000000
```

Which should report something like

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() function was called
'Hello, <???>.testnet!'
```

If it fails it will most likely be one of the following errors

(1) The amount of NEAR attached to the call isn't enough to pay for the gas to process the transaction

```text
Exceeded the prepaid gas
```

(2) The network connection times out. To resolve, use a local node or switch to another network. It may happen that the transaction eis actually processed even though this error is reported. Compare current and previous account balance and note if any gas was consumed by this call (the difference between `amount` values will be on the order of hundreds of millions)

```text
Server error: Timeout
```

Testing the other method in this contract follows exactly the same process but we will also notice a change in the state of the contract as the signing account `<???>.testnet` is stored in contract state.

```text
near call greeting.<???>.testnet saveMyName --account-id <???>.testnet --gas 10000000000000000000
```

And finally let's delete the contract account to cleanup. This step is optional of course.

The format of this call is as follows where `<BENEFICIARY ACCOUNT>` is the account that will receive the balance of `amount` tokens in the deleted account.

```text
near delete greeting.<???>.testnet <BENEFICIARY ACCOUNT>
```

So this will clean up our work here

```text
near delete greeting.<???>.testnet <???>.testnet
```

Which should report something like

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.
```

'''
'''--- contracts/02.counter/__tests__/counter.unit.spec.ts ---
import {
  getCounter,
  resetCounter,
  incrementCounter,
  decrementCounter,
} from "../assembly";

import { context, storage, VM, VMContext } from "near-sdk-as";

describe("02. Counter ", () => {
  beforeEach(() => {
    VMContext.setCurrent_account_id("eve");
  });

  it("should increment by one", () => {
    incrementCounter(1);
    expect(getCounter()).toBe(
      1,
      "counter should be one after a single increment."
    );
  });

  it("getCounter is the same as reading from storage", () => {
    expect(storage.getPrimitive<i32>("counter", 0)).toBe(
      getCounter(),
      'storage.getPrimitive<i32>("counter", 0) == getCounter()'
    );
  });

  it("should decrement by one", () => {
    incrementCounter(1);
    decrementCounter(1);
    expect(getCounter()).toBe(
      0,
      "counter should be zero after a single decrement."
    );
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 0");
  });

  it("should be resetable", () => {
    incrementCounter(1);
    incrementCounter(1);
    resetCounter(); // reset to zero
    expect(getCounter()).toBe(0, "counter should be zero after it is reset.");
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 2");
    expect(VM.logs()).toContainEqual("Counter is reset!");
  });

  it("should increment multiple times and decrement back to zero", () => {
    incrementCounter(1);
    expect(getCounter()).toBe(1, "0 + 1 = 1");
    incrementCounter(3);
    expect(getCounter()).toBe(4, "1 + 3 = 4");
    decrementCounter(4);
    expect(getCounter()).toBe(0, "4 - 4 = 0");
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 4");
    expect(VM.logs()).toContainEqual("Counter is now: 0");
  });

  it("should be eve's account", () => {
    expect(context.contractName).toBe("eve");
  });
});

'''
'''--- contracts/02.counter/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- contracts/02.counter/assembly/index.ts ---
import { storage, logging } from "near-sdk-as";

// --- contract code goes below

export function incrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) + value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter.toString());
}

export function decrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) - value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter.toString());
}

export function getCounter(): i32 {
  return storage.getPrimitive<i32>("counter", 0);
}

export function resetCounter(): void {
  storage.set<i32>("counter", 0);
  logging.log("Counter is reset!");
}

'''
'''--- contracts/03.guestbook/__tests__/guestbook.unit.spec.ts ---
import { addMessage, getMessages } from "../assembly";
import { PostedMessage, messages } from "../assembly/model";

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

function clearMessages(): void {
  while (messages.length > 0) {
    messages.pop();
  }
}

const hello: string = "hello world";
const message = createMessage(hello);

describe("03. Guestbook", () => {
  beforeEach(() => {
    addMessage(hello);
  });

  afterEach(() => {
    clearMessages();
  });

  it("should add a message", () => {
    expect(messages.length).toBe(1, "should only contain one message");
    expect(messages[0]).toStrictEqual(
      message,
      'message should be "hello world"'
    );
  });

  it("should retrieve messages", () => {
    const messages = getMessages();
    expect(messages.length).toBe(1, "should be one message");
    expect(messages).toIncludeEqual(
      message,
      "messages should include:\n" + message.toJSON()
    );
    // log(messages[0])
  });

  it("should only show the last ten messages", () => {
    const newMessages: PostedMessage[] = [];
    for (let i: i32 = 0; i < 10; i++) {
      const text = "message #" + i.toString();
      newMessages.push(createMessage(text));
      addMessage(text);
    }
    const messages = getMessages();
    // log(messages.slice(7, 10))
    expect(messages).toStrictEqual(
      newMessages,
      "should be the last ten mesages"
    );
    expect(messages).not.toIncludeEqual(
      message,
      "shouldn't contain the first element"
    );
  });
});

'''
'''--- contracts/03.guestbook/__tests__/posted-message.unit.spec.ts ---
import { PostedMessage } from "../assembly/model";
import { u128, VMContext } from "near-sdk-as";

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

const alice = "alice";
const hello: string = "hello world";
let message: PostedMessage;

describe("03. Guestbook :: PostedMessage", () => {
  it("should allow instantiation", () => {
    message = createMessage(hello);
    expect(message instanceof PostedMessage).toBeTruthy();
  });

  it("should record sender automatically", () => {
    VMContext.setSigner_account_id(alice);

    message = createMessage(hello);
    expect(message.sender).toStrictEqual(alice);
  });

  it("should allow for premium messages", () => {
    VMContext.setSigner_account_id(alice);
    VMContext.setAttached_deposit(u128.from("10000000000000000000000"));

    message = createMessage(hello);
    expect(message.premium).toBeTruthy();
  });
});

'''
'''--- contracts/03.guestbook/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- contracts/03.guestbook/assembly/index.ts ---
import { PostedMessage, messages } from "./model";

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const MESSAGE_LIMIT = 10;

/**
 * Adds a new message under the name of the sender's account id.\
 * NOTE: This is a change method. Which means it will modify the state.\
 * But right now we don't distinguish them with annotations yet.
 */
export function addMessage(text: string): void {
  // Creating a new message and populating fields with our data
  const message = new PostedMessage(text);
  // Adding the message to end of the the persistent collection
  messages.push(message);
}

/**
 * Returns an array of last N messages.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 */
export function getMessages(): PostedMessage[] {
  const numMessages = min(MESSAGE_LIMIT, messages.length);
  const startIndex = messages.length - numMessages;
  const result = new Array<PostedMessage>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = messages[i + startIndex];
  }
  return result;
}

'''
'''--- contracts/03.guestbook/assembly/model.ts ---
import { context, u128, PersistentVector } from "near-sdk-as";
 
/** 
 * Exporting a new class PostedMessage so it can be used outside of this file.
 */
@nearBindgen
export class PostedMessage {
  premium: boolean;
  sender: string;
  constructor(public text: string) {
    this.premium = context.attachedDeposit >= u128.from('10000000000000000000000');
    this.sender = context.sender;
  }
}
/** 
 * collections.vector is a persistent collection. Any changes to it will
 * be automatically saved in the storage.
 * The parameter to the constructor needs to be unique across a single contract.
 * It will be used as a prefix to all keys required to store data in the storage.
 */
export const messages = new PersistentVector<PostedMessage>("m");
'''
'''--- contracts/04.cross-contract-calls/__tests__/cross-contract-calls.simulate.spec.js ---
const {
  Runtime,
  encodeBs64
} = require("near-sdk-simulator");
const path = require("path");

const sentencesWasm = path.join(__dirname, "/../../../out/debug/sentences.wasm");
const wordsWasm = path.join(__dirname, "/../../../out/debug/words.wasm");

let runtime, alice, sentences, words;

describe("cross contract calls", () => {
  beforeEach(() => {
    runtime = new Runtime();
    alice = runtime.newAccount("alice");
    sentences = runtime.newAccount("sentences", sentencesWasm);
    words = runtime.newAccount("words.examples", wordsWasm);
  });

  function addWord(text) {
    return alice.call_other("sentences", "SetWord", {
      word: {
        text
      },
    });
  }

  test("single promise", () => {
    let res = alice.call_other("sentences", "reverseWordOne");
    expect(res.return_data.text).toBe("elpmas");
  });

  test("promise + then with no arguments", () => {
    let res = alice.call_other("sentences", "reverseWordTwo");
    expect(res.return_data).toBe(true);
  });
  test("promise + then with arguments", () => {
    let res = alice.call_other("sentences", "reverseWordThree");
    expect(res.return_data).toBe(true);
  });

  test("add to storage", () => {
    addWord("hello");
    expect(sentences.storage_usage).toBeGreaterThan(0);
  });

  test("read from storage with default", () => {
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("DEFAULT");
    expect(sentences.state["word"]).toBe(undefined);
  });
  test("read from storage", () => {
    addWord("hello");
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("hello");
    expect(sentences.state["word"]).toStrictEqual(word);
  });

  test("setting state", () => {
    let state = {
      word: {
        lang: "en-us",
        text: "hello"
      }
    };
    sentences.state = state;
    sentences.reset();
    let {
      result
    } = addWord("hello");
    expect(result.state).toStrictEqual(state);
  });
});

'''
'''--- contracts/04.cross-contract-calls/assembly/sentences/__tests__/sentences.unit.spec.ts ---
import { reverseWordOne, reverseWordTwo, reverseWordThree } from "..";
// import { VMContext, VM } from "near-sdk-as";

describe("04.  Cross-Contract Calls :: Sentences", () => {
  it("should reverse a sentence (one)", () => {
    reverseWordOne();
    // log(VM.outcome());
    // log(VM.logs());
  });

  it("should reverse a sentence (two)", () => {
    reverseWordTwo();
    // log(VM.outcome());
    // log(VM.logs());
  });

  it("should reverse a sentence (three)", () => {
    reverseWordThree();
    // log(VM.outcome());
    // log(VM.logs());
  });
});

'''
'''--- contracts/04.cross-contract-calls/assembly/sentences/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "index.ts"
}

'''
'''--- contracts/04.cross-contract-calls/assembly/sentences/index.ts ---
import { context, logging, ContractPromise, u128, storage } from "near-sdk-as";
import { Word } from "../words/model";

export function SetWord(word: Word): void {
  storage.set("word", word);
}

export function GetWord(): Word {
  return <Word>storage.get<Word>("word", new Word("DEFAULT"));
}

export function sample(): string {
  return "hello world";
}

export function reverseWordThree(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs, // serialized contract method arguments encoded as Uint8Array
    10000000, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  // Setting up args for the callback
  let responseArgs = new ReverseArgs(new Word("elpmas"));
  logging.log(responseArgs);
  let args = responseArgs;

  logging.log(context.contractName);
  let methodName = "_onReverseCalledThree";

  let callbackPromise = promise.then(context.contractName, methodName, args, 2);

  callbackPromise.returnAsResult();
}

export function _onReverseCalledThree(word: Word): bool {
  const drow = word;
  let results = ContractPromise.getResults();
  assert(results.length > 0, "should be contract promise result");
  let reverseResult = results[0];
  // logging.log(results[0]);
  // Verifying the remote contract call succeeded.
  if (reverseResult.status == 1) {
    // Decoding data from the bytes buffer into the local object.
    let word = decode<Word>(reverseResult.buffer);
    logging.log(word);
    return word.text == drow.text;
  }

  return false;
}

export function reverseWordTwo(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs.encode(), // serialized contract method arguments encoded as Uint8Array
    10000000, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  // Setting up args for the callback
  // let responseArgs = new ReverseArgs(new Word("elpmas"))

  logging.log(context.contractName);

  let callbackPromise = promise.then(
    context.contractName,
    "_onReverseCalledTwo",
    new Uint8Array(0),
    2
  );

  callbackPromise.returnAsResult();
}

export function _onReverseCalledTwo(): bool {
  const drow = new Word("elpmas");
  let results = ContractPromise.getResults();
  assert(results.length > 0, "should be contract promise result");
  let reverseResult = results[0];
  // Verifying the remote contract call succeeded.
  if (reverseResult.status == 1) {
    // Decoding data from the bytes buffer into the local object.
    let word = decode<Word>(reverseResult.buffer);
    logging.log(word);
    return word.text == drow.text;
  }

  return false;
}

export function reverseWordOne(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs, // serialized contract method arguments encoded as Uint8Array
    0, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  promise.returnAsResult();
}

@nearBindgen
class ReverseArgs {
  constructor(public word: Word) {}
}

'''
'''--- contracts/04.cross-contract-calls/assembly/words/__tests__/words.unit.spec.ts ---
import { reverse, upcase } from "..";
import { Word } from "../model";
import { VMContext, VM } from "near-sdk-as";

const alice: string = "alice";

let text: string;
let lang: string;
let word: Word;

describe("04.  Cross-Contract Calls :: Words", () => {
  beforeEach(() => {
    text = "sample";
    lang = "en-us";
    word = new Word(text, lang);

    VMContext.setSigner_account_id(alice);
  });

  it("should reverse a word", () => {
    const result = reverse(word);
    expect(result.text).toBe(text.split("").reverse().join(""));
  });

  it("should append to the log when reversing a word", () => {
    reverse(word);
    // log(VM.logs())
    expect(VM.logs()).toContainEqual(
      "[" + alice + "] invoked function reverse(" + text + ")"
    );
  });

  it("should upcase a word", () => {
    const result = upcase(word);
    expect(result.text).toBe(text.toUpperCase());
  });

  it("should append to the log when upcasing a word", () => {
    upcase(word);
    // log(VM.logs())
    expect(VM.logs()).toContainEqual(
      "[" + alice + "] invoked function upcase(" + text + ")"
    );
  });
});

'''
'''--- contracts/04.cross-contract-calls/assembly/words/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "index.ts"
}

'''
'''--- contracts/04.cross-contract-calls/assembly/words/index.ts ---
import { context, logging } from "near-sdk-as";
import { Word } from "./model";

// ----------------------------------------------------------------------------
// Contract methods
// ----------------------------------------------------------------------------

/**
 * Reverse the letters of an incoming Word
 * @param word the incoming Word
 * @returns a Word whose text attribute is the same characters but reversed
 */
export function reverse(word: Word): Word {
  logging.log(
    "[" + context.sender + "] invoked function reverse(" + word.text + ")"
  );
  return new Word(_reverse(word.text), word.lang);
}

/**
 * Convert the text attribute of an incoming Word to upper case
 * @param word the incoming Word
 * @returns a Word whose text attribute is the same characters but upper cased
 */
export function upcase(word: Word): Word {
  logging.log(
    "[" + context.sender + "] invoked function upcase(" + word.text + ")"
  );
  return new Word(_upcase(word.text), word.lang);
}

// ----------------------------------------------------------------------------
// Helper functions
// ----------------------------------------------------------------------------

/**
 * Reverse an incoming string of letters
 *
 * @param text the incoming string
 * @returns the reversed string
 */
function _reverse(text: string): string {
  return text.split("").reverse().join("");
}

/**
 * Convert an incoming string of letters
 *
 * @param text the incoming string
 * @returns the upper case version of the string
 */
function _upcase(text: string): string {
  return text.toUpperCase();
}

'''
'''--- contracts/04.cross-contract-calls/assembly/words/model.ts ---
@nearBindgen
export class Word {
  lang: string = "en-us";
  constructor(public text: string, lang: string = "en-us") {
    this.lang = lang;
  }
}

'''
'''--- contracts/as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- contracts/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- contracts/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- contracts/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- package.json ---
{
  "name": "workshop--exploring-assemblyscript-contracts",
  "version": "0.0.1",
  "description": "Learn to develop contracts for NEAR Protocol using AssemblyScript",
  "author": "Near, Inc. <hello@near.org>",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "yarn build:contract:debug",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "clean": "rm -rf ./out",
    "test": "yarn test:unit",
    "test:all": "yarn test && yarn test:simulate:runtime",
    "test:unit": "asp --verbose --nologo -c contracts/as-pect.config.js -f unit.spec",
    "test:simulate:runtime": "yarn build && jest --verbose -f simulate.spec"
  },
  "devDependencies": {
    "jest": "^25.5.4",
    "near-sdk-as": "^2.1.0",
    "near-cli": "^1.3.1"
  },
  "engines": {
    "node": ">=12.0.0"
  }
}

'''