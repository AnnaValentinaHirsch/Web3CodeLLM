*GitHub Repository "LiboShen/recur"*

'''--- README.md ---
# Recur

# Quick Start

If you haven't installed dependencies during setup:

    yarn deps-install

To deploy dev contract on testnet

    yarn deploy

To start dev server

    yarn start

'''
'''--- contract/Cargo.toml ---
[package]
name = "recur"
version = "1.0.0"
authors = ["Libo <liboooshen@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-contract-standards = "4.0.0"
near-sdk = "4.0.0"
# near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
# near-crypto = "0.14.0"
# getrandom = { version = "0.2", features = ["js"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/src/externals.rs ---
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::{ext_contract, AccountId};

// // Interface of this contract, for call backs - place holder
// #[ext_contract(ext_self)]
// pub trait Callbacks {
// }

// NFT interface, for cross-contract calls
// For details, refer to NEP-171
#[ext_contract(ext_nft)]
pub trait Nft {
    // cross-contract call
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,   // account to receive the token
        token_id: TokenId,        // nft token to be sent
        approval_id: Option<u64>, // approval ID, in case transfer is sent from ppl with valid approval
        memo: Option<String>,     
        msg: String,              // info needed by the receiving contract to handl the transfer.
    );
}

'''
'''--- contract/src/lib.rs ---
// TODO: Beneficier
// TODO: NFT contract
// TODO: Support Multi FTs
// TODO: Revist if we need a state for user. E.g. if a user has unsettled payment,
//       he should not be allowed to create new subscriptions

use near_contract_standards::non_fungible_token::hash_account_id;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::bs58;
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault,
    Promise,
};

use std::cmp::max;
use std::cmp::min;

const SECONDS_TO_NANO: u64 = 1000000000;

type SubscriptionPlanID = String; // ID for each subscription plan
type SubscriptionID = String;

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    SubscriptionById,
    SubscriptionPlanById,
    SubscriptionIdsByPlan,
    SubscriptionIdsByPlanInner { account_id_hash: CryptoHash },
    SubscriptionsPerSubscriber,
    SubscriptionsPerSubscriberInner { account_id_hash: CryptoHash },
    DepositByAccount,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
enum SubscriptionState {
    Active { ts: u64 },   // subscription activated time
    Canceled { ts: u64 }, // subscription canceled time
    Invalid, // When canceld subscription passed one more payment cycle, it is ready to be removed
}

// Subscription template
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SubscriptionPlan {
    provider_id: AccountId, // plan provider
    //TODO: beneficier: AccountId,
    payment_cycle_length: u64, // base payment cycle (e.g. hour, day, week) in the unit of seconds.
    payment_cycle_rate: u128,  // cost for 1 payment cycle
    payment_cycle_count: u64,  // total number of payments. 0 represents indefinte plan
    // allow_grace_period: u64,    // TODO: grace period in seconds
    plan_name: Option<String>, // name of the plan
                               // prev_charge_ts: Option<u64>, // most recent charge of the plan - used for calculating payment amount
                               //                              // set to 0 at initialisation
}
// Actual subscription instance based on SubscriptionPlan
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Subscription {
    subscriber_id: AccountId,    // plan subscriber
    plan_id: SubscriptionPlanID, // the subscribed plan
    // prev_charge_ts: u64, // ts of the previous charge. used for deciding whether the next payment is due.
    state: SubscriptionState, // state of the subscripion
    prev_charge_ts: u64,      // most recent charge of the subsciption, initilise to 0
                              // this will be only updated when funds are actually moved from subscriber's account
                              // Charge occurs upfront at the start of a cycle.
}

// helper structure for sorting subscriptions by next payment due time
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
struct SortResultSubscription {
    subscription_id: SubscriptionID,
    next_payment_due_ts: u64,
    incurred_fees: u128, // subscription cost to be collected
}

//Subscription Service Contract
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner: AccountId, // service owner
    subscription_plan_by_id: UnorderedMap<SubscriptionPlanID, SubscriptionPlan>,
    subscription_by_id: UnorderedMap<SubscriptionID, Subscription>,
    subscription_ids_by_plan_id: LookupMap<SubscriptionPlanID, UnorderedSet<SubscriptionID>>, // helper structure for viewing
    subscriptions_per_subscriber: LookupMap<AccountId, UnorderedSet<SubscriptionID>>, // heper structure to group all subscriptions under one user
    deposit_by_account: UnorderedMap<AccountId, u128>, // subscriber and her deposit
                                                       //TODO: deposit_map_multi_token: UnorderedMap<AccountId, UnorderedMap<AccountId, u128>>
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let this = Self {
            owner: owner_id,
            subscription_plan_by_id: UnorderedMap::new(StorageKey::SubscriptionPlanById),
            subscription_by_id: UnorderedMap::new(StorageKey::SubscriptionById),
            subscription_ids_by_plan_id: LookupMap::new(
                StorageKey::SubscriptionIdsByPlan.try_to_vec().unwrap(),
            ),
            subscriptions_per_subscriber: LookupMap::new(
                StorageKey::SubscriptionsPerSubscriber.try_to_vec().unwrap(),
            ),
            deposit_by_account: UnorderedMap::new(StorageKey::DepositByAccount),
        };
        this
    }

    pub fn get_plan(&self, plan_id: SubscriptionPlanID) -> SubscriptionPlan {
        let plan = self
            .subscription_plan_by_id
            .get(&plan_id)
            .expect("No such plan!");
        return plan;
    }

    pub fn get_subscription(&self, subscription_id: SubscriptionID) -> Subscription {
        let sub = self
            .subscription_by_id
            .get(&subscription_id)
            .expect("No such subscription!");

        return sub;
    }

    // get all subscriptions of a given plan
    pub fn list_subscriptions_by_plan_id(
        &self,
        plan_id: SubscriptionPlanID,
    ) -> Vec<(SubscriptionID, Subscription)> {
        let mut results: Vec<(SubscriptionID, Subscription)> = vec![];

        let ids = self.subscription_ids_by_plan_id.get(&plan_id).unwrap();
        for id in ids.iter() {
            let sub = self.subscription_by_id.get(&id).unwrap();
            results.push((id, sub));
        }
        return results;
    }

    // get all subscriptions of a user
    pub fn list_subscriptions_by_subscriber(
        &self,
        subscriber_id: AccountId,
    ) -> Vec<(SubscriptionID, Subscription)> {
        let mut results: Vec<(SubscriptionID, Subscription)> = vec![];

        let ids = self
            .subscriptions_per_subscriber
            .get(&subscriber_id)
            .map_or(vec![], |x| UnorderedSet::to_vec(&x));
        for id in ids.iter() {
            let sub = self.subscription_by_id.get(&id).unwrap();
            results.push((id.to_string(), sub));
        }
        return results;
    }

    // Returns all plans for a provider
    pub fn list_plans_by_provider(
        &self,
        provider_id: AccountId,
    ) -> Vec<(SubscriptionPlanID, SubscriptionPlan)> {
        let mut results: Vec<(SubscriptionPlanID, SubscriptionPlan)> = vec![];

        for (id, plan) in self.subscription_plan_by_id.iter() {
            if plan.provider_id == provider_id {
                results.push((id, plan));
            }
        }
        return results;
    }

    // check if a subscriber has enough funds
    // this can be used by providers to decide if service should be suspended
    pub fn validate_subscription(
        &self,
        subscription_id: &SubscriptionID,
        charge_ts: Option<u64>,
    ) -> bool {
        // check deposit
        // check currrent cost
        // compare
        // TODO(Steven): inspect the handling of subscription state: Canceled.

        let subscription = self
            .subscription_by_id
            .get(subscription_id)
            .expect("No such subscription!");

        if subscription.state == SubscriptionState::Invalid {
            return false;
        }

        // TODO: inspect and fix duplicate cost calcuations

        let balance = self
            .deposit_by_account
            .get(&subscription.subscriber_id)
            .unwrap_or(0);
        let total_fees = self.calculate_total_fees_for_subscriber(&subscription.subscriber_id);

        return balance >= total_fees;
    }

    pub fn find_valid_subscription(
        &self,
        subscriber_id: AccountId,
        plan_id: SubscriptionPlanID,
    ) -> Option<SubscriptionID> {
        // TODO(Steven): check for validate/active subscription
        for (id, sub) in self.list_subscriptions_by_subscriber(subscriber_id) {
            if sub.plan_id == plan_id && self.validate_subscription(&id, None) {
                return Some(id);
            }
        }
        return None;
    }

    // viewing function. The withdrawble amount is a dynamic value and updates in real time.
    // Take this into consideration when showing in the UI to avoid confusion.
    pub fn get_withdrawable_deposit(&self, account: &AccountId) -> u128 {
        let balance = self.deposit_by_account.get(&account).unwrap_or(0);

        let total_fees = self.calculate_total_fees_for_subscriber(account);

        // Avoid unsigned number overflow
        if balance > total_fees {
            balance - total_fees
        } else {
            0
        }
    }

    // function to return balance in the deposit table.
    // Not all balance is usable as it includes locked fees.
    // Used soley for debugging purposes. Shouldn't be exposed to user in case of confustion.
    pub fn get_account_balance(&self, account: &AccountId) -> u128 {
        assert!(
            env::predecessor_account_id() == self.owner||
            env::predecessor_account_id() == account.clone(),
            "Only Service Owner or User herself can check balance. For users, check get_withdrawable_deposit"
        );

        let balance = self
            .deposit_by_account
            .get(&account)
            .expect("The account has no deposit!");

        return balance;
    }

    // Core function to calculate the cost of one subscription. This should cover all subscription states.
    pub fn calcuate_subscription_incurred_cost(
        &self,
        subscription_id: &SubscriptionID,
        end_ts: Option<u64>,
    ) -> u128 {
        /* end_ts represents the charge period stop ts. if not given, default to current ts
        Decide charge duration:
        1. Active Subscription:
              charge_start_ts needs to consider upfront payment
              charge_end_ts is the given end_ts or current_ts
        2. Canceled Subscription:
              prev_charge_ts is decided at cancelation and can be used as charge_start_ts
              prev_end_ts is the cancled ts, which ensures last payment will be charged
        3. Invalid subscription: no cost. Ready to be removed from records
        */
        let subscription = self
            .subscription_by_id
            .get(&subscription_id)
            .expect("No such subscription!");

        let plan = self
            .subscription_plan_by_id
            .get(&subscription.plan_id)
            .unwrap();

        // Find charge charge_duration
        let charge_start_ts: u64;

        // if end_ts is not given, using the current ts
        let mut charge_end_ts = end_ts.unwrap_or_else(env::block_timestamp);
        assert!(
            charge_end_ts <= env::block_timestamp(),
            "Charge end time can't be in the furture!"
        );

        match subscription.state {
            SubscriptionState::Active { ts: sub_start_ts } => {
                // if no charge has been taken before, treat start_ts as one cycle earlier, to achive upfront payment
                charge_start_ts = max(
                    subscription.prev_charge_ts,
                    sub_start_ts - &plan.payment_cycle_length * SECONDS_TO_NANO,
                );
            }
            SubscriptionState::Canceled { ts: canceled_ts } => {
                // When a subscription is canceld, its prev_charge_ts has been set accordingly to cover upfront payment
                charge_start_ts = subscription.prev_charge_ts;
                // charge ends at the canceld ts, So the last payment cycle will always be charged
                charge_end_ts = canceled_ts;
            }
            SubscriptionState::Invalid => {
                // invalid subscription incurrs no cost and is ready to be removed
                return 0;
            }
        }

        let charge_duration = charge_end_ts - charge_start_ts;
        let count_payment_cycles = charge_duration / &plan.payment_cycle_length / SECONDS_TO_NANO;

        let cost = (count_payment_cycles as u128) * &plan.payment_cycle_rate;

        return cost;
    }

    // function to calcuate all subscriptions cost for a subscriber
    // This function will be used when calculating withdraw amount of a subscriber
    pub fn calculate_total_fees_for_subscriber(&self, subscriber_id: &AccountId) -> u128 {
        //1. get all subscritons of one user
        //2. accumulate fees from all subscriptions

        let mut total_fees: u128 = 0;

        let subscription_ids = self
            .subscriptions_per_subscriber
            .get(&subscriber_id)
            .unwrap_or(UnorderedSet::new(b"s"));

        for subscription_id in subscription_ids.iter() {
            total_fees += self.calcuate_subscription_incurred_cost(&subscription_id, None);
        }

        return total_fees;
    }

    // Provider or Subscriber can choose to cancel a service
    pub fn cancel_subscription(&mut self, subscription_id: &SubscriptionID) {
        // updating subscription state
        // insert the subscription back
        // cancled subscpriton should incurr cost until current cycle end,
        // which can be derived from prev_payment_ts and cancelation_ts

        let mut subscription = self
            .subscription_by_id
            .get(subscription_id)
            .expect("No such subscription!");

        let plan = self
            .subscription_plan_by_id
            .get(&subscription.plan_id)
            .unwrap(); // A plan must exist if the subscription exists

        assert!(
            plan.provider_id == env::predecessor_account_id()
                || subscription.subscriber_id == env::predecessor_account_id(),
            "Only the subscriber or service provider can cancel a subscription!"
        );

        match subscription.state {
            SubscriptionState::Active { ts: sub_start_ts } => {
                // when an Active subscription is canceled before a charge has even occured,
                // mark the prev charge ts to be one cycle earlier than sub_start_ts to enforce upfront payment
                // otherwise use the prev_charge_ts
                if subscription.prev_charge_ts == 0 {
                    subscription.prev_charge_ts = sub_start_ts - plan.payment_cycle_length;
                }
                // update subscription state to Canceled
                subscription.state = SubscriptionState::Canceled {
                    ts: env::block_timestamp(),
                };

                // insert back to the index
                self.subscription_by_id
                    .insert(subscription_id, &subscription);
            }
            SubscriptionState::Canceled { ts: _ } => {
                log!(
                    "Subsription has already been canceled. No action. subscription_id: {}",
                    &subscription_id
                )
            }
            SubscriptionState::Invalid => env::panic_str("Only Active Subsription can be canceled"),
        }
    }

    // function to remove invalid subscriptions from storage
    pub fn prune_subscriptions(&self) {
        todo!()
    }

    fn transfer(&self, to: AccountId, amount: Balance) {
        // Internal hellper function: tranfer FT to account
        Promise::new(to).transfer(amount);
    }

    fn internal_charge(&mut self, account_id: &AccountId, amount: u128) {
        // helper function to update deposit table internally without actually incurring any on-chain transfer
        // This is to help reduce the amount of - chain actions and to make a final transfer using total amount

        let mut deposit = self
            .deposit_by_account
            .get(&account_id)
            .expect("No deposit record!");
        // let new_deposit = max(0, deposit-amount);
        deposit = max(0, deposit - amount);
        self.deposit_by_account.insert(account_id, &deposit);
    }

    fn get_next_payment_due_ts(&self, sub: &Subscription) -> u64 {
        let plan = self.subscription_plan_by_id.get(&sub.plan_id).unwrap();

        if let SubscriptionState::Invalid = sub.state {
            return u64::MAX; // invalid subscriton can doesn't has a due date
        }

        let mut due_ts: u64 = 0;
        if sub.prev_charge_ts > 0 {
            due_ts = sub.prev_charge_ts + plan.payment_cycle_length;
        } else if let SubscriptionState::Active { ts: start_ts } = sub.state {
            due_ts = start_ts;
        }

        return due_ts;
    }

    pub fn get_available_fund_for_subscription(
        &self,
        subscription_id: &SubscriptionID,
    ) -> (u128, u128) {
        /* Core helper function to check available fund for one subscription
        This function takes into consideration the timely order of next due payment date.
        Return a tuple (available_fund, incurred_fees)

        Assumption: the number of subscriptions from one account is relatively small.
        So iteration/sort won't be expensive.

        1. Get all subs from the same subscriber
        2. Sort the subs based on their next payment date.
        3. For each sub in sorted_subs:
            Calculate pseudo_available_fund by deducting from account deposit the incurred fees
            Early stop if pseudo_available_fund becomes 0
        4. return (pseudo_available_fund, incurred_fees)
        */
        let target_sub = self
            .subscription_by_id
            .get(subscription_id)
            .expect("No such subscription!");

        let sub_ids = self
            .subscriptions_per_subscriber
            .get(&target_sub.subscriber_id)
            .expect("Error when getting subscriptions from subscriber");

        let mut sorted_subs: Vec<SortResultSubscription> = Vec::new();
        for sub_id in sub_ids.iter() {
            let sub = self.subscription_by_id.get(&sub_id).unwrap();
            let due_payment_ts = self.get_next_payment_due_ts(&sub);
            let fee = self.calcuate_subscription_incurred_cost(&sub_id, None);

            let sort_sub_result = SortResultSubscription {
                subscription_id: sub_id,
                next_payment_due_ts: due_payment_ts,
                incurred_fees: fee,
            };

            sorted_subs.push(sort_sub_result);
        }
        // sort the result based on payment due ts
        sorted_subs.sort_by_key(|k| k.next_payment_due_ts);

        let mut pseudo_deposit = self
            .deposit_by_account
            .get(&target_sub.subscriber_id)
            .unwrap();

        for sub_result in sorted_subs.iter() {
            // TODO(libo): provide a test to demo the charge ordering problem.
            if sub_result.subscription_id.eq(subscription_id) {
                let fund_for_sub = min(pseudo_deposit, sub_result.incurred_fees);
                return (fund_for_sub, sub_result.incurred_fees);
            }
            pseudo_deposit = if pseudo_deposit > sub_result.incurred_fees {
                pseudo_deposit - sub_result.incurred_fees
            } else {
                0
            };
            if pseudo_deposit <= 0 {
                return (0, sub_result.incurred_fees);
            }
        }

        // if no sub result is returned, there must be error in finding target sub's fund.
        env::panic_str("Sorted subscriptions result is empty");
    }
}

// functions related to to service provider
pub trait ProviderActions {
    fn create_subscription_plan(
        &mut self,
        provider_id: Option<AccountId>, // if none, use the caller accountid
        payment_cycle_length: u64,
        payment_cycle_rate: U128,
        payment_cycle_count: u64,
        plan_name: Option<String>,
        //prev_charge_ts: Option<u64>,
    ) -> SubscriptionPlanID;

    // collect fees from a chosen plan.
    // return a list of tuple representing the subscription and the collected fees
    fn collect_fees(
        &mut self,
        plan_id: SubscriptionPlanID,
        charge_ts: Option<u64>,
    ) -> Vec<(SubscriptionID, u128)>;

    // viewing function to get collectable fee of a plan
    fn view_collectable_fees_per_plan(&self, plan_id: SubscriptionPlanID) -> u128;

    // view function to get collectable fee of a provider
    fn view_collectable_fees_per_provider(&self, account: AccountId) -> u128;
}

pub trait SubscriberActions {
    fn create_subscription(&mut self, plan_id: SubscriptionPlanID) -> SubscriptionID;

    // function to deposit fund
    // TODO: support multi FTs
    fn deposit(&mut self, subscriber_id: AccountId);

    fn withdraw(&mut self, amount: Option<U128>);
}

#[near_bindgen]
impl ProviderActions for Contract {
    fn create_subscription_plan(
        &mut self,
        provider_id: Option<AccountId>, // if none, use the sending account id
        payment_cycle_length: u64,
        payment_cycle_rate: U128,
        payment_cycle_count: u64,
        plan_name: Option<String>,
        //prev_charge_ts: Option<u64>,
    ) -> SubscriptionPlanID {
        // if no provider is given, using the sender's account id
        let provider_id = provider_id
            // convert the valid provider ID into an account ID
            .map(|a| a.into())
            // if no provider id is given, simply use the caller's ID
            .unwrap_or_else(env::predecessor_account_id);

        let payment_cycle_rate = payment_cycle_rate.0;

        assert!(
            payment_cycle_length >= 60,
            "Payment cycle needs to be not less than 1 min!"
        );

        assert!(payment_cycle_rate > 0, "Rate needs to be a postive number!");

        assert!(
            payment_cycle_count > 0,
            "Payment count needs to be positive! "
        );

        // create plan ID
        let curr_ts_string = env::block_timestamp().to_string();
        let mut seed = provider_id.as_str().to_owned();
        seed.push_str(&curr_ts_string);

        let plan_id = bs58::encode(seed.into_bytes())
            .with_alphabet(bs58::Alphabet::BITCOIN)
            .into_string();

        // initiate the struct and return
        let a_plan = SubscriptionPlan {
            provider_id: provider_id,
            payment_cycle_length: payment_cycle_length,
            payment_cycle_rate: payment_cycle_rate,
            payment_cycle_count: payment_cycle_count,
            plan_name: plan_name,
            //prev_charge_ts: prev_charge_ts,
        };

        // insert the plan into map
        self.subscription_plan_by_id.insert(&plan_id, &a_plan);

        return plan_id;
    }

    #[payable]
    fn collect_fees(
        &mut self,
        plan_id: SubscriptionPlanID,
        charge_ts: Option<u64>,
    ) -> Vec<(SubscriptionID, u128)> {
        /* Core Function. Key features:
        - Collect fees from active & canceled subscriptions. Return a vector of <(sub_id, charged_fee)>
        - Move canceled subscriptions to Invalid, when the final payment cycle ends.
        - For each subscriber, fees are charged following timely order of payment_due_date
        - Fees from all subscriptions will be accumulated first and transfer altogether at the end
          to the provider in one on-chain transaction

        1. get all subscriptions of a plan
        2. for each subscription:
            2.1 If state is Invalid: no fee, continue
            2.2 (available_fund, incurred_fee) = get_available_fund_for_sub(): handles the charge order by due_payment_time
                2.2.1 if available_fund < incurred_fee:
                        cancel the subscription
                2.2.2 internal charge
                      internal_charge_amount = min(available_fund, incurred_fee)
                      total_fee += internal_charge_amount
                      internal_charge(internal_charge_amount): update deposit table
            2.3 update sub details and insert back to indices
                2.3.1. if State is canceled, check if the final payment cycle has ended,
                        if so, change state to Invalid & update indices. Then continue.
                2.3.2 update pre_charge_time
                2.3.3 insert back to indices
        3. transfer total_fee to provider
        */

        let charge_ts = charge_ts.unwrap_or_else(env::block_timestamp);
        assert!(
            charge_ts <= env::block_timestamp(),
            "You can't charge for future time!"
        );

        let plan = self
            .subscription_plan_by_id
            .get(&plan_id)
            .expect("No such plan!");

        assert!(
            plan.provider_id == env::predecessor_account_id()
                || self.owner == env::predecessor_account_id(),
            "Only the Provider or Service owner can collect fees for the provider"
        );

        let subscription_ids = self
            .subscription_ids_by_plan_id
            .get(&plan_id)
            .map_or(vec![], |x| UnorderedSet::to_vec(&x));

        // prepare result
        let mut total_fees: u128 = 0;
        let mut result: Vec<(SubscriptionID, u128)> = vec![];

        for subscription_id in subscription_ids.iter() {
            let mut subscription = self.subscription_by_id.get(&subscription_id).unwrap();

            // 2.1 if subscription is Invalid, no fees, skip
            if let SubscriptionState::Invalid = subscription.state {
                result.push((subscription_id.to_string(), 0));
                continue;
            }

            // 2.2 get the available fund for this subscription and incurred fees
            let (available_fund, incurred_fees) =
                self.get_available_fund_for_subscription(&subscription_id);

            if available_fund < incurred_fees {
                // cancel the subscription if the fund is not enough.
                // charge will still be taken in the following steps
                self.cancel_subscription(&subscription_id);

                // TODO: Revisit if whe should immediately invalidate the subscription when fund becomes insufficient.
                // Reasoning: if someone missed a payment before, they shouldn't be served even within this cycle.
                // But to make the logic fair, we also need to avoid partial payment
            }

            let internal_charge_amount = min(available_fund, incurred_fees);
            total_fees += internal_charge_amount; // accumulate fees
            self.internal_charge(&subscription.subscriber_id, internal_charge_amount);

            // 2.3 Update subscription details and push back to indices
            if let SubscriptionState::Canceled { ts: _ } = subscription.state {
                // if a canceld subscription's final cycle has ended. Change state to Invalid
                let payment_due_ts = self.get_next_payment_due_ts(&subscription);
                if payment_due_ts < env::block_timestamp() {
                    subscription.state = SubscriptionState::Invalid;
                    self.subscription_by_id
                        .insert(&subscription_id, &subscription);
                    result.push((subscription_id.to_string(), 0));
                    continue;
                }
            }

            subscription.prev_charge_ts = env::block_timestamp();
            self.subscription_by_id
                .insert(&subscription_id, &subscription);
            result.push((subscription_id.to_string(), internal_charge_amount));
        }

        //3. transfer the total fee to provider
        self.transfer(plan.provider_id, total_fees);

        return result;
    }

    // viewing function to get the total collectable fees of a plan without actuall collecting
    // implementation is similar to collect_fees
    fn view_collectable_fees_per_plan(&self, plan_id: SubscriptionPlanID) -> u128 {
        let subscription_ids = self
            .subscription_ids_by_plan_id
            .get(&plan_id)
            .map_or(vec![], |x| UnorderedSet::to_vec(&x));

        let mut total_fees: u128 = 0;

        for subscription_id in subscription_ids.iter() {
            let subscription = self.subscription_by_id.get(&subscription_id).unwrap();

            // if subscription is Invalid, no fees, skip
            if let SubscriptionState::Invalid = subscription.state {
                continue;
            }

            // get the available fund for this subscription and incurred fees
            let (available_fund, incurred_fees) =
                self.get_available_fund_for_subscription(&subscription_id);

            total_fees += min(available_fund, incurred_fees);
        }

        return total_fees;
    }

    // helper function to get total collectable fee of a provider
    fn view_collectable_fees_per_provider(&self, account: AccountId) -> u128 {
        let mut total_fee: u128 = 0;
        let ids_plans_result = self.list_plans_by_provider(account);
        for (plan_id, _) in ids_plans_result.iter() {
            total_fee += self.view_collectable_fees_per_plan(plan_id.to_string());
        }
        return total_fee;
    }
}

#[near_bindgen]
impl SubscriberActions for Contract {
    fn create_subscription(&mut self, plan_id: SubscriptionPlanID) -> SubscriptionID {
        // subscription can only be created by own account
        let subscriber: AccountId = env::predecessor_account_id();

        // get the plan
        let plan = self
            .subscription_plan_by_id
            .get(&plan_id)
            .expect("No such plan!");

        assert!(
            plan.provider_id != env::predecessor_account_id(),
            "Provider can't subscribe to its own plan!"
        );

        // check validate deposit : deposit should cover at least the 1st paymen
        let valid_deposit = self.get_withdrawable_deposit(&subscriber);
        assert!(
            valid_deposit >= plan.payment_cycle_rate,
            "Deposit is not enough for first payment {rate}",
            rate = &plan.payment_cycle_rate
        );

        // generate an id
        let curr_ts_string = env::block_timestamp().to_string();
        let mut seed = subscriber.as_str().to_owned();
        seed.push_str(&curr_ts_string);

        let subscription_id: SubscriptionID = bs58::encode(seed.into_bytes())
            .with_alphabet(bs58::Alphabet::BITCOIN)
            .into_string();

        // create the subscription
        let new_subscription = Subscription {
            subscriber_id: subscriber.clone(),
            plan_id: plan_id.clone(),
            state: SubscriptionState::Active {
                ts: env::block_timestamp(),
            },
            prev_charge_ts: 0, //defaul to 0 to indicate no charge has been taken
        };

        //update relevant indices
        self.subscription_by_id
            .insert(&subscription_id, &new_subscription);

        //update relevant indices
        // TODO: check if all new unordered sets of different plans from the same provider will be put at the same memory
        let mut subscriptions_ids_set = self
            .subscription_ids_by_plan_id
            .get(&plan_id)
            .unwrap_or_else(|| {
                // if the plan doesn't have any subscription, we create a new unordered set
                UnorderedSet::new(
                    StorageKey::SubscriptionIdsByPlanInner {
                        account_id_hash: hash_account_id(&plan.provider_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        subscriptions_ids_set.insert(&subscription_id);
        self.subscription_ids_by_plan_id
            .insert(&plan_id, &subscriptions_ids_set);

        //update relevant indices
        let mut subscriptions_ids_set_2 = self
            .subscriptions_per_subscriber
            .get(&subscriber)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::SubscriptionsPerSubscriberInner {
                        //get a new unique prefix for the set
                        account_id_hash: hash_account_id(&subscriber),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        subscriptions_ids_set_2.insert(&subscription_id);
        self.subscriptions_per_subscriber
            .insert(&subscriber, &subscriptions_ids_set_2);

        return subscription_id;
    }

    // function to top up deposit
    #[payable]
    fn deposit(&mut self, subscriber_id: AccountId) {
        // 1. transfer fund to current contract
        // 2. update the deposit table
        // one should be able to deposit to other's ccount too

        let amount = env::attached_deposit();
        assert!(amount > 0, "Deposit must be positive!");

        // get balance of the account, if the account is not in the map, default the balance to 0
        let mut balance: u128 = self.deposit_by_account.get(&subscriber_id).unwrap_or(0);
        balance += &amount;

        // update index
        self.deposit_by_account.insert(&subscriber_id, &balance);
    }

    // function to withdraw unlocked deposit
    #[payable]
    fn withdraw(&mut self, amount: Option<U128>) {
        // 1. get valid deposit
        // 2. when no input amount is given, set asking_amount to available_fund
        // if asking_amount < available_fund:
        //          update the deposit table
        //          transfer token
        // else: panic

        let user_id = env::predecessor_account_id();

        let withdrawable_fund = self.get_withdrawable_deposit(&user_id);

        // if no input amount is given, withdarw all available fund
        let asking_amount = amount.map_or(withdrawable_fund, |a| a.0);

        // panic if not enough fund!
        assert!(withdrawable_fund >= asking_amount, "Not enough fund!");

        // update deposit index
        let balance = self
            .deposit_by_account
            .get(&user_id)
            .expect("No such account!");
        let new_balance = max(0, balance - asking_amount);
        self.deposit_by_account.insert(&user_id, &new_balance);

        // transfer token
        self.transfer(user_id, asking_amount);
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    const MINT_COST: u128 = 1000000000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    // TODO: Add tests
    #[test]
    fn test_new() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new(accounts(1).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_COST)
            .predecessor_account_id(accounts(0))
            .build());
    }
}

'''
'''--- demo_frontend/index.html ---
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/src/main.css" />
    <title>BUIDL Club</title>
  </head>
  <body class="h-full">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./src/index.jsx" type="module"></script>
  </body>
</html>

'''
'''--- demo_frontend/package.json ---
{
  "name": "provider-demo",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "env-cmd -f ../contract/neardev/dev-account.env vite",
    "build": "CONTRACT_NAME=recurr.near vite build && yarn netlify_redirects",
    "build_testnet": "CONTRACT_NAME=recurr.testnet vite build -m testnet && yarn netlify_redirects",
    "build_mainnet": "CONTRACT_NAME=recurr.near vite build -m mainnet && yarn netlify_redirects",
    "netlify_redirects": "echo \"/* /index.html 200\" > dist/_redirects"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@types/node": "^18.6.2",
    "@vitejs/plugin-react": "^2.0.1",
    "autoprefixer": "^10.4.8",
    "ava": "^4.2.0",
    "env-cmd": "^10.1.0",
    "nodemon": "^2.0.16",
    "postcss": "^8.4.16",
    "process": "^0.11.10",
    "react-test-renderer": "^18.1.0",
    "tailwindcss": "^3.1.8",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "vite": "^3.0.9"
  },
  "dependencies": {
    "@apollo/client": "^3.6.9",
    "@tailwindcss/forms": "^0.5.3",
    "graphql": "^16.6.0",
    "near-api-js": "^0.44.2",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-router-dom": "6",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- demo_frontend/src/NftContract.js ---
const { connect, Contract, keyStores, WalletConnection } = window.nearApi;
import { nearConfig } from "./near-api";

// Initialize contract & set global variables
export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["nft_tokens_for_owner", "nft_token"],
    changeMethods: ["nft_approve"],
  });
}

export async function nftTokensForOwner(contract, accountId) {
  if (accountId == "") return [];
  let tokens = await contract.nft_tokens_for_owner({
    account_id: window.accountId,
  });
  return tokens;
}

export async function getToken(contract, tokenId) {
  console.log(tokenId);
  if (tokenId == "") return null;
  let token = await contract.nft_token({
    token_id: tokenId,
  });
  return token;
}

'''
'''--- demo_frontend/src/RentalContract.js ---
const { connect, Contract, keyStores, WalletConnection } = window.nearApi;
import { nearConfig } from "./near-api";

// Initialize contract & set global variables
export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["get_borrower"],
    changeMethods: [],
  });
}

export async function getBorrower(contract, nftContractId, tokenId) {
  let res = await contract.get_borrower({
    contract_id: nftContractId,
    token_id: tokenId,
  });
  return res;
}

'''
'''--- demo_frontend/src/Utils.js ---
export function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

'''
'''--- demo_frontend/src/main.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

'''
'''--- demo_frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}", "./index.html"],
  theme: {
    extend: {},
  },
  plugins: [require("@tailwindcss/forms")],
};

'''
'''--- demo_frontend/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  loader: { ".js": "jsx" },
  // To read contract name
  envPrefix: "CONTRACT_",
});

'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/src/main.css" />
    <title>Recur</title>
  </head>
  <body class="h-full">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./src/index.jsx" type="module"></script>
  </body>
</html>

'''
'''--- frontend/package.json ---
{
  "name": "recur",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "env-cmd -f ../contract/neardev/dev-account.env vite",
    "build": "CONTRACT_NAME=recurr.near vite build && yarn netlify_redirects",
    "build_testnet": "CONTRACT_NAME=recurr.testnet vite build -m testnet && yarn netlify_redirects",
    "build_mainnet": "CONTRACT_NAME=recurr.near vite build -m mainnet && yarn netlify_redirects",
    "netlify_redirects": "echo \"/* /index.html 200\" > dist/_redirects"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@types/node": "^18.11.9",
    "@vitejs/plugin-react": "^2.0.1",
    "autoprefixer": "^10.4.8",
    "ava": "^4.2.0",
    "env-cmd": "^10.1.0",
    "nodemon": "^2.0.16",
    "postcss": "^8.4.16",
    "process": "^0.11.10",
    "react-test-renderer": "^18.1.0",
    "tailwindcss": "^3.1.8",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "vite": "^3.0.9"
  },
  "dependencies": {
    "@apollo/client": "^3.6.9",
    "@tailwindcss/forms": "^0.5.3",
    "graphql": "^16.6.0",
    "near-api-js": "^0.44.2",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-router-dom": "6",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/src/NftContract.js ---
const { connect, Contract, keyStores, WalletConnection } = window.nearApi;
import { nearConfig } from "./near-api";

// Initialize contract & set global variables
export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["nft_tokens_for_owner", "nft_token"],
    changeMethods: ["nft_approve"],
  });
}

export async function nftTokensForOwner(contract, accountId) {
  if (accountId == "") return [];
  let tokens = await contract.nft_tokens_for_owner({
    account_id: window.accountId,
  });
  return tokens;
}

export async function getToken(contract, tokenId) {
  if (tokenId == "") return null;
  let token = await contract.nft_token({
    token_id: tokenId,
  });
  return token;
}

export async function newLease(
  contract,
  tokenId,
  borrower,
  expiration,
  amountNear
) {
  let YACTO = BigInt("1000000000000000000000000");
  let amountYacto = BigInt(amountNear) * YACTO;
  if (tokenId == "") return [];
  let message = JSON.stringify({
    contract_addr: contract.contractId,
    token_id: tokenId,
    borrower: borrower,
    expiration: expiration,
    amount_near: amountYacto.toString(),
  });
  let tokens = await contract.nft_approve({
    args: {
      token_id: tokenId,
      account_id: nearConfig.contractName,
      msg: message,
    },
    gas: "300000000000000",
    amount: "1000000000000000000000",
  });
  return tokens;
}

'''
'''--- frontend/src/Utils.js ---
export function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

export function formatNearAmount(amount) {
  return Number(window.nearApi.utils.format.formatNearAmount(BigInt(amount))).toFixed(2)
}

export function formatDuration(frequency) {
  if (frequency == 60) {
    return "1 minute"
  }
  if (frequency == 60 * 60) {
    return "1 hour"
  }
  if (frequency == 60 * 60 * 24) {
    return "1 day"
  }
  if (frequency == 60 * 60 * 24 * 7) {
    return " 1week"
  }
  if (frequency == 60 * 60 * 24 * 30) {
    return "30 days"
  }
  return frequency + " seconds";
}

export function subscriptionState(sub) {
  if (sub.state == "Invalid") {
    return "Invalid";
  }
  if ("Active" in sub.state) {
    return "Active";
  }
  if ("Canceled" in sub.state) {
    return "Canceled";
  }
}

'''
'''--- frontend/src/main.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

'''
'''--- frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}", "./index.html"],
  theme: {
    extend: {},
  },
  plugins: [require("@tailwindcss/forms")],
};

'''
'''--- frontend/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  loader: { ".js": "jsx" },
  // To read contract name
  envPrefix: "CONTRACT_",
});

'''
'''--- integration-tests/Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/src/tests.rs ---
use std::{env, fs};
use near_units::parse_near;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let wasm_arg: &str = &(env::args().nth(1).unwrap());
    let wasm_filepath = fs::canonicalize(env::current_dir()?.join(wasm_arg))?;

    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(wasm_filepath)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // begin tests
    test_default_message(&alice, &contract, &worker).await?;
    test_changes_message(&alice, &contract, &worker).await?;
    Ok(())
}

async fn test_default_message(
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let message: String = user
        .call(&worker, contract.id(), "get_greeting")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(message, "Hello".to_string());
    println!("      Passed ✅ gets default message");
    Ok(())
}

async fn test_changes_message(
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    user.call(&worker, contract.id(), "set_greeting")
        .args_json(json!({"message": "Howdy"}))?
        .transact()
        .await?;

    let message: String = user
        .call(&worker, contract.id(), "get_greeting")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(message, "Howdy".to_string());
    println!("      Passed ✅ changes message");
    Ok(())
}
'''
'''--- package.json ---
{
  "name": "recur",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "cd frontend && yarn start",
    "deploy": "yarn build:contract && cd contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/recur.wasm",
    "deploy_testnet": "yarn build:contract && cd contract && near deploy --wasmFile ./target/wasm32-unknown-unknown/release/recur.wasm --accountId recurr.testnet",
    "deploy_mainnet": "yarn build:contract && cd contract && NEAR_ENV=mainnet near deploy --wasmFile ./target/wasm32-unknown-unknown/release/recur.wasm --accountId recurr.near",
    "preview": "cd frontend && yarn vite preview",
    "preview:demo": "cd demo_frontend && yarn vite preview",
    "build": "yarn build:contract && yarn build:web",
    "build:web": "cd frontend && yarn build",
    "build_testnet:web": "cd frontend && yarn build_testnet",
    "build_mainnet:web": "cd frontend && yarn build_mainnet",
    "build:contract": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build_testnet:demo_web": "cd demo_frontend && yarn build_testnet",
    "test": "yarn test:unit && yarn test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "yarn build:contract && cd integration-tests && cargo run --example integration-tests \"../contract/target/wasm32-unknown-unknown/release/recur.wasm\"",
    "deps-install": "yarn install && cd frontend && yarn install && cd ..",
    "deps-install:demo_web": "yarn install && cd demo_frontend && yarn install && cd .."
  },
  "devDependencies": {
    "near-api-js": "^1.0.0",
    "near-cli": "^3.3.0"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.0",
    "@heroicons/react": "^2.0.10"
  }
}

'''
'''--- scripts/init.js ---
const { Contract } = nearAPI;

const contract = new Contract(account, account.accountId, {
  viewMethods: ["nft_tokens_for_owner"],
  changeMethods: ["new_default_meta", "nft_mint"],
  sender: account,
});

await contract.new_default_meta({ args: { owner_id: account.accountId } });

'''
'''--- scripts/test_util.txt ---
//deplyed to dev-1668677946314-54468871935084 ty_dev.testnet
// crypto_ty.testnet: subscriber
// ty_dev_2.

yarn deploy

export SERVICE_CONTRACT_OWNER=ty_dev.testnet
export SUBSCRIBER_ID=crypto_ty.testnet
export SUBSCRIBER_ID_2=ty_dev_3.testnet
export PROVIDER_ID=ty_dev_2.testnet
export CONTRACT_ADDR=dev-1668677946314-54468871935084

plan_id_1 = Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8
sub_id_1 = "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"

/* Singler Subscriber & Single Provider*/
// initialise a contract
near call dev-1668677946314-54468871935084 new '{"owner_id": "'$SERVICE_CONTRACT_OWNER'"}' --accountId $SERVICE_CONTRACT_OWNER

// Provider: Test Create a Plan -- SUCCEEDED plan-id:Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8
near call $CONTRACT_ADDR create_subscription_plan '{
    "provider_id":"'$PROVIDER_ID'",
    "payment_cycle_length":60,
    "payment_cycle_rate":1,
    "payment_cycle_count":5,
    "plan_name":"test_plan_1"
  }' --accountId $PROVIDER_ID

// Provider: check collectable fees - TODO

// Provider: collect fees -- FAILED
near call $CONTRACT_ADDR collect_fees '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// Contract: View existing plan -- SUCCEEDED
near call $CONTRACT_ADDR get_plan '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// Contract: View subscription of a plan
near call $CONTRACT_ADDR list_subscriptions_by_plan_id '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SERVICE_CONTRACT_OWNER

// Contract: get deposit of a user -- SUCCEEDED
near call $CONTRACT_ADDR get_unlocked_deposit '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

// Contract: get total fund of a user -- SUCCEEDED
near call $CONTRACT_ADDR get_account_balance '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

//Contract: cancel subscription & panic -- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $CONTRACT_ADDR 

//Contract: get a subscription -- SUCCEEDED
near call $CONTRACT_ADDR get_subscription '{
  "subscription_id": "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID

//Contract: get all subscriptions from a user -- SUCCEEDED
near call $CONTRACT_ADDR list_subscriptions_by_subscriber '{
  "subscriber_id": "'$SUBSCRIBER_ID'"
  }' --accountId $SERVICE_CONTRACT_OWNER

//Contract: validate a subscription -- SUCCEEDED
near call $CONTRACT_ADDR validate_subscription '{
  "subscription_id": "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SERVICE_CONTRACT_OWNER

// Contract: check total fee for a subscriber -- SUCCEEDED
// total fees should equal to (account_balance - un_locked_deposit) -- SUCCEEDED
near call $CONTRACT_ADDR calculate_total_fees_for_subscriber '{
    "subscriber_id":"'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: deposit -- SUCCEEDED
near call $CONTRACT_ADDR deposit '{
  "subscriber_id": "'$SUBSCRIBER_ID_2'"
  }' --accountId $SUBSCRIBER_ID --depositYocto 100000000000000000000000

// Subscriber: Creat a subscripton & Panic if not enough subscription -- SUCCEEDED
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: Creat a subscripton when enough deposit -- SUCCEEDED (sub_id:koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T)
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: withdarw fund -- SUCCEEDED
near call $CONTRACT_ADDR withdraw '{
  "amount":100
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR withdraw '{
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: calculate subscription cost -- SUCCEEDED
near call $CONTRACT_ADDR calcuate_subscription_incurred_cost '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

//Subscriber: cancel subscription & fee stop change-- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

// Contract: check total fee for a subscriber -- Succeed
near call $CONTRACT_ADDR calculate_total_fees_for_subscriber '{
    "subscriber_id":"'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR get_available_fund_for_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

/* multiple subscribers & Single Provider */

// create two subscriptions from the same plan -- SUCCEEDED
// sub_id_1: koFB4hKzwutqExxe7d2MzG63wUYJvVpbs7zf6aGQgapMPYmYB
// sub_id_2: Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID_2 

near call $CONTRACT_ADDR list_subscriptions_by_plan_id '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SERVICE_CONTRACT_OWNER

near call $CONTRACT_ADDR calcuate_subscription_incurred_cost '{
    "subscription_id":"Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR collect_fees '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// cancel subscription -- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvVpbs7zf6aGQgapMPYmYB"
  }' --accountId $PROVIDER_ID 

near call $CONTRACT_ADDR validate_subscription '{
  "subscription_id": "Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SERVICE_CONTRACT_OWNER

// for active subscription. unplock deposit should be decreasing
near call $CONTRACT_ADDR get_unlocked_deposit '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

near call $CONTRACT_ADDR get_available_fund_for_subscription '{
    "subscription_id":"Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SUBSCRIBER_ID 

/* multiple subscriptions from different plans 
( multiple subscribers & Multiple Providers )
*///deplyed to dev-1668677946314-54468871935084 ty_dev.testnet
// crypto_ty.testnet: subscriber
// ty_dev_2.

yarn deploy

export SERVICE_CONTRACT_OWNER=ty_dev.testnet
export SUBSCRIBER_ID=crypto_ty.testnet
export SUBSCRIBER_ID_2=ty_dev_3.testnet
export PROVIDER_ID=ty_dev_2.testnet
export CONTRACT_ADDR=dev-1668677946314-54468871935084

plan_id_1 = Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8
sub_id_1 = "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"

/* Singler Subscriber & Single Provider*/
// initialise a contract
near call dev-1668677946314-54468871935084 new '{"owner_id": "'$SERVICE_CONTRACT_OWNER'"}' --accountId $SERVICE_CONTRACT_OWNER

// Provider: Test Create a Plan -- SUCCEEDED plan-id:Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8
near call $CONTRACT_ADDR create_subscription_plan '{
    "provider_id":"'$PROVIDER_ID'",
    "payment_cycle_length":60,
    "payment_cycle_rate":1,
    "payment_cycle_count":5,
    "plan_name":"test_plan_1"
  }' --accountId $PROVIDER_ID

// Provider: check collectable fees - TODO

// Provider: collect fees -- FAILED
near call $CONTRACT_ADDR collect_fees '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// Contract: View existing plan -- SUCCEEDED
near call $CONTRACT_ADDR get_plan '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// Contract: View subscription of a plan
near call $CONTRACT_ADDR list_subscriptions_by_plan_id '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SERVICE_CONTRACT_OWNER

// Contract: get deposit of a user -- SUCCEEDED
near call $CONTRACT_ADDR get_unlocked_deposit '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

// Contract: get total fund of a user -- SUCCEEDED
near call $CONTRACT_ADDR get_account_balance '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

//Contract: cancel subscription & panic -- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $CONTRACT_ADDR 

//Contract: get a subscription -- SUCCEEDED
near call $CONTRACT_ADDR get_subscription '{
  "subscription_id": "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID

//Contract: get all subscriptions from a user -- SUCCEEDED
near call $CONTRACT_ADDR list_subscriptions_by_subscriber '{
  "subscriber_id": "'$SUBSCRIBER_ID'"
  }' --accountId $SERVICE_CONTRACT_OWNER

//Contract: validate a subscription -- SUCCEEDED
near call $CONTRACT_ADDR validate_subscription '{
  "subscription_id": "koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SERVICE_CONTRACT_OWNER

// Contract: check total fee for a subscriber -- SUCCEEDED
// total fees should equal to (account_balance - un_locked_deposit) -- SUCCEEDED
near call $CONTRACT_ADDR calculate_total_fees_for_subscriber '{
    "subscriber_id":"'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: deposit -- SUCCEEDED
near call $CONTRACT_ADDR deposit '{
  "subscriber_id": "'$SUBSCRIBER_ID_2'"
  }' --accountId $SUBSCRIBER_ID --depositYocto 100000000000000000000000

// Subscriber: Creat a subscripton & Panic if not enough subscription -- SUCCEEDED
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: Creat a subscripton when enough deposit -- SUCCEEDED (sub_id:koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T)
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: withdarw fund -- SUCCEEDED
near call $CONTRACT_ADDR withdraw '{
  "amount":100
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR withdraw '{
  }' --accountId $SUBSCRIBER_ID 

// Subscriber: calculate subscription cost -- SUCCEEDED
near call $CONTRACT_ADDR calcuate_subscription_incurred_cost '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

//Subscriber: cancel subscription & fee stop change-- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

// Contract: check total fee for a subscriber -- Succeed
near call $CONTRACT_ADDR calculate_total_fees_for_subscriber '{
    "subscriber_id":"'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR get_available_fund_for_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvUEhfwD4ohY6mrqgWob3T"
  }' --accountId $SUBSCRIBER_ID 

/* multiple subscribers & Single Provider */

// create two subscriptions from the same plan -- SUCCEEDED
// sub_id_1: koFB4hKzwutqExxe7d2MzG63wUYJvVpbs7zf6aGQgapMPYmYB
// sub_id_2: Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX
near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR create_subscription '{
    "plan_id":"Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SUBSCRIBER_ID_2 

near call $CONTRACT_ADDR list_subscriptions_by_plan_id '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $SERVICE_CONTRACT_OWNER

near call $CONTRACT_ADDR calcuate_subscription_incurred_cost '{
    "subscription_id":"Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SUBSCRIBER_ID 

near call $CONTRACT_ADDR collect_fees '{
  "plan_id": "Cd4f7hz2AU8qZWBSYvv4AUXFCzBSnFxKXELALMXfpLrexoc8"
  }' --accountId $PROVIDER_ID

// cancel subscription -- SUCCEEDED
near call $CONTRACT_ADDR cancel_subscription '{
    "subscription_id":"koFB4hKzwutqExxe7d2MzG63wUYJvVpbs7zf6aGQgapMPYmYB"
  }' --accountId $PROVIDER_ID 

near call $CONTRACT_ADDR validate_subscription '{
  "subscription_id": "Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SERVICE_CONTRACT_OWNER

// for active subscription. unplock deposit should be decreasing
near call $CONTRACT_ADDR get_unlocked_deposit '{
  "account": "'$SUBSCRIBER_ID'"
  }' --accountId $SUBSCRIBER_ID

near call $CONTRACT_ADDR get_available_fund_for_subscription '{
    "subscription_id":"Cd4f7hz2AU9SAHHyKGpmYGVix9nN3C9HUJxjU9vNMUbLm7nX"
  }' --accountId $SUBSCRIBER_ID 

/* multiple subscriptions from different plans 
( multiple subscribers & Multiple Providers )
*/
'''