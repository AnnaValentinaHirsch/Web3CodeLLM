*GitHub Repository "Incognito-CLI/IncognitoCLI"*

'''--- README.md ---
# Incognito CLI

Built by two goofy high school students

Shoutout
- toby
- snubs
- yzy
- cleo

## note

Current state of the repo is non-functional as various endpoints (like auth) have been removed. This is open sourced for educational purposes only.

Sorry for the very messy code

[Twitter](https://twitter.com/IncognitoCLI)

It was a good run, enjoy.

Sincerely,
opm & banana

'''
'''--- incognitoConfig.json ---
{
    "capmonsterKey": "",
    "key": "",
    "alchemyKey": "",
    "etherscanKey": "",
    "rpc": ""
}
'''
'''--- index.ts ---
import fs from 'fs';
import 'colorts/lib/string';
import Package from './package.json';
import cliProgress from 'cli-progress';
import { PATHS } from './src/constants/paths';
import { sleep } from './src/utils/misc';
import { log, title } from './src/utils/logger';
import Home from './src/pages/Home';
import { Server } from './src/utils/TLS/GotTLS';
import { Authenticate } from './src/utils/Authentication/Login';

Server.connect();

const version: string = Package.version;

interface Config {
    capmonsterKey: string;
    rpc: string;
    key: string;
    alchemyKey: string;
    etherscanKey: string;
};

class Main {
    private directory(): void {
        const defaultConfig: Config = {
            "capmonsterKey": "",
            "rpc": "",
            "key": "",
            "alchemyKey": "",
            "etherscanKey": "",
        };

        if (!fs.existsSync(PATHS.config)) {
            log('misc', `Creating config file in ${PATHS.config}`);

            try {
                fs.writeFileSync(PATHS.config, JSON.stringify(defaultConfig, null, 4), 'utf-8');

                return;
            } catch (err: unknown) {
                log('error', 'Unknown error while creating config file!');

                return;
            };
        } else {
            return;
        };
    };

    private makeCoolLoader = async (): Promise<void> => {
        try {
            let value: number = 0;

            const bar: cliProgress.Bar = new cliProgress.Bar({
                stopOnComplete: true,
                format: 'Progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}',
                barsize: 65,
            }, cliProgress.Presets.shades_grey);

            bar.start(Math.floor(Math.random() * (500 - 250 + 1) + 250), 0);

            const timer = await setInterval(async () => {
                value += 3;

                bar.update(value);

                if (value >= bar.getTotal()) {
                    clearInterval(timer);

                    await sleep(500);

                    await this.readFiles();
                };
            }, 0.25);

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while loading files!');

            await sleep(2500);

            process.exit();
        };
    };

    private readFiles = async (): Promise<void> => {
        try {
            let x: number = 0;
            let config: boolean = false;

            const files: string[] = fs.readdirSync(process.cwd());

            for (let y = 0; y < files.length; y++) {
                if (files[y].endsWith('csv')) {
                    x++;
                } else if (files[y].endsWith('json') && files[y].includes('incognitoConfig')) {
                    config = true;
                };
            };

            log('misc', `${x} csv file(s) detected!`);

            config ? log('misc', 'Detected JSON config file!') : await this.directory();

            return this.auth();
        } catch (err: unknown) {
            log('error', 'Unknown error while detecting files!');

            await sleep(2500);

            process.exit();
        };
    };

    private auth = async (): Promise<void> => {
        // const response = await Authenticate();

        const response = "good";

        if (response.slice(0, 4) == "good") {
            log('welcome', `Welcome back, ${response.slice(4, response.length)}.`);

            await sleep(2500);

            return new Home().index();
        } else {
            log('error', `Invalid Login!`);

            await sleep(2500);

            process.exit();
        };
    };

    public start = async (): Promise<void> => {
        title(`Incognito CLI - Version ${version} - Authorization`);

        console.clear();

        log('title');

        this.directory();

        log('loading');

        await this.makeCoolLoader();
    };
};

new Main().start();
'''
'''--- package.json ---
{
  "name": "incognito-cli",
  "version": "1.5.16",
  "description": "bot brrr make",
  "main": "index.js",
  "scripts": {
    "start": "ts-node index.ts",
    "dev": "ts-node-dev index.ts"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/aalsa16/incognito-cli.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/aalsa16/incognito-cli/issues"
  },
  "homepage": "https://github.com/aalsa16/incognito-cli#readme",
  "dependencies": {
    "@identity.com/solana-gateway-ts": "^0.8.2",
    "@metaplex-foundation/mpl-token-metadata": "^1.1.0",
    "@solana/buffer-layout": "^3.0.0",
    "@solana/buffer-layout-utils": "^0.2.0",
    "@solana/spl-token": "^0.1.8",
    "@solana/wallet-adapter-base": "^0.9.0",
    "@truffle/hdwallet-provider": "^2.0.4",
    "@types/configstore": "^5.0.1",
    "@types/inquirer": "^8.1.3",
    "@types/node-powershell": "^4.0.1",
    "@types/ps-list": "^6.2.1",
    "@types/sound-play": "^1.1.0",
    "admin-check": "^1.1.3",
    "base-x": "^4.0.0",
    "base58": "^2.0.1",
    "base58-js": "^1.0.0",
    "bn.js": "^5.2.0",
    "borsh": "^0.7.0",
    "bs58": "^4.0.1",
    "capmonster": "^0.0.3",
    "cardano-wallet-js": "^1.3.3",
    "cli-progress": "^3.10.0",
    "colorts": "^0.1.63",
    "configstore": "^6.0.0",
    "configstore-ts": "^0.0.2",
    "crypto": "^1.0.1",
    "csv-parser": "^3.0.0",
    "discord-rich-presence-typescript": "^0.0.8",
    "discord.js": "^13.5.0",
    "ethers": "^5.5.4",
    "fetch-retry-ts": "^1.1.25",
    "figlet": "^1.5.2",
    "got": "^11.8.3",
    "got-tls": "^1.0.6",
    "hcaptcha-solver": "^1.0.2",
    "hpagent": "^0.1.2",
    "inquirer": "^8.2.0",
    "inquirer-file-tree-selection-prompt": "^1.0.18",
    "install": "^0.13.0",
    "is-admin": "^4.0.0",
    "js-sha3": "^0.8.0",
    "jsbi": "^4.2.0",
    "json-rpc-2.0": "^1.0.0",
    "keccak256": "^1.0.6",
    "near-api-js": "^0.44.2",
    "near-seed-phrase": "^0.2.0",
    "node-powershell": "^5.0.1",
    "opensea-js": "^3.0.2",
    "ps-list": "^8.0.0",
    "public-ip": "^5.0.0",
    "pubsub-js": "^1.9.4",
    "rpc-websockets": "^7.4.17",
    "sound-play": "^1.1.0",
    "tweetnacl": "^1.0.3",
    "web3": "^1.7.1"
  },
  "devDependencies": {
    "@project-serum/anchor": "^0.17.0",
    "@solana/web3.js": "^1.41.3",
    "@types/admin-check": "^1.1.0",
    "@types/bs58": "^4.0.1",
    "@types/chalk": "^2.2.0",
    "@types/cli-color": "^2.0.1",
    "@types/cli-progress": "^3.9.2",
    "@types/elliptic": "^6.4.14",
    "@types/figlet": "^1.5.4",
    "@types/pubsub-js": "^1.8.3",
    "i": "^0.3.7",
    "npm": "^8.10.0",
    "ts-node": "^10.4.0",
    "tslint": "^6.1.3",
    "typescript": "^4.5.2"
  }
}

'''
'''--- proxies.txt ---

'''
'''--- spam.js ---
const path = require('path');
const { workerData } = require('worker_threads');

require('ts-node').register();
require(path.resolve(workerData.path));
'''
'''--- src/classes/civic.ts ---
import * as anchor from '@project-serum/anchor';
import { got } from '../utils/TLS/GotTLS';
// @ts-ignore
import capmonster from 'capmonster';
import { log } from '../utils/logger';
import { sleep } from '../utils/misc';

export default class Civic {
    wallet: anchor.Wallet;
    captcha: capmonster;

    constructor(values: {
        wallet: anchor.Wallet;
        captcha: capmonster;

    }) {
        this.wallet = values.wallet;
        this.captcha = values.captcha;
    };

    getRecord = async (publicKey: string): Promise<string> => {
        try {
            const response = await got.get(`https://gatekeeper-api.civic.com/v1/token/solana/${publicKey}?network=mainnet-beta&gatekeeperNetworkAddress=ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6`, {
                headers:  {
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
                    'Accept-Language': 'en-GB,en-US;q=0.9,en;q=0.8',
                    'Cache-Control': 'max-age=0',
                    'Connection': 'keep-alive',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                    'Sec-Fetch-User': '?1',
                    'Upgrade-Insecure-Requests': '1',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36',
                    'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="100", "Google Chrome";v="100"',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '"Windows"',
                }
            });

            switch (response.statusCode) {
                case 404:
                    return 'No record';
                default:
                    return 'Record';
            }
        } catch (err: unknown) {
            log('error', 'Unknown error while fetching civic record!');

            return await this.getRecord(publicKey);
        };
    };

    solve = async (publicKey: string, token: string, proof: string): Promise<boolean> => {
        try {
            let body;
            let method: string = '';
            let url: string = '';

            const record = await this.getRecord(publicKey);

            switch (record) {
                case 'No record':
                    url = `https://gatekeeper-api.civic.com/v1/token/solana?network=mainnet-beta&gatekeeperNetworkAddress=ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6`;

                    method = 'POST';

                    body = {
                        "acceptedDeclaration": "1. You confirm, to your knowledge, that you're not a bot, do in fact breathe oxygen, and may or may not have what is commonly referred to as a soul.",
                        "acceptedTermsAndConditionsLink": "https://www.civic.com/legal/terms-of-service-civic-pass-v1",
                        "address": publicKey,
                        "captchaToken": token,
                        "proof": proof,
                        "provider": "hcaptcha"
                    };

                    break;
                case 'Record':
                    url = `https://gatekeeper-api.civic.com/v1/token/solana/${publicKey}?network=mainnet-beta&gatekeeperNetworkAddress=ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6`;

                    method = 'PATCH';

                    body = {
                        "proof": proof,
                        "request": "refresh",
                        "acceptedDeclaration": "1. You confirm, to your knowledge, that you're not a bot, do in fact breathe oxygen, and may or may not have what is commonly referred to as a soul.",
                        "provider": "hcaptcha",
                        "captchaToken": token
                    };

                    break;
            };

            const response = await got(
                method,
                url,
                {
                    headers: {
                        'accept': '*/*',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'accept-language': 'en-GB,en-US;q=0.9,en;q=0.8',
                        'Connection': 'keep-alive',
                        'Content-Length': String(JSON.stringify(body).length),
                        'content-type': 'application/json',
                        'Host': 'gatekeeper-api.civic.com',
                        'Origin': 'https://getpass.civic.com',
                        'Referer': 'https://getpass.civic.com/',
                        'sec-ch-ua': '" Not;A Brand";v="99", "Google Chrome";v="97", "Chromium";v="97"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"Windows"',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-site',
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36',
                        'X-Civic-Client': '@civic/solana-gateway-react:0.4.12'
                    },
                    json: body
                }
            );

            const res: { state: string } = JSON.parse(response.body);

            switch (res.state) {
                case 'ACTIVE':
                case 'REQUESTED':
                case '{}':
                    return true;
                default:
                    log('error', `Error while solving civic for ${publicKey}... retrying`);

                    return false;
            };
        } catch (err: unknown) {
            log('error', 'Unknown error while solving civic!');

            return false;
        };
    };
    
    makeTransaction = async (connection: anchor.web3.Connection, fromPubkey: anchor.web3.PublicKey, toPubkey: anchor.web3.PublicKey, amount: number): Promise<anchor.web3.Transaction> => {
        try {
            const instruction: anchor.web3.TransactionInstruction = anchor.web3.SystemProgram.transfer({
                fromPubkey: fromPubkey,
                lamports: amount,
                toPubkey: toPubkey
            });
        
            const recentBlockhash: { blockhash: string } = await connection.getRecentBlockhash(
                'confirmed'
            );
        
            return new anchor.web3.Transaction({
                recentBlockhash: recentBlockhash.blockhash,
                feePayer: fromPubkey
            }).add(instruction);
        } catch (err: unknown) {
            log('error', 'Unknown error while solving civic!');

            return await this.makeTransaction(connection, fromPubkey, toPubkey, amount);
        };
    };

    createProof = async (key: anchor.web3.PublicKey, signer: anchor.Wallet): Promise<string> => {
        try {
            const connection: anchor.web3.Connection = new anchor.web3.Connection('https://civic.rpcpool.com/f40a068020b85335d0c8f2783747/', 'confirmed');

            const transaction: anchor.web3.Transaction = await this.makeTransaction(connection, key, key, 0);
        
            await signer.signTransaction(transaction);
        
            const serializedTx = transaction.serialize();
            
            return serializedTx.toString('base64');
        } catch (err: unknown) {
            log('error', 'Unknown error while solving civic!');

            return await this.createProof(key, signer);
        };
    };

    index = async (): Promise<void> => {
        while (true) {
            try {
                let token: any;
        
                const task = await this.captcha.createTask(
                    {
                        "type": "HCaptchaTask",
                        "websiteURL": "https://passv2.civic.com/",
                        "websiteKey": "3fe6bf88-7035-45b7-8f56-c9de61a1ca48"
                    }
                );

                while (!token) {
                    await this.captcha.getResult(task.taskId).then(async (result: { status: string; solution: { gRecaptchaResponse: string } }) => {
                        if (result.status == 'ready') {
                            token = result.solution.gRecaptchaResponse;
                        } else {
                            await sleep(2500);
                        }
                    });
                };

                const proof = await this.createProof(this.wallet.publicKey, this.wallet);
    
                const status: boolean = await this.solve(this.wallet.publicKey.toBase58(), token, proof);
    
                switch (status) {
                    case true:
                        log('success', `Solved civic for wallet: ${this.wallet.publicKey.toBase58()}`);

                        break;
                    default:
                        break;
                };
            } catch (err: unknown) {
                log('error', 'Unknown error while solving civic!');
            };
        };
    };
};
'''
'''--- src/classes/csvReader.ts ---
import fs from 'fs';
import csv from 'csv-parser';
import { log } from '../utils/logger';
import { sleep } from '../utils/misc';

export default class CsvReader {
    path: string;

    constructor(file: {
        path: string;
    }) {
        this.path = file.path;
    };

    public writeTasks = async (amount: number, options: string[]): Promise<void> => {
        try {
            let data: string = options.join(',');

            fs.writeFileSync(this.path, 'mode,privatekey,cmid,rpc,delay\n');
            
            for (let x = 0; x < amount; x++) {
                fs.appendFile(this.path, data + '\n', () => {});

                log('success', `Successfully saved task ${x}`);
            };

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while saving tasks!');

            await sleep(2500);

            return;
        };
    };

    public writeETHTasks = async (amount: number, options: string[]): Promise<void> => {
        try {
            let data: string = options.join(',');

            fs.writeFileSync(this.path, 'mode,privatekey,contractAddress,mintFunction,mintParameters,mintPrice,startTime,gasLimit,maxFee,maxPriority\n');
            
            for (let x = 0; x < amount; x++) {
                fs.appendFile(this.path, data + '\n', () => {});

                log('success', `Successfully saved task ${x}`);
            };

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while saving tasks!');

            await sleep(2500);

            return;
        };
    };

    public writeNEARTasks = async (amount: number, options: string[]): Promise<void> => {
        try {
            let data: string = options.join(',');

            fs.writeFileSync(this.path, 'mode,privateKey,monitorInput,accountName,price\n');
            
            for (let x = 0; x < amount; x++) {
                fs.appendFile(this.path, data + '\n', () => {});

                log('success', `Successfully saved task ${x}`);
            };

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while saving tasks!');

            await sleep(2500);

            return;
        };
    };

    public correctForm = async (): Promise<void> => {
        try {
            let x: number = 2;

            fs.createReadStream(this.path)
                .pipe(csv())
                .on('data', (data: {
                    mode: string;
                    privatekey: string;
                    cmid: string;
                    rpc: string;
                    delay: string;
                }): void => {
                    try {
                        if (data.mode && data.privatekey && data.cmid && data.rpc && data.delay) {
                            log('success', `Line ${x} has a correct task format!`);
                        } else {
                            log('error', `Line ${x} does not have a correct task format!`);
                        };
                    } catch (err: unknown) {
                        log('error', `Unknown error while checking task format on line ${x}!`);
                    };

                    x++;
                })
                .on('end', (): void => {
                    log('misc', `Finished checking task format!`);
                });

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while checking tasks format!');

            await sleep(2500);

            return;
        };
    };

    public returnTasks = async (): Promise<any> => {
        try {
            let x: number = 2;
            let tasks: {
                mode: string;
                wallet: string;
                cmid: string;
                rpc: string;
                delay: number;
            }[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privatekey: string;
                        cmid: string;
                        rpc: string;
                        delay: string;
                    }): void => {
                        try {
                            tasks.push({
                                mode: data.mode,
                                wallet: data.privatekey,
                                cmid: data.cmid,
                                rpc: data.rpc,
                                delay: parseInt(data.delay)
                            });
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching task on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(tasks);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while returning tasks!');

            await sleep(2500);

            return;
        };
    };

    public returnETHTasks = async (): Promise<any> => {
        try {
            let x: number = 2;
            let tasks: {
                mode: string;
                privatekey: string;
                contractAddress: string;
                mintFunction: string;
                mintParameters: string;
                mintPrice: string;
                startTime: string;
                gasLimit: string;
                maxFee: string;
                maxPriority: string;
            }[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privatekey: string;
                        contractAddress: string;
                        mintFunction: string;
                        mintParameters: string;
                        mintPrice: string;
                        startTime: string;
                        gasLimit: string;
                        maxFee: string;
                        maxPriority: string;
                    }): void => {
                        try {
                            tasks.push({
                                mode: data.mode,
                                privatekey: data.privatekey,
                                contractAddress: data.contractAddress,
                                mintFunction: data.mintFunction,
                                mintParameters: data.mintParameters,
                                mintPrice: data.mintPrice,
                                startTime: data.startTime,
                                gasLimit: data.gasLimit,
                                maxFee: data.maxFee,
                                maxPriority: data.maxPriority,
                            });
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching task on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(tasks);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while returning tasks!');

            await sleep(2500);

            return;
        };
    };

    public returnNEARTasks = async (): Promise<any> => {
        try {
            let x: number = 2;
            let tasks: {
                mode: string;
                privateKey: string;
                monitorInput: string;
                accountName: string;
                price: string;
            }[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privateKey: string;
                        monitorInput: string;
                        accountName: string;
                        price: string;
                    }): void => {
                        try {
                            tasks.push({
                                mode: data.mode,
                                privateKey: data.privateKey,
                                monitorInput: data.monitorInput,
                                accountName: data.accountName,
                                price: data.price,
                            });
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching task on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(tasks);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while returning tasks!');

            await sleep(2500);

            return;
        };
    };

    public returnPrivateKeys = async (): Promise<any> => {
        try {
            let x: number = 2;
            let privateKeys: string[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privatekey: string;
                        cmid: string;
                        rpc: string;
                        delay: string;
                    }): void => {
                        try {
                            if (!privateKeys.includes(data.privatekey)) privateKeys.push(data.privatekey);
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching wallet on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(privateKeys);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while fetching wallets!');

            await sleep(2500);

            return;
        };
    };

    public returnETHPrivateKeys = async (): Promise<any> => {
        try {
            let x: number = 2;
            let privateKeys: string[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privatekey: string;
                        contractAddress: string;
                        mintFunction: string;
                        mintParameters: string;
                        mintPrice: string;
                        startTime: string;
                        gasLimit: string;
                        maxFee: string;
                        maxPriority: string;
                    }): void => {
                        try {
                            if (!privateKeys.includes(data.privatekey)) privateKeys.push(data.privatekey);
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching wallet on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(privateKeys);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while fetching wallets!');

            await sleep(2500);

            return;
        };
    };

    public returnNEARKeys = async (): Promise<any> => {
        try {
            let x: number = 2;
            let privateKeys: string[] = [];

            return await new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(csv())
                    .on('error', (err: unknown) => reject(err))
                    .on('data', (data: {
                        mode: string;
                        privateKey: string;
                        monitorInput: string;
                        accountName: string;
                        price: string;
                    }): void => {
                        try {
                            if (!privateKeys.includes(data.accountName)) privateKeys.push(data.accountName);
                        } catch (err: unknown) {
                            log('error', `Unknown error while fetching wallet on line ${x}!`);
                        };

                        x++;
                    })
                    .on('end', () => {
                        resolve(privateKeys);
                    });
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while fetching wallets!');

            await sleep(2500);

            return;
        };
    };

};
'''
'''--- src/classes/pages/Ethereum/Ethereum.ts ---
import got from "got/dist/source";
import inquirer from "inquirer";
import { PATHS } from "../../../constants/paths";
import ContractMint from "../../../modules/Ethereum/ContractMint";
import { log } from "../../../utils/logger";
import { sleep } from "../../../utils/misc";
import CsvReader from "../../csvReader";
import fs from 'fs';
import CancelTX from "../../../modules/Ethereum/CancelTX";
import Sniper from "../../../modules/Ethereum/Opensea";
import { createPrompt } from "../../../utils/misc";

export abstract class Ethereum {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public createTasks = async (): Promise<void> => {
        try {
            const mode: { choice: string } = await inquirer.prompt([
                {
                    name: 'choice',
                    type: 'list',
                    message: `Select module`.magenta,
                    choices: [
                        'Ethereum Contract',
                        'Opensea',
                        'Back'
                    ]
                }
            ]);
    
            if (mode.choice == 'Back') {
                return;
            } else if (mode.choice == 'Ethereum Contract') {
                const privateKey = await createPrompt('password', 'Input wallet private key: ', true);

                const contractAddress = await createPrompt('input', 'Input contract address: ', false);

                const mintFunction = await createPrompt('input', 'Input mint function name: ', false);

                const mintParameters = await createPrompt('input', 'Input mint parameters (separated by semicolon): ', false);

                const mintPrice = await createPrompt('input', 'Input total mint price: ', false);

                const startTime = await createPrompt('input', 'Input start timestamp: ', false);

                const maxFee = await createPrompt('input', 'Input max gas fee: ', false);

                const maxPriority = await createPrompt('input', 'Input max priority fee: ', false);

                const file = await createPrompt('input', 'Input name for csv file: ', false);
        
                if (!file || !privateKey || !contractAddress || !mintFunction || !mintParameters || !mintPrice || !startTime || !maxFee || !maxPriority) {
                    log('error', 'One or more inputs are blank!');
        
                    await sleep(2500);
        
                    return;
                };
    
                await new CsvReader({ path: `${process.cwd()}\\${file}` }).writeETHTasks(1, [ mode.choice.trim(), privateKey.trim(), contractAddress.trim(), mintFunction.trim(), mintParameters.trim(), mintPrice.trim(), startTime.trim(), "auto", maxFee.trim(), maxPriority.trim() ]);
    
                await sleep(2500);
    
                return;
            } else {
                const privateKey = await createPrompt('password', 'Input wallet private key: ', true);

                const contractAddress = await createPrompt('input', 'Input collection: ', false);

                const mintPrice = await createPrompt('input', 'Input total max price: ', false);

                const maxFee = await createPrompt('input', 'Input max gas fee: ', false);

                const maxPriority = await createPrompt('input', 'Input max priority fee: ', false);
    
                const mintParameters = await createPrompt('input', 'Input discord webhook (leave blank for none): ', false);

                const file = await createPrompt('input', 'Input name for csv file: ', false);
        
                if (!file || !privateKey || !contractAddress || !mintPrice || !maxFee || !maxPriority || !mintParameters) {
                    log('error', 'One or more inputs are blank!');
        
                    await sleep(2500);
        
                    return;
                };
    
                await new CsvReader({ path: `${process.cwd()}\\${file}` }).writeETHTasks(1, [ mode.choice.trim(), privateKey.trim(), contractAddress.trim(), "null", mintParameters.trim(), mintPrice.trim(), "null", "auto", maxFee.trim(), maxPriority.trim() ]);
    
                await sleep(2500);
    
                return;
            }
        } catch (err: unknown) {
            log('error', 'Unknown error while creating tasks!');

            await sleep(2500);
            
            return;
        };
    };

    private getContractABI = async (contractId: string, etherscanKey: string): Promise<string> => {
        try {
            const response = await got.get(`https://api.etherscan.io/api?module=contract&action=getabi&address=${contractId}&apikey=${etherscanKey}`, {
                headers: {
                    'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36",
                    "upgrade-insecure-requests": "1",
                }
            });

            return response.body;
        } catch (err: unknown) {
            log('error', `Error getting contract ABI...`);

            await sleep(500);

            return this.getContractABI(contractId, etherscanKey);
        };
    }

    public startTasks = async (): Promise<void> => {
        try {
            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = await new CsvReader(answers);
                    let config = fs.readFileSync(PATHS.config, 'utf-8');

                    const tasks: {
                        mode: string;
                        privatekey: string;
                        contractAddress: string;
                        mintFunction: string;
                        mintParameters: string;
                        mintPrice: string;
                        startTime: string;
                        gasLimit: string;
                        maxFee: string;
                        maxPriority: string;
                        providerUrl: string;
                        abi: any;
                    }[] = await parser.returnETHTasks();

                    if (tasks[0].mode == 'Ethereum Contract') {
                        const abi = await this.getContractABI(tasks[0].contractAddress, JSON.parse(config).etherscanKey);

                        tasks.forEach(async (task: {
                            mode: string;
                            privatekey: string;
                            contractAddress: string;
                            mintFunction: string;
                            mintParameters: string;
                            mintPrice: string;
                            startTime: string;
                            gasLimit: string;
                            maxFee: string;
                            maxPriority: string;
                            providerUrl: string;
                            abi: any;
                        }): Promise<void> => {
                            let child = task;

                            child.providerUrl = JSON.parse(config).alchemyKey;

                            child.abi = JSON.parse(abi);

                            await new ContractMint(child).start();
                        });
                    } else if (tasks[0].mode == 'Opensea') {
                        tasks.forEach(async (task: {
                            mode: string;
                            privatekey: string;
                            contractAddress: string;
                            mintFunction: string;
                            mintParameters: string;
                            mintPrice: string;
                            startTime: string;
                            gasLimit: string;
                            maxFee: string;
                            maxPriority: string;
                            providerUrl: string;
                        }): Promise<void> => {
                            let child = task;

                            child.providerUrl = JSON.parse(config).alchemyKey;

                            await new Sniper(child).start();
                        });
                    }
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.startTasks();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while starting tasks!');

            await sleep(2500);

            return;
        };
    };

    public startCancelTasks = async (): Promise<void> => {
        try {
            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);
                    let config: any = fs.readFileSync(PATHS.config, 'utf-8');

                    const tasks: {
                        mode: string;
                        privatekey: string;
                        contractAddress: string;
                        mintFunction: string;
                        mintParameters: string;
                        mintPrice: string;
                        startTime: string;
                        gasLimit: string;
                        maxFee: string;
                        maxPriority: string;
                        providerUrl: string;
                        abi: any;
                    }[] = await parser.returnETHTasks();

                    const abi = await this.getContractABI(tasks[0].contractAddress, JSON.parse(config).etherscanKey);

                    tasks.forEach(async (task: {
                        mode: string;
                        privatekey: string;
                        contractAddress: string;
                        mintFunction: string;
                        mintParameters: string;
                        mintPrice: string;
                        startTime: string;
                        gasLimit: string;
                        maxFee: string;
                        maxPriority: string;
                        providerUrl: string;
                        abi: any;
                    }): Promise<void> => {
                        let child = task;

                        child.providerUrl = JSON.parse(config).alchemyKey;

                        child.abi = JSON.parse(abi);

                        await new CancelTX(child).start();
                    });
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.startTasks();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while starting tasks!');

            await sleep(2500);

            return;
        };
    };
};
'''
'''--- src/classes/pages/Ethereum/Utils.ts ---
import inquirer from "inquirer";
import Package from '../../../../package.json';
import inquirerFileTreeSelection from 'inquirer-file-tree-selection-prompt';
import { log, title } from "../../../utils/logger";
import CsvReader from "../../csvReader";
import { returnConfig, sleep } from "../../../utils/misc";
import { ethers } from "ethers";

inquirer.registerPrompt('file-tree-selection', inquirerFileTreeSelection);

const version: string = Package.version;

export abstract class Utils {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public checkFunds = async (): Promise<void> => {
        try {
            title(`Incognito CLI - Version ${version} - Utils - Checking funds`);

            const config = JSON.parse(returnConfig());
            const provider = new ethers.providers.JsonRpcProvider(config.alchemyKey);

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnETHPrivateKeys();

                    for (let x = 0; x < privateKeys.length; x++) {
                        while (true) {
                            try {
                                const wallet = new ethers.Wallet(privateKeys[x], provider);
                                log('misc', `Wallet ${wallet["address"]} has ${ethers.utils.formatEther(await provider.getBalance(wallet["address"])).slice(0, -11)} ETH`)

                                break;
                            } catch (err: unknown) {
                                log('error', 'Error while fetching funds');

                                await sleep(1500);
                            };
                        };
                    };

                    log('success', 'Successfully fetched all wallet funds!');

                    await sleep(5000);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.checkFunds();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while checking funds!');

            await sleep(2500);

            return;
        };
    };
};
'''
'''--- src/classes/pages/NEAR/NEAR.ts ---
import inquirer from 'inquirer';
import Paras from '../../../modules/NEAR/Paras';
import { log } from '../../../utils/logger';
import { createPrompt, sleep } from '../../../utils/misc';
import Contract from '../../../modules/NEAR/Contract';
import CsvReader from '../../csvReader';

export abstract class NEAR {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public createTasks = async (): Promise<void> => {
        try {
            const mode: { choice: string } = await inquirer.prompt([
                {
                    name: 'choice',
                    type: 'list',
                    message: `Select module`.magenta,
                    choices: [
                        'Contract',
                        'Paras',
                        'Back'
                    ]
                }
            ]);

            const privateKey = await createPrompt('password', 'Input wallet private key: ', true);

            const monitorInput = await createPrompt('input', 'Input monitor input: ', false);

            const accountName = await createPrompt('input', 'Input account name: ', false);

            const price = await createPrompt('input', 'Input price: ', false);

            const amount = await createPrompt('input', 'Input amount of tasks to save: ', false);

            const file = await createPrompt('input', 'Input name for csv file: ', false);

            if (!privateKey || !monitorInput || !accountName || !price || !file) {
                log('error', 'One or more inputs are blank!');

                await sleep(2500);

                return;
            };
            
            await new CsvReader({ path: `${process.cwd()}\\${file}` }).writeNEARTasks(parseInt(amount.trim()), [ mode.choice.trim(), privateKey.trim(), monitorInput.trim(), accountName.trim(), price.trim() ]);

            await sleep(2500);

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while creating tasks!');

            await sleep(2500);

            return;
        };
    };

    public startTasks = async (): Promise<void> => {
        try {
            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const tasks: {
                        mode: string;
                        privateKey: string;
                        monitorInput: string;
                        accountName: string;
                        price: string;
                    }[] = await parser.returnNEARTasks();

                    tasks.forEach(async (task: {
                        mode: string;
                        privateKey: string;
                        monitorInput: string;
                        accountName: string;
                        price: string;
                    }): Promise<void> => {
                        if (task.mode = "Paras") {
                            await new Paras(task).start();
                        } else {
                            await new Contract(task).mint();
                        }
                    });
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.startTasks();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while starting tasks!');

            await sleep(2500);

            return;
        };
    }
};
'''
'''--- src/classes/pages/NEAR/Utils.ts ---
import inquirer from "inquirer";
import Package from '../../../../package.json';
import inquirerFileTreeSelection from 'inquirer-file-tree-selection-prompt';
import { log, title } from "../../../utils/logger";
import CsvReader from "../../csvReader";
import { sleep } from "../../../utils/misc";
import * as nearAPI from "near-api-js";

inquirer.registerPrompt('file-tree-selection', inquirerFileTreeSelection);

const version: string = Package.version;

export abstract class Utils {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public checkFunds = async (): Promise<void> => {
        try {
            title(`Incognito CLI - Version ${version} - Utils - Checking funds`);

            const keyStore = new nearAPI.keyStores.InMemoryKeyStore();

            const config = {
                networkId: "mainnet",
                nodeUrl: "https://rpc.mainnet.near.org",
                walletUrl: "https://wallet.mainnet.near.org",
                helperUrl: "https://helper.mainnet.near.org",
                explorerUrl: "https://explorer.mainnet.near.org",
                keyStore
            };

            //@ts-ignore
            const near = await nearAPI.connect(config);

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnNEARKeys();

                    for (let x = 0; x < privateKeys.length; x++) {
                        while (true) {
                            try {
                                const account = await near.account(privateKeys[x]);
                                log('misc', `Wallet ${privateKeys[x].slice(0, -10)} has ${parseFloat((await account.getAccountBalance())['total']) / Math.pow(10, 24) } NEAR`)

                                break;
                            } catch (err: unknown) {
                                log('error', 'Error while fetching funds');
                                console.log(err);

                                await sleep(1500);
                            };
                        };
                    };

                    log('success', 'Successfully fetched all wallet funds!');

                    await sleep(5000);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.checkFunds();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while checking funds!');

            await sleep(2500);

            return;
        };
    };
};
'''
'''--- src/classes/pages/Settings.ts ---
import inquirer from "inquirer";
import { log, title } from "../../utils/logger";
import fs from 'fs';
import { returnConfig, sleep } from "../../utils/misc";
import Package from '../../../package.json';
import { PATHS } from "../../constants/paths";

const version: string = Package.version;

export abstract class Settings {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public setSetting = async (titleName: string, setting: string, message: string, successMessage: string): Promise<boolean> => {
        try {
            const config: string = returnConfig();
            const update = JSON.parse(config);
    
            title(`Incognito CLI - Version ${version} - Settings - ${titleName}`);
    
            const key: { input: string } = await inquirer.prompt([
                {
                    name: 'input',
                    type: 'input',
                    message: `${message} (blank input to go back): `.cyan,
                }
            ]);
    
            if (!key.input) {
                return false;
            };
    
            update[`${setting}`] = key.input.trim();
    
            fs.writeFileSync(PATHS.config, JSON.stringify(update, null, 4), 'utf-8')
    
            log('success', `${successMessage}`);
    
            await sleep(2500);
    
            return true;
        } catch (err: unknown) {
            log('error', 'An unknown error has occurred!');

            await sleep(2500);

            return false;
        };
    };
};
'''
'''--- src/classes/pages/Solana/Monitors.ts ---
import inquirer from "inquirer";
import CandyMachineMonitor from "../../../modules/Solana/monitors/CandyMachineMonitor";
import * as anchor from '@project-serum/anchor';
import { log } from "../../../utils/logger";
import { createPrompt, sleep } from "../../../utils/misc";
import LaunchpadMonitor from "../../../modules/Solana/monitors/LaunchpadMonitor";

export abstract class Monitors {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public beginMonitor = async (type: string): Promise<void> => {
        try {
            const id = await createPrompt('input', 'Input candy machine id to monitor: ', false);

            const delay = await createPrompt('input', 'Input monitor delay: ', false);

            if (type == 'cm') {
                await new CandyMachineMonitor({
                    cmid: new anchor.web3.PublicKey(id.trim()),
                    delay: parseInt(delay.trim())
                }).monitor();
            } else if (type == 'me') {
                await new LaunchpadMonitor({
                    cmid: new anchor.web3.PublicKey(id.trim()),
                    delay: parseInt(delay.trim())
                }).monitor();
            };
        } catch (err: unknown) {
            log('error', 'Unknown error while monitoring!');

            await sleep(1500);

            return this.beginMonitor(type);
        };
    };
};
'''
'''--- src/classes/pages/Solana/Solana.ts ---
import inquirer from "inquirer";
import { log } from "../../../utils/logger";
import { createPrompt, sleep } from "../../../utils/misc";
import CsvReader from "../../csvReader";
import { Worker } from 'worker_threads';
import os from 'os';
import path from 'path';

export abstract class Solana {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public createTasks = async (): Promise<void> => {
        try {
            let tasksMode: string = '';

            const mode: { choice: string } = await inquirer.prompt([
                {
                    name: 'choice',
                    type: 'list',
                    message: `Select module`.magenta,
                    choices: [
                        'Candy Machine',
                        'Magic Eden Launchpad',
                        // 'Nova Launch',
                        'MonkeLabs',
                        'SolPort (Taiyo Robotics)',
                        'Back'
                    ]
                }
            ]);

            if (mode.choice == 'Back') return;

            mode.choice == 'Candy Machine' ? tasksMode = 'cm' : mode.choice == 'Nova Launch' ? tasksMode = 'nl' : mode.choice == 'Magic Eden Launchpad' ? tasksMode = 'me' : mode.choice == 'MonkeLabs' ? tasksMode = 'ml' : mode.choice == 'SolPort (Taiyo Robotics)' ? tasksMode = 'sp' : null;

            const privateKey = await createPrompt('password', 'Input wallet private key: ', true);

            const id = await createPrompt('input', 'Input candy machine id: ', false);

            const rpc = await createPrompt('input', 'Input rpc: ', false);

            const delay = await createPrompt('input', 'Input retry delay (in milliseconds): ', false);

            const amount = await createPrompt('input', 'Input amount of tasks to save: ', false);

            const file = await createPrompt('input', 'Input name for csv file: ', false);

            if (!privateKey || !id || !rpc || !delay || !amount || !file) {
                log('error', 'One or more inputs are blank!');

                await sleep(2500);

                return;
            };

            await new CsvReader({ path: `${process.cwd()}\\${file}` }).writeTasks(parseInt(amount.trim()), [tasksMode.trim(), privateKey.trim(), id.trim(), rpc.trim(), delay.trim()]);

            await sleep(2500);

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while creating tasks!');

            await sleep(2500);

            return;
        };
    };

    public startTasks = async (): Promise<void> => {
        try {
            let workers: Worker[] = [];

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const tasks: {
                        mode: string;
                        wallet: string;
                        cmid: string;
                        rpc: string;
                        delay: number;
                        task: number;
                        limit: number;
                        timestamp: number;
                        launchpadProgramId: string;
                        launchpadFeeAddress: string;
                        generateDataEncoding: string;
                        generateHashEncoding: string;
                        metadataConfigAccountKey: string;
                        Account4: string;
                        Account7: string;
                        Account8: string;
                        instruction: string;
                        data: string;
                        hash: string;
                        paymentMint: string;
                        otherkey: string;
                        tokenmintkey: string;
                        tokenrecipkey: string;
                        mintPrice: number;
                        encodingString: string;
                        s3: string;
                        s4: string;
                    }[] = await parser.returnTasks();

                    let timestamp: string | null | number = await createPrompt('input', 'Input start date (unix form - leave blank if no timestamp): ', false);

                    timestamp == '' ? timestamp = null : timestamp = parseInt(timestamp.trim());

                    if (tasks[0].mode == 'me') {
                        const payment = await createPrompt('input', 'Input payment mint: ', false);

                        tasks.forEach((task: {
                            mode: string;
                            wallet: string;
                            cmid: string;
                            rpc: string;
                            delay: number;
                            task: number;
                            timestamp: string | number | null;
                            paymentMint: string;
                        }) => {
                            task.timestamp = timestamp;
                            task.paymentMint = payment;
                        });
                    } else if (tasks[0].mode == 'sp') {
                        const programId = await createPrompt('input', 'Input programId: ', false);

                        const launchpadFeeAddress = await createPrompt('input', 'Input fee address: ', false);

                        const metadataConfigAccountKey = await createPrompt('input', 'Input config key: ', false);

                        const account4 = await createPrompt('input', 'Input Account4: ', false);

                        const account7 = await createPrompt('input', 'Input Account7: ', false);

                        const account8 = await createPrompt('input', 'Input Account8: ', false);

                        const encoding = await createPrompt('input', 'Input encoding string: ', false);

                        const s3 = await createPrompt('input', 'Input secret 3: ', false);

                        const s4 = await createPrompt('input', 'Input secret 4: ', false);

                        tasks.forEach((task: {
                            mode: string;
                            wallet: string;
                            cmid: string;
                            rpc: string;
                            delay: number;
                            task: number;
                            limit: number;
                            timestamp: string | number | null;
                            launchpadProgramId: string;
                            launchpadFeeAddress: string;
                            metadataConfigAccountKey: string;
                            Account4: string;
                            Account7: string;
                            Account8: string;
                            encodingString: string;
                            s3: string;
                            s4: string;
                        }) => {
                            task.timestamp = timestamp;
                            task.launchpadProgramId = programId.trim();
                            task.launchpadFeeAddress = launchpadFeeAddress.trim();
                            task.metadataConfigAccountKey = metadataConfigAccountKey.trim();
                            task.Account4 = account4.trim();
                            task.Account7 = account7.trim();
                            task.Account8 = account8.trim();
                            task.encodingString = encoding.trim();
                            task.s3 = s3.trim();
                            task.s4 = s4.trim();
                        });
                    } else if (tasks[0].mode == 'ml') {
                        const otherkey = await createPrompt('input', 'Input other key: ', false);

                        const tokenmintkey = await createPrompt('input', 'Input token mint: ', false);

                        const tokenrecipkey = await createPrompt('input', 'Input token recip: ', false);

                        tasks.forEach((task: {
                            mode: string;
                            wallet: string;
                            cmid: string;
                            rpc: string;
                            delay: number;
                            task: number;
                            limit: number;
                            timestamp: string | number | null;
                            otherkey: string;
                            tokenmintkey: string;
                            tokenrecipkey: string;
                        }) => {
                            task.timestamp = timestamp;
                            task.otherkey = otherkey.trim();
                            task.tokenmintkey = tokenmintkey.trim();
                            task.tokenrecipkey = tokenrecipkey.trim();
                        });
                    } else {
                        tasks.forEach((task: {
                            mode: string;
                            wallet: string;
                            cmid: string;
                            rpc: string;
                            delay: number;
                            task: number;
                            timestamp: string | number | null;
                        }) => {
                            task.timestamp = timestamp;
                        });
                    };

                    let tasksPerThread = Math.floor(tasks.length / (os.cpus().length / 4));

                    tasksPerThread == 0 ? tasksPerThread++ : null;

                    for (let x = 0; x < (os.cpus().length / 4); x++) {
                        if (tasks[0].mode == 'me') {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/Launchpad.ts')
                                }
                            }));
                        } else if (tasks[0].mode == 'sp') {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/Solport.ts')
                                }
                            }));
                        } else if (tasks[0].mode == 'ml') {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/Monkelabs.ts')
                                }
                            }));
                        } else if (tasks[0].mode == 'lmnft') {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/LMNFT.ts')
                                }
                            }));
                        } else if (tasks[0].mode == 'temple') {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/TempleMint.ts')
                                }
                            }));
                        } else {
                            workers.push(new Worker(`${process.cwd()}\\spam.js`, {
                                workerData: {
                                    path: path.resolve(__dirname, '../../../modules/Solana/CandyMachine.ts')
                                }
                            }));
                        };
                    };

                    // Divide up all tasks into threads
                    let taskChunks = [];
                    
                    while (tasks.length > 0) {
                        taskChunks.push(tasks.slice(0, tasksPerThread));
                        taskChunks.push(tasks.slice(0, tasksPerThread));
                        tasks.splice(0, tasksPerThread);
                    };

                    for (let x = 0; x < workers.length; x++) {
                        for (let y = 0; y < tasksPerThread; y++) {
                            if (!taskChunks[x]) {
                                break;
                            }
                            workers[x].postMessage(taskChunks[x][y]);
                        }
                    }
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.startTasks();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while starting tasks!');

            await sleep(2500);

            return;
        };
    };
};
'''
'''--- src/classes/pages/Solana/Utils.ts ---
import inquirer from "inquirer";
import Package from '../../../../package.json';
import inquirerFileTreeSelection from 'inquirer-file-tree-selection-prompt';
import { log, title } from "../../../utils/logger";
import CsvReader from "../../csvReader";
import { createPrompt, getByteArray, returnConfig, sleep } from "../../../utils/misc";
import * as anchor from '@project-serum/anchor';
import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Metadata } from '@metaplex-foundation/mpl-token-metadata';
import base58 from "bs58";
import fs from 'fs';
import Civic from "../../civic";
// @ts-ignore
import capmonster from 'capmonster';
import got from "got/dist/source";

inquirer.registerPrompt('file-tree-selection', inquirerFileTreeSelection);

const version: string = Package.version;

export abstract class Utils {
    abstract index(): Promise<void>;
    abstract handleOption(option: string): Promise<void>;

    public solveCivic = async () => {
        try {
            const config: { capmonsterKey: string } = JSON.parse(returnConfig());
            const captcha = new capmonster(config.capmonsterKey);
            
            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnPrivateKeys();

                    privateKeys.forEach((privateKey: string) => {
                        const wallet: anchor.Wallet = new anchor.Wallet(anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(privateKey))));

                        log('misc', `Looping civic for wallet ${wallet.publicKey.toBase58()}`.cyan);

                        new Civic({
                            wallet: new anchor.Wallet(anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(privateKey)))),
                            captcha
                        }).index();
                    });
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.solveCivic();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while solving civic!');

            await sleep(2500);

            return;
        };
    };

    public rpcTester = async () => {
        try {
            const rpcUrl = await createPrompt('input', 'Input rpc to test: ', false);

            const startTime: number = performance.now();

            for (let x = 0; x < 100; x++) {
                await got.post(rpcUrl, {
                    json: {
                        id: 1,
                        jsonrpc: "2.0",
                        method: "getLatestBlockhash",
                        params: [
                            {
                                commitment: "processed"
                            }
                        ]
                    }
                });

                log('misc', `Request ${x} sent!`.cyan);
            };

            const endTime: number = performance.now();

            log('success', `100 RPC calls completed in ${endTime - startTime} milliseconds!`);

            await sleep(2500);

            return;
        } catch (err: unknown) {
            log('error', 'Unknown error while testing RPC!');

            await sleep(2500);

            return;
        };
    };

    public checkFormat = async (): Promise<void> => {
        try {
            title(`Incognito CLI - Version ${version} - Utils - Checking tasks format`);

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    await new CsvReader(answers).correctForm();

                    await sleep(2500);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.checkFormat();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while checking tasks format!');

            await sleep(2500);

            return;
        };
    };

    public checkFunds = async (): Promise<void> => {
        try {
            title(`Incognito CLI - Version ${version} - Utils - Checking funds`);

            const config: { rpc: string } = JSON.parse(returnConfig());
            const connection: anchor.web3.Connection = new anchor.web3.Connection(config.rpc, 'finalized');

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnPrivateKeys();

                    for (let x = 0; x < privateKeys.length; x++) {
                        while (true) {
                            try {
                                const publicKey: anchor.web3.PublicKey = anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(privateKeys[x]))).publicKey;
                                const res = await connection.getAccountInfo(publicKey);

                                res ? log('misc', `Wallet ${publicKey} has ${res.lamports / anchor.web3.LAMPORTS_PER_SOL} SOL`) : log('misc', `Wallet ${publicKey} has 0 SOL`);

                                break;
                            } catch (err: unknown) {
                                log('error', 'Error while fetching funds... Congestion moment???');

                                await sleep(1500);
                            };
                        };
                    };

                    log('success', 'Successfully fetched all wallet funds!');

                    await sleep(2500);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.checkFunds();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while checking funds!');

            await sleep(2500);

            return;
        };
    };

    public displayAllTokensInWallet = async () => {
        try {
            const config: { rpc: string } = JSON.parse(returnConfig());
            const connection: anchor.web3.Connection = new anchor.web3.Connection(config.rpc, 'finalized');

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnPrivateKeys();

                    for (let x = 0; x < privateKeys.length; x++) {
                        const wallet: anchor.web3.Keypair = anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(privateKeys[x])));

                        const nftsmetadata = await Metadata.findDataByOwner(connection, wallet.publicKey.toBase58());

                        if (nftsmetadata.length) {
                            for (const metadata of nftsmetadata) {
                                log('success', `Found 1 token named ${metadata.data.name} in wallet ${wallet.publicKey.toBase58()}`);
                            };
                        } else {
                            log('misc', `No NFTs with metadata to display in wallet ${wallet.publicKey.toBase58()}`);
                        };
                    };

                    await sleep(2500);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.displayAllTokensInWallet();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while displaying NFTs!');

            await sleep(2500);

            return;
        };
    };

    public createWallets = async () => {
        try {
            let wallets: string[] = [];

            const amount: { input: string } = await inquirer.prompt([
                {
                    name: 'input',
                    type: 'input',
                    message: `Enter amount of wallets to create: `.cyan
                }
            ]);

            if (!parseInt(amount.input)) {
                log('error', 'Please enter a valid number.');

                await sleep(2000);

                this.createWallets();
            } else {
                const file: { name: string } = await inquirer.prompt([
                    {
                        name: 'name',
                        type: 'input',
                        message: `Enter file name to save created wallets to (enter .csv at the end): `.cyan
                    }
                ]);

                for (let x = 0; x < parseInt(amount.input); x++) {
                    wallets.push(base58.encode(Buffer.from(anchor.web3.Keypair.generate().secretKey)));
                };

                await fs.writeFileSync(`${process.cwd()}\\${file.name}`, 'privatekey\n');
                
                for (let x = 0; x < wallets.length; x++) {
                    await fs.appendFile(`${process.cwd()}\\${file.name}`, wallets[x] + '\n', () => {});

                    log('success', `Successfully created wallet ${wallets[x]}`);
                };

                await sleep(2500);

                return;
            };
        } catch (err: unknown) {
            log('error', 'Unknown error creating wallets!');

            await sleep(2500);

            return;
        };
    };

    public transferAllNfts = async () => {
        try {
            title(`Incognito CLI - Version ${version} - Utils - Transferring NFTs`);

            const config: { rpc: string } = JSON.parse(returnConfig());
            const connection: anchor.web3.Connection = new anchor.web3.Connection(config.rpc, 'finalized');

            const receiver: { receiver: string } = await inquirer.prompt([
                {
                    name: 'receiver',
                    type: 'password',
                    message: `Enter receiving wallet's private key:`.magenta,
                    mask: '*'
                }
            ]);

            const receivingWallet: anchor.web3.Keypair = anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(receiver.receiver)));

            await inquirer.prompt([
                {
                    type: 'file-tree-selection',
                    name: 'path'
                }
            ]).then(async (answers: { path: string }) => {
                if (answers.path.endsWith('csv')) {
                    const parser: CsvReader = await new CsvReader(answers);

                    const privateKeys: string[] = await parser.returnPrivateKeys();

                    for (let x = 0; x < privateKeys.length; x++) {
                        while (true) {
                            try {
                                const sendingWallet: anchor.web3.Keypair = anchor.web3.Keypair.fromSecretKey(new Uint8Array(getByteArray(privateKeys[x])));
                                const response = await connection.getParsedTokenAccountsByOwner(sendingWallet.publicKey, { programId: TOKEN_PROGRAM_ID });

                                response.value.forEach(async (accountInfo) => {
                                    if (parseInt(accountInfo.account.data.parsed.info.tokenAmount.amount) > 0) {
                                        const fromTokenAccount: anchor.web3.PublicKey = await Token.getAssociatedTokenAddress(
                                            ASSOCIATED_TOKEN_PROGRAM_ID,
                                            TOKEN_PROGRAM_ID,
                                            new anchor.web3.PublicKey(accountInfo.account.data.parsed.info.mint),
                                            sendingWallet.publicKey
                                        );

                                        const toTokenAccount: anchor.web3.PublicKey = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new anchor.web3.PublicKey(accountInfo.account.data.parsed.info.mint), receivingWallet.publicKey);

                                        let transferInstruction: anchor.web3.TransactionInstruction = await Token.createTransferInstruction(
                                            TOKEN_PROGRAM_ID,
                                            fromTokenAccount,
                                            toTokenAccount,
                                            sendingWallet.publicKey,
                                            [sendingWallet],
                                            parseInt(accountInfo.account.data.parsed.info.tokenAmount.amount)
                                        );

                                        const tx: string = await connection.sendTransaction(new anchor.web3.Transaction().add(transferInstruction), [sendingWallet]);

                                        log('success', `Sent NFTs! TX: ${tx}`);

                                        await sleep(1500);
                                    } else {
                                        log('misc', `No NFT to send.`);
                                    };
                                });

                                break;
                            } catch (err: unknown) {
                                log('error', 'Error while sending NFTs... Congestion moment???');

                                await sleep(1500);
                            };
                        }
                    };

                    await sleep(2500);

                    return;
                } else {
                    log('error', 'Please select a CSV file!');

                    return this.transferAllNfts();
                };
            });
        } catch (err: unknown) {
            log('error', 'Unknown error while sending NFTs!');

            await sleep(2500);

            return;
        };
    };
};
'''
'''--- src/constants/Solana/functions.ts ---
import * as anchor from '@project-serum/anchor';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import constants from './publicKeys';
import got from 'got';

export const getAtaForMint = async (
    mint: anchor.web3.PublicKey,
    buyer: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return await anchor.web3.PublicKey.findProgramAddress(
        [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
        constants.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
    );
};

export const createAssociatedTokenAccountInstruction = (
    associatedTokenAddress: anchor.web3.PublicKey,
    payer: anchor.web3.PublicKey,
    walletAddress: anchor.web3.PublicKey,
    splTokenMintAddress: anchor.web3.PublicKey
): anchor.web3.TransactionInstruction => {
    const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
        { pubkey: walletAddress, isSigner: false, isWritable: false },
        { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
        {
            pubkey: anchor.web3.SystemProgram.programId,
            isSigner: false,
            isWritable: false,
        },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        {
            pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false,
        },
    ];
    return new anchor.web3.TransactionInstruction({
        keys,
        programId: constants.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
        data: Buffer.from([]),
    });
};

export const getNetworkToken = async (
    wallet: anchor.web3.PublicKey,
    gatekeeperNetwork: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return await anchor.web3.PublicKey.findProgramAddress(
        [
            wallet.toBuffer(),
            Buffer.from("gateway"),
            Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),
            gatekeeperNetwork.toBuffer(),
        ],
        constants.CIVIC
    );
};

export const getNetworkExpire = async (
    gatekeeperNetwork: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return await anchor.web3.PublicKey.findProgramAddress(
        [gatekeeperNetwork.toBuffer(), Buffer.from("expire")],
        constants.CIVIC
    );
};

export const getMetadata = async (
    mint: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return (
        await anchor.web3.PublicKey.findProgramAddress(
            [
                Buffer.from("metadata"),
                constants.TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                mint.toBuffer(),
            ],
            constants.TOKEN_METADATA_PROGRAM_ID
        )
    );
};

export const getMasterEdition = async (
    mint: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return (
        await anchor.web3.PublicKey.findProgramAddress(
            [
                Buffer.from("metadata"),
                constants.TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                mint.toBuffer(),
                Buffer.from("edition"),
            ],
            constants.TOKEN_METADATA_PROGRAM_ID
        )
    );
};

export const getCandyMachineCreator = async (
    candyMachine: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("candy_machine"), candyMachine.toBuffer()],
        constants.CANDY_MACHINE_PROGRAM
    );
};

export const getTokenWallet = async (
    wallet: anchor.web3.PublicKey,
    mint: anchor.web3.PublicKey
): Promise<[anchor.web3.PublicKey, number]> => {
    return (
        await anchor.web3.PublicKey.findProgramAddress(
            [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
            constants.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
        )
    );
};

export const getCollectionAuthorityRecordPDA = async (
    mint: anchor.web3.PublicKey,
    newAuthority: anchor.web3.PublicKey,
): Promise<anchor.web3.PublicKey> => {
    return (
        await anchor.web3.PublicKey.findProgramAddress(
            [
                Buffer.from('metadata'),
                constants.TOKEN_METADATA_PROGRAM_ID.toBuffer(),
                mint.toBuffer(),
                Buffer.from('collection_authority'),
                newAuthority.toBuffer(),
            ],
            constants.TOKEN_METADATA_PROGRAM_ID,
        )
    )[0];
};

export const getCollectionPDA = async (
    candyMachineAddress: anchor.web3.PublicKey,
): Promise<[anchor.web3.PublicKey, number]> => {
    return await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from('collection'), candyMachineAddress.toBuffer()],
        constants.CANDY_MACHINE_PROGRAM,
    );
};

export const limit = async (cmid: anchor.web3.PublicKey, payer: anchor.web3.PublicKey) => {
    return anchor.web3.PublicKey.findProgramAddress(
        [
            anchor.utils.bytes.utf8.encode("wallet_limit"),
            cmid.toBuffer(),
            payer.toBuffer(),
        ],
        constants.LAUNCHPAD_PROGRAM
    );
};

export const getLaunchStagesInfo = async (candyMachineId: anchor.web3.PublicKey) => {
    return anchor.web3.PublicKey.findProgramAddress(
        [
            anchor.utils.bytes.utf8.encode("candy_machine"),
            anchor.utils.bytes.utf8.encode("launch_stages"),
            candyMachineId.toBuffer()
        ],
        constants.LAUNCHPAD_PROGRAM
    );
};

async function getChunk(link: string): Promise<string> {
    try {
        const response = await got(link, {
            headers: {
                "sec-ch-ua": '" Not A;Brand";v="99", "Chromium";v="96", "Google Chrome";v="96"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"',
                "sec-fetch-dest": "document",
                "sec-fetch-mode": "navigate",
                "sec-fetch-site": "none",
                "sec-fetch-user": "?1",
                "upgrade-insecure-requests": "1",
                "user-agent":
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36",
            },
        });

        return response.body;
    } catch (err: unknown) {
        return '';
    };
};

export async function getHome(homepage: string): Promise<any> {
    try {
        const response = await got(homepage, {
            headers: {
                "sec-ch-ua": '" Not A;Brand";v="99", "Chromium";v="96", "Google Chrome";v="96"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"',
                "sec-fetch-dest": "document",
                "sec-fetch-mode": "navigate",
                "sec-fetch-site": "none",
                "sec-fetch-user": "?1",
                "upgrade-insecure-requests": "1",
                "user-agent":
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36",
            },
        });

        const body = response.body;

        const chunk = body.substring(
            body.indexOf(`script src="/static/js/`) + 13,
            body.lastIndexOf(`.chunk.js"></script><script src`) + 9
        );

        const chunkBody: string = await getChunk(
            `${homepage}${chunk}`
        );

        const pda_buf = chunkBody.substring(chunkBody.lastIndexOf('REACT_APP_PDA_BUFFER:"') + 22, chunkBody.lastIndexOf('"}).TEST_RETRY_MULTIPLIER'));

        const primary_wallet = chunkBody.substring(chunkBody.lastIndexOf(',REACT_APP_PRIMARY_WALLET:"') + 27, chunkBody.lastIndexOf('",REACT_APP_PDA_BUFFER:'));

        const index_key = chunkBody.substring(chunkBody.lastIndexOf('",REACT_APP_INDEX_KEY:"') + 23, chunkBody.lastIndexOf('",REACT_APP_SOLANA_NETWORK'));

        const config_key = chunkBody.substring(chunkBody.lastIndexOf('",REACT_APP_CONFIG_KEY:"') + 24, chunkBody.lastIndexOf('",REACT_APP_CANDY_MACHINE'));

        const wl_key = chunkBody.substring(chunkBody.lastIndexOf(',REACT_APP_WHITELIST_KEY:"') + 26, chunkBody.lastIndexOf('",REACT_APP_MINT_UUID'));

        return {
            pda_buf: pda_buf,
            primary_wallet: primary_wallet,
            config_key: config_key,
            index_key: index_key,
            wl_key: wl_key
        };
    } catch (err: unknown) {
        console.log("Error getting homepage.");

        return;
    };
};
'''
'''--- src/constants/Solana/publicKeys.ts ---
import * as anchor from '@project-serum/anchor';

export default {
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: new anchor.web3.PublicKey(
        "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
    ),
    TOKEN_METADATA_PROGRAM_ID: new anchor.web3.PublicKey(
        "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
    ),
    NOVA_LAUNCH_PROGRAM: new anchor.web3.PublicKey(
        "nva24Y1vHfhCrCLcqqFLXher9uZR4JjKP4D89MHhkmA"
    ),
    LAUNCHPAD_PROGRAM: new anchor.web3.PublicKey(
        "CMZYPASGWeTz7RNGHaRJfCq2XQ5pYK6nDvVQxzkH51zb"
    ),
    CIVIC: new anchor.web3.PublicKey(
        "gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs",
    ),
    CANDY_MACHINE_PROGRAM: new anchor.web3.PublicKey(
        "cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ"
    ),
    MONKE_LABS: new anchor.web3.PublicKey(
        "minwAEdewYNqagUwzrVBUGWuo277eeSMwEwj76agxYd"
    ),
    LMNFT_PROGRAM: new anchor.web3.PublicKey(
        "ArAA6CZC123yMJLUe4uisBEgvfuw2WEvex9iFmFCYiXv"
    )
};
'''
'''--- src/constants/Solana/types.ts ---
export var TokenInstruction: any;
(function (TokenInstruction) {
    TokenInstruction[TokenInstruction["InitializeMint"] = 0] = "InitializeMint";
    TokenInstruction[TokenInstruction["InitializeAccount"] = 1] = "InitializeAccount";
    TokenInstruction[TokenInstruction["InitializeMultisig"] = 2] = "InitializeMultisig";
    TokenInstruction[TokenInstruction["Transfer"] = 3] = "Transfer";
    TokenInstruction[TokenInstruction["Approve"] = 4] = "Approve";
    TokenInstruction[TokenInstruction["Revoke"] = 5] = "Revoke";
    TokenInstruction[TokenInstruction["SetAuthority"] = 6] = "SetAuthority";
    TokenInstruction[TokenInstruction["MintTo"] = 7] = "MintTo";
    TokenInstruction[TokenInstruction["Burn"] = 8] = "Burn";
    TokenInstruction[TokenInstruction["CloseAccount"] = 9] = "CloseAccount";
    TokenInstruction[TokenInstruction["FreezeAccount"] = 10] = "FreezeAccount";
    TokenInstruction[TokenInstruction["ThawAccount"] = 11] = "ThawAccount";
    TokenInstruction[TokenInstruction["TransferChecked"] = 12] = "TransferChecked";
    TokenInstruction[TokenInstruction["ApproveChecked"] = 13] = "ApproveChecked";
    TokenInstruction[TokenInstruction["MintToChecked"] = 14] = "MintToChecked";
    TokenInstruction[TokenInstruction["BurnChecked"] = 15] = "BurnChecked";
    TokenInstruction[TokenInstruction["InitializeAccount2"] = 16] = "InitializeAccount2";
    TokenInstruction[TokenInstruction["SyncNative"] = 17] = "SyncNative";
    TokenInstruction[TokenInstruction["InitializeAccount3"] = 18] = "InitializeAccount3";
    TokenInstruction[TokenInstruction["InitializeMultisig2"] = 19] = "InitializeMultisig2";
    TokenInstruction[TokenInstruction["InitializeMint2"] = 20] = "InitializeMint2";
    TokenInstruction[TokenInstruction["GetAccountDataSize"] = 21] = "GetAccountDataSize";
    TokenInstruction[TokenInstruction["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
    TokenInstruction[TokenInstruction["AmountToUiAmount"] = 23] = "AmountToUiAmount";
    TokenInstruction[TokenInstruction["UiAmountToAmount"] = 24] = "UiAmountToAmount";
    TokenInstruction[TokenInstruction["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
    TokenInstruction[TokenInstruction["TransferFeeExtension"] = 26] = "TransferFeeExtension";
    TokenInstruction[TokenInstruction["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
    TokenInstruction[TokenInstruction["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
    TokenInstruction[TokenInstruction["Reallocate"] = 29] = "Reallocate";
    TokenInstruction[TokenInstruction["MemoTransferExtension"] = 30] = "MemoTransferExtension";
    TokenInstruction[TokenInstruction["CreateNativeMint"] = 31] = "CreateNativeMint";
})(TokenInstruction || (TokenInstruction = {}));
'''
'''--- src/constants/TLSInterface.ts ---
import type {CookieJar} from 'tough-cookie'

export interface ResponseData {
    id: string;
    method: string;
    statusCode: number;
    url: string;
    headers: Headers;
    body: string;
    success: boolean;
    message: string;
}

export interface RequestData {
    id: string;
    debug?: boolean;
    method: string;
    url: string;
    proxy?: string;
    headers: Headers;
    body?: string;
    timeout?: string;
    redirect?: boolean;
}

export interface ResponseObject {
    statusCode: number;
    headers: Record<string, string | string[]>;
    body: string;
}

export interface Headers {
    [key: string]: any;
}

export interface RequestOptions {
    headers: Record<string, string | string>;
    json?: Record<string, any>;
    body?: string;
    form?: Record<string, any>;
    redirect?: boolean;
    timeout?: string;
    debug?: boolean
    cookieJar?:  CookieJar
    proxy?: string
}

export interface ToughCookieJar {
	getCookieString: ((currentUrl: string, options: Record<string, unknown>, cb: (error: Error | null, cookies: string) => void) => void)
	& ((url: string, callback: (error: Error | null, cookieHeader: string) => void) => void);
	setCookie: ((cookieOrString: unknown, currentUrl: string, options: Record<string, unknown>, cb: (error: Error | null, cookie: unknown) => void) => void)
	& ((rawCookie: string, url: string, callback: (error: Error | null, result: unknown) => void) => void);
}

export interface PromiseCookieJar {
	getCookieString: (url: string) => Promise<string>;
	setCookie: (rawCookie: string, url: string) => Promise<unknown>;
}
'''
'''--- src/constants/paths.ts ---
import { join } from 'path';

export const PATHS = {
    config: join(`${process.cwd()}/incognitoConfig.json`)
};
'''
'''--- src/modules/Ethereum/CancelTX.ts ---
import { ethers, utils } from 'ethers';
import 'colorts/lib/string';
import { sleep } from '../../utils/misc';
import { log } from '../../utils/logger';

export default class CancelTX {
    totalPrice: any;
    mintFunction: any;
    parameters: any;
    privateKey: any;
    providerUrl: any;
    contractId: any;
    abiJson: any;
    maxFeeGas: any;
    maxPriority: any;
    gasLimit: any;
    taskProvider: any;
    taskWallet: any;
    transaction: any;

    constructor(task: any) {
        this.totalPrice = task.mintPrice;
        this.mintFunction = task.mintFunction; 
        this.parameters = task.mintParameters; 
        this.privateKey = task.privatekey;
        this.providerUrl = task.providerUrl;
        this.contractId = task.contractAddress; 
        this.abiJson = task.abi; 
        this.maxFeeGas = task.maxFeeGas;
        this.maxPriority = task.maxPriority;
        this.gasLimit = task.gasLimit;
    }
    
    async start() {
        try {
            await this.initialize();
            await this.connectProvider();
            await this.getTaskWallet();
            await this.buildTx();
            await this.sendTx();
        } catch (error) {
            await sleep(2500);
            this.start();
        }
    }

    async initialize() {
        try {
            this.taskProvider = new ethers.providers.JsonRpcProvider(this.providerUrl);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error initializing task: ${error}`);
        }
    }

    async connectProvider() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Connecting to: ${this.providerUrl}`);
            this.taskProvider = new ethers.providers.JsonRpcProvider(this.providerUrl);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error initializing task: ${error}`);
        }
    }

    async getTaskWallet() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Connecting to wallet...`);
            this.taskWallet = new ethers.Wallet(this.privateKey, this.taskProvider);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error connecting to wallet: ${error}`);
        }
    }

    async buildTx() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Creating new tx...`);

            const fees = await this.taskProvider.getFeeData();

            const contractConfig = { //@ts-ignore
                nonce: await this.taskProvider.getTransactionCount(this.taskWallet["address"]), //@ts-ignore
                from: this.taskWallet["address"],
                type: 2, //@ts-ignore
                to: this.taskWallet["address"],
                maxFeePerGas: parseInt(this.maxFeeGas + 100) * 1000000000,
                maxPriorityFeePerGas: parseInt(this.maxPriority + 100) * 1000000000,
                value: utils.parseEther("0.01"),
                chainId: 1,
            }

            this.transaction = await this.taskWallet?.signTransaction(contractConfig);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error creating new tx: ${error}`);
        }
    }

    async sendTx() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Sending tx`.cyan);
            const tx = await this.taskProvider.sendTransaction(this.transaction);
            log('misc', `[Incognito] - [Ethereum] - Sent ${tx.hash} on ${this.taskWallet?.address}`);
        } catch (error: any) {
            if (error.code == 'INSUFFICIENT_FUNDS') {
                log('error', `[Incognito] - [Ethereum] - ${this.taskWallet?.address} does not have enough funds.`);
            } else {
                log('error', `[Incognito] - [Ethereum] - Error sending tx: ${error}`);
            }
        }
    }
}
'''
'''--- src/modules/Ethereum/ContractMint.ts ---
import { ethers, utils } from 'ethers';
import 'colorts/lib/string';
import { sleep } from '../../utils/misc';
import { log } from '../../utils/logger';

// this stuff is nasty - banana
export default class ContractMint {
    totalPrice: any;
    mintFunction: any;
    parameters: any;
    privateKey: any;
    providerUrl: any;
    contractId: any;
    abiJson: any;
    maxFeeGas: any;
    maxPriority: any;
    gasLimit: any;
    taskProvider: any;
    parsedABI: any;
    taskWallet: any;
    transaction: any;

    constructor(task: any) {
        this.totalPrice = task.mintPrice;
        this.mintFunction = task.mintFunction; 
        this.parameters = task.mintParameters; 
        this.privateKey = task.privatekey;
        this.providerUrl = task.providerUrl;
        this.contractId = task.contractAddress; 
        this.abiJson = task.abi; 
        this.maxFeeGas = task.maxFeeGas;
        this.maxPriority = task.maxPriority;
        this.gasLimit = task.gasLimit;
    }
    
    async start() {
        try {
            await this.initialize();
            await this.connectProvider();
            await this.getABI();
            await this.getTaskWallet();
            await this.buildTx();
            await this.sendTx();
        } catch (error) {
            await sleep(2500);
            this.start();
        }
    }

    async initialize() {
        try {
            this.taskProvider = new ethers.providers.JsonRpcProvider(this.providerUrl);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error initializing task: ${error}`);
        }
    }

    async connectProvider() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Connecting to: ${this.providerUrl}`);
            this.taskProvider = new ethers.providers.JsonRpcProvider(this.providerUrl);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error initializing task: ${error}`);
        }
    }

    async getABI() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Parsing ${this.contractId}'s ABI`);
            this.parsedABI = new ethers.utils.Interface(this.abiJson["result"]);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error grabbing ABI: ${error}`);
        }
    }

    async getTaskWallet() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Connecting to wallet...`);
            this.taskWallet = new ethers.Wallet(this.privateKey, this.taskProvider);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error connecting to wallet: ${error}`);
        }
    }

    async buildTx() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Creating new tx...`);
            //@ts-ignore
            const contract = new ethers.Contract(this.contractId, this.parsedABI, this.taskProvider);
            //@ts-ignore
            const encodedPayload = this.parsedABI.encodeFunctionData(this.mintFunction, this.parameters.split(';'));

            const fees = await this.taskProvider.getFeeData();

            const contractConfig = { //@ts-ignore
                nonce: await this.taskProvider.getTransactionCount(this.taskWallet["address"]), //@ts-ignore
                from: this.taskWallet["address"],
                type: 2,
                to: this.contractId,
                maxFeePerGas: parseInt(this.maxFeeGas) * 1000000000,
                maxPriorityFeePerGas: parseInt(this.maxPriority) * 1000000000,
                //gasLimit: utils.parseEther(fees.gasPrice["BigNumber"]),
                value: utils.parseEther(this.totalPrice),
                chainId: 1,
                data: encodedPayload
            }

            this.transaction = await this.taskWallet?.signTransaction(contractConfig);
        } catch (error) {
            log('error', `[Incognito] - [Ethereum] - Error creating new tx: ${error}`);
        }
    }

    async sendTx() {
        try {
            log('misc', `[Incognito] - [Ethereum] - Sending tx`.cyan);
            const tx = await this.taskProvider.sendTransaction(this.transaction);
            log('misc', `[Incognito] - [Ethereum] - Sent ${tx.hash} on ${this.taskWallet?.address}`);
        } catch (error: any) {
            if (error.code == 'INSUFFICIENT_FUNDS') {
                log('error', `[Incognito] - [Ethereum] - ${this.taskWallet?.address} does not have enough funds.`);
            } else {
                log('error', `[Incognito] - [Ethereum] - Error sending tx: ${error}`);
            }
        }
    }
}
'''
'''--- src/modules/Ethereum/Opensea.ts ---
import { ethers, utils } from 'ethers';
import 'colorts/lib/string';
import { sleep } from '../../utils/misc';
import { got } from '../../utils/TLS/GotTLS';
import { log } from '../../utils/logger';
import { OpenSeaPort, Network } from 'opensea-js';
import HDWalletProvider from '@truffle/hdwallet-provider';

// this stuff is nasty - banana
export default class Sniper {
    public totalPrice: any;
	public mintFunction: any;
	public parameters: any;
	public privateKey: any;
	public alchemyKey: any;
	public contractId: any;
	public webhook: any;
	public abiJson: any;
	public maxFeeGas: any;
	public signer: any;
	public walletAddress: any;
	public mintContract: any;
	public parametersDefault: any;
	public gasPriceMode: any;
    public providerUrl: any;
    public taskProvider: any;
    public taskWallet: ethers.Wallet | undefined;
    public parsedABI: ethers.utils.Interface | undefined;
    public transaction: string | undefined;
    public maxPriority: any;
    public gasLimit: any;
    public seaport: OpenSeaPort | undefined;
    public osProvider: HDWalletProvider | undefined;

    constructor(task: any) {
        this.totalPrice = task.mintPrice;
        this.mintFunction = task.mintFunction; 
        this.parameters = task.mintParameters; 
        this.privateKey = task.privatekey;
        this.providerUrl = task.providerUrl;
        this.contractId = task.contractAddress; 
        this.maxFeeGas = task.maxFeeGas;
        this.maxPriority = task.maxPriority;
        this.gasLimit = task.gasLimit;
    }
    
    async start() {
        try {
            await this.initialize();
            await this.getTaskWallet();
            await this.monitor();
        } catch (error) {
            await sleep(2500);
            this.start();
        }
    }

    async initialize() {
        try {
            this.taskProvider = new ethers.providers.JsonRpcProvider(this.providerUrl);
            this.osProvider = new HDWalletProvider(this.privateKey, this.providerUrl);
            this.seaport = new OpenSeaPort(this.osProvider, {
                networkName: Network.Main,
                apiKey: `2994802c1238407bbd86f3700070703b`,
            }, (arg) => {});
        } catch (error) {
            log('error', `Error initializing task: ${error}`.red);
        }
    }

    async getTaskWallet() {
        try {
            log('misc', `Connecting to wallet...`);
            this.taskWallet = new ethers.Wallet(this.privateKey, this.taskProvider);
        } catch (error) {
            log('error', `Error connecting to wallet: ${error}`);
        }
    }

    async monitor() {
        try {
            while (true) {
                log('misc', `Monitoring: ${this.contractId}`);
                const response = await got.post("https://api.opensea.io/graphql/", {
                    headers: {
                        "accept-language": "en-US,en;q=0.9",
                        "Cache-Control":'private, max-age=0, no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
                        "content-type": "application/json",
                        "sec-ch-ua": "\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"97\", \"Chromium\";v=\"97\"",
                        "sec-ch-ua-mobile": "?0",
                        "sec-ch-ua-platform": "\"Windows\"",
                        "sec-fetch-dest": "empty",
                        "sec-fetch-mode": "cors",
                        "sec-fetch-site": "same-site",
                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36",
                        "x-api-key": "2f6f419a083c46de9d83ce3dbe7db601",
                        "x-build-id": "BBoIbfl7o7p7qFpNB31WS",
                        "x-signed-query": "ac90cef79e9898a9e0d2dea265a5355bd39307f6ecd89239bdc6a5a11c408bc8",
                        "Referer": "https://opensea.io/",
                        "Referrer-Policy": "strict-origin"
                    },
                    body: JSON.stringify({
                        id: "AssetSearchQuery",
                        query: `query AssetSearchQuery(\n  $categories: [CollectionSlug!]\n  $chains: [ChainScalar!]\n  $collection: CollectionSlug\n  $collectionQuery: String\n  $collectionSortBy: CollectionSort\n  $collections: [CollectionSlug!]\n  $count: Int\n  $cursor: String\n  $identity: IdentityInputType\n  $includeHiddenCollections: Boolean\n  $numericTraits: [TraitRangeType!]\n  $paymentAssets: [PaymentAssetSymbol!]\n  $priceFilter: PriceFilterType\n  $query: String\n  $resultModel: SearchResultModel\n  $showContextMenu: Boolean = false\n  $shouldShowQuantity: Boolean = false\n  $sortAscending: Boolean\n  $sortBy: SearchSortBy\n  $stringTraits: [TraitInputType!]\n  $toggles: [SearchToggle!]\n  $creator: IdentityInputType\n  $assetOwner: IdentityInputType\n  $isPrivate: Boolean\n  $safelistRequestStatuses: [SafelistRequestStatus!]\n) {\n  query {\n    ...AssetSearch_data_2hBjZ1\n  }\n}\n\nfragment AssetCardAnnotations_assetBundle on AssetBundleType {\n  assetCount\n}\n\nfragment AssetCardAnnotations_asset_3Aax2O on AssetType {\n  assetContract {\n    chain\n    id\n  }\n  decimals\n  ownedQuantity(identity: $identity) @include(if: $shouldShowQuantity)\n  relayId\n  favoritesCount\n  isDelisted\n  isFavorite\n  isFrozen\n  hasUnlockableContent\n  ...AssetCardBuyNow_data\n  orderData {\n    bestAsk {\n      orderType\n      relayId\n      maker {\n        address\n      }\n    }\n  }\n  ...AssetContextMenu_data_3z4lq0 @include(if: $showContextMenu)\n}\n\nfragment AssetCardBuyNow_data on AssetType {\n  tokenId\n  relayId\n  assetContract {\n    address\n    chain\n    id\n  }\n  collection {\n    slug\n    id\n  }\n  orderData {\n    bestAsk {\n      relayId\n    }\n  }\n}\n\nfragment AssetCardContent_asset on AssetType {\n  relayId\n  name\n  ...AssetMedia_asset\n  assetContract {\n    address\n    chain\n    openseaVersion\n    id\n  }\n  tokenId\n  collection {\n    slug\n    id\n  }\n  isDelisted\n}\n\nfragment AssetCardContent_assetBundle on AssetBundleType {\n  assetQuantities(first: 18) {\n    edges {\n      node {\n        asset {\n          relayId\n          ...AssetMedia_asset\n          id\n        }\n        id\n      }\n    }\n  }\n}\n\nfragment AssetCardFooter_assetBundle on AssetBundleType {\n  ...AssetCardAnnotations_assetBundle\n  name\n  assetCount\n  assetQuantities(first: 18) {\n    edges {\n      node {\n        asset {\n          collection {\n            name\n            relayId\n            slug\n            isVerified\n            ...collection_url\n            id\n          }\n          id\n        }\n        id\n      }\n    }\n  }\n  assetEventData {\n    lastSale {\n      unitPriceQuantity {\n        ...AssetQuantity_data\n        id\n      }\n    }\n  }\n  orderData {\n    bestBid {\n      orderType\n      paymentAssetQuantity {\n        ...AssetQuantity_data\n        id\n      }\n    }\n    bestAsk {\n      closedAt\n      orderType\n      dutchAuctionFinalPrice\n      openedAt\n      priceFnEndedAt\n      quantity\n      decimals\n      paymentAssetQuantity {\n        quantity\n        ...AssetQuantity_data\n        id\n      }\n    }\n  }\n}\n\nfragment AssetCardFooter_asset_3Aax2O on AssetType {\n  ...AssetCardAnnotations_asset_3Aax2O\n  name\n  tokenId\n  collection {\n    slug\n    name\n    isVerified\n    ...collection_url\n    id\n  }\n  isDelisted\n  assetContract {\n    address\n    chain\n    openseaVersion\n    id\n  }\n  assetEventData {\n    lastSale {\n      unitPriceQuantity {\n        ...AssetQuantity_data\n        id\n      }\n    }\n  }\n  orderData {\n    bestBid {\n      orderType\n      paymentAssetQuantity {\n        ...AssetQuantity_data\n        id\n      }\n    }\n    bestAsk {\n      closedAt\n      orderType\n      dutchAuctionFinalPrice\n      openedAt\n      priceFnEndedAt\n      quantity\n      decimals\n      paymentAssetQuantity {\n        quantity\n        ...AssetQuantity_data\n        id\n      }\n    }\n  }\n}\n\nfragment AssetContextMenu_data_3z4lq0 on AssetType {\n  ...asset_edit_url\n  ...asset_url\n  ...itemEvents_data\n  relayId\n  isDelisted\n  isEditable {\n    value\n    reason\n  }\n  isListable\n  ownership(identity: {}) {\n    isPrivate\n    quantity\n  }\n  creator {\n    address\n    id\n  }\n  collection {\n    isAuthorizedEditor\n    id\n  }\n  imageUrl\n  ownedQuantity(identity: {})\n}\n\nfragment AssetMedia_asset on AssetType {\n  animationUrl\n  backgroundColor\n  collection {\n    displayData {\n      cardDisplayStyle\n    }\n    id\n  }\n  isDelisted\n  imageUrl\n  displayImageUrl\n}\n\nfragment AssetQuantity_data on AssetQuantityType {\n  asset {\n    ...Price_data\n    id\n  }\n  quantity\n}\n\nfragment AssetSearchFilter_data_3KTzFc on Query {\n  ...CollectionFilter_data_2qccfC\n  collection(collection: $collection) {\n    numericTraits {\n      key\n      value {\n        max\n        min\n      }\n      ...NumericTraitFilter_data\n    }\n    stringTraits {\n      key\n      ...StringTraitFilter_data\n    }\n    id\n  }\n  ...PaymentFilter_data_2YoIWt\n}\n\nfragment AssetSearchList_data_3Aax2O on SearchResultType {\n  asset {\n    assetContract {\n      address\n      chain\n      id\n    }\n    collection {\n      isVerified\n      relayId\n      id\n    }\n    relayId\n    tokenId\n    ...AssetSelectionItem_data\n    ...asset_url\n    id\n  }\n  assetBundle {\n    relayId\n    id\n  }\n  ...Asset_data_3Aax2O\n}\n\nfragment AssetSearch_data_2hBjZ1 on Query {\n  ...AssetSearchFilter_data_3KTzFc\n  ...SearchPills_data_2Kg4Sq\n  search(after: $cursor, chains: $chains, categories: $categories, collections: $collections, first: $count, identity: $identity, numericTraits: $numericTraits, paymentAssets: $paymentAssets, priceFilter: $priceFilter, querystring: $query, resultType: $resultModel, sortAscending: $sortAscending, sortBy: $sortBy, stringTraits: $stringTraits, toggles: $toggles, creator: $creator, isPrivate: $isPrivate, safelistRequestStatuses: $safelistRequestStatuses) {\n    edges {\n      node {\n        ...AssetSearchList_data_3Aax2O\n        __typename\n      }\n      cursor\n    }\n    totalCount\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nfragment AssetSelectionItem_data on AssetType {\n  backgroundColor\n  collection {\n    displayData {\n      cardDisplayStyle\n    }\n    imageUrl\n    id\n  }\n  imageUrl\n  name\n  relayId\n}\n\nfragment Asset_data_3Aax2O on SearchResultType {\n  asset {\n    relayId\n    isDelisted\n    ...AssetCardContent_asset\n    ...AssetCardFooter_asset_3Aax2O\n    ...AssetMedia_asset\n    ...asset_url\n    ...itemEvents_data\n    orderData {\n      bestAsk {\n        paymentAssetQuantity {\n          quantityInEth\n          id\n        }\n      }\n    }\n    id\n  }\n  assetBundle {\n    relayId\n    ...bundle_url\n    ...AssetCardContent_assetBundle\n    ...AssetCardFooter_assetBundle\n    orderData {\n      bestAsk {\n        paymentAssetQuantity {\n          quantityInEth\n          id\n        }\n      }\n    }\n    id\n  }\n}\n\nfragment CollectionFilter_data_2qccfC on Query {\n  selectedCollections: collections(first: 25, collections: $collections, includeHidden: true) {\n    edges {\n      node {\n        assetCount\n        imageUrl\n        name\n        slug\n        isVerified\n        id\n      }\n    }\n  }\n  collections(assetOwner: $assetOwner, assetCreator: $creator, onlyPrivateAssets: $isPrivate, chains: $chains, first: 100, includeHidden: $includeHiddenCollections, parents: $categories, query: $collectionQuery, sortBy: $collectionSortBy) {\n    edges {\n      node {\n        assetCount\n        imageUrl\n        name\n        slug\n        isVerified\n        id\n        __typename\n      }\n      cursor\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nfragment CollectionModalContent_data on CollectionType {\n  description\n  imageUrl\n  name\n  slug\n}\n\nfragment NumericTraitFilter_data on NumericTraitTypePair {\n  key\n  value {\n    max\n    min\n  }\n}\n\nfragment PaymentFilter_data_2YoIWt on Query {\n  paymentAssets(first: 10) {\n    edges {\n      node {\n        symbol\n        relayId\n        id\n        __typename\n      }\n      cursor\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n  PaymentFilter_collection: collection(collection: $collection) {\n    paymentAssets {\n      symbol\n      relayId\n      id\n    }\n    id\n  }\n}\n\nfragment Price_data on AssetType {\n  decimals\n  imageUrl\n  symbol\n  usdSpotPrice\n  assetContract {\n    blockExplorerLink\n    chain\n    id\n  }\n}\n\nfragment SearchPills_data_2Kg4Sq on Query {\n  selectedCollections: collections(first: 25, collections: $collections, includeHidden: true) {\n    edges {\n      node {\n        imageUrl\n        name\n        slug\n        ...CollectionModalContent_data\n        id\n      }\n    }\n  }\n}\n\nfragment StringTraitFilter_data on StringTraitType {\n  counts {\n    count\n    value\n  }\n  key\n}\n\nfragment asset_edit_url on AssetType {\n  assetContract {\n    address\n    chain\n    id\n  }\n  tokenId\n  collection {\n    slug\n    id\n  }\n}\n\nfragment asset_url on AssetType {\n  assetContract {\n    address\n    chain\n    id\n  }\n  tokenId\n}\n\nfragment bundle_url on AssetBundleType {\n  slug\n}\n\nfragment collection_url on CollectionType {\n  slug\n}\n\nfragment itemEvents_data on AssetType {\n  assetContract {\n    address\n    chain\n    id\n  }\n  tokenId\n}\n`,
                        variables: {
                            "categories": null,
                            "chains": null,
                            "collection": this.contractId,
                            "collectionQuery": null,
                            "collectionSortBy": "SEVEN_DAY_VOLUME",
                            "collections":[ this.contractId ],
                            "count": 32,
                            "cursor": null,
                            "identity": null,
                            "includeHiddenCollections": null,
                            "numericTraits": null,
                            "paymentAssets": null,
                            "priceFilter":{
                                "symbol":"ETH",
                                "max": this.totalPrice,
                            },
                            "query": " ",
                            "resultModel": "ASSETS",
                            "showContextMenu": true,
                            "shouldShowQuantity": false,
                            "sortAscending": true,
                            "sortBy": "PRICE",
                            "toggles": [
                                "BUY_NOW"
                            ],
                            "creator": null,
                            "assetOwner": null,
                            "isPrivate": null,
                            "safelistRequestStatuses": null
                        }
                    })
                });

                if (JSON.parse(response.body).data.query.search.edges.length >= 1) {
                    const asset = JSON.parse(response.body).data.query.search.edges[0]
                    await this.snipe(asset.node.asset.assetContract.address, asset.node.asset.tokenId, asset.node.asset.displayImageUrl, asset.node.asset.collection.name);
                }
                await sleep(5000);
                this.monitor();
            }
        } catch (error) {
            log('error', `Error Monitoring: ${error}`);
        }
    }

    async snipe(contractAddress: string, tokenId: string, imageUrl: string, collection: string) {
        try {
            log('misc', `Sniping: ${tokenId}`);
            //@ts-ignore
            const order = await this.seaport.api.getOrder({
                asset_contract_address: contractAddress,
                token_id: tokenId,
                side: 1,
            });

            //@ts-ignore
            if((parseInt(order.basePrice.toString())/1000000000000000000) > parseFloat(this.totalPrice)) {
                throw `Detected scam listing`;
            }

            //@ts-ignore
            const transaction = await this.seaport.fulfillOrder({
                //@ts-ignore
                accountAddress: this.taskWallet.address, //@ts-ignore
                order: order,
            });

            //@ts-ignore
            transaction.push({
                //@ts-ignore
                value: ethers.utils.parseEther((parseInt(order.basePrice.toString())/1000000000000000000).toString()),
                maxPriorityFeePerGas: parseInt(this.maxPriority) * 1000000000,
                maxFeePerGas: parseInt(this.maxFeeGas) * 1000000000,
            });
            log('success', `Sniped: ${tokenId}`);
            await this.sendWebhook("Success", tokenId, imageUrl, collection);
        } catch (error) {
            log('error', `Error sniping: ${error}`);
            await this.sendWebhook("Failed", tokenId, imageUrl, collection);
            await sleep(2500);
            this.snipe(contractAddress, tokenId, imageUrl, collection);
        }
    }

    async sendWebhook(status: string, tokenId: string, imageUrl: string, collection: string) {
        try {
            const webhook = {
                "content": null,
                    "embeds": [
                    {
                        "title": `Snipe ${status}`,
                        "color": 16514301,
                        "fields": [
                        {
                            "name": "Collection",
                            "value": collection,
                            "inline": true
                        },
                        {
                            "name": "Token ID",
                            "value": `#${tokenId}`,
                            "inline": true
                        }
                        ],
                        "thumbnail": {
                            "url": imageUrl
                        }
                    }
                ]
            }
    
            console.log(this.parameters);
            const response = await got.post(this.parameters, {
                headers: {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36",
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(webhook),
            });
        } catch (error) {console.log(error)}
    }
}
'''
'''--- src/modules/NEAR/Contract.ts ---
import * as nearAPI from "near-api-js";
import JSBI from "jsbi";
import { log } from "../../utils/logger";

export default class Contract {
    monitorInput: any;
    accountName: string;
    privateKey: string;
    price: string;
    
    constructor(task: {
        monitorInput: string,
        privateKey: string,
        accountName: string,
        price: string,
    }) {
        this.monitorInput = task.monitorInput;
        this.privateKey = task.privateKey;
        this.accountName = task.accountName;
        this.price = task.price;
    }

    async mint() {
        const fees = {
            STORAGE_ADD_MARKET_FEE: '8590000000000000000000',
            STORAGE_MINT_FEE: '11280000000000000000000',
            STORAGE_CREATE_SERIES_FEE: '8540000000000000000000',
            STORAGE_APPROVE_FEE: '760000000000000000000',
            GAS_FEE: `100000000000000`,
            GAS_FEE_150: `150000000000000`,
            GAS_FEE_200: `200000000000000`,
            GAS_FEE_300: `300000000000000`,
            MAX_FILE_SIZE: 30 * 1024 * 1024,
        };

        log('misc', "Connecting to wallet...");
        const signerKeyPair = nearAPI.utils.KeyPair.fromString(this.privateKey);
        const keyStore = new nearAPI.keyStores.InMemoryKeyStore();
        keyStore.setKey("mainnet", this.accountName, signerKeyPair);

        const near = await nearAPI.connect({
            deps: {
                keyStore,
            },
            nodeUrl: "https://rpc.mainnet.near.org",
            networkId: "mainnet",
            headers: {}
        });
        
        // Get parameters from mint
        const mintParameters = {
            "receiver_id": this.accountName,
            "actions": 'nft_mint_one'
        };
        const attachedDeposit = JSBI.add(JSBI.BigInt(parseInt(this.price) * 1000000000000000000000000), JSBI.BigInt(fees.STORAGE_MINT_FEE));
        const account = await near.account(this.accountName);

        // Attempt to mint
        log('submit', "Submitting mint...");
        try {
            const functionCallResponse = await account.functionCall({
                contractId: this.monitorInput,
                methodName: 'nft_mint_one',
                args: mintParameters, //@ts-ignore
                gas: fees.GAS_FEE, //@ts-ignore
                attachedDeposit: attachedDeposit.toString(),
            })
            const result = nearAPI.providers.getTransactionLastResult(
                functionCallResponse
            );
            log('success', "Check Wallet");
        } catch (e) {
            // Retry add sleep function here
            log('error', "Unknown error minting");
            this.mint();
        }
        return;
    }
}
'''
'''--- src/modules/NEAR/Paras.ts ---
import * as nearAPI from "near-api-js";
import JSBI from "jsbi";
import got from 'got/dist/source';
import { log } from '../../utils/logger';
import { sleep } from '../../utils/misc';

export default class Paras {
    monitorInput: string;
    accountName: string;
    privateKey: string;
    price: number;

    constructor(task: {
        monitorInput: string,
        privateKey: string,
        accountName: string,
        price: string,
    }) {
        this.monitorInput = task.monitorInput;
        this.privateKey = task.privateKey;
        this.accountName = task.accountName;
        this.price = parseFloat(task.price) * Math.pow(10, 24);
    }

    async start() {
        //@ts-ignore
        let [listing, floor] = await this.getListings();

        const signerKeyPair = nearAPI.utils.KeyPair.fromString(this.privateKey);
        const keyStore = new nearAPI.keyStores.InMemoryKeyStore();
        keyStore.setKey("mainnet", this.accountName, signerKeyPair);

        const near = await nearAPI.connect({
            deps: {
                keyStore,
            },
            nodeUrl: "https://rpc.mainnet.near.org",
            networkId: "mainnet",
            headers: {}
        });

        const params = {
            token_series_id: listing.token_series_id,
            receiver_id: this.accountName,
        }

        const attachedDeposit = JSBI.add(JSBI.BigInt(listing.lowest_price), JSBI.BigInt("11280000000000000000000"));
        const account = await near.account(this.accountName);

        try {
            const functionCallResponse = await account.functionCall({
                contractId: listing.contract_id,
                methodName: `nft_buy`,
                args: params, //@ts-ignore
                gas: 100000000000000, //@ts-ignore
                attachedDeposit: attachedDeposit.toString(),
            })
            const result = nearAPI.providers.getTransactionLastResult(
                functionCallResponse
            );
            log('success', 'Successfully sniped listing');
        } catch (e) {
            //@ts-ignore
            log('error', "Error sniping listing");
            await sleep(2500);
            this.start();
        }
        return;
    }

    async getListings() {
        let floor = 0;
        let lower = false;

        while (!lower) {
            let validListings: any[] = [];
            let listingsUnderMax: any[] = [];
            let allListings = await this.getAllListings();

            allListings.forEach((listing: any) => {
                if (listing.lowest_price !== null || listing.lowest_price !== '0') {
                    validListings.push(listing);
                    let realPrice = parseFloat((listing.lowest_price / 10 ** 24).toFixed(1));
                    if (realPrice <= parseFloat((this.price / 10 ** 24).toFixed(1))) {
                        listingsUnderMax.push(listing);
                    }
                }
            });

            floor = parseFloat((validListings[0].lowest_price / 10 ** 24).toFixed(1))
            if (listingsUnderMax.length > 0) {
                let randomListing = listingsUnderMax[this.randomRange(0, listingsUnderMax.length - 1)];
                let realPrice = parseFloat((randomListing.lowest_price / 10 ** 24).toFixed(1));
                log('misc', `Found listing @ ${realPrice} $NEAR`);
                return [randomListing, floor];
            } else {
                log('misc', `Monitoring: ${this.monitorInput}`);
                await sleep(5000);
            }
        }
    }

    async getAllListings() {
        try {
            const response = await got(`https://api-v2-mainnet.paras.id/token-series?collection_id=${this.monitorInput}&exclude_total_burn=true&__skip=0&__limit=16&__sort=lowest_price::1&min_price=10000000000000000000000`).json().catch(e => {
                console.log(e.response.body)
                log('error', "Unable to grab listings");
                return [];
            });
            //@ts-ignore
            return response.data.results;
        } catch (err: unknown) {
            log('error', "Unable to grab listings");
        }
    }

    randomRange(min: number, max: number) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
}
'''
'''--- src/modules/Solana/CandyMachine.ts ---
import * as anchor from "@project-serum/anchor";
import { log } from "../../utils/logger";
import { returnConfig, sleep } from "../../utils/misc";
import TpuProxy from "./TPUClient/tpu_proxy";
import constants from "../../constants/Solana/publicKeys";
import * as nacl from "tweetnacl";
import { parentPort } from "worker_threads";
import { MintLayout, Token, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import {
    createAssociatedTokenAccountInstruction,
    getAtaForMint,
    getCandyMachineCreator,
    getCollectionAuthorityRecordPDA,
    getCollectionPDA,
    getMasterEdition,
    getMetadata,
    getNetworkExpire,
    getNetworkToken,
} from "../../constants/Solana/functions";
import os from "os";
import base58 from "bs58";

interface CollectionData {
    mint: anchor.web3.PublicKey;
    candyMachine: anchor.web3.PublicKey;
}

async function createCandyMachineMint(
    id: anchor.web3.PublicKey,
    payer: anchor.web3.PublicKey,
    program: anchor.Program,
    candyMachineDetails: any
): Promise<{
    instructions: anchor.web3.TransactionInstruction[];
    signers: anchor.web3.Signer[];
}> {
    try {
        const mint = anchor.web3.Keypair.generate();

        const userTokenAccountAddress = (
            await getAtaForMint(mint.publicKey, payer)
        )[0];

        const userPayingAccountAddress = candyMachineDetails.tokenMint
            ? (await getAtaForMint(candyMachineDetails.tokenMint, payer))[0]
            : payer;

        const remainingAccounts = [];
        const signers = [mint];

        const instructions = [
            anchor.web3.SystemProgram.createAccount({
                fromPubkey: payer,
                newAccountPubkey: mint.publicKey,
                space: MintLayout.span,
                lamports:
                    await program.provider.connection.getMinimumBalanceForRentExemption(
                        MintLayout.span
                    ),
                programId: TOKEN_PROGRAM_ID,
            }),
            Token.createInitMintInstruction(
                TOKEN_PROGRAM_ID,
                mint.publicKey,
                0,
                payer,
                payer
            ),
            createAssociatedTokenAccountInstruction(
                userTokenAccountAddress,
                payer,
                payer,
                mint.publicKey
            ),
            Token.createMintToInstruction(
                TOKEN_PROGRAM_ID,
                mint.publicKey,
                userTokenAccountAddress,
                payer,
                [],
                1
            ),
        ];

        if (candyMachineDetails.data.gatekeeper) {
            remainingAccounts.push({
                pubkey: (
                    await getNetworkToken(
                        payer,
                        candyMachineDetails.data.gatekeeper.gatekeeperNetwork
                    )
                )[0],
                isWritable: true,
                isSigner: false,
            });

            if (candyMachineDetails.data.gatekeeper.expireOnUse) {
                remainingAccounts.push({
                    pubkey: constants.CIVIC,
                    isWritable: false,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: (
                        await getNetworkExpire(
                            candyMachineDetails.data.gatekeeper.gatekeeperNetwork
                        )
                    )[0],
                    isWritable: false,
                    isSigner: false,
                });
            }
        }
        if (candyMachineDetails.data.whitelistMintSettings) {
            const mint = new anchor.web3.PublicKey(
                candyMachineDetails.data.whitelistMintSettings.mint
            );

            const whitelistToken = (await getAtaForMint(mint, payer))[0];
            remainingAccounts.push({
                pubkey: whitelistToken,
                isWritable: true,
                isSigner: false,
            });

            if (candyMachineDetails.data.whitelistMintSettings.mode.burnEveryTime) {
                remainingAccounts.push({
                    pubkey: mint,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: payer,
                    isWritable: false,
                    isSigner: true,
                });
            }
        }

        if (candyMachineDetails.data.tokenMint) {
            remainingAccounts.push({
                pubkey: userPayingAccountAddress,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: payer,
                isWritable: false,
                isSigner: true,
            });
        }

        const metadataAddress = await getMetadata(mint.publicKey);
        const masterEdition = await (await getMasterEdition(mint.publicKey))[0];

        const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(id);

        instructions.push(
            program.instruction.mintNft(creatorBump, {
                accounts: {
                    candyMachine: id,
                    candyMachineCreator,
                    payer: userPayingAccountAddress,
                    wallet: candyMachineDetails.wallet,
                    mint: mint.publicKey,
                    metadata: metadataAddress[0],
                    masterEdition,
                    mintAuthority: userPayingAccountAddress,
                    updateAuthority: userPayingAccountAddress,
                    tokenMetadataProgram: constants.TOKEN_METADATA_PROGRAM_ID,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
                    recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                    instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
                },
                remainingAccounts:
                    remainingAccounts.length > 0 ? remainingAccounts : undefined,
            })
        );

        const [collectionPDA] = await getCollectionPDA(id);
        const collectionPDAAccount =
            await program.provider.connection.getAccountInfo(collectionPDA);

        if (collectionPDAAccount && candyMachineDetails.data.retainAuthority) {
            try {
                const collectionData =
                    // @ts-ignore
                    (await program.account.collectionPda.fetch(
                        collectionPDA
                    )) as CollectionData;

                const collectionMint = collectionData.mint;
                const collectionAuthorityRecord = await getCollectionAuthorityRecordPDA(
                    collectionMint,
                    collectionPDA
                );

                if (collectionMint) {
                    const collectionMetadata = (await getMetadata(collectionMint))[0];
                    const collectionMasterEdition = (
                        await getMasterEdition(collectionMint)
                    )[0];

                    instructions.push(
                        await program.instruction.setCollectionDuringMint({
                            accounts: {
                                candyMachine: id,
                                metadata: metadataAddress[0],
                                payer: payer,
                                collectionPda: collectionPDA,
                                tokenMetadataProgram: constants.TOKEN_METADATA_PROGRAM_ID,
                                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
                                collectionMint,
                                collectionMetadata,
                                collectionMasterEdition,
                                authority: candyMachineDetails.authority,
                                collectionAuthorityRecord,
                            },
                        })
                    );
                }
            } catch (error) {
                console.error(error);
            }
        }

        return {
            instructions: instructions,
            signers: signers
        };
    } catch (err: unknown) {
        log("error", "Unknown error while creating mint!");

        return await createCandyMachineMint(
            id,
            payer,
            program,
            candyMachineDetails
        );
    }
}

export default class CandyMachine {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private connection: anchor.web3.Connection;
    private signers: any;
    private transaction: any;
    private tpu: any;
    private candyMachineDetails: any;
    private program: any;
    private confirmed: boolean;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(
            anchor.utils.bytes.bs58.decode(options.wallet)
        );
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.timestamp = options.timestamp;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.rpc = options.rpc;
        this.connection = new anchor.web3.Connection(this.rpc, {
            commitment: "finalized",
        });
        this.signers = null;
        this.transaction = null;
        this.program = null;
        this.tpu = null;
        this.confirmed = false;
        this.candyMachineDetails = {} as any;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    }

    private start = async (): Promise<void> => {
        try {
            log("misc", `Creating connections...`);
            const config: { rpc: string } = JSON.parse(returnConfig());

            const provider = new anchor.AnchorProvider(this.connection, this.wallet, {
                preflightCommitment: "processed",
            });

            const idl: any = await anchor.Program.fetchIdl(
                constants.CANDY_MACHINE_PROGRAM,
                provider
            );

            this.program = new anchor.Program(
                idl,
                constants.CANDY_MACHINE_PROGRAM,
                provider
            );

            this.candyMachineDetails = await this.program.account.candyMachine.fetch(
                this.cmid
            );

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log("error", `Error starting task`);

            await sleep(this.delay);

            this.start();
        }
    };

    private async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log("misc", `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log("error", `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        }
    }

    private async spamMint(transaction: Buffer, sig: string): Promise<void> {
        while (!this.confirmed) {
            log("submit", `Submitted TX: ${sig}`);

            this.tpu.sendRawTransaction(transaction, this.rpc);

            await sleep(10);
        }

        return;
    }

    private async mint(): Promise<void> {
        try {
            this.confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            log("misc", `Creating transaction...`);

            const mintObject: {
                instructions: anchor.web3.TransactionInstruction[];
                signers: anchor.web3.Signer[];
            } = await createCandyMachineMint(
                this.cmid,
                this.wallet.payer.publicKey,
                this.program,
                this.candyMachineDetails
            );

            let transaction = new anchor.web3.Transaction();
            mintObject.instructions.forEach(
                (instruction: anchor.web3.TransactionInstruction) =>
                    transaction.add(instruction)
            );

            this.transaction = transaction;
            this.signers = mintObject.signers;

            log("misc", `Fetching blockhash...`);

            const blockhash = await this.connection.getLatestBlockhash("processed");

            this.transaction.recentBlockhash = blockhash.blockhash;

            this.transaction.feePayer = this.wallet.publicKey;

            log("misc", `Signing transaction...`);

            const walletSignature = nacl.sign.detached(
                this.transaction.serializeMessage(),
                this.wallet.payer.secretKey
            );

            this.transaction.addSignature(
                this.wallet.publicKey,
                Buffer.from(walletSignature)
            );

            this.transaction.partialSign(...this.signers);

            rawTransaction = (
                await this.wallet.signTransaction(this.transaction)
            ).serialize();

            let sig = base58.encode(
                new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65)
            );

            this.spamMint(rawTransaction, sig);

            while (true) {
                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        this.confirmed = true;

                        log(
                            "success",
                            `Transaction ${sig} has been confirmed on slot ${status.context.slot}`
                        );

                        break;
                    };
                };
            };

            this.mint();
        } catch (err: unknown) {
            log("error", `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        }
    }
}

async function start(task: any) {
    log("misc", `Creating client...`);

    new CandyMachine({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp,
    });
}

parentPort?.on("message", (message: any) => {
    start(message);
});

'''
'''--- src/modules/Solana/LMNFT.ts ---
import * as anchor from "@project-serum/anchor";
import { log } from "../../utils/logger";
import { returnConfig, sleep } from "../../utils/misc";
import TpuProxy from "./TPUClient/tpu_proxy";
import constants from "../../constants/Solana/publicKeys";
import * as nacl from "tweetnacl";
import { parentPort } from "worker_threads";
import { MintLayout, Token, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import {
    createAssociatedTokenAccountInstruction,
    getAtaForMint,
    getMasterEdition,
    getMetadata,
} from "../../constants/Solana/functions";
import os from "os";
import base58 from "bs58";

async function createMint(
    program: anchor.Program,
    cmid: anchor.web3.PublicKey,
    wallet: anchor.Wallet,
    connection: anchor.web3.Connection,
    candyMachineDetails: any
): Promise<{
    tx: anchor.web3.Transaction;
    signers: anchor.web3.Signer[];
}> {
    try {
        const mint = anchor.web3.Keypair.generate();

        let w = await getMetadata(mint.publicKey);
        let x = await getMasterEdition(mint.publicKey);
        let k = await getAtaForMint(mint.publicKey, wallet.publicKey);

        let l = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("TotalMints"), wallet.publicKey.toBuffer(), cmid.toBuffer()],
            constants.LMNFT_PROGRAM
        );
        let d = l[0];
        let h = l[1];

        if (candyMachineDetails.mode == "v3") {
            let I = {
                candyMachine: cmid,
                payer: wallet.publicKey,
                wallet: candyMachineDetails.wallet,
                wallet2: new anchor.web3.PublicKey(
                    "33nQCgievSd3jJLSWFBefH3BJRN7h6sAoS82VFFdJGF5"
                ),
                metadata: w[0],
                mint: mint.publicKey,
                associated: k[0],
                masterEdition: x[0],
                totalMints: d,
                associatedTokenProgram:
                    constants.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
                tokenMetadataProgram: constants.TOKEN_METADATA_PROGRAM_ID,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: anchor.web3.SystemProgram.programId,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            };

            // @ts-ignore
            let M = program.instruction.mintV3(null, {
                accounts: I,
                signers: [mint],
            });

            const blockhash = await connection.getLatestBlockhash("processed");

            let tx = new anchor.web3.Transaction({
                feePayer: wallet.publicKey,
                recentBlockhash: blockhash.blockhash,
            });

            tx.add(M);

            return { tx: tx, signers: [mint] };
        } else {
            let f = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("candy_machine"), cmid.toBuffer()], constants.LMNFT_PROGRAM);

            let p = f[0];
            let g = f[1];

            let E = await connection.getMinimumBalanceForRentExemption(
                MintLayout.span
            );

            let A = [
                anchor.web3.SystemProgram.createAccount({
                    fromPubkey: wallet.publicKey,
                    newAccountPubkey: mint.publicKey,
                    space: MintLayout.span,
                    lamports: E,
                    programId: TOKEN_PROGRAM_ID,
                }),
                Token.createInitMintInstruction(
                    TOKEN_PROGRAM_ID,
                    mint.publicKey,
                    0,
                    wallet.publicKey,
                    wallet.publicKey
                ),
                createAssociatedTokenAccountInstruction(
                    k[0],
                    wallet.publicKey,
                    wallet.publicKey,
                    mint.publicKey
                ),
                Token.createMintToInstruction(
                    TOKEN_PROGRAM_ID,
                    mint.publicKey,
                    k[0],
                    wallet.publicKey,
                    [],
                    1
                ),
            ];

            let I = {
                candyMachine: cmid,
                payer: wallet.publicKey,
                candyMachineCreator: p,
                wallet: candyMachineDetails.wallet,
                wallet2: new anchor.web3.PublicKey(
                    "33nQCgievSd3jJLSWFBefH3BJRN7h6sAoS82VFFdJGF5"
                ),
                metadata: w[0],
                mint: mint.publicKey,
                masterEdition: x[0],
                totalMints: d,
                tokenMetadataProgram: constants.TOKEN_METADATA_PROGRAM_ID,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: anchor.web3.SystemProgram.programId,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            };

            // @ts-ignore
            let M = program.instruction.mintV2(g, h, null, {
                accounts: I,
                signers: [mint],
            });

            const blockhash = await connection.getLatestBlockhash("processed");

            let tx = new anchor.web3.Transaction({
                feePayer: wallet.publicKey,
                recentBlockhash: blockhash.blockhash,
            });

            A.forEach((instruction: anchor.web3.TransactionInstruction) => {
                tx.add(instruction);
            });

            tx.add(M);

            return { tx: tx, signers: [mint] };
        };
    } catch (err: unknown) {
        log("error", "Unknown error while creating mint!");

        await sleep(2500);

        return await createMint(
            program,
            cmid,
            wallet,
            connection,
            candyMachineDetails
        );
    }
}

export default class LMNFT {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private connection: anchor.web3.Connection;
    private signers: any;
    private transaction: any;
    private tpu: any;
    private candyMachineDetails: any;
    private program: any;
    private confirmed: boolean;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(
            anchor.utils.bytes.bs58.decode(options.wallet)
        );
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.timestamp = options.timestamp;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.rpc = options.rpc;
        this.connection = new anchor.web3.Connection(this.rpc, {
            commitment: "finalized",
        });
        this.signers = null;
        this.transaction = null;
        this.program = null;
        this.tpu = null;
        this.confirmed = false;
        this.candyMachineDetails = {} as any;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    }

    private start = async (): Promise<void> => {
        try {
            log("misc", `Creating connections...`);
            const config: { rpc: string } = JSON.parse(returnConfig());

            const provider: anchor.Provider = new anchor.AnchorProvider(
                this.connection,
                this.wallet,
                {
                    preflightCommitment: "processed",
                }
            );

            const idl: any = await anchor.Program.fetchIdl(
                constants.LMNFT_PROGRAM,
                provider
            );

            this.program = new anchor.Program(idl, constants.LMNFT_PROGRAM, provider);

            try {
                this.candyMachineDetails = await this.program.account.candyMachineV3.fetch(this.cmid);

                this.candyMachineDetails.mode = "v3";
            } catch (err: unknown) {
                this.candyMachineDetails = await this.program.account.candyMachineV2.fetch(this.cmid);

                this.candyMachineDetails.mode = "v2";
            };

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log("error", `Error starting task`);

            await sleep(this.delay);

            this.start();
        }
    };

    private async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log("misc", `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log("error", `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        }
    }

    private async spamMint(transaction: Buffer, sig: string): Promise<void> {
        while (!this.confirmed) {
            log("submit", `Submitted TX: ${sig}`);

            this.tpu.sendRawTransaction(transaction, this.rpc);

            await sleep(10);
        };

        return;
    }

    private async mint(): Promise<void> {
        try {
            this.confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            log("misc", `Creating transaction...`);

            const mintObject: {
                tx: anchor.web3.Transaction;
                signers: anchor.web3.Signer[];
            } = await createMint(
                this.program,
                this.cmid,
                this.wallet,
                this.connection,
                this.candyMachineDetails
            );

            this.transaction = mintObject.tx;
            this.signers = mintObject.signers;

            log("misc", `Signing transaction...`);

            const walletSignature = nacl.sign.detached(
                this.transaction.serializeMessage(),
                this.wallet.payer.secretKey
            );

            this.transaction.addSignature(
                this.wallet.publicKey,
                Buffer.from(walletSignature)
            );

            this.transaction.partialSign(...this.signers);

            rawTransaction = (
                await this.wallet.signTransaction(this.transaction)
            ).serialize();

            let sig = base58.encode(
                new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65)
            );

            this.spamMint(rawTransaction, sig);

            while (true) {
                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        this.confirmed = true;

                        log(
                            "success",
                            `Transaction ${sig} has been confirmed on slot ${status.context.slot}`
                        );

                        break;
                    }
                };
            };

            this.mint();
        } catch (err: unknown) {
            log("error", `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        }
    }
}

async function start(task: any) {
    log("misc", `Creating client...`);

    new LMNFT({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp,
    });
}

parentPort?.on("message", (message: any) => {
    start(message);
});

'''
'''--- src/modules/Solana/Launchpad.ts ---
import * as anchor from '@project-serum/anchor';
import { log } from '../../utils/logger';
import { getProxies, returnConfig, sleep } from '../../utils/misc';
import TpuProxy from './TPUClient/tpu_proxy';
import constants from '../../constants/Solana/publicKeys';
import {
    base58_to_binary,
    // @ts-ignore
} from "base58-js";
import tough from 'tough-cookie';
import { getLaunchStagesInfo, getMasterEdition, getMetadata, getTokenWallet, limit } from '../../constants/Solana/functions';
import { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { got, Server } from '../../utils/TLS/GotTLS';
import { parentPort } from 'worker_threads';
import base58 from 'bs58';
import os from 'os';
import _ from 'lodash';

const cookiejar = new tough.CookieJar();
Server.connect();

async function getHomePage(
    delay: number,
    agentSettings: null | {
        proxy: string
    }
): Promise<void> {
    try {
        if (agentSettings) {
            let x = await got.get("https://wk-notary-prod.magiceden.io/", {
                headers: {
                    'authority': 'wk-notary-prod.magiceden.io',
                    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
                    'accept-language': 'en-GB,en-US;q=0.9,en;q=0.8',
                    'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '"Windows"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'none',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36',
                },
                cookieJar: cookiejar,
                proxy: agentSettings.proxy,
                redirect: true
            });
        } else {
            await got.get("https://wk-notary-prod.magiceden.io/", {
                headers: {
                    'authority': 'wk-notary-prod.magiceden.io',
                    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
                    'accept-language': 'en-GB,en-US;q=0.9,en;q=0.8',
                    'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '"Windows"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'none',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36',
                },
                cookieJar: cookiejar,
                redirect: true
            });
        }

        return;
    } catch (err: unknown) {
        log('error', 'Unknown error while fetching homepage!');

        await sleep(delay);

        return await getHomePage(delay, agentSettings);
    };
};

async function getSignature(
    B: any,
    W: any,
    agentSettings: null | {
        proxy: string
    },
    delay: number,
): Promise<any> {
    try {
        let a = {
            config: W.config.toBase58(),
            candyMachine: W.candyMachine.toBase58(),
            launchStagesInfo: W.launchStagesInfo.toBase58(),
            candyMachineWalletAuthority: W.candyMachineWalletAuthority.toBase58(),
            mintReceiver: W.mintReceiver.toBase58(),
            payer: W.payer.toBase58(),
            payTo: W.payTo.toBase58(),
            payFrom: W.payFrom.toBase58(),
            mint: W.mint.toBase58(),
            tokenAta: W.tokenAta.toBase58(),
            metadata: W.metadata.toBase58(),
            masterEdition: W.masterEdition.toBase58(),
            walletLimitInfo: W.walletLimitInfo.toBase58(),
            tokenMetadataProgram: W.tokenMetadataProgram.toBase58(),
            tokenProgram: W.tokenProgram.toBase58(),
            systemProgram: W.systemProgram.toBase58(),
            rent: W.rent.toBase58(),
            orderInfo: W.orderInfo.toBase58(),
            slotHashes: W.slotHashes.toBase58(),
            notary: W.notary.toBase58(),
            associatedTokenProgram: W.associatedTokenProgram.toBase58()
        };

        if (agentSettings) {
            const response = await got.post("https://wk-notary-prod.magiceden.io/mintix", {
                headers: {
                    'authority': 'wk-notary-prod.magiceden.io',
                    'accept': 'application/json, text/plain, /',
                    'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"',
                    'sec-ch-ua-mobile': '?0',
                    'accept-encoding': 'gzip, deflate, br',
                    'accept-language': 'en-US,en;q=0.9',
                    'content-type': 'application/json',
                    'origin': 'https://magiceden.io',
                    'referer': 'https://magiceden.io/',
                    'sec-ch-ua-platform': '"Windows"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'none',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36',
                },
                body: JSON.stringify({
                    params: B,
                    accounts: a
                }),
                proxy: agentSettings.proxy,
                // redirect: true
            });

            console.log(response.body);

            const body = JSON.parse(response.body);

            let i = anchor.web3.Transaction.from(base58_to_binary(body.tx))

            return i;
        } else {
            const response = await got.post("https://wk-notary-prod.magiceden.io/mintix", {
                headers: {
                    'authority': 'wk-notary-prod.magiceden.io',
                    'accept': 'application/json, text/plain, /',
                    'sec-ch-ua': '" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"',
                    'sec-ch-ua-mobile': '?0',
                    'accept-encoding': 'gzip, deflate, br',
                    'accept-language': 'en-US,en;q=0.9',
                    'content-type': 'application/json',
                    'origin': 'https://magiceden.io',
                    'referer': 'https://magiceden.io/',
                    'sec-ch-ua-platform': '"Windows"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'none',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36',
                },
                body: JSON.stringify({
                    params: B,
                    accounts: a
                }),
                // redirect: true
            });

            console.log(response.body);

            const body = JSON.parse(response.body);

            let i = anchor.web3.Transaction.from(base58_to_binary(body.tx))

            return i;
        }
    } catch (err: unknown) {
        console.log(err);

        log('error', 'Unknown error while signing mint!');

        await sleep(delay);

        return await getSignature(B, W, agentSettings, delay);
    };
};

async function bump(payer: anchor.web3.PublicKey) {
    try {
        let s,
            c,
            m,
            d,
            l,
            p,
            f;

        let a: any = 0;
        let t = [payer].length > 1 && void 0 !== [payer][1] ? [payer][1] : 100;

        while (true) {
            if (!(a < t)) {
                throw 1;
            };

            let r = anchor.web3.Keypair.generate();
            let metadataFunctions = await Promise.all([getMetadata(r.publicKey), getMasterEdition(r.publicKey), getTokenWallet(payer, r.publicKey)]);

            if (s = metadataFunctions, c = s[0], c[0], m = c[1], d = s[1], d[0], l = d[1], p = s[2], p[0], f = p[1], 255 !== m || 255 !== l || 255 !== f) {
                a += 1;
            } else {
                return r;
            };
        };
    } catch (err: unknown) {

    };
};

async function createLaunchpadMint(
    connection: anchor.web3.Connection,
    id: anchor.web3.PublicKey,
    payer: anchor.web3.PublicKey,
    program: anchor.Program,
    details: any,
    delay: number,
    paymentMint: string,
): Promise<{ B: {
    walletLimitInfoBump: number;
    inOrder: boolean;
    blockhash: string;
    needsNotary: boolean;
}, W: any, signers: anchor.web3.Signer[] }> {
    try {
        let l = null != details.notary && !details.notary.equals(anchor.web3.SystemProgram.programId);

        let x = await Promise.all(new Array(1).fill(null).map((async function () {
            return await bump(payer);
        })));

        let h = x.filter((function (e) {
            return null !== e
        }));

        let T = [];
        let I;

        if (!(I = h[0])) {
            throw 1;
        };

        let v = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, I.publicKey, payer);
        let N = await getMetadata(I.publicKey);
        let O = await getMasterEdition(I.publicKey);

        let k = await limit(id, payer);
        let L = k;
        let w = L[0];
        let P = L[1];
        let C = await getLaunchStagesInfo(id);

        let D = C;
        let K = D[0];
        let U = new anchor.web3.PublicKey(paymentMint);
        let G = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, U, details.walletAuthority);
        let W;
        
        if (U.equals(NATIVE_MINT)) {
            W = payer;
        } else {
            W = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, U, payer);
        };

        let B = [I];
        T.push(I);

        let M;

        log('misc', `Fetching blockhash...`);

        const blockhash = await connection.getLatestBlockhash('processed');

        let B1 = {
            walletLimitInfoBump: k[1],
            inOrder: false,
            blockhash: blockhash.blockhash,
            needsNotary: l
        };

        let W1 = {
            config: details.config,
            candyMachine: id,
            launchStagesInfo: K,
            candyMachineWalletAuthority: details.walletAuthority,
            mintReceiver: payer,
            payer: payer,
            payTo: G,
            payFrom: W,
            mint: I.publicKey,
            tokenAta: v,
            metadata: N[0],
            masterEdition: O[0],
            walletLimitInfo: w,
            tokenMetadataProgram: constants.TOKEN_METADATA_PROGRAM_ID,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: anchor.web3.SystemProgram.programId,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            orderInfo: details.orderInfo,
            slotHashes: new anchor.web3.PublicKey("SysvarS1otHashes111111111111111111111111111"),
            notary: null !== (M = details.notary) && void 0 !== M ? M : anchor.web3.PublicKey.default,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
        };

        return {
            B: B1,
            W: W1,
            signers: [I]
        };
    } catch (err: unknown) {
        log('error', 'Unknown error while creating mint!');

        await sleep(delay);

        return await createLaunchpadMint(connection, id, payer, program, details, delay, paymentMint);
    };
};

export default class Launchpad {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private signers: any;
    private transaction: any;
    private candyMachineDetails: any;
    private program: any;
    private connection: anchor.web3.Connection;
    private tpu: any;
    private paymentMint: string;
    public agentSettings: any;
    private confirmed: boolean;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
        paymentMint: string;
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(anchor.utils.bytes.bs58.decode(options.wallet));
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.rpc = options.rpc;
        this.timestamp = options.timestamp;
        this.connection = new anchor.web3.Connection(this.rpc, { commitment: 'finalized' });
        this.paymentMint = options.paymentMint;
        this.signers = null;
        this.transaction = null;
        this.program = null;
        this.tpu = null;
        this.confirmed = false;
        this.candyMachineDetails = {} as any;
        this.agentSettings = null;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    };

    public start = async (): Promise<void> => {
        try {
            log('misc', `Creating connections...`);

            try {
                const proxyList = getProxies();
                //@ts-ignore
                if (proxyList.split("\n").length > 0) {
                    //@ts-ignore
                    const temp = proxyList.split("\n")[Math.floor(Math.random() * proxyList.split("\n").length)];

                    if (temp.length < 5) {
                        throw new Error("Bad proxy");
                    }

                    const split = temp.split(":");

                    split[3] = split[3].replace(`\r`, ``);

                    let proxy = `http://${split[2]}:${split[3]}@${split[0]}:${split[1]}`;
                    log('misc', `Using proxy: ${proxy}`);

                    this.agentSettings = {
                        proxy: proxy
                    };
                };
            } catch (err) {
                log(`misc`, 'Skipping proxy');
            }

            await getHomePage(this.delay, this.agentSettings);

            const config: { rpc: string } = JSON.parse(returnConfig());

            const provider = new anchor.AnchorProvider(this.connection, this.wallet, {
                preflightCommitment: "processed",
            });

            const idl: any = await anchor.Program.fetchIdl(
                constants.LAUNCHPAD_PROGRAM,
                provider
            );

            this.program = new anchor.Program(idl, constants.LAUNCHPAD_PROGRAM, provider);

            this.candyMachineDetails = await this.program.account.candyMachine.fetch(this.cmid);

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log('error', `Error starting task`);

            await sleep(this.delay);

            this.start();
        };
    };

    public async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log('misc', `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log('error', `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        };
    };

    private async genTransaction(): Promise<void> {
        try {
            log('misc', `Creating transaction...`);

            const mintObject: {
                B: any,
                W: any,
                signers: any
            } = await createLaunchpadMint(
                this.connection, this.cmid, this.wallet.payer.publicKey, this.program, this.candyMachineDetails, this.delay, this.paymentMint
            );

            this.transaction = [mintObject.B, mintObject.W];
            this.signers = mintObject.signers;

            return;
        } catch (err: unknown) {
            log('error', `Unknown error while creating transaction!`);

            await sleep(this.delay);

            this.genTransaction();
        };
    };

    private async spamMint(transaction: Buffer, sig: string): Promise<void> {
        while (!this.confirmed) {
            log('submit', `Submitted TX: ${sig}`);

            this.tpu.sendRawTransaction(transaction, this.rpc);

            await sleep(10);
        };

        return;
    };

    public async mint(): Promise<void> {
        try {
            this.confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            await this.genTransaction();

            const B = this.transaction[0];
            const W = this.transaction[1];

            const transaction = await getSignature(B, W, this.agentSettings, this.delay);

            this.transaction = transaction;

            log('misc', `Signing transaction...`);

            this.transaction.partialSign(...this.signers);

            const signedTx = await this.wallet.signTransaction(this.transaction);
            
            rawTransaction = signedTx.serialize({
                verifySignatures: true
            });

            let sig = base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65));

            this.spamMint(rawTransaction, sig);

            while (true) {
                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        this.confirmed = true;

                        log('success', `Transaction ${sig} has been confirmed on slot ${status.context.slot}`);

                        break;
                    };
                };
            };

            this.mint();
        } catch (err: unknown) {
            console.log(err);

            log('error', `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        };
    };
};

async function start(task: any) {
    log('misc', `Creating client...`);

    new Launchpad({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp,
        paymentMint: task.paymentMint,
    });
};

parentPort?.on('message', (message: any) => {
    start(message);
});
'''
'''--- src/modules/Solana/Monkelabs.ts ---
import constants from '../../constants/Solana/publicKeys';
import * as anchor from '@project-serum/anchor';
import { MintLayout, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { ConfigAccount, ConfigAccountSchema } from './schemas/ConfigSchema';
import * as borsh from 'borsh';
import { extendBorsh } from './schemas/Borsh';
import { log } from '../../utils/logger';
import { returnConfig, sleep } from '../../utils/misc';
import base58 from 'bs58';
import nacl from 'tweetnacl';
import TpuProxy from './TPUClient/tpu_proxy';
import { parentPort } from 'worker_threads';
import os from 'os';

extendBorsh();

async function createMint(
    connection: anchor.web3.Connection,
    wallet: anchor.Wallet,
    configkey: anchor.web3.PublicKey,
    otherkey: anchor.web3.PublicKey,
    tokenmintkey: anchor.web3.PublicKey,
    tokenrecipkey: anchor.web3.PublicKey,
): Promise<{
    transaction: anchor.web3.Transaction,
    signer: anchor.web3.Signer
}> {
    try {
        const cfg_account = await connection.getAccountInfo(
            configkey
        );

        const parsed: ConfigAccount = borsh.deserializeUnchecked(
            ConfigAccountSchema,
            ConfigAccount,
            cfg_account!.data!,
        );

        let config = {
            pda_buf: +parsed.pda_buf,
            price: +parsed.price,
            index_cap: +parsed.index_cap,
            wl_key: parsed.wl_key,
            index_key: parsed.index_key,
            primary_wallet: parsed.primary_wallet,
            timeout: parsed.ctimeout,
            public: parsed.publicTime,
            presale: parsed.presaleTime,
            presalePrice: +parsed.presalePrice,
            token_mint_account:
                parsed.token_mint_account ||
                'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
            token_recip_account: parsed.token_recip_account || undefined,
            token_price: parsed.token_price ? +parsed.token_price : undefined,
            token_option: parsed.token_option ? +parsed.token_option : 1,
        };

        const mint_kp = anchor.web3.Keypair.generate();

        const meta_program = constants.TOKEN_METADATA_PROGRAM_ID;

        const minter_program = constants.MONKE_LABS;
        const associated_program = constants.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID;

        const token_key = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    wallet.publicKey.toBuffer(),
                    TOKEN_PROGRAM_ID.toBuffer(),
                    mint_kp.publicKey.toBuffer(),
                ],
                associated_program,
            )
        )[0];

        const meta_key = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]),
                    meta_program.toBuffer(),
                    mint_kp.publicKey.toBuffer(),
                ],
                meta_program,
            )
        )[0];

        const auth_key = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    new Uint8Array([
                        config.pda_buf & 0xff,
                        (config.pda_buf & 0xff00) >> 8,
                    ]),
                    new Uint8Array([97, 117, 116, 104]),
                    minter_program.toBuffer(),
                ],
                minter_program,
            )
        )[0];

        const sys_key = new anchor.web3.PublicKey('11111111111111111111111111111111');
        const rent_key = new anchor.web3.PublicKey('SysvarRent111111111111111111111111111111111');

        const uniqPDA = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    new Uint8Array([
                        config.pda_buf & 0xff,
                        (config.pda_buf & 0xff00) >> 8,
                    ]),
                    wallet.publicKey.toBuffer(),
                    minter_program.toBuffer(),
                ],
                minter_program,
            )
        )[0];

        const timePDA = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    new Uint8Array([108, 116, 105, 109, 101]),
                    wallet.publicKey.toBuffer(),
                    minter_program.toBuffer(),
                ],
                minter_program,
            )
        )[0];

        const edition_key = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]),
                    meta_program.toBuffer(),
                    mint_kp.publicKey.toBuffer(),
                    new Uint8Array([101, 100, 105, 116, 105, 111, 110]),
                ],
                meta_program,
            )
        )[0];

        const their_wallet = new anchor.web3.PublicKey(config.primary_wallet);
        const ix_key = new anchor.web3.PublicKey(config.index_key);
        const wl_key = new anchor.web3.PublicKey(config.wl_key);
        const config_key = configkey;
        const other_key = otherkey;

        let token_mint_key = tokenmintkey;

        let token_recip_key = tokenrecipkey;

        if (config.token_mint_account !== undefined && config.token_mint_account) {
            token_mint_key = new anchor.web3.PublicKey(config.token_mint_account);
        }
        if (config.token_recip_account !== undefined && config.token_recip_account) {
            token_recip_key = new anchor.web3.PublicKey(config.token_recip_account);
        }

        let payer_st_key = (
            await anchor.web3.PublicKey.findProgramAddress(
                [
                    wallet.publicKey.toBuffer(),
                    TOKEN_PROGRAM_ID.toBuffer(),
                    token_mint_key.toBuffer(),
                ],
                associated_program,
            )
        )[0];

        // accounts
        let account_0 = { pubkey: ix_key, isSigner: false, isWritable: true },
            account_1 = { pubkey: their_wallet, isSigner: false, isWritable: true },
            account_2 = { pubkey: new anchor.web3.PublicKey('mnKzuL9RMtR6GeSHBfDpnQaefcMsiw7waoTSduKNiXM'), isSigner: false, isWritable: true },
            account_3 = { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
            account_4 = { pubkey: wl_key, isSigner: false, isWritable: true },
            account_5 = { pubkey: token_key, isSigner: false, isWritable: true },
            account_6 = { pubkey: sys_key, isSigner: false, isWritable: false },
            account_7 = { pubkey: meta_key, isSigner: false, isWritable: true },
            account_8 = {
                pubkey: mint_kp.publicKey,
                isSigner: false,
                isWritable: true,
            },
            account_9 = { pubkey: meta_program, isSigner: false, isWritable: false },
            account_10 = { pubkey: rent_key, isSigner: false, isWritable: false },
            account_11 = { pubkey: auth_key, isSigner: false, isWritable: true },
            account_12 = {
                pubkey: TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            account_13 = { pubkey: uniqPDA, isSigner: false, isWritable: true },
            account_14 = { pubkey: timePDA, isSigner: false, isWritable: true },
            account_15 = { pubkey: edition_key, isSigner: false, isWritable: true },
            account_16 = { pubkey: config_key, isSigner: false, isWritable: true },
            account_17 = {
                pubkey: new anchor.web3.PublicKey('Sysvar1nstructions1111111111111111111111111'),
                isSigner: false,
                isWritable: false,
            },
            account_18 = { pubkey: other_key, isSigner: false, isWritable: false },
            account_19 = { pubkey: token_mint_key, isSigner: false, isWritable: true },
            account_20 = { pubkey: payer_st_key, isSigner: false, isWritable: true },
            account_21 = { pubkey: token_recip_key, isSigner: false, isWritable: true };

        let mintRent = await connection.getMinimumBalanceForRentExemption(
            MintLayout.span,
        );

        let mintAccount = anchor.web3.SystemProgram.createAccount({
            fromPubkey: wallet.publicKey,
            newAccountPubkey: mint_kp.publicKey,
            lamports: mintRent,
            space: MintLayout.span,
            programId: TOKEN_PROGRAM_ID,
        }),
            tokenAccount = Token.createAssociatedTokenAccountInstruction(
                associated_program,
                TOKEN_PROGRAM_ID,
                mint_kp.publicKey,
                token_key,
                wallet.publicKey,
                wallet.publicKey,
            ),
            create_token = Token.createInitMintInstruction(
                TOKEN_PROGRAM_ID,
                mint_kp.publicKey,
                0,
                wallet.publicKey,
                null,
            ),
            mint_into_token_account = Token.createMintToInstruction(
                TOKEN_PROGRAM_ID,
                mint_kp.publicKey,
                token_key,
                wallet.publicKey,
                [],
                1,
            ),
            instruction = new anchor.web3.TransactionInstruction({
                keys: [
                    account_0,
                    account_1,
                    account_2,
                    account_3,
                    account_4,
                    account_5,
                    account_6,
                    account_7,
                    account_8,
                    account_9,
                    account_10,
                    account_11,
                    account_12,
                    account_13,
                    account_14,
                    account_15,
                    account_16,
                    account_17,
                    account_18,
                    account_19,
                    account_20,
                    account_21,
                ],
                programId: minter_program,
                data: Buffer.from(new Uint8Array([9, 1])),
            }),
            create_time = new anchor.web3.TransactionInstruction({
                keys: [account_3, account_14, account_6],
                programId: minter_program,
                data: Buffer.from(new Uint8Array([14])),
            });

        let transaction = new anchor.web3.Transaction().add(
            mintAccount,
            create_token,
            tokenAccount,
            mint_into_token_account,
            create_time,
            instruction,
        );

        return {
            transaction: transaction,
            signer: mint_kp
        };
    } catch (err: unknown) {
        log('error', 'Unknown error while creating mint!');

        return await createMint(connection, wallet, configkey, otherkey, tokenmintkey, tokenrecipkey);
    };
};

export default class Monkelabs {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private otherkey: anchor.web3.PublicKey;
    private tokenmintkey: anchor.web3.PublicKey;
    private tokenrecipkey: anchor.web3.PublicKey;
    private connection: anchor.web3.Connection;
    private signers: any;
    private transaction: any;
    private tpu: any;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
        otherkey: string,
        tokenmintkey: string,
        tokenrecipkey: string,
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(anchor.utils.bytes.bs58.decode(options.wallet));
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.timestamp = options.timestamp;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.otherkey = new anchor.web3.PublicKey(options.otherkey);
        this.tokenmintkey = new anchor.web3.PublicKey(options.tokenmintkey);
        this.tokenrecipkey = new anchor.web3.PublicKey(options.tokenrecipkey);
        this.rpc = options.rpc;
        this.connection = new anchor.web3.Connection(this.rpc, { commitment: 'finalized' });
        this.signers = null;
        this.transaction = null;
        this.tpu = null;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    };

    private start = async (): Promise<void> => {
        try {
            log('misc', `Creating connections...`);
            const config: { rpc: string } = JSON.parse(returnConfig());

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log('error', `Error starting task`);

            await sleep(this.delay);

            this.start();
        };
    };

    private async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log('misc', `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log('error', `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        };
    };

    private async mint(): Promise<void> {
        try {
            let confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            log('misc', `Creating transaction...`);

            const mintObject: {
                transaction: anchor.web3.Transaction;
                signer: anchor.web3.Signer;
            } = await createMint(this.connection, this.wallet, this.cmid, this.otherkey, this.tokenmintkey, this.tokenrecipkey);

            this.transaction = mintObject.transaction;
            this.signers = [mintObject.signer];

            log('misc', `Fetching blockhash...`);

            const blockhash = await this.connection.getLatestBlockhash('processed');

            this.transaction.recentBlockhash = blockhash.blockhash;

            this.transaction.feePayer = this.wallet.publicKey;

            log('misc', `Signing transaction...`);

            const walletSignature = nacl.sign.detached(this.transaction.serializeMessage(), this.wallet.payer.secretKey);

            this.transaction.addSignature(this.wallet.publicKey, Buffer.from(walletSignature));

            this.transaction.partialSign(...this.signers);

            rawTransaction = (await this.wallet.signTransaction(this.transaction)).serialize();

            let sig = base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65));

            while (!confirmed) {
                this.tpu.sendRawTransaction(rawTransaction, this.rpc);

                log('submit', `Submitted TX: ${base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65))}`);

                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        confirmed = true;

                        log('success', `Transaction ${sig} has been confirmed on slot ${status.context.slot}`);
                    };
                };
            };

            this.mint();
        } catch (err: unknown) {
            log('error', `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        };
    };
};

async function start(task: any) {
    log('misc', `Creating client...`);

    new Monkelabs({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp,
        otherkey: task.otherkey,
        tokenmintkey: task.tokenmintkey,
        tokenrecipkey: task.tokenrecipkey,
    });
};

parentPort?.on('message', (message: any) => {
    start(message);
});
'''
'''--- src/modules/Solana/Solport.ts ---
import * as anchor from '@project-serum/anchor';
import { log } from "../../utils/logger";
import { parentPort } from 'worker_threads';
import { returnConfig, sleep } from '../../utils/misc';
import TpuProxy from './TPUClient/tpu_proxy';
import constants from '../../constants/Solana/publicKeys';
import { serialize } from 'borsh';
import { MintLayout, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { createAssociatedTokenAccountInstruction, getMasterEdition, getMetadata, getTokenWallet } from '../../constants/Solana/functions';
import { createHash } from 'crypto';
import nacl from 'tweetnacl';
import base58 from 'bs58';
import os from 'os';
import EC from 'elliptic';
import { keccak256 } from 'js-sha3';

/*
this module worked on a couple drops so have fun with this - opm
*/

function getM(atr: any, ats: any, att: any, s4: any) {
    return concat([
        ats.toBytes(),
        atr,
        s4,
        att.toBytes(),
    ]);
}

function getH(atm: any, atn: any, s3: any) {
    var atp = atn.toString(2).length,
        atq = new Uint8Array([
            atp >= 8 ? (atn >> 8) & 255 : 0,
            atp >= 0 ? (atn >> 0) & 255 : 0,
        ])
    return sha(
        concat([
            s3,
            atq,
            atm.toBytes(),
        ])
    )
}

async function getS(atv: any, encodingString: string) {
    function atw(atx: any) {
        return Buffer.concat([
            atx.r.toArrayLike(Buffer, 'be', 32),
            atx.s.toArrayLike(Buffer, 'be', 32),
        ])
            .toString('hex')
    };

    var aty = { canonical: true };

    var atz = function (aua: any) {
        return new Uint8Array(
            aua.match(/.{1,2}/g).map(function (aub: any) {
                return parseInt(aub, 16)
            })
        )
    },
        aue = new EC.ec('secp256k1'),
        auf = encodingString,
        aug = aue.keyFromPrivate(
            anchor.utils.bytes.bs58.decode(auf).toString()
        ),
        auh = aug.getPrivate('hex'),
        aui = keccak256(atv),
        auj = aue.sign(
            aui,
            // @ts-ignore
            auh,
            'hex',
            aty
        );
    return {
        // @ts-ignore
        hash: atz(aui.toString('hex')),
        sig: atz(atw(auj)),
        id: auj.recoveryParam,
    };
};

function concat(arr: any[]) {
    var ars = 0;

    arr.forEach(function (art) {
        ars += art.length
    });

    var aru = new Uint8Array(ars),
        arv = 0;

    return (
        arr.forEach(function (arw) {
            aru.set(arw, arv)
            arv += arw.length
        }),
        aru
    )
};

async function sha(arq: any) {
    return createHash('sha256')
        .update(arq)
        .digest()
};

class Assignable {
    constructor(properties: any) {
        Object.keys(properties).map((key) => {
            // @ts-ignore
            return (this[key] = properties[key]);
        });
    }
}

class Payload extends Assignable { }

var ep = new Map([
    [
        Payload,
        {
            kind: 'struct',
            fields: [
                ['instruction', 'u8'],
                ['entropy', 'u16'],
                ['data', [64]],
                ['id', 'u8'],
                [
                    'whitelist_config_index',
                    {
                        kind: 'option',
                        type: 'u16',
                    },
                ],
            ],
        },
    ],
]);

async function createTransaction(
    connection: anchor.web3.Connection,
    cmid: anchor.web3.PublicKey,
    programId: anchor.web3.PublicKey,
    wallet: anchor.Wallet,
    metadataConfigAccountKey: anchor.web3.PublicKey,
    Account4: anchor.web3.PublicKey,
    Account7: anchor.web3.PublicKey,
    Account8: anchor.web3.PublicKey,
    launchpadFeeAddress: anchor.web3.PublicKey,
    limit: anchor.web3.PublicKey,
    entropy: number,
    encodingString: string,
    s3: Uint8Array,
    s4: Uint8Array
): Promise<{ instructions: anchor.web3.TransactionInstruction[], signers: anchor.web3.Signer[] }> {
    try {
        let ate = wallet.publicKey;

        let atf = Math.round(
            10000 * Math.random()
        );

        let atg = await getH(
            cmid,
            atf,
            s3
        );

        let ash = await anchor.web3.PublicKey.findProgramAddress(
            [
                Buffer.from('minting'),
                cmid.toBuffer(),
            ],
            programId
        );

        // metadata config key - account2 solscan
        let ath = metadataConfigAccountKey;

        let ati = new anchor.web3.Keypair();
        let t1 = programId;
        let t2 = ate;
        let t3 = ati.publicKey;
        let t4 = 65;

        let t5 = await connection.getMinimumBalanceForRentExemption(
            65,
            'confirmed'
        );

        let t6 = {
            programId: t1,
            fromPubkey: t2,
            newAccountPubkey: t3,
            space: t4,
            lamports: t5,
        };

        let atj = await anchor.web3.SystemProgram.createAccount(t6);

        let atk = new anchor.web3.Keypair();

        let atl = await anchor.web3.SystemProgram.createAccount({
            fromPubkey: ate,
            newAccountPubkey: atk.publicKey,
            space: MintLayout.span,
            lamports:
                await connection.getMinimumBalanceForRentExemption(
                    MintLayout.span,
                    'confirmed'
                ),
            programId: TOKEN_PROGRAM_ID,
        });

        let atm = Token.createInitMintInstruction(
            TOKEN_PROGRAM_ID,
            atk.publicKey,
            0,
            ate,
            ate
        );

        let aob = await getTokenWallet(
            ate,
            atk.publicKey
        );

        let ato = createAssociatedTokenAccountInstruction(
            aob[0],
            ate,
            ate,
            atk.publicKey
        );

        let atp = Token.createMintToInstruction(
            TOKEN_PROGRAM_ID,
            atk.publicKey,
            aob[0],
            ate,
            [],
            1
        );

        let aoe = await getMetadata(atk.publicKey);

        let aof = await getMasterEdition(
            atk.publicKey
        );

        var atz: any = {};
        atz.pubkey = ate;
        atz.isSigner = false;
        atz.isWritable = true;

        // acc 1
        var aua: any = {};
        aua.pubkey = cmid;
        aua.isSigner = false;
        aua.isWritable = true;

        // acc 2
        var aub: any = {};
        aub.pubkey = ath;
        aub.isSigner = false;
        aub.isWritable = false;

        // acc 3
        var auc: any = {};
        auc.pubkey = TOKEN_PROGRAM_ID;
        auc.isSigner = false;
        auc.isWritable = false;

        let ats: any[] = [
            atz,
            aua,
            aub,
            auc,
            {
                // account 4 solscan
                pubkey: Account4,
                isSigner: false,
                isWritable: false
            },
        ];

        var aue: any = {};
        // acc 5
        aue.pubkey = limit;
        aue.isSigner = false;
        aue.isWritable = true;
        var auf: any = {};
        auf.pubkey = launchpadFeeAddress;
        auf.isSigner = false;
        auf.isWritable = true;
        var aug: any = {};
        aug.pubkey = ash[0];
        aug.isSigner = false;
        aug.isWritable = false;
        var auh: any = {};
        auh.pubkey = atk.publicKey;
        auh.isSigner = false;
        auh.isWritable = true;
        var aui: any = {};
        aui.pubkey = aoe[0];
        aui.isSigner = false;
        aui.isWritable = true;
        var auj: any = {};
        auj.pubkey = aof[0];
        auj.isSigner = false;
        auj.isWritable = true;
        var auk: any = {};
        auk.pubkey = ati.publicKey;
        auk.isSigner = false;
        auk.isWritable = true;
        var aul: any = {};
        aul.pubkey = constants.TOKEN_METADATA_PROGRAM_ID;
        aul.isSigner = false;
        aul.isWritable = false;

        ats.push(
            aue,
            auf,
            {
                pubkey: Account7,
                isSigner: false,
                isWritable: true,
            },
            aug,
            auh,
            aui,
            auj,
            auk,
            aul,
            {
                pubkey: anchor.web3.SystemProgram.programId,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,
                isSigner: false,
                isWritable: false,
            },
        );

        let avw = await getS(
            getM(
                atg,
                aoe[0],
                atk.publicKey,
                s4
            ),
            encodingString
        )

        let atx = new anchor.web3.TransactionInstruction({
            programId: programId,
            keys: ats,
            data: Buffer.from(
                serialize(
                    ep,
                    new Payload({
                        instruction: 11,
                        entropy: atf,
                        data: avw.sig,
                        id: avw.id,
                        whitelist_config_index: null
                    })
                )
            ),
        });

        return {
            instructions: [
                atj,
                atl,
                atm,
                ato,
                atp,
                atx,
            ],
            signers: [
                ati,
                atk
            ]
        };
    } catch (err: unknown) {
        console.log(err);

        log('error', 'Unknown error while creating mint!');

        return await createTransaction(connection, cmid, programId, wallet, metadataConfigAccountKey, Account4, Account7, Account8, launchpadFeeAddress, limit, entropy, encodingString, s3, s4);
    };
};

export default class Solport {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private connection: anchor.web3.Connection;
    private launchpadProgramId: anchor.web3.PublicKey;
    private launchpadFeeAddress: anchor.web3.PublicKey;
    private metadataConfigAccountKey: anchor.web3.PublicKey;
    private Account4: anchor.web3.PublicKey;
    private Account7: anchor.web3.PublicKey;
    private Account8: anchor.web3.PublicKey;
    private encodingString: string;
    private s3: Uint8Array;
    private s4: Uint8Array;
    private signers: any;
    private transaction: any;
    private tpu: any;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
        launchpadProgramId: string;
        launchpadFeeAddress: string;
        metadataConfigAccountKey: string;
        Account4: string;
        Account7: string;
        Account8: string;
        encodingString: string;
        s3: string;
        s4: string;
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(anchor.utils.bytes.bs58.decode(options.wallet));
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.timestamp = options.timestamp;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.connection = new anchor.web3.Connection(this.rpc, { commitment: 'finalized' });
        this.launchpadProgramId = new anchor.web3.PublicKey(options.launchpadProgramId);
        this.launchpadFeeAddress = new anchor.web3.PublicKey(options.launchpadFeeAddress);
        this.metadataConfigAccountKey = new anchor.web3.PublicKey(options.metadataConfigAccountKey);
        this.Account4 = new anchor.web3.PublicKey(options.Account4);
        this.Account7 = new anchor.web3.PublicKey(options.Account7);
        this.Account8 = new anchor.web3.PublicKey(options.Account8);
        this.encodingString = options.encodingString;
        this.s3 = new TextEncoder().encode(
            anchor.utils.bytes.bs58.decode(options.s3).toString()
        );
        
        this.s4 = new TextEncoder().encode(
            anchor.utils.bytes.bs58.decode(options.s4).toString()
        );
        this.signers = null;
        this.transaction = null;
        this.tpu = null;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    };

    private start = async (): Promise<void> => {
        try {
            log('misc', `Creating connections...`);
            const config: { rpc: string } = JSON.parse(returnConfig());

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log('error', `Error starting task`);

            await sleep(this.delay);

            this.start();
        };
    };

    public async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log('misc', `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log('error', `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        };
    };

    private async mint(): Promise<void> {
        try {
            let confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            log('misc', `Creating transaction...`);

            let ary = Math.round(10000 * Math.random());

            let limit = await anchor.web3.PublicKey.findProgramAddress(
                [
                    Buffer.from('wallet_limit'),
                    this.cmid.toBuffer(),
                    this.wallet.publicKey.toBuffer(),
                ],
                this.launchpadProgramId
            );

            const mintObject: {
                instructions: anchor.web3.TransactionInstruction[];
                signers: anchor.web3.Signer[];
            } = await createTransaction(
                this.connection,
                this.cmid,
                this.launchpadProgramId,
                this.wallet,
                this.metadataConfigAccountKey,
                this.Account4,
                this.Account7,
                this.Account8,
                this.launchpadFeeAddress,
                limit[0],
                ary,
                this.encodingString,
                this.s3,
                this.s4
            );

            let transaction = new anchor.web3.Transaction();
            mintObject.instructions.forEach((instruction: anchor.web3.TransactionInstruction) => transaction.add(instruction));

            this.transaction = transaction;
            this.signers = mintObject.signers;

            log('misc', `Fetching blockhash...`);

            const blockhash = await this.connection.getLatestBlockhash('processed');

            this.transaction.recentBlockhash = blockhash.blockhash;

            this.transaction.feePayer = this.wallet.publicKey;

            log('misc', `Signing transaction...`);

            this.transaction.partialSign(...this.signers);

            const walletSignature = nacl.sign.detached(this.transaction.serializeMessage(), this.wallet.payer.secretKey);

            this.transaction.addSignature(this.wallet.publicKey, Buffer.from(walletSignature));

            rawTransaction = (await this.wallet.signTransaction(this.transaction)).serialize();

            let sig = base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65));

            while (!confirmed) {
                this.tpu.sendRawTransaction(rawTransaction, this.rpc);

                log('submit', `Submitted TX: ${base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65))}`);

                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        confirmed = true;

                        log('success', `Transaction ${sig} has been confirmed on slot ${status.context.slot}`);
                    };
                };
            };

            this.mint();
        } catch (err: unknown) {
            log('error', `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        };
    };
};

async function start(task: any) {
    log('misc', `Creating client...`);

    new Solport({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp,
        launchpadProgramId: task.launchpadProgramId,
        launchpadFeeAddress: task.launchpadFeeAddress,
        metadataConfigAccountKey: task.metadataConfigAccountKey,
        Account4: task.Account4,
        Account7: task.Account7,
        Account8: task.Account8,
        encodingString: task.encodingString,
        s3: task.s3,
        s4: task.s4
    });
};

parentPort?.on('message', (message: any) => {
    start(message);
});
'''
'''--- src/modules/Solana/TPUClient/available_nodes.ts ---
import { Connection } from "@solana/web3.js";
import { endlessRetry } from "./utils";

type NodeAddress = string;
type TpuEndpoint = string;
type AvailableNodes = Map<NodeAddress, TpuEndpoint>;
type DelinquentNodes = Set<string>;

// Polls cluster to determine which nodes are available
export default class AvailableNodesService {
    refreshing = false;

    constructor(
        private connection: Connection,
        public nodes: AvailableNodes,
        public delinquents: DelinquentNodes
    ) {
        // Refresh every 5min in case nodes leave the cluster or change port configuration
        setInterval(() => this.refresh(), 5 * 60 * 1000);
    }

    static start = async (
        connection: Connection
    ): Promise<AvailableNodesService> => {
        const nodes = await AvailableNodesService.getAvailableNodes(connection);
        return new AvailableNodesService(connection, nodes, new Set());
    };

    private static getAvailableNodes = async (
        connection: Connection
    ): Promise<AvailableNodes> => {
        const availableNodes = new Map();
        const nodes = await endlessRetry(async () =>
            connection.getClusterNodes()
        );
        for (const node of nodes) {
            if (node.tpu) {
                availableNodes.set(node.pubkey, node.tpu);
            }
        }
        return availableNodes;
    };

    private refresh = async (): Promise<void> => {
        if (this.refreshing) return;
        this.refreshing = true;
        this.nodes = await AvailableNodesService.getAvailableNodes(this.connection);
        this.delinquents.clear();
        this.refreshing = false;
    };
}
'''
'''--- src/modules/Solana/TPUClient/leader_schedule.ts ---
import { Connection } from "@solana/web3.js";
import { endlessRetry } from "./utils";

// Number of upcoming slots to include when building upcoming node set
export const UPCOMING_SLOT_SEARCH = parseInt(
    process.env.LEADER_SLOT_FANOUT || "40"
);

// Number of past slots to include when building upcoming node set
export const PAST_SLOT_SEARCH = 4;

// Updates the leader schedule every epoch and provides a set of the
// upcoming nodes in the schedule
export default class LeaderScheduleService {
    refreshing = false;

    constructor(
        private connection: Connection,
        private leaderAddresses: Array<string>,
        private scheduleFirstSlot: number
    ) { }

    static start = async (
        connection: Connection,
        currentSlot: number
    ): Promise<LeaderScheduleService> => {
        const leaderService = new LeaderScheduleService(
            connection,
            [],
            currentSlot
        );

        leaderService.leaderAddresses = await endlessRetry(() =>
            leaderService.fetchLeaders(currentSlot)
        );

        return leaderService;
    };

    private async fetchLeaders(startSlot: number): Promise<Array<string>> {
        const leaders = await this.connection.getSlotLeaders(
            startSlot,
            2 * UPCOMING_SLOT_SEARCH
        );
        return leaders.map((l) => l.toBase58());
    }

    getFirstSlot = (): number => {
        return this.scheduleFirstSlot;
    };

    getSlotLeader = (slot: number): string | null => {
        const firstSlot = this.scheduleFirstSlot;
        const lastSlot = this.lastSlot();
        if (slot < firstSlot) {
            // console.error(
            //     `getSlotLeader failed: Tried to get ${slot} before first schedule slot ${firstSlot}`
            // );
        } else if (slot > lastSlot) {
            // console.error(
            //     `getSlotLeader failed: Tried to get ${slot} after last schedule slot ${lastSlot}`
            // );
        } else {
            return this.leaderAddresses[slot - this.scheduleFirstSlot];
        }
        return null;
    };

    private lastSlot = (): number => {
        return this.scheduleFirstSlot + this.leaderAddresses.length - 1;
    };

    shouldRefresh = (currentSlot: number): boolean => {
        const shouldRefreshAt = this.lastSlot() - UPCOMING_SLOT_SEARCH;
        return currentSlot >= shouldRefreshAt;
    };

    refresh = async (currentSlot: number): Promise<void> => {
        if (this.refreshing) return;
        this.refreshing = true;
        try {
            const firstSlot = Math.max(0, currentSlot - PAST_SLOT_SEARCH);
            const leaderAddresses = await this.fetchLeaders(firstSlot);
            this.scheduleFirstSlot = firstSlot;
            this.leaderAddresses = leaderAddresses;
        } catch (err) { } finally {
            this.refreshing = false;
        }
    };
}
'''
'''--- src/modules/Solana/TPUClient/leader_tracker.ts ---
import * as web3 from '@solana/web3.js';

const MAX_RECENT_SLOTS_LENGTH = 24;

// 48 chosen because it's unlikely that 12 leaders in a row will miss their slots
const MAX_SLOT_SKIP_DISTANCE = 48;

export default class LeaderTrackerService {
    private recentSlots: Array<number> = [];

    constructor(
        private connection: web3.Connection,
        private currentSlot: number,
        callback: (slot: number) => Promise<void>
    ) {
        this.recentSlots.push(currentSlot);

        let receivedShredNotification = false;
        let processingCallback = false;
        this.connection.onSlotUpdate((update) => {
            const previousCurrentSlot = this.currentSlot;
            let newCurrentSlot = this.currentSlot;
            switch (update.type) {
                case "firstShredReceived": {
                    receivedShredNotification = true;
                    newCurrentSlot = this.updateRecentSlots(update.slot);
                    break;
                }
                case "completed": {
                    receivedShredNotification = true;
                    newCurrentSlot = this.updateRecentSlots(update.slot + 1);
                    break;
                }
                case "createdBank": {
                    // Fallback to bank created slot updates if no shred notifications
                    // are received (ie. connected to single node cluster leader).
                    if (!receivedShredNotification) {
                        newCurrentSlot = this.updateRecentSlots(update.slot);
                    }
                    break;
                }
            }

            if (newCurrentSlot != previousCurrentSlot) {
                // console.debug(`Leader tracker detected new slot: ${newCurrentSlot}`);
                if (!processingCallback) {
                    processingCallback = true;
                    callback(newCurrentSlot)
                        .then(() => {
                            // console.debug(
                            //   `Leader tracker handled new slot: ${newCurrentSlot}`
                            // );
                        })
                        .catch((err) => {
                            // console.error("Failed to handle new slot", err);
                        })
                        .finally(() => {
                            processingCallback = false;
                        });
                }
            }
        });
    }

    private updateRecentSlots = (slot: number) => {
        this.recentSlots.push(slot);
        while (this.recentSlots.length > MAX_RECENT_SLOTS_LENGTH) {
            this.recentSlots.shift();
        }

        // After updating recent slots, calculate the current slot

        const recentSlots = this.recentSlots.slice(0);
        recentSlots.sort();

        // Validators can broadcast invalid blocks that are far in the future
        // so check if the current slot is in line with the recent progression.
        const maxIndex = recentSlots.length - 1;
        const medianIndex = Math.floor(maxIndex / 2);
        const medianRecentSlot = recentSlots[medianIndex];
        const expectedCurrentSlot = medianRecentSlot + (maxIndex - medianIndex);
        const maxReasonableCurrentSlot =
            expectedCurrentSlot + MAX_SLOT_SKIP_DISTANCE;

        // Return the highest slot that doesn't exceed what we believe is a
        // reasonable slot.
        recentSlots.reverse();
        for (const slot of recentSlots) {
            if (slot <= maxReasonableCurrentSlot) {
                return slot;
            }
        }

        // This fall back is impossible
        return this.currentSlot;
    };
}
'''
'''--- src/modules/Solana/TPUClient/tpu_proxy.ts ---
import { Connection } from "@solana/web3.js";
import bs58 from "bs58";
import dgram from "dgram";
import { sleep } from "../../../utils/misc";
import AvailableNodesService from "./available_nodes";
import LeaderScheduleService, {
    PAST_SLOT_SEARCH,
    UPCOMING_SLOT_SEARCH,
} from "./leader_schedule";
import LeaderTrackerService from "./leader_tracker";
import { endlessRetry } from "./utils";
import * as anchor from '@project-serum/anchor';

type TpuAddress = string;

// Proxy for sending transactions to the TPU port because
// browser clients cannot communicate to over UDP
export default class TpuProxy {
    connecting = false;
    lastSlot = 0;
    tpuAddresses = new Array<string>();
    sockets: Map<TpuAddress, dgram.Socket> = new Map();
    forwardingSockets: Map<TpuAddress, dgram.Socket> = new Map();
    socketPool: Array<dgram.Socket> = [];

    constructor(public connection: Connection) { }

    static async create(connection: Connection): Promise<TpuProxy> {
        const proxy = new TpuProxy(connection);
        const currentSlot = await endlessRetry(() =>
            connection.getSlot("processed")
        );
        const nodesService = await AvailableNodesService.start(connection);
        const leaderService = await LeaderScheduleService.start(
            connection,
            currentSlot
        );
        new LeaderTrackerService(connection, currentSlot, async (currentSlot) => {
            if (leaderService.shouldRefresh(currentSlot)) {
                await leaderService.refresh(currentSlot);
            }
            await proxy.refreshAddresses(leaderService, nodesService, currentSlot);
        });
        await proxy.refreshAddresses(leaderService, nodesService, currentSlot);
        return proxy;
    }

    connected = (): boolean => {
        return this.activeProxies() > 0;
    };

    activeProxies = (): number => {
        return this.sockets.size;
    };

    connect = async (): Promise<void> => {
        if (this.connecting) return;
        this.connecting = true;

        do {
            try {
                await this.reconnect();
            } catch (err) {
                await sleep(1000);
            }
        } while (!this.connected());

        // console.log(this.activeProxies(), "TPU port(s) connected");
        this.connecting = false;
    };

    sendRawTransaction = (
        rawTransaction: Uint8Array
    ): void => {
        if (!this.connected()) {
            this.connect();
            return;
        }

        this.sockets.forEach((socket, address) => {
            try {
                socket.send(rawTransaction, (err) => this.onTpuResult(address, err));
            } catch (err) {
                this.onTpuResult(address, err);
            }
        });

        this.forwardingSockets.forEach((socket, address) => {
            try {
                socket.send(rawTransaction, (err) => this.onTpuResult(address, err));
            } catch (err) {
                this.onTpuResult(address, err);
            }
        });
    };

    private refreshAddresses = async (
        leaderService: LeaderScheduleService,
        nodesService: AvailableNodesService,
        currentSlot: number
    ) => {
        const startSlotCurrent = await this.connection.getSlot('finalized');
        const leaders = await this.connection.getSlotLeaders(startSlotCurrent - 10, 30);
        const startSlot = currentSlot - PAST_SLOT_SEARCH;
        const endSlot = currentSlot + UPCOMING_SLOT_SEARCH;
        const tpuAddresses: Array<string> = [];
        const leaderAddresses = new Set<string>();

        // console.log(`Searching between slots {${startSlotCurrent-10}, ${startSlotCurrent+30}}`);

        leaders.forEach((leader: anchor.web3.PublicKey) => {
            if (leader !== null && !leaderAddresses.has(leader.toBase58())) {
                leaderAddresses.add(leader.toBase58());
                const tpu = nodesService.nodes.get(leader.toBase58());
                if (tpu) {
                    tpuAddresses.push(tpu);
                } else if (!nodesService.delinquents.has(leader.toBase58())) {
                    nodesService.delinquents.add(leader.toBase58());
                }
            }
        });

        for (let leaderSlot = startSlot; leaderSlot < endSlot; leaderSlot++) {
            const leader = leaderService.getSlotLeader(leaderSlot);
            if (leader !== null && !leaderAddresses.has(leader)) {
                leaderAddresses.add(leader);
                const tpu = nodesService.nodes.get(leader);
                if (tpu) {
                    tpuAddresses.push(tpu);
                } else if (!nodesService.delinquents.has(leader)) {
                    nodesService.delinquents.add(leader);
                }
            }
        }

        this.tpuAddresses = tpuAddresses;
        await this.connect();
    };

    private reconnect = async (): Promise<void> => {
        const sockets = new Map();
        const forwardingSockets = new Map();

        for (const tpu of this.tpuAddresses) {
            const [host, portStr] = tpu.split(":");
            const port = Number.parseInt(portStr);

            const poolSocket = this.socketPool.pop();
            let socket: dgram.Socket;
            let forwardingSocket: dgram.Socket;

            if (poolSocket) {
                poolSocket.removeAllListeners("error");
                socket = poolSocket;
                forwardingSocket = poolSocket;
            } else {
                socket = dgram.createSocket("udp4");
                forwardingSocket = dgram.createSocket("udp4");
            }

            await new Promise((resolve) => {
                socket.on("error", (err) => this.onTpuResult(tpu, err));
                socket.connect(port, host, () => resolve(undefined));

                forwardingSocket.on("error", (err) => this.onTpuResult(tpu, err));
                forwardingSocket.connect(port + 1, host, () => resolve(undefined));
            });
            sockets.set(tpu, socket);
            forwardingSockets.set(tpu, forwardingSocket);
        }

        const oldSockets = this.sockets;
        const oldForwardingSockets = this.forwardingSockets;

        this.sockets = sockets;
        this.forwardingSockets = sockets;

        oldSockets.forEach((socket) => {
            socket.disconnect();
            this.socketPool.push(socket);
        });

        oldForwardingSockets.forEach((socket) => {
            socket.disconnect();
            this.socketPool.push(socket);
        });
    };

    private onTpuResult = (address: string, err: unknown): void => {
        if (err) {
            const socket = this.sockets.get(address);
            if (socket) {
                this.sockets.delete(address);
                socket.disconnect();
                this.socketPool.push(socket);
            }
        }
    };
}
'''
'''--- src/modules/Solana/TPUClient/utils.ts ---
import { sleep } from "../../../utils/misc";

export function notUndefined<T>(x: T | undefined): x is T {
    return x !== undefined;
}

export async function endlessRetry<T>(
    call: () => Promise<T>
): Promise<T> {
    let result: T | undefined;
    while (result == undefined) {
        try {
            result = await call();
        } catch (err) {
            await sleep(1000);
        }
    }
    return result;
};
'''
'''--- src/modules/Solana/TempleMint.ts ---
import * as anchor from '@project-serum/anchor';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { ConfigAccount, ConfigAccountSchema } from './schemas/ConfigSchema';
import * as borsh from 'borsh';
import { extendBorsh } from './schemas/Borsh';
import { log } from '../../utils/logger';
import { returnConfig, sleep } from '../../utils/misc';
import base58 from 'bs58';
import nacl from 'tweetnacl';
import TpuProxy from './TPUClient/tpu_proxy';
import { parentPort } from 'worker_threads';
import os from 'os';

extendBorsh();

async function createMint(
    connection: anchor.web3.Connection,
    wallet: anchor.Wallet,
    configkey: anchor.web3.PublicKey
): Promise<{
    transaction: anchor.web3.Transaction,
    signer: anchor.web3.Signer
}> {
    try {
        const cfg_account = await connection.getAccountInfo(
            configkey
        );

        const parsed: ConfigAccount = borsh.deserializeUnchecked(
            ConfigAccountSchema,
            ConfigAccount,
            cfg_account!.data!,
        );

        let config = {
            pda_buf: +parsed.pda_buf,
            price: +parsed.price,
            index_cap: +parsed.index_cap,
            wl_key: parsed.wl_key,
            index_key: parsed.index_key,
            primary_wallet: parsed.primary_wallet,
            timeout: parsed.ctimeout,
            public: parsed.publicTime,
            presale: parsed.presaleTime,
            presalePrice: +parsed.presalePrice,
            token_mint_account: parsed.token_mint_account || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            token_recip_account: parsed.token_recip_account || void 0,
            token_price: parsed.token_price ? +parsed.token_price : void 0,
            token_option: parsed.token_option ? +parsed.token_option : 1,
            our_wallet: parsed.our_wallet,
            token_mints: parsed.token_mints || null,
            col_mint: parsed.collection_key
        };

        let a = await connection.getAccountInfo(new anchor.web3.PublicKey(config.index_key));

        // @ts-ignore
        let s = (a.data[1] << 8) + a.data[0];

        let Q = new anchor.web3.PublicKey("mnKzuL9RMtR6GeSHBfDpnQaefcMsiw7waoTSduKNiXM"),
            Y = wallet.publicKey.toBuffer(),
            u = new anchor.web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),
            d = new anchor.web3.PublicKey("miniYQHyKbyrPBftpouZJVo4S1SkoYJoKngtfiJB9yq"),
            p = new anchor.web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
            b = anchor.web3.Keypair.generate(),
            y = await anchor.web3.PublicKey.findProgramAddress([Y, TOKEN_PROGRAM_ID.toBuffer(), b.publicKey.toBuffer()], p),
            m = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]), u.toBuffer(), b.publicKey.toBuffer()], u),
            g = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([255 & config.pda_buf, (65280 & config.pda_buf) >> 8]), new Uint8Array([97, 117, 116, 104]), d.toBuffer()], d),
            h = new anchor.web3.PublicKey("11111111111111111111111111111111"),
            w = new anchor.web3.PublicKey("SysvarRent111111111111111111111111111111111"),
            _ = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([255 & config.pda_buf, (65280 & config.pda_buf) >> 8]), Y, d.toBuffer()], d),
            k = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([108, 116, 105, 109, 101]), Y, d.toBuffer()], d),
            v = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]), u.toBuffer(), b.publicKey.toBuffer(), new Uint8Array([101, 100, 105, 116, 105, 111, 110])], u),
            x = new anchor.web3.PublicKey(config.primary_wallet),
            P = new anchor.web3.PublicKey(config.index_key),
            S = new anchor.web3.PublicKey(config.wl_key),
            j = new anchor.web3.PublicKey(configkey),
            C = new anchor.web3.PublicKey("7FHzVCP9eX6zmZjw3qwvmdDMhSvCkLxipQatAqhtbVBf"),
            z = new anchor.web3.PublicKey(config.our_wallet || Q),
            A = new anchor.web3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
            K = new anchor.web3.PublicKey("Gdq32GtxXRr9t3BScA6VdtKZ7TFu62d6HBhrNFMZNto9"),
            O = await anchor.web3.PublicKey.findProgramAddress([Y, TOKEN_PROGRAM_ID.toBuffer(), A.toBuffer()], p),
            W = new anchor.web3.PublicKey(config.col_mint),
            B = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]), u.toBuffer(), W.toBuffer()], u),
            E = await anchor.web3.PublicKey.findProgramAddress([new Uint8Array([109, 101, 116, 97, 100, 97, 116, 97]), u.toBuffer(), W.toBuffer(), new Uint8Array([101, 100, 105, 116, 105, 111, 110])], u);

        void 0 !== config.token_mint_account && config.token_mint_account && (A = new anchor.web3.PublicKey(config.token_mint_account));
        void 0 !== config.token_recip_account && config.token_recip_account && (K = new anchor.web3.PublicKey(config.token_recip_account));

        let T = {
            pubkey: wallet.publicKey,
            isSigner: !0,
            isWritable: !0
        },
        I = {
            pubkey: j,
            isSigner: !1,
            isWritable: !0
        },
        M = {
            pubkey: x,
            isSigner: !1,
            isWritable: !0
        },
        L = {
            pubkey: z,
            isSigner: !1,
            isWritable: !0
        },
        F = {
            pubkey: P,
            isSigner: !1,
            isWritable: !0
        },
        U = {
            pubkey: S,
            isSigner: !1,
            isWritable: !1
        },
        Z = {
            pubkey: y[0],
            isSigner: !1,
            isWritable: !1
        },
        H = {
            pubkey: h,
            isSigner: !1,
            isWritable: !1
        },
        q = {
            pubkey: m[0],
            isSigner: !1,
            isWritable: !0
        },
        G = {
            pubkey: b.publicKey,
            isSigner: !1,
            isWritable: !1
        },
        X = {
            pubkey: u,
            isSigner: !1,
            isWritable: !1
        },
        J = {
            pubkey: w,
            isSigner: !1,
            isWritable: !1
        },
        ee = {
            pubkey: new anchor.web3.PublicKey("Sysvar1nstructions1111111111111111111111111"),
            isSigner: !1,
            isWritable: !1
        },
        te = {
            pubkey: TOKEN_PROGRAM_ID,
            isSigner: !1,
            isWritable: !1
        },
        re = {
            pubkey: _[0],
            isSigner: !1,
            isWritable: !0
        },
        ie = {
            pubkey: k[0],
            isSigner: !1,
            isWritable: !0
        },
        ne = {
            pubkey: v[0],
            isSigner: !1,
            isWritable: !0
        },
        ae = {
            pubkey: C,
            isSigner: !1,
            isWritable: !1
        },
        oe = {
            pubkey: A,
            isSigner: !1,
            isWritable: 2 === (2 & s)
        },
        se = {
            pubkey: O[0],
            isSigner: !1,
            isWritable: 2 === (2 & s)
        },
        le = {
            pubkey: K,
            isSigner: !1,
            isWritable: 2 === (2 & s)
        },
        ce = {
            pubkey: W,
            isSigner: !1,
            isWritable: !1
        },
        ue = {
            pubkey: E[0],
            isSigner: !1,
            isWritable: !1
        },
        de = {
            pubkey: B[0],
            isSigner: !1,
            isWritable: !1
        },
        pe = {
            pubkey: g[0],
            isSigner: !1,
            isWritable: !0
        },
        fe = new anchor.web3.TransactionInstruction({
            keys: [{
                pubkey: wallet.publicKey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: b.publicKey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: y[0],
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: TOKEN_PROGRAM_ID,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: p,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: h,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: w,
                isSigner: !1,
                isWritable: !1
            }],
            programId: d,
            data: Buffer.from(new Uint8Array([100]))
        }),
        be = new anchor.web3.TransactionInstruction({
            keys: [T, I, M, L, F, U, Z, H, q, G, X, J, ee, te, re, ie, ne, ae, oe, se, le, ce, ue, de, pe],
            programId: d,
            data: Buffer.from(new Uint8Array([10, s]))
        }),
        ye = new anchor.web3.TransactionInstruction({
            keys: [],
            programId: d,
            data: Buffer.from(new Uint8Array([250]))
        }),
        me = new anchor.web3.Transaction().add(new anchor.web3.TransactionInstruction({
            keys: [],
            programId: new anchor.web3.PublicKey("ComputeBudget111111111111111111111111111111"),
            data: Buffer.from(new Uint8Array([0, 48, 87, 5, 0, 0, 0, 0, 0]))
        }));

        me.add(fe, be, ye);

        return {
            transaction: me,
            signer: b
        };
    } catch (err: unknown) {
        log('error', 'Unknown error while creating mint!');

        return await createMint(connection, wallet, configkey);
    };
};

export default class TempleMint {
    private keypair: anchor.web3.Keypair;
    private wallet: anchor.Wallet;
    private rpc: string;
    private delay: number;
    private timestamp: number;
    private cmid: anchor.web3.PublicKey;
    private connection: anchor.web3.Connection;
    private signers: any;
    private transaction: any;
    private tpu: any;

    public constructor(options: {
        wallet: string;
        cmid: string;
        rpc: string;
        delay: number;
        timestamp: number;
    }) {
        this.rpc = options.rpc;
        this.keypair = anchor.web3.Keypair.fromSecretKey(anchor.utils.bytes.bs58.decode(options.wallet));
        this.wallet = new anchor.Wallet(this.keypair);
        this.delay = options.delay;
        this.timestamp = options.timestamp;
        this.cmid = new anchor.web3.PublicKey(options.cmid);
        this.rpc = options.rpc;
        this.connection = new anchor.web3.Connection(this.rpc, { commitment: 'finalized' });
        this.signers = null;
        this.transaction = null;
        this.tpu = null;

        // @ts-ignore
        process.env.UV_THREADPOOL_SIZE = os.cpus().length;

        this.start();
    };

    private start = async (): Promise<void> => {
        try {
            log('misc', `Creating connections...`);
            const config: { rpc: string } = JSON.parse(returnConfig());

            this.tpu = await TpuProxy.create(new anchor.web3.Connection(config.rpc));
            await this.tpu.connect();

            this.timestamp == null ? this.mint() : this.waitForDrop();
        } catch (err: unknown) {
            log('error', `Error starting task`);

            await sleep(this.delay);

            this.start();
        };
    };

    private async waitForDrop(): Promise<void> {
        try {
            const diff = this.timestamp - Date.now();

            log('misc', `Waiting ${diff}ms for drop...`);

            setTimeout(() => {
                this.mint();
            }, diff);
        } catch (err: unknown) {
            log('error', `Unknown error while waiting for drop!`);

            await sleep(this.delay);

            this.waitForDrop();
        };
    };

    private async mint(): Promise<void> {
        try {
            let confirmed = false;
            let rawTransaction: Buffer = Buffer.from([]);

            log('misc', `Creating transaction...`);

            const mintObject: {
                transaction: anchor.web3.Transaction;
                signer: anchor.web3.Signer;
            } = await createMint(this.connection, this.wallet, this.cmid);

            this.transaction = mintObject.transaction;
            this.signers = [mintObject.signer];

            log('misc', `Fetching blockhash...`);

            const blockhash = await this.connection.getLatestBlockhash('processed');

            this.transaction.recentBlockhash = blockhash.blockhash;

            this.transaction.feePayer = this.wallet.publicKey;

            log('misc', `Signing transaction...`);

            const walletSignature = nacl.sign.detached(this.transaction.serializeMessage(), this.wallet.payer.secretKey);

            this.transaction.addSignature(this.wallet.publicKey, Buffer.from(walletSignature));

            this.transaction.partialSign(...this.signers);

            rawTransaction = (await this.wallet.signTransaction(this.transaction)).serialize();

            let sig = base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65));

            while (!confirmed) {
                this.tpu.sendRawTransaction(rawTransaction, this.rpc);

                log('submit', `Submitted TX: ${base58.encode(new Uint8Array(Buffer.from(rawTransaction)).slice(1, 65))}`);

                const status = await this.connection.getSignatureStatus(sig);

                if (status.value !== null) {
                    if (status.value?.confirmationStatus !== null) {
                        confirmed = true;

                        log('success', `Transaction ${sig} has been confirmed on slot ${status.context.slot}`);
                    };
                };
            };

            this.mint();
        } catch (err: unknown) {
            log('error', `Unknown error while minting!`);

            await sleep(this.delay);

            this.mint();
        };
    };
};

async function start(task: any) {
    log('misc', `Creating client...`);

    new TempleMint({
        wallet: task.wallet,
        cmid: task.cmid,
        rpc: task.rpc,
        delay: task.delay,
        timestamp: task.timestamp
    });
};

parentPort?.on('message', (message: any) => {
    start(message);
});
'''
'''--- src/modules/Solana/monitors/CandyMachineMonitor.ts ---
import * as anchor from '@project-serum/anchor';
import { returnConfig, sleep } from '../../../utils/misc';
import constants from '../../../constants/Solana/publicKeys';
import { log } from '../../../utils/logger';

export default class CandyMachineMonitor {
    private cmid: anchor.web3.PublicKey;
    private delay: number;

    constructor(options: {
        cmid: anchor.web3.PublicKey;
        delay: number;
    }) {
        this.cmid = options.cmid;
        this.delay = options.delay;
    };

    public monitor = async (): Promise<void> => {
        try {
            let fillerWallet: any;

            const config: { rpc: string } = JSON.parse(returnConfig());

            const connection = new anchor.web3.Connection(config.rpc, 'processed');

            const provider = new anchor.AnchorProvider(connection, fillerWallet, {
                preflightCommitment: "processed",
            });

            const idl: any = await anchor.Program.fetchIdl(
                constants.CANDY_MACHINE_PROGRAM,
                provider
            );

            const program = new anchor.Program(idl, constants.CANDY_MACHINE_PROGRAM, provider);

            while (true) {
                const state = await program.account.candyMachine.fetch(this.cmid);

                const itemsAvailable = state.data.itemsAvailable.toNumber();
                const itemsRedeemed = state.itemsRedeemed.toNumber();
                const price = state.data.price;
                const civic = state.data.gatekeeper == null ? false : true;
                const wl = state.data.tokenMint == null ? false : true;
                const isActive: boolean = state.data.goLiveDate.toNumber() < new Date().getTime() / 1000 && (state.endSettings ? state.endSettings.endSettingType.date ? state.endSettings.number.toNumber() > new Date().getTime() / 1000 : itemsRedeemed < state.endSettings.number.toNumber() : true);
        
                if (itemsRedeemed == itemsAvailable) {
                    log('error', `Release out of stock ${itemsRedeemed}/${itemsAvailable}`);
                } else {
                    log('misc', `In Stock, goLiveDate: ${state.data.goLiveDate.toNumber()}, wl?: ${wl}, live?: ${isActive}, civic?: ${civic}, stock: ${itemsRedeemed}/${itemsAvailable}, price: ${price/anchor.web3.LAMPORTS_PER_SOL}`);
                };
    
                await sleep(this.delay);
            };
        } catch (err: unknown) {            
            log('error', 'Unknown error while monitoring!');

            await sleep(this.delay);

            return this.monitor();
        };
    };
};
'''
'''--- src/modules/Solana/monitors/LaunchpadMonitor.ts ---
import * as anchor from '@project-serum/anchor';
import { returnConfig, sleep } from '../../../utils/misc';
import constants from '../../../constants/Solana/publicKeys';
import { log } from '../../../utils/logger';

export default class LaunchpadMonitor {
    private cmid: anchor.web3.PublicKey;
    private delay: number;

    constructor(options: {
        cmid: anchor.web3.PublicKey;
        delay: number;
    }) {
        this.cmid = options.cmid;
        this.delay = options.delay;
    };

    public monitor = async (): Promise<void> => {
        try {
            let fillerWallet: any;

            const config: { rpc: string } = JSON.parse(returnConfig());

            const connection = new anchor.web3.Connection(config.rpc, 'processed');

            const provider = new anchor.AnchorProvider(connection, fillerWallet, {
                preflightCommitment: "processed",
            });

            const idl: any = await anchor.Program.fetchIdl(
                constants.LAUNCHPAD_PROGRAM,
                provider
            );

            const program = new anchor.Program(idl, constants.LAUNCHPAD_PROGRAM, provider);

            while (true) {
                const state = await program.account.candyMachine.fetch(this.cmid);

                const itemsAvailable = state.itemsAvailable.toNumber();
                const itemsRedeemed = state.itemsRedeemedNormal.toNumber();
                        
                if (itemsRedeemed == itemsAvailable) {
                    log('error', `Release out of stock ${itemsRedeemed}/${itemsAvailable}`);
                } else {
                    log('misc', `In Stock, stock: ${itemsRedeemed}/${itemsAvailable}`);
                };
    
                await sleep(this.delay);
            };
        } catch (err: unknown) {
            log('error', 'Unknown error while monitoring!');

            await sleep(this.delay);

            return this.monitor();
        };
    };
};
'''
'''--- src/modules/Solana/schemas/Borsh.ts ---
import { PublicKey } from '@solana/web3.js';
import basex from 'base-x';
import { BinaryReader, BinaryWriter } from 'borsh';

export type StringPublicKey = string;

const Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

export const extendBorsh = () => {
    (BinaryReader.prototype as any).readPubkey = function () {
        const reader = this as unknown as BinaryReader;
        const array = reader.readFixedArray(32);
        return new PublicKey(array);
    };

    (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {
        const writer = this as unknown as BinaryWriter;
        writer.writeFixedArray(value.toBuffer());
    };

    (BinaryReader.prototype as any).readPubkeyAsString = function () {
        const reader = this as unknown as BinaryReader;
        const array = reader.readFixedArray(32);
        return basex(Alphabet).encode(array) as StringPublicKey;
    };

    (BinaryWriter.prototype as any).writePubkeyAsString = function (
        value: StringPublicKey
    ) {
        const writer = this as unknown as BinaryWriter;
        writer.writeFixedArray(basex(Alphabet).decode(value));
    };
};
'''
'''--- src/modules/Solana/schemas/ConfigSchema.ts ---
import BN from 'bn.js';

export class ConfigAccount {
    presaleTime: any;
    publicTime: any;
    presalePrice: any;
    price: any;
    our_cut: any;
    sname: any;
    symbol: any;
    per_wallet: any;
    pda_buf: typeof BN | any;
    uri: any;
    index_cap: any;
    auth_pda: any;
    index_key: any;
    wl_key: any;
    wl_size: any;
    primary_wallet: any;
    sfbp: any;
    secondary_wl_index: any;
    creator_1: any;
    creator_1_cut: any;
    ctimeout: any;
    config_seed: typeof BN | any;
    creator_2: any | null;
    creator_3: any | null;
    creator_4: any | null;
    creator_2_cut: any | null;
    creator_3_cut: any | null;
    creator_4_cut: any | null;
    token_mint_account: any | null;
    token_recip_account: any | null;
    token_decimals: any | null;
    token_price: any | null;
    token_option: any | null;
    collection_key: any;
    collection_name: any;
    our_wallet: any;
    given_dao: any;
    token_mints: any;
    constructor(properties: any) {
        this.presaleTime = 0;
        this.publicTime = 0;
        this.presalePrice = 0;
        this.price = 0;
        this.our_cut = 0;
        this.sname = 0;
        this.symbol = 0;
        this.per_wallet = 0;
        this.pda_buf = 0;
        this.uri = 0;
        this.index_cap = 0;
        this.auth_pda = 0;
        this.index_key = 0;
        this.wl_key = 0;
        this.wl_size = 0;
        this.ctimeout = 0;
        this.primary_wallet = 0;
        this.sfbp = 0;
        this.secondary_wl_index = 0;
        this.collection_key = 0;
        this.creator_1 = 0;
        this.creator_1_cut = 0;
        this.collection_name = 0;
        this.config_seed = 0;
        this.creator_2 = 0;
        this.creator_3 = 0;
        this.creator_4 = 0;
        this.creator_2_cut = 0;
        this.creator_3_cut = 0;
        this.creator_4_cut = 0;
        this.token_mint_account = 0;
        this.token_recip_account = 0;
        this.token_decimals = 0;
        this.token_price = 0;
        this.token_option = 0;
        this.our_wallet = 0;
        this.given_dao = 0;
        this.token_mints = 0;
        this.presaleTime = properties.presaleTime;
        this.publicTime = properties.publicTime;
        this.presalePrice = properties.presalePrice;
        this.price = properties.price;
        this.our_cut = properties.our_cut;
        this.sname = properties.sname;
        this.symbol = properties.symbol;
        this.per_wallet = properties.per_wallet;
        this.pda_buf = new BN(properties.pda_buf, 10).or(properties.dutch ? new BN(1, 10).shln(56) : new BN(0, 10));
        this.uri = properties.uri;
        this.index_cap = properties.index_cap;
        this.auth_pda = properties.auth_pda;
        this.index_key = properties.index_key;
        this.wl_key = properties.wl_key;
        this.wl_size = properties.wl_size;
        this.primary_wallet = properties.primary_wallet;
        this.sfbp = properties.sfbp;
        this.secondary_wl_index = properties.secondary_wl_index;
        this.collection_key = properties.collection_key;
        this.creator_1 = properties.creator_1;
        this.creator_1_cut = properties.creator_1_cut;
        this.collection_name = properties.collection_name;
        this.ctimeout = properties.ctimeout;
        this.config_seed = new BN(properties.config_seed, 10).or(properties.dutch ? new BN(1, 10).shln(56) : new BN(0, 10));
        this.creator_2 = (null === properties || void 0 === properties ? void 0 : properties.creator_2) || null;
        this.creator_3 = (null === properties || void 0 === properties ? void 0 : properties.creator_3) || null;
        this.creator_4 = (null === properties || void 0 === properties ? void 0 : properties.creator_4) || null;
        this.creator_2_cut = (null === properties || void 0 === properties ? void 0 : properties.creator_2_cut) || null;
        this.creator_3_cut = (null === properties || void 0 === properties ? void 0 : properties.creator_3_cut) || null;
        this.creator_4_cut = (null === properties || void 0 === properties ? void 0 : properties.creator_4_cut) || null;
        this.token_mint_account = (null === properties || void 0 === properties ? void 0 : properties.token_mint_account) || null;
        this.token_recip_account = (null === properties || void 0 === properties ? void 0 : properties.token_recip_account) || null;
        this.token_decimals = (null === properties || void 0 === properties ? void 0 : properties.token_decimals) || null;
        this.token_price = (null === properties || void 0 === properties ? void 0 : properties.token_price) || null;
        this.token_option = (null === properties || void 0 === properties ? void 0 : properties.token_option) || null;
        this.our_wallet = (null === properties || void 0 === properties ? void 0 : properties.our_wallet) || null;
        this.given_dao = (null === properties || void 0 === properties ? void 0 : properties.given_dao) || null;
        this.token_mints = (null === properties || void 0 === properties ? void 0 : properties.token_mints) || null;
    }
}

export const ConfigAccountSchema = new Map([
    [
        ConfigAccount,
        {
            kind: 'struct',
            fields: [["presaleTime", "u32"], ["publicTime", "u32"], ["presalePrice", "u64"], ["price", "u64"], ["our_cut", "string"], ["sname", "string"], ["symbol", "string"], ["per_wallet", "u8"], ["pda_buf", "u64"], ["uri", "string"], ["index_cap", "u16"], ["auth_pda", "pubkeyAsString"], ["index_key", "pubkeyAsString"], ["wl_key", "pubkeyAsString"], ["wl_size", "u16"], ["ctimeout", "u16"], ["config_seed", "u64"], ["primary_wallet", "pubkeyAsString"], ["sfbp", "u16"], ["secondary_wl_index", "u16"], ["collection_key", "pubkeyAsString"], ["creator_1", "pubkeyAsString"], ["creator_1_cut", "u8"], ["collection_name", "string"], ["creator_2", {
                kind: "option",
                type: "pubkeyAsString"
            }], ["creator_2_cut", {
                kind: "option",
                type: "u8"
            }], ["creator_3", {
                kind: "option",
                type: "pubkeyAsString"
            }], ["creator_3_cut", {
                kind: "option",
                type: "u8"
            }], ["creator_4", {
                kind: "option",
                type: "pubkeyAsString"
            }], ["creator_4_cut", {
                kind: "option",
                type: "u8"
            }], ["token_mint_account", {
                kind: "option",
                type: "pubkeyAsString"
            }], ["token_recip_account", {
                kind: "option",
                type: "pubkeyAsString"
            }], ["token_decimals", {
                kind: "option",
                type: "u8"
            }], ["token_price", {
                kind: "option",
                type: "u64"
            }], ["token_option", {
                kind: "option",
                type: "u8"
            }], ["our_wallet", {
                kind: "option",
                type: "string"
            }], ["given_dao", {
                kind: "option",
                type: "string"
            }], ["token_mints", {
                kind: "option",
                type: "u16"
            }]]
        },
    ],
]);
'''
'''--- src/pages/Ethereum/Main.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Ethereum as Base } from "../../classes/pages/Ethereum/Ethereum";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";
import Utils from "./Utils";

const version: string = Package.version;

export default class Ethereum extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Tasks`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Create tasks',
                    'Run all tasks',
                    'Cancel Tasks',
                    'Utils',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Utils':
                await new Utils().index();

                break;
            case 'Run all tasks':
                await this.startTasks();

                break;
            case 'Cancel Tasks':
                await this.startCancelTasks();

                break;
            case 'Create tasks':
                await this.createTasks();

                return this.index();
            case 'Back':
                return new Home().index();
        };
    }
};
'''
'''--- src/pages/Ethereum/Utils.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Utils as Base } from "../../classes/pages/Ethereum/Utils";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";

const version: string = Package.version;

export default class Utils extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Utils`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Check tasks wallet funds',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Check tasks wallet funds':
                await this.checkFunds();

                break;
            case 'Back':
                return new Home().index();
        };

        return this.index();
    }
};
'''
'''--- src/pages/Home.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { log, title } from "../utils/logger";
import Package from '../../package.json';
import Settings from "./Settings";
import Solana from "./Solana/Main";
import Ethereum from "./Ethereum/Main";
import { returnConfig } from "../utils/misc";
import { sleep } from "../utils/TLS/GotMain";
import NEAR from "./NEAR/Main";

const version: string = Package.version;

export default class Home {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Home`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'Where would you like to go?'.magenta,
                choices: [
                    'Ethereum',
                    'NEAR',
                    'Solana',
                    'Settings'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    private handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Ethereum':
                const config = JSON.parse(returnConfig());

                if (config.alchemyKey == "" || config.etherscanKey == "") {
                    log('error', 'Please set your Ethereum RPC and Etherscan key in settings!');

                    await sleep(2500);

                    return this.index();
                } else {
                    new Ethereum().index();

                    break;
                }
            case 'NEAR':
                new NEAR().index();

                break;
            case 'Solana':
                new Solana().index();

                break;
            case 'Settings':
                new Settings().index();

                break;
        }
    }
};
'''
'''--- src/pages/NEAR/Main.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { NEAR as Base } from "../../classes/pages/NEAR/NEAR";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";
import Utils from "./Utils";

const version: string = Package.version;

export default class NEAR extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Tasks`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Create tasks',
                    'Run all tasks',
                    'Utils',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Utils':
                await new Utils().index();

                break;
            case 'Run all tasks':
                await this.startTasks();

                break;
            case 'Create tasks':
                await this.createTasks();

                return this.index();
            case 'Back':
                return new Home().index();
        };
    }
};
'''
'''--- src/pages/NEAR/Utils.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Utils as Base } from "../../classes/pages/NEAR/Utils";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";

const version: string = Package.version;

export default class Utils extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Utils`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Check tasks wallet funds',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Check tasks wallet funds':
                await this.checkFunds();

                break;
            case 'Back':
                return new Home().index();
        };

        return this.index();
    }
};
'''
'''--- src/pages/Settings.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Settings as Base } from "../classes/pages/Settings";
import { log, title } from "../utils/logger";
import Package from '../../package.json';
import Home from "./Home";

const version: string = Package.version;

export default class Settings extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Settings`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Configure capmonster',
                    'Set default solana RPC',
                    'Set ETH RPC & Etherscan',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Configure capmonster':
                await this.setSetting('Configuring capmonster', 'capmonsterKey', 'Enter capmonster API key', 'Configure capmonster - Successfully added client key!');

                break;
            case 'Set default solana RPC':
                await this.setSetting('Setting default solana RPC', 'rpc', 'Enter default solana RPC', 'Set default solana RPC - Successfully set default solana RPC!');

                break;
            case 'Set ETH RPC & Etherscan':
                await this.setSetting('Setting ETH RPC', 'alchemyKey', 'Enter ETH RPC url', 'Set ETH RPC - Successfully set ETH RPC!');
                await this.setSetting('Setting Etherscan API key', 'etherscanKey', 'Enter Etherscan API key', 'Set Etherscan API key - Successfully added API key!');

                break;
            case 'Back':
                return new Home().index();
        };

        return this.index();
    }
};
'''
'''--- src/pages/Solana/Main.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Solana as Base } from "../../classes/pages/Solana/Solana";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";
import Utils from "./Utils";
import Monitors from "./Monitors";

const version: string = Package.version;

export default class Solana extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Tasks`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Create tasks',
                    'Monitors',
                    'Run all tasks',
                    'Utils',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Run all tasks':
                await this.startTasks();

                break;
            case 'Create tasks':
                await this.createTasks();

                return this.index();
            case 'Monitors':
                new Monitors().index();

                break;
            case 'Utils':
                new Utils().index();

                break;
            case 'Back':
                return new Home().index();
        };
    }
};
'''
'''--- src/pages/Solana/Monitors.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Monitors as Base } from "../../classes/pages/Solana/Monitors";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";

const version: string = Package.version;

export default class Monitors extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Monitors`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Monitor Candy Machine',
                    'Monitor Launchpad',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Monitor Candy Machine':
                await this.beginMonitor('cm');
            case 'Monitor Launchpad':
                await this.beginMonitor('me');
            case 'Back':
                return new Home().index();
        };
    }
};
'''
'''--- src/pages/Solana/Utils.ts ---
import inquirer from "inquirer";
import 'colorts/lib/string';
import { Utils as Base } from "../../classes/pages/Solana/Utils";
import { log, title } from "../../utils/logger";
import Package from '../../../package.json';
import Home from "../Home";

const version: string = Package.version;

export default class Utils extends Base {
    public index = async (): Promise<void> => {
        console.clear();

        title(`Incognito CLI - Version ${version} - Utils`);

        log('title');

        const prompt: { choice: string } = await inquirer.prompt([
            {
                name: 'choice',
                type: 'list',
                message: 'What would you like to do?'.magenta,
                choices: [
                    'Solve civic on tasks wallets',
                    'Send all NFTs to wallet',
                    'Display all tokens in tasks wallets',
                    'Create wallets',
                    'Check tasks wallet funds',
                    'Check tasks format',
                    'Test RPC',
                    'Back'
                ]
            }
        ]);

        this.handleOption(prompt.choice);
    };

    public handleOption = async (option: string): Promise<void> => {
        switch (option) {
            case 'Send all NFTs to wallet':
                await this.transferAllNfts();

                return this.index();
            case 'Display all tokens in tasks wallets':
                await this.displayAllTokensInWallet();

                return this.index();
            case 'Create wallets':
                await this.createWallets();

                return this.index();
            case 'Check tasks wallet funds':
                await this.checkFunds();

                return this.index();
            case 'Check tasks format':
                await this.checkFormat();

                return this.index();
            case 'Solve civic on tasks wallets':
                await this.solveCivic();

                break;
            case 'Test RPC':
                await this.rpcTester();

                return this.index();
            case 'Back':
                return new Home().index();
        };
    };
};
'''
'''--- src/utils/Authentication/Decipher.ts ---
import crypto from 'crypto';

export const Decrypt = (text: any) => {
    const ENCRYPTION_KEY = "5v8x/A?D(G+KbPeShVmYq3t6w9z$B&E)";
    let parts = text.split(':');
    let iv = Buffer.from(parts.shift(), 'hex');
    let encrypted = Buffer.from(parts.join(':'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY), iv);
    let decrypted = decipher.update(encrypted);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
}

export const DecodeCipher = (s: any, n: any) => {
	let alphabet = 'abcdefghijklmnopqrstuvwxyz'
	let lc = alphabet.replace(/\s/g, '').toLowerCase().split('')
	let uc = alphabet.replace(/\s/g, '').toUpperCase().split('')

	return Array.from(s).map((v: any) => {
		if (lc.indexOf(v.toLowerCase()) === -1 || uc.indexOf(v.toUpperCase()) === -1) { return v }

		let lcEncryptIndex = (lc.indexOf(v.toLowerCase()) - n) % alphabet.length
		lcEncryptIndex = lcEncryptIndex < 0 ? lcEncryptIndex + alphabet.length : lcEncryptIndex
		const lcEncryptedChar = lc[lcEncryptIndex]

		let ucEncryptIndex = (uc.indexOf(v.toUpperCase()) - n) % alphabet.length
		ucEncryptIndex = ucEncryptIndex < 0 ? ucEncryptIndex + alphabet.length : ucEncryptIndex
		const ucEncryptedChar = uc[ucEncryptIndex]

		return lc.indexOf(v) !== -1 ? lcEncryptedChar : ucEncryptedChar
	}).join('')
}
'''
'''--- src/utils/Authentication/Login.ts ---
import inquirer from "inquirer";
import { log } from '../logger';
import 'colorts/lib/string';
import { sleep, getIP } from '../misc';
import fs from 'fs';
import got from 'got';
import { Decrypt, DecodeCipher } from './Decipher';
import { PATHS } from "../../constants/paths";

export const Authenticate = async (): Promise<string> => {
    let config: any = fs.readFileSync(PATHS.config, 'utf-8');
    let update = JSON.parse(config);
    let status;

    let publicIP;
    try {
        publicIP = await getIP();
    } catch (err: unknown) {
        return "bad";
    }
    
    if (update["key"] == "") {
        const key: { input: string } = await inquirer.prompt([
            {
                name: 'input',
                type: 'input',
                message: 'Input your key: '.magenta
            }
        ]);

        update["key"] = key.input;

        fs.writeFileSync(PATHS.config, JSON.stringify(update, null, 4), 'utf-8');    
        
        const date = new Date();

        status = checkKey(JSON.parse(publicIP).ip, key.input, date);
    } else {
        const date = new Date();

        status = checkKey(JSON.parse(publicIP).ip, update["key"], date);
    }

    return status;
};

async function checkKey(publicip: any, key: string, date: any) {
    try {
        // Removed for privacy
        const response = await got("http://:7777/auth", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                "ip": publicip,
                "key": Buffer.from(key).toString("base64"),
                "time": date.getTime(),
            })
        });

        if (JSON.parse(response.body)['version'] != 'v1.5.16') {
            log('error', `Version not up to date, please update to ${JSON.parse(response.body).version}!`);
            await sleep(2500);
            return "bad"
        } else if (DecodeCipher(Buffer.from(DecodeCipher(Decrypt(JSON.parse(response.body).l), date.getTime() % 10), "base64").toString("ascii").substring(0, 24), date.getTime() % 10) == key && JSON.parse(response.body).version == "v1.5.16") {
            return `good${JSON.parse(response.body).u}`
        }

        throw "Error checking key"
    } catch (err) {
        log('error', `Error checking key!`);
        await sleep(2500);
        return "bad"
    }
}
'''
'''--- src/utils/TLS/GotMain.ts ---
import { spawn, exec, ChildProcessWithoutNullStreams } from "child_process";
import type { ResponseData } from "../../constants/TLSInterface";
import { join } from "path";
import PubSub from "pubsub-js";
import getPort from "get-port";
const W3CWebSocket = require("websocket").w3cwebsocket;
import 'colorts/lib/string';

let child: ChildProcessWithoutNullStreams;

const cleanExit = async (message?: string | Error) => {
    if (!child) return;
    if (message) {
        console.log(message);
    }
    if (process.platform == "win32") {
        new Promise((resolve, reject) => {
            exec(
                "taskkill /pid " + child.pid + " /T /F",
                (error: any, stdout: any, stderr: any) => {
                if (error) {
                    console.warn(error);
                }
                process.exit();
                resolve(stdout ? stdout : stderr);
                }
            );
        });
    } else {
        new Promise((resolve, reject) => {
            if (child.pid) {
                process.kill(-child.pid);
                process.exit();
            }
        });
    }
};

process.on("SIGINT", () => cleanExit());

process.on("SIGTERM", () => cleanExit());

export let BACKEND: any
let PORT: number
export let CONNECTED = false

const connectToServer = async () => {
    try {
        await sleep(500)

        BACKEND = new W3CWebSocket(`ws://localhost:${PORT}/client`)

        BACKEND.onopen = function () {
            CONNECTED = true
        }

        BACKEND.onmessage = function (e: any) {
            if (typeof e.data === "string") {
                let responseData: ResponseData = JSON.parse(e.data);
                PubSub.publish(responseData.id, responseData);
            }
        }

        BACKEND.onclose = function () {
            console.log('Error using helper [1]'.red)
            CONNECTED = false
            connectToServer()
        }

        BACKEND.onerror = function () {
            console.log('Error using helper [2]'.red)
            CONNECTED = false
            connectToServer()
        }
    } catch (e) {}
}

export const startServer = async () => {
    try {
        PORT = await getPort()

        let executableFilename = "";
        if (process.platform == "win32") {
            executableFilename = "helper.exe";
        } else if (process.platform == "linux") {
            executableFilename = "helper-linux";
        } else if (process.platform == "darwin") {
            executableFilename = "helper";
        } else {
            throw new Error("Operating system not supported");
        }

        child = spawn(join(`"${process.cwd()}"`, `./${executableFilename}`), {
            env: { PROXY_PORT: PORT.toString() },
            shell: true,
            windowsHide: true,
            detached: process.platform !== "win32",
        });

        await connectToServer()
    } catch (e) {
        console.log("Error (HELPER NOT FOUND) ask for help in incognito.".red);
        await sleep(2500);
        process.exit(3);
    }
}

const dir = "/";

export function getBaseUrl(url: string, prefix?: string) {
    const urlAsArray = url.split(dir);
    const doubleSlashIndex = url.indexOf("://");
    if (doubleSlashIndex !== -1 && doubleSlashIndex === url.indexOf(dir) - 1) {
        urlAsArray.length = 3;
        let url = urlAsArray.join(dir);
        if (prefix !== undefined) url = url.replace(/http:\/\/|https:\/\//, prefix);
        return url;
    } else {
        let pointIndex = url.indexOf(".");
        if (pointIndex !== -1 && pointIndex !== 0) {
            return (prefix !== undefined ? prefix : "https://") + urlAsArray[0];
        }
    }
    return "";
}

export function sleep(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
'''
'''--- src/utils/TLS/GotTLS.ts ---
import { sleep, getBaseUrl, startServer, CONNECTED, BACKEND } from "./GotMain";
import type {
    RequestOptions,
    ResponseData,
    RequestData,
    PromiseCookieJar,
} from "../../constants/TLSInterface";
import { EventEmitter } from "events";
import { FormDataEncoder, isFormDataLike } from "form-data-encoder";
import { v4 as uuidv4 } from "uuid";
import PubSub from "pubsub-js";
import { URLSearchParams } from "url";

export const Server = {
    connect: startServer,
};

const validMethods = [
    "GET",
    "POST",
    "PUT",
    "PATCH",
    "HEAD",
    "DELETE",
    "OPTIONS",
    "TRACE",
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete",
    "options",
    "trace",
];

export const got = async (
    method: string,
    url: string,
    options: RequestOptions,
    responseEmitter: EventEmitter | null = null,
    redirects: number = 0
) => {
    method = method.toUpperCase();

    let init = false;

    if (!responseEmitter) {
        init = true;
        responseEmitter = new EventEmitter();
    }

    let timeWaited = 0;

    while (!CONNECTED) {
        (await sleep(100)) && (timeWaited += 100);
        if (timeWaited > 10000) {
            responseEmitter.emit("error", `Proxy Client Took Too Long To Connect!`);
        }
    }

    if (!validMethods.includes(method)) {
        responseEmitter.emit("error", `Request Method ${method} Is Not Supported`);
    }

    if (typeof url === "string" && url === "") {
        responseEmitter.emit("error", `Request Url ${url} Is Not Valid`);
    }

    if (!url.includes("https://") && !url.includes("http://")) {
        responseEmitter.emit(
            "error",
            `Request Protocol Not Found! e.g http:// https://`
        );
    }

    let baseUrl = getBaseUrl(url);

    if (options.cookieJar && typeof baseUrl === "string" && baseUrl === "") {
        responseEmitter.emit(
            "error",
            `Cookie Domain Cannot Be Resolved With Url ${url}`
        );
    }

    const id = uuidv4();

    let request: RequestData = {
        id: id,
        method: method,
        url: url,
        headers: options.headers,
        debug: options.debug,
    };

    let hasContentType =
        options.headers["content-type"] || options.headers["Content-Type"];

    if (options.json) {
        if (!hasContentType) {
            options.headers["content-type"] = "application/json";
        }
        request.body = JSON.stringify(options.json);
    } else if (options.body) {
        if (isFormDataLike(options.body)) {
            const encoder = new FormDataEncoder(options.body);
            if (!hasContentType) {
                options.headers["content-type"] = encoder.headers["Content-Type"];
            }
            request.body = encoder.encode().toString();
            } else {
            request.body = options.body
        }
    } else if (options.form) {
        if (!hasContentType) {
        options.headers["content-type"] = "application/x-www-form-urlencoded";
        }
        request.body = new URLSearchParams(
        options.form as Record<string, string>
        ).toString();
    }

    if (options.redirect) {
        request.redirect = options.redirect;
    }

    if (options.timeout) {
        request.timeout = options.timeout;
    }

    if (options.proxy) {
        request.proxy = options.proxy;
    }

    if (options.cookieJar) {
        const cookieString: string = await options.cookieJar.getCookieString(
        baseUrl
        );
        if (cookieString != "") {
        request.headers.cookie = cookieString;
        }
    }

    PubSub.subscribe(id, async (msg: any, data: ResponseData) => {
        if (data.success) {
        if (data.headers) {
            let finalHeaders: { [key: string]: string } = {};

            for (const header in data.headers) {
            if (
                header === "Set-Cookie" &&
                typeof data.headers["Set-Cookie"] === "object" &&
                Array.isArray(data.headers["Set-Cookie"])
            ) {
                if (options.cookieJar) {
                let promises: Array<Promise<unknown>> = data.headers[
                    "Set-Cookie"
                ].map(async (rawCookie: string) =>
                    (options.cookieJar as PromiseCookieJar).setCookie(
                    rawCookie,
                    url!.toString()
                    )
                );
                try {
                    await Promise.all(promises);
                } catch (error: any) {}
                }
                finalHeaders["Set-Cookie"] = data.headers["Set-Cookie"].join(", ");
            } else {
                finalHeaders[header] = data.headers[header][0];
            }
            }
            data.headers = finalHeaders;
        }

        if (
            data.statusCode >= 300 &&
            data.statusCode < 400 &&
            data.headers["Location"]
        ) {
            responseEmitter?.emit("redirect", data.headers["Location"]);
        } else {
            responseEmitter?.emit("end", data);
        }
        } else {
        responseEmitter?.emit("error", data.message);
        }
    });

    BACKEND.send(JSON.stringify(request));

    responseEmitter.on("redirect", async (data) => {
        redirects = redirects + 1;
        if (redirects >= 20) {
            responseEmitter?.emit("error", "Too Many Redirects Error");
        } else {
        options.body = undefined
        options.json = undefined
        options.form = undefined
        got("GET", data, options, responseEmitter, redirects);
        }
    });

    if (init) {
        return new Promise<ResponseData>((resolve, reject) => {
        responseEmitter?.on("end", (data: ResponseData) => {
            PubSub.unsubscribe(data.id);
            resolve(data);
        });
        responseEmitter?.on("error", (err) => {
            reject(new Error(err));
        });
        });
    } else {
        return <ResponseData>{
        id: "",
        method: "",
        statusCode: 0,
        url: "",
        headers: {},
        body: "",
        success: false,
        message: "",
        };
    }
};

got.head = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("head", url, options);
};
got.get = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("get", url, options);
};
got.post = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("post", url, options);
};
got.put = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("put", url, options);
};
got.delete = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("delete", url, options);
};
got.trace = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("trace", url, options);
};
got.options = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("options", url, options);
};
got.connect = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("options", url, options);
};
got.patch = (url: string, options: RequestOptions): Promise<ResponseData> => {
    return got("patch", url, options);
};
'''
'''--- src/utils/logger.ts ---
import isAdmin from 'admin-check';
import { getTime } from './misc';
import chalk from 'chalk';

let admin: boolean;

export const checkAdmin = async (): Promise<void> => {
    await isAdmin.check().then((result: boolean): void => {
        admin = result;
    });
};

export const log = (type: string, message?: string): void => {
    if (type == 'title') {
        console.log(chalk.cyan(
            `
                                                  
                                               
                                          
                                     
                                
                                                            
                                                                          
                                                                                   
                                                                                               
                                                                                                              
            \n`)
        );
    } else if (type == 'loading') {
        console.log(chalk.magenta(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[MESSAGE] - Loading files...\n`));
    } else if (type == 'error') {
        console.log(chalk.red(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[MESSAGE] - ${message}`));
    } else if (type == 'misc') {
        console.log(chalk.cyan(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[MESSAGE] - ${message}`));
    } else if (type == 'welcome') {
        console.log(chalk.green(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[AUTH] - ${message}`));
    } else if (type == 'success') {
        console.log(chalk.green(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[MESSAGE] - ${message}`));
    } else if (type == 'submit') {
        console.log(chalk.magenta(`[${getTime()}] - [INCOGNITO]${admin ? ' - [ADMIN] - ' : ' - '}[MESSAGE] - ${message}`));
    }
};

export const title = (title: string): void => {
    if (process.platform == 'win32') {
        process.title = title;
    } else {
        process.stdout.write('\x1b]2;' + title + '\x1b\x5c');
    };
};
'''
'''--- src/utils/misc.ts ---
import fs from 'fs';
import got from 'got';
import bs58 from 'bs58';
import * as web3 from '@solana/web3.js';
import { PATHS } from '../constants/paths';
import { log } from './logger';
import inquirer from 'inquirer';

export const sleep = (ms: number): Promise<void> => {
    return new Promise((resolve) => setTimeout(resolve, ms));
};

export const getTime = (): string => {
    let x: Date = new Date();
    let ampm: string = (x.getTime() >= 12) ? "PM" : "AM";

    return `${x.toLocaleDateString('pt-PT')} ${x.getHours()}:${x.getMinutes()}:${x.getSeconds()}.${x.getMilliseconds()} ${ampm}`;
};

export const returnConfig = (): string => {
    return fs.readFileSync(PATHS.config, 'utf-8');
};

export const returnPubKey = (uint8array: number[]): string => {
    const publicKey: web3.Keypair = web3.Keypair.fromSecretKey(new Uint8Array(uint8array));

    return publicKey.publicKey.toString();
};

export const getByteArray = (privateKey: string): number[] => {
    const byteArray: any = bs58.decode(privateKey);
    const buffer: unknown = Buffer.from(bs58.decode(privateKey));
    const uint8arr: number[] = Array.prototype.slice.call(buffer, byteArray);

    return uint8arr;
};

export const shortenAddress = (address: string, chars = 4): string => {
    return `${address.slice(0, chars)}...${address.slice(-chars)}`;
};

export const getIP = async (): Promise<string> => {
    try {
        const response = await got('https://api.ipify.org?format=json');

        return response.body;
    } catch (err: unknown) {
        throw "Error"
    }
};

export const getProxies = () => {
    try {
        const data = fs.readFileSync(`${process.cwd()}\\proxies.txt`, "utf-8");
        return data;
    } catch (err) {
        log(`error`, `Error getting proxies: ${err}`);
    }
};

export const createPrompt = async (type: string, message: string, mask: boolean): Promise<string> => {
    let settings;

    if (mask) {
        settings = {
            name: 'input',
            type: type,
            message: message.magenta,
            mask: '*'
        }
    } else {
        settings = {
            name: 'input',
            type: type,
            message: message.magenta,
        }
    }

    const answer: { input: string } = await inquirer.prompt([
        settings
    ]);

    return answer.input;
};
'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Enable incremental compilation */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./",                          /* Specify the folder for .tsbuildinfo incremental compilation files. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es5",                                     /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */
    // "reactNamespace": "",                             /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like `./node_modules/@types`. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    "resolveJsonModule": true,                        /* Enable importing .json files */
    // "noResolve": true,                                /* Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have `@internal` in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like `__extends` in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing `const enum` declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied `any` type.. */
    // "strictNullChecks": true,                         /* When type checking, take into account `null` and `undefined`. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when `this` is given the type `any`. */
    // "useUnknownInCatchVariables": true,               /* Type catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when a local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Include 'undefined' in index signature results */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}

'''