*GitHub Repository "mikenevermindng/Token-factory"*

'''--- factory/Cargo.toml ---
[package]
name = "token-factory"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./out
cp target/wasm32-unknown-unknown/release/*.wasm ./out/factory.wasm
'''
'''--- factory/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise,
};

near_sdk::setup_alloc!();

const FT_WASM_CODE: &[u8] = include_bytes!("../../ft-token/out/ft-token.wasm");

const EXTRA_BYTES: usize = 10000;
const GAS: Gas = 50_000_000_000_000;
type TokenId = String;

pub fn is_valid_token_id(token_id: &TokenId) -> bool {
    for c in token_id.as_bytes() {
        match c {
            b'0'..=b'9' | b'a'..=b'z' => (),
            _ => return false,
        }
    }
    true
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Tokens,
    StorageDeposits,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    pub tokens: UnorderedMap<TokenId, TokenArgs>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub storage_balance_cost: Balance,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgs {
    owner_id: ValidAccountId,
    total_supply: U128,
    metadata: FungibleTokenMetadata,
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new() -> Self {
        let mut storage_deposits = LookupMap::new(StorageKey::StorageDeposits);

        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        storage_deposits.insert(&tmp_account_id, &0);
        let storage_balance_cost =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;
        storage_deposits.remove(&tmp_account_id);

        Self {
            tokens: UnorderedMap::new(StorageKey::Tokens),
            storage_deposits,
            storage_balance_cost,
        }
    }

    fn get_min_attached_balance(&self, args: &TokenArgs) -> u128 {
        ((FT_WASM_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance
            * STORAGE_PRICE_PER_BYTE)
            .into()
    }

    pub fn get_required_deposit(&self, args: TokenArgs, account_id: ValidAccountId) -> U128 {
        let args_deposit = self.get_min_attached_balance(&args);
        if let Some(previous_balance) = self.storage_deposits.get(account_id.as_ref()) {
            args_deposit.saturating_sub(previous_balance).into()
        } else {
            (self.storage_balance_cost + args_deposit).into()
        }
    }

    #[payable]
    pub fn storage_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let deposit = env::attached_deposit();
        if let Some(previous_balance) = self.storage_deposits.get(&account_id) {
            self.storage_deposits
                .insert(&account_id, &(previous_balance + deposit));
        } else {
            assert!(deposit >= self.storage_balance_cost, "Deposit is too low");
            self.storage_deposits
                .insert(&account_id, &(deposit - self.storage_balance_cost));
        }
    }

    pub fn get_number_of_tokens(&self) -> u64 {
        self.tokens.len()
    }

    pub fn get_tokens(&self, from_index: u64, limit: u64) -> Vec<TokenArgs> {
        let tokens = self.tokens.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, tokens.len()))
            .filter_map(|index| tokens.get(index))
            .collect()
    }

    pub fn get_token(&self, token_id: TokenId) -> Option<TokenArgs> {
        self.tokens.get(&token_id)
    }

    #[payable]
    pub fn create_token(&mut self, args: TokenArgs) -> Promise {
        if env::attached_deposit() > 0 {
            self.storage_deposit();
        }
        args.metadata.assert_valid();
        let token_id = args.metadata.symbol.to_ascii_lowercase();
        assert!(is_valid_token_id(&token_id), "Invalid Symbol");
        let token_account_id = format!("{}.{}", token_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(token_account_id.as_bytes()),
            "Token Account ID is invalid"
        );

        let account_id = env::predecessor_account_id();

        let required_balance = self.get_min_attached_balance(&args);
        let user_balance = self.storage_deposits.get(&account_id).unwrap_or(0);
        assert!(
            user_balance >= required_balance,
            "Not enough required balance"
        );
        self.storage_deposits
            .insert(&account_id, &(user_balance - required_balance));

        let initial_storage_usage = env::storage_usage();

        assert!(
            self.tokens.insert(&token_id, &args).is_none(),
            "Token ID is already taken {}", token_account_id
        );

        let storage_balance_used =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;

        Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_WASM_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS)
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;

    use near_sdk::test_utils::{VMContextBuilder, accounts};
    use near_sdk::{testing_env, env, Balance};
    use near_sdk::MockedBlockchain;

    const MINT_STORAGE_COST: u128 = 58700000000000000000000;
    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;
    

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.
        current_account_id(accounts(0))
        .signer_account_id(accounts(0))
        .predecessor_account_id(accounts(0))
        .is_view(is_view);
        builder
    }

    fn get_sample_metadata(name: String ,symbol: String) -> FungibleTokenMetadata {
        FungibleTokenMetadata { 
            spec: "ft-1.0.0".to_string(),
            name: name,
            symbol: symbol,
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 1,
         }
    }

    fn get_token_args(owner_id: ValidAccountId, token_name: String, symbol: String) -> TokenArgs {
        TokenArgs {
            owner_id: owner_id,
            total_supply: TOTAL_SUPPLY.into(),
            metadata: get_sample_metadata(token_name, symbol),
        }
    }

    #[test]
    fn test_init_contract() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = TokenFactory::new();

        testing_env!(
            context.storage_usage(env::storage_usage())
            .is_view(true)
            .attached_deposit(0)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let token_num = contract.get_number_of_tokens();

        assert_eq!(token_num, 0);
    }

    #[test]
    fn test_create_token() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = TokenFactory::new();

        testing_env!(
            context.storage_usage(env::storage_usage())
            .is_view(false)
            .attached_deposit(MINT_STORAGE_COST * 100)
            .predecessor_account_id(accounts(0))
            .build()
        );

        contract.create_token(get_token_args(accounts(0), "ManhnvCoin".to_string(), "MNV".to_string()));

        let token_num = contract.get_number_of_tokens();

        assert_eq!(token_num, 1);

    }

}

'''
'''--- ft-token/Cargo.toml ---
[package]
name = "ft-token"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- ft-token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./out
cp target/wasm32-unknown-unknown/release/*.wasm ./out/ft-token.wasm
'''
'''--- ft-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, BorshStorageKey, near_bindgen, AccountId, PanicOnDefault, PromiseOrValue, Balance, Promise};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Token,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(StorageKey::Token),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    #[payable]
    pub fn mint(&mut self, account_id: ValidAccountId) {
        let amount: Balance = env::attached_deposit();
        self.token.internal_deposit(account_id.as_ref(), amount);
    }

    pub fn withdraw(&mut self, amount: U128) -> Promise {
        let account_id: AccountId = env::predecessor_account_id();
        self.token.internal_withdraw(&account_id, amount.0);
        Promise::new(account_id).transfer(amount.0)
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;

    use near_sdk::test_utils::{VMContextBuilder, accounts};
    use near_sdk::{testing_env, env, Balance};
    use near_sdk::MockedBlockchain;

    const MINT_STORAGE_COST: u128 = 58700000000000000000000;
    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;
    

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.
        current_account_id(accounts(0))
        .signer_account_id(accounts(0))
        .predecessor_account_id(accounts(0))
        .is_view(is_view);
        builder
    }

    fn get_sample_metadata() -> FungibleTokenMetadata {
        FungibleTokenMetadata { 
            spec: "ft-1.0.0".to_string(),
            name: "ManhnvCoin".to_string(),
            symbol: "MNC".to_string(),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 1,
        }
    }

    #[test]
    fn test_init_contract() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let metadata = get_sample_metadata();
        let total_supply =  U128::from(587000000000000000000000000);
        let mut contract = Contract::new(accounts(0), total_supply, metadata);

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let balance = contract.ft_balance_of(accounts(0));
        let total_supply_contract = contract.ft_total_supply();

        assert_eq!(balance.0, total_supply_contract.0);
        assert_eq!(total_supply_contract.0, total_supply.0);
        assert_eq!(balance.0, total_supply.0);
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(false);
        testing_env!(context.build());
        let metadata = get_sample_metadata();
        let total_supply = 1_000_000_000_000_000;
        let mut contract = Contract::new(accounts(0), total_supply.into(), metadata);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(0))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        let transfer_amount = total_supply / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(0)).0, (total_supply - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }

    #[test]
    fn test_mint() {
        let deposit_amount = 100000;
        let mut context = get_context(false);
        testing_env!(context.build());
        let metadata = get_sample_metadata();
        let total_supply = 1_000_000_000_000_000;
        let mut contract = Contract::new(accounts(0), total_supply.into(), metadata);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        // testing_env!(context
        //     .storage_usage(env::storage_usage())
        //     .attached_deposit(deposit_amount)
        //     .predecessor_account_id(accounts(1))
        //     .build());
        // contract.mint(accounts(1));

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(false)
            .predecessor_account_id(accounts(2))
            .attached_deposit(deposit_amount)
            .build());
        contract.mint(accounts(1));

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .predecessor_account_id(accounts(1))
            .build());

        assert_eq!(contract.ft_balance_of(accounts(1)).0, deposit_amount * 2);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(false)
            .predecessor_account_id(accounts(1))
            .build());
        let balance_before = accounts(1);
        contract.withdraw(deposit_amount.into());
        assert_eq!(contract.ft_balance_of(accounts(1)).0, deposit_amount);
    }
}
'''