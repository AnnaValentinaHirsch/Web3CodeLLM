*GitHub Repository "maxhr/near--near-sdk-js"*

'''--- .github/workflows/standalone-examples.yml ---
name: Standalone examples
on: push
jobs:
  examples:
    strategy:
      matrix:
        platform: [ubuntu-latest] # macos-latest
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install dependencies
        run: yarn && cd examples && yarn
      - name: clean-state
        run: cd examples && yarn build:clean-state && yarn test:clean-state
      - name: counter
        run: cd examples && yarn build:counter && yarn test:counter
      - name: counter-lowlevel
        run: cd examples && yarn build:counter-lowlevel && yarn test:counter-lowlevel
      - name: counter-ts
        run: cd examples && yarn build:counter-ts && yarn test:counter-ts
      - name: cross-contract-call
        run: cd examples && yarn build:cross-contract-call && yarn test:cross-contract-call
      - name: fungible-token-lockable
        run: cd examples && yarn build:fungible-token-lockable && yarn test:fungible-token-lockable
      - name: fungible-token
        run: cd examples && yarn build:fungible-token && yarn test:fungible-token
      - name: non-fungible-token
        run: cd examples && yarn build:non-fungible-token && yarn test:non-fungible-token
      - name: status-message-collections
        run: cd examples && yarn build:status-message-collections && yarn test:status-message-collections
      - name: status-message
        run: cd examples && yarn build:status-message && yarn test:status-message
      - name: parking-lot
        run: cd examples && yarn build:parking-lot && yarn test:parking-lot
'''
'''--- .github/workflows/standalone-unit-test.yml ---
name: Standalone unit
on: push
jobs:
  unit-tests:
    strategy:
      matrix:
        platform: [ubuntu-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Run standalone unit tests
        run: yarn test:standalone:unit

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at social@nearprotocol.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- CONTRIBUTING.md ---
# Contributing to NEAR

NEAR welcomes help in many forms including development, code review, documentation improvements, and outreach.
Please visit [the contribution overview](https://docs.nearprotocol.com/docs/contribution/contribution-overview) for more information.

## Using Github issues and pull requests

Some repositories have specific issue templates that will be helpful for maintainers and community contributors. Please use the templates whenever available.

Please include steps to reproduction, if reporting an error. Information on all applicable versions is quite helpful. Some versions can be found using the command line. (For example: `node --version` or `rustc --version`.) Other version information may be packaged as dependencies. (For example: in `package.json` or `Cargo.toml`.)

If there are verbosity flags available, please include those to offer as much information as possible.

When opening a pull request, please use the typical open-source flow of forking the desired repository and opening a pull request from your forked repository. (More information on [technical contributions here](https://docs.nearprotocol.com/docs/contribution/technical-contribution).)

## Testing

Please note that for technical contributions, NEAR runs a battery of continuous integration tools and tests for each pull request.

It's encouraged to write unit tests on new features. Many NEAR repositories have built-in scripts that run tests locally. Tests may check linting and must be addressed.

For this repository, please follow testing directions outlined in the `README.md` file.

### Thank you

NEAR values all contributors to the projects in the ecosystem and invites public discussion on the tech and vision. Please feel free to join the conversation using the links offered at [near.help](https://near.help).

'''
'''--- README.md ---
# NEAR-SDK-JS (Standalone)

## Installation
It is tested on Ubuntu 20.04, M1 Mac and Intel Mac. Other linux should also work but they're not tested.

1. Make sure you have make, cmake and nodejs. On Linux, also make sure you have gcc.
2. `make setup`

## Usage

1. Copy project layout including configurations from `examples/` as a starting point
2. Write smart contracts with JavaScript. You can use most npm packages that uses portable ES2020 features. 
3. Build the contract with `yarn build`.
4. If no errors happens, a `<contract-name>.wasm` will be generate at `<project-dir>/build/`. It can be tested with workspaces-js and deployed to a NEAR node.

## Running Examples
There are a couple of contract examples in the project:

- [Clean contract state](https://github.com/near/near-sdk-js/tree/develop/examples/src/clean-state.js)
- [Counter using low level API](https://github.com/near/near-sdk-js/tree/develop/examples/src/counter-lowlevel.js)
- [Counter in JavaScript](https://github.com/near/near-sdk-js/tree/develop/examples/src/counter.js)
- [Counter in TypeScript](https://github.com/near/near-sdk-js/tree/develop/examples/src/counter.ts)
- [Doing cross contract call](https://github.com/near/near-sdk-js/tree/develop/examples/src/cross-contract-call.js)
- [Fungible token](https://github.com/near/near-sdk-js/tree/develop/examples/src/fungible-token.js)
- [Lockable fungible token](https://github.com/near/near-sdk-js/tree/develop/examples/src/fungible-token-lockable.js)
- [Non fungible token](https://github.com/near/near-sdk-js/tree/develop/examples/src/non-fungible-token.js)
- [Non fungible token receiver contract](https://github.com/near/near-sdk-js/tree/develop/examples/src/non-fungible-token-receiver.js)
- [Status message board](https://github.com/near/near-sdk-js/tree/develop/examples/src/status-message.js)
- [Status message board with unique messages](https://github.com/near/near-sdk-js/tree/develop/examples/src/status-message-collections.js)

To build all examples, run `yarn build` in `examples/`. To test all examples, run `yarn test`. You can also build and test one specific example with `yarn build:<example-name>` and `yarn test:<example-name>`, see `examples/package.json`.

To deploy and call a contract on a NEAR node, use near-cli's `near deploy` and `near call`.

## Error Handling in NEAR-SDK-JS

If you want to indicate an error happened and fail the transaction, just throw an error object in JavaScript. The compiled JavaScript contract includes error handling capability. It will catch throwed errors and automatically invoke `panic_utf8` with `"{error.message}\n:{error.stack}"`. As a result, transaction will fail with `"Smart contract panicked: {error.message}\n{error.stack}"` error message. You can also use an error utilities library to organize your errors, such as verror.

When your JS code or library throws an error, uncaught, the transaction will also fail with GuestPanic error, with the error message and stacktrace.

When call host function with inappropriate type, means incorrect number of arguments or arg is not expected type:
    - if arguments less than params, remaining argument are set as 'undefined'
    - if arguments more than params, remaining argument are ignored
    - if argument is different than the required type, it'll be coerced to required type
    - if argument is different than the required type but cannot be coerced, will throw runtime type error, also with message and stacktrace

## Test
We recommend to use near-workspaces to write tests for your smart contracts. See any of the examples for how tests are setup and written.

## NEAR-SDK-JS API Reference

All NEAR blockchain provided functionality (host functions) are defined in `src/api.ts` and exported as `near`. You can use them by:
```js
import {near} from 'near-sdk-js'

// near.<api doucmented below>. e.g.:
let signer = near.signerAccountId()
```

To use nightly host functions, such as `altBn128G1Sum`, your contract need to be built with nightly enabled. Use:
```
export NEAR_NIGHTLY=1
yarn build
```

### About Type

NEAR-SDK-JS is written in TypeScript, so every API function has a type specified by signature that looks familiar to JavaScript/TypeScript Developers. Two types in the signature need a special attention:
- Most of the API take `BigInt` instead of Number as type. This because JavaScript Number cannot hold 64 bit and 128 bit integer without losing precision.
- `Bytes` in both arguments and return represent a byte buffer, internally it's a JavaScript String Object. Any binary data `0x00-0xff` is stored as the char '\x00-\xff'. This is because QuickJS doesn't have ArrayBuffer in C API.
    - To ensure correctness, every `Bytes` argument need to be pass in with the `bytes()` function to runtime type check it's indeed a `Bytes`.
    - If `Bytes` is too long that `bytes()` can cause gas limit problem, such as in factory contract, represents the content of contract to be deployed. In this case you can precheck and guarantee the correctness of the content and use without `bytes()`.

### Context API

```
function currentAccountId(): String;
function signerAccountId(): String;
function signerAccountPk(): Bytes;
function predecessorAccountId(): String;
function input(): Bytes;
function blockIndex(): BigInt;
function blockHeight(): BigInt;
function blockTimestamp(): BigInt;
function epochHeight(): BigInt;
function storageUsage(): BigInt
```

### Economics API
```
function accountBalance(): BigInt;
function accountLockedBalance(): BigInt;
function attachedDeposit(): BigInt;
function prepaidGas(): BigInt;
function usedGas(): BigInt;
```

### Math API

```
function randomSeed(): Bytes;
function sha256(value: Bytes): Bytes;
function keccak256(value: Bytes): Bytes;
function keccak512(value: Bytes): Bytes;
function ripemd160(value: Bytes): Bytes;
function ecrecover(hash: Bytes, sign: Bytes, v: BigInt, malleability_flag: BigInt): Bytes | null;
```

### Miscellaneous API

```
function valueReturn(value: Bytes);
function panic(msg?: String);
function panicUtf8(msg: Bytes);
function log(msg: String);
function logUtf8(msg: Bytes);
function logUtf16(msg: Bytes);
```

### Promises API

```
function promiseCreate(account_id: String, method_name: String, arguments: Bytes, amount: BigInt, gas: BigInt): BigInt;
function promiseThen(promise_index: BigInt, account_id: String, method_name: String, arguments: Bytes, amount: BigInt, gas: BigInt): BigInt;
function promiseAnd(...promise_idx: BigInt): BigInt;
function promiseBatchCreate(account_id: String): BigInt;
function promiseBatchThen(promise_index: BigInt, account_id: String): BigInt;
```

### Promise API actions

```
function promiseBatchActionCreateAccount(promise_index: BigInt);
function promiseBatchActionDeployContract(promise_index: BigInt, code: Bytes);
function promiseBatchActionFunctionCall(promise_index: BigInt, method_name: String, arguments: Bytes, amount: BigInt, gas: BigInt);
function promiseBatchActionTransfer(promise_index: BigInt, amount: BigInt);
function promiseBatchActionStake(promise_index: BigInt, amount: BigInt, public_key: Bytes);
function promiseBatchActionAddKeyWithFullAccess(promise_index: BigInt, public_key: Bytes, nonce: BigInt);
function promiseBatchActionAddKeyWithFunctionCall(promise_index: BigInt, public_key: Bytes, nonce: BigInt, allowance: BigInt, receiver_id: String, method_names: String);
function promiseBatchActionDeleteKey(promise_index: BigInt, public_key: Bytes);
function promiseBatchActionDeleteAccount(promise_index: BigInt, beneficiary_id: String);
```

### Promise API results

```
function promiseResultsCount(): BigInt;
function promiseResult(result_idx: BigInt, register_id: BigInt): BigInt;
function promiseReturn(promise_idx: BigInt);
```

### Storage API

```
function storageWrite(key: Bytes, value: Bytes, register_id: BigInt): BigInt;
function storageRead(key: Bytes, register_id: BigInt): BigInt;
function storageRemove(key: Bytes, register_id: BigInt): BigInt;
function storageHasKey(key: Bytes): BigInt;
```

### Validator API

```
function validatorStake(account_id: String): BigInt;
function validatorTotalStake(): BigInt;
```

### Alt BN128

```
function altBn128G1Multiexp(value: Bytes, register_id: BigInt);
function altBn128G1Sum(value: Bytes, register_id: BigInt);
function altBn128PairingCheck(value: Bytes): BigInt;
```

### Collections
A few useful on-chain persistent collections are provided. All keys, values and elements are of type `Bytes`.

#### Vector
Vector is an iterable implementation of vector that stores its content on the trie. Usage:

```js
import {Vector} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.v = new Vector('my_prefix_')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.v = Object.assign(new Vector, this.v)
}

someMethod() {
    // insert
    this.v.push('abc')
    this.v.push('def')
    this.v.push('ghi')

    // batch insert, extend:
    this.v.extend(['xyz', '123'])

    // get
    let first = this.v.get(0)

    // remove, move the last element to the given index
    this.v.swapRemove(0) 

    // replace
    this.v.replace(1, 'jkl')

    // remove the last
    this.v.pop()

    // len, isEmpty
    let len = this.v.len()
    let isEmpty = this.v.isEnpty()

    // iterate
    for (let element of this.v) {
        near.log(element)
    }

    // toArray, convert to JavaScript Array
    let a = this.v.toArray()

    // clear
    ths.v.clear()
}
```

#### LookupMap
LookupMap is an non-iterable implementation of a map that stores its content directly on the trie. It's like a big hash map, but on trie. Usage:
```js
import {LookupMap} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.m = new LookupMap('prefix_a')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.m = Object.assign(new LookupMap, this.m)
}

someMethod() {
    // insert
    this.m.set('abc', 'aaa')
    this.m.set('def', 'bbb')
    this.m.set('ghi', 'ccc')

    // batch insert, extend:
    this.m.extend([['xyz', '123'], ['key2', 'value2']])

    // check exist
    let exist = this.m.containsKey('abc')

    // get
    let value = this.m.get('abc')

    // remove
    this.m.remove('def') 

    // replace
    this.m.set('ghi', 'ddd')
}
```

#### LookupSet
LookupSet is an non-iterable implementation of a set that stores its content directly on the trie. It's like LookupMap, but it only stores whether the value presents. Usage:
```js
import {LookupSet} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.s = new LookupSet('prefix_b')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.s = Object.assign(new LookupSet, this.s)
}

someMethod() {
    // insert
    this.s.set('abc')
    this.s.set('def')
    this.s.set('ghi')

    // batch insert, extend:
    this.s.extend(['xyz', '123'])

    // check exist
    let exist = this.s.contains('abc')

    // remove
    this.s.remove('def')
}
```

#### UnorderedMap
UnorderedMap is an iterable implementation of a map that stores its content directly on the trie. Usage:
```js
import {UnorderedMap} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.m = new UnorderedMap('prefix_c')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.m.keys = Object.assign(new Vector, this.m.keys)
    this.m.values = Object.assign(new Vector, this.m.values)
    this.m = Object.assign(new UnorderedMap, this.m)
}

someMethod() {
    // insert
    this.m.set('abc', 'aaa')
    this.m.set('def', 'bbb')
    this.m.set('ghi', 'ccc')

    // batch insert, extend:
    this.m.extend([['xyz', '123'], ['key2', 'value2']])

    // get
    let value = this.m.get('abc')

    // remove
    this.m.remove('def') 

    // replace
    this.m.set('ghi', 'ddd')

    // len, isEmpty
    let len = this.m.len()
    let isEmpty = this.m.isEnpty()

    // iterate
    for (let [k, v] of this.m) {
        near.log(k+v)
    }

    // toArray, convert to JavaScript Array
    let a = this.m.toArray()

    // clear
    this.m.clear()
}
```

#### UnorderedSet
UnorderedSet is an iterable implementation of a set that stores its content directly on the trie. It's like UnorderedMap but it only stores whether the value presents. Usage:
```js
import {UnorderedSet} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.s = new UnorderedSet('prefix_d')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.s.elements = Object.assign(new Vector, this.s.elements)
    this.s = Object.assign(new UnorderedSet, this.s)
}

someMethod() {
    // insert
    this.s.set('abc')
    this.s.set('def')
    this.s.set('ghi')

    // batch insert, extend:
    this.s.extend(['xyz', '123'])

    // check exist
    let exist = this.s.contains('abc')

    // remove
    this.s.remove('def')

    // len, isEmpty
    let len = this.s.len()
    let isEmpty = this.s.isEnpty()

    // iterate
    for (let e of this.s) {
        near.log(e)
    }

    // toArray, convert to JavaScript Array
    let a = this.s.toArray()

    // clear
    this.s.clear()
}
```

'''
'''--- cli/builder/builder.c ---
#include <string.h>
#include "../node_modules/near-sdk-js/cli/deps/quickjs/quickjs-libc-min.h"
#include "../node_modules/near-sdk-js/cli/deps/quickjs/libbf.h"
#include "code.h"

static JSContext *JS_NewCustomContext(JSRuntime *rt)
{
  JSContext *ctx = JS_NewContextRaw(rt);
  if (!ctx)
    return NULL;
  JS_AddIntrinsicBaseObjects(ctx);
  JS_AddIntrinsicDate(ctx);
  JS_AddIntrinsicEval(ctx);
  JS_AddIntrinsicStringNormalize(ctx);
  JS_AddIntrinsicRegExp(ctx);
  JS_AddIntrinsicJSON(ctx);
  JS_AddIntrinsicProxy(ctx);
  JS_AddIntrinsicMapSet(ctx);
  JS_AddIntrinsicTypedArrays(ctx);
  JS_AddIntrinsicPromise(ctx);
  JS_AddIntrinsicBigInt(ctx);
  return ctx;
}

#define DEFINE_NEAR_METHOD(name) \
  void name () __attribute__((export_name(#name))) {\
    JSRuntime *rt;\
    JSContext *ctx;\
    JSValue mod_obj, fun_obj, result, error, error_message, error_stack;\
    const char *error_message_c, *error_stack_c;\
    char *error_c;\
    size_t msg_len, stack_len;\
    rt = JS_NewRuntime();\
    ctx = JS_NewCustomContext(rt);\
    js_add_near_host_functions(ctx);\
    mod_obj = js_load_module_binary(ctx, code, code_size);\
    fun_obj = JS_GetProperty(ctx, mod_obj, JS_NewAtom(ctx, #name));\
    result = JS_Call(ctx, fun_obj, mod_obj, 0, NULL);\
    if (JS_IsException(result)) {\
      error = JS_GetException(ctx);\
      error_message = JS_GetPropertyStr(ctx, error, "message");\
      error_stack = JS_GetPropertyStr(ctx, error, "stack");\
      error_message_c = JS_ToCStringLen(ctx, &msg_len, error_message);\
      error_stack_c = JS_ToCStringLen(ctx, &stack_len, error_stack);\
      error_c = malloc(msg_len+1+stack_len);\
      strncpy(error_c, error_message_c, msg_len);\
      error_c[msg_len] = '\n';\
      strncpy(error_c+msg_len+1, error_stack_c, stack_len);\
      panic_utf8(msg_len+1+stack_len, (uint64_t)error_c);\
    }\
    js_std_loop(ctx);\
  }

// #############
// # Registers #
// #############
extern void read_register(uint64_t register_id, uint64_t ptr);
extern uint64_t register_len(uint64_t register_id);
extern void write_register(uint64_t register_id, uint64_t data_len, uint64_t data_ptr);
// ###############
// # Context API #
// ###############
extern void current_account_id(uint64_t register_id);
extern void signer_account_id(uint64_t register_id);
extern void signer_account_pk(uint64_t register_id);
extern void predecessor_account_id(uint64_t register_id);
extern void input(uint64_t register_id);
extern uint64_t block_index();
extern uint64_t block_timestamp();
extern uint64_t epoch_height();
extern uint64_t storage_usage();
// #################
// # Economics API #
// #################
extern void account_balance(uint64_t balance_ptr);
extern void account_locked_balance(uint64_t balance_ptr);
extern void attached_deposit(uint64_t balance_ptr);
extern uint64_t prepaid_gas();
extern uint64_t used_gas();
// ############
// # Math API #
// ############
extern void random_seed(uint64_t register_id);
extern void sha256(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void keccak256(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void keccak512(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void ripemd160(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t ecrecover(uint64_t hash_len, uint64_t hash_ptr, uint64_t sign_len, uint64_t sig_ptr, uint64_t v, uint64_t malleability_flag, uint64_t register_id);
// #####################
// # Miscellaneous API #
// #####################
extern void value_return(uint64_t value_len, uint64_t value_ptr);
extern void panic(void);
extern void panic_utf8(uint64_t len, uint64_t ptr);
extern void log_utf8(uint64_t len, uint64_t ptr);
extern void log_utf16(uint64_t len, uint64_t ptr);
// Name confliction with WASI. Can be re-exported with a different name on NEAR side with a protocol upgrade
// Or, this is actually not a primitive, can be implement with log and panic host functions in C side or JS side. 
// extern void abort(uint32_t msg_ptr, uint32_t filename_ptr, uint32_t u32, uint32_t col);
// ################
// # Promises API #
// ################
extern uint64_t promise_create(uint64_t account_id_len, uint64_t account_id_ptr, uint64_t method_name_len, uint64_t method_name_ptr, uint64_t arguments_len, uint64_t arguments_ptr, uint64_t amount_ptr, uint64_t gas);
extern uint64_t promise_then(uint64_t promise_index, uint64_t account_id_len, uint64_t account_id_ptr, uint64_t method_name_len, uint64_t method_name_ptr, uint64_t arguments_len, uint64_t arguments_ptr, uint64_t amount_ptr, uint64_t gas);
extern uint64_t promise_and(uint64_t promise_idx_ptr, uint64_t promise_idx_count);
extern uint64_t promise_batch_create(uint64_t account_id_len, uint64_t account_id_ptr);
extern uint64_t promise_batch_then(uint64_t promise_index, uint64_t account_id_len, uint64_t account_id_ptr);
// #######################
// # Promise API actions #
// #######################
extern void promise_batch_action_create_account(uint64_t promise_index);
extern void promise_batch_action_deploy_contract(uint64_t promise_index, uint64_t code_len, uint64_t code_ptr);
extern void promise_batch_action_function_call(uint64_t promise_index, uint64_t method_name_len, uint64_t method_name_ptr, uint64_t arguments_len, uint64_t arguments_ptr, uint64_t amount_ptr, uint64_t gas);
extern void promise_batch_action_transfer(uint64_t promise_index, uint64_t amount_ptr);
extern void promise_batch_action_stake(uint64_t promise_index, uint64_t amount_ptr, uint64_t public_key_len, uint64_t public_key_ptr);
extern void promise_batch_action_add_key_with_full_access(uint64_t promise_index, uint64_t public_key_len, uint64_t public_key_ptr, uint64_t nonce);
extern void promise_batch_action_add_key_with_function_call(uint64_t promise_index, uint64_t public_key_len, uint64_t public_key_ptr, uint64_t nonce, uint64_t allowance_ptr, uint64_t receiver_id_len, uint64_t receiver_id_ptr, uint64_t method_names_len, uint64_t method_names_ptr);
extern void promise_batch_action_delete_key(uint64_t promise_index, uint64_t public_key_len, uint64_t public_key_ptr);
extern void promise_batch_action_delete_account(uint64_t promise_index, uint64_t beneficiary_id_len, uint64_t beneficiary_id_ptr);
// #######################
// # Promise API results #
// #######################
extern uint64_t promise_results_count(void);
extern uint64_t promise_result(uint64_t result_idx, uint64_t register_id);
extern void promise_return(uint64_t promise_idx);
// ###############
// # Storage API #
// ###############
extern uint64_t storage_write(uint64_t key_len, uint64_t key_ptr, uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t storage_read(uint64_t key_len, uint64_t key_ptr, uint64_t register_id);
extern uint64_t storage_remove(uint64_t key_len, uint64_t key_ptr, uint64_t register_id);
extern uint64_t storage_has_key(uint64_t key_len, uint64_t key_ptr);
// #################
// # Validator API #
// #################
extern void validator_stake(uint64_t account_id_len, uint64_t account_id_ptr, uint64_t stake_ptr);
extern void validator_total_stake(uint64_t stake_ptr);
// #############
// # Alt BN128 #
// #############
#ifdef NIGHTLY
extern void alt_bn128_g1_multiexp(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void alt_bn128_g1_sum(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t alt_bn128_pairing_check(uint64_t value_len, uint64_t value_ptr);
#endif

static JSValue near_read_register(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  char *data;
  uint64_t data_len;
  JSValue ret;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  data_len = register_len(register_id);
  if (data_len != UINT64_MAX) {
    data = malloc(data_len);
    read_register(register_id, (uint64_t)data);
    ret = JS_NewStringLenRaw(ctx, data, data_len);
    free(data);
    return ret;
  } else {
    return JS_UNDEFINED;
  }
}

static JSValue near_register_len(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id, len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  len = register_len(register_id);
  return JS_NewBigUint64(ctx, len);
}

static JSValue near_write_register(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[1]);

  write_register(register_id, data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_current_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  current_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_signer_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  signer_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_signer_account_pk(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  signer_account_pk(register_id);
  return JS_UNDEFINED;
}

static JSValue near_predecessor_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  predecessor_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_input(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  input(register_id);
  return JS_UNDEFINED;
}

static JSValue near_block_index(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = block_index();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_block_timestamp(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = block_timestamp();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_epoch_height(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = epoch_height();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_storage_usage(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = storage_usage();
  return JS_NewBigUint64(ctx, value);
}

// ptr[0] ptr[1] is little-endian u128.
static JSValue u128_to_quickjs(JSContext *ctx, uint64_t* ptr) {
  JSValue value;
  bf_t* bn;
  bf_t b;

  value = JS_NewBigInt(ctx);
  bn = JS_GetBigInt(value);
  // from ptr[] to bn
  // high 64 bits
  bf_set_ui(bn, ptr[1]);
  bf_mul_2exp(bn, 64, BF_PREC_INF, BF_RNDZ);
  // low 64 bits
  bf_init(bn->ctx, &b);
  bf_set_ui(&b, ptr[0]);
  bf_add(bn, bn, &b, BF_PREC_INF, BF_RNDZ);
  bf_delete(&b);
  
  return value;
}

static int quickjs_bigint_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  bf_t* a;
  bf_t q, r, b, one, u128max;
  a = JS_GetBigInt(val);
  bf_init(a->ctx, &u128max);
  bf_set_ui(&u128max, 1);
  bf_mul_2exp(&u128max, 128, BF_PREC_INF, BF_RNDZ);
  if (bf_cmp_le(&u128max, a)) {
    return 1;
  }
  bf_init(a->ctx, &q);
  bf_init(a->ctx, &r);
  bf_init(a->ctx, &b);
  bf_init(a->ctx, &one);
  bf_set_ui(&b, UINT64_MAX);
  bf_set_ui(&one, 1);
  bf_add(&b, &b, &one, BF_PREC_INF, BF_RNDZ);
  bf_divrem(&q, &r, a, &b, BF_PREC_INF, BF_RNDZ, BF_RNDZ);
  
  bf_get_uint64(ptr, &r);
  bf_get_uint64(ptr+1, &q);
  return 0;
}

static int quickjs_int_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  if (JS_ToUint64Ext(ctx, ptr, val) < 0) {
    return 1;
  }
  ptr[1] = 0;
  return 0;
}

static int quickjs_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  if (JS_IsBigInt(ctx, val))
    return quickjs_bigint_to_u128(ctx, val, ptr);
  else {
    return quickjs_int_to_u128(ctx, val, ptr);
  }
}

static JSValue near_account_balance(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{  
  uint64_t ptr[2];

  account_balance((uint64_t)ptr); 
  return u128_to_quickjs(ctx, ptr);
}

static JSValue near_account_locked_balance(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t ptr[2];

  account_locked_balance((uint64_t)ptr);
  return u128_to_quickjs(ctx, ptr);
}

static JSValue near_attached_deposit(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t ptr[2];

  attached_deposit((uint64_t)ptr);
  return u128_to_quickjs(ctx, ptr);
}

static JSValue near_prepaid_gas(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = prepaid_gas();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_used_gas(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = used_gas();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_random_seed(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  random_seed(register_id);
  return JS_UNDEFINED;
}

static JSValue near_sha256(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  sha256(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_keccak256(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }  
  keccak256(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_keccak512(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  keccak512(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_ripemd160(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  ripemd160(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_ecrecover(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t malleability_flag, v, register_id, result;
  const char *hash_ptr, *sig_ptr;
  size_t hash_len, sign_len;

  hash_ptr = JS_ToCStringLenRaw(ctx, &hash_len, argv[0]);
  sig_ptr = JS_ToCStringLenRaw(ctx, &sign_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &malleability_flag, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for malleability_flag");
  }
  if (JS_ToUint64Ext(ctx, &v, argv[3]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for v");
  }
  if (JS_ToUint64Ext(ctx, &register_id, argv[4]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
 
  result = ecrecover(hash_len, (uint64_t)hash_ptr, sign_len, (uint64_t)sig_ptr, malleability_flag, v, register_id);
  return JS_NewBigUint64(ctx, result);
}

static JSValue near_value_return(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) 
{
  const char *value_ptr;
  size_t value_len;

  value_ptr = JS_ToCStringLenRaw(ctx, &value_len, argv[0]);
  value_return(value_len, (uint64_t)value_ptr);
  return JS_UNDEFINED;
}

static JSValue near_panic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  if (argc == 1) {
    data_ptr = JS_ToCStringLen(ctx, &data_len, argv[0]);
    panic_utf8(data_len, (uint64_t)data_ptr);
  } else {
    panic();
  }
  return JS_UNDEFINED;
}

static JSValue near_panic_utf8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  panic_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLen(ctx, &data_len, argv[0]);
  
  log_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log_utf8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  log_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log_utf16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  log_utf16(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_create(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *account_id_ptr, *method_name_ptr, *arguments_ptr;
  size_t account_id_len, method_name_len, arguments_len;
  uint64_t amount_ptr[2]; // amount is u128
  uint64_t gas, ret;

  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[0]);
  method_name_ptr = JS_ToCStringLen(ctx, &method_name_len, argv[1]);
  arguments_ptr = JS_ToCStringLenRaw(ctx, &arguments_len, argv[2]);
  if (quickjs_to_u128(ctx, argv[3], amount_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for amount");
  }
  if (JS_ToUint64Ext(ctx, &gas, argv[4]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for gas");
  }

  ret = promise_create(account_id_len, (uint64_t)account_id_ptr, method_name_len, (uint64_t)method_name_ptr, arguments_len, (uint64_t)arguments_ptr, (uint64_t)amount_ptr, gas);
  
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_then(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *account_id_ptr, *method_name_ptr, *arguments_ptr;
  size_t account_id_len, method_name_len, arguments_len;
  uint64_t amount_ptr[2]; // amount is u128
  uint64_t gas, ret;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[1]);
  method_name_ptr = JS_ToCStringLen(ctx, &method_name_len, argv[2]);
  arguments_ptr = JS_ToCStringLenRaw(ctx, &arguments_len, argv[3]);
  if (quickjs_to_u128(ctx, argv[4], amount_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for amount");
  }
  if (JS_ToUint64Ext(ctx, &gas, argv[5]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for gas");
  }

  ret = promise_then(promise_index, account_id_len, (uint64_t)account_id_ptr, method_name_len, (uint64_t)method_name_ptr, arguments_len, (uint64_t)arguments_ptr, (uint64_t)amount_ptr, gas);
  
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_and(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_idx_ptr[argc], ret;

  for(int i = 0; i < argc; i++) {
    if (JS_ToUint64Ext(ctx, &promise_idx_ptr[i], argv[i]) < 0) {
      return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_id");
    }
  }
  ret = promise_and((uint64_t)promise_idx_ptr, argc);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_batch_create(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *account_id_ptr;
  size_t account_id_len;
  uint64_t ret;

  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[0]);
  ret = promise_batch_create(account_id_len, (uint64_t)account_id_ptr);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_batch_then(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *account_id_ptr;
  size_t account_id_len;
  uint64_t ret;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[1]);
  ret = promise_batch_then(promise_index, account_id_len, (uint64_t)account_id_ptr);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_batch_action_create_account(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  promise_batch_action_create_account(promise_index);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_deploy_contract(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *code_ptr;
  size_t code_len;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  code_ptr = JS_ToCStringLenRaw(ctx, &code_len, argv[1]);
  promise_batch_action_deploy_contract(promise_index, code_len, (uint64_t)code_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_function_call(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *method_name_ptr, *arguments_ptr;
  size_t method_name_len, arguments_len;
  uint64_t amount_ptr[2]; // amount is u128
  uint64_t gas;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  method_name_ptr = JS_ToCStringLen(ctx, &method_name_len, argv[1]);
  arguments_ptr = JS_ToCStringLenRaw(ctx, &arguments_len, argv[2]);
  if (quickjs_to_u128(ctx, argv[3], amount_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for amount");
  }
  if (JS_ToUint64Ext(ctx, &gas, argv[4]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for gas");
  }
  promise_batch_action_function_call(promise_index, method_name_len, (uint64_t)method_name_ptr, arguments_len, (uint64_t)arguments_ptr, (uint64_t)amount_ptr, gas);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_transfer(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  uint64_t amount_ptr[2]; // amount is u128

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  if (quickjs_to_u128(ctx, argv[1], amount_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for amount");
  }
  promise_batch_action_transfer(promise_index, (uint64_t)amount_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_stake(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  uint64_t amount_ptr[2];
  const char *public_key_ptr;
  size_t public_key_len;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  if (quickjs_to_u128(ctx, argv[1], amount_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for amount");
  }
  public_key_ptr = JS_ToCStringLenRaw(ctx, &public_key_len, argv[2]);

  promise_batch_action_stake(promise_index, (uint64_t)amount_ptr, public_key_len, (uint64_t)public_key_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_add_key_with_full_access(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *public_key_ptr;
  size_t public_key_len;
  uint64_t nonce;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  public_key_ptr = JS_ToCStringLenRaw(ctx, &public_key_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &nonce, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for nonce");
  }
  promise_batch_action_add_key_with_full_access(promise_index, public_key_len, (uint64_t)public_key_ptr, nonce);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_add_key_with_function_call(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *public_key_ptr, *receiver_id_ptr, *method_names_ptr;
  size_t public_key_len, receiver_id_len, method_names_len;
  uint64_t nonce, allowance_ptr[2];

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  public_key_ptr = JS_ToCStringLenRaw(ctx, &public_key_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &nonce, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for nonce");
  }
  if (quickjs_to_u128(ctx, argv[3], allowance_ptr) != 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint128 for allowance");
  }
  receiver_id_ptr = JS_ToCStringLen(ctx, &receiver_id_len, argv[4]);
  method_names_ptr = JS_ToCStringLen(ctx, &method_names_len, argv[5]);

  promise_batch_action_add_key_with_function_call(promise_index, public_key_len, (uint64_t)public_key_ptr, nonce, (uint64_t)allowance_ptr, receiver_id_len, (uint64_t)receiver_id_ptr, method_names_len, (uint64_t)method_names_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_delete_key(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *public_key_ptr;
  size_t public_key_len;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  public_key_ptr = JS_ToCStringLenRaw(ctx, &public_key_len, argv[1]);
  promise_batch_action_delete_key(promise_index, public_key_len, (uint64_t)public_key_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_batch_action_delete_account(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_index;
  const char *beneficiary_id_ptr;
  size_t beneficiary_id_len;

  if (JS_ToUint64Ext(ctx, &promise_index, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_index");
  }
  beneficiary_id_ptr = JS_ToCStringLen(ctx, &beneficiary_id_len, argv[1]);
  promise_batch_action_delete_account(promise_index, beneficiary_id_len, (uint64_t)beneficiary_id_ptr);
  return JS_UNDEFINED;
}

static JSValue near_promise_results_count(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = promise_results_count();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_promise_result(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t result_idx, register_id;
  uint64_t ret;

  if (JS_ToUint64Ext(ctx, &result_idx, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for result_idx");
  }
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  ret = promise_result(result_idx, register_id);

  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_promise_return(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t promise_idx;
  if (JS_ToUint64Ext(ctx, &promise_idx, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for promise_idx");
  }
  promise_return(promise_idx);
  
  return JS_UNDEFINED;
}

static JSValue near_storage_write(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr, *value_ptr;
  size_t key_len, value_len;
  uint64_t register_id, ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  value_ptr = JS_ToCStringLenRaw(ctx, &value_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  ret = storage_write(key_len, (uint64_t)key_ptr, value_len, (uint64_t)value_ptr, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_storage_read(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  size_t key_len;
  uint64_t register_id;
  uint64_t ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  ret = storage_read(key_len, (uint64_t)key_ptr, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_storage_remove(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  size_t key_len;
  uint64_t register_id;
  uint64_t ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  ret = storage_remove(key_len, (uint64_t)key_ptr, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_storage_has_key(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  size_t key_len;
  uint64_t ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  ret = storage_has_key(key_len, (uint64_t)key_ptr);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_validator_stake(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *account_id_ptr;
  size_t account_id_len;
  uint64_t stake_ptr[2];

  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[0]);
  validator_stake(account_id_len, (uint64_t)account_id_ptr, (uint64_t)stake_ptr);

  return u128_to_quickjs(ctx, stake_ptr);
}

static JSValue near_validator_total_stake(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t stake_ptr[2];

  validator_total_stake((uint64_t)stake_ptr);
  return u128_to_quickjs(ctx, stake_ptr);
}

#ifdef NIGHTLY
static JSValue near_alt_bn128_g1_multiexp(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }

  alt_bn128_g1_multiexp(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_alt_bn128_g1_sum(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }

  alt_bn128_g1_sum(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_alt_bn128_pairing_check(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;
  uint64_t ret;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  ret = alt_bn128_pairing_check(data_len, (uint64_t)data_ptr);
  return JS_NewBigUint64(ctx, ret);
}
#endif

static void js_add_near_host_functions(JSContext* ctx) {
  JSValue global_obj, env;

  global_obj = JS_GetGlobalObject(ctx);
  env = JS_NewObject(ctx);

  JS_SetPropertyStr(ctx, env, "read_register", JS_NewCFunction(ctx, near_read_register, "read_register", 1));
  JS_SetPropertyStr(ctx, env, "register_len", JS_NewCFunction(ctx, near_register_len, "register_len", 1));
  JS_SetPropertyStr(ctx, env, "write_register", JS_NewCFunction(ctx, near_write_register, "write_register", 2));
  JS_SetPropertyStr(ctx, env, "current_account_id", JS_NewCFunction(ctx, near_current_account_id, "current_account_id", 1));
  JS_SetPropertyStr(ctx, env, "signer_account_id", JS_NewCFunction(ctx, near_signer_account_id, "signer_account_id", 1));
  JS_SetPropertyStr(ctx, env, "signer_account_pk", JS_NewCFunction(ctx, near_signer_account_pk, "signer_account_pk", 1));
  JS_SetPropertyStr(ctx, env, "predecessor_account_id", JS_NewCFunction(ctx, near_predecessor_account_id, "predecessor_account_id", 1));
  JS_SetPropertyStr(ctx, env, "input", JS_NewCFunction(ctx, near_input, "input", 1));
  JS_SetPropertyStr(ctx, env, "block_index", JS_NewCFunction(ctx, near_block_index, "block_index", 0));
  JS_SetPropertyStr(ctx, env, "block_timestamp", JS_NewCFunction(ctx, near_block_timestamp, "block_timestamp", 0));
  JS_SetPropertyStr(ctx, env, "epoch_height", JS_NewCFunction(ctx, near_epoch_height, "epoch_height", 0));
  JS_SetPropertyStr(ctx, env, "storage_usage", JS_NewCFunction(ctx, near_storage_usage, "storage_usage", 0));
  JS_SetPropertyStr(ctx, env, "account_balance", JS_NewCFunction(ctx, near_account_balance, "account_balance", 0));
  JS_SetPropertyStr(ctx, env, "account_locked_balance", JS_NewCFunction(ctx, near_account_locked_balance, "account_locked_balance", 0));
  JS_SetPropertyStr(ctx, env, "attached_deposit", JS_NewCFunction(ctx, near_attached_deposit, "attached_deposit", 0));
  JS_SetPropertyStr(ctx, env, "prepaid_gas", JS_NewCFunction(ctx, near_prepaid_gas, "prepaid_gas", 0));
  JS_SetPropertyStr(ctx, env, "used_gas", JS_NewCFunction(ctx, near_used_gas, "used_gas", 0));
  JS_SetPropertyStr(ctx, env, "random_seed", JS_NewCFunction(ctx, near_random_seed, "random_seed", 1));
  JS_SetPropertyStr(ctx, env, "sha256", JS_NewCFunction(ctx, near_sha256, "sha256", 2));
  JS_SetPropertyStr(ctx, env, "keccak256", JS_NewCFunction(ctx, near_keccak256, "keccak256", 2));
  JS_SetPropertyStr(ctx, env, "keccak512", JS_NewCFunction(ctx, near_keccak512, "keccak512", 2));
  JS_SetPropertyStr(ctx, env, "ripemd160", JS_NewCFunction(ctx, near_ripemd160, "ripemd160", 2));
  JS_SetPropertyStr(ctx, env, "ecrecover", JS_NewCFunction(ctx, near_ecrecover, "ecrecover", 5));
  JS_SetPropertyStr(ctx, env, "value_return", JS_NewCFunction(ctx, near_value_return, "value_return", 1));
  JS_SetPropertyStr(ctx, env, "panic", JS_NewCFunction(ctx, near_panic, "panic", 1));
  JS_SetPropertyStr(ctx, env, "panic_utf8", JS_NewCFunction(ctx, near_panic_utf8, "panic_utf8", 1));
  JS_SetPropertyStr(ctx, env, "log", JS_NewCFunction(ctx, near_log, "log", 1));
  JS_SetPropertyStr(ctx, env, "log_utf8", JS_NewCFunction(ctx, near_log_utf8, "log_utf8", 1));
  JS_SetPropertyStr(ctx, env, "log_utf16", JS_NewCFunction(ctx, near_log_utf16, "log_utf16", 1));
  JS_SetPropertyStr(ctx, env, "promise_create", JS_NewCFunction(ctx, near_promise_create, "promise_create", 5));
  JS_SetPropertyStr(ctx, env, "promise_then", JS_NewCFunction(ctx, near_promise_then, "promise_then", 6));
  JS_SetPropertyStr(ctx, env, "promise_and", JS_NewCFunction(ctx, near_promise_and, "promise_and", 1));
  JS_SetPropertyStr(ctx, env, "promise_batch_create", JS_NewCFunction(ctx, near_promise_batch_create, "promise_batch_create", 1));
  JS_SetPropertyStr(ctx, env, "promise_batch_then", JS_NewCFunction(ctx, near_promise_batch_then, "promise_batch_then", 2));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_create_account", JS_NewCFunction(ctx, near_promise_batch_action_create_account, "promise_batch_action_create_account", 1));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_deploy_contract", JS_NewCFunction(ctx, near_promise_batch_action_deploy_contract, "promise_batch_action_deploy_contract", 2));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_function_call", JS_NewCFunction(ctx, near_promise_batch_action_function_call, "promise_batch_action_function_call", 5));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_transfer", JS_NewCFunction(ctx, near_promise_batch_action_transfer, "promise_batch_action_transfer", 2));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_stake", JS_NewCFunction(ctx, near_promise_batch_action_stake, "promise_batch_action_stake", 3));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_add_key_with_full_access", JS_NewCFunction(ctx, near_promise_batch_action_add_key_with_full_access, "promise_batch_action_add_key_with_full_access", 3));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_add_key_with_function_call", JS_NewCFunction(ctx, near_promise_batch_action_add_key_with_function_call, "promise_batch_action_add_key_with_function_call", 6));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_delete_key", JS_NewCFunction(ctx, near_promise_batch_action_delete_key, "promise_batch_action_delete_key", 2));
  JS_SetPropertyStr(ctx, env, "promise_batch_action_delete_account", JS_NewCFunction(ctx, near_promise_batch_action_delete_account, "promise_batch_action_delete_account", 2));
  JS_SetPropertyStr(ctx, env, "promise_results_count", JS_NewCFunction(ctx, near_promise_results_count, "promise_results_count", 0));
  JS_SetPropertyStr(ctx, env, "promise_result", JS_NewCFunction(ctx, near_promise_result, "promise_result", 2));
  JS_SetPropertyStr(ctx, env, "promise_return", JS_NewCFunction(ctx, near_promise_return, "promise_return", 1));
  JS_SetPropertyStr(ctx, env, "storage_write", JS_NewCFunction(ctx, near_storage_write, "storage_write", 2));
  JS_SetPropertyStr(ctx, env, "storage_read", JS_NewCFunction(ctx, near_storage_read, "storage_read", 2));
  JS_SetPropertyStr(ctx, env, "storage_remove", JS_NewCFunction(ctx, near_storage_remove, "storage_remove", 2));
  JS_SetPropertyStr(ctx, env, "storage_has_key", JS_NewCFunction(ctx, near_storage_has_key, "storage_has_key", 2));
  JS_SetPropertyStr(ctx, env, "validator_stake", JS_NewCFunction(ctx, near_validator_stake, "validator_stake", 2));
  JS_SetPropertyStr(ctx, env, "validator_total_stake", JS_NewCFunction(ctx, near_validator_total_stake, "validator_total_stake", 1));
  #ifdef NIGHTLY
  // as of Jun 24, 2022, alt_bn128 is not a nightly protocol feature any more. It's part of protocol version 55. But, testnet
// is at protocol version 54 and mainnet is at protocol version 53. We'll enable and add alt_bn128 as they in testnet.
  JS_SetPropertyStr(ctx, env, "alt_bn128_g1_multiexp", JS_NewCFunction(ctx, near_alt_bn128_g1_multiexp, "alt_bn128_g1_multiexp", 2));
  JS_SetPropertyStr(ctx, env, "alt_bn128_g1_sum", JS_NewCFunction(ctx, near_alt_bn128_g1_sum, "alt_bn128_g1_sum", 2));
  JS_SetPropertyStr(ctx, env, "alt_bn128_pairing_check", JS_NewCFunction(ctx, near_alt_bn128_pairing_check, "alt_bn128_pairing_check", 1));
  #endif

  JS_SetPropertyStr(ctx, global_obj, "env", env);
}

JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
                int argc, JSValueConst *argv);

void _start() {}

#include "methods.h"

'''
'''--- cli/cli.js ---
#!/usr/bin/env node

import fs from 'fs/promises'
import path from 'path';

import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'

import { nodeResolve } from '@rollup/plugin-node-resolve';
import sourcemaps from 'rollup-plugin-sourcemaps';
import { babel } from '@rollup/plugin-babel';
import { rollup } from 'rollup';

import { executeCommand } from './utils.js';

const PROJECT_DIR = process.cwd();
const NEAR_SDK_JS = 'node_modules/near-sdk-js';
const TSC = 'node_modules/.bin/tsc';
const QJSC_DIR = `${NEAR_SDK_JS}/cli/deps/quickjs`;
const QJSC = `${NEAR_SDK_JS}/cli/deps/qjsc`;

yargs(hideBin(process.argv))
    .scriptName('near-sdk-js')
    .usage('$0 <cmd> [args]')
    .command('build [source] [target]', 'Build NEAR JS Smart-contract', (yargs) => {
        yargs
            .positional('source', {
                type: 'string',
                default: 'src/index.js',
                describe: 'Contract to build'
            })
            .positional('target', {
                type: 'string',
                default: 'build/contract.wasm',
                describe: 'Target file path and name'
            })
    }, build)
    .help()
    .argv

async function build(argv) {
    const SOURCE_FILE_WITH_PATH = argv.source;
    const SOURCE_EXT = argv.source.split('.').pop();
    const TARGET_DIR = path.dirname(argv.target);
    const TARGET_EXT = argv.target.split('.').pop();
    const TARGET_FILE_NAME = path.basename(argv.target, `.${TARGET_EXT}`);

    if(!["wasm", "base64"].includes(TARGET_EXT)){
        throw new Error(`Unsupported target ${TARGET_EXT}, make sure target ends with .wasm or .base64`);
    } 

    const TARGET_TYPE = TARGET_EXT === 'wasm' ? 'STANDALONE' : 'ENCLAVED';

    const ROLLUP_TARGET = `${TARGET_DIR}/${TARGET_FILE_NAME}.js`;
    const QJSC_TARGET = `${TARGET_DIR}/${TARGET_FILE_NAME}.h`;
    const STANDALONE_CONTRACT_TARGET = `${TARGET_DIR}/${TARGET_FILE_NAME}.wasm`;
    const ENCLAVED_CONTRACT_TARGET = `${TARGET_DIR}/${TARGET_FILE_NAME}.base64`;

    console.log(`Building ${SOURCE_FILE_WITH_PATH} contract...`);

    if (SOURCE_EXT === 'ts') {
        await checkTsBuildWithTsc(SOURCE_FILE_WITH_PATH);
    }

    console.log(`Creating ${TARGET_DIR} directory...`);
    await executeCommand(`mkdir -p ${TARGET_DIR}`);

    await createJsFileWithRullup(SOURCE_FILE_WITH_PATH, ROLLUP_TARGET);

    await createHeaderFileWithQjsc(ROLLUP_TARGET, QJSC_TARGET);

    if (TARGET_TYPE === 'STANDALONE') {
        await createStandaloneMethodsHeaderFile(ROLLUP_TARGET);
        await createStandaloneWasmContract(QJSC_TARGET, STANDALONE_CONTRACT_TARGET);
        await wasiStubStandaloneContract(STANDALONE_CONTRACT_TARGET);
    } else {
        await createEnclavedContract(QJSC_TARGET, ENCLAVED_CONTRACT_TARGET);
    }
}

async function checkTsBuildWithTsc(sourceFileWithPath) {
    console.log(`check TypeScript build of ${sourceFileWithPath} with tsc`)
    await executeCommand(`${TSC} --noEmit --experimentalDecorators --target es5 ${sourceFileWithPath}`);
}

// Common build function
async function createJsFileWithRullup(sourceFileWithPath, rollupTarget) {
    console.log(`Creating ${rollupTarget} file with Rollup...`);
    const bundle = await rollup({
        input: sourceFileWithPath,
        plugins: [
            nodeResolve({
                extensions: ['.js', '.ts']
            }),
            sourcemaps(),
            // commonjs(),
            babel({ babelHelpers: 'bundled', extensions: ['.ts', '.js', '.jsx', '.es6', '.es', '.mjs'] })
        ],
    });

    await bundle.write({
        sourcemap: true,
        file: rollupTarget,
        format: 'es'
    });
}

async function createHeaderFileWithQjsc(rollupTarget, qjscTarget) {
    console.log(`Creating ${qjscTarget} file with QJSC...`);
    await executeCommand(`${QJSC} -c -m -o ${qjscTarget} -N code ${rollupTarget}`);
}

// Enclaved build functions
async function createEnclavedContract(qjscTarget, enclavedContractTarget) {
    console.log(`Saving enclaved bytecode to ${enclavedContractTarget}`);
    const SAVE_BYTECODE_SCRIPT = `${NEAR_SDK_JS}/cli/save_bytecode.js`;
    await executeCommand(`node ${SAVE_BYTECODE_SCRIPT} ${qjscTarget} ${enclavedContractTarget}`);
}

// Standalone build functions
async function createStandaloneMethodsHeaderFile(rollupTarget) {
    console.log(`Genereting methods.h file`);
    let source = rollupTarget;
    const buildPath = path.dirname(source);
    console.log(rollupTarget)
    let mod = await import(`${PROJECT_DIR}/${rollupTarget}`);
    let exportNames = Object.keys(mod);
    let methods = '';
    for (let name of exportNames) {
        methods += `DEFINE_NEAR_METHOD(${name})\n`;
    }
    await fs.writeFile(`${buildPath}/methods.h`, methods);
}

async function createStandaloneWasmContract(qjscTarget, standaloneContractTarget) {
    console.log(`Creating ${standaloneContractTarget} contract...`);
    const WASI_SDK_PATH = `${NEAR_SDK_JS}/cli/deps/wasi-sdk`;

    const CC = `${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot`
    let DEFS = `-D_GNU_SOURCE '-DCONFIG_VERSION="2021-03-27"' -DCONFIG_BIGNUM`
    if (process.env.NEAR_NIGHTLY) {
        DEFS = DEFS + ' -DNIGHTLY'
    }
    const INCLUDES = `-I${QJSC_DIR} -I.`
    const ORIGINAL_BUILDER_PATH = `${NEAR_SDK_JS}/cli/builder/builder.c`;
    const NEW_BUILDER_PATH = `${path.dirname(standaloneContractTarget)}/builder.c`
    const SOURCES = `${NEW_BUILDER_PATH} ${QJSC_DIR}/quickjs.c ${QJSC_DIR}/libregexp.c ${QJSC_DIR}/libunicode.c ${QJSC_DIR}/cutils.c ${QJSC_DIR}/quickjs-libc-min.c ${QJSC_DIR}/libbf.c`;
    const LIBS = `-lm`

    // copying builder.c file to the build folder
    await executeCommand(`cp ${ORIGINAL_BUILDER_PATH} ${NEW_BUILDER_PATH}`);
    await executeCommand(`mv ${qjscTarget} build/code.h`);

    await executeCommand(`${CC} --target=wasm32-wasi -nostartfiles -Oz -flto ${DEFS} ${INCLUDES} ${SOURCES} ${LIBS} -Wl,--no-entry -Wl,--allow-undefined -Wl,-z,stack-size=${256 * 1024} -Wl,--lto-O3 -o ${standaloneContractTarget}`);
}

async function wasiStubStandaloneContract(standaloneContractTarget) {
    console.log(`Excecuting wasi-stub...`);
    const WASI_STUB = `${NEAR_SDK_JS}/cli/deps/binaryen/wasi-stub/run.sh`;
    await executeCommand(`${WASI_STUB} ${standaloneContractTarget} >/dev/null`);
}

'''
'''--- cli/post-install.js ---
import { executeCommand } from './utils.js';

const OS = await executeCommand('uname -s', true);
const ARCH = await executeCommand('uname -m', true);

if (OS !== 'Linux' && OS !== 'Darwin') {
    console.error(`OS ${OS} is not supported at the moment`);
    process.exit(1);
}

if (ARCH !== 'x86_64' && ARCH !== 'arm64') {
    console.error(` ${ARCH} architecture is unsapported at the moment`);
    process.exit(1);
}

console.log('Installing wasi-stub...');
const BINARYEN_VERSION = `0.1.10`;
const BINARYEN_VERSION_TAG = `v${BINARYEN_VERSION}`;
const BINARYEN_SYSTEM_NAME = OS === 'Linux' ? 'Linux' : OS === 'Darwin' ? 'macOS' : 'other';
const BINARYEN_ARCH_NAME = ARCH === 'x86_64' ? 'X64' : ARCH === 'arm64' ? 'arm64' : 'other';
const BINARYEN_TAR_NAME = `binaryen-${BINARYEN_SYSTEM_NAME}-${BINARYEN_ARCH_NAME}.tar.gz`;

await executeCommand(`wget https://github.com/near/binaryen/releases/download/${BINARYEN_VERSION_TAG}/${BINARYEN_TAR_NAME}`);
await executeCommand(`mkdir -p binaryen && tar xvf ${BINARYEN_TAR_NAME} --directory binaryen`);
await executeCommand(`rm ${BINARYEN_TAR_NAME}`);

console.log('Installing QuickJS...');
const QUICK_JS_VERSION = `0.1.0`;
const QUICK_JS_VERSION_TAG = `v${QUICK_JS_VERSION}`;
const QUICK_JS_SYSTEM_NAME = OS === 'Linux' ? 'Linux' : OS === 'Darwin' ? 'macOS' : 'other';
const QUICK_JS_ARCH_NAME = ARCH === 'x86_64' ? 'X64' : ARCH === 'arm64' ? 'arm64' : 'other';
const QUICK_JS_TAR_NAME = `${QUICK_JS_VERSION_TAG}.tar.gz`
const QUICK_JS_DOWNLOADED_FOLDER_NAME = `quickjs-${QUICK_JS_VERSION}`
const QUICK_JS_TARGET_FOLDER_NAME = 'quickjs';
const QUICK_JS_DOWNLOADED_NAME = `qjsc-${QUICK_JS_SYSTEM_NAME}-${QUICK_JS_ARCH_NAME}`
const QUICK_JS_TARGET_NAME = 'qjsc';
// Download QuickJS
await executeCommand(`wget https://github.com/near/quickjs/releases/download/${QUICK_JS_VERSION_TAG}/qjsc-${QUICK_JS_SYSTEM_NAME}-${QUICK_JS_ARCH_NAME}`);
await executeCommand(`wget https://github.com/near/quickjs/archive/refs/tags/${QUICK_JS_VERSION_TAG}.tar.gz`);
// Extract QuickJS
await executeCommand(`tar xvf ${QUICK_JS_TAR_NAME}`);
// Delete .tar file
await executeCommand(`rm ${QUICK_JS_TAR_NAME}`);
// Delete version from folder name
await executeCommand(`mv ${QUICK_JS_DOWNLOADED_FOLDER_NAME} ${QUICK_JS_TARGET_FOLDER_NAME}`);
// Rename qjsc file
await executeCommand(`mv ${QUICK_JS_DOWNLOADED_NAME} ${QUICK_JS_TARGET_NAME}`);
// chmod qjsc
await executeCommand(`chmod 777 ${QUICK_JS_TARGET_NAME}`);

console.log('Installing wasi-sdk...');
const WASI_SDK_MAJOR_VER = 11;
const WASI_SDK_MINOR_VER = 0;
const WASI_SDK_DOWNLOADED_FOLDER_NAME = `wasi-sdk-${WASI_SDK_MAJOR_VER}.${WASI_SDK_MINOR_VER}`
const WASI_SDK_SYSTEM_NAME = OS === 'Linux' ? 'linux' : OS === 'Darwin' ? 'macos' : 'other';
const WASI_SDK_TAR_NAME = `${WASI_SDK_DOWNLOADED_FOLDER_NAME}-${WASI_SDK_SYSTEM_NAME}.tar.gz`

// Download WASI SDK
await executeCommand(`wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-${WASI_SDK_MAJOR_VER}/${WASI_SDK_TAR_NAME}`);
// Extract WASI SDK
await executeCommand(`tar xvf ${WASI_SDK_TAR_NAME}`);
// Delete .tar file
await executeCommand(`rm ${WASI_SDK_TAR_NAME}`);
// Delete version from folder name
await executeCommand(`mv ${WASI_SDK_DOWNLOADED_FOLDER_NAME} wasi-sdk`);

'''
'''--- cli/save_bytecode.js ---
import fs from 'fs/promises'
import path from 'path'

//TODO: execute it in js env
async function main() {
    let source = path.resolve(process.argv[process.argv.length-2])
    let target = path.resolve(process.argv[process.argv.length-1])
    let code = await fs.readFile(source, 'utf-8')
    let lines = code.split('\n')
    let codes = []
    for (let line of lines) {
        if (line.indexOf('0x') >= 0) {
            let nums = line.trim()
            nums = nums.slice(0, nums.length - 1).split(', ')
            codes.push(nums.map(Number))
        }
    }
    let bytecode = Buffer.concat(codes.map(Buffer.from))
    await fs.writeFile(target, bytecode.toString('base64'))
}

main()
'''
'''--- cli/utils.js ---
import { exec as exec_ } from 'child_process';
import { promisify } from 'util';

const exec = promisify(exec_);

export async function executeCommand(command, silent = false) {
    console.log(command);
    const { error, stdout, stderr } = await exec(command);

    if (error) {
        console.log(error);
        process.exit(1);
    }
    if (stderr && !silent) {
        console.error(stderr);
    }

    if (silent) {
        return stdout.trim();
    } else {
        console.log(stdout);
    }
}
'''
'''--- cli/wasm_to_bytes.js ---
import fs from 'fs/promises'
import path from 'path'

// used for deploy code in contract with near.promiseBatchActionDeployContract.
// Usage:
// node wasm_to_bytes.js contract.wasm contract.jsbytes
// copy paste the content of the contract.jsbytes, pass it as arguments to near.promiseBatchActionDeployContract:
// near.promiseBatchActionDeployContract(promsieId, '<content of contract.jsbytes>')
// Note, do not use `bytes()` type check here, which is too expensive for this long bytes and will exceed gas limit.
async function main() {
    let source = path.resolve(process.argv[process.argv.length-2])
    let target = path.resolve(process.argv[process.argv.length-1])
    let code = await fs.readFile(source)
    let result = '';
    for (let e of code) {
        result += '\\x' + e.toString(16).padStart(2, '0')
    }
    await fs.writeFile(target, result)
}

main()
'''
'''--- examples/__tests__/test-clean-state.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the clean-state contract.
    const cleanState = await root.devDeploy('./build/clean-state.wasm');

    // Init the contract
    await cleanState.call(cleanState, 'init', {});

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        cleanState,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Clean state after storing', async t => {
    const { root, cleanState } = t.context.accounts;
    await root.call(cleanState, 'put', { key: '1', value: 1 });
    const value1 = await cleanState.view('get', { key: '1' });
    t.is(value1, '1');
    await cleanState.call(cleanState, 'clean', { keys: ['1'] });
    const value2 = await cleanState.view('get', { key: '1' });
    t.is(value2, null);
});

'''
'''--- examples/__tests__/test-counter.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the counter contract.
    const counter = await root.devDeploy(
        process.env['COUNTER_LOWLEVEL'] ? 
        './build/counter-lowlevel.wasm' :
        (process.env['COUNTER_TS'] ? './build/counter-ts.wasm' : './build/counter.wasm')
    );

    // Init the contract
    await counter.call(counter, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, counter, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Initial count is 0', async t => {
    const { counter } = t.context.accounts;
    const result = await counter.view('getCount', {});
    t.is(result, 0);
});

test('Increase works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'increase', {});

    let result = await counter.view('getCount', {});
    t.is(result, 1);

    await bob.call(counter, 'increase', { n: 4 });
    result = await counter.view('getCount', {});
    t.is(result, 5);
});

test('Decrease works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'decrease', {});

    let result = await counter.view('getCount', {});
    t.is(result, -1);

    let dec = await bob.callRaw(counter, 'decrease', { n: 4 });
    // ensure imported log does work, not silent failure
    t.is(dec.result.receipts_outcome[0].outcome.logs[0], "Counter decreased to -5")
    result = await counter.view('getCount', {});
    t.is(result, -5);
});
'''
'''--- examples/__tests__/test-cross-contract-call.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy status-message the contract.
    const statusMessage = await root.devDeploy(
        './build/status-message.wasm',
    );

    // Init the contract
    await statusMessage.call(statusMessage, 'init', {});

    // Deploy the onCall contract.
    const onCall = await root.devDeploy(
        './build/cross-contract-call.wasm',
    );

    // Init the contract
    await onCall.call(onCall, 'init', { statusMessageContract: statusMessage.accountId });

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        statusMessage,
        onCall,
        ali,
        bob,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Nobody is on-call in the beginning', async t => {
    const { onCall } = t.context.accounts;
    const result = await onCall.view('person_on_call', {});
    t.is(result, 'undefined');
});

test('Person can be set on-call if AVAILABLE', async t => {
    const { ali, bob, onCall, statusMessage } = t.context.accounts;

    // Ali set her status as AVAILABLE
    await ali.call(statusMessage, 'set_status', { message: 'AVAILABLE' });
    // Bob sets Ali on-call
    await bob.call(onCall, 'set_person_on_call', { accountId: ali.accountId }, { gas: 120000000000000 });

    // Check that Ali is on-call
    t.is(
        await onCall.view('person_on_call', {}),
        ali.accountId
    );
});

test('Person can NOT be set on-call if UNAVAILABLE', async t => {
    const { ali, bob, onCall, statusMessage } = t.context.accounts;

    // Ali set her status as AVAILABLE
    await ali.call(statusMessage, 'set_status', { message: 'UNAVAILABLE' });
    // Bob tries to sets Ali on-call
    await bob.call(onCall, 'set_person_on_call', { accountId: ali.accountId }, { gas: 120000000000000 });

    // Check that Ali is NOT on-call
    t.not(
        await onCall.view('person_on_call', {}),
        ali.accountId
    );
});

'''
'''--- examples/__tests__/test-fungible-token-lockable.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the lockable-ft contract.
    const lockableFt = await root.devDeploy(
        './build/fungible-token-lockable.wasm',
    );

    // Init the contract
    await lockableFt.call(lockableFt, 'init', { prefix: 'prefix', totalSupply: 10000 });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, lockableFt, ali, bob };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Owner initial details', async t => {
    const { lockableFt } = t.context.accounts;
    const totalSupply = await lockableFt.view('getTotalSupply', {});
    t.is(totalSupply, 10000);
    const totalBalance = await lockableFt.view('getTotalBalance', { ownerId: lockableFt.accountId });
    t.is(totalBalance, 10000);
    const unlockedBalance = await lockableFt.view('getUnlockedBalance', { ownerId: lockableFt.accountId });
    t.is(unlockedBalance, 10000);
    const allowance = await lockableFt.view('getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(allowance, 0);
    const lockedBalance = await lockableFt.view('getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(lockedBalance, 0);
});

test('Set allowance', async t => {
    const { lockableFt, ali } = t.context.accounts;
    await lockableFt.call(lockableFt, 'setAllowance', { escrowAccountId: ali.accountId, allowance: 100 });
    const aliAllowance = await lockableFt.view('getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: ali.accountId });
    t.is(aliAllowance, 100);
    const contractAllowance = await lockableFt.view('getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(contractAllowance, 0);
});

test('Fail to set allowance for oneself', async t => {
    const { lockableFt } = t.context.accounts;
    const error = await t.throwsAsync(() => lockableFt.call(lockableFt, 'setAllowance', { escrowAccountId: lockableFt.accountId, allowance: 100 }));
    t.assert(error.message.includes(`Can't set allowance for yourself`));
});

test('Lock owner', async t => {
    const { lockableFt } = t.context.accounts;
    await lockableFt.call(lockableFt, 'lock', { ownerId: lockableFt.accountId, lockAmount: 100 });
    const unlockedBalance = await lockableFt.view('getUnlockedBalance', { ownerId: lockableFt.accountId });
    t.is(unlockedBalance, 9900);
    const allowance = await lockableFt.view('getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(allowance, 0);
    const lockedBalance = await lockableFt.view('getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(lockedBalance, 100);
});

test('Lock failures', async t => {
    const { lockableFt, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'lock', { ownerId: lockableFt.accountId, lockAmount: 0 }));
    t.assert(error1.message.includes(`Can't lock 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'lock', { ownerId: lockableFt.accountId, lockAmount: 10001 }));
    t.assert(error2.message.includes(`Not enough unlocked balance`));

    const error3 = await t.throwsAsync(() => ali.call(lockableFt, 'lock', { ownerId: lockableFt.accountId, lockAmount: 10 }));
    t.assert(error3.message.includes(`Not enough allowance`));
});

test('Unlock owner', async t => {
    const { lockableFt } = t.context.accounts;
    await lockableFt.call(lockableFt, 'lock', { ownerId: lockableFt.accountId, lockAmount: 100 });
    await lockableFt.call(lockableFt, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 100 });
    const unlockedBalance = await lockableFt.view('getUnlockedBalance', { ownerId: lockableFt.accountId });
    t.is(unlockedBalance, 10000);
    const allowance = await lockableFt.view('getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(allowance, 0);
    const lockedBalance = await lockableFt.view('getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId });
    t.is(lockedBalance, 0);
});

test('Unlock failures', async t => {
    const { lockableFt } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 0 }));
    t.assert(error1.message.includes(`Can't unlock 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 1 }));
    t.assert(error2.message.includes(`Not enough locked tokens`));
});

test('Simple transfer', async t => {
    const { lockableFt, ali } = t.context.accounts;
    await lockableFt.call(lockableFt, 'transfer', { newOwnerId: ali.accountId, amount: 100 });
    const ownerUnlockedBalance = await lockableFt.view('getUnlockedBalance', { ownerId: lockableFt.accountId });
    t.is(ownerUnlockedBalance, 9900);
    const aliUnlockedBalance = await lockableFt.view('getUnlockedBalance', { ownerId: ali.accountId });
    t.is(aliUnlockedBalance, 100);
});

test('Transfer failures', async t => {
    const { lockableFt, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'transfer', { newOwnerId: ali.accountId, amount: 0 }));
    t.assert(error1.message.includes(`Can't transfer 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(lockableFt, 'transfer', { newOwnerId: ali.accountId, amount: 10001 }));
    t.assert(error2.message.includes(`Not enough unlocked balance`));
});

'''
'''--- examples/__tests__/test-fungible-token.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async (t) => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the ft contract.
    const ft = await root.devDeploy(
        './build/fungible-token.wasm',
    );
    const xcc = await root.devDeploy(
        './build/fungible-token-helper.wasm',
    );

    // Init the contracts
    await ft.call(ft, 'init', { prefix: 'a', totalSupply: '1000' });
    await xcc.call(xcc, 'init', {});

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = { root, ft, ali, bob, xcc };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Owner has all balance in the beginning', async t => {
    const { ft } = t.context.accounts;
    const result = await ft.view('ftBalanceOf', { accountId: ft.accountId });
    t.is(result, '1000');
});

test('Can transfer if balance is sufficient', async t => {
    const { ali, ft } = t.context.accounts;

    await ft.call(ft, 'ftTransfer', { receiverId: ali.accountId, amount: '100' });
    const aliBalance = await ft.view('ftBalanceOf', { accountId: ali.accountId });
    t.is(aliBalance, '100');
    const ownerBalance = await ft.view('ftBalanceOf', { accountId: ft.accountId });
    t.is(ownerBalance, '900');
});

test('Cannot transfer if balance is not sufficient', async t => {
    const { ali, bob, ft } = t.context.accounts;
    try {
        await ali.call(ft, 'ftTransfer', { receiverId: bob.accountId, amount: '100' });
    } catch (e) {
        t.assert(e.toString().indexOf('Smart contract panicked: assertion failed: The account doesn\'t have enough balance') >= 0);
    }
});

test('Cross contract transfer', async (t) => {
    const { xcc, ft } = t.context.accounts;
    await ft.call(ft, 'ftTransferCall', { receiverId: xcc.accountId, amount: '900', memo: null, msg: 'test msg' }, { gas: 200000000000000 });
    const aliBalance = await ft.view('ftBalanceOf', { accountId: xcc.accountId });
    t.is(aliBalance, '900');
    const aliSubContractData = await xcc.view('getContractData');
    t.is(aliSubContractData, `[900 from ${ft.accountId} to ${xcc.accountId}] test msg `);
    const ownerBalance = await ft.view('ftBalanceOf', { accountId: ft.accountId });
    t.is(ownerBalance, '100');
});

'''
'''--- examples/__tests__/test-non-fungible-token.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the nft contract.
    const nft = await root.devDeploy(
        './build/non-fungible-token.wasm',
    );

    // Init the contract
    await nft.call(nft, 'init', { owner_id: nft.accountId, owner_by_id_prefix: 'a' });

    // Deploy the tokenReceiver contract.
    const tokenReceiver = await root.devDeploy(
        './build/non-fungible-token-receiver.wasm',
    );

    // Init the contract
    await tokenReceiver.call(tokenReceiver, 'init', { nonFungibleTokenAccountId: nft.accountId });

    // Mint an NFT
    let tokenId = 'my-cool-nft';
    await nft.call(nft, 'nftMint', { token_id: tokenId, token_owner_id: nft.accountId });

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = { root, nft, tokenReceiver, tokenId, ali, bob };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Owner has the NFT in the beginning', async t => {
    const { nft, tokenId } = t.context.accounts;
    const result = await nft.view('nftToken', { token_id: tokenId });
    t.deepEqual(result, { owner_id: nft.accountId, token_id: tokenId });
});

test('Simple transfer', async t => {
    const { nft, tokenId, ali } = t.context.accounts;
    await nft.call(nft, 'nftTransfer', { receiver_id: ali.accountId, token_id: tokenId });
    const result = await nft.view('nftToken', { token_id: tokenId });
    t.deepEqual(result, { owner_id: ali.accountId, token_id: tokenId });
});

test('Transfer failures', async t => {
    const { nft, tokenId, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => ali.call(nft, 'nftTransfer', { receiver_id: nft.accountId, token_id: 'non-existent-id' }));
    t.assert(error1.message.includes(`Token not found`));

    const error2 = await t.throwsAsync(() => ali.call(nft, 'nftTransfer', { receiver_id: nft.accountId, token_id: tokenId }));
    t.assert(error2.message.includes(`Sender must be the current owner`));

    const error3 = await t.throwsAsync(() => nft.call(nft, 'nftTransfer', { receiver_id: nft.accountId, token_id: tokenId }));
    t.assert(error3.message.includes(`Current and next owner must differ`));
});

test('Transfer call where receiver returns the token', async t => {
    const { nft, tokenReceiver, tokenId } = t.context.accounts;
    await nft.call(
        nft,
        'nftTransferCall', { receiver_id: tokenReceiver.accountId, token_id: tokenId, approval_id: null, memo: null, msg: 'return-it-now' }, { gas: '120000000000000' });
    const result = await nft.view('nftToken', { token_id: tokenId });
    t.deepEqual(result, { owner_id: nft.accountId, token_id: tokenId });
});

test('Transfer call where receiver keeps the token', async t => {
    const { nft, tokenReceiver, tokenId } = t.context.accounts;
    await nft.call(nft, 'nftTransferCall', { receiver_id: tokenReceiver.accountId, token_id: tokenId, approval_id: null, memo: null, msg: 'keep-it-now' }, { gas: '120000000000000' });
    const result = await nft.view('nftToken', { token_id: tokenId });
    t.deepEqual(result, { owner_id: tokenReceiver.accountId, token_id: tokenId });
});

'''
'''--- examples/__tests__/test-parking-lot.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;

    const parkingLot = await root.devDeploy(
        'build/parking-lot.wasm',
    );
    await parkingLot.call(parkingLot, 'init', {});

    const ali = await root.createSubAccount('ali');

    t.context.worker = worker;
    t.context.accounts = { root, parkingLot, ali };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('No BMW in the beginning', async t => {
    const { parkingLot } = t.context.accounts;

    t.is(
        await parkingLot.view('getCarSpecs', { name: 'BMW' }),
        null
    );
});

test('Can run the car after adding it', async t => {
    const { ali, parkingLot } = t.context.accounts;

    const bmwSpecs = {
        id: 1,
        color: 'Black',
        price: 100500,
        engineHp: 500,
    };

    await ali.call(parkingLot, 'addCar', {
        name: 'BMW',
        ...bmwSpecs
    });

    t.is(await parkingLot.view('runCar', {name: 'BMW'}), 'boom');
});

'''
'''--- examples/__tests__/test-status-message-collections.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the statis-message contract.
    const statusMessage = await root.devDeploy(
        './build/status-message-collections.wasm',
    );

    // Init the contract
    await statusMessage.call(statusMessage, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, statusMessage, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Root gets null status', async t => {
    const { root, statusMessage } = t.context.accounts;
    const result = await statusMessage.view('get_status', { account_id: root.accountId });
    t.is(result, null);
});

test('Ali sets then gets status', async t => {
    const { ali, statusMessage } = t.context.accounts;
    await ali.call(statusMessage, 'set_status', { message: 'hello' });

    t.is(
        await statusMessage.view('get_status', { account_id: ali.accountId }),
        'hello'
    );
});

test('Bob and Carl have different statuses', async t => {
    const { statusMessage, bob, carl } = t.context.accounts;
    await bob.call(statusMessage, 'set_status', { message: 'hello' });
    await carl.call(statusMessage, 'set_status', { message: 'world' });

    const bobStatus = await statusMessage.view('get_status', { account_id: bob.accountId });
    const carlStatus = await statusMessage.view('get_status', { account_id: carl.accountId });
    t.is(bobStatus, 'hello');
    t.is(carlStatus, 'world');
});

test('Get statuses from the contract', async t => {
    const { statusMessage, bob, carl } = t.context.accounts;
    await bob.call(statusMessage, 'set_status', { message: 'hello' });
    await carl.call(statusMessage, 'set_status', { message: 'world' });

    const statuses = await statusMessage.view('get_all_statuses', {});
    t.deepEqual(statuses, [[bob.accountId, 'hello'], [carl.accountId, 'world']]);
});

test('message has stored by someone', async t => {
    const { ali, statusMessage } = t.context.accounts;
    await ali.call(statusMessage, 'set_status', { message: 'hello' });

    t.is(
        await statusMessage.view('has_status', { message: 'hello' }),
        true
    );

    t.is(
        await statusMessage.view('has_status', { message: 'world' }),
        false
    );
});
'''
'''--- examples/__tests__/test-status-message.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;
    
    // Deploy the contract.
    const statusMessage = await root.devDeploy(
        './build/status-message.wasm',
    );
    
    // Init the contract
    await statusMessage.call(statusMessage, 'init', {});
    
    // Create test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, statusMessage, ali, bob, carl };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Root gets null status', async t => {
    const { statusMessage, root } = t.context.accounts;
    const result = await statusMessage.view('get_status', { account_id: root.accountId });
    t.is(result, null);
});

test('Ali sets then gets status', async t => {
    const { ali, statusMessage } = t.context.accounts;
    await ali.call(statusMessage, 'set_status', { message: 'hello' });

    t.is(
        await statusMessage.view('get_status', { account_id: ali.accountId }),
        'hello'
    );
});

test('Bob and Carl have different statuses', async t => {
    const { statusMessage, bob, carl } = t.context.accounts;
    await bob.call(statusMessage, 'set_status', { message: 'hello' });
    await carl.call(statusMessage, 'set_status', { message: 'world' });

    const bobStatus = await statusMessage.view('get_status', { account_id: bob.accountId });
    const carlStatus = await statusMessage.view('get_status', { account_id: carl.accountId });
    t.is(bobStatus, 'hello');
    t.is(carlStatus, 'world');
});

'''
'''--- examples/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ],
  "presets": ["@babel/preset-typescript"]
}

'''
'''--- examples/jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- examples/package.json ---
{
  "name": "standalone-examples",
  "version": "1.0.0",
  "description": "Status message example with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "postinstall": "cd .. && yarn link && cd examples && yarn link near-sdk-js",
    "build": "yarn build:clean-state && yarn build:counter && yarn build:counter-lowlevel && yarn build:counter-ts && yarn build:cross-contract-call && yarn build:fungible-token-lockable && yarn build:fungible-token && yarn build:non-fungible-token && yarn build:status-message-collections && yarn build:status-message && yarn build:parking-lot",
    "build:status-message": "near-sdk-js build src/status-message.js build/status-message.wasm",
    "build:clean-state": "near-sdk-js build src/clean-state.js build/clean-state.wasm",
    "build:counter": "near-sdk-js build src/counter.js build/counter.wasm",
    "build:counter-lowlevel": "near-sdk-js build src/counter-lowlevel.js build/counter-lowlevel.wasm",
    "build:counter-ts": "near-sdk-js build src/counter.ts build/counter-ts.wasm",
    "build:cross-contract-call": "near-sdk-js build src/status-message.js build/status-message.wasm && near-sdk-js build src/cross-contract-call.js build/cross-contract-call.wasm",
    "build:fungible-token-lockable": "near-sdk-js build src/fungible-token-lockable.js build/fungible-token-lockable.wasm",
    "build:fungible-token": "near-sdk-js build src/fungible-token.js build/fungible-token.wasm && near-sdk-js build src/fungible-token-helper.js build/fungible-token-helper.wasm",
    "build:non-fungible-token": "near-sdk-js build src/non-fungible-token-receiver.js build/non-fungible-token-receiver.wasm && near-sdk-js build src/non-fungible-token.js build/non-fungible-token.wasm",
    "build:status-message-collections": "near-sdk-js build src/status-message-collections.js build/status-message-collections.wasm",
    "build:parking-lot": "near-sdk-js build src/parking-lot.ts build/parking-lot.wasm",
    "test": "ava && yarn test:counter-lowlevel && yarn test:counter-ts",
    "test:status-message": "ava __tests__/test-status-message.ava.js",
    "test:clean-state": "ava __tests__/test-clean-state.ava.js",
    "test:counter": "ava __tests__/test-counter.ava.js",
    "test:counter-lowlevel": "COUNTER_LOWLEVEL=1 ava __tests__/test-counter.ava.js",
    "test:counter-ts": "COUNTER_TS=1 ava __tests__/test-counter.ava.js",
    "test:cross-contract-call": "ava __tests__/test-cross-contract-call.ava.js",
    "test:fungible-token-lockable": "ava __tests__/test-fungible-token-lockable.ava.js",
    "test:fungible-token": "ava __tests__/test-fungible-token.ava.js",
    "test:non-fungible-token": "ava __tests__/test-non-fungible-token.ava.js",
    "test:status-message-collections": "ava __tests__/test-status-message-collections.ava.js",
    "test:parking-lot": "ava __tests__/test-parking-lot.ava.js"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "Apache-2.0",
  "dependencies": {
    "lodash-es": "^4.17.21",
    "near-sdk-js": "file:../"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "3.1.0",
    "typescript": "^4.7.4"
  }
}

'''
'''--- examples/src/clean-state.js ---
import { NearContract, NearBindgen, call, view, near } from 'near-sdk-js'

@NearBindgen
class CleanState extends NearContract {
    @call
    clean({keys}) {
        keys.forEach(key => near.storageRemove(key))
    }

    @call
    put({key, value}) {
        near.storageWrite(key, value)
    }

    @view
    get({key}) {
        return near.storageRead(key)
    }
}

'''
'''--- examples/src/counter-lowlevel.js ---
// This contract implements exact same functionality as counter.js, but only use low level APIs
import {near} from 'near-sdk-js'

export function init() {
    let argsRaw = near.input()
    let args = JSON.parse(argsRaw || "{}")
    let initial = args.initial || 0
    let count = initial
    let state = JSON.stringify({count})
    near.storageWrite('STATE', state)
}

function deserialize() {
    let state = near.storageRead("STATE")
    if (state) {
        return JSON.parse(state)
    } else {
        throw new Error("Contract state is empty")
    }
}

export function getCount() {
    let state = deserialize()
    let count = state.count
    near.valueReturn(JSON.stringify(count))
}

export function increase() {
    let argsRaw = near.input()
    let args = JSON.parse(argsRaw || "{}")
    let n = args.n || 1
    let state = deserialize()
    state.count += n
    near.log(`Counter increased to ${state.count}`)
    near.storageWrite('STATE', JSON.stringify(state))
}

export function decrease() {
    let argsRaw = near.input()
    let args = JSON.parse(argsRaw || "{}")
    let n = args.n || 1
    let state = deserialize()
    state.count -= n
    near.log(`Counter decreased to ${state.count}`)
    near.storageWrite('STATE', JSON.stringify(state))
}

'''
'''--- examples/src/counter.js ---
import { NearContract, NearBindgen, near, call, view } from 'near-sdk-js'
import { isUndefined } from 'lodash-es'

@NearBindgen
class Counter extends NearContract {
    constructor({ initial = 0 }) {
        super()
        this.count = initial
    }

    @call
    increase({ n = 1 }) {
        this.count += n
        near.log(`Counter increased to ${this.count}`)
    }

    @call
    decrease({ n }) {
        // you can use default argument `n=1` too
        // this is to illustrate a npm dependency: lodash can be used
        if (isUndefined(n)) {
            this.count -= 1
        } else {
            this.count -= n
        }
        near.log(`Counter decreased to ${this.count}`)
    }

    @view
    getCount() {
        return this.count
    }
}

'''
'''--- examples/src/counter.ts ---
import { NearContract, NearBindgen, near, call, view } from 'near-sdk-js'
import { isUndefined } from 'lodash-es'
import { log } from './log'

@NearBindgen
class Counter extends NearContract {
    count: number;

    constructor({ initial = 0 }: {initial : number}) {
        super()
        this.count = initial
    }

    @call
    increase({ n = 1 }: {n: number}) {
        this.count += n
        near.log(`Counter increased to ${this.count}`)
    }

    @call
    decrease({ n }: {n: number}) {
        // you can use default argument `n=1` too
        // this is to illustrate a npm dependency: lodash can be used
        if (isUndefined(n)) {
            this.count -= 1
        } else {
            this.count -= n
        }
        // this is to illustrate import a local ts module
        log(`Counter decreased to ${this.count}`)
    }

    @view
    getCount(): number {
        return this.count
    }
}

'''
'''--- examples/src/cross-contract-call.js ---
import { NearContract, NearBindgen, call, view, near, bytes } from 'near-sdk-js'

@NearBindgen
class OnCall extends NearContract {
    constructor({ statusMessageContract }) {
        super()
        this.personOnCall = "undefined"
        this.statusMessageContract = statusMessageContract
    }

    @call
    set_person_on_call({ accountId }) {
        near.log(`Trying to set ${accountId} on-call`)
        const promise = near.promiseBatchCreate(this.statusMessageContract)
        near.promiseBatchActionFunctionCall(promise, 'get_status', bytes(JSON.stringify({ account_id: accountId })), 0, 30000000000000)
        near.promiseThen(promise, near.currentAccountId(), '_set_person_on_call_private', bytes(JSON.stringify({ accountId: accountId })), 0, 30000000000000);
    }

    @call
    _set_person_on_call_private({ accountId }) {
        near.log(`_set_person_on_call_private called, accountId ${accountId}`)
        if (near.currentAccountId() !== near.predecessorAccountId()) {
            near.panic('Function can be used as a callback only')
        }
        const status = JSON.parse(near.promiseResult(0))
        near.log(`${accountId} status is ${status}`)
        if (status === 'AVAILABLE') {
            this.personOnCall = accountId
            near.log(`${accountId} set on-call`)
        } else {
            near.log(`${accountId} can not be set on-call`)
        }
    }

    @view
    person_on_call() {
        near.log(`Returning person on-call: ${this.personOnCall}`)
        return this.personOnCall
    }
}

'''
'''--- examples/src/fungible-token-helper.js ---
import { NearContract, NearBindgen, call, view } from "near-sdk-js";

@NearBindgen
class FungibleTokenHelper extends NearContract {
    constructor() {
        super();
        this.data = "";
    }

    @call 
    ftOnTransfer({ senderId, amount, msg, receiverId }) {
        const concatString = `[${amount} from ${senderId} to ${receiverId}] ${msg} `;
        this.data = this.data.concat("", concatString);
    }

    @view 
    getContractData() {
        return this.data;
    }
}
'''
'''--- examples/src/fungible-token-lockable.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
    LookupMap,
    assert,
} from 'near-sdk-js'
import { Serializer } from 'superserial'

class Account {
    constructor(balance, allowances, lockedBalances) {
        this.balance = balance // Current unlocked balance
        this.allowances = allowances // Allowed account to the allowance amount
        this.lockedBalances = lockedBalances // Allowed account to locked balance
    }

    setAllowance(escrowAccountId, allowance) {
        if (allowance > 0) {
            this.allowances[escrowAccountId] = allowance
        } else if (allowance === 0) {
            delete this.allowances[escrowAccountId]
        } else {
            throw Error("Allowance can't be negative")
        }
    }

    getAllowance(escrowAccountId) {
        return this.allowances[escrowAccountId] || 0
    }

    setLockedBalance(escrowAccountId, lockedBalance) {
        if (lockedBalance > 0) {
            this.lockedBalances[escrowAccountId] = lockedBalance
        } else if (lockedBalance === 0) {
            delete this.lockedBalances[escrowAccountId]
        } else {
            throw Error("Locked balance cannot be negative")
        }
    }

    getLockedBalance(escrowAccountId) {
        return this.lockedBalances[escrowAccountId] || 0
    }

    totalBalance() {
        let totalLockedBalance =
            Object.values(this.lockedBalances).reduce((acc, val) => acc + val, 0)
        return this.balance + totalLockedBalance
    }
}

@NearBindgen
class LockableFungibleToken extends NearContract {
    constructor({ prefix, totalSupply }) {
        super()
        this.accounts = new LookupMap(prefix, {Account}) // Account ID -> Account mapping
        this.totalSupply = totalSupply // Total supply of the all tokens
        let ownerId = near.signerAccountId()
        let ownerAccount = this.getAccount(ownerId)
        ownerAccount.balance = totalSupply
        this.setAccount(ownerId, ownerAccount)
    }

    deserialize() {
        super.deserialize()
        this.accounts.serializer = new Serializer({classes: {Account}});
        this.accounts = Object.assign(new LookupMap, this.accounts)
    }

    getAccount(ownerId) {
        let account = this.accounts.get(ownerId)
        if (account === null) {
            return new Account(0, {}, {})
        }
        return account
    }

    setAccount(accountId, account) {
        this.accounts.set(accountId, account)
    }

    @call
    setAllowance({ escrowAccountId, allowance }) {
        let ownerId = near.predecessorAccountId()
        if (escrowAccountId === ownerId) {
            throw Error("Can't set allowance for yourself")
        }
        let account = this.getAccount(ownerId)
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        if (lockedBalance > allowance) {
            throw Error("The new allowance can't be less than the amount of locked tokens")
        }

        account.setAllowance(escrowAccountId, allowance - lockedBalance)
        this.setAccount(ownerId, account)
    }

    @call
    lock({ ownerId, lockAmount }) {
        if (lockAmount <= 0) {
            throw Error("Can't lock 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating unlocked balance
        if (account.balance < lockAmount) {
            throw Error("Not enough unlocked balance")
        }
        account.balance -= lockAmount

        // If locking by escrow, need to check and update the allowance.
        if (escrowAccountId !== ownerId) {
            let allowance = account.getAllowance(escrowAccountId)
            if (allowance < lockAmount) {
                throw Error("Not enough allowance")
            }
            account.setAllowance(escrowAccountId, allowance - lockAmount)
        }

        // Updating total lock balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        account.setLockedBalance(escrowAccountId, lockedBalance + lockAmount)

        this.setAccount(ownerId, account)
    }

    @call
    unlock({ ownerId, unlockAmount }) {
        if (unlockAmount <= 0) {
            throw Error("Can't unlock 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating locked balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        if (lockedBalance < unlockAmount) {
            throw Error("Not enough locked tokens")
        }
        account.setLockedBalance(escrowAccountId, lockedBalance - unlockAmount)

        // If unlocking by escrow, need to update allowance.
        if (escrowAccountId !== ownerId) {
            let allowance = account.getAllowance(escrowAccountId)
            account.setAllowance(escrowAccountId, allowance + unlockAmount)
        }

        // Updating unlocked balance
        account.balance += unlockAmount

        this.setAccount(ownerId, account)
    }

    @call
    transferFrom({ ownerId, newOwnerId, amount }) {
        if (amount <= 0) {
            throw Error("Can't transfer 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating locked balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        var remainingAmount
        if (lockedBalance >= amount) {
            account.setLockedBalance(escrowAccountId, lockedBalance - amount)
            remainingAmount = 0
        } else {
            account.setLockedBalance(escrowAccountId, 0)
            remainingAmount = amount - lockedBalance
        }

        // If there is remaining balance after the locked balance, we try to use unlocked tokens.
        if (remainingAmount > 0) {
            // Checking and updating unlocked balance
            if (account.balance < remainingAmount) {
                throw Error("Not enough unlocked balance")
            }
            account.balance -= remainingAmount

            // If transferring by escrow, need to check and update allowance.
            if (escrowAccountId !== ownerId) {
                let allowance = account.getAllowance(escrowAccountId)
                // Checking and updating unlocked balance
                if (allowance < remainingAmount) {
                    throw Error("Not enough allowance")
                }
                account.setAllowance(escrowAccountId, allowance - remainingAmount)
            }
        }

        this.setAccount(ownerId, account)

        // Deposit amount to the new owner
        let newAccount = this.getAccount(newOwnerId)
        newAccount.balance += amount
        this.setAccount(newOwnerId, newAccount)
    }

    @call
    transfer({ newOwnerId, amount }) {
        this.transferFrom({ ownerId: near.predecessorAccountId(), newOwnerId, amount })
    }

    @view
    getTotalSupply() {
        return this.totalSupply
    }

    @view
    getTotalBalance({ ownerId }) {
        return this.getAccount(ownerId).totalBalance()
    }

    @view
    getUnlockedBalance({ ownerId }) {
        return this.getAccount(ownerId).balance
    }

    @view
    getAllowance({ ownerId, escrowAccountId }) {
        return this.getAccount(ownerId).getAllowance(escrowAccountId)
    }

    @view
    getLockedBalance({ ownerId, escrowAccountId }) {
        return this.getAccount(ownerId).getLockedBalance(escrowAccountId)
    }
}

'''
'''--- examples/src/fungible-token.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
    LookupMap,
    assert
} from 'near-sdk-js'
import { Serializer } from 'superserial'

@NearBindgen
class FungibleToken extends NearContract {
    constructor({ prefix, totalSupply }) {
        super()
        this.accounts = new LookupMap(prefix)
        this.totalSupply = totalSupply
        this.accounts.set(near.signerAccountId(), totalSupply)
        // don't need accountStorageUsage like rust in JS contract, storage deposit management is automatic in JSVM
    }

    deserialize() {
        super.deserialize()
        this.accounts.serializer = new Serializer()
        this.accounts = Object.assign(new LookupMap, this.accounts)
    }

    internalDeposit({ accountId, amount }) {
        let balance = this.accounts.get(accountId) || '0'
        let newBalance = BigInt(balance) + BigInt(amount)
        this.accounts.set(accountId, newBalance.toString())
        this.totalSupply = (BigInt(this.totalSupply) + BigInt(amount)).toString()
    }

    internalWithdraw({ accountId, amount }) {
        let balance = this.accounts.get(accountId) || '0'
        let newBalance = BigInt(balance) - BigInt(amount)
        assert(newBalance >= 0n, "The account doesn't have enough balance")
        this.accounts.set(accountId, newBalance.toString())
        let newSupply = BigInt(this.totalSupply) - BigInt(amount)
        assert(newSupply >= 0n, "Total supply overflow")
        this.totalSupply = newSupply.toString()
    }

    internalTransfer({ senderId, receiverId, amount, memo }) {
        assert(senderId != receiverId, "Sender and receiver should be different")
        let amountInt = BigInt(amount)
        assert(amountInt > 0n, "The amount should be a positive number")
        this.internalWithdraw({ accountId: senderId, amount })
        this.internalDeposit({ accountId: receiverId, amount })
    }

    @call
    ftTransfer({ receiverId, amount, memo }) {
        let senderId = near.predecessorAccountId()
        this.internalTransfer({ senderId, receiverId, amount, memo })
    }

    @call
    ftTransferCall({ receiverId, amount, memo, msg }) {
        let senderId = near.predecessorAccountId()
        this.internalTransfer({ senderId, receiverId, amount, memo });
        const promise = near.promiseBatchCreate(receiverId);
        const params = { senderId: senderId, amount: amount, msg: msg, receiverId: receiverId };
        near.promiseBatchActionFunctionCall(promise, 'ftOnTransfer', JSON.stringify(params), 0, 30000000000000);        
        return near.promiseReturn();
    }

    @view
    ftTotalSupply() {
        return this.totalSupply
    }

    @view
    ftBalanceOf({ accountId }) {
        return this.accounts.get(accountId) || '0'
    }
}

'''
'''--- examples/src/log.ts ---
import {near} from 'near-sdk-js'

export function log(msg: any) {
    near.log(msg)
}
'''
'''--- examples/src/non-fungible-token-receiver.js ---
import { NearContract, NearBindgen, call, near, assert } from 'near-sdk-js'

@NearBindgen
class NftContract extends NearContract {
    constructor({ nonFungibleTokenAccountId }) {
        super()
        this.nonFungibleTokenAccountId = nonFungibleTokenAccountId
    }

    @call
    nftOnTransfer({ senderId, previousOwnerId, tokenId, msg }) {
        near.log(`nftOnTransfer called, params: senderId: ${senderId}, previousOwnerId: ${previousOwnerId}, tokenId: ${tokenId}, msg: ${msg}`)
        assert(
            near.predecessorAccountId() === this.nonFungibleTokenAccountId,
            "Only supports the one non-fungible token contract"
        )
        if (msg === "return-it-now") {
            near.log(`Returning ${tokenId} to ${senderId}`)
            return false
        } else if (msg === "keep-it-now") {
            near.log(`Keep ${tokenId}`)
            return true
        } else {
            throw Error("unsupported msg")
        }
    }
}

'''
'''--- examples/src/non-fungible-token.js ---
import { NearContract, NearBindgen, call, view, near, LookupMap, bytes, assert } from 'near-sdk-js'
import { Serializer } from 'superserial';

class Token {
    constructor(token_id, owner_id) {
        this.token_id = token_id;
        this.owner_id = owner_id;
    }
}

@NearBindgen
class NftContract extends NearContract {
    constructor({ owner_id, owner_by_id_prefix }) {
        super()
        this.owner_id = owner_id
        this.owner_by_id = new LookupMap(owner_by_id_prefix)
    }

    deserialize() {
        super.deserialize()
        this.owner_by_id.serializer = new Serializer()
        this.owner_by_id = Object.assign(new LookupMap, this.owner_by_id)
    }

    internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo }) {
        let owner_id = this.owner_by_id.get(token_id)

        assert(owner_id !== null, "Token not found")
        assert(sender_id === owner_id, "Sender must be the current owner")
        assert(owner_id !== receiver_id, "Current and next owner must differ")

        this.owner_by_id.set(token_id, receiver_id)

        return owner_id
    }

    @call
    nftTransfer({ receiver_id, token_id, approval_id, memo }) {
        let sender_id = near.predecessorAccountId()
        this.internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo })
    }

    @call
    nftTransferCall({ receiver_id, token_id, approval_id, memo, msg }) {
        near.log(`nftTransferCall called, receiver_id ${receiver_id}, token_id ${token_id}`)
        let sender_id = near.predecessorAccountId()
        let old_owner_id = this.internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo })

        const promise = near.promiseBatchCreate(receiver_id)
        near.promiseBatchActionFunctionCall(promise, 'nftOnTransfer', bytes(JSON.stringify({ senderId: sender_id, previousOwnerId: old_owner_id, tokenId: token_id, msg: msg })), 0, 30000000000000)
        near.promiseThen(promise, near.currentAccountId(), '_nftResolveTransfer', bytes(JSON.stringify({ sender_id, receiver_id, token_id })), 0, 30000000000000);
    }

    @call
    _nftResolveTransfer({ sender_id, receiver_id, token_id }) {
        near.log(`_nftResolveTransfer called, receiver_id ${receiver_id}, token_id ${token_id}`)
        if (near.currentAccountId() == !near.predecessorAccountId()) {
            near.panic('Function can be used as a callback only')
        }
        const isTokenTransfered = JSON.parse(near.promiseResult(0))
        near.log(`${token_id} ${isTokenTransfered ? 'was transfered' : 'was NOT transfered'}`)

        if (!isTokenTransfered) {
            near.log(`Returning ${token_id} to ${receiver_id}`)
            const currentOwner = this.owner_by_id.get(token_id)
            if (currentOwner === receiver_id) {
                this.internalTransfer({ sender_id: receiver_id, receiver_id: sender_id, token_id: token_id, approval_id: null, memo: null })
                near.log(`${token_id} returned to ${sender_id}`)
                return
            }
            near.log(`Failed to return ${token_id}. It was burned or not owned by ${receiver_id} now.`)
        }
    }

    @call
    nftMint({ token_id, token_owner_id, token_metadata }) {
        let sender_id = near.predecessorAccountId()
        assert(sender_id === this.owner_id, "Unauthorized")
        assert(this.owner_by_id.get(token_id) === null, "Token ID must be unique")

        this.owner_by_id.set(token_id, token_owner_id)

        return new Token(token_id, token_owner_id)
    }

    @view
    nftToken({ token_id }) {
        let owner_id = this.owner_by_id.get(token_id)
        if (owner_id === null) {
            return null
        }

        return new Token(token_id, owner_id)
    }
}

'''
'''--- examples/src/parking-lot.ts ---
import { NearContract, NearBindgen, near, call, view, LookupMap } from 'near-sdk-js'

class CarSpecs {
    id: number;
    color: string;
    price: number;
    engine: Engine;

    constructor(id: number, color: string, price: number, engine: Engine) {
        this.id = id;
        this.color = color;
        this.price = price;
        this.engine = engine;
    }
}

class Engine {
    hp: number;

    constructor(hp: number) {
      this.hp = hp;
    }

    run(): string {
        if (this.hp > 400) {
            return "boom"
        } else {
            return "zoom"
        }
    }
}

@NearBindgen
class ParkingLot extends NearContract {
    cars: LookupMap<string, CarSpecs>;
    constructor() {
        super()
        this.cars = new LookupMap<string, CarSpecs>('a', {CarSpecs, Engine});
    }

    deserialize() {
        super.deserialize();
        this.cars = new LookupMap<string, CarSpecs>('a', {CarSpecs, Engine});
    }

    @call
    addCar({ name, id, color, price, engineHp }: { name: string, id: number, color: string, price: number, engineHp: number }) {
    // args can be json arguments only, they cannot be of a JS/TS class like following, unless override NearContract.deserializeArgs method.
    // addCar({ name, specs }: { name: string, specs: CarSpecs }) {
        let engine = new Engine(engineHp)
        let car = new CarSpecs(id, color, price, engine);
        near.log(`addCar() called, name: ${name}, specs: ${JSON.stringify(car)}`)
        this.cars.set(name, car)
    }

    @call
    removeCar({ name }: { name: string }) {
        near.log(`removeCar() called, name: ${name}`)
        this.cars.remove(name)
    }

    @view
    getCarSpecs({ name }: { name: string }) {
        near.log(`getCarSpecs() called, name: ${name}`)
        return this.cars.get(name)
    }

    @view
    runCar({name}: {name: string}) {
        let car = this.cars.get(name)
        return car.engine.run()
    }
}
'''
'''--- examples/src/status-message-collections.js ---
import { NearContract, NearBindgen, call, view, near, LookupSet, UnorderedMap, Vector } from 'near-sdk-js'
import { Serializer } from 'superserial'

@NearBindgen
class StatusMessage extends NearContract {
    constructor() {
        super()
        this.records = new UnorderedMap('a')
        this.uniqueValues = new LookupSet('b')
    }

    deserialize() {
        super.deserialize()
        this.records.keys.serializer = new Serializer()
        this.records.keys = Object.assign(new Vector, this.records.keys)
        this.records.values.serializer = new Serializer()
        this.records.values = Object.assign(new Vector, this.records.values)
        this.records.serializer = new Serializer()
        this.records = Object.assign(new UnorderedMap, this.records)
        this.uniqueValues.serializer = new Serializer()
        this.uniqueValues = Object.assign(new LookupSet, this.uniqueValues)
    }

    @call
    set_status({ message }) {
        let account_id = near.signerAccountId()
        near.log(`${account_id} set_status with message ${message}`)
        this.records.set(account_id, message)
        this.uniqueValues.set(message)
    }

    @view
    get_status({ account_id }) {
        near.log(`get_status for account_id ${account_id}`)
        return this.records.get(account_id)
    }

    @view
    has_status({ message }) {
        // used for test LookupMap
        return this.uniqueValues.contains(message)
    }

    @view
    get_all_statuses() {
        // used for test UnorderedMap
        return this.records.toArray()
    }
}

'''
'''--- examples/src/status-message.js ---
import { NearContract, NearBindgen, call, view, near } from 'near-sdk-js'

@NearBindgen
class StatusMessage extends NearContract {
    constructor() {
        super()
        this.records = {}
    }

    @call
    set_status({ message }) {
        let account_id = near.signerAccountId()
        near.log(`${account_id} set_status with message ${message}`)
        this.records[account_id] = message
    }

    @view
    get_status({ account_id }) {
        near.log(`get_status for account_id ${account_id}`)
        return this.records[account_id] || null
    }
}

'''
'''--- examples/tsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "target": "es5",
        "noEmit": true
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- jsvm/README.md ---
# NEAR-SDK-JS (Enclave)

## Getting started with template project

The fastest and recommended way to develop with near-sdk-js is to create a project with our github template: https://github.com/near/near-sdk-js-template-project.

## Running examples

There are a couple of contract examples in the project:

- [Clean contract state](https://github.com/near/near-sdk-js/tree/master/examples/clean-state)
- [Doing cross contract call](https://github.com/near/near-sdk-js/tree/master/examples/cross-contract-call)
- [Fungible token](https://github.com/near/near-sdk-js/tree/master/examples/fungible-token)
- [Lockable fungible token](https://github.com/near/near-sdk-js/tree/master/examples/lockable-fungible-token)
- [Non fungible token](https://github.com/near/near-sdk-js/tree/master/examples/non-fungible-token)
- [Status message board](https://github.com/near/near-sdk-js/tree/master/examples/status-message)

The general steps to run these contracts are same. You can also follow their corresponding READMEs to build, test and run the contracts.

### General steps to run examples locally
1. Use near-cli to deploy `jsvm.wasm` from the `jsvm/build` folder to one of account you controlled. For example, `jsvm.<your-account>`:
```sh
export NEAR_ENV=local
near deploy <jsvm-account> jsvm/build/jsvm.wasm
```
2. `cd examples/<example>`
3. `yarn && yarn build` to get <contract>.base64 file (JS smart-contract).
4. Deploy <contract>.base64 file to `JSVM` account from the previous step.
```sh
near js deploy --accountId <your-account> --base64File build/<contract-name>.base64 --deposit 0.1 --jsvm <jsvm-account>
```

5. Interact with your contract using NEAR CLI or `near-api-js`. Encode the parameters and call. If the call cause the state increasement, you also need to attach NEAR to cover the storage deposit for the delta.

```sh
near js call <account-that-deployed-js-contract-to-jsvm> <method-name> --accountId <account-performing-call> --args <args> --deposit 0.1 --jsvm <jsvm-account>
```

6. If you want to remove the js contract and withdraw the storage deposit, use:

```sh
near js remove --accountId <your-account> --jsvm <jsvm-account>
```

### General steps to run examples on testnet
1. `export NEAR_ENV=testnet`
2. `cd examples/<example>`
3. `yarn && yarn build` to get <contract>.base64 file (JS smart-contract).
4. Deploy, call and remove JS contract is same as above, except <jsvm-account> is `jsvm.testnet`. This is also the default value, so you omit `--jsvm`.

## Error Handling in NEAR-SDK-JS

If you want to indicate an error happened and fail the transaction, just throw an error object in JavaScript. Our JSVM runtime will detect and automatically invoke `panic_utf8` with `"{error.message}\n:{error.stack}"`. As a result, transaction will fail with `"Smart contract panicked: {error.message}\n{error.stack}"` error message. You can also use an error utilities library to organize your errors, such as verror.

When your JS code or library throws an error, uncaught, the transaction will also fail with GuestPanic error, with the error message and stacktrace.

When call host function with inappropriate type, means incorrect number of arguments or arg is not expected type:
    - if arguments less than params, remaining argument are set as 'undefined'
    - if arguments more than params, remaining argument are ignored
    - if argument is different than the required type, it'll be coerced to required type
    - if argument is different than the required type but cannot be coerced, will throw runtime type error, also with message and stacktrace

## Test
We recommend to use near-workspaces to write tests for your smart contracts. See any of the examples for how tests are setup and written.

## NEAR-SDK-JS API Reference

All NEAR blockchain provided functionality (host functions) are defined in `src/api.js` and exported as `near`. You can use them by:
```js
import {near} from 'near-sdk-js'

// near.<api doucmented below>. e.g.:
let signer = near.signerAccountId()
```

To use nightly host functions, such as `altBn128G1Sum`, the enclave contract need to be built with `make jsvm-nightly` and deployed to a nearcore node that has nightly enabled.

### About Type

- In arguments, `Uint64: Number | BigInt`. In return, `Uint64: BigInt`. Because JavaScript Number cannot hold all Uint64 without losing precision. But as arguments, interger number is also allowed for convinience. Same for `Uint128`.
- `Bytes` in both arguments and return represent a byte buffer, internally it's a JavaScript String Object. Any binary data `0x00-0xff` is stored as the char '\x00-\xff'. This is because QuickJS doesn't have ArrayBuffer in C API. If the bytes happens to have only 1-byte chars, it happens to be same as the the same content string.

### Context API

```
function signerAccountId(): String;
function signerAccountPk(): String;
function predecessorAccountId(): String;
function blockIndex(): Uint64;
function blockHeight(): Uint64;
function blockTimestamp(): Uint64;
function epochHeight(): Uint64;
```

### Economics API
```
function attachedDeposit(): Uint128;
function prepaidGas(): Uint64;
function usedGas(): Uint64;
```

### Math API

```
function randomSeed(): Bytes;
function sha256(value: Bytes): Bytes;
function keccak256(value: Bytes): Bytes;
function keccak512(value: Bytes): Bytes;
function ripemd160(value: Bytes): Bytes;
function ecrecover(hash: Bytes, sign: Bytes, v: Uint64, malleability_flag: Uint64): Bytes | null;
```

### Miscellaneous API

```
function panic(msg?: String);
function panicUtf8(msg: Bytes);
function log(msg: String);
function logUtf8(msg: Bytes);
function logUtf16(msg: Bytes);
```

### Storage API

```
function storageRead(key: Bytes): Bytes | null;
function storageHasKey(key: Bytes): bool;
```

### Validator API

```
function validatorStake(account_id: String): Uint128;
function validatorTotalStake(): Uint128;
```

### Alt BN128

```
function altBn128G1Multiexp(value: Bytes): Bytes;
function altBn128G1Sum(value: Bytes): Bytes;
function altBn128PairingCheck(value: Bytes): bool;
```

### JSVM Specific APIs
Due to the design of JavaScript VM Contract, some additonal APIs are provided to obtain context, access storage and cross contract call. Since they're not documented at [NEAR nomicon](https://nomicon.io/). They're explained here.

#### Obtain Context
```
function jsvmAccountId(): String;
function jsvmJsContractName(): String;
function jsvmMethodName(): String;
function jsvmArgs(): Bytes;
```

The `jsvmAccountId` returns the JavaScript VM's contract account ID.

The `jsvmJsContractName`, when called, returns the JavaScript contract name that are called at the moment.

The `jsvmJsContractName` returns the method name being called.

The `jsvmArgs` return the arguments passed to the method.

#### Storage Access
```
function jsvmStorageWrite(key: Bytes, value: Bytes): bool;
function jsvmStorageRead(key: Bytes): Bytes | null;
function jsvmStorageRemove(key: Bytes): bool;
function jsvmStorageHasKey(key: Bytes): bool;
function storageGetEvicted(): Bytes;
```

These are equivalent to `storage*` but access limit to the substate of current JS contract. The `jsvmStorageWrite` and `jsvmStorageRemove` require and refund deposit to cover the storage delta. `jsvmStorage*` access the substate of current JS contract by prefix the key of current JS contract name (deployer's account id). You can use `storageRead` and `storageHasKey` to get code and state of other JS contracts. More specifically: code of `contractA` is stored under the key `contractA/code`. state of `contractA` is stored under `contractA/state/` concat with developer specifid key. And:
```
jsvmStorageRead(k)
// equvalent to
storageRead(jsvmJsContractName() + '/state/' + k)
```

When `jsvmStorageWrite` write to a key that already exists, the old value would be saved and can be obtained by `storageGetEvicted()`. In this case, jsvmStorageWrite returns `true`. If key doesn't exist before, returns `false`.

When `jsvmStroageRemove` remove a key that exists, the old value would be saved and can be obtained by `storageGetEvicted()`. In this case, jsvmStroageRemove returns `true`. If key doesn't exist before, nothing is removed and returns `false`.

#### Cross Contract Call
```
function jsvmValueReturn(value: Bytes);
function jsvmCall(contract_name: String, method: String, args: Bytes): any;
function jsvmCallRaw(contract_name: String, method: String, args: Bytes): Bytes;
```

The `jsvmValueReturn` is the version of `valueReturn` that should be used in all JavaScript contracts. It play well with `jsvmCall`.

The `jsvmCall` invoke a synchronous cross contract call, to the given JavaScript `contract_name`, `method` with `args`. And returned the return value parsed as JSON into a JS object.

The `jsvmCallRaw` is similar to `jsvmCall`, but return the raw, unparsed Bytes.

### Collections
A few useful on-chain persistent collections are provided. All keys, values and elements are of type `Bytes`.

#### Vector
Vector is an iterable implementation of vector that stores its content on the trie. Usage:

```js
import {Vector} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.v = new Vector('my_prefix_')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.v = Object.assign(new Vector, this.v)
}

someMethod() {
    // insert
    this.v.push('abc')
    this.v.push('def')
    this.v.push('ghi')

    // batch insert, extend:
    this.v.extend(['xyz', '123'])

    // get
    let first = this.v.get(0)

    // remove, move the last element to the given index
    this.v.swapRemove(0) 

    // replace
    this.v.replace(1, 'jkl')

    // remove the last
    this.v.pop()

    // len, isEmpty
    let len = this.v.len()
    let isEmpty = this.v.isEnpty()

    // iterate
    for (let element of this.v) {
        near.log(element)
    }

    // toArray, convert to JavaScript Array
    let a = this.v.toArray()

    // clear
    ths.v.clear()
}
```

#### LookupMap
LookupMap is an non-iterable implementation of a map that stores its content directly on the trie. It's like a big hash map, but on trie. Usage:
```js
import {LookupMap} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.m = new LookupMap('prefix_a')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.m = Object.assign(new LookupMap, this.m)
}

someMethod() {
    // insert
    this.m.set('abc', 'aaa')
    this.m.set('def', 'bbb')
    this.m.set('ghi', 'ccc')

    // batch insert, extend:
    this.m.extend([['xyz', '123'], ['key2', 'value2']])

    // check exist
    let exist = this.m.containsKey('abc')

    // get
    let value = this.m.get('abc')

    // remove
    this.m.remove('def') 

    // replace
    this.m.set('ghi', 'ddd')
}
```

#### LookupSet
LookupSet is an non-iterable implementation of a set that stores its content directly on the trie. It's like LookupMap, but it only stores whether the value presents. Usage:
```js
import {LookupSet} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.s = new LookupSet('prefix_b')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.s = Object.assign(new LookupSet, this.s)
}

someMethod() {
    // insert
    this.s.set('abc')
    this.s.set('def')
    this.s.set('ghi')

    // batch insert, extend:
    this.s.extend(['xyz', '123'])

    // check exist
    let exist = this.s.contains('abc')

    // remove
    this.s.remove('def')
}
```

#### UnorderedMap
UnorderedMap is an iterable implementation of a map that stores its content directly on the trie. Usage:
```js
import {UnorderedMap} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.m = new UnorderedMap('prefix_c')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.m.keys = Object.assign(new Vector, this.m.keys)
    this.m.values = Object.assign(new Vector, this.m.values)
    this.m = Object.assign(new UnorderedMap, this.m)
}

someMethod() {
    // insert
    this.m.set('abc', 'aaa')
    this.m.set('def', 'bbb')
    this.m.set('ghi', 'ccc')

    // batch insert, extend:
    this.m.extend([['xyz', '123'], ['key2', 'value2']])

    // get
    let value = this.m.get('abc')

    // remove
    this.m.remove('def') 

    // replace
    this.m.set('ghi', 'ddd')

    // len, isEmpty
    let len = this.m.len()
    let isEmpty = this.m.isEnpty()

    // iterate
    for (let [k, v] of this.m) {
        near.log(k+v)
    }

    // toArray, convert to JavaScript Array
    let a = this.m.toArray()

    // clear
    this.m.clear()
}
```

#### UnorderedSet
UnorderedSet is an iterable implementation of a set that stores its content directly on the trie. It's like UnorderedMap but it only stores whether the value presents. Usage:
```js
import {UnorderedSet} from 'near-sdk-js'

// in contract class constructor:
constructor() {
    super()
    this.s = new UnorderedSet('prefix_d')
}

// Override the deserializer to load vector from chain
deserialize() {
    super.deserialize()
    this.s.elements = Object.assign(new Vector, this.s.elements)
    this.s = Object.assign(new UnorderedSet, this.s)
}

someMethod() {
    // insert
    this.s.set('abc')
    this.s.set('def')
    this.s.set('ghi')

    // batch insert, extend:
    this.s.extend(['xyz', '123'])

    // check exist
    let exist = this.s.contains('abc')

    // remove
    this.s.remove('def')

    // len, isEmpty
    let len = this.s.len()
    let isEmpty = this.s.isEnpty()

    // iterate
    for (let e of this.s) {
        near.log(e)
    }

    // toArray, convert to JavaScript Array
    let a = this.s.toArray()

    // clear
    this.s.clear()
}
```

### APIs not available in JSVM
Due to the architecture of the JSVM, some NEAR host functions, part of Standalone SDK or Rust SDK, are not revelant or being replaced by above JSVM specific APIs. Those unavailable APIs are explained here.

- The `current_account_id` would always puts the account id of the JavaScript VM contract account in given register. The naming `current_account_id` is therefore confusing and not as helpful as a Rust contract. In some case, developer may want to get JavaScript VM contract account name, for example, determines whether it's running on testnet or mainnet, and behaves differently. So we expose this functionality under `jsvm_account_id()`.

- The `input` puts the argument passed to call the contract in given register. In JavaScript VM, this is encoded as `"js_contract_name\0method_name\0args...`. This format isn't very convinient to developer, therefore, separate API `jsvm_js_contract_name`, `jsvm_method_name` and `jsvm_args` are provided.

- The `storage_usage` return the storage bytes used by JavaScript VM contract. User doesn't care about the storage usage of the JSVM. Instead, users care about storage usage of a given JavaScript contract. This can be obtained by `storage_read` and count the sum of `register_len`.

- The `account_balance` and `account_locked_balance` returns balance and locked_balance of JavaScript VM. Those are also not cared by users.

- The `value_return` is a NEAR primitive that puts the value to return in a receipt. However we would want to access it as a JavaScript return value in a cross contract call. So we have a new API `jsvmValueReturn`, which does return the value in receipt and also as a JavaScript value returned by `jsvm_call`. The `jsvmValueReturn` should be used whenever you need `value_return`.

- `abort` is intended to mark error location (line number). A full stacktrace with line numbers is provided by QuickJS, available when you throw a JS Error. So this API isn't needed.

- Promise APIs act on the JSVM contract and could create subaccount, use the balance from JSVM account.JSVM would be a common VM used by the community instead of a Rust contract owned by the deployer. Therefore, promise APIs are not allowed.

- The `storage_write` and `storage_remove` have access to all JavaScript contract codes and states deployed on JSVM. User can only write to their account owned code and state, as a substate of the JSVM. Therefor these two APIs are disallowed. Use `jsvm_storage_write` and `jsvm_storage_remove` instead. Read to other people owned code and state is allowed, as they're public as part of the blockchain anyway.

## Advanced guides

### Manual setup with npm package

You can also layout your project by install the npm package manually:
```
yarn add near-sdk-js
# or
npm install near-sdk-js
```

### NEAR-SDK-JS contributor setup

It is tested on Ubuntu 20.04, Intel Mac and M1 Mac. Other linux should also work but they're not tested.

1. Make sure you have `wget`, `make`, `cmake` and `nodejs`. On Linux, also make sure you have `gcc`.
2. Run `make` to get platform specific `qjsc` and `jsvm` contract in `jsvm/build` folder.

### Run NEAR-SDK-JS tests
See https://github.com/near/near-sdk-js/tree/master/tests

### Low level way to invoke NEAR-CLI

`near js` subcommand in near-cli is a recent feature. Under the hood, it is encoding a special function call to jsvm contract. 

#### Deploy a JS contract

<details>
<summary><strong>The equivalent raw command is:</strong></summary>
<p>

    near call <jsvm-account> deploy_js_contract --accountId <your-account> --args $(cat <contract-name>.base64) --base64 --deposit 0.1

</p>
</details>

#### Call a JS contract

<details>
<summary><strong>The equivalent raw command is:</strong></summary>
<p>

    near call <jsvm-account> call_js_contract --accountId <your-account> --args <encoded-args> --base64

    # where `<encoded-args>` can be obtained by:
    node scripts/encode_call.js <your-account> <method-name> <args>

</p>
</details>

#### Remove a JS contract

<details>
<summary><strong>The equivalent raw command is:</strong></summary>
<p>

    near call <jsvm-account> remove_js_contract --accountId <your-account>

</p>
</details>

'''
'''--- jsvm/build.sh ---
#!/bin/bash
set -euo pipefail

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
WASI_SDK_PATH=${SCRIPT_DIR}/../vendor/wasi-sdk-11.0
CC="${WASI_SDK_PATH}/bin/clang --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot"
QUICKJS_SRC_DIR=${SCRIPT_DIR}/../quickjs
WASI_STUB=${SCRIPT_DIR}/../vendor/binaryen/wasi-stub/run.sh
TARGET_NAME=jsvm

DEFS='-D_GNU_SOURCE -DCONFIG_VERSION="2021-03-27" -DCONFIG_BIGNUM'
set +u
if [[ -n "${NEAR_NIGHTLY}" ]]; then
  DEFS+=' -DNIGHTLY'
  TARGET_NAME+='_nightly'
fi
if [[ -n "${NEAR_SANDBOX}" ]]; then
  DEFS+=' -DSANDBOX'
  TARGET_NAME+='_sandbox'
fi
set -u
TARGET_NAME+='.wasm'

INCLUDES="-I${QUICKJS_SRC_DIR} -I."
LIBS='-lm'
QUICKJS_SOURCES=(quickjs.c libregexp.c libunicode.c cutils.c quickjs-libc-min.c libbf.c)
SOURCES="${SCRIPT_DIR}/jsvm.c"

for i in "${QUICKJS_SOURCES[@]}"; do 
  SOURCES="${SOURCES} ${QUICKJS_SRC_DIR}/${i}"
done

$CC --target=wasm32-wasi \
    -nostartfiles -Oz -flto \
    ${DEFS} ${INCLUDES} ${SOURCES} ${LIBS} \
    -Wl,--no-entry \
    -Wl,--allow-undefined \
    -Wl,-z,stack-size=$[256 * 1024] \
    -Wl,--lto-O3 \
    -o ${TARGET_NAME}

${WASI_STUB} ${TARGET_NAME} >/dev/null

mkdir -p build
mv ${TARGET_NAME} build
'''
'''--- jsvm/examples/README-CLEAN-STATE.md ---
# Clean state contract in JavaScript

This is an equivalent JavaScript implementation of the clean state example. 

## Build the contract

First ensure JSVM contract is build and deployed locally, follow [Local Installation](https://github.com/near/near-sdk-js#local-installation). Then run:
```
npm i
npm run build
```

## Test the contract with workspaces-js
```
npm run test
```

## Guide on how to clean arbitrary account's state

First, build the contract as described above and deploy it to the account which state you want to clean up (this will override the contract that is currently there, but you can then re-deploy the original contract after the cleanup is done). Assuming that you are using JSVM contract deployed to `jsvm.testnet`, run the following command:

```
near call jsvm.testnet deploy_js_contract --accountId account-to-cleanup.testnet --args $(cat build/contract.base64) --base64 --deposit 0.1
```

Now, you can call the `clean` method to delete the unwanted keys:

```
near call jsvm.testnet call_js_contract --accountId account-to-cleanup.testnet --base64 --args $(node encode_call.js account-to-cleanup.testnet clean '[["key1", "key2"]]') --deposit 0.1
```

If gas limit prevents you from deleting all keys you want at once, just split the array into multiple parts and make a few subsequent `clean` calls.

Once you are done, just de-deploy the original contract and you should be all set:

```
near call jsvm.testnet deploy_js_contract --accountId account-to-cleanup.testnet --args $(cat path-to-original-contract.base64) --base64 --deposit 0.1
```

'''
'''--- jsvm/examples/README-COUNTER.md ---
# NEAR-SDK-JS template project

This is a template project. It implements a counter. You can copy this folder to start writing your first contract.

# Build the contract

```
npm i
npm run build
```

# Run tests
```
npm run test
```

'''
'''--- jsvm/examples/README-CROSS-CONTRACT-CALL.md ---
# Enclaved cross-contract-call in JavaScript

This example demonstrates how you can make a cross-contract call (contract call that is made from inside of the contract). Here we have 2 smart contracts: `status_message` from `../status-message` example and `on-call` contract in `src`. When somebody is trying to set a person on-call, smart-contract will check if the person is `AVAILABLE`. A person's status is in control of the person itself.

A good place to start is the integration test stored in `__tests__/` folder.

## Build the contract

First ensure JSVM contract is built and deployed locally, follow [Local Installation](https://github.com/near/near-sdk-js#local-installation). Then run:
```
yarn
yarn build
```

The result contract bytecode file will be in `build/on-call.base64`. An intermediate JavaScript file can be found in `build/on-call.js`. You'll only need the `base64` file to deploy contract to chain. The intermediate JavaScript file is for the curious user and near-sdk-js developers to understand what code generation happened under the hood.

## Test the contract with workspaces-js
```
yarn test
```

## Deploy the contract

Suppose JSVM contract was deployed to `jsvm.test.near`. Now you want to deploy the status-message contract to `status-message.test.near` and on-call contract to `on-call.test.near`. Create `status-message.test.near`, `on-call.test.near`, `alice.test.near` and `bob.test.near` locally. Then deploy the contracts following this pattern using the latest `near-cli`:
```sh
export NEAR_ENV=local
near js deploy --accountId <accountId> --base64File <contract-name>.base64 --deposit 0.1 --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    export NEAR_ENV=local
    near call jsvm.test.near deploy_js_contract --accountId <accountId> --args $(cat <contract-name>.base64) --base64 --deposit 0.1

</p>
</details>

## Initialize the contract

Now we need to initialize `status-message` and `on-call` contracts after deployment is ready, call the `init` method which will execute `new OnCall()` or `new StatusMessage()` respectfully.

Go back to the root dir of near-sdk-js, where we have a helper `encode-call.js` and use this pattern to init contracts:

```sh
near js call <contract-id> init --deposit 0.1 --accountId <signer-id> --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --base64 --args $(node encode_call.js <contract-id> init '') --accountId <signer-id>

</p>
</details>

## Call the contract
Under the root dir of near-sdk-js, call the `set_status` and `set_person_on_call` using this pattern:

```sh
near js call <contract-id> <function-name> [--args '<parameter>'] --deposit 0.1 --accountId <signer-id> --jsvm jsvm.test.near
```

or with t<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId <accountID> --base64 --args $(node encode_call.js <contract-account-id> <function-name> '[<parameter>]') --deposit 0.1

</p>
</details>

'''
'''--- jsvm/examples/README-FT.md ---
# Fungible token contract in JavaScript

This is an equivalent JavaScript implementation of the fungible token example. Every user can send and recieve a fungible token.

## Build the contract

First ensure JSVM contract is build and deployed locally, follow [Local Installation](https://github.com/near/near-sdk-js#local-installation). Then run:
```
npm i
npm run build
```

## Test the contract with workspaces-js
```
npm run test
```

'''
'''--- jsvm/examples/README-LOCKABLE-FT.md ---
# Lockable fungible token contract in JavaScript

This is an equivalent JavaScript implementation of the lockable fungible token example.

## Build the contract

First ensure JSVM contract is build and deployed locally, follow [Local Installation](https://github.com/near/near-sdk-js#local-installation). Then run:
```
npm i
npm run build
```

## Test the contract with workspaces-js
```
npm run test
```

'''
'''--- jsvm/examples/README-NFT.md ---
# Non-fungible token contract in JavaScript

This is an equivalent JavaScript implementation of the non-fungible token example. Every user can send and receive a non-fungible token.

## Build the contract

First ensure JSVM contract is build and deployed locally, follow [Local Installation](https://github.com/near/near-sdk-js#local-installation). Then run:
```
npm i
npm run build
```

Result contract bytecode file will be in `build/fungible-token.base64`. Intermediate JavaScript file can be found in `build/fungible-token.js`. You'll only need the `base64` file to deploy contract to chain. The intermediate JavaScript file is for curious user and near-sdk-js developers to understand what code generation happened under the hood.

## Deploy the contract

Suppose JSVM contract was deployed to `jsvm.test.near`. Developer want to deploy the fungible token contract to `nft-jsvm.test.near`. Create `nft-jsvm.test.near`, `alice.test.near` and `bob.test.near` locally. Then:

```sh
export NEAR_ENV=local
near js deploy --accountId nft-jsvm.test.near --base64File build/non-fungible-token.base64 --deposit 0.1 --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    export NEAR_ENV=local
    near call jsvm.test.near deploy_js_contract --accountId nft-jsvm.test.near --args $(cat build/non-fungible-token.base64) --base64 --deposit 0.1

</p>
</details>

## Initialize the contract

Now we need to initialize the contract after deployment is ready, call the `init` method which will execute `new NftContract(owner_id, owner_by_id_prefix)` for the class.
Go back to the root dir of near-sdk-js, where we have a helper `encode-call.js`. Call it with:

```sh
near js call nft-jsvm.test.near init --args '["nft-jsvm.test.near", "prefix"]' --deposit 0.1 --accountId nft-jsvm.test.near --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId nft-jsvm.test.near --base64 --args $(node encode_call.js nft-jsvm.test.near init '["nft-jsvm.test.near", "prefix"]') --deposit 0.1

</p>
</details>

## Call the contract
Under the root dir of near-sdk-js, call the `nftMint` and `nftToken` methods with:

```sh
near js call nft-jsvm.test.near nftMint --args '["1", "alice.test.near"]' --deposit 0.1 --accountId nft-jsvm.test.near --jsvm jsvm.test.near

near js call nft-jsvm.test.near nftToken --args '["1"]' --deposit 0.1 --accountId nft-jsvm.test.near --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId nft-jsvm.test.near --base64 --args $(node encode_call.js nft-jsvm.test.near nftMint '["1", "alice.test.near"]') --deposit 0.1

    near call jsvm.test.near call_js_contract --accountId nft-jsvm.test.near --base64 --args $(node encode_call.js nft-jsvm.test.near nftToken '["1"]')

</p>
</details>

To transfer the NFT to Bob and check its new owner:

```sh
near js call nft-jsvm.test.near nftTransfer --args '["bob.test.near", "1"]' --deposit 0.1 --accountId nft-jsvm.test.near --jsvm jsvm.test.near

near js call nft-jsvm.test.near nftToken --args '["1"]' --deposit 0.1 --accountId nft-jsvm.test.near --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId nft-jsvm.test.near --base64 --args $(node encode_call.js nft-jsvm.test.near nftTransfer '["bob.test.near", "1"]') --deposit 0.1

    near call jsvm.test.near call_js_contract --accountId nft-jsvm.test.near --base64 --args $(node encode_call.js nft-jsvm.test.near nftToken '["1"]')

</p>
</details>

'''
'''--- jsvm/examples/README-STATUS-MESSAGE.md ---
# Status message contract in JavaScript

This is an equivalent JavaScript implementation of the status message example. Every user can store a message on chain. Every user can view everyone's message. Logic is implemented two times with the use of collections and without them.

## Build the contract
```
npm i
npm run build
```

Result contract bytecode files will be stored in `build/status-message.base64` and `build/status-message-collections.base64`. Intermediate JavaScript file can be found in `build/` folder. You'll only need the `base64` file to deploy contract to chain. The intermediate JavaScript file is for curious user and near-sdk-js developers to understand what code generation happened under the hood.

## Test the contracts with workspaces-js
```
npm run test
```

## Deploy the contract

Suppose JSVM contract was deployed to `jsvm.test.near`. Developer want to deploy the status message contract to `status-message.test.near`. Create `status-message.test.near`, `alice.test.near` and `bob.test.near` locally. Then:

```sh
export NEAR_ENV=local
near js deploy --accountId status-message.test.near --base64File build/status-message.base64 --deposit 0.1 --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    export NEAR_ENV=local
    near call jsvm.test.near deploy_js_contract --accountId status-message.test.near --args $(cat build/status-message.base64) --base64 --deposit 0.1

</p>
</details>

## Initialize the contract

Now we need to initialize the contract after deployment is ready, call the `init` method which will execute `new StatusMessage()` for the class.
Go back to the root dir of near-sdk-js, where we have a helper `encode-call.js`. Call it with:

```sh
near js call status-message.test.near init --deposit 0.1 --accountId status-message.test.near --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId status-message.test.near --base64 --args $(node encode_call.js status-message.test.near init '')

</p>
</details>

## Call the contract
Under the root dir of near-sdk-js, call the `set_status` and `get_status` methods with:

```sh
near js call status-message.test.near set_status --args '["hello"]' --deposit 0.1 --accountId alice.test.near--jsvm jsvm.test.near

near js view status-message.test.near get_status --args '["alice.test.near"]' --deposit 0.1 --accountId bob.test.near --jsvm jsvm.test.near
```

<details>
<summary><strong>Or with the raw CLI call command</strong></summary>
<p>

    near call jsvm.test.near call_js_contract --accountId alice.test.near --base64 --args $(node encode_call.js status-message.test.near set_status '["hello"]') --deposit 0.1

    near call jsvm.test.near call_js_contract --accountId bob.test.near --base64 --args $(node encode_call.js status-message.test.near get_status '["alice.test.near"]')

</p>
</details>
'''
'''--- jsvm/examples/README.md ---
# Examples of contracts writen in JS with the use of `near-sdk-js`

## Install dependencies
```bash
yarn
```
## Build contracts
```bash
yarn build
```
## Run Tests
```bash
yarn test
```
## Example specific info
- [Status Message](README-STATUS-MESSAGE.md)

- [Counter](README-COUNTER.md)

- [Cross-contract call](README-CROSS-CONTRACT-CALL.md)

- [NFT](README-NFT.md)

- [FT](README-FT.md)

- [Lockable FT](README-LOCKABLE-FT.md)

- [Clean State](README-CLEAN-STATE.md)
'''
'''--- jsvm/examples/__tests__/test-clean-state.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

// TODO: make this function part of the npm package when it is available
function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy clean state contract
    const cleanStateContract = await root.createSubAccount('clean-state');
    let cleanStateContractBase64 = (await readFile('build/clean-state.base64')).toString();
    await cleanStateContract.call(jsvm, 'deploy_js_contract', Buffer.from(cleanStateContractBase64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await cleanStateContract.call(jsvm, 'call_js_contract', encodeCall(cleanStateContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        jsvm,
        cleanStateContract,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Clean state after storing', async t => {
    const { jsvm, cleanStateContract } = t.context.accounts;
    await cleanStateContract.call(jsvm, 'call_js_contract', encodeCall(cleanStateContract.accountId, 'put', { key: '1', value: 1 }), { attachedDeposit: '400000000000000000000000' });
    const value1 = await jsvm.view('view_js_contract', encodeCall(cleanStateContract.accountId, 'get', { key: '1' }));
    t.is(value1, '1');
    await cleanStateContract.call(jsvm, 'call_js_contract', encodeCall(cleanStateContract.accountId, 'clean', { keys: ['1'] }), { attachedDeposit: '400000000000000000000000' });
    const value2 = await jsvm.view('view_js_contract', encodeCall(cleanStateContract.accountId, 'get', { key: '1' }));
    t.is(value2, null);
});

'''
'''--- jsvm/examples/__tests__/test-counter.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

// Use test.beforeEach to setup the environment with clean state before each test
// If tests can be run in parallel in any order, you can reuse the environment by use test.before
test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy and init the counter JS contract
    const counter = await root.createSubAccount('counter');
    let contract_base64 = (await readFile('build/counter.base64')).toString();
    await counter.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await counter.call(jsvm, 'call_js_contract', encodeCall(counter.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, counter, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Initial count is 0', async t => {
    const { jsvm, counter } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(counter.accountId, 'getCount', {}));
    t.is(result, 0);
});

test('Increase works', async t => {
    const { jsvm, counter, ali, bob } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(counter.accountId, 'increase', {}), { attachedDeposit: '100000000000000000000000' });

    let result = await jsvm.view('view_js_contract', encodeCall(counter.accountId, 'getCount', {}));
    t.is(result, 1);

    await bob.call(jsvm, 'call_js_contract', encodeCall(counter.accountId, 'increase', { n: 4 }), { attachedDeposit: '100000000000000000000000' });
    result = await jsvm.view('view_js_contract', encodeCall(counter.accountId, 'getCount', {}));
    t.is(result, 5);
});

test('Decrease works', async t => {
    const { jsvm, counter, ali, bob } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(counter.accountId, 'decrease', {}), { attachedDeposit: '100000000000000000000000' });

    let result = await jsvm.view('view_js_contract', encodeCall(counter.accountId, 'getCount', {}));
    t.is(result, -1);

    await bob.call(jsvm, 'call_js_contract', encodeCall(counter.accountId, 'decrease', { n: 4 }), { attachedDeposit: '100000000000000000000000' });
    result = await jsvm.view('view_js_contract', encodeCall(counter.accountId, 'getCount', {}));
    t.is(result, -5);
});
'''
'''--- jsvm/examples/__tests__/test-cross-contract-call.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

// TODO: make this function part of the npm package when it is available
function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy status-message JS contract
    const statusMessageContract = await root.createSubAccount('status-message');
    let statusContractBase64 = (await readFile('build/status-message.base64')).toString();
    await statusMessageContract.call(jsvm, 'deploy_js_contract', Buffer.from(statusContractBase64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await statusMessageContract.call(jsvm, 'call_js_contract', encodeCall(statusMessageContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Deploy on-call contrat
    const onCallContract = await root.createSubAccount('on-call');
    let cross_cc_contract_base64 = (await readFile('build/cross-contract-call.base64')).toString();
    await onCallContract.call(jsvm, 'deploy_js_contract', Buffer.from(cross_cc_contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await onCallContract.call(jsvm, 'call_js_contract', encodeCall(onCallContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        jsvm,
        statusMessageContract,
        onCallContract,
        ali,
        bob,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Nobody is on-call in the beginning', async t => {
    const { jsvm, onCallContract } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(onCallContract.accountId, 'person_on_call', {}));
    t.is(result, 'undefined');
});

test('Person can be set on-call if AVAILABLE', async t => {
    const { ali, bob, jsvm, statusMessageContract, onCallContract } = t.context.accounts;

    // Ali set her status as AVAILABLE
    await ali.call(jsvm, 'call_js_contract', encodeCall(statusMessageContract.accountId, 'set_status', { message: 'AVAILABLE' }), { attachedDeposit: '100000000000000000000000' });
    // Bob sets Ali on-call
    await bob.call(jsvm, 'call_js_contract', encodeCall(onCallContract.accountId, 'set_person_on_call', { accountId: ali.accountId }), { attachedDeposit: '100000000000000000000000' });

    // Check that Ali is on-call
    t.is(
        await jsvm.view('view_js_contract', encodeCall(onCallContract.accountId, 'person_on_call', {})),
        ali.accountId
    );
});

test('Person can NOT be set on-call if UNAVAILABLE', async t => {
    const { ali, bob, jsvm, statusMessageContract, onCallContract } = t.context.accounts;

    // Ali set her status as AVAILABLE
    await ali.call(jsvm, 'call_js_contract', encodeCall(statusMessageContract.accountId, 'set_status', { message: 'UNAVAILABLE' }), { attachedDeposit: '100000000000000000000000' });
    // Bob tries to sets Ali on-call
    await bob.call(jsvm, 'call_js_contract', encodeCall(onCallContract.accountId, 'set_person_on_call', { accountId: ali.accountId }), { attachedDeposit: '100000000000000000000000' });

    // Check that Ali is NOT on-call
    t.not(
        await jsvm.view('view_js_contract', encodeCall(onCallContract.accountId, 'person_on_call', {})),
        ali.accountId
    );
});

'''
'''--- jsvm/examples/__tests__/test-fungible-token-lockable.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy lockable FT JS contract
    const lockableFt = await root.createSubAccount('lockable-ft');
    let contract_base64 = (await readFile('build/fungible-token-lockable.base64')).toString();
    await lockableFt.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '1000000000000000000000000' });
    await lockableFt.call(jsvm, 'call_js_contract', encodeCall(lockableFt.accountId, 'init', { prefix: 'prefix', totalSupply: 10000 }), { attachedDeposit: '1000000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, lockableFt, ali, bob };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Owner initial details', async t => {
    const { jsvm, lockableFt } = t.context.accounts;
    const totalSupply = await jsvm.view('view_js_contract', encodeCall(lockableFt.accountId, 'getTotalSupply', {}));
    t.is(totalSupply, 10000);
    const totalBalance = await jsvm.view('view_js_contract', encodeCall(lockableFt.accountId, 'getTotalBalance', { ownerId: lockableFt.accountId }));
    t.is(totalBalance, 10000);
    const unlockedBalance = await jsvm.view('view_js_contract', encodeCall(lockableFt.accountId, 'getUnlockedBalance', { ownerId: lockableFt.accountId }));
    t.is(unlockedBalance, 10000);
    const allowance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(allowance, 0);
    const lockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(lockedBalance, 0);
});

test('Set allowance', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    await lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'setAllowance', { escrowAccountId: ali.accountId, allowance: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    );
    const aliAllowance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: ali.accountId })
    );
    t.is(aliAllowance, 100);
    const contractAllowance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(contractAllowance, 0);
});

test('Fail to set allowance for oneself', async t => {
    const { jsvm, lockableFt } = t.context.accounts;
    const error = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'setAllowance', { escrowAccountId: lockableFt.accountId, allowance: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error.message.includes(`Can't set allowance for yourself`));
});

test('Lock owner', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    await lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'lock', { ownerId: lockableFt.accountId, lockAmount: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    );
    const unlockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getUnlockedBalance', { ownerId: lockableFt.accountId })
    );
    t.is(unlockedBalance, 9900);
    const allowance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(allowance, 0);
    const lockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(lockedBalance, 100);
});

test('Lock failures', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'lock', { ownerId: lockableFt.accountId, lockAmount: 0 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error1.message.includes(`Can't lock 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'lock', { ownerId: lockableFt.accountId, lockAmount: 10001 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error2.message.includes(`Not enough unlocked balance`));

    const error3 = await t.throwsAsync(() => ali.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'lock', { ownerId: lockableFt.accountId, lockAmount: 10 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error3.message.includes(`Not enough allowance`));
});

test('Unlock owner', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    await lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'lock', { ownerId: lockableFt.accountId, lockAmount: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    );
    await lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    );
    const unlockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getUnlockedBalance', { ownerId: lockableFt.accountId })
    );
    t.is(unlockedBalance, 10000);
    const allowance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getAllowance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(allowance, 0);
    const lockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getLockedBalance', { ownerId: lockableFt.accountId, escrowAccountId: lockableFt.accountId })
    );
    t.is(lockedBalance, 0);
});

test('Unlock failures', async t => {
    const { jsvm, lockableFt } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 0 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error1.message.includes(`Can't unlock 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'unlock', { ownerId: lockableFt.accountId, unlockAmount: 1 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error2.message.includes(`Not enough locked tokens`));
});

test('Simple transfer', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    await lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'transfer', { newOwnerId: ali.accountId, amount: 100 }),
        { attachedDeposit: '100000000000000000000000' }
    );
    const ownerUnlockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getUnlockedBalance', { ownerId: lockableFt.accountId })
    );
    t.is(ownerUnlockedBalance, 9900);
    const aliUnlockedBalance = await jsvm.view(
        'view_js_contract',
        encodeCall(lockableFt.accountId, 'getUnlockedBalance', { ownerId: ali.accountId })
    );
    t.is(aliUnlockedBalance, 100);
});

test('Transfer failures', async t => {
    const { jsvm, lockableFt, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'transfer', { newOwnerId: ali.accountId, amount: 0 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error1.message.includes(`Can't transfer 0 or less tokens`));

    const error2 = await t.throwsAsync(() => lockableFt.call(
        jsvm,
        'call_js_contract',
        encodeCall(lockableFt.accountId, 'transfer', { newOwnerId: ali.accountId, amount: 10001 }),
        { attachedDeposit: '100000000000000000000000' }
    ));
    t.assert(error2.message.includes(`Not enough unlocked balance`));
});

'''
'''--- jsvm/examples/__tests__/test-fungible-token.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

// TODO: make this function part of the npm package when it is available
function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy fungible token contract
    const fungibleTokenContract = await root.createSubAccount('fungible-token');
    let ftContractBase64 = (await readFile('build/fungible-token.base64')).toString();
    await fungibleTokenContract.call(jsvm, 'deploy_js_contract', Buffer.from(ftContractBase64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await fungibleTokenContract.call(jsvm, 'call_js_contract', encodeCall(fungibleTokenContract.accountId, 'init', { prefix: 'a', totalSupply: '1000' }), { attachedDeposit: '400000000000000000000000' });

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        jsvm,
        fungibleTokenContract,
        ali,
        bob,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Owner has all balance in the beginning', async t => {
    const { jsvm, fungibleTokenContract } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(fungibleTokenContract.accountId, 'ftBalanceOf', { accountId: fungibleTokenContract.accountId }));
    t.is(result, '1000');
});

test('Can transfer if balance is sufficient', async t => {
    const { ali, jsvm, fungibleTokenContract } = t.context.accounts;

    await fungibleTokenContract.call(jsvm, 'call_js_contract', encodeCall(fungibleTokenContract.accountId, 'ftTransfer', { receiverId: ali.accountId, amount: '100' }), { attachedDeposit: '400000000000000000000000' });
    const aliBalance = await jsvm.view('view_js_contract', encodeCall(fungibleTokenContract.accountId, 'ftBalanceOf', { accountId: ali.accountId }));
    t.is(aliBalance, '100');
    const ownerBalance = await jsvm.view('view_js_contract', encodeCall(fungibleTokenContract.accountId, 'ftBalanceOf', { accountId: fungibleTokenContract.accountId }));
    t.is(ownerBalance, '900');
});

test('Cannot transfer if balance is not sufficient', async t => {
    const { ali, bob, jsvm, fungibleTokenContract } = t.context.accounts;
    try {
        await ali.call(jsvm, 'call_js_contract', encodeCall(fungibleTokenContract.accountId, 'ftTransfer', { receiverId: bob.accountId, amount: '100' }), { attachedDeposit: '400000000000000000000000' });
    } catch (e) {
        t.assert(e.toString().indexOf('Smart contract panicked: assertion failed: The account doesn\'t have enough balance') >= 0);
    }
});

'''
'''--- jsvm/examples/__tests__/test-non-fungible-token.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

// TODO: make this function part of the npm package when it is available
function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy fungible token contract
    const nftContract = await root.createSubAccount('fungible-token');
    let nftContractBase64 = (await readFile('build/non-fungible-token.base64')).toString();
    await nftContract.call(jsvm, 'deploy_js_contract', Buffer.from(nftContractBase64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await nftContract.call(jsvm, 'call_js_contract', encodeCall(nftContract.accountId, 'init', { owner_id: nftContract.accountId, owner_by_id_prefix: 'prefix' }), { attachedDeposit: '400000000000000000000000' });

    // Deploy token receiver contract
    const tokenReceiverContract = await root.createSubAccount('token-receiver');
    let tokenReceiverContractBase64 = (await readFile('build/test-token-receiver.base64')).toString();
    await tokenReceiverContract.call(jsvm, 'deploy_js_contract', Buffer.from(tokenReceiverContractBase64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await tokenReceiverContract.call(jsvm, 'call_js_contract', encodeCall(tokenReceiverContract.accountId, 'init', { nonFungibleTokenAccountId: nftContract.accountId }), { attachedDeposit: '400000000000000000000000' });

    // Mint an NFT
    let tokenId = 'my-cool-nft';
    await nftContract.call(jsvm, 'call_js_contract', encodeCall(nftContract.accountId, 'nftMint', { token_id: tokenId, token_owner_id: nftContract.accountId }), { attachedDeposit: '400000000000000000000000' });

    // Create test accounts
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs, it is unique for each test
    t.context.worker = worker;
    t.context.accounts = {
        root,
        jsvm,
        nftContract,
        tokenReceiverContract,
        tokenId,
        ali,
        bob,
    };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed tear down the worker:', error);
    });
});

test('Owner has the NFT in the beginning', async t => {
    const { jsvm, nftContract, tokenId } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(nftContract.accountId, 'nftToken', { token_id: tokenId }));
    t.deepEqual(result, { owner_id: nftContract.accountId, token_id: tokenId });
});

test('Simple transfer', async t => {
    const { jsvm, nftContract, tokenId, ali } = t.context.accounts;
    await nftContract.call(jsvm, 'call_js_contract', encodeCall(nftContract.accountId, 'nftTransfer', { receiver_id: ali.accountId, token_id: tokenId }), { attachedDeposit: '400000000000000000000000' });
    const result = await jsvm.view('view_js_contract', encodeCall(nftContract.accountId, 'nftToken', { token_id: tokenId }));
    t.deepEqual(result, { owner_id: ali.accountId, token_id: tokenId });
});

test('Transfer failures', async t => {
    const { jsvm, nftContract, tokenId, ali } = t.context.accounts;
    const error1 = await t.throwsAsync(() => ali.call(
        jsvm,
        'call_js_contract',
        encodeCall(nftContract.accountId, 'nftTransfer', { receiver_id: nftContract.accountId, token_id: 'non-existent-id' }),
        { attachedDeposit: '400000000000000000000000' }
    ));
    t.assert(error1.message.includes(`Token not found`));

    const error2 = await t.throwsAsync(() => ali.call(
        jsvm,
        'call_js_contract',
        encodeCall(nftContract.accountId, 'nftTransfer', { receiver_id: nftContract.accountId, token_id: tokenId }),
        { attachedDeposit: '400000000000000000000000' }
    ));
    t.assert(error2.message.includes(`Sender must be the current owner`));

    const error3 = await t.throwsAsync(() => nftContract.call(
        jsvm,
        'call_js_contract',
        encodeCall(nftContract.accountId, 'nftTransfer', { receiver_id: nftContract.accountId, token_id: tokenId }),
        { attachedDeposit: '400000000000000000000000' }
    ));
    t.assert(error3.message.includes(`Current and next owner must differ`));
});

test('Transfer call where receiver returns the token', async t => {
    const { jsvm, nftContract, tokenReceiverContract, tokenId } = t.context.accounts;
    await nftContract.call(
        jsvm,
        'call_js_contract',
        encodeCall(nftContract.accountId, 'nftTransferCall', { receiver_id: tokenReceiverContract.accountId, token_id: tokenId, approval_id: null, memo: null, msg: 'return-it-now' }),
        {
            attachedDeposit: '400000000000000000000000',
            gas: '40000000000000',
        }
    );
    const result = await jsvm.view('view_js_contract', encodeCall(nftContract.accountId, 'nftToken', { token_id: tokenId }));
    t.deepEqual(result, { owner_id: nftContract.accountId, token_id: tokenId });
});

test('Transfer call where receiver keeps the token', async t => {
    const { jsvm, nftContract, tokenReceiverContract, tokenId } = t.context.accounts;
    await nftContract.call(
        jsvm,
        'call_js_contract',
        encodeCall(nftContract.accountId, 'nftTransferCall', { receiver_id: tokenReceiverContract.accountId, token_id: tokenId, approval_id: null, memo: null, msg: 'keep-it-now' }),
        { attachedDeposit: '400000000000000000000000' }
    );
    const result = await jsvm.view('view_js_contract', encodeCall(nftContract.accountId, 'nftToken', { token_id: tokenId }));
    t.deepEqual(result, { owner_id: tokenReceiverContract.accountId, token_id: tokenId });
});

'''
'''--- jsvm/examples/__tests__/test-status-message-collections.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy status-message JS contract
    const statusMessage = await root.createSubAccount('status-message');
    let contract_base64 = (await readFile('build/status-message-collections.base64')).toString();
    await statusMessage.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await statusMessage.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, statusMessage, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Root gets null status', async t => {
    const { root, jsvm, statusMessage } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: root.accountId }));
    t.is(result, null);
});

test('Ali sets then gets status', async t => {
    const { ali, jsvm, statusMessage } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: ali.accountId })),
        'hello'
    );
});

test('Bob and Carl have different statuses', async t => {
    const { jsvm, statusMessage, bob, carl } = t.context.accounts;
    await bob.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    await carl.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'world' }), { attachedDeposit: '100000000000000000000000' });

    const bobStatus = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: bob.accountId }));
    const carlStatus = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: carl.accountId }));
    t.is(bobStatus, 'hello');
    t.is(carlStatus, 'world');
});

test('Get statuses from the contract', async t => {
    const { jsvm, statusMessage, bob, carl } = t.context.accounts;
    await bob.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    await carl.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'world' }), { attachedDeposit: '100000000000000000000000' });

    const statuses = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_all_statuses', {}));
    t.deepEqual(statuses, [[bob.accountId, 'hello'], [carl.accountId, 'world']]);
});

test('message has stored by someone', async t => {
    const { ali, jsvm, statusMessage } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'has_status', { message: 'hello' })),
        true
    );

    t.is(
        await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'has_status', { message: 'world' })),
        false
    );
});
'''
'''--- jsvm/examples/__tests__/test-status-message.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        './node_modules/near-sdk-js/jsvm/build/jsvm.wasm',
    );

    // Deploy status-message JS contract
    const statusMessage = await root.createSubAccount('status-message');
    let contract_base64 = (await readFile('build/status-message.base64')).toString();
    await statusMessage.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await statusMessage.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, statusMessage, ali, bob, carl };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Root gets null status', async t => {
    const { root, jsvm, statusMessage } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: root.accountId }));
    t.is(result, null);
});

test('Ali sets then gets status', async t => {
    const { ali, jsvm, statusMessage } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: ali.accountId })),
        'hello'
    );
});

test('Bob and Carl have different statuses', async t => {
    const { jsvm, statusMessage, bob, carl } = t.context.accounts;
    await bob.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    await carl.call(jsvm, 'call_js_contract', encodeCall(statusMessage.accountId, 'set_status', { message: 'world' }), { attachedDeposit: '100000000000000000000000' });

    const bobStatus = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: bob.accountId }));
    const carlStatus = await jsvm.view('view_js_contract', encodeCall(statusMessage.accountId, 'get_status', { account_id: carl.accountId }));
    t.is(bobStatus, 'hello');
    t.is(carlStatus, 'world');
});

'''
'''--- jsvm/examples/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ]
}

'''
'''--- jsvm/examples/jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- jsvm/examples/package.json ---
{
  "name": "enclaved-examples",
  "version": "1.0.0",
  "description": "Status message example with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "build": "yarn build:clean-state && yarn build:counter && yarn build:cross-contract-call && yarn build:fungible-token-lockable && yarn build:fungible-token && yarn build:non-fungible-token && yarn build:status-message-collections && yarn build:status-message",
    "rebuild": "cd ../../ && yarn build && cd jsvm/examples && rm -rf node_modules && rm -rf build && yarn && yarn build",
    "build:clean-state": "near-sdk-js build src/clean-state.js build/clean-state.base64",
    "build:counter": "near-sdk-js build src/counter.js build/counter.base64",
    "build:cross-contract-call": "near-sdk-js build src/status-message.js build/status-message.base64 && near-sdk-js build src/cross-contract-call.js build/cross-contract-call.base64",
    "build:fungible-token-lockable": "near-sdk-js build src/fungible-token-lockable.js build/fungible-token-lockable.base64",
    "build:fungible-token": "near-sdk-js build src/fungible-token.js build/fungible-token.base64",
    "build:non-fungible-token": "near-sdk-js build src/test-token-receiver.js build/test-token-receiver.base64 && near-sdk-js build src/non-fungible-token.js build/non-fungible-token.base64",
    "build:status-message-collections": "near-sdk-js build src/status-message-collections.js build/status-message-collections.base64",
    "build:status-message": "near-sdk-js build src/status-message.js build/status-message.base64",
    "test": "ava",
    "test:clean-state": "ava __tests__/test-clean-state.ava.js",
    "test:counter": "ava __tests__/test-counter.ava.js",
    "test:cross-contract-call": "ava __tests__/test-cross-contract-call.ava.js",
    "test:fungible-token-lockable": "ava __tests__/test-fungible-token-lockable.ava.js",
    "test:fungible-token": "ava __tests__/test-fungible-token.ava.js",
    "test:non-fungible-token": "ava __tests__/test-non-fungible-token.ava.js",
    "test:status-message-collections": "ava __tests__/test-status-message-collections.ava.js",
    "test:status-message": "ava __tests__/test-status-message.ava.js"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "Apache-2.0",
  "dependencies": {
    "near-sdk-js": "file:../../",
    "lodash-es": "^4.17.21"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "^3.0.0"
  }
}
'''
'''--- jsvm/examples/src/clean-state.js ---
import { NearContract, NearBindgen, call, view, near, LookupMap } from 'near-sdk-js'

@NearBindgen
class CleanState extends NearContract {
    @call
    clean({keys}) {
        keys.forEach(key => near.jsvmStorageRemove(key))
    }

    @call
    put({key, value}) {
        near.jsvmStorageWrite(key, value)
    }

    @view
    get({key}) {
        return near.jsvmStorageRead(key)
    }
}

'''
'''--- jsvm/examples/src/counter.js ---
import { NearContract, NearBindgen, near, call, view } from 'near-sdk-js'
import { isUndefined } from 'lodash-es'

@NearBindgen
class Counter extends NearContract {
    constructor({ initial = 0 }) {
        super()
        this.count = initial
    }

    @call
    increase({ n = 1 }) {
        this.count += n
        near.log(`Counter increased to ${this.count}`)
    }

    @call
    decrease({ n }) {
        // you can use default argument `n=1` too
        // this is to illustrate a npm dependency: lodash can be used
        if (isUndefined(n)) {
            this.count -= 1
        } else {
            this.count -= n
        }
        near.log(`Counter decreased to ${this.count}`)
    }

    @view
    getCount() {
        return this.count
    }
}

'''
'''--- jsvm/examples/src/cross-contract-call.js ---
import { NearContract, NearBindgen, call, view, near } from 'near-sdk-js'

@NearBindgen
class OnCall extends NearContract {
    constructor({ }) {
        super()
        this.personOnCall = "undefined"
    }

    @call
    set_person_on_call({ accountId }) {
        near.log(`Trying to set ${accountId} on-call`)
        const status = near.jsvmCall('status-message.test.near', 'get_status', { account_id: accountId })
        near.log(`${accountId} status is ${status}`)
        if (status === 'AVAILABLE') {
            this.personOnCall = accountId
            near.log(`${accountId} set on-call`)
        } else {
            near.log(`${accountId} can not be set on-call`)
        }
    }

    @view
    person_on_call() {
        near.log(`Returning person on-call: ${this.personOnCall}`)
        return this.personOnCall
    }
}

'''
'''--- jsvm/examples/src/fungible-token-lockable.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
    LookupMap,
    assert
} from 'near-sdk-js'

class Account {
    constructor(balance, allowances, lockedBalances) {
        this.balance = balance // Current unlocked balance
        this.allowances = allowances // Allowed account to the allowance amount
        this.lockedBalances = lockedBalances // Allowed account to locked balance
    }

    setAllowance(escrowAccountId, allowance) {
        if (allowance > 0) {
            this.allowances[escrowAccountId] = allowance
        } else if (allowance === 0) {
            delete this.allowances[escrowAccountId]
        } else {
            throw Error("Allowance can't be negative")
        }
    }

    getAllowance(escrowAccountId) {
        return this.allowances[escrowAccountId] || 0
    }

    setLockedBalance(escrowAccountId, lockedBalance) {
        if (lockedBalance > 0) {
            this.lockedBalances[escrowAccountId] = lockedBalance
        } else if (lockedBalance === 0) {
            delete this.lockedBalances[escrowAccountId]
        } else {
            throw Error("Locked balance cannot be negative")
        }
    }

    getLockedBalance(escrowAccountId) {
        return this.lockedBalances[escrowAccountId] || 0
    }

    totalBalance() {
        let totalLockedBalance =
            Object.values(this.lockedBalances).reduce((acc, val) => acc + val, 0)
        return this.balance + totalLockedBalance
    }
}

@NearBindgen
class LockableFungibleToken extends NearContract {
    constructor({ prefix, totalSupply }) {
        super()
        this.accounts = new LookupMap(prefix) // Account ID -> Account mapping
        this.totalSupply = totalSupply // Total supply of the all tokens
        let ownerId = near.signerAccountId()
        let ownerAccount = this.getAccount(ownerId)
        ownerAccount.balance = totalSupply
        this.setAccount(ownerId, ownerAccount)
    }

    deserialize() {
        super.deserialize()
        this.accounts = Object.assign(new LookupMap, this.accounts)
    }

    getAccount(ownerId) {
        let account = this.accounts.get(ownerId)
        if (account === null) {
            return new Account(0, {}, {})
        }
        return Object.assign(new Account(), JSON.parse(account))
    }

    setAccount(accountId, account) {
        this.accounts.set(accountId, JSON.stringify(account))
    }

    @call
    setAllowance({ escrowAccountId, allowance }) {
        let ownerId = near.predecessorAccountId()
        if (escrowAccountId === ownerId) {
            throw Error("Can't set allowance for yourself")
        }
        let account = this.getAccount(ownerId)
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        if (lockedBalance > allowance) {
            throw Error("The new allowance can't be less than the amount of locked tokens")
        }

        account.setAllowance(escrowAccountId, allowance - lockedBalance)
        this.setAccount(ownerId, account)
    }

    @call
    lock({ ownerId, lockAmount }) {
        if (lockAmount <= 0) {
            throw Error("Can't lock 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating unlocked balance
        if (account.balance < lockAmount) {
            throw Error("Not enough unlocked balance")
        }
        account.balance -= lockAmount

        // If locking by escrow, need to check and update the allowance.
        if (escrowAccountId !== ownerId) {
            let allowance = account.getAllowance(escrowAccountId)
            if (allowance < lockAmount) {
                throw Error("Not enough allowance")
            }
            account.setAllowance(escrowAccountId, allowance - lockAmount)
        }

        // Updating total lock balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        account.setLockedBalance(escrowAccountId, lockedBalance + lockAmount)

        this.setAccount(ownerId, account)
    }

    @call
    unlock({ ownerId, unlockAmount }) {
        if (unlockAmount <= 0) {
            throw Error("Can't unlock 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating locked balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        if (lockedBalance < unlockAmount) {
            throw Error("Not enough locked tokens")
        }
        account.setLockedBalance(escrowAccountId, lockedBalance - unlockAmount)

        // If unlocking by escrow, need to update allowance.
        if (escrowAccountId !== ownerId) {
            let allowance = account.getAllowance(escrowAccountId)
            account.setAllowance(escrowAccountId, allowance + unlockAmount)
        }

        // Updating unlocked balance
        account.balance += unlockAmount

        this.setAccount(ownerId, account)
    }

    @call
    transferFrom({ ownerId, newOwnerId, amount }) {
        if (amount <= 0) {
            throw Error("Can't transfer 0 or less tokens")
        }
        let escrowAccountId = near.predecessorAccountId()
        let account = this.getAccount(ownerId)

        // Checking and updating locked balance
        let lockedBalance = account.getLockedBalance(escrowAccountId)
        var remainingAmount
        if (lockedBalance >= amount) {
            account.setLockedBalance(escrowAccountId, lockedBalance - amount)
            remainingAmount = 0
        } else {
            account.setLockedBalance(escrowAccountId, 0)
            remainingAmount = amount - lockedBalance
        }

        // If there is remaining balance after the locked balance, we try to use unlocked tokens.
        if (remainingAmount > 0) {
            // Checking and updating unlocked balance
            if (account.balance < remainingAmount) {
                throw Error("Not enough unlocked balance")
            }
            account.balance -= remainingAmount

            // If transferring by escrow, need to check and update allowance.
            if (escrowAccountId !== ownerId) {
                let allowance = account.getAllowance(escrowAccountId)
                // Checking and updating unlocked balance
                if (allowance < remainingAmount) {
                    throw Error("Not enough allowance")
                }
                account.setAllowance(escrowAccountId, allowance - remainingAmount)
            }
        }

        this.setAccount(ownerId, account)

        // Deposit amount to the new owner
        let newAccount = this.getAccount(newOwnerId)
        newAccount.balance += amount
        this.setAccount(newOwnerId, newAccount)
    }

    @call
    transfer({ newOwnerId, amount }) {
        this.transferFrom({ ownerId: near.predecessorAccountId(), newOwnerId, amount })
    }

    @view
    getTotalSupply() {
        return this.totalSupply
    }

    @view
    getTotalBalance({ ownerId }) {
        return this.getAccount(ownerId).totalBalance()
    }

    @view
    getUnlockedBalance({ ownerId }) {
        return this.getAccount(ownerId).balance
    }

    @view
    getAllowance({ ownerId, escrowAccountId }) {
        return this.getAccount(ownerId).getAllowance(escrowAccountId)
    }

    @view
    getLockedBalance({ ownerId, escrowAccountId }) {
        return this.getAccount(ownerId).getLockedBalance(escrowAccountId)
    }
}

'''
'''--- jsvm/examples/src/fungible-token.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
    LookupMap,
    assert
} from 'near-sdk-js'

@NearBindgen
class FungibleToken extends NearContract {
    constructor({ prefix, totalSupply }) {
        super()
        this.accounts = new LookupMap(prefix)
        this.totalSupply = totalSupply
        this.accounts.set(near.signerAccountId(), totalSupply)
        // don't need accountStorageUsage like rust in JS contract, storage deposit management is automatic in JSVM
    }

    deserialize() {
        super.deserialize()
        this.accounts = Object.assign(new LookupMap, this.accounts)
    }

    internalDeposit({ accountId, amount }) {
        let balance = this.accounts.get(accountId) || '0'
        let newBalance = BigInt(balance) + BigInt(amount)
        this.accounts.set(accountId, newBalance.toString())
        this.totalSupply = (BigInt(this.totalSupply) + BigInt(amount)).toString()
    }

    internalWithdraw({ accountId, amount }) {
        let balance = this.accounts.get(accountId) || '0'
        let newBalance = BigInt(balance) - BigInt(amount)
        assert(newBalance >= 0n, "The account doesn't have enough balance")
        this.accounts.set(accountId, newBalance.toString())
        let newSupply = BigInt(this.totalSupply) - BigInt(amount)
        assert(newSupply >= 0n, "Total supply overflow")
        this.totalSupply = newSupply.toString()
    }

    internalTransfer({ senderId, receiverId, amount, memo }) {
        assert(senderId != receiverId, "Sender and receiver should be different")
        let amountInt = BigInt(amount)
        assert(amountInt > 0n, "The amount should be a positive number")
        this.internalWithdraw({ accountId: senderId, amount })
        this.internalDeposit({ accountId: receiverId, amount })
    }

    @call
    ftTransfer({ receiverId, amount, memo }) {
        let senderId = near.predecessorAccountId()
        this.internalTransfer({ senderId, receiverId, amount, memo })
    }

    @call
    ftTransferCall({ receiverId, amount, memo, msg }) {
        let senderId = near.predecessorAccountId()
        this.internalTransfer({ senderId, receiverId, amount, memo })
        let onTransferRet = near.jsvmCall(receiverId, 'ftOnTransfer', { senderId, amount, msg, receiverId })
        // In JS, do not need a callback, ftResolveTransfer after ftOnTransfer Returns
        // If any logic after ftOnTransfer Returns is required, just do it on onTransferRet.
        return onTransferRet
    }

    @view
    ftTotalSupply() {
        return this.totalSupply
    }

    @view
    ftBalanceOf({ accountId }) {
        return this.accounts.get(accountId) || '0'
    }
}

'''
'''--- jsvm/examples/src/non-fungible-token.js ---
import { NearContract, NearBindgen, call, view, near, LookupMap, assert } from 'near-sdk-js'

class Token {
    constructor(token_id, owner_id) {
        this.token_id = token_id;
        this.owner_id = owner_id;
    }
}

@NearBindgen
class NftContract extends NearContract {
    constructor({ owner_id, owner_by_id_prefix }) {
        super()
        this.owner_id = owner_id
        this.owner_by_id = new LookupMap(owner_by_id_prefix)
    }

    deserialize() {
        super.deserialize()
        this.owner_by_id = Object.assign(new LookupMap, this.owner_by_id)
    }

    internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo }) {
        let owner_id = this.owner_by_id.get(token_id)

        assert(owner_id !== null, "Token not found")
        assert(sender_id === owner_id, "Sender must be the current owner")
        assert(owner_id !== receiver_id, "Current and next owner must differ")

        this.owner_by_id.set(token_id, receiver_id)

        return owner_id
    }

    @call
    nftTransfer({ receiver_id, token_id, approval_id, memo }) {
        let sender_id = near.predecessorAccountId()
        this.internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo })
    }

    @call
    nftTransferCall({ receiver_id, token_id, approval_id, memo, msg }) {
        let sender_id = near.predecessorAccountId()
        let old_owner_id = this.internalTransfer({ sender_id, receiver_id, token_id, approval_id, memo })

        let onTransferRet = near.jsvmCall(receiver_id, 'nftOnTransfer', { senderId: sender_id, previousOwnerId: old_owner_id, tokenId: token_id, msg: msg })

        // NOTE: Arbitrary logic can be run here, as an example we return the token to the initial
        // owner if receiver's `nftOnTransfer` returns `true`
        if (onTransferRet) {
            let currentOwner = this.owner_by_id.get(token_id)
            if (currentOwner === null) {
                // The token was burned and doesn't exist anymore.
                return true
            } else if (currentOwner !== receiver_id) {
                // The token is not owned by the receiver anymore. Can't return it.
                return true
            } else {
                this.internalTransfer({ sender_id: receiver_id, receiver_id: sender_id, token_id: token_id, approval_id: null, memo: null })
                return false
            }
        } else {
            return true
        }
    }

    @call
    nftMint({ token_id, token_owner_id, token_metadata }) {
        let sender_id = near.predecessorAccountId()
        assert(sender_id === this.owner_id, "Unauthorized")
        assert(this.owner_by_id.get(token_id) === null, "Token ID must be unique")

        this.owner_by_id.set(token_id, token_owner_id)

        return new Token(token_id, token_owner_id)
    }

    @view
    nftToken({ token_id }) {
        let owner_id = this.owner_by_id.get(token_id)
        if (owner_id === null) {
            return null
        }

        return new Token(token_id, owner_id)
    }
}

'''
'''--- jsvm/examples/src/status-message-collections.js ---
import { NearContract, NearBindgen, call, view, near, LookupSet, UnorderedMap, Vector } from 'near-sdk-js'

@NearBindgen
class StatusMessage extends NearContract {
    constructor() {
        super()
        this.records = new UnorderedMap('a')
        this.uniqueValues = new LookupSet('b')
    }

    deserialize() {
        super.deserialize()
        this.records.keys = Object.assign(new Vector, this.records.keys)
        this.records.values = Object.assign(new Vector, this.records.values)
        this.records = Object.assign(new UnorderedMap, this.records)
        this.uniqueValues = Object.assign(new LookupSet, this.uniqueValues)
    }

    @call
    set_status({ message }) {
        let account_id = near.signerAccountId()
        near.log(`${account_id} set_status with message ${message}`)
        this.records.set(account_id, message)
        this.uniqueValues.set(message)
    }

    @view
    get_status({ account_id }) {
        near.log(`get_status for account_id ${account_id}`)
        return this.records.get(account_id)
    }

    @view
    has_status({ message }) {
        // used for test LookupMap
        return this.uniqueValues.contains(message)
    }

    @view
    get_all_statuses() {
        // used for test UnorderedMap
        return this.records.toArray()
    }
}

'''
'''--- jsvm/examples/src/status-message.js ---
import { NearContract, NearBindgen, call, view, near } from 'near-sdk-js'

@NearBindgen
class StatusMessage extends NearContract {
    constructor() {
        super()
        this.records = {}
    }

    @call
    set_status({ message }) {
        let account_id = near.signerAccountId()
        near.log(`${account_id} set_status with message ${message}`)
        this.records[account_id] = message
    }

    @view
    get_status({ account_id }) {
        near.log(`get_status for account_id ${account_id}`)
        return this.records[account_id] || null
    }
}

'''
'''--- jsvm/examples/src/test-token-receiver.js ---
import { NearContract, NearBindgen, call, near, assert } from 'near-sdk-js'

@NearBindgen
class NftContract extends NearContract {
    constructor({ nonFungibleTokenAccountId }) {
        super()
        this.nonFungibleTokenAccountId = nonFungibleTokenAccountId
    }

    @call
    nftOnTransfer({ senderId, previousOwnerId, tokenId, msg }) {
        assert(
            near.predecessorAccountId() === this.nonFungibleTokenAccountId,
            "Only supports the one non-fungible token contract"
        )
        if (msg === "return-it-now") {
            return true
        } else if (msg === "keep-it-now") {
            return false
        } else {
            throw Error("unsupported msg")
        }
    }
}

'''
'''--- jsvm/jsvm.c ---
#include <string.h>
#include <stdbool.h>
#include "../quickjs/quickjs-libc-min.h"
#include "../quickjs/libbf.h"

static JSContext *JS_NewCustomContext(JSRuntime *rt)
{
  JSContext *ctx = JS_NewContextRaw(rt);
  if (!ctx)
    return NULL;
  JS_AddIntrinsicBaseObjects(ctx);
  JS_AddIntrinsicDate(ctx);
  JS_AddIntrinsicEval(ctx);
  JS_AddIntrinsicStringNormalize(ctx);
  JS_AddIntrinsicRegExp(ctx);
  JS_AddIntrinsicJSON(ctx);
  JS_AddIntrinsicProxy(ctx);
  JS_AddIntrinsicMapSet(ctx);
  JS_AddIntrinsicTypedArrays(ctx);
  JS_AddIntrinsicPromise(ctx);
  JS_AddIntrinsicBigInt(ctx);
  return ctx;
}

// #############
// # Registers #
// #############
extern void read_register(uint64_t register_id, uint64_t ptr);
extern uint64_t register_len(uint64_t register_id);
extern void write_register(uint64_t register_id, uint64_t data_len, uint64_t data_ptr);
// ###############
// # Context API #
// ###############
extern void current_account_id(uint64_t register_id);
extern void signer_account_id(uint64_t register_id);
extern void signer_account_pk(uint64_t register_id);
extern void predecessor_account_id(uint64_t register_id);
extern void input(uint64_t register_id);
extern uint64_t block_index();
extern uint64_t block_timestamp();
extern uint64_t epoch_height();
extern uint64_t storage_usage();
// #################
// # Economics API #
// #################
extern void account_balance(uint64_t balance_ptr);
extern void account_locked_balance(uint64_t balance_ptr);
extern void attached_deposit(uint64_t balance_ptr);
extern uint64_t prepaid_gas();
extern uint64_t used_gas();
// ############
// # Math API #
// ############
extern void random_seed(uint64_t register_id);
extern void sha256(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void keccak256(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void keccak512(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void ripemd160(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t ecrecover(uint64_t hash_len, uint64_t hash_ptr, uint64_t sign_len, uint64_t sig_ptr, uint64_t v, uint64_t malleability_flag, uint64_t register_id);
// #####################
// # Miscellaneous API #
// #####################
extern void value_return(uint64_t value_len, uint64_t value_ptr);
extern void panic(void);
extern void panic_utf8(uint64_t len, uint64_t ptr);
extern void log_utf8(uint64_t len, uint64_t ptr);
extern void log_utf16(uint64_t len, uint64_t ptr);
// ################
// # Promises API #
// ################
extern uint64_t promise_batch_create(uint64_t account_id_len, uint64_t account_id_ptr);
// #######################
// # Promise API actions #
// #######################
extern void promise_batch_action_transfer(uint64_t promise_index, uint64_t amount_ptr);
// #######################
// # Promise API results #
// #######################
extern void promise_return(uint64_t promise_idx);
// ###############
// # Storage API #
// ###############
extern uint64_t storage_write(uint64_t key_len, uint64_t key_ptr, uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t storage_read(uint64_t key_len, uint64_t key_ptr, uint64_t register_id);
extern uint64_t storage_remove(uint64_t key_len, uint64_t key_ptr, uint64_t register_id);
extern uint64_t storage_has_key(uint64_t key_len, uint64_t key_ptr);
// #################
// # Validator API #
// #################
extern void validator_stake(uint64_t account_id_len, uint64_t account_id_ptr, uint64_t stake_ptr);
extern void validator_total_stake(uint64_t stake_ptr);
// #############
// # Alt BN128 #
// #############
#ifdef NIGHTLY
extern void alt_bn128_g1_multiexp(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern void alt_bn128_g1_sum(uint64_t value_len, uint64_t value_ptr, uint64_t register_id);
extern uint64_t alt_bn128_pairing_check(uint64_t value_len, uint64_t value_ptr);
#endif
// #############
// #  Sandbox  #
// #############
#ifdef SANDBOX
extern void sandbox_debug_log(uint64_t len, uint64_t ptr);
#endif

static JSValue near_read_register(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  char *data;
  uint64_t data_len;
  JSValue ret;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  data_len = register_len(register_id);
  if (data_len != UINT64_MAX) {
    data = malloc(data_len);
    read_register(register_id, (uint64_t)data);
    ret = JS_NewStringLenRaw(ctx, data, data_len);
    free(data);
    return ret;
  } else {
    return JS_UNDEFINED;
  }
}

static JSValue near_register_len(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id, len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  len = register_len(register_id);
  return JS_NewBigUint64(ctx, len);
}

static JSValue near_write_register(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[1]);

  write_register(register_id, data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_jsvm_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  current_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_signer_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  signer_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_signer_account_pk(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  signer_account_pk(register_id);
  return JS_UNDEFINED;
}

static JSValue near_predecessor_account_id(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  predecessor_account_id(register_id);
  return JS_UNDEFINED;
}

static JSValue near_block_index(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = block_index();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_block_timestamp(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = block_timestamp();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_epoch_height(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = epoch_height();
  return JS_NewBigUint64(ctx, value);
}

// ptr[0] ptr[1] is little-endian u128.
static JSValue u128_to_quickjs(JSContext *ctx, uint64_t* ptr) {
  JSValue value;
  bf_t* bn;
  bf_t b;

  value = JS_NewBigInt(ctx);
  bn = JS_GetBigInt(value);
  // from ptr[] to bn
  // high 64 bits
  bf_set_ui(bn, ptr[1]);
  bf_mul_2exp(bn, 64, BF_PREC_INF, BF_RNDZ);
  // low 64 bits
  bf_init(bn->ctx, &b);
  bf_set_ui(&b, ptr[0]);
  bf_add(bn, bn, &b, BF_PREC_INF, BF_RNDZ);
  bf_delete(&b);
  
  return value;
}

static int quickjs_bigint_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  bf_t* a;
  bf_t q, r, b, one, u128max;
  a = JS_GetBigInt(val);
  bf_init(a->ctx, &u128max);
  bf_set_ui(&u128max, 1);
  bf_mul_2exp(&u128max, 128, BF_PREC_INF, BF_RNDZ);
  if (bf_cmp_le(&u128max, a)) {
    return 1;
  }
  bf_init(a->ctx, &q);
  bf_init(a->ctx, &r);
  bf_init(a->ctx, &b);
  bf_init(a->ctx, &one);
  bf_set_ui(&b, UINT64_MAX);
  bf_set_ui(&one, 1);
  bf_add(&b, &b, &one, BF_PREC_INF, BF_RNDZ);
  bf_divrem(&q, &r, a, &b, BF_PREC_INF, BF_RNDZ, BF_RNDZ);
  
  bf_get_uint64(ptr, &r);
  bf_get_uint64(ptr+1, &q);
  return 0;
}

static int quickjs_int_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  if (JS_ToUint64Ext(ctx, ptr, val) < 0) {
    return 1;
  }
  ptr[1] = 0;
  return 0;
}

static int quickjs_to_u128(JSContext *ctx, JSValueConst val, uint64_t* ptr) {
  if (JS_IsBigInt(ctx, val))
    return quickjs_bigint_to_u128(ctx, val, ptr);
  else {
    return quickjs_int_to_u128(ctx, val, ptr);
  }
}

static JSValue near_attached_deposit(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t ptr[2];

  attached_deposit((uint64_t)ptr);
  return u128_to_quickjs(ctx, ptr);
}

static JSValue near_prepaid_gas(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = prepaid_gas();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_used_gas(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t value;

  value = used_gas();
  return JS_NewBigUint64(ctx, value);
}

static JSValue near_random_seed(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  random_seed(register_id);
  return JS_UNDEFINED;
}

static JSValue near_sha256(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  sha256(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_keccak256(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }  
  keccak256(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_keccak512(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  keccak512(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_ripemd160(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  
  ripemd160(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_ecrecover(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t malleability_flag, v, register_id, result;
  const char *hash_ptr, *sig_ptr;
  size_t hash_len, sign_len;

  hash_ptr = JS_ToCStringLenRaw(ctx, &hash_len, argv[0]);
  sig_ptr = JS_ToCStringLenRaw(ctx, &sign_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &malleability_flag, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for malleability_flag");
  }
  if (JS_ToUint64Ext(ctx, &v, argv[3]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for v");
  }
  if (JS_ToUint64Ext(ctx, &register_id, argv[4]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
 
  result = ecrecover(hash_len, (uint64_t)hash_ptr, sign_len, (uint64_t)sig_ptr, malleability_flag, v, register_id);
  return JS_NewBigUint64(ctx, result);
}

static JSValue near_panic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  if (argc == 1) {
    data_ptr = JS_ToCStringLen(ctx, &data_len, argv[0]);
    panic_utf8(data_len, (uint64_t)data_ptr);
  } else {
    panic();
  }
  return JS_UNDEFINED;
}

static JSValue near_panic_utf8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  panic_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLen(ctx, &data_len, argv[0]);
  
  log_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log_utf8(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  log_utf8(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

static JSValue near_log_utf16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  log_utf16(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}

const uint64_t STORAGE_PRICE_PER_BYTE_U64 = 10000000000000000000ul;
const char *STORAGE_PRICE_PER_BYTE = "10000000000000000000";

static void mult64to128(uint64_t op1, uint64_t op2, uint64_t *hi, uint64_t *lo)
{
  uint64_t u1 = (op1 & 0xffffffff);
  uint64_t v1 = (op2 & 0xffffffff);
  uint64_t t = (u1 * v1);
  uint64_t w3 = (t & 0xffffffff);
  uint64_t k = (t >> 32);

  op1 >>= 32;
  t = (op1 * v1) + k;
  k = (t & 0xffffffff);
  uint64_t w1 = (t >> 32);

  op2 >>= 32;
  t = (u1 * op2) + k;
  k = (t >> 32);

  *hi = (op1 * op2) + w1 + k;
  *lo = (t << 32) + w3;
}

static void uint128minus(uint64_t *op1_hi, uint64_t *op1_lo, uint64_t *op2_hi, uint64_t *op2_lo) {
  *op1_lo = *op1_lo - *op2_lo;
  uint64_t c = (((*op1_lo & *op2_lo) & 1) + (*op2_lo >> 1) + (*op1_lo >> 1)) >> 63;
  *op1_hi = *op1_hi - (*op2_hi + c);
}

static void uint128add(uint64_t *op1_hi, uint64_t *op1_lo, uint64_t *op2_hi, uint64_t *op2_lo) {
  uint64_t c = (((*op1_lo & *op2_lo) & 1) + (*op1_lo >> 1) + (*op2_lo >> 1)) >> 63;
  *op1_hi = *op1_hi + *op2_hi + c;
  *op1_lo = *op1_lo + *op2_lo;
}

static void storage_cost_for_bytes(uint64_t n, uint64_t* cost) {
  // cost = n * STORAGE_PRICE_PER_BYTE
  mult64to128(n, STORAGE_PRICE_PER_BYTE_U64, cost+1, cost);
}

static bool u128_less_than(uint64_t *a, uint64_t *b) {
  return (a[1] < b[1]) || ((a[1] == b[1]) && (a[0] < b[0]));
}

static void panic_str(char *s) {
  panic_utf8(strlen(s), (uint64_t)s);
}

#define GET 0
#define SET 1

static void remaining_deposit(uint64_t *deposit, int flag) {
  static bool remain_deposit_set = false;
  static uint64_t remain_deposit[2];

  if (flag == GET) {
    if (!remain_deposit_set) {
      remain_deposit_set = true;
      attached_deposit((uint64_t)remain_deposit);
    }
    deposit[0] = remain_deposit[0];
    deposit[1] = remain_deposit[1];
  } else {
    if (!remain_deposit_set) {
      remain_deposit_set = true;
    }
    remain_deposit[0] = deposit[0];
    remain_deposit[1] = deposit[1];
  }
}

static void input_js_contract_name(char **name, uint64_t *len, int flag) {
  static char *js_contract_name;
  static uint64_t js_contract_name_len;

  if (flag == GET) {
    *name = js_contract_name;
    *len = js_contract_name_len;
  } else {
    js_contract_name = *name;
    js_contract_name_len = *len;
  }
}

static void input_method_name(char **name, uint64_t *len, int flag) {
  static char *method_name;
  static uint64_t method_name_len;

  if (flag == GET) {
    *name = method_name;
    *len = method_name_len;
  } else {
    method_name = *name;
    method_name_len = *len;
  }
}

static void input_args(char **name, uint64_t *len, int flag) {
  static char *args;
  static uint64_t args_len;

  if (flag == GET) {
    *name = args;
    *len = args_len;
  } else {
    args = *name;
    args_len = *len;
  }
}

static void jsvm_call_returns(char **val, uint64_t *len, int flag) {
  static char *ret = "";
  static uint64_t ret_len = 0;

  if (flag == GET) {
    *val = ret;
    *len = ret_len;
  } else {
    ret = *val;
    ret_len = *len;
  }
}

static JSValue near_jsvm_value_return(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) 
{
  const char *value_ptr;
  size_t value_len;
  char *value;
  uint64_t value_len_u64;

  value_ptr = JS_ToCStringLenRaw(ctx, &value_len, argv[0]);
  value = (char *)value_ptr;
  value_len_u64 = (uint64_t)value_len;
  value_return(value_len, (uint64_t)value_ptr);
  jsvm_call_returns(&value, &value_len_u64, SET);
  return JS_UNDEFINED;
}

static void deduct_cost(uint64_t *cost) {
  uint64_t deposit[2];
  remaining_deposit(deposit, GET);
  if (u128_less_than(deposit, cost)) {
    panic_str("insufficient deposit for storage");
  } else {
    uint128minus(deposit+1, deposit, cost+1, cost);
    remaining_deposit(deposit, SET);
  }
}

static void refund_cost(uint64_t *cost) {
  uint64_t deposit[2];
  remaining_deposit(deposit, GET);
  uint128add(deposit+1, deposit, cost+1, cost);
  remaining_deposit(deposit, SET);
}

static void refund_storage_deposit() {
  uint64_t deposit[2];
  uint64_t promise_id;
  char account[64];
  uint64_t account_len;

  predecessor_account_id(0);
  read_register(0, (uint64_t)account);
  account_len = register_len(0);

  remaining_deposit(deposit, GET);
  
  if (deposit[0] > 0 || deposit[1] > 0) {
    promise_id = promise_batch_create(account_len, (uint64_t)account);
    promise_batch_action_transfer(promise_id, (uint64_t)deposit);
    promise_return(promise_id);
  }
}

static uint64_t storage_write_enclave(uint64_t key_len, uint64_t key_ptr, uint64_t value_len, uint64_t value_ptr, uint64_t register_id) {
  uint64_t cost[2];
  uint64_t ret;
  uint64_t initial = storage_usage(), after;

  ret = storage_write(key_len, key_ptr, value_len, value_ptr, register_id);
  after = storage_usage();
  if (after > initial) {
    storage_cost_for_bytes(after - initial, cost);
    deduct_cost(cost);
  } else if (after < initial) {
    storage_cost_for_bytes(initial - after, cost);
    refund_cost(cost);
  }
  return ret;
}

static uint64_t storage_remove_enclave(uint64_t key_len, uint64_t key_ptr, uint64_t register_id) {
  uint64_t cost[2];
  uint64_t ret;
  uint64_t initial = storage_usage(), after;

  ret = storage_remove(key_len, key_ptr, register_id);
  after = storage_usage();
  if (after < initial) {
    storage_cost_for_bytes(initial - after, cost);
    refund_cost(cost);
  }
  return ret;
}

static JSValue near_jsvm_js_contract_name(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  char* contract_name;
  uint64_t contract_name_len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  input_js_contract_name(&contract_name, &contract_name_len, GET);
  write_register(register_id, contract_name_len, (uint64_t)contract_name);
  return JS_UNDEFINED;
}

static JSValue near_jsvm_method_name(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  char* method_name;
  uint64_t method_name_len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  input_method_name(&method_name, &method_name_len, GET);
  write_register(register_id, method_name_len, (uint64_t)method_name);
  return JS_UNDEFINED;
}

static JSValue near_jsvm_args(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  char* args;
  uint64_t args_len;

  if (JS_ToUint64Ext(ctx, &register_id, argv[0]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  input_args(&args, &args_len, GET);
  write_register(register_id, args_len, (uint64_t)args);
  return JS_UNDEFINED;
}

static JSValue near_jsvm_storage_write(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr, *value_ptr;
  char *key_with_account_prefix, *contract_name;
  size_t key_len, value_len, key_with_prefix_len;
  uint64_t register_id, contract_name_len, ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  value_ptr = JS_ToCStringLenRaw(ctx, &value_len, argv[1]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[2]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  input_js_contract_name(&contract_name, &contract_name_len, GET);
  key_with_prefix_len = contract_name_len + 7 + key_len;
  key_with_account_prefix = malloc(key_with_prefix_len);
  strncpy(key_with_account_prefix, contract_name, contract_name_len);
  strncpy(key_with_account_prefix+contract_name_len, "/state/", 7);
  memcpy(key_with_account_prefix+contract_name_len+7, key_ptr, key_len);

  ret = storage_write_enclave(key_with_prefix_len, (uint64_t)key_with_account_prefix, value_len, (uint64_t)value_ptr, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_jsvm_storage_read(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  char *key_with_account_prefix, *contract_name;
  size_t key_len, key_with_prefix_len;
  uint64_t register_id, contract_name_len, ret;

  input_js_contract_name(&contract_name, &contract_name_len, GET);
  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  key_with_prefix_len = contract_name_len + 7 + key_len;
  key_with_account_prefix = malloc(key_with_prefix_len);
  strncpy(key_with_account_prefix, contract_name, contract_name_len);
  strncpy(key_with_account_prefix+contract_name_len, "/state/", 7);
  memcpy(key_with_account_prefix+contract_name_len+7, key_ptr, key_len);

  ret = storage_read(key_with_prefix_len, (uint64_t)key_with_account_prefix, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_storage_read(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  const char *key_ptr;
  size_t key_len;
  uint64_t register_id;
  uint64_t ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  ret = storage_read(key_len, (uint64_t)key_ptr, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_jsvm_storage_remove(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  char *key_with_account_prefix, *contract_name;
  size_t key_len, key_with_prefix_len;
  uint64_t register_id, contract_name_len, ret;

  input_js_contract_name(&contract_name, &contract_name_len, GET);
  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }
  key_with_prefix_len = contract_name_len + 7 + key_len;
  key_with_account_prefix = malloc(key_with_prefix_len);
  strncpy(key_with_account_prefix, contract_name, contract_name_len);
  strncpy(key_with_account_prefix+contract_name_len, "/state/", 7);
  memcpy(key_with_account_prefix+contract_name_len+7, key_ptr, key_len);

  ret = storage_remove_enclave(key_with_prefix_len, (uint64_t)key_with_account_prefix, register_id);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_jsvm_storage_has_key(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  char *key_with_account_prefix, *contract_name;
  size_t key_len, key_with_prefix_len;
  uint64_t register_id, contract_name_len, ret;

  input_js_contract_name(&contract_name, &contract_name_len, GET);
  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  key_with_prefix_len = contract_name_len + 7 + key_len;
  key_with_account_prefix = malloc(key_with_prefix_len);
  strncpy(key_with_account_prefix, contract_name, contract_name_len);
  strncpy(key_with_account_prefix+contract_name_len, "/state/", 7);
  memcpy(key_with_account_prefix+contract_name_len+7, key_ptr, key_len);

  ret = storage_has_key(key_with_prefix_len, (uint64_t)key_with_account_prefix);
  return JS_NewBigUint64(ctx, ret);
}

static JSValue near_storage_has_key(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *key_ptr;
  size_t key_len;
  uint64_t ret;

  key_ptr = JS_ToCStringLenRaw(ctx, &key_len, argv[0]);
  ret = storage_has_key(key_len, (uint64_t)key_ptr);
  return JS_NewBigUint64(ctx, ret);
}

static void js_add_near_host_functions(JSContext* ctx);

static void jsvm_call(uint64_t contract_len, char *contract, uint64_t method_len, char *method, uint64_t args_len, char *args, bool has_prev_call)
{
  char key[69];
  int has_read;
  size_t code_len;
  char *code;

  JSRuntime *rt;
  JSContext *ctx;
  JSValue mod_obj, fun_obj, result, error, error_message, error_stack;
  const char *error_message_c, *error_stack_c;
  char *error_c;
  size_t msg_len, stack_len;

  char *prev_contract, *prev_method, *prev_args;
  uint64_t prev_contract_len, prev_method_len, prev_args_len;

  if (has_prev_call) {
    // called from a cross contract call
    // keep track of previous contract name, method and args
    input_js_contract_name(&prev_contract, &prev_contract_len, GET);
    input_method_name(&prev_method, &prev_method_len, GET);
    input_args(&prev_args, &prev_args_len, GET);
  }

  input_js_contract_name(&contract, &contract_len, SET);
  input_method_name(&method, &method_len, SET);
  input_args(&args, &args_len, SET);

  strncpy(key, contract, contract_len);
  strncpy(key+contract_len, "/code", 5);
  has_read = storage_read(contract_len+5, (uint64_t)key, UINT64_MAX);
  if (!has_read) {
    panic_str("JS contract does not exist");
  }
  code_len = register_len(UINT64_MAX);
  code = malloc(code_len);
  read_register(UINT64_MAX, (uint64_t)code);

  rt = JS_NewRuntime();
  ctx = JS_NewCustomContext(rt);
  js_add_near_host_functions(ctx);
  mod_obj = js_load_module_binary(ctx, (const uint8_t *)code, code_len);
  fun_obj = JS_GetProperty(ctx, mod_obj, JS_NewAtom(ctx, method));
  result = JS_Call(ctx, fun_obj, mod_obj, 0, NULL);
  if (JS_IsException(result)) {
    error = JS_GetException(ctx);
    error_message = JS_GetPropertyStr(ctx, error, "message");
    error_stack = JS_GetPropertyStr(ctx, error, "stack");
    error_message_c = JS_ToCStringLen(ctx, &msg_len, error_message);
    error_stack_c = JS_ToCStringLen(ctx, &stack_len, error_stack);
    error_c = malloc(msg_len+1+stack_len);
    memcpy(error_c, error_message_c, msg_len);
    error_c[msg_len] = '\n';
    strncpy(error_c+msg_len+1, error_stack_c, stack_len);
    panic_utf8(msg_len+1+stack_len, (uint64_t)error_c);
  }
  js_std_loop(ctx);

  if (has_prev_call) {
    // restore previous contract name, method and args
    input_js_contract_name(&prev_contract, &prev_contract_len, SET);
    input_method_name(&prev_method, &prev_method_len, SET);
    input_args(&prev_args, &prev_args_len, SET);
  }
}

static JSValue near_jsvm_call(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *contract_name_ptr, *method_name_ptr, *arguments_ptr;
  char *call_ret;
  size_t contract_name_len, method_name_len, arguments_len;
  uint64_t register_id, ret_len;

  contract_name_ptr = JS_ToCStringLen(ctx, &contract_name_len, argv[0]);
  method_name_ptr = JS_ToCStringLen(ctx, &method_name_len, argv[1]);
  arguments_ptr = JS_ToCStringLenRaw(ctx, &arguments_len, argv[2]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[3]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }

  jsvm_call(contract_name_len, (char *)contract_name_ptr, method_name_len, (char *)method_name_ptr, arguments_len, (char *)arguments_ptr, true);
  jsvm_call_returns(&call_ret, &ret_len, GET);
  write_register(register_id, ret_len, (uint64_t)call_ret);
  return JS_UNDEFINED;
}

static JSValue near_validator_stake(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *account_id_ptr;
  size_t account_id_len;
  uint64_t stake_ptr[2];

  account_id_ptr = JS_ToCStringLen(ctx, &account_id_len, argv[0]);
  validator_stake(account_id_len, (uint64_t)account_id_ptr, (uint64_t)stake_ptr);

  return u128_to_quickjs(ctx, stake_ptr);
}

static JSValue near_validator_total_stake(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t stake_ptr[2];

  validator_total_stake((uint64_t)stake_ptr);
  return u128_to_quickjs(ctx, stake_ptr);
}

static JSValue near_storage_byte_cost(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {
  JSValue value;
  bf_t *a;
  
  value = JS_NewBigInt(ctx);
  a = JS_GetBigInt(value);
  bf_atof(a, STORAGE_PRICE_PER_BYTE, NULL, 10, BF_PREC_INF, BF_RNDZ);
  return value;
}

#ifdef NIGHTLY
static JSValue near_alt_bn128_g1_multiexp(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }

  alt_bn128_g1_multiexp(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_alt_bn128_g1_sum(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  uint64_t register_id;
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  if (JS_ToUint64Ext(ctx, &register_id, argv[1]) < 0) {
    return JS_ThrowTypeError(ctx, "Expect Uint64 for register_id");
  }

  alt_bn128_g1_sum(data_len, (uint64_t)data_ptr, register_id);
  return JS_UNDEFINED;
}

static JSValue near_alt_bn128_pairing_check(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
  const char *data_ptr;
  size_t data_len;
  uint64_t ret;

  data_ptr = JS_ToCStringLenRaw(ctx, &data_len, argv[0]);
  
  ret = alt_bn128_pairing_check(data_len, (uint64_t)data_ptr);
  return JS_NewBigUint64(ctx, ret);
}
#endif

static JSValue near_debug_log(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
#ifdef SANDBOX
{
  const char *data_ptr;
  size_t data_len;

  data_ptr = JS_ToCStringLen(ctx, &data_len, argv[0]);
  
  sandbox_debug_log(data_len, (uint64_t)data_ptr);
  return JS_UNDEFINED;
}
#else
{
  return JS_UNDEFINED;
}
#endif

static void js_add_near_host_functions(JSContext* ctx) {
  JSValue global_obj, env;

  global_obj = JS_GetGlobalObject(ctx);
  env = JS_NewObject(ctx);

  JS_SetPropertyStr(ctx, env, "read_register", JS_NewCFunction(ctx, near_read_register, "read_register", 1));
  JS_SetPropertyStr(ctx, env, "register_len", JS_NewCFunction(ctx, near_register_len, "register_len", 1));
  JS_SetPropertyStr(ctx, env, "write_register", JS_NewCFunction(ctx, near_write_register, "write_register", 2));
  JS_SetPropertyStr(ctx, env, "signer_account_id", JS_NewCFunction(ctx, near_signer_account_id, "signer_account_id", 1));
  JS_SetPropertyStr(ctx, env, "signer_account_pk", JS_NewCFunction(ctx, near_signer_account_pk, "signer_account_pk", 1));
  JS_SetPropertyStr(ctx, env, "predecessor_account_id", JS_NewCFunction(ctx, near_predecessor_account_id, "predecessor_account_id", 1));
  JS_SetPropertyStr(ctx, env, "block_index", JS_NewCFunction(ctx, near_block_index, "block_index", 0));
  JS_SetPropertyStr(ctx, env, "block_timestamp", JS_NewCFunction(ctx, near_block_timestamp, "block_timestamp", 0));
  JS_SetPropertyStr(ctx, env, "epoch_height", JS_NewCFunction(ctx, near_epoch_height, "epoch_height", 0));
  JS_SetPropertyStr(ctx, env, "attached_deposit", JS_NewCFunction(ctx, near_attached_deposit, "attached_deposit", 0));
  JS_SetPropertyStr(ctx, env, "prepaid_gas", JS_NewCFunction(ctx, near_prepaid_gas, "prepaid_gas", 0));
  JS_SetPropertyStr(ctx, env, "used_gas", JS_NewCFunction(ctx, near_used_gas, "used_gas", 0));
  JS_SetPropertyStr(ctx, env, "random_seed", JS_NewCFunction(ctx, near_random_seed, "random_seed", 1));
  JS_SetPropertyStr(ctx, env, "sha256", JS_NewCFunction(ctx, near_sha256, "sha256", 2));
  JS_SetPropertyStr(ctx, env, "keccak256", JS_NewCFunction(ctx, near_keccak256, "keccak256", 2));
  JS_SetPropertyStr(ctx, env, "keccak512", JS_NewCFunction(ctx, near_keccak512, "keccak512", 2));
  JS_SetPropertyStr(ctx, env, "ripemd160", JS_NewCFunction(ctx, near_ripemd160, "ripemd160", 2));
  JS_SetPropertyStr(ctx, env, "ecrecover", JS_NewCFunction(ctx, near_ecrecover, "ecrecover", 5));
  JS_SetPropertyStr(ctx, env, "panic", JS_NewCFunction(ctx, near_panic, "panic", 1));
  JS_SetPropertyStr(ctx, env, "panic_utf8", JS_NewCFunction(ctx, near_panic_utf8, "panic_utf8", 1));
  JS_SetPropertyStr(ctx, env, "log", JS_NewCFunction(ctx, near_log, "log", 1));
  JS_SetPropertyStr(ctx, env, "log_utf8", JS_NewCFunction(ctx, near_log_utf8, "log_utf8", 1));
  JS_SetPropertyStr(ctx, env, "log_utf16", JS_NewCFunction(ctx, near_log_utf16, "log_utf16", 1));
  JS_SetPropertyStr(ctx, env, "storage_read", JS_NewCFunction(ctx, near_storage_read, "storage_read", 2));
  JS_SetPropertyStr(ctx, env, "storage_has_key", JS_NewCFunction(ctx, near_storage_has_key, "storage_has_key", 1));
  JS_SetPropertyStr(ctx, env, "validator_stake", JS_NewCFunction(ctx, near_validator_stake, "validator_stake", 2));
  JS_SetPropertyStr(ctx, env, "validator_total_stake", JS_NewCFunction(ctx, near_validator_total_stake, "validator_total_stake", 1));
  #ifdef NIGHTLY
  JS_SetPropertyStr(ctx, env, "alt_bn128_g1_multiexp", JS_NewCFunction(ctx, near_alt_bn128_g1_multiexp, "alt_bn128_g1_multiexp", 2));
  JS_SetPropertyStr(ctx, env, "alt_bn128_g1_sum", JS_NewCFunction(ctx, near_alt_bn128_g1_sum, "alt_bn128_g1_sum", 2));
  JS_SetPropertyStr(ctx, env, "alt_bn128_pairing_check", JS_NewCFunction(ctx, near_alt_bn128_pairing_check, "alt_bn128_pairing_check", 1));
  #endif

  // APIs that unique to JSVM
  JS_SetPropertyStr(ctx, env, "jsvm_account_id", JS_NewCFunction(ctx, near_jsvm_account_id, "jsvm_account_id", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_js_contract_name", JS_NewCFunction(ctx, near_jsvm_js_contract_name, "jsvm_js_contract_name", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_method_name", JS_NewCFunction(ctx, near_jsvm_method_name, "jsvm_method_name", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_args", JS_NewCFunction(ctx, near_jsvm_args, "jsvm_args", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_storage_write", JS_NewCFunction(ctx, near_jsvm_storage_write, "jsvm_storage_write", 3));
  JS_SetPropertyStr(ctx, env, "jsvm_storage_read", JS_NewCFunction(ctx, near_jsvm_storage_read, "jsvm_storage_read", 2));
  JS_SetPropertyStr(ctx, env, "jsvm_storage_has_key", JS_NewCFunction(ctx, near_jsvm_storage_has_key, "jsvm_storage_has_key", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_storage_remove", JS_NewCFunction(ctx, near_jsvm_storage_remove, "jsvm_storage_remove", 2));
  JS_SetPropertyStr(ctx, env, "jsvm_value_return", JS_NewCFunction(ctx, near_jsvm_value_return, "jsvm_value_return", 1));
  JS_SetPropertyStr(ctx, env, "jsvm_call", JS_NewCFunction(ctx, near_jsvm_call, "jsvm_call", 4));

  JS_SetPropertyStr(ctx, global_obj, "env", env);

  JSValue debug = JS_NewObject(ctx);
  JS_SetPropertyStr(ctx, debug, "log", JS_NewCFunction(ctx, near_debug_log, "log", 1));
  JS_SetPropertyStr(ctx, global_obj, "debug", debug);
}

JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
                int argc, JSValueConst *argv);

void _start() {}

void deploy_js_contract () __attribute__((export_name("deploy_js_contract"))) {
  char account[64], *code;
  size_t account_len, code_len;
  char key[69];

  predecessor_account_id(0);
  read_register(0, (uint64_t)account);
  account_len = register_len(0);

  input(1);
  code_len = register_len(1);
  code = malloc(code_len);
  read_register(1, (uint64_t)code);
  strncpy(key, account, account_len);
  strncpy(key+account_len, "/code", 5);
  storage_write_enclave(account_len+5, (uint64_t)key, code_len, (uint64_t)code, 2);
  refund_storage_deposit();
}

void remove_js_contract () __attribute__((export_name("remove_js_contract"))) {
  char account[64];
  size_t account_len;
  char key[69];

  predecessor_account_id(0);
  read_register(0, (uint64_t)account);
  account_len = register_len(0);
  strncpy(key, account, account_len);
  strncpy(key+account_len, "/code", 5);
  storage_remove_enclave(account_len+5, (uint64_t)key, 1);
  refund_storage_deposit();
}

static void call_js_contract_internal() {
  char *in, *contract, *method, *args;
  uint64_t contract_len = 0, method_len = 0, args_len = 0;
  size_t in_len;

  input(0);
  in_len = register_len(0);
  in = malloc(in_len);
  read_register(0, (uint64_t)in);
  for (size_t i = 0; i < in_len; i++) {
    if (in[i] == '\0') {
      contract_len = i;
      contract = in;
      break;
    }
  }
  for (size_t i = contract_len+1; i < in_len; i++) {
    if (in[i] == '\0') {
      method = in + contract_len + 1;
      method_len = i - contract_len - 1;
      args_len = in_len - contract_len - method_len - 2;
      args = in + i + 1;
      break;
    }
  }

  if (contract_len == 0) {
    panic_str("JS contract name is empty");
  }
  if (contract_len > 64) {
    panic_str("JS contract name is too long, invalid NEAR account");
  }
  if (method_len == 0) {
    panic_str("method name is empty");
  }
  
  jsvm_call(contract_len, contract, method_len, method, args_len, args, false);
}

void call_js_contract () __attribute__((export_name("call_js_contract"))) {
  call_js_contract_internal();
  refund_storage_deposit(); 
}

void view_js_contract () __attribute__((export_name("view_js_contract"))) {
  call_js_contract_internal();
}
'''
'''--- jsvm/tests/README.md ---
# NEAR-SDK-JS Tests

This tests the functionality of high level APIs of NEAR-SDK-JS. Currently, it directly tests all collections and indirectly tests all decorators, serialization/deserialization, utils, code generation and some important APIs. Majority of near-sdk-js can be seen as tested.

# Run tests
```
yarn
yarn build
yarn test
```

# Add a new test

Create a test contract that covers the API you want to test in `src/`. Add a build command in `build.sh`. Write ava test in `__tests__`.
'''
'''--- jsvm/tests/__tests__/bytes.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/bytes.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Log expected types work', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'log_expected_input_tests', ''), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "abc",
            "",
            "333",
            '\x00\x01\xff',
            '\xe6\xb0\xb4',
            "",
            ""
        ]
    );
});

test('Log unexpected types not logging', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'log_unexpected_input_tests', ''), { attachedDeposit: '100000000000000000000000' });
    // logUtf8 and logUtf16 only works with bytes, trying to log it with string is unexpected and behavior is undefined
    // in this specific case, it logs nothing
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "",
            "",
        ]
    );
});

test('Log invalid utf-8 sequence panic', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'log_invalid_utf8_sequence_test', ''), { attachedDeposit: '100000000000000000000000' });
    // console.log(JSON.stringify(r, null, 2))
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
});

test('Log invalid utf-16 sequence panic', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'log_invalid_utf16_sequence_test', ''), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-16 sequence.'
    );
});

function encodeStateKey(k) {
    return Buffer.concat([Buffer.from('test-contract.test.near/state/'), Buffer.from(k)]).toString('base64')
}

test('storage write bytes tests', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'storage_write_bytes', ''), { attachedDeposit: '100000000000000000000000' });
    let stateMap = new Map()
    // viewState doesn't work, because it tries to convert key to utf-8 string, which is not
    let state = await jsvm.viewStateRaw()
    for (let {key, value} of state) {
        stateMap.set(key, value)
    }

    t.deepEqual(
        stateMap.get(encodeStateKey('abc')),
        Buffer.from('def').toString('base64')
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([0x00, 0x01, 0xff])),
        Buffer.from([0xe6, 0xb0, 0xb4]).toString('base64')
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([0xe6, 0xb0, 0xb4])),
        Buffer.from([0x00, 'a'.charCodeAt(0), 'b'.charCodeAt(0)]).toString('base64')
    );
});

test('storage write unexpected types tests', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'storage_write_unexpected_input', ''), { attachedDeposit: '100000000000000000000000' });
    let stateMap = new Map()
    // viewState doesn't work, because it tries to convert key to utf-8 string, which is not
    let state = await jsvm.viewStateRaw()
    for (let {key, value} of state) {
        stateMap.set(key, value)
    }
    console.log(await jsvm.viewState())

    t.deepEqual(
        stateMap.get(encodeStateKey('123')),
        Buffer.from('456').toString('base64')
    );
    // pass in utf-8 string instead of bytes, key and value become empty 
    t.deepEqual(
        stateMap.get(encodeStateKey([0xe6, 0xb0, 0xb4])),
        undefined
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([])),
        ''
    );
});

test('Storage read bytes tests', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'storage_write_bytes', ''), { attachedDeposit: '100000000000000000000000' });
    let r = await jsvm.viewRaw('view_js_contract', encodeCall(testContract.accountId, 'storage_read_ascii_bytes', ''))
    console.log(r)
    t.deepEqual(
        r.result,
        [100, 101, 102]
    );

    r = await jsvm.viewRaw('view_js_contract', encodeCall(testContract.accountId, 'storage_read_arbitrary_bytes_key_utf8_sequence_bytes_value', ''))
    t.deepEqual(
        r.result,
        [0xe6, 0xb0, 0xb4]
    );

    r = await jsvm.viewRaw('view_js_contract', encodeCall(testContract.accountId, 'storage_read_utf8_sequence_bytes_key_arbitrary_bytes_value', ''))
    t.deepEqual(
        r.result,
        [0x00, 'a'.charCodeAt(0), 'b'.charCodeAt(0)]
    );
});

test('panic tests', async t => {
    const { jsvm, ali, testContract } = t.context.accounts;
    let r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_test', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_ascii_test', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: abc'
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_js_number', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: 356'
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_js_undefined', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_js_null', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: null'
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panic_utf8_test', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panicUtf8_valid_utf8_sequence', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'panicUtf8_invalid_utf8_sequence', ''));
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
})
'''
'''--- jsvm/tests/__tests__/function-params.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/function-params.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Developer can pass parameters as dictionary', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set_values', { param1: 'newVal1', param2: 'newVal2', param3: 'newVal3' }), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get_values', {})),
        { val3: 'newVal3', val2: 'newVal2', val1: 'newVal1' }
    );
});

'''
'''--- jsvm/tests/__tests__/lookup-map.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/lookup-map.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('LookupMap set() get()', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        null
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'containsKey', { key: 'hello' })),
        false
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello', value: 'world' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        'world'
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'containsKey', { key: 'hello' })),
        true
    );
});

test('LookupMap update, remove', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello', value: 'world' }), { attachedDeposit: '100000000000000000000000' });
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello1', value: 'world0' }), { attachedDeposit: '100000000000000000000000' });

    // update a value, len shouldn't change
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello1', value: 'world1' }), { attachedDeposit: '100000000000000000000000' });
    // update should have effect
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello1' })),
        'world1'
    );
    // not update key should not changed
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        'world'
    );
    // remove non existing element should not error
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello3' }), { attachedDeposit: '100000000000000000000000' });
    // remove existing key should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello1' }));
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'containsKey', { key: 'hello1' })),
        false
    );
    // not removed key should not affected
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        'world'
    );
});

test('LookupMap extend', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        'world'
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello1' })),
        'world1'
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello2' })),
        'world2'
    );
})
'''
'''--- jsvm/tests/__tests__/lookup-set.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/lookup-set.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('LookupSet set() contains()', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello' })),
        false
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello' })),
        true
    );
});

test('LookupSet remove', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello1' }), { attachedDeposit: '100000000000000000000000' });

    // remove non existing element should not error
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello3' }), { attachedDeposit: '100000000000000000000000' });
    // remove existing key should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello1' }));
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello1' })),
        false
    );
    // not removed key should not affected
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello' })),
        true
    );
});

test('LookupSet extend', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { keys: ['hello', 'world', 'hello1'] }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello' })),
        true
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'hello1' })),
        true
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { key: 'world' })),
        true
    );
})
'''
'''--- jsvm/tests/__tests__/unordered-map.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/unordered-map.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('UnorderedMap is empty by default', async t => {
    const { root, jsvm, testContract } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {}));
    t.is(result, 0);
});

test('UnorderedMap set() get()', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        null
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello', value: 'world' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello' })),
        'world'
    );
});

test('UnorderedMap insert, update, len and iterate', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        0
    );
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello', value: 'world' }), { attachedDeposit: '100000000000000000000000' });
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello1', value: 'world0' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        2
    );

    // update a value, len shouldn't change
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello1', value: 'world1' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        2
    );
    // update should have effect
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { key: 'hello1' })),
        'world1'
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello2', value: 'world2' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        3
    );

    // Try to set a key with same value, len shouldn't change
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { key: 'hello2', value: 'world2' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        3
    );

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );
});

test('UnorderedMap extend, remove, clear', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] }), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );

    // remove non existing element should not error
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello3' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );

    // remove not the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        [['hello2', 'world2'], ['hello1', 'world1']]
    );

    // remove the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello1' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        [['hello2', 'world2']]
    );

    // remove when length is 1 should work
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        1
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { key: 'hello2' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'clear', {}), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );
})
'''
'''--- jsvm/tests/__tests__/unordered-set.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/unordered-set.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('UnorderedSet is empty by default', async t => {
    const { root, jsvm, testContract } = t.context.accounts;
    const result = await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {}));
    t.is(result, 0);
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );
});

test('UnorderedSet set() contains()', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { element: 'hello' })),
        false
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { element: 'hello' }), { attachedDeposit: '100000000000000000000000' });

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'contains', { element: 'hello' })),
        true
    );
});

test('UnorderedSet insert, len and iterate', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        0
    );
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { element: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        1
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { element: 'hello1' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        2
    );

    // insert the same value, len shouldn't change
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'set', { element: 'hello1' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        2
    );

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'hello1']
    );
});

test('UnorderedSet extend, remove, clear', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { elements: ['hello', 'world', 'hello1'] }), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'world', 'hello1']
    );

    // remove non existing element should not error
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { element: 'hello3' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'world', 'hello1']
    );

    // remove not the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { element: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello1', 'world']
    );

    // remove the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { element: 'world' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello1']
    );

    // remove when length is 1 should work
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        1
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'remove', { element: 'hello1' }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { elements: ['hello', 'world', 'hello1'] }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'world', 'hello1']
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    // clear should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'clear', {}), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );
})
'''
'''--- jsvm/tests/__tests__/vector.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the jsvm contract.
    const jsvm = await root.devDeploy(
        '../../jsvm/build/jsvm.wasm',
    );

    // Deploy test JS contract
    const testContract = await root.createSubAccount('test-contract');
    let contract_base64 = (await readFile('build/vector.base64')).toString();
    await testContract.call(jsvm, 'deploy_js_contract', Buffer.from(contract_base64, 'base64'), { attachedDeposit: '400000000000000000000000' });
    await testContract.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'init', {}), { attachedDeposit: '400000000000000000000000' });

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, jsvm, testContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Vector is empty by default', async t => {
    const { root, jsvm, testContract } = t.context.accounts;
    let result = await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {}));
    t.is(result, 0);
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );
});

test('Vector push, get, pop, replace', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'push', { value: 'hello' }), { attachedDeposit: '100000000000000000000000' });
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'push', { value: 'world' }), { attachedDeposit: '100000000000000000000000' });
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'push', { value: 'aaa' }), { attachedDeposit: '100000000000000000000000' });
    let result = await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {}));
    t.is(result, 3);
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 0 })),
        'hello'
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 2 })),
        'aaa'
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 3 })),
        null
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'pop', {}));
    result = await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {}));
    t.is(result, 2);
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 2 })),
        null
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 1 })),
        'world'
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'replace', { index: 1, value: 'aaa' }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'get', { index: 1 })),
        'aaa'
    );
});

test('Vector extend, toArray, swapRemove, clear', async t => {
    const { ali, jsvm, testContract } = t.context.accounts;

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { kvs: ['hello', 'world', 'aaa'] }), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'world', 'aaa']
    );

    // swapRemove non existing element should error
    const error1 = await t.throwsAsync(() => ali.call(
        jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'swapRemove', { index: 3 })
    ));
    t.assert(error1.message.includes(`Index out of bounds`));
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['hello', 'world', 'aaa']
    );

    // swapRemove not the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'swapRemove', { index: 0 }));
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['aaa', 'world']
    );

    // swapRemove the last one should work
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'swapRemove', { index: 1 }));
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        ['aaa']
    );

    // swapRemove when length is 1 should work
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'len', {})),
        1
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'swapRemove', { index: 0 }), { attachedDeposit: '100000000000000000000000' });
    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );

    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'extend', { kvs: ['hello', 'world', 'aaa'] }), { attachedDeposit: '100000000000000000000000' });
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        false
    );
    await ali.call(jsvm, 'call_js_contract', encodeCall(testContract.accountId, 'clear', {}), { attachedDeposit: '100000000000000000000000' });

    t.deepEqual(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'toArray', {})),
        []
    );
    t.is(
        await jsvm.view('view_js_contract', encodeCall(testContract.accountId, 'isEmpty', {})),
        true
    );
})
'''
'''--- jsvm/tests/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ]
}

'''
'''--- jsvm/tests/build.sh ---
#!/usr/bin/env bash
## Run this script with `npm run build`

near-sdk-js build src/unordered-map.js build/unordered-map.base64
near-sdk-js build src/vector.js build/vector.base64
near-sdk-js build src/lookup-map.js build/lookup-map.base64
near-sdk-js build src/lookup-set.js build/lookup-set.base64
near-sdk-js build src/unordered-set.js build/unordered-set.base64
near-sdk-js build src/function-params.js build/function-params.base64
near-sdk-js build src/bytes.js build/bytes.base64
'''
'''--- jsvm/tests/jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- jsvm/tests/package.json ---
{
    "name": "tests",
    "version": "1.0.0",
    "description": "near-sdk-js tests",
    "main": "index.js",
    "type": "module",
    "scripts": {
        "build": "./build.sh",
        "rebuild": "cd ../../ && yarn build && cd jsvm/tests && rm -rf node_modules && rm -rf build && yarn && yarn build",
        "test": "ava"
    },
    "author": "Near Inc <hello@nearprotocol.com>",
    "license": "Apache-2.0",
    "dependencies": {
        "near-sdk-js": "file:../../"
    },
    "devDependencies": {
        "ava": "^4.2.0",
        "near-workspaces": "^3.0.0"
    }
}
'''
'''--- jsvm/tests/src/bytes.js ---
import {near, bytes} from 'near-sdk-js'

export function log_expected_input_tests() {
    // log ascii string
    near.log('abc')
    // log string with utf-8 chars
    near.log('')
    // log number
    near.log(333)
    // log aribrary byte sequence
    near.log(bytes('\x00\x01\xff'))
    // log valid utf8 seqence
    near.log(bytes('\xe6\xb0\xb4'))

    // log valid utf8 sequence 
    near.logUtf8(bytes('\xe6\xb0\xb4'))
    // log valid utf16 sequence
    near.logUtf16(bytes('\x34\x6c'))
}

export function log_unexpected_input_tests() {
    // log non-bytes with logUtf8
    near.logUtf8('')
    // log non-bytes with logUtf16
    near.logUtf16('')
}

export function log_invalid_utf8_sequence_test() {
    near.logUtf8(bytes('\x00\x01\xff'))
}

export function log_invalid_utf16_sequence_test() {
    near.logUtf16(bytes('\x00\x01\xff'))
}

export function storage_write_bytes() {
    near.jsvmStorageWrite(bytes('abc'), bytes('def'))
    near.jsvmStorageWrite(bytes('\x00\x01\xff'), bytes('\xe6\xb0\xb4'))
    near.jsvmStorageWrite(bytes('\xe6\xb0\xb4'), bytes('\x00ab'))
}

export function storage_write_unexpected_input() {
    near.jsvmStorageWrite('', '')
    near.jsvmStorageWrite(123, 456)
}

export function storage_read_ascii_bytes() {
    near.jsvmValueReturn(near.jsvmStorageRead(bytes('abc')))
}

export function storage_read_arbitrary_bytes_key_utf8_sequence_bytes_value() {
    near.jsvmValueReturn(near.jsvmStorageRead(bytes('\x00\x01\xff')))
}

export function storage_read_utf8_sequence_bytes_key_arbitrary_bytes_value() {
    near.jsvmValueReturn(near.jsvmStorageRead(bytes('\xe6\xb0\xb4')))
}

export function panic_test() {
    near.panic()
}

export function panic_ascii_test() {
    near.panic('abc')
}

export function panic_js_number() {
    near.panic(356)
}

export function panic_js_undefined() {
    near.panic(undefined)
}

export function panic_js_null() {
    near.panic(null)
}

export function panic_utf8_test() {
    near.panic('')
}

export function panicUtf8_valid_utf8_sequence() {
    near.panicUtf8(bytes('\xe6\xb0\xb4'))
}

export function panicUtf8_invalid_utf8_sequence() {
    near.panicUtf8(bytes('\x00\x01\xff'))
}
'''
'''--- jsvm/tests/src/function-params.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
} from 'near-sdk-js'

/**
 * Simple contract to test function parameters
 */
@NearBindgen
class FunctionParamsTestContract extends NearContract {
    constructor() {
        super()
        this.val1 = 'default1';
        this.val2 = 'default2';
        this.val3 = 'default3';
    }

    @call
    set_values({ param1, param2, param3 }) {
        near.log(JSON.stringify({ param1, param2, param3 }));
        this.val1 = param1;
        this.val2 = param2;
        this.val3 = param3;
    }

    @view
    get_values() {
        return { val3: this.val3, val2: this.val2, val1: this.val1 }
    }
}
'''
'''--- jsvm/tests/src/lookup-map.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    LookupMap
} from 'near-sdk-js'

@NearBindgen
class LookupMapTestContract extends NearContract {
    constructor() {
        super()
        this.lookupMap = new LookupMap('a');
    }

    deserialize() {
        super.deserialize();
        this.lookupMap = Object.assign(new LookupMap, this.lookupMap);
    }

    @view
    get({key}) {
        return this.lookupMap.get(key);
    }

    @view
    containsKey({key}) {
        return this.lookupMap.containsKey(key);
    }

    @call
    set({key, value}) {
        this.lookupMap.set(key, value);
    }

    @call
    remove({key}) {
        this.lookupMap.remove(key);
    }

    @call
    extend({kvs}) {
        this.lookupMap.extend(kvs);
    }
}

'''
'''--- jsvm/tests/src/lookup-set.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    LookupSet
} from 'near-sdk-js'

@NearBindgen
class LookupSetTestContract extends NearContract {
    constructor() {
        super()
        this.lookupSet = new LookupSet('a');
    }

    deserialize() {
        super.deserialize();
        this.lookupSet = Object.assign(new LookupSet, this.lookupSet);
    }

    @view
    contains({key}) {
        return this.lookupSet.contains(key);
    }

    @call
    set({key}) {
        this.lookupSet.set(key);
    }

    @call
    remove({key}) {
        this.lookupSet.remove(key);
    }

    @call
    extend({keys}) {
        this.lookupSet.extend(keys);
    }
}

'''
'''--- jsvm/tests/src/unordered-map.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    UnorderedMap,
    Vector
} from 'near-sdk-js'

@NearBindgen
class UnorderedMapTestContract extends NearContract {
    constructor() {
        super()
        this.unorderedMap = new UnorderedMap('a');
    }

    deserialize() {
        super.deserialize()
        this.unorderedMap.keys = Object.assign(new Vector, this.unorderedMap.keys)
        this.unorderedMap.values = Object.assign(new Vector, this.unorderedMap.values)
        this.unorderedMap = Object.assign(new UnorderedMap, this.unorderedMap)
    }

    @view
    len() {
        return this.unorderedMap.len();
    }

    @view
    isEmpty() {
        return this.unorderedMap.isEmpty();
    }

    @view
    serializeIndex({index}) {
        return this.unorderedMap.serializeIndex(index);
    }

    @view
    deserializeIndex({rawIndex}) {
        return this.unorderedMap.deserializeIndex(rawIndex);
    }

    @view
    getIndexRaw({key}) {
        return this.unorderedMap.getIndexRaw(key);
    }

    @view
    get({key}) {
        return this.unorderedMap.get(key);
    }

    @call
    set({key, value}) {
        this.unorderedMap.set(key, value);
    }

    @call
    remove({key}) {
        this.unorderedMap.remove(key);
    }

    @call
    clear() {
        this.unorderedMap.clear();
    }

    @view
    toArray() {
        return this.unorderedMap.toArray();
    }

    @call
    extend({kvs}) {
        this.unorderedMap.extend(kvs);
    }
}

'''
'''--- jsvm/tests/src/unordered-set.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    UnorderedSet,
    Vector
} from 'near-sdk-js'

@NearBindgen
class UnorderedSetTestContract extends NearContract {
    constructor() {
        super()
        this.unorderedSet = new UnorderedSet('a');
    }

    deserialize() {
        super.deserialize()
        this.unorderedSet.elements = Object.assign(new Vector, this.unorderedSet.elements)
        this.unorderedSet = Object.assign(new UnorderedSet, this.unorderedSet)
    }

    @view
    len() {
        return this.unorderedSet.len();
    }

    @view
    isEmpty() {
        return this.unorderedSet.isEmpty();
    }

    @view
    contains({element}) {
        return this.unorderedSet.contains(element);
    }

    @call
    set({element}) {
        this.unorderedSet.set(element);
    }

    @call
    remove({element}) {
        this.unorderedSet.remove(element);
    }

    @call
    clear() {
        this.unorderedSet.clear();
    }

    @view
    toArray() {
        return this.unorderedSet.toArray();
    }

    @call
    extend({elements}) {
        this.unorderedSet.extend(elements);
    }
}

'''
'''--- jsvm/tests/src/vector.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    Vector
} from 'near-sdk-js'

@NearBindgen
class VectorTestContract extends NearContract {
    constructor() {
        super()
        this.vector = new Vector('a');
    }

    deserialize() {
        super.deserialize();
        this.vector = Object.assign(new Vector, this.vector);
    }

    @view
    len() {
        return this.vector.len();
    }

    @view
    isEmpty() {
        return this.vector.isEmpty();
    }

    @view
    get({index}) {
        return this.vector.get(index);
    }

    @call
    push({value}) {
        this.vector.push(value);
    }

    @call
    pop() {
        this.vector.pop();
    }

    @call
    clear() {
        this.vector.clear();
    }

    @view
    toArray() {
        return this.vector.toArray();
    }

    @call
    extend({kvs}) {
        this.vector.extend(kvs);
    }

    @call
    replace({index, value}) {
        this.vector.replace(index, value);
    }

    @call
    swapRemove({index}) {
        this.vector.swapRemove(index);
    }
}

'''
'''--- lib/api.d.ts ---
import { Bytes } from "./utils";
export declare function log(...params: any[]): void;
export declare function signerAccountId(): string;
export declare function signerAccountPk(): Bytes;
export declare function predecessorAccountId(): string;
export declare function blockIndex(): BigInt;
export declare function blockHeight(): BigInt;
export declare function blockTimestamp(): BigInt;
export declare function epochHeight(): BigInt;
export declare function attachedDeposit(): BigInt;
export declare function prepaidGas(): BigInt;
export declare function usedGas(): BigInt;
export declare function randomSeed(): Bytes;
export declare function sha256(value: Bytes): Bytes;
export declare function keccak256(value: Bytes): Bytes;
export declare function keccak512(value: Bytes): Bytes;
export declare function ripemd160(value: Bytes): Bytes;
export declare function ecrecover(hash: Bytes, sig: Bytes, v: number, malleabilityFlag: number): Bytes | null;
export declare function panic(msg?: string): never;
export declare function panicUtf8(msg: string): never;
export declare function logUtf8(msg: string): void;
export declare function logUtf16(msg: string): void;
export declare function storageRead(key: Bytes): Bytes | null;
export declare function storageHasKey(key: Bytes): boolean;
export declare function validatorStake(accountId: string): any;
export declare function validatorTotalStake(): BigInt;
export declare function altBn128G1Multiexp(value: Bytes): Bytes;
export declare function altBn128G1Sum(value: Bytes): Bytes;
export declare function altBn128PairingCheck(value: Bytes): boolean;
export declare function jsvmAccountId(): string;
export declare function jsvmJsContractName(): string;
export declare function jsvmMethodName(): string;
export declare function jsvmArgs(): Bytes;
export declare function jsvmStorageWrite(key: Bytes, value: Bytes): boolean;
export declare function jsvmStorageRead(key: Bytes): Bytes | null;
export declare function jsvmStorageRemove(key: Bytes): boolean;
export declare function jsvmStorageHasKey(key: Bytes): boolean;
export declare function jsvmCallRaw(contractName: string, method: string, args: any): Bytes | null;
export declare function jsvmCall(contractName: string, method: string, args: any): any | null;
export declare function storageGetEvicted(): Bytes;
export declare function jsvmValueReturn(value: Bytes): void;
export declare function currentAccountId(): string;
export declare function input(): Bytes;
export declare function storageUsage(): BigInt;
export declare function accountBalance(): BigInt;
export declare function accountLockedBalance(): BigInt;
export declare function valueReturn(value: Bytes): void;
export declare function promiseCreate(accountId: string, methodName: string, args: Bytes, amount: number | BigInt, gas: number | BigInt): BigInt;
export declare function promiseThen(promiseIndex: number | BigInt, accountId: string, methodName: string, args: Bytes, amount: number | BigInt, gas: number | BigInt): any;
export declare function promiseAnd(...promiseIndex: number[] | BigInt[]): BigInt;
export declare function promiseBatchCreate(accountId: string): BigInt;
export declare function promiseBatchThen(promiseIndex: number | BigInt, accountId: string): BigInt;
export declare function promiseBatchActionCreateAccount(promiseIndex: number | BigInt): void;
export declare function promiseBatchActionDeployContract(promiseIndex: number | BigInt, code: Bytes): void;
export declare function promiseBatchActionFunctionCall(promiseIndex: number | BigInt, methodName: string, args: Bytes, amount: number | BigInt, gas: number | BigInt): void;
export declare function promiseBatchActionTransfer(promiseIndex: number | BigInt, amount: number | BigInt): void;
export declare function promiseBatchActionStake(promiseIndex: number | BigInt, amount: number | BigInt, publicKey: Bytes): void;
export declare function promiseBatchActionAddKeyWithFullAccess(promiseIndex: number | BigInt, publicKey: Bytes, nonce: number | BigInt): void;
export declare function promiseBatchActionAddKeyWithFunctionCall(promiseIndex: number | BigInt, publicKey: Bytes, nonce: number | BigInt, allowance: number | BigInt, receiverId: string, methodNames: string): void;
export declare function promiseBatchActionDeleteKey(promiseIndex: number | BigInt, publicKey: Bytes): void;
export declare function promiseBatchActionDeleteAccount(promiseIndex: number | BigInt, beneficiaryId: string): void;
export declare function promiseResultsCount(): BigInt;
export declare enum PromiseResult {
    NotReady = 0,
    Successful = 1,
    Failed = 2
}
export declare function promiseResult(resultIdx: number | BigInt): Bytes | PromiseResult.NotReady | PromiseResult.Failed;
export declare function promiseReturn(promiseIdx: number | BigInt): void;
export declare function storageWrite(key: Bytes, value: Bytes): boolean;
export declare function storageRemove(key: Bytes): boolean;
export declare function storageByteCost(): BigInt;

'''
'''--- lib/api.js ---
const U64_MAX = 2n ** 64n - 1n;
const EVICTED_REGISTER = U64_MAX - 1n;
export function log(...params) {
    env.log(`${params
        .map(x => x === undefined ? 'undefined' : x) // Stringify undefined
        .map(x => typeof (x) === 'object' ? JSON.stringify(x) : x) // Convert Objects to strings
        .join(' ')}` // Convert to string
    );
}
export function signerAccountId() {
    env.signer_account_id(0);
    return env.read_register(0);
}
export function signerAccountPk() {
    env.signer_account_pk(0);
    return env.read_register(0);
}
export function predecessorAccountId() {
    env.predecessor_account_id(0);
    return env.read_register(0);
}
export function blockIndex() {
    return env.block_index();
}
export function blockHeight() {
    return blockIndex();
}
export function blockTimestamp() {
    return env.block_timestamp();
}
export function epochHeight() {
    return env.epoch_height();
}
export function attachedDeposit() {
    return env.attached_deposit();
}
export function prepaidGas() {
    return env.prepaid_gas();
}
export function usedGas() {
    return env.used_gas();
}
export function randomSeed() {
    env.random_seed(0);
    return env.read_register(0);
}
export function sha256(value) {
    env.sha256(value, 0);
    return env.read_register(0);
}
export function keccak256(value) {
    env.keccak256(value, 0);
    return env.read_register(0);
}
export function keccak512(value) {
    env.keccak512(value, 0);
    return env.read_register(0);
}
export function ripemd160(value) {
    env.ripemd160(value, 0);
    return env.read_register(0);
}
export function ecrecover(hash, sig, v, malleabilityFlag) {
    let ret = env.ecrecover(hash, sig, v, malleabilityFlag, 0);
    if (ret === 0n) {
        return null;
    }
    return env.read_register(0);
}
export function panic(msg) {
    if (msg !== undefined) {
        env.panic(msg);
    }
    else {
        env.panic();
    }
}
export function panicUtf8(msg) {
    env.panic_utf8(msg);
}
export function logUtf8(msg) {
    env.log_utf8(msg);
}
export function logUtf16(msg) {
    env.log_utf16(msg);
}
export function storageRead(key) {
    let ret = env.storage_read(key, 0);
    if (ret === 1n) {
        return env.read_register(0);
    }
    else {
        return null;
    }
}
export function storageHasKey(key) {
    let ret = env.storage_has_key(key);
    if (ret === 1n) {
        return true;
    }
    else {
        return false;
    }
}
export function validatorStake(accountId) {
    return env.validator_stake(accountId);
}
export function validatorTotalStake() {
    return env.validator_total_stake();
}
export function altBn128G1Multiexp(value) {
    env.alt_bn128_g1_multiexp(value, 0);
    return env.read_register(0);
}
export function altBn128G1Sum(value) {
    env.alt_bn128_g1_sum(value, 0);
    return env.read_register(0);
}
export function altBn128PairingCheck(value) {
    let ret = env.alt_bn128_pairing_check(value);
    if (ret === 1n) {
        return true;
    }
    else {
        return false;
    }
}
export function jsvmAccountId() {
    env.jsvm_account_id(0);
    return env.read_register(0);
}
export function jsvmJsContractName() {
    env.jsvm_js_contract_name(0);
    return env.read_register(0);
}
export function jsvmMethodName() {
    env.jsvm_method_name(0);
    return env.read_register(0);
}
export function jsvmArgs() {
    env.jsvm_args(0);
    return env.read_register(0);
}
export function jsvmStorageWrite(key, value) {
    let exist = env.jsvm_storage_write(key, value, EVICTED_REGISTER);
    if (exist === 1n) {
        return true;
    }
    return false;
}
export function jsvmStorageRead(key) {
    let exist = env.jsvm_storage_read(key, 0);
    if (exist === 1n) {
        return env.read_register(0);
    }
    return null;
}
export function jsvmStorageRemove(key) {
    let exist = env.jsvm_storage_remove(key, EVICTED_REGISTER);
    if (exist === 1n) {
        return true;
    }
    return false;
}
export function jsvmStorageHasKey(key) {
    let exist = env.jsvm_storage_has_key(key);
    if (exist === 1n) {
        return true;
    }
    return false;
}
export function jsvmCallRaw(contractName, method, args) {
    env.jsvm_call(contractName, method, JSON.stringify(args), 0);
    return env.read_register(0);
}
export function jsvmCall(contractName, method, args) {
    let ret = jsvmCallRaw(contractName, method, args);
    if (ret === null) {
        return ret;
    }
    return JSON.parse(ret);
}
export function storageGetEvicted() {
    return env.read_register(EVICTED_REGISTER);
}
export function jsvmValueReturn(value) {
    env.jsvm_value_return(value);
}
// Standalone only APIs
export function currentAccountId() {
    env.current_account_id(0);
    return env.read_register(0);
}
export function input() {
    env.input(0);
    return env.read_register(0);
}
export function storageUsage() {
    return env.storage_usage();
}
export function accountBalance() {
    return env.account_balance();
}
export function accountLockedBalance() {
    return env.account_locked_balance();
}
export function valueReturn(value) {
    env.value_return(value);
}
export function promiseCreate(accountId, methodName, args, amount, gas) {
    return env.promise_create(accountId, methodName, args, amount, gas);
}
export function promiseThen(promiseIndex, accountId, methodName, args, amount, gas) {
    return env.promise_then(promiseIndex, accountId, methodName, args, amount, gas);
}
export function promiseAnd(...promiseIndex) {
    return env.promise_and(...promiseIndex);
}
export function promiseBatchCreate(accountId) {
    return env.promise_batch_create(accountId);
}
export function promiseBatchThen(promiseIndex, accountId) {
    return env.promise_batch_then(promiseIndex, accountId);
}
export function promiseBatchActionCreateAccount(promiseIndex) {
    env.promise_batch_action_create_account(promiseIndex);
}
export function promiseBatchActionDeployContract(promiseIndex, code) {
    env.promise_batch_action_deploy_contract(promiseIndex, code);
}
export function promiseBatchActionFunctionCall(promiseIndex, methodName, args, amount, gas) {
    env.promise_batch_action_function_call(promiseIndex, methodName, args, amount, gas);
}
export function promiseBatchActionTransfer(promiseIndex, amount) {
    env.promise_batch_action_transfer(promiseIndex, amount);
}
export function promiseBatchActionStake(promiseIndex, amount, publicKey) {
    env.promise_batch_action_stake(promiseIndex, amount, publicKey);
}
export function promiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKey, nonce) {
    env.promise_batch_action_add_key_with_full_access(promiseIndex, publicKey, nonce);
}
export function promiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames) {
    env.promise_batch_action_add_key_with_function_call(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames);
}
export function promiseBatchActionDeleteKey(promiseIndex, publicKey) {
    env.promise_batch_action_delete_key(promiseIndex, publicKey);
}
export function promiseBatchActionDeleteAccount(promiseIndex, beneficiaryId) {
    env.promise_batch_action_delete_account(promiseIndex, beneficiaryId);
}
export function promiseResultsCount() {
    return env.promise_results_count();
}
export var PromiseResult;
(function (PromiseResult) {
    PromiseResult[PromiseResult["NotReady"] = 0] = "NotReady";
    PromiseResult[PromiseResult["Successful"] = 1] = "Successful";
    PromiseResult[PromiseResult["Failed"] = 2] = "Failed";
})(PromiseResult || (PromiseResult = {}));
export function promiseResult(resultIdx) {
    let status = env.promise_result(resultIdx, 0);
    if (status == PromiseResult.Successful) {
        return env.read_register(0);
    }
    else if (status == PromiseResult.Failed ||
        status == PromiseResult.NotReady) {
        return status;
    }
    else {
        panic(`Unexpected return code: ${status}`);
    }
}
export function promiseReturn(promiseIdx) {
    env.promise_return(promiseIdx);
}
export function storageWrite(key, value) {
    let exist = env.storage_write(key, value, EVICTED_REGISTER);
    if (exist === 1n) {
        return true;
    }
    return false;
}
export function storageRemove(key) {
    let exist = env.storage_remove(key, EVICTED_REGISTER);
    if (exist === 1n) {
        return true;
    }
    return false;
}
export function storageByteCost() {
    return 10000000000000000000n;
}

'''
'''--- lib/build-tools/near-bindgen-exporter.d.ts ---
export default function _default(): {
    visitor: {
        ClassDeclaration(path: any): void;
    };
};

'''
'''--- lib/build-tools/near-bindgen-exporter.js ---
import * as t from "@babel/types";
export default function () {
    return {
        visitor: {
            ClassDeclaration(path) {
                let classNode = path.node;
                if (classNode.decorators && classNode.decorators[0].expression.name == 'NearBindgen') {
                    let classId = classNode.id;
                    let contractMethods = {};
                    for (let child of classNode.body.body) {
                        if (child.type == 'ClassMethod' && child.kind == 'method' && child.decorators) {
                            if (child.decorators[0].expression.name == 'call') {
                                let callMethod = child.key.name;
                                contractMethods[callMethod] = 'call';
                            }
                            else if (child.decorators[0].expression.name == 'view') {
                                let viewMethod = child.key.name;
                                contractMethods[viewMethod] = 'view';
                            }
                        }
                    }
                    for (let method of Object.keys(contractMethods)) {
                        path.insertAfter(t.exportNamedDeclaration(t.functionDeclaration(t.identifier(method), [], t.blockStatement([
                            // let _contract = ContractClass._get()
                            t.variableDeclaration('let', [t.variableDeclarator(t.identifier('_contract'), t.callExpression(t.memberExpression(classId, t.identifier('_get')), []))]),
                            // _contract.deserialize()
                            t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier('deserialize')), [])),
                            // let args = _contract.constructor.deserializeArgs()
                            t.variableDeclaration('let', [t.variableDeclarator(t.identifier('args'), t.callExpression(t.memberExpression(t.memberExpression(t.identifier('_contract'), t.identifier('constructor')), t.identifier('deserializeArgs')), []))]),
                            // let ret = _contract.method(args)
                            t.variableDeclaration('let', [t.variableDeclarator(t.identifier('ret'), t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier(method)), [t.identifier('args')]))]),
                            contractMethods[method] == 'call' ?
                                // _contract.serialize()
                                t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier('serialize')), []))
                                : t.emptyStatement(),
                            // if (ret !== undefined)
                            t.ifStatement(t.binaryExpression('!==', t.identifier('ret'), t.identifier('undefined')), 
                            // env.value_return(_contract.constructor.serializeReturn(ret))
                            t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('env'), t.identifier('value_return')), [
                                t.callExpression(t.memberExpression(t.memberExpression(t.identifier('_contract'), t.identifier('constructor')), t.identifier('serializeReturn')), [t.identifier('ret')])
                            ])))
                        ])), [t.exportSpecifier(t.identifier(method), t.identifier(method))]));
                        path.scope.registerDeclaration(path.getSibling(path.key + 1));
                    }
                    path.insertAfter(t.exportNamedDeclaration(t.functionDeclaration(t.identifier('init'), [], t.blockStatement([
                        t.expressionStatement(t.callExpression(t.memberExpression(classId, t.identifier('_init')), [])),
                    ])), [t.exportSpecifier(t.identifier('init'), t.identifier('init'))]));
                    path.scope.registerDeclaration(path.getSibling(path.key + 1));
                    console.log('Near bindgen export done');
                }
            },
        },
    };
}

'''
'''--- lib/collections/index.d.ts ---
import { LookupMap } from "./lookup-map";
import { Vector } from "./vector";
import { LookupSet } from "./lookup-set";
import { UnorderedMap } from "./unordered-map";
import { UnorderedSet } from "./unordered-set";
export { LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet };

'''
'''--- lib/collections/index.js ---
import { LookupMap } from "./lookup-map";
import { Vector } from "./vector";
import { LookupSet } from "./lookup-set";
import { UnorderedMap } from "./unordered-map";
import { UnorderedSet } from "./unordered-set";
export { LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet };

'''
'''--- lib/collections/lookup-map.d.ts ---
import { Bytes, ClassMap } from '../utils';
import { Serializer } from 'superserial';
export declare class LookupMap<K, V> {
    readonly keyPrefix: Bytes;
    readonly serializer: Serializer;
    constructor(keyPrefix: Bytes, classes?: ClassMap);
    containsKey(key: K): boolean;
    get(key: K): V | null;
    remove(key: K): V | null;
    set(key: K, value: V): V | null;
    extend(objects: [K, V][]): void;
}

'''
'''--- lib/collections/lookup-map.js ---
import * as near from '../api';
import { Serializer } from 'superserial';
export class LookupMap {
    constructor(keyPrefix, classes) {
        this.keyPrefix = keyPrefix;
        this.serializer = new Serializer({ classes });
    }
    containsKey(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        return near.storageHasKey(storageKey);
    }
    get(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        let raw = near.storageRead(storageKey);
        if (raw !== null) {
            return this.serializer.deserialize(raw);
        }
        return null;
    }
    remove(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        if (near.storageRemove(storageKey)) {
            return this.serializer.deserialize(near.storageGetEvicted());
        }
        return null;
    }
    set(key, value) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        let storageValue = this.serializer.serialize(value);
        if (near.storageWrite(storageKey, storageValue)) {
            return this.serializer.deserialize(near.storageGetEvicted());
        }
        return null;
    }
    extend(objects) {
        for (let kv of objects) {
            this.set(kv[0], kv[1]);
        }
    }
}

'''
'''--- lib/collections/lookup-set.d.ts ---
import { Bytes, ClassMap } from '../utils';
import { Serializer } from 'superserial';
export declare class LookupSet<K> {
    readonly keyPrefix: Bytes;
    readonly serializer: Serializer;
    constructor(keyPrefix: Bytes, classes?: ClassMap);
    contains(key: K): boolean;
    remove(key: K): boolean;
    set(key: K): boolean;
    extend(keys: K[]): void;
}

'''
'''--- lib/collections/lookup-set.js ---
import * as near from '../api';
import { Serializer } from 'superserial';
export class LookupSet {
    constructor(keyPrefix, classes) {
        this.keyPrefix = keyPrefix;
        this.serializer = new Serializer({ classes });
    }
    contains(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        return near.storageHasKey(storageKey);
    }
    // Returns true if the element was present in the set.
    remove(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        return near.storageRemove(storageKey);
    }
    // If the set did not have this value present, `true` is returned.
    // If the set did have this value present, `false` is returned.
    set(key) {
        let storageKey = this.keyPrefix + this.serializer.serialize(key);
        return !near.storageWrite(storageKey, '');
    }
    extend(keys) {
        for (let key of keys) {
            this.set(key);
        }
    }
}

'''
'''--- lib/collections/unordered-map.d.ts ---
import { Bytes, ClassMap } from "../utils";
import { Vector } from "./vector";
import { Serializer } from 'superserial';
export declare class UnorderedMap<K, V> {
    readonly length: number;
    readonly keyIndexPrefix: Bytes;
    readonly keys: Vector<K>;
    readonly values: Vector<V>;
    readonly serializer: Serializer;
    constructor(prefix: Bytes, classes?: ClassMap);
    len(): number;
    isEmpty(): boolean;
    serializeIndex(index: number): Bytes;
    deserializeIndex(rawIndex: Bytes): number;
    getIndexRaw(key: K): Bytes;
    get(key: K): V | null;
    set(key: K, value: V): V | null;
    remove(key: K): V | null;
    clear(): void;
    toArray(): [K, V][];
    [Symbol.iterator](): UnorderedMapIterator<K, V>;
    extend(kvs: [K, V][]): void;
}
declare class UnorderedMapIterator<K, V> {
    private keys;
    private values;
    constructor(unorderedMap: UnorderedMap<K, V>);
    next(): {
        value: [K | null, V | null];
        done: boolean;
    };
}
export {};

'''
'''--- lib/collections/unordered-map.js ---
import * as near from "../api";
import { u8ArrayToBytes, bytesToU8Array } from "../utils";
import { Vector, VectorIterator } from "./vector";
import { Serializer } from 'superserial';
const ERR_INCONSISTENT_STATE = "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";
export class UnorderedMap {
    constructor(prefix, classes) {
        this.length = 0;
        this.keyIndexPrefix = prefix + "i";
        let indexKey = prefix + "k";
        let indexValue = prefix + "v";
        this.keys = new Vector(indexKey, classes);
        this.values = new Vector(indexValue, classes);
        this.serializer = new Serializer(classes);
    }
    len() {
        let keysLen = this.keys.len();
        let valuesLen = this.values.len();
        if (keysLen != valuesLen) {
            throw new Error(ERR_INCONSISTENT_STATE);
        }
        return keysLen;
    }
    isEmpty() {
        let keysIsEmpty = this.keys.isEmpty();
        let valuesIsEmpty = this.values.isEmpty();
        if (keysIsEmpty != valuesIsEmpty) {
            throw new Error(ERR_INCONSISTENT_STATE);
        }
        return keysIsEmpty;
    }
    serializeIndex(index) {
        let data = new Uint32Array([index]);
        let array = new Uint8Array(data.buffer);
        return u8ArrayToBytes(array);
    }
    deserializeIndex(rawIndex) {
        let array = bytesToU8Array(rawIndex);
        let data = new Uint32Array(array.buffer);
        return data[0];
    }
    getIndexRaw(key) {
        let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
        let indexRaw = near.storageRead(indexLookup);
        return indexRaw;
    }
    get(key) {
        let indexRaw = this.getIndexRaw(key);
        if (indexRaw) {
            let index = this.deserializeIndex(indexRaw);
            let value = this.values.get(index);
            if (value) {
                return value;
            }
            else {
                throw new Error(ERR_INCONSISTENT_STATE);
            }
        }
        return null;
    }
    set(key, value) {
        let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
        let indexRaw = near.storageRead(indexLookup);
        if (indexRaw) {
            let index = this.deserializeIndex(indexRaw);
            return this.values.replace(index, value);
        }
        else {
            let nextIndex = this.len();
            let nextIndexRaw = this.serializeIndex(nextIndex);
            near.storageWrite(indexLookup, nextIndexRaw);
            this.keys.push(key);
            this.values.push(value);
            return null;
        }
    }
    remove(key) {
        let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
        let indexRaw = near.storageRead(indexLookup);
        if (indexRaw) {
            if (this.len() == 1) {
                // If there is only one element then swap remove simply removes it without
                // swapping with the last element.
                near.storageRemove(indexLookup);
            }
            else {
                // If there is more than one element then swap remove swaps it with the last
                // element.
                let lastKey = this.keys.get(this.len() - 1);
                if (!lastKey) {
                    throw new Error(ERR_INCONSISTENT_STATE);
                }
                near.storageRemove(indexLookup);
                // If the removed element was the last element from keys, then we don't need to
                // reinsert the lookup back.
                if (lastKey != key) {
                    let lastLookupKey = this.keyIndexPrefix + this.serializer.serialize(lastKey);
                    near.storageWrite(lastLookupKey, indexRaw);
                }
            }
            let index = this.deserializeIndex(indexRaw);
            this.keys.swapRemove(index);
            return this.values.swapRemove(index);
        }
        return null;
    }
    clear() {
        for (let key of this.keys) {
            let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
            near.storageRemove(indexLookup);
        }
        this.keys.clear();
        this.values.clear();
    }
    toArray() {
        let ret = [];
        for (let v of this) {
            ret.push(v);
        }
        return ret;
    }
    [Symbol.iterator]() {
        return new UnorderedMapIterator(this);
    }
    extend(kvs) {
        for (let [k, v] of kvs) {
            this.set(k, v);
        }
    }
}
class UnorderedMapIterator {
    constructor(unorderedMap) {
        this.keys = new VectorIterator(unorderedMap.keys);
        this.values = new VectorIterator(unorderedMap.values);
    }
    next() {
        let key = this.keys.next();
        let value = this.values.next();
        if (key.done != value.done) {
            throw new Error(ERR_INCONSISTENT_STATE);
        }
        return { value: [key.value, value.value], done: key.done };
    }
}

'''
'''--- lib/collections/unordered-set.d.ts ---
import { Bytes, ClassMap } from "../utils";
import { Vector } from "./vector";
import { Serializer } from 'superserial';
export declare class UnorderedSet<E> {
    readonly length: number;
    readonly elementIndexPrefix: Bytes;
    readonly elements: Vector<E>;
    readonly serializer: Serializer;
    constructor(prefix: Bytes, classes?: ClassMap);
    len(): number;
    isEmpty(): boolean;
    serializeIndex(index: number): string;
    deserializeIndex(rawIndex: Bytes): number;
    contains(element: E): boolean;
    set(element: E): boolean;
    remove(element: E): boolean;
    clear(): void;
    toArray(): Bytes[];
    [Symbol.iterator](): import("./vector").VectorIterator<E>;
    extend(elements: E[]): void;
}

'''
'''--- lib/collections/unordered-set.js ---
import * as near from "../api";
import { u8ArrayToBytes, bytesToU8Array } from "../utils";
import { Vector } from "./vector";
import { Serializer } from 'superserial';
const ERR_INCONSISTENT_STATE = "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";
export class UnorderedSet {
    constructor(prefix, classes) {
        this.length = 0;
        this.elementIndexPrefix = prefix + "i";
        let elementsPrefix = prefix + "e";
        this.elements = new Vector(elementsPrefix, classes);
        this.serializer = new Serializer({ classes });
    }
    len() {
        return this.elements.len();
    }
    isEmpty() {
        return this.elements.isEmpty();
    }
    serializeIndex(index) {
        let data = new Uint32Array([index]);
        let array = new Uint8Array(data.buffer);
        return u8ArrayToBytes(array);
    }
    deserializeIndex(rawIndex) {
        let array = bytesToU8Array(rawIndex);
        let data = new Uint32Array(array.buffer);
        return data[0];
    }
    contains(element) {
        let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
        return near.storageHasKey(indexLookup);
    }
    set(element) {
        let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
        if (near.storageRead(indexLookup)) {
            return false;
        }
        else {
            let nextIndex = this.len();
            let nextIndexRaw = this.serializeIndex(nextIndex);
            near.storageWrite(indexLookup, nextIndexRaw);
            this.elements.push(element);
            return true;
        }
    }
    remove(element) {
        let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
        let indexRaw = near.storageRead(indexLookup);
        if (indexRaw) {
            if (this.len() == 1) {
                // If there is only one element then swap remove simply removes it without
                // swapping with the last element.
                near.storageRemove(indexLookup);
            }
            else {
                // If there is more than one element then swap remove swaps it with the last
                // element.
                let lastElement = this.elements.get(this.len() - 1);
                if (!lastElement) {
                    throw new Error(ERR_INCONSISTENT_STATE);
                }
                near.storageRemove(indexLookup);
                // If the removed element was the last element from keys, then we don't need to
                // reinsert the lookup back.
                if (lastElement != element) {
                    let lastLookupElement = this.elementIndexPrefix + this.serializer.serialize(lastElement);
                    near.storageWrite(lastLookupElement, indexRaw);
                }
            }
            let index = this.deserializeIndex(indexRaw);
            this.elements.swapRemove(index);
            return true;
        }
        return false;
    }
    clear() {
        for (let element of this.elements) {
            let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
            near.storageRemove(indexLookup);
        }
        this.elements.clear();
    }
    toArray() {
        let ret = [];
        for (let v of this) {
            ret.push(v);
        }
        return ret;
    }
    [Symbol.iterator]() {
        return this.elements[Symbol.iterator]();
    }
    extend(elements) {
        for (let element of elements) {
            this.set(element);
        }
    }
}

'''
'''--- lib/collections/vector.d.ts ---
import { Bytes, ClassMap } from "../utils";
import { Serializer } from 'superserial';
export declare class Vector<E> {
    length: number;
    readonly prefix: Bytes;
    readonly serializer: Serializer;
    constructor(prefix: Bytes, classes?: ClassMap);
    len(): number;
    isEmpty(): boolean;
    get(index: number): E | null;
    swapRemove(index: number): E | null;
    push(element: E): void;
    pop(): E | null;
    replace(index: number, element: E): E;
    extend(elements: E[]): void;
    [Symbol.iterator](): VectorIterator<E>;
    clear(): void;
    toArray(): E[];
}
export declare class VectorIterator<E> {
    private current;
    private vector;
    constructor(vector: Vector<E>);
    next(): {
        value: E | null;
        done: boolean;
    };
}

'''
'''--- lib/collections/vector.js ---
import * as near from "../api";
import { u8ArrayToBytes } from "../utils";
import { Serializer } from 'superserial';
const ERR_INDEX_OUT_OF_BOUNDS = "Index out of bounds";
const ERR_INCONSISTENT_STATE = "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";
function indexToKey(prefix, index) {
    let data = new Uint32Array([index]);
    let array = new Uint8Array(data.buffer);
    let key = u8ArrayToBytes(array);
    return prefix + key;
}
/// An iterable implementation of vector that stores its content on the trie.
/// Uses the following map: index -> element
export class Vector {
    constructor(prefix, classes) {
        this.length = 0;
        this.prefix = prefix;
        this.serializer = new Serializer({ classes });
    }
    len() {
        return this.length;
    }
    isEmpty() {
        return this.length == 0;
    }
    get(index) {
        if (index >= this.length) {
            return null;
        }
        let storageKey = indexToKey(this.prefix, index);
        return this.serializer.deserialize(near.storageRead(storageKey));
    }
    /// Removes an element from the vector and returns it in serialized form.
    /// The removed element is replaced by the last element of the vector.
    /// Does not preserve ordering, but is `O(1)`.
    swapRemove(index) {
        if (index >= this.length) {
            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);
        }
        else if (index + 1 == this.length) {
            return this.pop();
        }
        else {
            let key = indexToKey(this.prefix, index);
            let last = this.pop();
            if (near.storageWrite(key, this.serializer.serialize(last))) {
                return this.serializer.deserialize(near.storageGetEvicted());
            }
            else {
                throw new Error(ERR_INCONSISTENT_STATE);
            }
        }
    }
    push(element) {
        let key = indexToKey(this.prefix, this.length);
        this.length += 1;
        near.storageWrite(key, this.serializer.serialize(element));
    }
    pop() {
        if (this.isEmpty()) {
            return null;
        }
        else {
            let lastIndex = this.length - 1;
            let lastKey = indexToKey(this.prefix, lastIndex);
            this.length -= 1;
            if (near.storageRemove(lastKey)) {
                return this.serializer.deserialize(near.storageGetEvicted());
            }
            else {
                throw new Error(ERR_INCONSISTENT_STATE);
            }
        }
    }
    replace(index, element) {
        if (index >= this.length) {
            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);
        }
        else {
            let key = indexToKey(this.prefix, index);
            if (near.storageWrite(key, this.serializer.serialize(element))) {
                return this.serializer.deserialize(near.storageGetEvicted());
            }
            else {
                throw new Error(ERR_INCONSISTENT_STATE);
            }
        }
    }
    extend(elements) {
        for (let element of elements) {
            this.push(element);
        }
    }
    [Symbol.iterator]() {
        return new VectorIterator(this);
    }
    clear() {
        for (let i = 0; i < this.length; i++) {
            let key = indexToKey(this.prefix, i);
            near.storageRemove(key);
        }
        this.length = 0;
    }
    toArray() {
        let ret = [];
        for (let v of this) {
            ret.push(v);
        }
        return ret;
    }
}
export class VectorIterator {
    constructor(vector) {
        this.current = 0;
        this.vector = vector;
    }
    next() {
        if (this.current < this.vector.len()) {
            let value = this.vector.get(this.current);
            this.current += 1;
            return { value, done: false };
        }
        return { value: null, done: true };
    }
}

'''
'''--- lib/index.d.ts ---
import { call, view, NearBindgen } from "./near-bindgen";
import { NearContract } from "./near-contract";
import * as near from "./api";
import { LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet } from "./collections";
import { bytes, Bytes, assert } from "./utils";
export { call, view, NearBindgen, NearContract, near, LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet, bytes, Bytes, assert, };

'''
'''--- lib/index.js ---
import { call, view, NearBindgen } from "./near-bindgen";
import { NearContract } from "./near-contract";
import * as near from "./api";
import { LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet, } from "./collections";
import { bytes, assert } from "./utils";
export { call, view, NearBindgen, NearContract, near, LookupMap, Vector, LookupSet, UnorderedMap, UnorderedSet, bytes, assert, };

'''
'''--- lib/near-bindgen.d.ts ---
export declare function call(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<Function>): void;
export declare function view(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<Function>): void;
export declare function NearBindgen<T extends {
    new (...args: any[]): {};
}>(target: T): {
    new (...args: any[]): {};
    _init(): {};
    _get(): any;
} & T;

'''
'''--- lib/near-bindgen.js ---
export function call(target, key, descriptor) {
}
export function view(target, key, descriptor) {
}
export function NearBindgen(target) {
    return class extends target {
        static _init() {
            // @ts-ignore
            let args = target.deserializeArgs();
            let ret = new target(args);
            // @ts-ignore
            ret.serialize();
            return ret;
        }
        static _get() {
            let ret = Object.create(target.prototype);
            return ret;
        }
    };
}

'''
'''--- lib/near-contract.d.ts ---
export declare class NearContract {
    deserialize(): void;
    serialize(): void;
    static deserializeArgs(): any;
    static serializeReturn(ret: any): string;
}

'''
'''--- lib/near-contract.js ---
import * as near from "./api";
export class NearContract {
    deserialize() {
        let state = near.storageRead("STATE");
        if (state) {
            Object.assign(this, JSON.parse(state));
        }
        else {
            throw new Error("Contract state is empty");
        }
    }
    serialize() {
        near.storageWrite("STATE", JSON.stringify(this));
    }
    static deserializeArgs() {
        let args = near.input();
        return JSON.parse(args || "{}");
    }
    static serializeReturn(ret) {
        return JSON.stringify(ret);
    }
}

'''
'''--- lib/utils.d.ts ---
export declare type Bytes = string;
export declare function u8ArrayToBytes(array: Uint8Array): string;
export declare function bytesToU8Array(bytes: Bytes): Uint8Array;
export declare function bytes(strOrU8Array: string | Uint8Array): Bytes;
export declare function assert(b: boolean, str: string): void;
export declare type ClassMap = {
    [className: string]: ((new (...args: any[]) => any) | Function);
};

'''
'''--- lib/utils.js ---
export function u8ArrayToBytes(array) {
    let ret = "";
    for (let e of array) {
        ret += String.fromCharCode(e);
    }
    return ret;
}
// TODO this function is a bit broken and the type can't be string
// TODO for more info: https://github.com/near/near-sdk-js/issues/78
export function bytesToU8Array(bytes) {
    let ret = new Uint8Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        ret[i] = bytes.charCodeAt(i);
    }
    return ret;
}
export function bytes(strOrU8Array) {
    if (typeof strOrU8Array == "string") {
        return checkStringIsBytes(strOrU8Array);
    }
    else if (strOrU8Array instanceof Uint8Array) {
        return u8ArrayToBytes(strOrU8Array);
    }
    throw new Error("bytes: expected string or Uint8Array");
}
function checkStringIsBytes(str) {
    for (let i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) > 255) {
            throw new Error(`string ${str} at index ${i}: ${str[i]} is not a valid byte`);
        }
    }
    return str;
}
export function assert(b, str) {
    if (b) {
        return;
    }
    else {
        throw Error("assertion failed: " + str);
    }
}

'''
'''--- package.json ---
{
  "name": "near-sdk-js",
  "version": "0.4.0-4",
  "description": "High Level JavaScript SDK for building smart contracts on NEAR",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "type": "module",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/near/near-sdk-js.git"
  },
  "homepage": "https://github.com/near/near-sdk-js",
  "keywords": [
    "JS",
    "JavaScript",
    "NEAR",
    "SDK",
    "contract",
    "smart",
    "smart-contract"
  ],
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "tsc -p ./tsconfig.json",
    "pretest": "yarn build",
    "test": "yarn test:standalone && yarn test:enclaved",
    "test:standalone": "yarn test:standalone:unit && yarn test:standalone:examples",
    "test:standalone:unit": "yarn && cd tests && yarn && yarn build && yarn test && cd ..",
    "test:standalone:examples": "yarn && cd examples && yarn && yarn build && yarn test && cd ..",
    "test:enclaved": "yarn test:enclaved:unit && yarn test:enclaved:examples",
    "test:enclaved:unit": "cd jsvm/tests && yarn rebuild && yarn test && cd ../..",
    "test:enclaved:examples": "cd jsvm/examples && yarn && yarn rebuild && yarn test && cd ../..",
    "postinstall": "cd cli && mkdir -p deps && cd deps && node ../post-install.js"
  },
  "bin": {
    "near-sdk-js": "cli/cli.js"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "dependencies": {
    "@babel/core": "^7.17.5",
    "@babel/plugin-proposal-decorators": "^7.17.2",
    "@babel/preset-typescript": "^7.18.6",
    "@rollup/plugin-babel": "^5.3.1",
    "@rollup/plugin-commonjs": "^21.0.1",
    "@rollup/plugin-node-resolve": "^13.1.1",
    "rollup": "^2.61.1",
    "rollup-plugin-sourcemaps": "^0.6.3",
    "superserial": "^0.3.0",
    "yargs": "^17.5.1"
  },
  "files": [
    "cli",
    "lib"
  ],
  "devDependencies": {
    "@rollup/plugin-typescript": "^8.3.2",
    "@types/node": "^17.0.38",
    "@types/rollup": "^0.54.0",
    "typescript": "^4.7.2"
  }
}

'''
'''--- src/api.ts ---
import { Bytes } from "./utils";

const U64_MAX = 2n ** 64n - 1n;
const EVICTED_REGISTER = U64_MAX - 1n;

interface Env {
  panic: (msg?: string) => never;
  panic_utf8: (msg: string) => never;
  [x: string]: any;
}
// env object is injected by JSVM
declare let env: Env;

export function log(...params: any[]) {
  env.log(`${params
    .map(x => x === undefined ? 'undefined' : x)                // Stringify undefined
    .map(x => typeof (x) === 'object' ? JSON.stringify(x) : x)  // Convert Objects to strings
    .join(' ')}`                                                // Convert to string
  )
}

export function signerAccountId(): string {
  env.signer_account_id(0);
  return env.read_register(0);
}

export function signerAccountPk(): Bytes {
  env.signer_account_pk(0);
  return env.read_register(0);
}

export function predecessorAccountId(): string {
  env.predecessor_account_id(0);
  return env.read_register(0);
}

export function blockIndex(): BigInt {
  return env.block_index();
}

export function blockHeight(): BigInt {
  return blockIndex();
}

export function blockTimestamp(): BigInt {
  return env.block_timestamp();
}

export function epochHeight(): BigInt {
  return env.epoch_height();
}

export function attachedDeposit(): BigInt {
  return env.attached_deposit();
}

export function prepaidGas(): BigInt {
  return env.prepaid_gas();
}

export function usedGas(): BigInt {
  return env.used_gas();
}

export function randomSeed(): Bytes {
  env.random_seed(0);
  return env.read_register(0);
}

export function sha256(value: Bytes): Bytes {
  env.sha256(value, 0);
  return env.read_register(0);
}

export function keccak256(value: Bytes): Bytes {
  env.keccak256(value, 0);
  return env.read_register(0);
}

export function keccak512(value: Bytes): Bytes {
  env.keccak512(value, 0);
  return env.read_register(0);
}

export function ripemd160(value: Bytes): Bytes {
  env.ripemd160(value, 0);
  return env.read_register(0);
}

export function ecrecover(
  hash: Bytes,
  sig: Bytes,
  v: number,
  malleabilityFlag: number
): Bytes | null {
  let ret = env.ecrecover(hash, sig, v, malleabilityFlag, 0);
  if (ret === 0n) {
    return null;
  }
  return env.read_register(0);
}

export function panic(msg?: string): never {
  if (msg !== undefined) {
    env.panic(msg);
  } else {
    env.panic();
  }
}

export function panicUtf8(msg: string): never {
  env.panic_utf8(msg);
}

export function logUtf8(msg: string) {
  env.log_utf8(msg);
}

export function logUtf16(msg: string) {
  env.log_utf16(msg);
}

export function storageRead(key: Bytes): Bytes | null {
  let ret = env.storage_read(key, 0);
  if (ret === 1n) {
    return env.read_register(0);
  } else {
    return null;
  }
}

export function storageHasKey(key: Bytes): boolean {
  let ret = env.storage_has_key(key);
  if (ret === 1n) {
    return true;
  } else {
    return false;
  }
}

export function validatorStake(accountId: string) {
  return env.validator_stake(accountId);
}

export function validatorTotalStake(): BigInt {
  return env.validator_total_stake();
}

export function altBn128G1Multiexp(value: Bytes): Bytes {
  env.alt_bn128_g1_multiexp(value, 0);
  return env.read_register(0);
}

export function altBn128G1Sum(value: Bytes): Bytes {
  env.alt_bn128_g1_sum(value, 0);
  return env.read_register(0);
}

export function altBn128PairingCheck(value: Bytes): boolean {
  let ret = env.alt_bn128_pairing_check(value);
  if (ret === 1n) {
    return true;
  } else {
    return false;
  }
}

export function jsvmAccountId(): string {
  env.jsvm_account_id(0);
  return env.read_register(0);
}

export function jsvmJsContractName(): string {
  env.jsvm_js_contract_name(0);
  return env.read_register(0);
}

export function jsvmMethodName(): string {
  env.jsvm_method_name(0);
  return env.read_register(0);
}

export function jsvmArgs(): Bytes {
  env.jsvm_args(0);
  return env.read_register(0);
}

export function jsvmStorageWrite(key: Bytes, value: Bytes): boolean {
  let exist = env.jsvm_storage_write(key, value, EVICTED_REGISTER);
  if (exist === 1n) {
    return true;
  }
  return false;
}

export function jsvmStorageRead(key: Bytes): Bytes | null {
  let exist = env.jsvm_storage_read(key, 0);
  if (exist === 1n) {
    return env.read_register(0);
  }
  return null;
}

export function jsvmStorageRemove(key: Bytes): boolean {
  let exist = env.jsvm_storage_remove(key, EVICTED_REGISTER);
  if (exist === 1n) {
    return true;
  }
  return false;
}

export function jsvmStorageHasKey(key: Bytes): boolean {
  let exist = env.jsvm_storage_has_key(key);
  if (exist === 1n) {
    return true;
  }
  return false;
}

export function jsvmCallRaw(
  contractName: string,
  method: string,
  args: any
): Bytes | null {
  env.jsvm_call(contractName, method, JSON.stringify(args), 0);
  return env.read_register(0);
}

export function jsvmCall(
  contractName: string,
  method: string,
  args: any
): any | null {
  let ret = jsvmCallRaw(contractName, method, args);
  if (ret === null) {
    return ret;
  }
  return JSON.parse(ret);
}

export function storageGetEvicted(): Bytes {
  return env.read_register(EVICTED_REGISTER);
}

export function jsvmValueReturn(value: Bytes) {
  env.jsvm_value_return(value);
}

// Standalone only APIs
export function currentAccountId(): string {
  env.current_account_id(0);
  return env.read_register(0);
}

export function input(): Bytes {
  env.input(0);
  return env.read_register(0);
}

export function storageUsage(): BigInt {
  return env.storage_usage();
}

export function accountBalance(): BigInt {
  return env.account_balance();
}

export function accountLockedBalance(): BigInt {
  return env.account_locked_balance();
}

export function valueReturn(value: Bytes) {
  env.value_return(value);
}

export function promiseCreate(
  accountId: string,
  methodName: string,
  args: Bytes,
  amount: number | BigInt,
  gas: number | BigInt
): BigInt {
  return env.promise_create(accountId, methodName, args, amount, gas);
}

export function promiseThen(
  promiseIndex: number | BigInt,
  accountId: string,
  methodName: string,
  args: Bytes,
  amount: number | BigInt,
  gas: number | BigInt
) {
  return env.promise_then(
    promiseIndex,
    accountId,
    methodName,
    args,
    amount,
    gas
  );
}

export function promiseAnd(...promiseIndex: number[] | BigInt[]): BigInt {
  return env.promise_and(...promiseIndex);
}

export function promiseBatchCreate(accountId: string): BigInt {
  return env.promise_batch_create(accountId);
}

export function promiseBatchThen(
  promiseIndex: number | BigInt,
  accountId: string
): BigInt {
  return env.promise_batch_then(promiseIndex, accountId);
}

export function promiseBatchActionCreateAccount(promiseIndex: number | BigInt) {
  env.promise_batch_action_create_account(promiseIndex);
}

export function promiseBatchActionDeployContract(
  promiseIndex: number | BigInt,
  code: Bytes
) {
  env.promise_batch_action_deploy_contract(promiseIndex, code);
}

export function promiseBatchActionFunctionCall(
  promiseIndex: number | BigInt,
  methodName: string,
  args: Bytes,
  amount: number | BigInt,
  gas: number | BigInt
) {
  env.promise_batch_action_function_call(
    promiseIndex,
    methodName,
    args,
    amount,
    gas
  );
}

export function promiseBatchActionTransfer(
  promiseIndex: number | BigInt,
  amount: number | BigInt
) {
  env.promise_batch_action_transfer(promiseIndex, amount);
}

export function promiseBatchActionStake(
  promiseIndex: number | BigInt,
  amount: number | BigInt,
  publicKey: Bytes
) {
  env.promise_batch_action_stake(promiseIndex, amount, publicKey);
}

export function promiseBatchActionAddKeyWithFullAccess(
  promiseIndex: number | BigInt,
  publicKey: Bytes,
  nonce: number | BigInt
) {
  env.promise_batch_action_add_key_with_full_access(
    promiseIndex,
    publicKey,
    nonce
  );
}

export function promiseBatchActionAddKeyWithFunctionCall(
  promiseIndex: number | BigInt,
  publicKey: Bytes,
  nonce: number | BigInt,
  allowance: number | BigInt,
  receiverId: string,
  methodNames: string
) {
  env.promise_batch_action_add_key_with_function_call(
    promiseIndex,
    publicKey,
    nonce,
    allowance,
    receiverId,
    methodNames
  );
}

export function promiseBatchActionDeleteKey(
  promiseIndex: number | BigInt,
  publicKey: Bytes
) {
  env.promise_batch_action_delete_key(promiseIndex, publicKey);
}

export function promiseBatchActionDeleteAccount(
  promiseIndex: number | BigInt,
  beneficiaryId: string
) {
  env.promise_batch_action_delete_account(promiseIndex, beneficiaryId);
}

export function promiseResultsCount(): BigInt {
  return env.promise_results_count();
}

export enum PromiseResult {
  NotReady = 0,
  Successful = 1,
  Failed = 2,
}

export function promiseResult(
  resultIdx: number | BigInt
): Bytes | PromiseResult.NotReady | PromiseResult.Failed {
  let status: PromiseResult = env.promise_result(resultIdx, 0);
  if (status == PromiseResult.Successful) {
    return env.read_register(0);
  } else if (
    status == PromiseResult.Failed ||
    status == PromiseResult.NotReady
  ) {
    return status;
  } else {
    panic(`Unexpected return code: ${status}`);
  }
}

export function promiseReturn(promiseIdx: number | BigInt) {
  env.promise_return(promiseIdx);
}

export function storageWrite(key: Bytes, value: Bytes): boolean {
  let exist = env.storage_write(key, value, EVICTED_REGISTER);
  if (exist === 1n) {
    return true;
  }
  return false;
}

export function storageRemove(key: Bytes): boolean {
  let exist = env.storage_remove(key, EVICTED_REGISTER);
  if (exist === 1n) {
    return true;
  }
  return false;
}

export function storageByteCost(): BigInt {
  return 10_000_000_000_000_000_000n;
}

'''
'''--- src/build-tools/near-bindgen-exporter.js ---
import * as t from "@babel/types";

export default function () {
  return {
    visitor: {
      ClassDeclaration(path) {
        let classNode = path.node
        if (classNode.decorators && classNode.decorators[0].expression.name == 'NearBindgen') {
          let classId = classNode.id
          let contractMethods = {}

          for(let child of classNode.body.body) {
            if (child.type == 'ClassMethod' && child.kind == 'method' && child.decorators) {
              if (child.decorators[0].expression.name == 'call') {
                let callMethod = child.key.name
                contractMethods[callMethod] = 'call'
              } else if (child.decorators[0].expression.name == 'view') {
                let viewMethod = child.key.name
                contractMethods[viewMethod] = 'view'
              }
            }
          }

          for (let method of Object.keys(contractMethods)) {
            path.insertAfter(
              t.exportNamedDeclaration(
                t.functionDeclaration(t.identifier(method), [], t.blockStatement([
                  // let _contract = ContractClass._get()
                  t.variableDeclaration('let', [t.variableDeclarator(t.identifier('_contract'), 
                    t.callExpression(t.memberExpression(classId, t.identifier('_get')), []))]),
                  // _contract.deserialize()
                  t.expressionStatement(
                    t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier('deserialize')), [])),
                  // let args = _contract.constructor.deserializeArgs()
                  t.variableDeclaration('let', [t.variableDeclarator(t.identifier('args'), 
                    t.callExpression(t.memberExpression(t.memberExpression(t.identifier('_contract'), t.identifier('constructor')), t.identifier('deserializeArgs')), []))]),
                  // let ret = _contract.method(args)
                  t.variableDeclaration('let', [t.variableDeclarator(t.identifier('ret'), 
                    t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier(method)), [t.identifier('args')]))]),
                  contractMethods[method] == 'call' ?
                    // _contract.serialize()
                    t.expressionStatement(
                      t.callExpression(t.memberExpression(t.identifier('_contract'), t.identifier('serialize')), []))
                    : t.emptyStatement(),
                  // if (ret !== undefined)
                  t.ifStatement(t.binaryExpression('!==', t.identifier('ret'), t.identifier('undefined')),
                    // env.value_return(_contract.constructor.serializeReturn(ret))
                    t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('env'), t.identifier('value_return')), [
                      t.callExpression(t.memberExpression(t.memberExpression(t.identifier('_contract'), t.identifier('constructor')), t.identifier('serializeReturn')), [t.identifier('ret')])
                    ]))
                  )
                ])),
                [t.exportSpecifier(t.identifier(method), t.identifier(method))]))
            path.scope.registerDeclaration(path.getSibling(path.key + 1))
          }

          path.insertAfter(
            t.exportNamedDeclaration(
              t.functionDeclaration(t.identifier('init'), [], t.blockStatement([
                t.expressionStatement(t.callExpression(t.memberExpression(classId, t.identifier('_init')), [])),
              ])),
              [t.exportSpecifier(t.identifier('init'), t.identifier('init'))]))
          path.scope.registerDeclaration(path.getSibling(path.key + 1))

          console.log('Near bindgen export done')
        }
      },
    },
  }
}

'''
'''--- src/collections/index.ts ---
import { LookupMap } from "./lookup-map";
import { Vector } from "./vector";
import { LookupSet } from "./lookup-set";
import { UnorderedMap } from "./unordered-map";
import { UnorderedSet } from "./unordered-set";

export {
    LookupMap,
    Vector,
    LookupSet,
    UnorderedMap,
    UnorderedSet
}
'''
'''--- src/collections/lookup-map.ts ---
import * as near from '../api'
import { Bytes, ClassMap } from '../utils';
import { Serializer } from 'superserial';

export class LookupMap<K, V> {
    readonly keyPrefix: Bytes;
    readonly serializer: Serializer;

    constructor(keyPrefix: Bytes, classes?: ClassMap) {
        this.keyPrefix = keyPrefix
        this.serializer = new Serializer({classes})
    }

    containsKey(key: K): boolean {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        return near.storageHasKey(storageKey)
    }

    get(key: K): V | null {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        let raw = near.storageRead(storageKey)
        if (raw !== null) {
            return this.serializer.deserialize(raw)
        }
        return null
    }

    remove(key: K): V | null {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        if (near.storageRemove(storageKey)) {
            return this.serializer.deserialize(near.storageGetEvicted())
        }
        return null
    }

    set(key: K, value: V): V | null {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        let storageValue = this.serializer.serialize(value)
        if (near.storageWrite(storageKey, storageValue)) {
            return this.serializer.deserialize(near.storageGetEvicted())
        }
        return null
    }

    extend(objects: [K, V][]) {
        for(let kv of objects) {
            this.set(kv[0], kv[1])
        }
    }
}
'''
'''--- src/collections/lookup-set.ts ---
import * as near from '../api'
import { Bytes, ClassMap } from '../utils';
import { Serializer } from 'superserial';

export class LookupSet<K> {
    readonly keyPrefix: Bytes;
    readonly serializer: Serializer;

    constructor(keyPrefix: Bytes, classes?: ClassMap) {
        this.keyPrefix = keyPrefix
        this.serializer = new Serializer({classes})
    }

    contains(key: K): boolean {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        return near.storageHasKey(storageKey)
    }
    
    // Returns true if the element was present in the set.
    remove(key: K): boolean {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        return near.storageRemove(storageKey)
    }

    // If the set did not have this value present, `true` is returned.
    // If the set did have this value present, `false` is returned.
    set(key: K): boolean {
        let storageKey = this.keyPrefix + this.serializer.serialize(key)
        return !near.storageWrite(storageKey, '')
    }

    extend(keys: K[]) {
        for(let key of keys) {
            this.set(key)
        }
    }
}
'''
'''--- src/collections/unordered-map.ts ---
import * as near from "../api";
import { u8ArrayToBytes, bytesToU8Array, Bytes, ClassMap } from "../utils";
import { Vector, VectorIterator } from "./vector";
import { Serializer } from 'superserial';

const ERR_INCONSISTENT_STATE =
  "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";

export class UnorderedMap<K, V> {
  readonly length: number;
  readonly keyIndexPrefix: Bytes;
  readonly keys: Vector<K>;
  readonly values: Vector<V>;
  readonly serializer: Serializer;

  constructor(prefix: Bytes, classes?: ClassMap) {
    this.length = 0;
    this.keyIndexPrefix = prefix + "i";
    let indexKey = prefix + "k";
    let indexValue = prefix + "v";
    this.keys = new Vector(indexKey, classes);
    this.values = new Vector(indexValue, classes);
    this.serializer = new Serializer(classes)
  }

  len() {
    let keysLen = this.keys.len();
    let valuesLen = this.values.len();
    if (keysLen != valuesLen) {
      throw new Error(ERR_INCONSISTENT_STATE);
    }
    return keysLen;
  }

  isEmpty(): boolean {
    let keysIsEmpty = this.keys.isEmpty();
    let valuesIsEmpty = this.values.isEmpty();
    if (keysIsEmpty != valuesIsEmpty) {
      throw new Error(ERR_INCONSISTENT_STATE);
    }
    return keysIsEmpty;
  }

  serializeIndex(index: number): Bytes {
    let data = new Uint32Array([index]);
    let array = new Uint8Array(data.buffer);
    return u8ArrayToBytes(array);
  }

  deserializeIndex(rawIndex: Bytes) {
    let array = bytesToU8Array(rawIndex);
    let data = new Uint32Array(array.buffer);
    return data[0];
  }

  getIndexRaw(key: K): Bytes {
    let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
    let indexRaw = near.storageRead(indexLookup);
    return indexRaw;
  }

  get(key: K): V | null {
    let indexRaw = this.getIndexRaw(key);
    if (indexRaw) {
      let index = this.deserializeIndex(indexRaw);
      let value = this.values.get(index);
      if (value) {
        return value;
      } else {
        throw new Error(ERR_INCONSISTENT_STATE);
      }
    }
    return null;
  }

  set(key: K, value: V): V | null {
    let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
    let indexRaw = near.storageRead(indexLookup);
    if (indexRaw) {
      let index = this.deserializeIndex(indexRaw);
      return this.values.replace(index, value);
    } else {
      let nextIndex = this.len();
      let nextIndexRaw = this.serializeIndex(nextIndex);
      near.storageWrite(indexLookup, nextIndexRaw);
      this.keys.push(key);
      this.values.push(value);
      return null;
    }
  }

  remove(key: K): V | null {
    let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
    let indexRaw = near.storageRead(indexLookup);
    if (indexRaw) {
      if (this.len() == 1) {
        // If there is only one element then swap remove simply removes it without
        // swapping with the last element.
        near.storageRemove(indexLookup);
      } else {
        // If there is more than one element then swap remove swaps it with the last
        // element.
        let lastKey = this.keys.get(this.len() - 1);
        if (!lastKey) {
          throw new Error(ERR_INCONSISTENT_STATE);
        }
        near.storageRemove(indexLookup);
        // If the removed element was the last element from keys, then we don't need to
        // reinsert the lookup back.
        if (lastKey != key) {
          let lastLookupKey = this.keyIndexPrefix + this.serializer.serialize(lastKey);
          near.storageWrite(lastLookupKey, indexRaw);
        }
      }
      let index = this.deserializeIndex(indexRaw);
      this.keys.swapRemove(index);
      return this.values.swapRemove(index);
    }
    return null;
  }

  clear() {
    for (let key of this.keys) {
      let indexLookup = this.keyIndexPrefix + this.serializer.serialize(key);
      near.storageRemove(indexLookup);
    }
    this.keys.clear();
    this.values.clear();
  }

  toArray(): [K, V][] {
    let ret = [];
    for (let v of this) {
      ret.push(v);
    }
    return ret;
  }

  [Symbol.iterator](): UnorderedMapIterator<K, V> {
    return new UnorderedMapIterator<K, V>(this);
  }

  extend(kvs: [K, V][]) {
    for (let [k, v] of kvs) {
      this.set(k, v);
    }
  }
}

class UnorderedMapIterator<K, V> {
  private keys: VectorIterator<K>;
  private values: VectorIterator<V>;
  constructor(unorderedMap: UnorderedMap<K, V>) {
    this.keys = new VectorIterator(unorderedMap.keys);
    this.values = new VectorIterator(unorderedMap.values);
  }

  next(): { value: [K | null, V | null]; done: boolean } {
    let key = this.keys.next();
    let value = this.values.next();
    if (key.done != value.done) {
      throw new Error(ERR_INCONSISTENT_STATE);
    }
    return { value: [key.value, value.value], done: key.done };
  }
}

'''
'''--- src/collections/unordered-set.ts ---
import * as near from "../api";
import { u8ArrayToBytes, bytesToU8Array, Bytes, ClassMap } from "../utils";
import { Vector } from "./vector";
import { Serializer } from 'superserial';

const ERR_INCONSISTENT_STATE =
  "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";

export class UnorderedSet<E> {
  readonly length: number;
  readonly elementIndexPrefix: Bytes;
  readonly elements: Vector<E>;
  readonly serializer: Serializer;

  constructor(prefix: Bytes, classes?: ClassMap) {
    this.length = 0;
    this.elementIndexPrefix = prefix + "i";
    let elementsPrefix = prefix + "e";
    this.elements = new Vector(elementsPrefix, classes);
    this.serializer = new Serializer({classes});
  }

  len(): number {
    return this.elements.len();
  }

  isEmpty(): boolean {
    return this.elements.isEmpty();
  }

  serializeIndex(index: number) {
    let data = new Uint32Array([index]);
    let array = new Uint8Array(data.buffer);
    return u8ArrayToBytes(array);
  }

  deserializeIndex(rawIndex: Bytes): number {
    let array = bytesToU8Array(rawIndex);
    let data = new Uint32Array(array.buffer);
    return data[0];
  }

  contains(element: E): boolean {
    let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
    return near.storageHasKey(indexLookup);
  }

  set(element: E): boolean {
    let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
    if (near.storageRead(indexLookup)) {
      return false;
    } else {
      let nextIndex = this.len();
      let nextIndexRaw = this.serializeIndex(nextIndex);
      near.storageWrite(indexLookup, nextIndexRaw);
      this.elements.push(element);
      return true;
    }
  }

  remove(element: E): boolean {
    let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
    let indexRaw = near.storageRead(indexLookup);
    if (indexRaw) {
      if (this.len() == 1) {
        // If there is only one element then swap remove simply removes it without
        // swapping with the last element.
        near.storageRemove(indexLookup);
      } else {
        // If there is more than one element then swap remove swaps it with the last
        // element.
        let lastElement = this.elements.get(this.len() - 1);
        if (!lastElement) {
          throw new Error(ERR_INCONSISTENT_STATE);
        }
        near.storageRemove(indexLookup);
        // If the removed element was the last element from keys, then we don't need to
        // reinsert the lookup back.
        if (lastElement != element) {
          let lastLookupElement = this.elementIndexPrefix + this.serializer.serialize(lastElement);
          near.storageWrite(lastLookupElement, indexRaw);
        }
      }
      let index = this.deserializeIndex(indexRaw);
      this.elements.swapRemove(index);
      return true;
    }
    return false;
  }

  clear() {
    for (let element of this.elements) {
      let indexLookup = this.elementIndexPrefix + this.serializer.serialize(element);
      near.storageRemove(indexLookup);
    }
    this.elements.clear();
  }

  toArray(): Bytes[] {
    let ret = [];
    for (let v of this) {
      ret.push(v);
    }
    return ret;
  }

  [Symbol.iterator]() {
    return this.elements[Symbol.iterator]();
  }

  extend(elements: E[]) {
    for (let element of elements) {
      this.set(element);
    }
  }
}

'''
'''--- src/collections/vector.ts ---
import * as near from "../api";
import { Bytes, u8ArrayToBytes, ClassMap } from "../utils";
import { Serializer } from 'superserial';

const ERR_INDEX_OUT_OF_BOUNDS = "Index out of bounds";
const ERR_INCONSISTENT_STATE =
  "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";

function indexToKey(prefix: Bytes, index: number): Bytes {
  let data = new Uint32Array([index]);
  let array = new Uint8Array(data.buffer);
  let key = u8ArrayToBytes(array);
  return prefix + key;
}

/// An iterable implementation of vector that stores its content on the trie.
/// Uses the following map: index -> element
export class Vector<E> {
  length: number;
  readonly prefix: Bytes;
  readonly serializer: Serializer;

  constructor(prefix: Bytes, classes?: ClassMap) {
    this.length = 0;
    this.prefix = prefix;
    this.serializer = new Serializer({classes})
  }

  len(): number {
    return this.length;
  }

  isEmpty(): boolean {
    return this.length == 0;
  }

  get(index: number): E | null {
    if (index >= this.length) {
      return null;
    }
    let storageKey = indexToKey(this.prefix, index);
    return this.serializer.deserialize(near.storageRead(storageKey));
  }

  /// Removes an element from the vector and returns it in serialized form.
  /// The removed element is replaced by the last element of the vector.
  /// Does not preserve ordering, but is `O(1)`.
  swapRemove(index: number): E | null {
    if (index >= this.length) {
      throw new Error(ERR_INDEX_OUT_OF_BOUNDS);
    } else if (index + 1 == this.length) {
      return this.pop();
    } else {
      let key = indexToKey(this.prefix, index);
      let last = this.pop();
      if (near.storageWrite(key, this.serializer.serialize(last))) {
        return this.serializer.deserialize(near.storageGetEvicted());
      } else {
        throw new Error(ERR_INCONSISTENT_STATE);
      }
    }
  }

  push(element: E) {
    let key = indexToKey(this.prefix, this.length);
    this.length += 1;
    near.storageWrite(key, this.serializer.serialize(element));
  }

  pop(): E | null {
    if (this.isEmpty()) {
      return null;
    } else {
      let lastIndex = this.length - 1;
      let lastKey = indexToKey(this.prefix, lastIndex);
      this.length -= 1;
      if (near.storageRemove(lastKey)) {
        return this.serializer.deserialize(near.storageGetEvicted());
      } else {
        throw new Error(ERR_INCONSISTENT_STATE);
      }
    }
  }

  replace(index: number, element: E): E {
    if (index >= this.length) {
      throw new Error(ERR_INDEX_OUT_OF_BOUNDS);
    } else {
      let key = indexToKey(this.prefix, index);
      if (near.storageWrite(key, this.serializer.serialize(element))) {
        return this.serializer.deserialize(near.storageGetEvicted());
      } else {
        throw new Error(ERR_INCONSISTENT_STATE);
      }
    }
  }

  extend(elements: E[]) {
    for (let element of elements) {
      this.push(element);
    }
  }

  [Symbol.iterator](): VectorIterator<E> {
    return new VectorIterator(this);
  }

  clear() {
    for (let i = 0; i < this.length; i++) {
      let key = indexToKey(this.prefix, i);
      near.storageRemove(key);
    }
    this.length = 0;
  }

  toArray(): E[] {
    let ret = [];
    for (let v of this) {
      ret.push(v);
    }
    return ret;
  }
}

export class VectorIterator<E> {
  private current: number;
  private vector: Vector<E>;
  constructor(vector: Vector<E>) {
    this.current = 0;
    this.vector = vector;
  }

  next(): { value: E | null; done: boolean } {
    if (this.current < this.vector.len()) {
      let value = this.vector.get(this.current);
      this.current += 1;
      return { value, done: false };
    }
    return { value: null, done: true };
  }
}

'''
'''--- src/index.ts ---
import { call, view, NearBindgen } from "./near-bindgen";

import { NearContract } from "./near-contract";

import * as near from "./api";
import {
  LookupMap,
  Vector,
  LookupSet,
  UnorderedMap,
  UnorderedSet,
} from "./collections";

import { bytes, Bytes, assert } from "./utils";

export {
  call,
  view,
  NearBindgen,
  NearContract,
  near,
  LookupMap,
  Vector,
  LookupSet,
  UnorderedMap,
  UnorderedSet,
  bytes,
  Bytes,
  assert,
};

'''
'''--- src/near-bindgen.ts ---
export function call (target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<Function>): void {
}

export function view (target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<Function>): void {
}

export function NearBindgen<T extends { new(...args: any[]): {}}>(target: T) {
    return class extends target {
        static _init() {
            // @ts-ignore
            let args = target.deserializeArgs()
            let ret = new target(args)
            // @ts-ignore
            ret.serialize()
            return ret
        }

        static _get() {
            let ret = Object.create(target.prototype)
            return ret
        }
    }
}

'''
'''--- src/near-contract.ts ---
import * as near from "./api";

export class NearContract {
  deserialize() {
    let state = near.storageRead("STATE");
    if (state) {
      Object.assign(this, JSON.parse(state));
    } else {
      throw new Error("Contract state is empty");
    }
  }

  serialize() {
    near.storageWrite("STATE", JSON.stringify(this));
  }

  static deserializeArgs(): any {
    let args = near.input();
    return JSON.parse(args || "{}");
  }

  static serializeReturn(ret: any) {
    return JSON.stringify(ret);
  }
}

'''
'''--- src/utils.ts ---
// Type alias of bytes as string. This is done because internally, JSVM accepts `string`
// as bytes. In the future, this can be updated to a separate type if added support
// within quickjs/jsvm.
export type Bytes = string;

export function u8ArrayToBytes(array: Uint8Array) {
  let ret = "";
  for (let e of array) {
    ret += String.fromCharCode(e);
  }
  return ret;
}

// TODO this function is a bit broken and the type can't be string
// TODO for more info: https://github.com/near/near-sdk-js/issues/78
export function bytesToU8Array(bytes: Bytes): Uint8Array {
  let ret = new Uint8Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    ret[i] = bytes.charCodeAt(i);
  }
  return ret;
}

export function bytes(strOrU8Array: string | Uint8Array): Bytes {
  if (typeof strOrU8Array == "string") {
    return checkStringIsBytes(strOrU8Array);
  } else if (strOrU8Array instanceof Uint8Array) {
    return u8ArrayToBytes(strOrU8Array);
  }
  throw new Error("bytes: expected string or Uint8Array");
}

function checkStringIsBytes(str: string) {
  for (let i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) > 255) {
      throw new Error(
        `string ${str} at index ${i}: ${str[i]} is not a valid byte`
      );
    }
  }
  return str;
}

export function assert(b: boolean, str: string) {
  if (b) {
      return
  } else {
      throw Error("assertion failed: " + str)
  }
}

export type ClassMap = {
  [className: string]: ((new (...args: any[]) => any) | Function);
};
'''
'''--- tests/README.md ---
# NEAR-SDK-JS Tests

This tests the functionality of high level APIs of NEAR-SDK-JS. Currently, it directly tests all collections and indirectly tests all decorators, serialization/deserialization, utils, code generation and some important APIs. Majority of near-sdk-js can be seen as tested.

# Run tests
```
yarn
yarn build
yarn test
```

# Add a new test

Create a test contract that covers the API you want to test in `src/`. Add a build command in `build.sh`. Write ava test in `__tests__`.
'''
'''--- tests/__tests__/bytes.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const bytesContract = await root.devDeploy(
        'build/bytes.wasm',
    );
    // Test users
    const ali = await root.createSubAccount('ali');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, bytesContract, ali };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Log expected types work', async t => {
    const { ali, bytesContract } = t.context.accounts;

    let r = await ali.callRaw(bytesContract, 'log_expected_input_tests', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "abc",
            "",
            "333",
            '\x00\x01\xff',
            '\xe6\xb0\xb4',
            "",
            ""
        ]
    );
});

test('Log unexpected types not logging', async t => {
    const { ali, bytesContract } = t.context.accounts;

    let r = await ali.callRaw(bytesContract, 'log_unexpected_input_tests', '');
    // logUtf8 and logUtf16 only works with bytes, trying to log it with string is unexpected and behavior is undefined
    // in this specific case, it logs nothing
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "",
            "",
        ]
    );
});

test('Log invalid utf-8 sequence panic', async t => {
    const { ali, bytesContract } = t.context.accounts;

    let r = await ali.callRaw(bytesContract, 'log_invalid_utf8_sequence_test', '');
    // console.log(JSON.stringify(r, null, 2))
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
});

test('Log invalid utf-16 sequence panic', async t => {
    const { ali, bytesContract } = t.context.accounts;

    let r = await ali.callRaw(bytesContract, 'log_invalid_utf16_sequence_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-16 sequence.'
    );
});

function encodeStateKey(k) {
    return Buffer.from(k).toString('base64')
}

test('storage write bytes tests', async t => {
    const { ali, bytesContract } = t.context.accounts;

    await ali.call(bytesContract, 'storage_write_bytes', '');
    let stateMap = new Map()
    // viewState doesn't work, because it tries to convert key to utf-8 string, which is not. So we use viewStateRaw
    let state = await bytesContract.viewStateRaw()
    for (let {key, value} of state) {
        stateMap.set(key, value)
    }

    t.deepEqual(
        stateMap.get(encodeStateKey('abc')),
        Buffer.from('def').toString('base64')
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([0x00, 0x01, 0xff])),
        Buffer.from([0xe6, 0xb0, 0xb4]).toString('base64')
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([0xe6, 0xb0, 0xb4])),
        Buffer.from([0x00, 'a'.charCodeAt(0), 'b'.charCodeAt(0)]).toString('base64')
    );
});

test('storage write unexpected types tests', async t => {
    const { ali, bytesContract } = t.context.accounts;

    await ali.call(bytesContract, 'storage_write_unexpected_input', '');
    let stateMap = new Map()
    // viewState doesn't work, because it tries to convert key to utf-8 string, which is not
    let state = await bytesContract.viewStateRaw()
    for (let {key, value} of state) {
        stateMap.set(key, value)
    }

    t.deepEqual(
        stateMap.get(encodeStateKey('123')),
        Buffer.from('456').toString('base64')
    );
    // pass in utf-8 string instead of bytes, key and value become empty 
    t.deepEqual(
        stateMap.get(encodeStateKey([0xe6, 0xb0, 0xb4])),
        undefined
    );
    t.deepEqual(
        stateMap.get(encodeStateKey([])),
        ''
    );
});

test('Storage read bytes tests', async t => {
    const { ali, bytesContract } = t.context.accounts;

    await ali.call(bytesContract, 'storage_write_bytes', '');
    let r = await bytesContract.viewRaw('storage_read_ascii_bytes', '');
    console.log(r)
    t.deepEqual(
        r.result,
        [100, 101, 102]
    );

    r = await bytesContract.viewRaw('storage_read_arbitrary_bytes_key_utf8_sequence_bytes_value', '');
    t.deepEqual(
        r.result,
        [0xe6, 0xb0, 0xb4]
    );

    r = await bytesContract.viewRaw('storage_read_utf8_sequence_bytes_key_arbitrary_bytes_value', '');
    t.deepEqual(
        r.result,
        [0x00, 'a'.charCodeAt(0), 'b'.charCodeAt(0)]
    );
});

test('panic tests', async t => {
    const { ali, bytesContract } = t.context.accounts;
    let r = await ali.callRaw(bytesContract, 'panic_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(bytesContract, 'panic_ascii_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: abc'
    );

    r = await ali.callRaw(bytesContract, 'panic_js_number', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: 356'
    );

    r = await ali.callRaw(bytesContract, 'panic_js_undefined', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(bytesContract, 'panic_js_null', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: null'
    );

    r = await ali.callRaw(bytesContract, 'panic_utf8_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(bytesContract, 'panicUtf8_valid_utf8_sequence', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(bytesContract, 'panicUtf8_invalid_utf8_sequence', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
})
'''
'''--- tests/__tests__/function-params.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const functionParamsContract = await root.devDeploy(
        'build/function-params.wasm',
    );
    await functionParamsContract.call(functionParamsContract, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, functionParamsContract, ali, bob, carl };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('get current account id correct', async t => {
    const { ali, functionParamsContract } = t.context.accounts;
    await ali.call(functionParamsContract, 'set_values', { param1: 'newVal1', param2: 'newVal2', param3: 'newVal3' });
    let values = await functionParamsContract.view('get_values', '');
    t.deepEqual(values,  { val3: 'newVal3', val2: 'newVal2', val1: 'newVal1' });
});

'''
'''--- tests/__tests__/lookup-map.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const lookupMapContract = await root.devDeploy(
        'build/lookup-map.wasm',
    );
    await lookupMapContract.call(lookupMapContract, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, lookupMapContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('LookupMap set() get()', async t => {
    const { ali, lookupMapContract } = t.context.accounts;

    t.is(
        await lookupMapContract.view('get', { key: 'hello' }),
        null
    );
    t.is(
        await lookupMapContract.view('containsKey', { key: 'hello' }),
        false
    );

    await ali.call(lookupMapContract, 'set', { key: 'hello', value: 'world' });

    t.is(
        await lookupMapContract.view('get', { key: 'hello' }),
        'world'
    );
    t.is(
        await lookupMapContract.view('containsKey', { key: 'hello' }),
        true
    );
});

test('LookupMap update, remove', async t => {
    const { ali, lookupMapContract } = t.context.accounts;

    await ali.call(lookupMapContract, 'set', { key: 'hello', value: 'world' });
    await ali.call(lookupMapContract, 'set', { key: 'hello1', value: 'world0' });

    // update a value, len shouldn't change
    await ali.call(lookupMapContract, 'set', { key: 'hello1', value: 'world1' });
    // update should have effect
    t.is(
        await lookupMapContract.view('get', { key: 'hello1' }),
        'world1'
    );
    // not update key should not changed
    t.is(
        await lookupMapContract.view('get', { key: 'hello' }),
        'world'
    );
    // remove non existing element should not error
    await ali.call(lookupMapContract, 'remove_key', { key: 'hello3' });
    // remove existing key should work
    await ali.call(lookupMapContract, 'remove_key', { key: 'hello1' });
    t.is(
        await lookupMapContract.view('containsKey', { key: 'hello1' }),
        false
    );
    // not removed key should not affected
    t.is(
        await lookupMapContract.view('get', { key: 'hello' }),
        'world'
    );
});

test('LookupMap extend', async t => {
    const { ali, lookupMapContract } = t.context.accounts;

    await ali.call(lookupMapContract, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] });
    t.is(
        await lookupMapContract.view('get', { key: 'hello' }),
        'world'
    );
    t.is(
        await lookupMapContract.view('get', { key: 'hello1' }),
        'world1'
    );
    t.is(
        await lookupMapContract.view('get', { key: 'hello2' }),
        'world2'
    );
})

test('LookupMap set get object', async t => {
    const { ali, lookupMapContract } = t.context.accounts;
    await ali.call(lookupMapContract, 'add_house', {});
    t.is(
        await lookupMapContract.view('get_house', {}),
        'house house1 has 2 rooms. room room1 is 200sqft.'
    )
    
})
'''
'''--- tests/__tests__/lookup-set.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const lookupSetContract = await root.devDeploy(
        'build/lookup-set.wasm',
    );
    await lookupSetContract.call(lookupSetContract, 'init', {});
    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, lookupSetContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('LookupSet set() contains()', async t => {
    const { ali, lookupSetContract } = t.context.accounts;
    t.is(
        await lookupSetContract.view('contains', { key: 'hello' }),
        false
    );

    await ali.call(lookupSetContract, 'set', { key: 'hello' });

    t.is(
        await lookupSetContract.view('contains', { key: 'hello' }),
        true
    );
});

test('LookupSet remove', async t => {
    const { ali, lookupSetContract } = t.context.accounts;

    await ali.call(lookupSetContract, 'set', { key: 'hello' });
    await ali.call(lookupSetContract, 'set', { key: 'hello1' });

    // remove non existing element should not error
    await ali.call(lookupSetContract, 'remove_key', { key: 'hello3' });
    // remove existing key should work
    await ali.call(lookupSetContract, 'remove_key', { key: 'hello1' });
    t.is(
        await lookupSetContract.view('contains', { key: 'hello1' }),
        false
    );
    // not removed key should not affected
    t.is(
        await lookupSetContract.view('contains', { key: 'hello' }),
        true
    );
});

test('LookupSet extend', async t => {
    const { ali, lookupSetContract } = t.context.accounts;

    await ali.call(lookupSetContract, 'extend', { keys: ['hello', 'world', 'hello1'] });
    t.is(
        await lookupSetContract.view('contains', { key: 'hello' }),
        true
    );
    t.is(
        await lookupSetContract.view('contains', { key: 'hello1' }),
        true
    );
    t.is(
        await lookupSetContract.view('contains', { key: 'world' }),
        true
    );
})

test('Add and check exist of object', async t => {
    const { ali, lookupSetContract } = t.context.accounts;
    let houseSpec = {name: "a", rooms: [{name: "bedroom", size: "300sqft"}]}
    t.is(
        await lookupSetContract.view('house_exist', houseSpec),
        false
    );
    await ali.call(lookupSetContract, 'add_house', houseSpec);
    t.is(
        await lookupSetContract.view('house_exist', houseSpec),
        true
    );
})
'''
'''--- tests/__tests__/test_context_api.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const contextApiContract = await root.devDeploy(
        'build/context_api.wasm',
    );

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, contextApiContract, ali, bob, carl };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('get current account id correct', async t => {
    const { ali, contextApiContract } = t.context.accounts;
    let r = await ali.call(contextApiContract, 'get_current_account_id', '');
    t.is(r, contextApiContract.accountId);
});

test('get signer account id correct', async t => {
    const { ali, contextApiContract } = t.context.accounts;
    let r = await ali.call(contextApiContract, 'get_signer_account_id', '');
    t.is(r, ali.accountId);
});

test('get predecessor account id correct', async t => {
    const { ali, contextApiContract } = t.context.accounts;
    let r = await ali.call(contextApiContract, 'get_predecessor_account_id', '');
    t.is(r, ali.accountId);
});

test('get signer account pk correct', async t => {
    const { ali, contextApiContract } = t.context.accounts;
    let r = await ali.callRaw(contextApiContract, 'get_signer_account_pk', '');
    // the prefixing byte 0 indicates it's a ED25519 PublicKey, see how PublicKey is serialized in nearcore
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.concat([Buffer.from([0]), Buffer.from((await ali.getKey(ali.accountId)).getPublicKey().data)]));
});

test('get input correct', async t => {
    const { bob, contextApiContract } = t.context.accounts;
    let r = await bob.callRaw(contextApiContract, 'get_input', new Uint8Array([0, 1, 255]));
    t.is(r.result.status.SuccessValue, Buffer.from(new Uint8Array([0, 1, 255])).toString('base64'));
});

test('get storage usage', async t => {
    const { carl, contextApiContract } = t.context.accounts;
    let r = await carl.call(contextApiContract, 'get_storage_usage', '', {gas: '10 TGas'});
    t.is(r>0, true);
});

test('get block height', async t => {
    const { bob, contextApiContract } = t.context.accounts;
    let r = await bob.call(contextApiContract, 'get_block_height', '');
    t.is(r > 0, true);
});

test('get block timestamp', async t => {
    let time = new Date().getTime() * 1e6;
    const { bob, contextApiContract } = t.context.accounts;
    let r = await bob.call(contextApiContract, 'get_block_timestamp', '');
    t.is(r > time, true);
});

test('get epoch height', async t => {
    const { bob, contextApiContract } = t.context.accounts;
    let r = await bob.call(contextApiContract, 'get_epoch_height', '');
    t.is(r, 1);
});

test('get attached deposit', async t => {
    const { carl, contextApiContract } = t.context.accounts;
    let r = await carl.call(contextApiContract, 'get_attached_deposit', '', {attachedDeposit: 3});
    t.is(r, 3);
});

test('get prepaid gas', async t => {
    const { carl, contextApiContract } = t.context.accounts;
    let r = await carl.call(contextApiContract, 'get_prepaid_gas', '', {gas: '10 TGas'});
    t.is(r, 10000000000000);
});

test('get used gas', async t => {
    const { carl, contextApiContract } = t.context.accounts;
    let r = await carl.call(contextApiContract, 'get_used_gas', '', {gas: '10 TGas'});
    t.is(r>0, true);
    t.is(r<10000000000000, true);
});

test('get random seed', async t => {
    const { carl, contextApiContract } = t.context.accounts;
    let r = await carl.callRaw(contextApiContract, 'get_random_seed', '');
    t.is(Buffer.from(r.result.status.SuccessValue, 'base64').length, 32);
});

test('get validator stake test', async t => {
    const { carl, contextApiContract, root } = t.context.accounts;
    let r = await carl.call(contextApiContract, 'get_validator_stake', '');
    t.is(r, 0);
    r = await root.callRaw(contextApiContract, 'get_validator_stake', '');
    t.is(Buffer.from(r.result.status.SuccessValue, 'base64').toString('ascii'), '50000000000000000000000000000000');
    r = await contextApiContract.viewRaw('get_total_stake', '');
    t.is(Buffer.from(r.result).toString('ascii'), '50000000000000000000000000000000');
});
'''
'''--- tests/__tests__/test_log_panic_api.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const testContract = await root.devDeploy(
        'build/log_panic_api.wasm',
    );

    // Test users
    const ali = await root.createSubAccount('ali');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, testContract, ali };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Log expected types work', async t => {
    const { ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(testContract, 'log_expected_input_tests', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "abc",
            "",
            "333",
            '\x00\x01\xff',
            '\xe6\xb0\xb4',
            "",
            ""
        ]
    );
});

test('Log unexpected types not logging', async t => {
    const { ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(testContract, 'log_unexpected_input_tests', '');
    // logUtf8 and logUtf16 only works with bytes, trying to log it with string is unexpected and behavior is undefined
    // in this specific case, it logs nothing
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.logs,
        [
            "",
            "",
        ]
    );
});

test('Log invalid utf-8 sequence panic', async t => {
    const { ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(testContract, 'log_invalid_utf8_sequence_test', '');
    // console.log(JSON.stringify(r, null, 2))
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
});

test('Log invalid utf-16 sequence panic', async t => {
    const { ali, testContract } = t.context.accounts;

    let r = await ali.callRaw(testContract, 'log_invalid_utf16_sequence_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-16 sequence.'
    );
});

test('panic tests', async t => {
    const { ali, testContract } = t.context.accounts;
    let r = await ali.callRaw(testContract, 'panic_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(testContract, 'panic_ascii_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: abc'
    );

    r = await ali.callRaw(testContract, 'panic_js_number', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: 356'
    );

    r = await ali.callRaw(testContract, 'panic_js_undefined', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: explicit guest panic'
    );

    r = await ali.callRaw(testContract, 'panic_js_null', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: null'
    );

    r = await ali.callRaw(testContract, 'panic_utf8_test', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(testContract, 'panicUtf8_valid_utf8_sequence', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'Smart contract panicked: '
    );

    r = await ali.callRaw(testContract, 'panicUtf8_invalid_utf8_sequence', '');
    t.deepEqual(
        r.result.receipts_outcome[0].outcome.status.Failure.ActionError.kind.FunctionCallError.ExecutionError,
        'String encoding is bad UTF-8 sequence.'
    );
})
'''
'''--- tests/__tests__/test_math_api.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const mathApiContract = await root.devDeploy(
        'build/math_api.wasm',
    );

    // Test users
    const ali = await root.createSubAccount('ali');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, mathApiContract, ali };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('sha256', async t => {
    const { ali, mathApiContract } = t.context.accounts;
    let r = await ali.callRaw(mathApiContract, 'test_sha256', '');
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([
        18, 176, 115, 156, 45, 100, 241, 132, 180, 134, 77, 42, 105, 111, 199, 127, 118, 112,
        92, 255, 88, 43, 83, 147, 122, 55, 26, 36, 42, 156, 160, 158,
    ]));
});

test('keccak256', async t => {
    const { ali, mathApiContract } = t.context.accounts;
    let r = await ali.callRaw(mathApiContract, 'test_keccak256', '');
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([
        104, 110, 58, 122, 230, 181, 215, 145, 231, 229, 49, 162, 123, 167, 177, 58, 26, 142,
        129, 173, 7, 37, 9, 26, 233, 115, 64, 102, 61, 85, 10, 159,
    ]));
});

test('keccak512', async t => {
    const { ali, mathApiContract } = t.context.accounts;
    let r = await ali.callRaw(mathApiContract, 'test_keccak512', '');
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([
        55, 134, 96, 137, 168, 122, 187, 95, 67, 76, 18, 122, 146, 11, 225, 106, 117, 194, 154,
        157, 48, 160, 90, 146, 104, 209, 118, 126, 222, 230, 200, 125, 48, 73, 197, 236, 123,
        173, 192, 197, 90, 153, 167, 121, 100, 88, 209, 240, 137, 86, 239, 41, 87, 128, 219,
        249, 136, 203, 220, 109, 46, 168, 234, 190
    ]));
});

test('ripemd160', async t => {
    const { ali, mathApiContract } = t.context.accounts;
    let r = await ali.callRaw(mathApiContract, 'test_ripemd160', '');
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([
        21, 102, 156, 115, 232, 3, 58, 215, 35, 84, 129, 30, 143, 86, 212, 104, 70, 97, 14, 225,
    ]));
});

test('ecrecover', async t => {
    const { ali, mathApiContract } = t.context.accounts;
    let r = await ali.callRaw(mathApiContract, 'test_ecrecover', '');
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([
        227,  45, 244,  40, 101, 233, 113,  53, 172, 251, 101,
        243, 186, 231,  27, 220, 134, 244, 212, 145,  80, 173,
        106,  68,  11, 111,  21, 135, 129,   9, 136,  10,  10,
         43,  38, 103, 247, 231,  37, 206, 234, 112, 198, 115,
          9,  59, 246, 118,  99, 224,  49,  38,  35, 200, 224,
        145, 177,  60, 242, 192, 241,  30, 246,  82
    ]));
});

// As of Jun 24, 2022, near-sandbox is using 97c0410de519ecaca369aaee26f0ca5eb9e7de06, in which alt_bn256 is still
// under nightly protocol feature. As near-sandbox is built without nightly protocol feature, alt_bn256 operations
// cannot be tested yet
'''
'''--- tests/__tests__/test_promise_api.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.before(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Create and deploy caller contract
    const callerContract = await root.createSubAccount('caller-contract');
    await callerContract.deploy('build/promise_api.wasm');

    // Create and deploy callee contract
    const calleeContract = await root.createSubAccount('callee-contract');
    await calleeContract.deploy('build/promise_api.wasm');

    // Create and deploy caller2 contract
    const caller2Contract = await root.createSubAccount('caller2', {initialBalance: '100100N'});
    await caller2Contract.deploy('build/promise_batch_api.wasm');

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, callerContract, calleeContract, ali, bob, caller2Contract };
});

test.after(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('promise create', async t => {
    const { ali, callerContract, calleeContract } = t.context.accounts;
    // default is 30 TGas, sufficient when the callee contract method is trivial
    let r = await ali.callRaw(callerContract, 'test_promise_create', '', {gas: '40 Tgas'});
    t.is(r.result.receipts_outcome[1].outcome.executor_id, calleeContract.accountId);
    t.deepEqual(Buffer.from(r.result.receipts_outcome[1].outcome.status.SuccessValue, 'base64'), Buffer.from(JSON.stringify({
        currentAccountId: calleeContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'abc',
    })));
});

test('promise then', async t => {
    const { ali, callerContract, calleeContract } = t.context.accounts;
    let r = await ali.callRaw(callerContract, 'test_promise_then', '', {gas: '70 Tgas'});
    // console.log(JSON.stringify(r, null, 2))
    // call the callee
    t.is(r.result.receipts_outcome[1].outcome.executor_id, calleeContract.accountId);
    t.deepEqual(JSON.parse(Buffer.from(r.result.receipts_outcome[1].outcome.status.SuccessValue, 'base64')), {
        currentAccountId: calleeContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'abc',
    });

    // the callback scheduled by promise_then
    t.is(r.result.receipts_outcome[3].outcome.executor_id, callerContract.accountId);
    t.deepEqual(JSON.parse(Buffer.from(r.result.receipts_outcome[3].outcome.status.SuccessValue, 'base64')), {
        currentAccountId: callerContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'def',
        promiseResults: [JSON.stringify({
            currentAccountId: calleeContract.accountId,
            signerAccountId: ali.accountId,
            predecessorAccountId: callerContract.accountId,
            input: 'abc',
        })]
    });
});

test('promise and', async t => {
    const { ali, callerContract, calleeContract } = t.context.accounts;
    let r = await ali.callRaw(callerContract, 'test_promise_and', '', {gas: '150 Tgas'});
    // console.log(JSON.stringify(r, null, 2))
    // promise and schedule to call the callee
    t.is(r.result.receipts_outcome[1].outcome.executor_id, calleeContract.accountId);
    t.deepEqual(JSON.parse(Buffer.from(r.result.receipts_outcome[1].outcome.status.SuccessValue, 'base64')), {
        currentAccountId: calleeContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'abc',
    });

    // promise and schedule to call the callee, with different args
    t.is(r.result.receipts_outcome[3].outcome.executor_id, calleeContract.accountId);
    t.deepEqual(JSON.parse(Buffer.from(r.result.receipts_outcome[3].outcome.status.SuccessValue, 'base64')), {
        currentAccountId: calleeContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'def',
    });

    // the callback scheduled by promise_then on the promise created by promise_and
    t.is(r.result.receipts_outcome[5].outcome.executor_id, callerContract.accountId);
    t.deepEqual(JSON.parse(Buffer.from(r.result.receipts_outcome[5].outcome.status.SuccessValue, 'base64')), {
        currentAccountId: callerContract.accountId,
        signerAccountId: ali.accountId,
        predecessorAccountId: callerContract.accountId,
        input: 'ghi',
        promiseResults: [JSON.stringify({
            currentAccountId: calleeContract.accountId,
            signerAccountId: ali.accountId,
            predecessorAccountId: callerContract.accountId,
            input: 'abc',
        }), JSON.stringify({
            currentAccountId: calleeContract.accountId,
            signerAccountId: ali.accountId,
            predecessorAccountId: callerContract.accountId,
            input: 'def',
        })]
    });
});

test('promise batch create account, transfer', async t => {
    const { bob, caller2Contract } = t.context.accounts;

    let r = await bob.callRaw(caller2Contract, 'test_promise_batch_create_transfer', '', {gas: '100 Tgas'});
    t.is(r.result.receipts_outcome[1].outcome.executor_id, caller2Contract.getSubAccount('a').accountId);
    t.is(r.result.receipts_outcome[1].outcome.status.SuccessValue, '');

    let balance = await caller2Contract.getSubAccount('a').balance()
    t.is(balance.total.toString(), '10000000000000000000000000')
});

test('promise batch deploy contract and call', async t => {
    const { bob, caller2Contract } = t.context.accounts;

    let r = await bob.callRaw(caller2Contract, 'test_promise_batch_deploy_call', '', {gas: '200 Tgas'});
    let deployed = caller2Contract.getSubAccount('b');
    t.deepEqual(JSON.parse(Buffer.from(r.result.status.SuccessValue, 'base64')), {
        currentAccountId: deployed.accountId,
        signerAccountId: bob.accountId,
        predecessorAccountId: caller2Contract.accountId,
        input: 'abc',
    });
});

test('promise batch stake', async t => {
    const { caller2Contract } = t.context.accounts;
    await caller2Contract.callRaw(caller2Contract, 'test_promise_batch_stake', '', {gas: '100 Tgas'});
    let balance = await caller2Contract.balance();
    t.is(balance.staked.toString(), '100000000000000000000000000000');
});

test('promise batch add full access key', async t => {
    const { bob, caller2Contract } = t.context.accounts;
    let r = await bob.callRaw(caller2Contract, 'test_promise_add_full_access_key', '', {gas: '100 Tgas'});
    t.is(r.result.status.SuccessValue, '');
});

test('promise batch add function call key', async t => {
    const { bob, caller2Contract } = t.context.accounts;
    let r = await bob.callRaw(caller2Contract, 'test_promise_add_function_call_access_key', '', {gas: '100 Tgas'});
    t.is(r.result.status.SuccessValue, '');
});

test('promise delete account', async t => {
    const { bob, caller2Contract } = t.context.accounts;
    let r = await bob.callRaw(caller2Contract, 'test_delete_account', '', {gas: '100 Tgas'});
    t.is(r.result.status.SuccessValue, '');
    t.is(await caller2Contract.getSubAccount('e').exists(), false);
});
'''
'''--- tests/__tests__/test_storage_api.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Use beforeEach instead of before to start from scratch state for each test
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const storageApiContract = await root.devDeploy(
        'build/storage_api.wasm',
    );

    // Test users
    const ali = await root.createSubAccount('ali');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, storageApiContract, ali };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('storage read write', async t => {
    const { ali, storageApiContract } = t.context.accounts;

    let exist = await ali.call(storageApiContract, 'test_storage_write', '');
    t.is(exist, false);
    let r = await storageApiContract.viewRaw('test_storage_read', '');
    t.deepEqual(r.result, [0, 1, 255]);
    exist = await ali.call(storageApiContract, 'test_storage_write', '');
    t.is(exist, true);
});

test('storage remove', async t => {
    const { ali, storageApiContract } = t.context.accounts;
    let hasKey = await storageApiContract.view('test_storage_has_key', '');
    t.is(hasKey, false);
    let exist = await ali.call(storageApiContract, 'test_storage_remove', '');
    t.is(exist, false);
    
    await ali.call(storageApiContract, 'test_storage_write', '');

    hasKey = await storageApiContract.view('test_storage_has_key', '');
    t.is(hasKey, true);
    exist = await ali.call(storageApiContract, 'test_storage_remove', '');
    t.is(exist, true);
})

test('storage get evicted', async t => {
    const { ali, storageApiContract } = t.context.accounts;

    let r = await ali.callRaw(storageApiContract, 'test_storage_get_evicted', '');
    console.log(JSON.stringify(r,null,2))
    t.deepEqual(Buffer.from(r.result.status.SuccessValue, 'base64'), Buffer.from([0, 1, 255]));
});
'''
'''--- tests/__tests__/unordered-map.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const unorderedMapContract = await root.devDeploy(
        'build/unordered-map.wasm',
    );
    await unorderedMapContract.call(unorderedMapContract, 'init', {});
    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, unorderedMapContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('UnorderedMap is empty by default', async t => {
    const { root, unorderedMapContract } = t.context.accounts;
    const result = await unorderedMapContract.view('len', {});
    t.is(result, 0);
});

test('UnorderedMap set() get()', async t => {
    const { ali, unorderedMapContract } = t.context.accounts;
    t.is(
        await unorderedMapContract.view('get', { key: 'hello' }),
        null
    );

    await ali.call(unorderedMapContract, 'set', { key: 'hello', value: 'world' });

    t.is(
        await unorderedMapContract.view('get', { key: 'hello' }),
        'world'
    );
});

test('UnorderedMap insert, update, len and iterate', async t => {
    const { ali, unorderedMapContract } = t.context.accounts;

    t.is(
        await unorderedMapContract.view('len', {}),
        0
    );
    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        []
    );

    await ali.call(unorderedMapContract, 'set', { key: 'hello', value: 'world' });
    await ali.call(unorderedMapContract, 'set', { key: 'hello1', value: 'world0' });
    t.is(
        await unorderedMapContract.view('len', {}),
        2
    );

    // update a value, len shouldn't change
    await ali.call(unorderedMapContract, 'set', { key: 'hello1', value: 'world1' });
    t.is(
        await unorderedMapContract.view('len', {}),
        2
    );
    // update should have effect
    t.is(
        await unorderedMapContract.view('get', { key: 'hello1' }),
        'world1'
    );

    await ali.call(unorderedMapContract, 'set', { key: 'hello2', value: 'world2' });
    t.is(
        await unorderedMapContract.view('len', {}),
        3
    );

    // Try to set a key with same value, len shouldn't change
    await ali.call(unorderedMapContract, 'set', { key: 'hello2', value: 'world2' });
    t.is(
        await unorderedMapContract.view('len', {}),
        3
    );

    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );
});

test('UnorderedMap extend, remove, clear', async t => {
    const { ali, unorderedMapContract } = t.context.accounts;

    await ali.call(unorderedMapContract, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] });

    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );

    // remove non existing element should not error
    await ali.call(unorderedMapContract, 'remove_key', { key: 'hello3' });
    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']]
    );

    // remove not the last one should work
    await ali.call(unorderedMapContract, 'remove_key', { key: 'hello' });
    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        [['hello2', 'world2'], ['hello1', 'world1']]
    );

    // remove the last one should work
    await ali.call(unorderedMapContract, 'remove_key', { key: 'hello1' });
    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        [['hello2', 'world2']]
    );

    // remove when length is 1 should work
    t.is(
        await unorderedMapContract.view('len', {}),
        1
    );
    t.is(
        await unorderedMapContract.view('isEmpty', {}),
        false
    );
    await ali.call(unorderedMapContract, 'remove_key', { key: 'hello2' });
    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        []
    );
    t.is(
        await unorderedMapContract.view('isEmpty', {}),
        true
    );

    await ali.call(unorderedMapContract, 'extend', { kvs: [['hello', 'world'], ['hello1', 'world1'], ['hello2', 'world2']] });
    t.is(
        await unorderedMapContract.view('isEmpty', {}),
        false
    );
    await ali.call(unorderedMapContract, 'clear', {});

    t.deepEqual(
        await unorderedMapContract.view('toArray', {}),
        []
    );
    t.is(
        await unorderedMapContract.view('isEmpty', {}),
        true
    );
})

test('UnorderedMap set get object', async t => {
    const { ali, unorderedMapContract } = t.context.accounts;
    await ali.call(unorderedMapContract, 'add_house', {});
    t.is(
        await unorderedMapContract.view('get_house', {}),
        'house house1 has 2 rooms. room room1 is 200sqft.'
    )
    
})
'''
'''--- tests/__tests__/unordered-set.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

function encodeCall(contract, method, args) {
    return Buffer.concat([Buffer.from(contract), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(JSON.stringify(args))])
}

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const unorderedSetContract = await root.devDeploy(
        'build/unordered-set.wasm',
    );
    await unorderedSetContract.call(unorderedSetContract, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, unorderedSetContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('UnorderedSet is empty by default', async t => {
    const { root, unorderedSetContract } = t.context.accounts;
    const result = await unorderedSetContract.view('len', {});
    t.is(result, 0);
    t.is(
        await unorderedSetContract.view('isEmpty', {}),
        true
    );
});

test('UnorderedSet set() contains()', async t => {
    const { ali, unorderedSetContract } = t.context.accounts;
    t.is(
        await unorderedSetContract.view('contains', { element: 'hello' }),
        false
    );

    await ali.call(unorderedSetContract, 'set', { element: 'hello' });

    t.is(
        await unorderedSetContract.view('contains', { element: 'hello' }),
        true
    );
});

test('UnorderedSet insert, len and iterate', async t => {
    const { ali, unorderedSetContract } = t.context.accounts;

    t.is(
        await unorderedSetContract.view('len', {}),
        0
    );
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        []
    );

    await ali.call(unorderedSetContract, 'set', { element: 'hello' });
    t.is(
        await unorderedSetContract.view('len', {}),
        1
    );
    await ali.call(unorderedSetContract, 'set', { element: 'hello1' });
    t.is(
        await unorderedSetContract.view('len', {}),
        2
    );

    // insert the same value, len shouldn't change
    await ali.call(unorderedSetContract, 'set', { element: 'hello1' });
    t.is(
        await unorderedSetContract.view('len', {}),
        2
    );

    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello', 'hello1']
    );
});

test('UnorderedSet extend, remove, clear', async t => {
    const { ali, unorderedSetContract } = t.context.accounts;

    await ali.call(unorderedSetContract, 'extend', { elements: ['hello', 'world', 'hello1'] });

    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello', 'world', 'hello1']
    );

    // remove non existing element should not error
    await ali.call(unorderedSetContract, 'remove_key', { element: 'hello3' });
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello', 'world', 'hello1']
    );

    // remove not the last one should work
    await ali.call(unorderedSetContract, 'remove_key', { element: 'hello' });
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello1', 'world']
    );

    // remove the last one should work
    await ali.call(unorderedSetContract, 'remove_key', { element: 'world' });
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello1']
    );

    // remove when length is 1 should work
    t.is(
        await unorderedSetContract.view('len', {}),
        1
    );
    t.is(
        await unorderedSetContract.view('isEmpty', {}),
        false
    );
    await ali.call(unorderedSetContract, 'remove_key', { element: 'hello1' });
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        []
    );
    t.is(
        await unorderedSetContract.view('isEmpty', {}),
        true
    );

    await ali.call(unorderedSetContract, 'extend', { elements: ['hello', 'world', 'hello1'] });
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        ['hello', 'world', 'hello1']
    );
    t.is(
        await unorderedSetContract.view('isEmpty', {}),
        false
    );
    // clear should work
    await ali.call(unorderedSetContract, 'clear', {});
    t.deepEqual(
        await unorderedSetContract.view('toArray', {}),
        []
    );
    t.is(
        await unorderedSetContract.view('isEmpty', {}),
        true
    );
})

test('Add and check exist of object', async t => {
    const { ali, unorderedSetContract } = t.context.accounts;
    let houseSpec = {name: "a", rooms: [{name: "bedroom", size: "300sqft"}]}
    t.is(
        await unorderedSetContract.view('house_exist', houseSpec),
        false
    );
    await ali.call(unorderedSetContract, 'add_house', houseSpec);
    t.is(
        await unorderedSetContract.view('house_exist', houseSpec),
        true
    );
})
'''
'''--- tests/__tests__/vector.ava.js ---
import { Worker } from 'near-workspaces';
import { readFile } from 'fs/promises'
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etx.
    const root = worker.rootAccount;

    // Deploy the test contract.
    const vectorContract = await root.devDeploy(
        'build/vector.wasm',
    );
    await vectorContract.call(vectorContract, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');
    const carl = await root.createSubAccount('carl');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, vectorContract, ali, bob, carl };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Vector is empty by default', async t => {
    const { root, vectorContract } = t.context.accounts;
    let result = await vectorContract.view('len', {});
    t.is(result, 0);
    t.is(
        await vectorContract.view('isEmpty', {}),
        true
    );
});

test('Vector push, get, pop, replace', async t => {
    const { ali, vectorContract } = t.context.accounts;
    await ali.call(vectorContract, 'push', { value: 'hello' });
    await ali.call(vectorContract, 'push', { value: 'world' });
    await ali.call(vectorContract, 'push', { value: 'aaa' });
    let result = await vectorContract.view('len', {});
    t.is(result, 3);
    t.is(
        await vectorContract.view('get', { index: 0 }),
        'hello'
    );
    t.is(
        await vectorContract.view('get', { index: 2 }),
        'aaa'
    );
    t.is(
        await vectorContract.view('get', { index: 3 }),
        null
    );

    await ali.call(vectorContract, 'pop', {});
    result = await vectorContract.view('len', {}),
    t.is(result, 2);
    t.is(
        await vectorContract.view('get', { index: 2 }),
        null
    );
    t.is(
        await vectorContract.view('get', { index: 1 }),
        'world'
    );
    await ali.call(vectorContract, 'replace', { index: 1, value: 'aaa' });
    t.is(
        await vectorContract.view('get', { index: 1 }),
        'aaa'
    );
});

test('Vector extend, toArray, swapRemove, clear', async t => {
    const { ali, vectorContract } = t.context.accounts;

    await ali.call(vectorContract, 'extend', { kvs: ['hello', 'world', 'aaa'] });

    t.deepEqual(
        await vectorContract.view('toArray', {}),
        ['hello', 'world', 'aaa']
    );

    // swapRemove non existing element should error
    const error1 = await t.throwsAsync(() => ali.call(vectorContract, 'swapRemove', { index: 3 }));
    t.assert(error1.message.includes(`Index out of bounds`));
    t.deepEqual(
        await vectorContract.view('toArray', {}),
        ['hello', 'world', 'aaa']
    );

    // swapRemove not the last one should work
    await ali.call(vectorContract, 'swapRemove', { index: 0 });
    t.deepEqual(
        await vectorContract.view('toArray', {}),
        ['aaa', 'world']
    );

    // swapRemove the last one should work
    await ali.call(vectorContract, 'swapRemove', { index: 1 });
    t.deepEqual(
        await vectorContract.view('toArray', {}),
        ['aaa']
    );

    // swapRemove when length is 1 should work
    t.is(
        await vectorContract.view('len', {}),
        1
    );
    t.is(
        await vectorContract.view('isEmpty', {}),
        false
    );
    await ali.call(vectorContract, 'swapRemove', { index: 0 });
    t.deepEqual(
        await vectorContract.view('toArray', {}),
        []
    );
    t.is(
        await vectorContract.view('isEmpty', {}),
        true
    );

    await ali.call(vectorContract, 'extend', { kvs: ['hello', 'world', 'aaa'] });
    t.is(
        await vectorContract.view('isEmpty', {}),
        false
    );
    await ali.call(vectorContract, 'clear', {});

    t.deepEqual(
        await vectorContract.view('toArray', {}),
        []
    );
    t.is(
        await vectorContract.view('isEmpty', {}),
        true
    );
})

test('Vector add and get object', async t => {
    const { ali, vectorContract } = t.context.accounts;
    await ali.call(vectorContract, 'add_house', {});
    let result = await vectorContract.view('get_house', {});
    t.deepEqual(result, {
        name: 'house1',
        rooms: [
            {
            name: 'room1',
            size: '200sqft',
            },
            {
            name: 'room2',
            size: '300sqft',
            },
        ],
    })
});

'''
'''--- tests/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ]
}

'''
'''--- tests/jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- tests/package.json ---
{
    "name": "tests",
    "version": "1.0.0",
    "description": "near-sdk-js tests",
    "main": "index.js",
    "type": "module",
    "scripts": {
        "postinstall": "cd .. && yarn link && cd tests && yarn link near-sdk-js",
        "build": "yarn build:context-api && yarn build:math-api && yarn build:storage-api && yarn build:log-panic-api && yarn build:promise-api && yarn build:promise-batch-api && yarn build:function-params && yarn build:lookup-map && yarn build:lookup-set && yarn build:unordered-map && yarn build:unordered-set && yarn build:vector && yarn build:bytes",
        "build:context-api": "near-sdk-js build src/context_api.js build/context_api.wasm",
        "build:math-api": "near-sdk-js build src/math_api.js build/math_api.wasm",
        "build:storage-api": "near-sdk-js build src/storage_api.js build/storage_api.wasm",
        "build:log-panic-api": "near-sdk-js build src/log_panic_api.js build/log_panic_api.wasm",
        "build:promise-api": "near-sdk-js build src/promise_api.js build/promise_api.wasm",
        "build:promise-batch-api": "near-sdk-js build src/promise_batch_api.js build/promise_batch_api.wasm",
        "build:function-params": "near-sdk-js build src/function-params.js build/function-params.wasm",
        "build:lookup-map": "near-sdk-js build src/lookup-map.js build/lookup-map.wasm",
        "build:lookup-set": "near-sdk-js build src/lookup-set.js build/lookup-set.wasm",
        "build:unordered-map": "near-sdk-js build src/unordered-map.js build/unordered-map.wasm",
        "build:unordered-set": "near-sdk-js build src/unordered-set.js build/unordered-set.wasm",
        "build:vector": "near-sdk-js build src/vector.js build/vector.wasm",
        "build:bytes": "near-sdk-js build src/bytes.js build/bytes.wasm",
        "test": "ava",
        "test:context-api": "ava __tests__/test_context_api.ava.js",
        "test:math-api": "ava __tests__/test_math_api.ava.js",
        "test:storage-api": "ava __tests__/test_storage_api.ava.js",
        "test:log-panic-api": "ava __tests__/test_log_panic_api.ava.js",
        "test:promise-api": "ava __tests__/test_promise_api.ava.js",
        "test:function-params": "ava __tests__/function-params.ava.js",
        "test:lookup-map": "ava __tests__/lookup-map.ava.js",
        "test:lookup-set": "ava __tests__/lookup-set.ava.js",
        "test:unordered-set": "ava __tests__/unordered-set.ava.js",
        "test:unordered-map": "ava __tests__/unordered-map.ava.js",
        "test:vector": "ava __tests__/vector.ava.js",
        "test:bytes": "ava __tests__/bytes.ava.js"
    },
    "author": "Near Inc <hello@nearprotocol.com>",
    "license": "Apache-2.0",
    "devDependencies": {
        "ava": "^4.2.0",
        "near-workspaces": "3.1.0"
    }
}

'''
'''--- tests/src/bytes.js ---
import {near, bytes} from 'near-sdk-js'

export function log_expected_input_tests() {
    // log ascii string
    near.log('abc')
    // log string with utf-8 chars
    near.log('')
    // log number
    near.log(333)
    // log aribrary byte sequence
    near.log(bytes('\x00\x01\xff'))
    // log valid utf8 seqence
    near.log(bytes('\xe6\xb0\xb4'))

    // log valid utf8 sequence 
    near.logUtf8(bytes('\xe6\xb0\xb4'))
    // log valid utf16 sequence
    near.logUtf16(bytes('\x34\x6c'))
}

export function log_unexpected_input_tests() {
    // log non-bytes with logUtf8
    near.logUtf8('')
    // log non-bytes with logUtf16
    near.logUtf16('')
}

export function log_invalid_utf8_sequence_test() {
    near.logUtf8(bytes('\x00\x01\xff'))
}

export function log_invalid_utf16_sequence_test() {
    near.logUtf16(bytes('\x00\x01\xff'))
}

export function storage_write_bytes() {
    near.storageWrite(bytes('abc'), bytes('def'))
    near.storageWrite(bytes('\x00\x01\xff'), bytes('\xe6\xb0\xb4'))
    near.storageWrite(bytes('\xe6\xb0\xb4'), bytes('\x00ab'))
}

export function storage_write_unexpected_input() {
    near.storageWrite('', '')
    near.storageWrite(123, 456)
}

export function storage_read_ascii_bytes() {
    near.valueReturn(near.storageRead(bytes('abc')))
}

export function storage_read_arbitrary_bytes_key_utf8_sequence_bytes_value() {
    near.valueReturn(near.storageRead(bytes('\x00\x01\xff')))
}

export function storage_read_utf8_sequence_bytes_key_arbitrary_bytes_value() {
    near.valueReturn(near.storageRead(bytes('\xe6\xb0\xb4')))
}

export function panic_test() {
    near.panic()
}

export function panic_ascii_test() {
    near.panic('abc')
}

export function panic_js_number() {
    near.panic(356)
}

export function panic_js_undefined() {
    near.panic(undefined)
}

export function panic_js_null() {
    near.panic(null)
}

export function panic_utf8_test() {
    near.panic('')
}

export function panicUtf8_valid_utf8_sequence() {
    near.panicUtf8(bytes('\xe6\xb0\xb4'))
}

export function panicUtf8_invalid_utf8_sequence() {
    near.panicUtf8(bytes('\x00\x01\xff'))
}
'''
'''--- tests/src/context_api.js ---
import {near} from 'near-sdk-js'

export function get_current_account_id() {
    near.valueReturn(near.currentAccountId())
}

export function get_signer_account_id() {
    near.valueReturn(near.signerAccountId())
}

export function get_predecessor_account_id() {
    near.valueReturn(near.predecessorAccountId())
}

export function get_signer_account_pk() {
    near.valueReturn(near.signerAccountPk())
}

export function get_input() {
    near.valueReturn(near.input())
}

export function get_storage_usage() {
    near.valueReturn(near.storageUsage())
}

export function get_block_height() {
    near.valueReturn(near.blockHeight())
}

export function get_block_timestamp() {
    near.valueReturn(near.blockTimestamp())
}

export function get_epoch_height() {
    near.valueReturn(near.epochHeight())
}

export function get_attached_deposit() {
    near.valueReturn(near.attachedDeposit())
}

export function get_prepaid_gas() {
    near.valueReturn(near.prepaidGas())
}

export function get_used_gas() {
    near.valueReturn(near.usedGas())
}

export function get_random_seed() {
    near.valueReturn(near.randomSeed())
}

export function get_validator_stake() {
    near.valueReturn(near.validatorStake(near.signerAccountId()))
}

export function get_total_stake() {
    near.valueReturn(near.validatorTotalStake())
}

'''
'''--- tests/src/function-params.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    near,
} from 'near-sdk-js'

/**
 * Simple contract to test function parameters
 */
@NearBindgen
class FunctionParamsTestContract extends NearContract {
    constructor() {
        super()
        this.val1 = 'default1';
        this.val2 = 'default2';
        this.val3 = 'default3';
    }

    @call
    set_values({ param1, param2, param3 }) {
        near.log(JSON.stringify({ param1, param2, param3 }));
        this.val1 = param1;
        this.val2 = param2;
        this.val3 = param3;
    }

    @view
    get_values() {
        return { val3: this.val3, val2: this.val2, val1: this.val1 }
    }
}
'''
'''--- tests/src/log_panic_api.js ---
import {near, bytes} from 'near-sdk-js'

export function log_expected_input_tests() {
    // log ascii string
    near.log('abc')
    // log string with utf-8 chars
    near.log('')
    // log number
    near.log(333)
    // log aribrary byte sequence
    near.log(bytes('\x00\x01\xff'))
    // log valid utf8 seqence
    near.log(bytes('\xe6\xb0\xb4'))

    // log valid utf8 sequence 
    near.logUtf8(bytes('\xe6\xb0\xb4'))
    // log valid utf16 sequence
    near.logUtf16(bytes('\x34\x6c'))
}

export function log_unexpected_input_tests() {
    // log non-bytes with logUtf8
    near.logUtf8('')
    // log non-bytes with logUtf16
    near.logUtf16('')
}

export function log_invalid_utf8_sequence_test() {
    near.logUtf8(bytes('\x00\x01\xff'))
}

export function log_invalid_utf16_sequence_test() {
    near.logUtf16(bytes('\x00\x01\xff'))
}

export function panic_test() {
    near.panic()
}

export function panic_ascii_test() {
    near.panic('abc')
}

export function panic_js_number() {
    near.panic(356)
}

export function panic_js_undefined() {
    near.panic(undefined)
}

export function panic_js_null() {
    near.panic(null)
}

export function panic_utf8_test() {
    near.panic('')
}

export function panicUtf8_valid_utf8_sequence() {
    near.panicUtf8(bytes('\xe6\xb0\xb4'))
}

export function panicUtf8_invalid_utf8_sequence() {
    near.panicUtf8(bytes('\x00\x01\xff'))
}
'''
'''--- tests/src/lookup-map.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    LookupMap
} from 'near-sdk-js'
import { Serializer } from 'superserial';
import {House, Room} from './model.js';

@NearBindgen
class LookupMapTestContract extends NearContract {
    constructor() {
        super()
        this.lookupMap = new LookupMap('a', {House, Room});
    }

    deserialize() {
        super.deserialize();
        this.lookupMap.serializer = new Serializer({classes: {House, Room}})
        this.lookupMap = Object.assign(new LookupMap, this.lookupMap);
    }

    @view
    get({key}) {
        return this.lookupMap.get(key);
    }

    @view
    containsKey({key}) {
        return this.lookupMap.containsKey(key);
    }

    @call
    set({key, value}) {
        this.lookupMap.set(key, value);
    }

    @call
    remove_key({key}) {
        this.lookupMap.remove(key);
    }

    @call
    extend({kvs}) {
        this.lookupMap.extend(kvs);
    }

    @call
    add_house() {
        this.lookupMap.set('house1', new House('house1', [new Room('room1', '200sqft'), new Room('room2', '300sqft')]))
    }

    @view
    get_house() {
        let house = this.lookupMap.get('house1')
        let room = house.rooms[0]
        // ensure the object's class is preserved
        // if and only if house and room is still of class House and Room, this would work:
        return house.describe() + room.describe()
    }
}

'''
'''--- tests/src/lookup-set.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    LookupSet
} from 'near-sdk-js'
import { Serializer } from 'superserial';
import { House, Room } from './model.js';

@NearBindgen
class LookupSetTestContract extends NearContract {
    constructor() {
        super()
        this.lookupSet = new LookupSet('a', {House, Room});
    }

    deserialize() {
        super.deserialize();
        this.lookupSet = new LookupSet('a', {House, Room});
    }

    @view
    contains({key}) {
        return this.lookupSet.contains(key);
    }

    @call
    set({key}) {
        this.lookupSet.set(key);
    }

    @call
    remove_key({key}) {
        this.lookupSet.remove(key);
    }

    @call
    extend({keys}) {
        this.lookupSet.extend(keys);
    }

    @call
    add_house({name, rooms}) {
        let house = new House(name, [])
        for (let r of rooms) {
            house.rooms.push(new Room(r.name, r.size))
        }
        this.lookupSet.set(house)
    }

    @view
    house_exist({name, rooms}) {
        let house = new House(name, [])
        for (let r of rooms) {
            house.rooms.push(new Room(r.name, r.size))
        }
        return this.lookupSet.contains(house)
    }
}

'''
'''--- tests/src/math_api.js ---
import {near, bytes} from 'near-sdk-js'

export function test_sha256() {
    near.valueReturn(near.sha256(bytes("tesdsst")))
}

export function test_keccak256() {
    near.valueReturn(near.keccak256(bytes("tesdsst")))
}

export function test_keccak512() {
    near.valueReturn(near.keccak512(bytes("tesdsst")))
}

export function test_ripemd160() {
    near.valueReturn(near.ripemd160(bytes("tesdsst")))
}

export function test_ecrecover() {
    let hash = bytes(new Uint8Array([
        206,   6, 119, 187,  48, 186, 168, 207,
        6, 124, 136, 219, 152,  17, 244,  51,
       61,  19,  27, 248, 188, 241,  47, 231,
        6,  93,  33,  29, 206, 151,  16,   8
    ]))
    let sign = bytes(new Uint8Array([
        144, 242, 123, 139,  72, 141, 176,  11,   0,  96, 103,
        150, 210, 152, 127, 106,  95,  89, 174,  98, 234,   5,
        239, 254, 132, 254, 245, 184, 176, 229,  73, 152,  74,
        105,  17,  57, 173,  87, 163, 240, 185,   6,  99, 118,
        115, 170,  47,  99, 209, 245,  92, 177, 166, 145, 153,
        212,   0, 158, 234,  35, 206, 173, 220, 147
    ]))
    let v = 1
    let malleabilityFlag = 1
    let ret = near.ecrecover(hash, sign, v, malleabilityFlag)
    near.valueReturn(ret)
}

'''
'''--- tests/src/model.js ---
export class House {
    constructor(name, rooms) {
        this.name = name
        this.rooms = rooms
    }

    describe() {
        return `house ${this.name} has ${this.rooms.length} rooms. `
    }
}

export class Room {
    constructor(name, size) {
        this.name = name
        this.size = size
    }

    describe() {
        return `room ${this.name} is ${this.size}.`
    }
}
'''
'''--- tests/src/promise_api.js ---
import {near, bytes} from 'near-sdk-js'

function arrayN(n) {
    return [...Array(Number(n)).keys()]
}

function callingData() {
    return {
        currentAccountId: near.currentAccountId(),
        signerAccountId: near.signerAccountId(),
        predecessorAccountId: near.predecessorAccountId(),
        input: near.input(),
    }
}

export function cross_contract_callee() {
    near.valueReturn(bytes(JSON.stringify(callingData())))
}

export function cross_contract_callback() {
    near.valueReturn(bytes(JSON.stringify({...callingData(), promiseResults: arrayN(near.promiseResultsCount()).map(i => near.promiseResult(i))})))
}

export function test_promise_create() {
    near.promiseCreate('callee-contract.test.near', 'cross_contract_callee', bytes('abc'), 0, 2 * Math.pow(10, 13))
}

export function test_promise_then() {
    let promiseId = near.promiseCreate('callee-contract.test.near', 'cross_contract_callee', bytes('abc'), 0, 2 * Math.pow(10, 13))
    near.promiseThen(promiseId, 'caller-contract.test.near', 'cross_contract_callback', bytes('def'), 0, 2 * Math.pow(10, 13))
}

export function test_promise_and() {
    let promiseId = near.promiseCreate('callee-contract.test.near', 'cross_contract_callee', bytes('abc'), 0, 2 * Math.pow(10, 13))
    let promiseId2 = near.promiseCreate('callee-contract.test.near', 'cross_contract_callee', bytes('def'), 0, 2 * Math.pow(10, 13))
    let promiseIdAnd = near.promiseAnd(promiseId, promiseId2)
    near.promiseThen(promiseIdAnd, 'caller-contract.test.near', 'cross_contract_callback', bytes('ghi'), 0, 3 * Math.pow(10, 13))
}

'''
'''--- tests/src/storage_api.js ---
import {near, bytes} from 'near-sdk-js'

export function test_storage_write() {
    near.valueReturn(near.storageWrite(bytes("\x00tesdsst\xff"), bytes("\x00\x01\xff")))
}

export function test_storage_read() {
    near.valueReturn(near.storageRead(bytes("\x00tesdsst\xff")))
}

export function test_storage_remove() {
    near.valueReturn(near.storageRemove(bytes("\x00tesdsst\xff")))
}

export function test_storage_has_key() {
    near.valueReturn(near.storageHasKey(bytes("\x00tesdsst\xff")))
}

export function test_storage_get_evicted() {
    near.storageWrite(bytes("\x00tesdsst\xff"), bytes("\x00\x01\xff"))
    near.storageWrite(bytes("\x00tesdsst\xff"), bytes("\x03\x01\xee"))
    near.valueReturn(near.storageGetEvicted())
}

'''
'''--- tests/src/unordered-map.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    UnorderedMap,
    Vector
} from 'near-sdk-js'
import { Serializer } from 'superserial';
import {House, Room} from './model.js';

@NearBindgen
class UnorderedMapTestContract extends NearContract {
    constructor() {
        super()
        this.unorderedMap = new UnorderedMap('a', {House, Room});
    }

    deserialize() {
        super.deserialize()
        this.unorderedMap.keys.serializer = new Serializer({classes: {House, Room}})
        this.unorderedMap.keys = Object.assign(new Vector, this.unorderedMap.keys)
        this.unorderedMap.values.serializer = new Serializer({classes: {House, Room}})
        this.unorderedMap.values = Object.assign(new Vector, this.unorderedMap.values)
        this.unorderedMap.serializer = new Serializer({classes: {House, Room}})
        this.unorderedMap = Object.assign(new UnorderedMap, this.unorderedMap)
    }

    @view
    len() {
        return this.unorderedMap.len();
    }

    @view
    isEmpty() {
        return this.unorderedMap.isEmpty();
    }

    @view
    serializeIndex({index}) {
        return this.unorderedMap.serializeIndex(index);
    }

    @view
    deserializeIndex({rawIndex}) {
        return this.unorderedMap.deserializeIndex(rawIndex);
    }

    @view
    getIndexRaw({key}) {
        return this.unorderedMap.getIndexRaw(key);
    }

    @view
    get({key}) {
        return this.unorderedMap.get(key);
    }

    @call
    set({key, value}) {
        this.unorderedMap.set(key, value);
    }

    @call
    remove_key({key}) {
        this.unorderedMap.remove(key);
    }

    @call
    clear() {
        this.unorderedMap.clear();
    }

    @view
    toArray() {
        return this.unorderedMap.toArray();
    }

    @call
    extend({kvs}) {
        this.unorderedMap.extend(kvs);
    }

    @call
    add_house() {
        this.unorderedMap.set('house1', new House('house1', [new Room('room1', '200sqft'), new Room('room2', '300sqft')]))
    }

    @view
    get_house() {
        let house = this.unorderedMap.get('house1')
        let room = house.rooms[0]
        return house.describe() + room.describe()
    }
}

'''
'''--- tests/src/unordered-set.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    UnorderedSet,
    Vector
} from 'near-sdk-js'
import { Serializer } from 'superserial';
import {House, Room} from './model.js';

@NearBindgen
class UnorderedSetTestContract extends NearContract {
    constructor() {
        super()
        this.unorderedSet = new UnorderedSet('a', {House, Room});
    }

    deserialize() {
        super.deserialize()
        this.unorderedSet.elements.serializer = new Serializer({classes: {House, Room}})
        this.unorderedSet.elements = Object.assign(new Vector, this.unorderedSet.elements)
        this.unorderedSet.serializer = new Serializer({classes: {House, Room}})
        this.unorderedSet = Object.assign(new UnorderedSet, this.unorderedSet)
    }

    @view
    len() {
        return this.unorderedSet.len();
    }

    @view
    isEmpty() {
        return this.unorderedSet.isEmpty();
    }

    @view
    contains({element}) {
        return this.unorderedSet.contains(element);
    }

    @call
    set({element}) {
        this.unorderedSet.set(element);
    }

    @call
    remove_key({element}) {
        this.unorderedSet.remove(element);
    }

    @call
    clear() {
        this.unorderedSet.clear();
    }

    @view
    toArray() {
        return this.unorderedSet.toArray();
    }

    @call
    extend({elements}) {
        this.unorderedSet.extend(elements);
    }

    @call
    add_house({name, rooms}) {
        let house = new House(name, [])
        for (let r of rooms) {
            house.rooms.push(new Room(r.name, r.size))
        }
        this.unorderedSet.set(house)
    }

    @view
    house_exist({name, rooms}) {
        let house = new House(name, [])
        for (let r of rooms) {
            house.rooms.push(new Room(r.name, r.size))
        }
        return this.unorderedSet.contains(house)
    }
}

'''
'''--- tests/src/vector.js ---
import {
    NearContract,
    NearBindgen,
    call,
    view,
    Vector
} from 'near-sdk-js'
import { Serializer } from 'superserial';
import {House, Room} from './model.js';

@NearBindgen
class VectorTestContract extends NearContract {
    constructor() {
        super()
        this.vector = new Vector('a', {House, Room});
    }

    deserialize() {
        super.deserialize();
        this.vector.serializer = new Serializer({classes: {House, Room}});
        this.vector = Object.assign(new Vector, this.vector);
    }

    @view
    len() {
        return this.vector.len();
    }

    @view
    isEmpty() {
        return this.vector.isEmpty();
    }

    @view
    get({index}) {
        return this.vector.get(index);
    }

    @call
    push({value}) {
        this.vector.push(value);
    }

    @call
    pop() {
        this.vector.pop();
    }

    @call
    clear() {
        this.vector.clear();
    }

    @view
    toArray() {
        return this.vector.toArray();
    }

    @call
    extend({kvs}) {
        this.vector.extend(kvs);
    }

    @call
    replace({index, value}) {
        this.vector.replace(index, value);
    }

    @call
    swapRemove({index}) {
        this.vector.swapRemove(index);
    }

    @call
    add_house() {
        this.vector.push(new House('house1', [new Room('room1', '200sqft'), new Room('room2', '300sqft')]));
    }

    @view
    get_house() {
        return this.vector.get(0);
    }
}

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "esModuleInterop": true,
        "lib": [
            "es2015",
            "esnext",
            "dom"
        ],
        "module": "esnext",
        "target": "es2020",
        "moduleResolution": "node",
        "alwaysStrict": true,
        "outDir": "./lib",
        "declaration": true,
        "preserveSymlinks": true,
        "preserveWatchOutput": true,
        "pretty": false,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "noImplicitAny": false,
        "noImplicitReturns": true,
        "noUnusedLocals": true,
        "experimentalDecorators": true,
        "resolveJsonModule": true,
		"allowJs": true,
    },
    "files": [
        "src/index.ts",
        "src/build-tools/near-bindgen-exporter.js",
    ]
}
'''