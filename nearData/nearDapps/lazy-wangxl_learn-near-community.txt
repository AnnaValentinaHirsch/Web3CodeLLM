*GitHub Repository "lazy-wangxl/learn-near-community"*

'''--- README.md ---
# learn-near-community
Learn NEAR Community

'''
'''--- cn/resources/glossary/README.md ---
è‹±æ–‡ | ä¸­æ–‡
-- | --
Open Web | å¼€æ”¾ç½‘ç»œ
Nightshade | å¤œå½±
chunks | åˆ†ç‰‡æ®µ
Validator | éªŒè¯èŠ‚ç‚¹
genesis block | åˆ›ä¸–åŒºå—
full virtual machine | å›¾çµå®Œå¤‡çš„è™šæ‹Ÿæœº
robustness | é²æ£’æ€§
volume/speed/cost transactions | ååé‡/å¤„ç†é€Ÿåº¦/äº¤æ˜“æˆæœ¬
Usability | å¯ç”¨æ€§
Chunk Producer | å‡ºæ®µäºº
fisherman | æ¸”å¤«
Primitives | åŸºå…ƒï¼Œæ–¹æ¡ˆï¼Œåè®® ï¼ˆæ ¹æ®è¯­å¢ƒï¼‰
implementation | (ä»£ç çš„)å®ç°
Slot | å¡æ§½
License compliance | è®¸å¯è¯ä¹¦ä¸€è‡´æ€§
performance overhead | æ€§èƒ½å¼€é”€
dump memory | å†…å­˜è½¬å‚¨
block ordinal | åŒºå—åºå·
Missing Block | ä¸¢å—
Unknown Block | æœªçŸ¥åŒºå—
synthetic bench | ç»¼åˆåŸºå‡†æµ‹è¯•
attack angle | æ”»å‡»æ–¹å¼
versioning | ç‰ˆæœ¬åŒ–
routing table | è·¯ç”±è¡¨
validator selection algorithm | éªŒè¯èŠ‚ç‚¹é€‰æ‹©ç®—æ³•
batch reads | æ‰¹é‡è¯»å–
error propagation | é”™è¯¯ä¼ æ’­
contract caching | åˆçº¦ç¼“å­˜
simulation test | æ¨¡æ‹Ÿæµ‹è¯•
host function | ä¸»å‡½æ•°
Protocol Config | åè®®é…ç½®
Node Public Interfaces | èŠ‚ç‚¹å…¬å…±ç•Œé¢
overflow bug | æº¢å‡ºæ¼æ´
archival data | å½’æ¡£æ•°æ®
external contributor | å¤–éƒ¨è´¡çŒ®è€…
storage attachment | å­˜å‚¨é™„ä»¶
transaction-time authorization | äº¤æ˜“æ—¶é—´æˆæƒ
receipts | äº¤æ˜“å›æ‰§
nested trees | åµŒå¥—æ ‘
Cross-Chain Atomic Swap | è·¨é“¾åŸå­äº’æ¢
social graphs | ç¤¾äº¤å›¾è°±
key rotation | ç§˜é’¥è½®æ¢
fair launch | å…¬å¹³å¯åŠ¨
base token | åŸºç¡€é€šè¯
escrow | æ‰˜ç®¡è´¦æˆ·
post-mortem | äº‹ååˆ†æ
hidden validator | éšè—çš„éªŒè¯èŠ‚ç‚¹
synchronous execution | åŒæ­¥æ‰§è¡Œ
private shard | ç§æœ‰åˆ†ç‰‡
Hackathon | é»‘å®¢é©¬æ‹‰æ¾
application hosting | åº”ç”¨æ‰˜ç®¡
Open Finance | å¼€æ”¾é‡‘è
Open Web | å¼€æ”¾ç½‘ç»œ
account model | è´¦æˆ·æ¨¡å‹
cross-shard communication | è·¨åˆ†ç‰‡é€šä¿¡
access keys | æˆæƒå¯†é’¥
staking pool contract | è´¨æŠ¼æ± åˆçº¦
bridge | è·¨é“¾/è·¨é“¾æ¡¥
Non-fungible Token | éåŒè´¨åŒ–é€šè¯
layer 2 components | ç¬¬äºŒå±‚éƒ¨ä»¶
Contract-Based Accounts | åŸºäºåˆçº¦çš„è´¦æˆ·
delegation | å§”æ‰˜
endowment | æèµ åŸºé‡‘
Circulating Supply | æµé€šä¾›åº”é‡
uptime | åœ¨çº¿ç‡
guild | å…¬ä¼š
precompile | é¢„ç¼–è¯‘
private transaction | ç§å¯†äº¤æ˜“
indexer repositories | ç´¢å¼•å™¨ä»£ç åº“
contract review | åˆçº¦è¯„å®¡
license compliance testing | è¯ä¹¦åˆè§„æµ‹è¯•
access key | è®¿é—®å¯†é’¥
DevEx | å¼€å‘è€…ä½“éªŒ
initial supply | åˆæ¬¡å‘è¡Œ
convertible note | å¯å…‘æ¢ç¥¨æ®
New Issuance | é€šè¯å¢å‘
DevOps | å¼€å‘è¿ç»´
epoch | å‘¨æœŸ
fisherman | æ¸”å¤«
challenge | è´¨ç–‘/æŒ‘æˆ˜
backer | æ”¯æŒè€…
'''
'''--- cn/resources/guides/NEAR_Protocol_and_Solana.md ---
# NEAR Protocol å’Œ Solana
ä»Šå¤©ï¼Œè®©æˆ‘ä»¬æ¥è®¤è¯†ä¸‹ä¸–ç•Œä¸Šæœ€æœ‰å‰é€”çš„ä¸¤ä¸ªæ™ºèƒ½åˆçº¦å¹³å°- Near Protocolå’ŒSolanaã€‚å°½ç®¡ç›®å‰Ethereumä¾æ—§ä¸»å¯¼è¿™ä¸ªå¸‚åœº
ä½†äº‹å®æ˜¯å®ƒç¼ºä¹å¯æ‰©å±•æ€§å’Œé«˜æ˜‚çš„è´¹ç”¨è¿«ä½¿å¤§å¤šæ•°å¼€å‘è€…å¯»æ‰¾å¯è¡Œçš„æ›¿ä»£æ–¹æ¡ˆã€‚Near å’Œ Solanaå·²ç»æˆä¸ºå‰ä¸¤åçš„é¢†è·‘è€…ã€‚

## 1.ä»€ä¹ˆæ˜¯ Solana?
[Solana](https://solana.com/) æˆç«‹äº2017å¹´ï¼Œåˆ›å§‹äººæ˜¯æ›¾åœ¨ DropBox å·¥ä½œè¿‡çš„ Yakovenko, Eric Williams ä»¥åŠä½œä¸ºCTOçš„ Greg Fritzgeraldï¼Œ
åˆ›ç«‹Solanaä¸»è¦æ˜¯è§£å†³æ¯”ç‰¹å¸å’Œä»¥å¤ªåŠç›®å‰å­˜åœ¨çš„é—®é¢˜ã€‚è¯¥é¡¹ç›®å¸å¼•äº†æ¥è‡ª Multicoin Capitalã€ Foundation Capitalã€ SLOW Capitalã€ CMCC Globalã€ Abstract Ventures ç­‰å…¬å¸çš„æŠ•èµ„ã€‚

![img.png](img.png)

SolanaåŒºå—é“¾çš„ç‰¹ç‚¹
* æ¯ç§’50,000æ¬¡äº¤æ˜“å’Œ0.4ç§’çš„åŒºå—äº§ç”Ÿæ—¶é—´
* è¯¥ç³»ç»Ÿåœ¨40 gigabit ç½‘ç»œä¸Šæ¯ç§’å¯æä¾›2840ä¸‡æ¬¡äº¤æ˜“
* Solanaä½¿ç”¨å†å²è¯æ˜ï¼ˆProof-of-Historyï¼‰å…±è¯†ç®—æ³•

### å†å²è¯æ˜ç®—æ³•æ˜¯å¦‚ä½•è¿ä½œçš„ï¼Ÿ
åœ¨ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„ç½‘ç»œä¸­ï¼Œå…±è¯†æ˜¯å¿…ä¸å¯å°‘çš„ã€‚æ¯”ç‰¹å¸ä½¿ç”¨å·¥ä½œè¯æ˜(proof-of-workï¼ŒPoW)å…±è¯†æ¥å¤„ç†å…±è¯†ã€‚è™½ç„¶è¯¥æ–¹æ³•éå¸¸å®‰å…¨ï¼Œ
ä½†æ˜¯å¾ˆéš¾ä¸å¿½è§†å®ƒæœ€é‡è¦çš„é—®é¢˜â€”â€”ç¼ºä¹å¯ä¼¸ç¼©æ€§ã€‚åˆ«å¿˜äº†æ¯”ç‰¹å¸æ¯ç§’åªèƒ½è¿›è¡Œ7æ¬¡äº¤æ˜“ã€‚

Solanaä½¿ç”¨å†å²è¯æ˜ç®—æ³•ï¼Œé€šè¿‡åˆ›é€ å†å²è®°å½•æ¥è¯æ˜æŸä¸€äº‹ä»¶å‘ç”Ÿåœ¨æŸä¸€ç‰¹å®šæ—¶åˆ»ã€‚ä»¥ä¸‹å‡ ç‚¹éœ€è¦è®°ä½:
* è¯¥ç®—æ³•ä½¿ç”¨äº†ä¸€ä¸ªé«˜é¢‘å¯éªŒè¯å»¶è¿Ÿå‡½æ•°ï¼Œè¯¥å‡½æ•°éœ€è¦ä¸€å®šæ•°é‡çš„è¿ç»­æ­¥éª¤æ¥å®Œæˆ
* åœ¨ç½‘ç»œä¸­è®¡æ—¶çš„äº¤æ˜“æˆ–äº‹ä»¶å°†è¢«æŒ‡å®šä¸ºå”¯ä¸€çš„æ•£åˆ—è®¡æ•°ï¼Œå¯ä»¥è¿›è¡Œå…¬å¼€éªŒè¯
* è®¡æ•°å…è®¸ç½‘ç»œå‡†ç¡®åœ°çŸ¥é“äº¤æ˜“æˆ–äº‹ä»¶å‘ç”Ÿçš„æ—¶é—´
* æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªç”¨äºè·Ÿè¸ªç½‘ç»œæ—¶é—´å’Œäº‹ä»¶é¡ºåºçš„åŠ å¯†æ—¶é’Ÿ

åŸºäºå†å²è¯æ˜( PoH)ï¼Œå½“ä½¿ç”¨ GPU è¿è¡Œæ—¶ï¼ŒSolana ç½‘ç»œæ¯ç§’æ”¯æŒ50,000ä¸ªäº¤æ˜“ã€‚

### ä»€ä¹ˆæ˜¯Solana Cluster?
clusteræ˜¯ä¸€ç»„ç‹¬ç«‹æ‹¥æœ‰çš„è®¡ç®—æœºå…±åŒå·¥ä½œï¼Œå¯ä»¥è¢«è§†ä¸ºä¸€ä¸ªå•ä¸€çš„ç³»ç»Ÿã€‚Clusterçš„ä¸»è¦ç‰¹ç‚¹å¦‚ä¸‹:
* å®ƒä»¬æœ‰åŠ©äºéªŒè¯æœªå—ä¿¡ä»»çš„è¾“å‡ºåŠç”¨æˆ·æäº¤çš„ç¨‹åº
* ç»´æŠ¤ç”¨æˆ·è¿›è¡Œçš„ä»»ä½•äº¤æ˜“æˆ–äº‹ä»¶çš„è®°å½•
* å®ƒä¿ç•™ç€æœ‰å…³å“ªäº›è®¡ç®—æœºåšäº†æœ‰æ„ä¹‰çš„å·¥ä½œçš„çºªå½•æ¥ç»´æŒç½‘ç»œè¿è¡Œ
* å®ƒä¿ç•™ç€æœ‰å…³çœŸå®ä¸–ç•Œä¸­èµ„äº§çš„æ‹¥æœ‰æƒçš„çºªå½•

ä»¥ä¸‹å“ªé¡¹ä½¿ç”¨äº†åˆ†ç‰‡ï¼Ÿ
- Solana
- Near protocol
- Both

### åœ¨ Solana ä¸­ç¼–ç¨‹
Solana ä¸­çš„æ™ºèƒ½åˆçº¦æ˜¯ç”¨ Rust æˆ– c ç¼–å†™çš„ï¼Œå¹¶ç¼–è¯‘æˆä¼¯å…‹åˆ©åŒ…è¿‡æ»¤å™¨(BPF)ã€‚ç”±äºæœ‰æ›´å¤šçš„å·¥å…·å¯ç”¨ï¼Œå»ºè®®æ‚¨åœ¨ Rust ä¸­ç¼–å†™ä»£ç ã€‚åˆå­¦è€…åº”è¯¥ä½¿ç”¨ Anchor æ¡†æ¶ç¼–å†™ç¨‹åºä»£ç ï¼Œè¯¥æ¡†æ¶å¯ä»¥ç®€åŒ–æ‰§è¡Œã€‚

Solana ç±»ä¼¼äºLinucæ“ä½œç³»ç»Ÿæœ‰çš„æ–‡ä»¶æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„å¸æˆ·æ¨¡å‹ã€‚å®ƒä»¬å¯ä»¥ä¿å­˜ä»»ä½•ä»»æ„æ•°æ®ï¼Œè¿˜åŒ…å«å…³äºå¦‚ä½•è®¿é—®å®ƒä»¬çš„å…ƒæ•°æ®ã€‚è¯·è®°ä½ï¼Œè¿™äº›å¸æˆ·æœ‰ä¸€ä¸ªå›ºå®šçš„å¤§å°ï¼Œä¸èƒ½è°ƒæ•´å¤§å°ã€‚

Solanaç›®å‰çš„ç¼–ç¨‹æ¨¡å‹å—åˆ¶äºå›ºå®šçš„å¸æˆ·å¤§å°ï¼Œå¯èƒ½ä¼šè¿«ä½¿ä½ å°†åº”ç”¨ç¨‹åºçš„é€»è¾‘éƒ¨ä»½è½¬ç§»åˆ°é“¾ä¸‹æˆ–ä¿®æ”¹åŠŸèƒ½ä»¥æé«˜æ•ˆç‡ã€‚
ä»¥ä¸‹å“ªé¡¹æ˜¯Solanaçš„ç»„æˆéƒ¨åˆ†ï¼Ÿ

-Cluster
-Collective
-Parachain

åˆçº¦ä¾‹å­
```rust
#![feature(proc_macro_hygiene)]

use anchor_lang::prelude::*;
use anchor_spl::token::{self, TokenAccount, Transfer};

#[program]
pub mod plutocratic_hosting {
    use super::*;

    /// Initialize a new contract with initialized content.
    #[access_control(Initialize::validate(&ctx, nonce))]
    pub fn initialize(
        ctx: Context<Initialize>,
        price: u64,
        content: String,
        nonce: u8,
    ) -> ProgramResult {

        // Transfer funds to the contract vault.
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info().clone(),
            to: ctx.accounts.vault.to_account_info().clone(),
            authority: ctx.accounts.owner.clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, price)?;

        // Initialize the content data.
        let content_record = &mut ctx.accounts.content;
        content_record.price = price;
        content_record.content = content;
        content_record.nonce = nonce;
        content_record.owner = *ctx.accounts.owner.to_account_info().key;
        content_record.vault = *ctx.accounts.vault.to_account_info().key;
        Ok(())

    }

    /// Purchase content address for new price, if transferring more tokens.
    #[access_control(check_funds(&ctx.accounts.content, price))]
    pub fn purchase(ctx: Context<Purchase>, price: u64, content: String) -> ProgramResult {
        // Transfer funds from contract back to owner.
        let seeds = &[
            ctx.accounts.content.to_account_info().key.as_ref(),
            &[ctx.accounts.content.nonce],
        ];
        let signer = &[&seeds[..]];
        let cpi_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info().clone(),
            to: ctx.accounts.owner_token.to_account_info().clone(),
            authority: ctx.accounts.contract_signer.clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::transfer(cpi_ctx, ctx.accounts.content.price)?;

        // Transfer funds from new owner to contract.
        let cpi_accounts = Transfer {
            from: ctx.accounts.new_owner_token.to_account_info().clone(),
            to: ctx.accounts.vault.to_account_info().clone(),
            authority: ctx.accounts.new_owner.clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, price)?;

        // Overwrite content
        let content_record = &mut ctx.accounts.content;
        content_record.price = price;
        content_record.content = content;
        content_record.owner = *ctx.accounts.new_owner.to_account_info().key;

        Ok(())
    }
}

#[account]
pub struct ContentRecord {
    /// Price at which the current content is owned.
    pub price: u64,
    /// Content Data.
    pub content: String,
    /// Public key of current owner of the content.
    pub owner: Pubkey,
    /// Address for token program of funds locked in contract.
    pub vault: Pubkey,
    /// Nonce for the content, to create valid program derived addresses.
    pub nonce: u8,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init)]
    content: ProgramAccount<'info, ContentRecord>,
    #[account(mut, "&vault.owner == contract_signer.key")]
    vault: CpiAccount<'info, TokenAccount>,
    /// Program derived address for the contract.
    contract_signer: AccountInfo<'info>,
    /// Token account the contract is made from.
    #[account(mut, has_one = owner)]
    from: CpiAccount<'info, TokenAccount>,
    /// Owner of the `from` token account.
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
    rent: Sysvar<'info, Rent>,
}

impl<'info> Initialize<'info> {
    pub fn validate(ctx: &Context<Self>, nonce: u8) -> Result<()> {
        let signer = Pubkey::create_program_address(
            &[
                ctx.accounts.content.to_account_info().key.as_ref(),
                &[nonce],
            ],
            ctx.program_id,
        )
        .map_err(|_| ErrorCode::InvalidNonce)?;
        if &signer != ctx.accounts.contract_signer.to_account_info().key {
            return Err(ErrorCode::InvalidSigner.into());
        }
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Purchase<'info> {
    #[account(mut, has_one = vault)]
    content: ProgramAccount<'info, ContentRecord>,
    #[account(mut)]
    vault: CpiAccount<'info, TokenAccount>,
    #[account(seeds = [
        content.to_account_info().key.as_ref(),
        &[content.nonce],
    ])]
    contract_signer: AccountInfo<'info>,
    #[account(mut, has_one = owner)]
    owner_token: CpiAccount<'info, TokenAccount>,
    #[account(mut)]
    new_owner_token: CpiAccount<'info, TokenAccount>,
    #[account(signer)]
    new_owner: AccountInfo<'info>,
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

fn check_funds(check: &ContentRecord, new_price: u64) -> Result<()> {
    if check.price >= new_price {
        return Err(ErrorCode::InsufficientFunds.into());
    }

    Ok(())
}

#[error]
pub enum ErrorCode {
    #[msg("The given nonce does not create a valid program derived address.")]
    InvalidNonce,
    #[msg("The derived signer does not match that which was given.")]
    InvalidSigner,
    #[msg("Insufficient funds provided to purchase route.")]
    InsufficientFunds,
}
```
åˆçº¦è§£é‡Š
* å¯¹äºæ¯ä¸ªè°ƒç”¨ï¼Œè¦è®¿é—®çš„æ‰€æœ‰å¸æˆ·éƒ½ç”¨ #[derive(Accounts)]åœ¨ç»“æ„ä¸ŠåŠ æ³¨é‡Š
* è¿™äº›å‡½æ•°åˆå§‹åŒ–æ‰€æœ‰è€…å’Œ Purchase çš„å¸æˆ·æ•°æ®ã€‚è¿™ä½¿å¾—ä»»ä½•äººéƒ½å¯ä»¥è´­ä¹°æ›´å¤šçš„ä»£å¸
* ä¸´æ—¶æ•°æ®è¢«ä¼ é€’åˆ°å‡½æ•°å‚æ•°ä¸­ã€‚è¿™äº›å‚æ•°ä½äº initialize å’Œ purchase å‡½æ•°å†…éƒ¨ã€‚è¿™ä¹ŸåŒ…æ‹¬ä¿å­˜äº¤æ˜“æ‰€éœ€å¸æˆ·çš„ä¸Šä¸‹æ–‡
* åˆçº¦çš„çŠ¶æ€ä½äº ContentRecord ç»“æ„ä¸­ã€‚ä½¿ç”¨ #[account]  æ³¨è§£ï¼Œä»¥è¡¨æ˜å®ƒä»£è¡¨äº†è´¦æˆ·çš„æ•°æ®å¸ƒå±€

##  2.ä»€ä¹ˆæ˜¯ NEAR åè®®ï¼Ÿ
NEAR åè®®è¯ç”Ÿäº 2018 å¹´å¤å¤©ã€‚ è¯¥åè®®æ—¨åœ¨ä¸ºå»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºåˆ›é€ å®Œç¾çš„ç¯å¢ƒï¼Œå®ƒå¯ä»¥æä¾›æ›´é«˜é€Ÿã€æ›´é«˜ååé‡ä»¥åŠä¸å…¶ä»–é“¾æœ‰æ›´å¥½çš„å…¼å®¹æ€§ã€‚NEAR æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„åˆ†ç‰‡æŠ€æœ¯ï¼Œ
å®ƒè¿˜å¼•å…¥äº†åœ¨ 2019 å¹´æå‡ºçš„åä¸º"Doomslug"çš„åŒºå—ç”Ÿæˆæœºåˆ¶ã€‚ Doomslug å…è®¸å®ç”¨ç¡®å®šæ€§æˆ–"Doomslug"ç¡®å®šæ€§ï¼Œç¡®ä¿åŒºå—åœ¨å‡ ç§’é’Ÿå†…è·å¾—ç¡®å®šæ€§ã€‚

NEAR åè®®æ˜¯ç”± NEAR Collective å¼€å‘çš„ï¼Œè¿™æ˜¯ä¸€ä¸ªç”±å¼€å‘äººå‘˜å’Œç ”ç©¶äººå‘˜åˆä½œæ„å»ºé¡¹ç›®çš„ç¤¾åŒºã€‚ä»¥ä¸‹æ˜¯NEAR çš„ä¸€äº›å…³é”®ç‰¹æ€§:
* NEAR æ˜¯ä¸€ä¸ªåˆ†ç‰‡ç³»ç»Ÿï¼Œå®ƒæ”¯æŒæ— é™çš„å¯ä¼¸ç¼©æ€§
* NEAR æ˜¯ä¸€ç§æ˜“äºä½¿ç”¨çš„åè®®ï¼Œå…è®¸å¼€å‘äººå‘˜è½»æ¾å¿«é€Ÿåœ°æ„å»ºåº”ç”¨ç¨‹åº
* NEAR ä¸æ˜¯ä¸€ä¸ªä¾§é“¾ï¼Œè€Œæ˜¯ä¸€ä¸ªLayer-1åè®®
* ä½¿ç”¨ NEAR åˆ›å»ºçš„ dApps è¿è¡Œåœ¨åº•å±‚ NEAR å±‚ä¹‹ä¸Š

### ä»€ä¹ˆæ˜¯ NEAR Collective
NEAR Collectiveç”±ä¸æ–­è‡´åŠ›äºæ”¹è¿› NEAR åè®®çš„ä¸ªäººç»„ç»‡å’Œå…¶ä»–è´¡çŒ®è€…ç»„æˆã€‚ è¯¥Collectiveè‡´åŠ›äºä¸º NEAR ç½‘ç»œç¼–å†™åˆå§‹ä»£ç å’Œé€²è¡Œå®è·µç­‰é¡¹ç›®ã€‚ NEAR æ˜¯å®Œå…¨å»ä¸­å¿ƒåŒ–çš„ï¼Œç‹¬ç«‹è¿è¡Œï¼Œä¸èƒ½è¢«å…³é—­æˆ–æ“çºµï¼Œå³ä½¿æ˜¯é‚£äº›æ„å»ºå®ƒçš„äººã€‚

è¿™æ˜¯ä¸€ä¸ªä¸“æ³¨äºå›´ç»• NEAR åŒºå—é“¾åˆ›å»ºä¸€ä¸ªå……æ»¡æ´»åŠ›çš„ç”Ÿæ€ç³»ç»Ÿçš„éè¥åˆ©ç»„ç»‡ã€‚å®ƒæœ‰åŠ©äºåè°ƒæ²»ç†æ´»åŠ¨å’Œå¼€å‘ã€‚NEAR Collectiveæœ‰å‡ ä¸ªé¡¹ç›®ï¼Œ NEAR åŒºå—é“¾åªæ˜¯å‡ ä¸ªé¡¹ç›®ä¹‹ä¸€ã€‚

NEAR å…±è¯†æœºåˆ¶
åœ¨ NEAR ä¸Šå®ç°çš„å…±è¯†åˆ¶ç§°ä¸ºNightshadeã€‚Nightshade å°†ç³»ç»Ÿè§†ä¸ºå•ä¸ªåŒºå—é“¾ã€‚æ¯ä¸ªåŒºå—ä¸­æ‰€æœ‰äº¤æ˜“çš„åˆ—è¡¨ä¼šè¢«æ‹†åˆ†ä¸ºå¤šä¸ªç¢å—ï¼Œæ¯ä¸ªç¢å—ä¸­ä¼šæœ‰ä¸€ä¸ªåˆ†ç‰‡ã€‚æ‰€æœ‰ç¢å—å¯ä»¥ç»„æˆä¸€ä¸ªåŒºå—ï¼Œå—åªå¯ä»¥è¢«ç»´æŒå®ƒçš„åˆ†ç‰‡çŠ¶æ€çš„èŠ‚ç‚¹è¿›è¡ŒéªŒè¯ã€‚

è¯´åˆ°éªŒè¯ï¼ŒNEAR çš„ä¸€ä¸ªå…³é”®ç»„ä»¶æ˜¯éªŒè¯è€…ã€‚è¿™äº›éªŒè¯è€…è´Ÿè´£ç»´æŒåœ¨åè®®å†…çš„å…±è¯†ã€‚éªŒè¯è€…æ˜¯ä¸“é—¨çš„èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦ä¿æŒæœåŠ¡å™¨ä¸€ç›´åœ¨çº¿ï¼ŒåŒæ—¶ä¿æŒç³»ç»Ÿåœ¨æœ€æ–°çŠ¶æ€ã€‚

å…³äºç½‘ç»œéªŒè¯è€…ï¼Œæ‚¨å¿…é¡»ç‰¢è®°ä»¥ä¸‹å‡ ç‚¹ã€‚
* æ¯ä¸ªepochéƒ½ä¼šç¡®å®šå®ƒçš„ç½‘ç»œéªŒè¯è€…ï¼Œå¹¶æ ¹æ®å®ƒä»¬çš„æŠµæŠ¼é€‰æ‹©å®ƒä»¬
* å·²è·é€‰çš„éªŒè¯è€…å¯ä»¥é€šè¿‡é‡æ–°æŠµæŠ¼ä»–ä»¬çš„é€šè¯å’Œç´¯ç§¯çš„å¥–åŠ±æ¥å†æ¬¡å‚åŠ ã€‚
* æ½œåœ¨çš„éªŒè¯è€…å¿…é¡»ä¿è¯ä»–ä»¬çš„æŠµæŠ¼ä¿æŒåœ¨ä¸€ä¸ªåŠ¨æ€ç¡®å®šçš„å€¼ä¹‹ä¸Š
* éªŒè¯è€…å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥åŠ å¼ºä»–ä»¬çš„æƒç›Šä»½é¢-è‡ªå·±è´­ä¹°é€šè¯æˆ–é€šè¿‡å€Ÿç”¨å…¶ä»–äººçš„æŠµæŠ¼å§”æ‰˜ã€‚
* æ‚¨å¾—åˆ°çš„å›æŠ¥ä¸æ‚¨çš„æŠµæŠ¼æˆæ­£æ¯”-æŠµæŠ¼è¶Šå¤šï¼Œå¥–åŠ±è¶Šå¤š

è¿™ä¸€å…±è¯†æ˜¯åŸºäºæœ€é‡æƒé‡é“¾å…±è¯†ã€‚è¿™æ„å‘³ç€ï¼Œä¸€æ—¦å—ç”Ÿæˆå™¨å‘å¸ƒäº†ä¸€ä¸ªå—ï¼Œå®ƒä»¬å°†æ”¶é›†éªŒè¯è€…èŠ‚ç‚¹çš„ç­¾åã€‚ç„¶åï¼Œå—çš„æƒé‡æ˜¯è¯¥å—ä¸­åŒ…å«ç­¾åçš„æ‰€æœ‰ç­¾åè€…çš„ç´¯ç§¯ã€‚è¯¥é“¾çš„æƒé‡æ˜¯å„å—æƒé‡ä¹‹å’Œã€‚å¦å¤–ï¼Œå…±è¯†ä½¿ç”¨äº†ä¸€ä¸ªç¡®å®šæ€§å°å·¥å…·ï¼Œè¯¥å·¥å…·å¼•å…¥äº†é¢å¤–çš„â€åˆ é™¤æ¡ä»¶â€ä»¥æé«˜é“¾çš„å®‰å…¨æ€§ã€‚
Doomslug æ˜¯å“ªä¸ªåè®®çš„åŒºå—ç”Ÿæˆæœºåˆ¶?

-Nearåè®®
-Solana
### Aurora and NEAR åè®®
Aurora ä¹Ÿåœ¨NEAR åè®®ä¸Šæ¨å‡ºï¼Œæä¾›ä»¥å¤ªåŠç¬¬ 2 å±‚ä½“éªŒï¼ŒAurora æ”¹è¿› NEAR çš„ä¸€äº›æ–¹æ³•æ˜¯:

* å®ƒæœ‰åŠ©äºå°†ååé‡æé«˜åˆ°æ¯ç§’æ•°åƒä¸ªäº¤æ˜“
* åŒºå—çš„ç¡®å®šæ€§æ—¶é—´ä¸º2ç§’
* æœªæ¥ç”Ÿæ€ç³»ç»Ÿçš„å¢é•¿
* ä½äº¤æ˜“è´¹ï¼Œæ¯”ä»¥å¤ªåŠä½1000å€
* ä¸ä»¥å¤ªåŠæ°¸è¿œä¿æŒå…¼å®¹æ€§

ä»£ç ç¤ºä¾‹
```rust
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ContentRecord {
    pub price: Balance,
    pub content: String,
    pub owner: AccountId,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct ContentTracker {
    values: LookupMap<String, ContentRecord>,
    contract_owner: AccountId,
}

impl Default for ContentTracker {
    fn default() -> Self {
        let contract_owner = env::predecessor_account_id();
        Self {
            values: LookupMap::new(b"v".to_vec()),
            contract_owner,
        }
    }
}

#[near_bindgen]
impl ContentTracker {
    /// Gets content at a given route.
    pub fn get_route(&self, route: String) -> Option<String> {
        self.values.get(&route).map(|v| v.content)
    }

    /// Purchases a route based on funds sent to the contract.
    #[payable]
    pub fn purchase(&mut self, route: String, content: String) {
        let deposit = env::attached_deposit();
        assert!(deposit > 0);
        if let Some(entry) = self.values.get(&route) {
            assert!(
                deposit > entry.price,
                "Not enough deposit to purchase route, price: {} deposit: {}",
                entry.price,
                deposit
            );

            // Refund purchase to existing owner
            Promise::new(entry.owner).transfer(entry.price);
        }

        // Update record for the contract state.
        self.values.insert(
            &route,
            &ContentRecord {
                price: deposit,
                content,
                owner: env::predecessor_account_id(),
            },
        );
    }

    /// Allows owner of the contract withdraw funds.
    pub fn withdraw(&mut self) {
        assert_eq!(env::predecessor_account_id(), self.contract_owner);

        // Send the contract funds to the contract owner
        Promise::new(self.contract_owner.clone()).transfer(env::account_balance());
    }
}

```

åˆçº¦è§£é‡Š
* è¯¥åˆçº¦ç”± ContentTracker ä¸­çš„ #[near_bindgen] å®šä¹‰ï¼Œå®ƒç±»ä¼¼äº Solidity ä¸­çš„æ„é€ å‡½æ•°ï¼Œå¹¶åœ¨éƒ¨ç½²åˆçº¦æ—¶è°ƒç”¨
* purchaseå‡½æ•° ä½¿ç”¨äº†  #[payable] æ³¨è§£
* åˆçº¦åŒ…æ‹¬ä»¥ Promise: : new (...) . transfer (...) ; lines çš„å½¢å¼è¿›è¡Œçš„å¼‚æ­¥è°ƒç”¨
* æ•°æ®ç»“æ„ LookupMap < Stringï¼ŒContentRecord > å¤„ç†é”®å€¼æŸ¥æ‰¾ï¼Œè¿™ç­‰åŒäºsolidityçš„â€œmappingâ€

## 3.æ€»ç»“
Solana å’Œ NEAR åè®®éƒ½æ˜¯å“è¶Šçš„æ™ºèƒ½åˆçº¦å¹³å°ï¼Œå·²ç»å»ºç«‹äº†é«˜åº¦æ´»è·ƒçš„ç¤¾åŒºã€‚ä»–ä»¬éƒ½å¸¦æ¥äº†ç‰¹æ®Šçš„åŠŸèƒ½ï¼Œå¸®åŠ©è§£å†³å»ä¸­å¿ƒåŒ–æœ€å¤§çš„é—®é¢˜-é€Ÿåº¦ã€‚
è¿™ä¸¤ä¸ªå¹³å°éƒ½åœ¨ä¸æ–­æˆé•¿ï¼Œå¹¶ä¸”å‰æ™¯çœ‹å¥½ã€‚

åŸæ–‡é“¾æ¥ï¼šhttps://learnnear.club/near-protocol-and-solana/

'''
'''--- cn/resources/guides/README.md ---

Posts |
--- | 
NEAR Account â€“ Express Guide | 
What is NEAR protocol?  | 
NEAR ğŸ¤ Ethereum | 
NEAR Protocol and Solana | 
How the NEAR Rainbow Bridge works | 
How to Build on NEAR? Starting Guide | @shepf | 
NEAR Sputnik DAO: Empowering Communities | 

'''
'''--- cn/resources/guides/near-account-express-guide.md ---
# NEARè´¦æˆ· - å¿«é€ŸæŒ‡å—
## NEARè´¦æˆ·ä»‹ç»
1. NEARä½¿ç”¨äººç±»å¯è¯»çš„è´¦æˆ·æ ‡è¯†ç¬¦ã€‚ä¾‹å¦‚ï¼Œmaria.near æˆ– jane.nearã€‚
2. ä» NEAR å¸æˆ·å¯ä»¥æ ¹æ®éœ€è¦åˆ›å»ºå¤šä¸ªå­å¸æˆ·çš„è§’åº¦æ¥çœ‹ï¼ŒNEAR å¸æˆ·ç³»ç»Ÿç±»ä¼¼äºç½‘ç«™åŸŸåç³»ç»Ÿã€‚ ä¾‹å¦‚ï¼Œmaria.near çš„å¸æˆ·å¯ä»¥åˆ›å»ºåƒ sub.maria.near å¸æˆ·ï¼Œä»¥åŠfirst.sub.masha.near, second.sub.maria.nearç­‰ã€‚
3. NEARé’±åŒ… (https://wallet.near.org/) ã€NEARæ°´é¾™å¤´ (https://faucet.paras.id/) ï¼ˆEthereumå’ŒMetamaskç”¨æˆ·å¯ä»¥ä½¿ç”¨ï¼‰å’Œ near-cli (https://github.com/near/near-cli) ï¼ˆä¸ºNEARé›†æˆæä¾›åŠŸèƒ½çš„å‘½ä»¤è¡Œæ¥å£ï¼‰éƒ½å¯ä»¥ç”¨æ¥åˆ›å»ºå¸æˆ·ã€‚
4. é€šè¿‡ https://nearnames.com æœåŠ¡ï¼Œæ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ª NEAR å¸æˆ·å¹¶çš„ä½œä¸ºç¤¼ç‰©å‘é€ç»™æœ‹å‹æˆ–è®¢é˜…è€…ã€‚
5. æ‚¨å¯ä»¥åœ¨NEARæµè§ˆå™¨ (https://explorer.near.org/) ä»¥åŠNEARçš„é’±åŒ…ä¸­æŸ¥çœ‹å¸æˆ·ä¿¡æ¯ã€‚
6. é™¤äº†æ˜¾å¼å¸æˆ·ï¼ˆname.nearç±»å‹ï¼‰ï¼ŒNEAR ç”Ÿæ€ç³»ç»Ÿè¿˜æ”¯æŒé€šè¿‡ near-cli åˆ›å»ºéšå¼è´¦æˆ·ï¼ˆå®ƒä»¬çœ‹èµ·æ¥ä¸æ¯”ç‰¹å¸å’Œä»¥å¤ªåŠåœ°å€ç›¸ä¼¼ï¼‰ã€‚ æ‚¨å¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°è¯¦ç»†çš„[è‹±æ–‡æŒ‡å—](https://docs.near.org/docs/roles/integrator/implicit-accounts)
7. ç³»ç»Ÿä¸­çš„æ¯ä¸ªå¸æˆ·åªèƒ½éƒ¨ç½²1ä¸ªæ™ºèƒ½åˆçº¦ã€‚ å¯¹äºè¦æ±‚ç”¨æˆ·ä½¿ç”¨å¤šä¸ªæ™ºèƒ½åˆçº¦çš„åº”ç”¨ç¨‹åºï¼Œå¯ä»¥ä½¿ç”¨å­å¸æˆ·æ¥éƒ¨ç½²ã€‚ ä¾‹å¦‚ contract_1.maria.nearã€contract_2.maria.nearç­‰ã€‚
8. åœ¨NEARç”Ÿæ€ç³»ç»Ÿä¸­æœ‰å¼€å‘è€…å¸æˆ·ï¼ˆhttps://docs.near.org/docs/concepts/account#dev-accountsï¼‰ã€‚ ä»–ä»¬çš„ä¸“ç”¨äºæµ‹è¯•å’Œè°ƒè¯•æ™ºèƒ½åˆçº¦ã€‚

## NEARè´¦æˆ· - Keys
1. NEARå’Œå…¶ä»–å¤§å¤šæ•°åŒºå—é“¾ä¸€æ ·ä½¿ç”¨åŸºäºå¯†ç å­¦çš„å¯†é’¥ã€‚ å®ƒä¾èµ–äºä¸€å¯¹æˆ–å¤šå¯¹ç”±ç›¸äº’åŒ¹é…çš„**å…¬é’¥ï¼ˆpublic key**ï¼‰å’Œ**ç§é’¥ï¼ˆprivate keyï¼‰** ç»„æˆçš„å¯†é’¥å¯¹ã€‚
2. NEAR ç”¨æˆ·ä½¿ç”¨å…¬é’¥è¿›è¡Œèº«ä»½è¯†åˆ«ï¼Œç”¨ç§é’¥è¿›è¡Œç­¾åäº¤æ˜“ï¼ˆåœ¨äº¤æ˜“åˆ›å»ºæœŸé—´ç¡®è®¤å¸æˆ·æ‰€æœ‰æƒï¼‰ã€‚
3. NEAR æœ‰3ç§ç±»å‹çš„å¯†é’¥ï¼š**Access Keys**ç”¨äºå¸æˆ·äº¤æ˜“ç­¾åï¼Œ**Validator Keys**å…è®¸ä¸ç½‘ç»œéªŒè¯ç›¸å…³çš„æ“ä½œï¼Œ**Node Keys**ï¼ˆç½‘ç»œèŠ‚ç‚¹ï¼‰å…è®¸ç½‘ç»œä¸ŠèŠ‚ç‚¹ä¹‹é—´çš„åº•å±‚é€šä¿¡ã€‚æ›´å¤šèµ„æ–™ä»‹ç»å¯ä»¥å‚è€ƒ[è¿™é‡Œ](https://docs.near.org/docs/develop/node/intro/types-of-node)
4. å¯†é’¥å¯ä»¥å­˜å‚¨åœ¨3ç§ä¸åŒçš„å­˜å‚¨ä¸­ï¼š**BrowserLocalStorageKeyStore** - æœªåŠ å¯†çš„æœ¬åœ°æµè§ˆå™¨å­˜å‚¨ï¼Œç”¨äºä½¿ç”¨æµè§ˆå™¨ä¸­çš„åº”ç”¨ç¨‹åºï¼›**InMemoryKeyStore** - å†…å­˜å­˜å‚¨ï¼Œç”¨äºä¸´æ—¶æ–¹æ¡ˆæˆ–åœ¨æœ¬åœ°ç¨‹åºæŒ‡å®šç‰¹å®šçš„å¯†é’¥ï¼› **UnencryptedFileSystemKeyStore** - ç”¨äº near-cliæˆ–æœ¬åœ°ç¨‹åºï¼Œæ˜¯ä½äºæ–‡ä»¶ç³»ç»Ÿä¸­çš„æœªåŠ å¯†å­˜å‚¨ã€‚
5. å¸æˆ·å¯ä»¥å…·æœ‰å¤šä¸ªè®¿é—®å¯†é’¥æˆ–æ²¡æœ‰å¯†é’¥ã€‚
6. å¯†é’¥å¯ä»¥å…·æœ‰ä¸åŒçš„è®¿é—®çº§åˆ« - **FullAccess**ï¼ˆå®Œå…¨è®¿é—®ï¼‰æˆ– **FunctionCall**ï¼ˆåªèƒ½è°ƒç”¨åˆçº¦æ–¹æ³•ï¼‰ã€‚
7. æ‰€æœ‰å¯†é’¥åœ¨ä¸€ä¸ªå¸æˆ·ä¸­æ˜¯å”¯ä¸€çš„ï¼Œä½†åŒä¸€ä¸ªå…¬é’¥å¯ä»¥ä»¥ä¸åŒè®¿é—®çº§åˆ«æ·»åŠ åˆ°ä¸åŒå¸æˆ·ä¸Šã€‚ è®¿é—®çº§åˆ«å†³å®šäº†å¯ä»¥ä½¿ç”¨æ­¤å¯†é’¥æ‰§è¡Œå¸æˆ·ä¸­çš„å“ªäº›æ“ä½œã€‚
8. å¯¹äº **FullAccess** è®¿é—®çº§åˆ«ï¼Œæ‰€æœ‰8ç§ç±»å‹çš„æ“ä½œå‡å¯ç”¨ï¼šCreateAccountActionï¼ˆåˆ›å»ºå¸æˆ·ï¼‰ã€DeployContractActionï¼ˆéƒ¨ç½²åˆçº¦ï¼‰ã€FunctionCallActionï¼ˆè°ƒç”¨åˆçº¦æ–¹æ³•ï¼‰ã€TransferActionï¼ˆå°†é€šè¯å‘é€åˆ°å¦ä¸€ä¸ªå¸æˆ·ï¼‰ã€StakeActionï¼ˆè´¨æŠ¼é€šè¯ï¼‰ã€AddKeyActionï¼ˆç»™è´¦æˆ·æ·»åŠ å¯†é’¥ï¼‰ã€DeleteKeyActionï¼ˆåˆ é™¤å¸æˆ·çš„æŸä¸ªå¯†é’¥ï¼‰ã€DeleteAccountActionï¼ˆåˆ é™¤å¸æˆ·ï¼‰ã€‚
9. å¯¹äº **FunctionCall** è®¿é—®çº§åˆ«ï¼Œåªæœ‰FunctionCallActionå¯ç”¨ï¼ˆè°ƒç”¨åˆçº¦æ–¹æ³•ï¼‰ã€‚ æ­¤å¤–ï¼Œå¯¹äºè¿™æ ·çš„å¯†é’¥ï¼Œæ‚¨å¯ä»¥æŒ‡å®šå®ƒå¯ä»¥è°ƒç”¨çš„åˆçº¦æ–¹æ³•ã€‚

Source / åŸæ–‡é“¾æ¥ï¼šhttps://learnnear.club/near-account-express-guide/

'''
'''--- cn/resources/guides/what-is-near-protocol.md ---
# NEAR Protocol æ˜¯ä»€ä¹ˆ?

NEAR æ˜¯ä¸€ä¸ªè¿è¡Œåœ¨ NEAR Protocol åŒºå—é“¾ä¹‹ä¸Šçš„å»ä¸­å¿ƒåŒ–åº”ç”¨å¹³å°

åŸæ–‡é“¾æ¥ï¼šhttps://learnnear.club/what-is-near-protocol/

'''
'''--- cn/resources/ncd/level1/README.md ---
### NEAR Certified Developer Level 1

#### Course Content

Step |
--- |
Course Intro  |
Intro â€“ NEAR Certified Developer Level 1  |
Step 1 â€“ Perceiving web3 â€“ NEAR Certified Developer Level 1  |
Step 2 â€“ Reading web3 NEAR Certified Developer Level 1  |
Step 3 â€“ Writing web3 NEAR Certified Developer Level 1  |
Step 4 â€“ Testing web3 NEAR Certified Developer Level 1  |
Step 5 â€“ Deploying web3 NEAR Certified Developer Level 1  |
Step 6 â€“ Demo web3 NEAR Certified Developer Level 1  |
Further Steps after NEAR Certified Developer Level 1  |

'''