*GitHub Repository "Ideevoog/Toolblox.Ada.App"*

'''--- .github/workflows/adawillhandlefunctions.yml ---
name: Build and deploy .NET Core application to Function App adawillhandlefunctions
on:
  push:
    branches:
    - main
env:
  AZURE_FUNCTIONAPP_NAME: adawillhandlefunctions
  AZURE_FUNCTIONAPP_PACKAGE_PATH: Toolblox.Ada.App.Functions\published
  CONFIGURATION: Release
  DOTNET_CORE_VERSION: 6.0.x
  WORKING_DIRECTORY: Toolblox.Ada.App.Functions
jobs:
  build:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@master
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: ${{ env.DOTNET_CORE_VERSION }}
    - name: Restore
      run: dotnet restore "${{ env.WORKING_DIRECTORY }}"
    - name: Build
      run: dotnet build "${{ env.WORKING_DIRECTORY }}" --configuration ${{ env.CONFIGURATION }} --no-restore
    - name: Publish
      run: dotnet publish "${{ env.WORKING_DIRECTORY }}" --configuration ${{ env.CONFIGURATION }} --no-build --output "${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}"
    - name: Publish Artifacts
      uses: actions/upload-artifact@v1.0.0
      with:
        name: functionapp
        path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
  deploy:
    runs-on: windows-latest
    needs: build
    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v2
      with:
        name: functionapp
        path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
    - name: Deploy to Azure Function App
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
        publish-profile: ${{ secrets.adawillhandlefunctions_8D67 }}
        package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

'''
'''--- LICENSE.md ---
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

'''
'''--- Lib/NBitcoin.deps.json ---
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.0/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.0": {},
    ".NETStandard,Version=v2.0/": {
      "NBitcoin/7.0.17": {
        "dependencies": {
          "Microsoft.Extensions.Logging.Abstractions": "1.0.0",
          "Microsoft.SourceLink.GitHub": "1.1.1",
          "NETStandard.Library": "2.0.3",
          "Newtonsoft.Json": "13.0.1",
          "System.Buffers": "4.5.0"
        },
        "runtime": {
          "NBitcoin.dll": {}
        }
      },
      "Microsoft.Build.Tasks.Git/1.1.1": {},
      "Microsoft.Extensions.Logging.Abstractions/1.0.0": {
        "dependencies": {
          "System.Collections": "4.0.11",
          "System.Collections.Concurrent": "4.0.12",
          "System.Diagnostics.Debug": "4.0.11",
          "System.Globalization": "4.0.11",
          "System.Linq": "4.1.0",
          "System.Reflection": "4.1.0",
          "System.Resources.ResourceManager": "4.0.1",
          "System.Runtime.Extensions": "4.1.0",
          "System.Runtime.InteropServices": "4.1.0"
        },
        "runtime": {
          "lib/netstandard1.1/Microsoft.Extensions.Logging.Abstractions.dll": {
            "assemblyVersion": "1.0.0.0",
            "fileVersion": "1.0.0.20622"
          }
        }
      },
      "Microsoft.NETCore.Platforms/1.1.0": {},
      "Microsoft.NETCore.Targets/1.0.1": {},
      "Microsoft.SourceLink.Common/1.1.1": {},
      "Microsoft.SourceLink.GitHub/1.1.1": {
        "dependencies": {
          "Microsoft.Build.Tasks.Git": "1.1.1",
          "Microsoft.SourceLink.Common": "1.1.1"
        }
      },
      "NETStandard.Library/2.0.3": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0"
        }
      },
      "Newtonsoft.Json/13.0.1": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "13.0.0.0",
            "fileVersion": "13.0.1.25517"
          }
        }
      },
      "System.Buffers/4.5.0": {
        "runtime": {
          "lib/netstandard2.0/System.Buffers.dll": {
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.26515.6"
          }
        }
      },
      "System.Collections/4.0.11": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Collections.Concurrent/4.0.12": {
        "dependencies": {
          "System.Collections": "4.0.11",
          "System.Diagnostics.Debug": "4.0.11",
          "System.Diagnostics.Tracing": "4.1.0",
          "System.Globalization": "4.0.11",
          "System.Reflection": "4.1.0",
          "System.Resources.ResourceManager": "4.0.1",
          "System.Runtime": "4.1.0",
          "System.Runtime.Extensions": "4.1.0",
          "System.Threading": "4.0.11",
          "System.Threading.Tasks": "4.0.11"
        },
        "runtime": {
          "lib/netstandard1.3/System.Collections.Concurrent.dll": {
            "assemblyVersion": "4.0.12.0",
            "fileVersion": "1.0.24212.1"
          }
        }
      },
      "System.Diagnostics.Debug/4.0.11": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Diagnostics.Tracing/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Globalization/4.0.11": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.IO/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0",
          "System.Text.Encoding": "4.0.11",
          "System.Threading.Tasks": "4.0.11"
        }
      },
      "System.Linq/4.1.0": {
        "dependencies": {
          "System.Collections": "4.0.11",
          "System.Diagnostics.Debug": "4.0.11",
          "System.Resources.ResourceManager": "4.0.1",
          "System.Runtime": "4.1.0",
          "System.Runtime.Extensions": "4.1.0"
        },
        "runtime": {
          "lib/netstandard1.6/System.Linq.dll": {
            "assemblyVersion": "4.1.0.0",
            "fileVersion": "1.0.24212.1"
          }
        }
      },
      "System.Reflection/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.IO": "4.1.0",
          "System.Reflection.Primitives": "4.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Reflection.Primitives/4.0.1": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Resources.ResourceManager/4.0.1": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Globalization": "4.0.11",
          "System.Reflection": "4.1.0",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Runtime/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1"
        }
      },
      "System.Runtime.Extensions/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Runtime.Handles/4.0.1": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Runtime.InteropServices/4.1.0": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Reflection": "4.1.0",
          "System.Reflection.Primitives": "4.0.1",
          "System.Runtime": "4.1.0",
          "System.Runtime.Handles": "4.0.1"
        }
      },
      "System.Text.Encoding/4.0.11": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      },
      "System.Threading/4.0.11": {
        "dependencies": {
          "System.Runtime": "4.1.0",
          "System.Threading.Tasks": "4.0.11"
        },
        "runtime": {
          "lib/netstandard1.3/System.Threading.dll": {
            "assemblyVersion": "4.0.11.0",
            "fileVersion": "1.0.24212.1"
          }
        }
      },
      "System.Threading.Tasks/4.0.11": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.NETCore.Targets": "1.0.1",
          "System.Runtime": "4.1.0"
        }
      }
    }
  },
  "libraries": {
    "NBitcoin/7.0.17": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Microsoft.Build.Tasks.Git/1.1.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-AT3HlgTjsqHnWpBHSNeR0KxbLZD7bztlZVj7I8vgeYG9SYqbeFGh0TM/KVtC6fg53nrWHl3VfZFvb5BiQFcY6Q==",
      "path": "microsoft.build.tasks.git/1.1.1",
      "hashPath": "microsoft.build.tasks.git.1.1.1.nupkg.sha512"
    },
    "Microsoft.Extensions.Logging.Abstractions/1.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-wHT6oY50q36mAXBRKtFaB7u07WxKC5u2M8fi3PqHOOnHyUo9gD0u1TlCNR8UObHQxKMYwqlgI8TLcErpt29n8A==",
      "path": "microsoft.extensions.logging.abstractions/1.0.0",
      "hashPath": "microsoft.extensions.logging.abstractions.1.0.0.nupkg.sha512"
    },
    "Microsoft.NETCore.Platforms/1.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kz0PEW2lhqygehI/d6XsPCQzD7ff7gUJaVGPVETX611eadGsA3A877GdSlU0LRVMCTH/+P3o2iDTak+S08V2+A==",
      "path": "microsoft.netcore.platforms/1.1.0",
      "hashPath": "microsoft.netcore.platforms.1.1.0.nupkg.sha512"
    },
    "Microsoft.NETCore.Targets/1.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-rkn+fKobF/cbWfnnfBOQHKVKIOpxMZBvlSHkqDWgBpwGDcLRduvs3D9OLGeV6GWGvVwNlVi2CBbTjuPmtHvyNw==",
      "path": "microsoft.netcore.targets/1.0.1",
      "hashPath": "microsoft.netcore.targets.1.0.1.nupkg.sha512"
    },
    "Microsoft.SourceLink.Common/1.1.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-WMcGpWKrmJmzrNeuaEb23bEMnbtR/vLmvZtkAP5qWu7vQsY59GqfRJd65sFpBszbd2k/bQ8cs8eWawQKAabkVg==",
      "path": "microsoft.sourcelink.common/1.1.1",
      "hashPath": "microsoft.sourcelink.common.1.1.1.nupkg.sha512"
    },
    "Microsoft.SourceLink.GitHub/1.1.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-IaJGnOv/M7UQjRJks7B6p7pbPnOwisYGOIzqCz5ilGFTApZ3ktOR+6zJ12ZRPInulBmdAf1SrGdDG2MU8g6XTw==",
      "path": "microsoft.sourcelink.github/1.1.1",
      "hashPath": "microsoft.sourcelink.github.1.1.1.nupkg.sha512"
    },
    "NETStandard.Library/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-st47PosZSHrjECdjeIzZQbzivYBJFv6P2nv4cj2ypdI204DO+vZ7l5raGMiX4eXMJ53RfOIg+/s4DHVZ54Nu2A==",
      "path": "netstandard.library/2.0.3",
      "hashPath": "netstandard.library.2.0.3.nupkg.sha512"
    },
    "Newtonsoft.Json/13.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-ppPFpBcvxdsfUonNcvITKqLl3bqxWbDCZIzDWHzjpdAHRFfZe0Dw9HmA0+za13IdyrgJwpkDTDA9fHaxOrt20A==",
      "path": "newtonsoft.json/13.0.1",
      "hashPath": "newtonsoft.json.13.0.1.nupkg.sha512"
    },
    "System.Buffers/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-pL2ChpaRRWI/p4LXyy4RgeWlYF2sgfj/pnVMvBqwNFr5cXg7CXNnWZWxrOONLg8VGdFB8oB+EG2Qw4MLgTOe+A==",
      "path": "system.buffers/4.5.0",
      "hashPath": "system.buffers.4.5.0.nupkg.sha512"
    },
    "System.Collections/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-YUJGz6eFKqS0V//mLt25vFGrrCvOnsXjlvFQs+KimpwNxug9x0Pzy4PlFMU3Q2IzqAa9G2L4LsK3+9vCBK7oTg==",
      "path": "system.collections/4.0.11",
      "hashPath": "system.collections.4.0.11.nupkg.sha512"
    },
    "System.Collections.Concurrent/4.0.12": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-2gBcbb3drMLgxlI0fBfxMA31ec6AEyYCHygGse4vxceJan8mRIWeKJ24BFzN7+bi/NFTgdIgufzb94LWO5EERQ==",
      "path": "system.collections.concurrent/4.0.12",
      "hashPath": "system.collections.concurrent.4.0.12.nupkg.sha512"
    },
    "System.Diagnostics.Debug/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-w5U95fVKHY4G8ASs/K5iK3J5LY+/dLFd4vKejsnI/ZhBsWS9hQakfx3Zr7lRWKg4tAw9r4iktyvsTagWkqYCiw==",
      "path": "system.diagnostics.debug/4.0.11",
      "hashPath": "system.diagnostics.debug.4.0.11.nupkg.sha512"
    },
    "System.Diagnostics.Tracing/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-vDN1PoMZCkkdNjvZLql592oYJZgS7URcJzJ7bxeBgGtx5UtR5leNm49VmfHGqIffX4FKacHbI3H6UyNSHQknBg==",
      "path": "system.diagnostics.tracing/4.1.0",
      "hashPath": "system.diagnostics.tracing.4.1.0.nupkg.sha512"
    },
    "System.Globalization/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-B95h0YLEL2oSnwF/XjqSWKnwKOy/01VWkNlsCeMTFJLLabflpGV26nK164eRs5GiaRSBGpOxQ3pKoSnnyZN5pg==",
      "path": "system.globalization/4.0.11",
      "hashPath": "system.globalization.4.0.11.nupkg.sha512"
    },
    "System.IO/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-3KlTJceQc3gnGIaHZ7UBZO26SHL1SHE4ddrmiwumFnId+CEHP+O8r386tZKaE6zlk5/mF8vifMBzHj9SaXN+mQ==",
      "path": "system.io/4.1.0",
      "hashPath": "system.io.4.1.0.nupkg.sha512"
    },
    "System.Linq/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-bQ0iYFOQI0nuTnt+NQADns6ucV4DUvMdwN6CbkB1yj8i7arTGiTN5eok1kQwdnnNWSDZfIUySQY+J3d5KjWn0g==",
      "path": "system.linq/4.1.0",
      "hashPath": "system.linq.4.1.0.nupkg.sha512"
    },
    "System.Reflection/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-JCKANJ0TI7kzoQzuwB/OoJANy1Lg338B6+JVacPl4TpUwi3cReg3nMLplMq2uqYfHFQpKIlHAUVAJlImZz/4ng==",
      "path": "system.reflection/4.1.0",
      "hashPath": "system.reflection.4.1.0.nupkg.sha512"
    },
    "System.Reflection.Primitives/4.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-4inTox4wTBaDhB7V3mPvp9XlCbeGYWVEM9/fXALd52vNEAVisc1BoVWQPuUuD0Ga//dNbA/WeMy9u9mzLxGTHQ==",
      "path": "system.reflection.primitives/4.0.1",
      "hashPath": "system.reflection.primitives.4.0.1.nupkg.sha512"
    },
    "System.Resources.ResourceManager/4.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-TxwVeUNoTgUOdQ09gfTjvW411MF+w9MBYL7AtNVc+HtBCFlutPLhUCdZjNkjbhj3bNQWMdHboF0KIWEOjJssbA==",
      "path": "system.resources.resourcemanager/4.0.1",
      "hashPath": "system.resources.resourcemanager.4.0.1.nupkg.sha512"
    },
    "System.Runtime/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-v6c/4Yaa9uWsq+JMhnOFewrYkgdNHNG2eMKuNqRn8P733rNXeRCGvV5FkkjBXn2dbVkPXOsO0xjsEeM1q2zC0g==",
      "path": "system.runtime/4.1.0",
      "hashPath": "system.runtime.4.1.0.nupkg.sha512"
    },
    "System.Runtime.Extensions/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-CUOHjTT/vgP0qGW22U4/hDlOqXmcPq5YicBaXdUR2UiUoLwBT+olO6we4DVbq57jeX5uXH2uerVZhf0qGj+sVQ==",
      "path": "system.runtime.extensions/4.1.0",
      "hashPath": "system.runtime.extensions.4.1.0.nupkg.sha512"
    },
    "System.Runtime.Handles/4.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-nCJvEKguXEvk2ymk1gqj625vVnlK3/xdGzx0vOKicQkoquaTBJTP13AIYkocSUwHCLNBwUbXTqTWGDxBTWpt7g==",
      "path": "system.runtime.handles/4.0.1",
      "hashPath": "system.runtime.handles.4.0.1.nupkg.sha512"
    },
    "System.Runtime.InteropServices/4.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-16eu3kjHS633yYdkjwShDHZLRNMKVi/s0bY8ODiqJ2RfMhDMAwxZaUaWVnZ2P71kr/or+X9o/xFWtNqz8ivieQ==",
      "path": "system.runtime.interopservices/4.1.0",
      "hashPath": "system.runtime.interopservices.4.1.0.nupkg.sha512"
    },
    "System.Text.Encoding/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-U3gGeMlDZXxCEiY4DwVLSacg+DFWCvoiX+JThA/rvw37Sqrku7sEFeVBBBMBnfB6FeZHsyDx85HlKL19x0HtZA==",
      "path": "system.text.encoding/4.0.11",
      "hashPath": "system.text.encoding.4.0.11.nupkg.sha512"
    },
    "System.Threading/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-N+3xqIcg3VDKyjwwCGaZ9HawG9aC6cSDI+s7ROma310GQo8vilFZa86hqKppwTHleR/G0sfOzhvgnUxWCR/DrQ==",
      "path": "system.threading/4.0.11",
      "hashPath": "system.threading.4.0.11.nupkg.sha512"
    },
    "System.Threading.Tasks/4.0.11": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-k1S4Gc6IGwtHGT8188RSeGaX86Qw/wnrgNLshJvsdNUOPP9etMmo8S07c+UlOAx4K/xLuN9ivA1bD0LVurtIxQ==",
      "path": "system.threading.tasks/4.0.11",
      "hashPath": "system.threading.tasks.4.0.11.nupkg.sha512"
    }
  }
}
'''
'''--- Lib/NBitcoin.xml ---
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NBitcoin</name>
    </assembly>
    <members>
        <member name="T:NBitcoin.Base58Data">
            <summary>
            Base class for all Base58 check representation of data
            </summary>
        </member>
        <member name="T:NBitcoin.BitStream">
            <summary> Provides a view of an array of bits as a stream of bits. </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilter">
            <summary>
            Implements a Golomb-coded set to be use in the creation of client-side filter
            for a new kind Bitcoin light clients. This code is based on the BIP:
            https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.P">
            <summary>
            a value which is computed as 1/fp where fp is the desired false positive rate.
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.M">
            <summary>
            a value which is computed as N * fp (or false positive rate = 1/M).
            this value allows filter to uniquely tune the range that items are hashed onto
            before compressing
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.N">
            <summary>
            Number of elements in the filter
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.Data">
            <summary>
            Raw filter data
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Parse(System.String)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[])">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Byte,System.UInt32)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="p">The P value to use.</param>
            <param name="m">The M value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Int32,System.Byte,System.UInt32)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="n">The number of elements in the filter.</param>
            <param name="p">The P value to use.</param>
            <param name="m">The M value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ConstructHashedSet(System.Byte,System.Int32,System.UInt32,System.Byte[],System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32)">
            <summary>
            Computes the sorted-and-uncompressed list of values to be included in the filter.
            /// </summary>
            <param name="P">P value used.</param>
            <param name="key">Key used for hashing the datalements.</param>
            <param name="data">Data elements to be computed in the list.</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.GetHeader(NBitcoin.uint256)">
            <summary>
            Calculates the filter's header.
            </summary>
            <param name="previousHeader">Previous filter header.</param>
            <returns>The filter header.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Match(System.Byte[],System.Byte[])">
            <summary>
            Checks if the value passed is in the filter.
            </summary>
            <param name="data">Data element to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if the element is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Byte[][],System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Collections.Generic.IEnumerable{System.Byte[]},System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToBytes">
            <summary>
            Serialize the filter as a array of bytes using [varint(N) | data].
            </summary>
            <returns>A array of bytes with the serialized filter data.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToString">
            <summary>
            Serialize the filter as hexadecimal string.
            </summary>
            <returns>A string with the serialized filter data</returns>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder">
            <summary>
            Class for creating Golomb-Rice filters for a given block.
            It provides methods for building two kind of filters out-of-the-box:
            Basic Filters and Extenden Filters.
            </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder.ByteArrayComparer">
            <summary>
            Helper class for making sure not two identical data elements are
            included in a filter.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.BuildBasicFilter(NBitcoin.Block)">
             <summary>
             Builds the basic filter for a given block.
            
             The basic filter is designed to contain everything that a light client needs to sync a regular Bitcoin wallet.
             A basic filter MUST contain exactly the following items for each transaction in a block:
              * The outpoint of each input, except for the coinbase transaction
              * The scriptPubKey of each output
              * The txid of the transaction itself
             </summary>
             <param name="block">The block used for building the filter.</param>
             <returns>The basic filter for the block.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.#ctor">
            <summary>
            Creates a new Golob-Rice filter builder.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetKey(NBitcoin.uint256)">
            <summary>
            Sets the key used for hashing the filter data elements.
            The first half of the block hash is used as described in the BIP.
            </summary>
            <param name="blockHash">The block hash which the hashing key is derived from.</param>
            <returns>The updated filter builder instance</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetP(System.Int32)">
            <summary>
            Sets the P value to use.
            </summary>
            <param name="p">P value</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetM(System.UInt32)">
            <summary>
            Sets the M value to use.
            </summary>
            <param name="m">M value</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddTxId(NBitcoin.uint256)">
            <summary>
            Adds a transacion id to the list of elements that will be used for building the filter.
            </summary>
            <param name="id">The transaction id.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptPubkey(NBitcoin.Script)">
            <summary>
            Adds a scriptPubKey to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptPubkey">The scriptPubkey.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptSig(NBitcoin.Script)">
            <summary>
            Adds a scriptSig to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptSig">The scriptSig.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddWitness(NBitcoin.WitScript)">
            <summary>
            Adds a witness stack to the list of elements that will be used for building the filter.
            </summary>
            <param name="witScript">The witScript.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddOutPoint(NBitcoin.OutPoint)">
            <summary>
            Adds an outpoint to the list of elements that will be used for building the filter.
            </summary>
            <param name="outpoint">The outpoint.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddEntries(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Adds a list of elements to the list of elements that will be used for building the filter.
            </summary>
            <param name="entries">The entries.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.Build">
            <summary>
            Builds the Golomb-Rice filters from the parameters and data elements included.
            </summary>
            <returns>The built filter.</returns>
        </member>
        <member name="P:NBitcoin.PSBTSettings.CustomBuilderExtensions">
            <summary>
            Use custom builder extensions to customize finalization
            </summary>
        </member>
        <member name="P:NBitcoin.PSBTSettings.IsSmart">
            <summary>
            Try to do anything that is possible to deduce PSBT information from input information
            </summary>
        </member>
        <member name="M:NBitcoin.PSBT.AddTransactions(NBitcoin.Transaction[])">
            <summary>
            Add transactions to non segwit outputs
            </summary>
            <param name="parentTransactions">Parent transactions</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Combine(NBitcoin.PSBT)">
             <summary>
             If an other PSBT has a specific field and this does not have it, then inject that field to this.
             otherwise leave it as it is.
            
             If you need to call this on transactions with different global transaction, use <see cref="M:NBitcoin.PSBT.UpdateFrom(NBitcoin.PSBT)"/> instead.
             </summary>
             <param name="other">Another PSBT to takes information from</param>
             <exception cref="T:System.ArgumentException">Can not Combine PSBT with different global tx.</exception>
             <returns>This instance</returns>
        </member>
        <member name="M:NBitcoin.PSBT.UpdateFrom(NBitcoin.PSBT)">
             <summary>
             If an other PSBT has a specific field and this does not have it, then inject that field to this.
             otherwise leave it as it is.
            
             Contrary to <see cref="M:NBitcoin.PSBT.Combine(NBitcoin.PSBT)"/>, it can be called on PSBT with a different global transaction.
             </summary>
             <param name="other">Another PSBT to takes information from</param>
             <returns>This instance</returns>
        </member>
        <member name="M:NBitcoin.PSBT.CoinJoin(NBitcoin.PSBT)">
            <summary>
            Join two PSBT into one CoinJoin PSBT.
            This is an immutable method.
            TODO: May need assertion for sighash type?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Sign all inputs which derive <paramref name="accountKey"/> of type <paramref name="scriptPubKeyType"/>.
            </summary>
            <param name="scriptPubKeyType">The way to derive addresses from the accountKey</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="accountKeyPath">The account key path (eg. [masterFP]/49'/0'/0')</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey)">
            <summary>
            Sign all inputs which derive <paramref name="accountKey"/> of type <paramref name="scriptPubKeyType"/>.
            </summary>
            <param name="scriptPubKeyType">The way to derive addresses from the accountKey</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey)">
            <summary>
            Sign all inputs which derive addresses from <paramref name="accountHDScriptPubKey"/> and that need to be signed by <paramref name="accountKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The address generator</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Sign all inputs which derive addresses from <paramref name="accountHDScriptPubKey"/> and that need to be signed by <paramref name="accountKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The address generator</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="accountKeyPath">The account key path (eg. [masterFP]/49'/0'/0')</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetFee(NBitcoin.Money@)">
            <summary>
            Returns the fee of the transaction being signed
            </summary>
            <param name="fee"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetFee">
            <summary>
            Returns the fee of the transaction being signed
            </summary>
            <returns>The fees</returns>
            <exception cref="T:System.InvalidOperationException">Not enough information to know about the fee</exception>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetEstimatedFeeRate(NBitcoin.FeeRate@)">
            <summary>
            Returns the fee rate of the transaction. If the PSBT is finalized, then the exact rate is returned, else an estimation is made.
            </summary>
            <param name="estimatedFeeRate"></param>
            <returns>True if could get the estimated fee rate</returns>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetVirtualSize(System.Int32@)">
            <summary>
            Returns the virtual transaction size of the transaction. If the PSBT is finalized, then the exact virtual size.
            </summary>
            <param name="vsize">The calculated virtual size</param>
            <returns>True if could get the virtual size could get estimated</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetEstimatedFeeRate">
            <summary>
            Returns the fee rate of the transaction. If the PSBT is finalized, then the exact rate is returned, else an estimation is made.
            </summary>
            <returns>The estimated fee</returns>
            <exception cref="T:System.InvalidOperationException">Not enough information to know about the fee rate</exception>
        </member>
        <member name="M:NBitcoin.PSBT.PrecomputeTransactionData">
            <summary>
            Returns a data structure precomputing some hash values that are needed for all inputs to be signed in the transaction.
            </summary>
            <returns>The PrecomputedTransactionData</returns>
            <exception cref="T:NBitcoin.PSBTException">Throw if the PSBT is missing some previous outputs.</exception>
        </member>
        <member name="M:NBitcoin.PSBT.ExtractTransaction">
            <summary>
            Extract the fully signed transaction from the PSBT
            </summary>
            <returns>The fully signed transaction</returns>
            <exception cref="T:System.InvalidOperationException">PSBTInputs are not all finalized</exception>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetFinalizedHash(NBitcoin.uint256@)">
            <summary>
            Get the expected hash once the transaction is fully signed
            </summary>
            <param name="hash">The hash once fully signed</param>
            <returns>True if we can know the expected hash. False if we can't (unsigned non-segwit).</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Clone">
            <summary>
            Clone this PSBT
            </summary>
            <returns>A cloned PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Clone(System.Boolean)">
            <summary>
            Clone this PSBT
            </summary>
            <param name="keepOriginalTransactionInformation">Whether the original scriptSig and witScript or inputs is saved</param>
            <returns>A cloned PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetBalance(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Get the balance change if you were signing this transaction.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>The balance change</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetBalance(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Get the balance change if you were signing this transaction.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>The balance change</returns>
        </member>
        <member name="M:NBitcoin.PSBT.CoinsFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the coins which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and derive
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>Inputs with HD keys matching masterFingerprint and account key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.HDKeysFor(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/>.
            </summary>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.IHDKey,NBitcoin.KeyPath[])">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="masterKey">The master key of the keypaths</param>
            <param name="paths">The path of the public keys</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.IHDKey,System.Tuple{NBitcoin.KeyPath,NBitcoin.Script}[])">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="masterKey">The master key of the keypaths</param>
            <param name="paths">The path of the public keys with their expected scriptPubKey</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.PubKey,NBitcoin.RootedKeyPath)">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="pubkey">The public key which need to sign</param>
            <param name="rootedKeyPath">The keypath to this public key</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.PubKey,NBitcoin.RootedKeyPath,NBitcoin.Script)">
            <summary>
            Add keypath information to this PSBT, if the PSBT all finalized this operation is a no-op
            </summary>
            <param name="pubkey">The public key which need to sign</param>
            <param name="rootedKeyPath">The keypath to this public key</param>
            <param name="scriptPubKey">A specific scriptPubKey this pubkey is involved with</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.RebaseKeyPaths(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Rebase the keypaths.
            If a PSBT updater only know the child HD public key but not the root one, another updater knowing the parent master key it is based on
            can rebase the paths. If the PSBT is all finalized this operation is a no-op
            </summary>
            <param name="accountKey">The current account key</param>
            <param name="newRoot">The KeyPath with the fingerprint of the new root key</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoin.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The accountHDScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="P:NBitcoin.PSBTHDKeyMatch.AddressKeyPath">
            <summary>
            KeyPath relative to the accountKey to PubKey
            </summary>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.CoinsFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the coins which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and derive
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>Inputs with HD keys matching masterFingerprint and account key</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output 
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.HDKeysFor(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/>.
            </summary>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.SetSequence(System.UInt16)">
            <summary>
            Changes the nSequence field of the corresponding TxIn.
            You should not call this method if any PSBTInput in the same PSBT has a signature.
            Because the siagnature usually commits to the old nSequence value.
            </summary>
            <exception cref="T:System.InvalidOperationException">When at least one signature exists in any other inputs in the PSBT</exception>
        </member>
        <member name="M:NBitcoin.PSBTInput.UpdateFrom(NBitcoin.PSBTInput)">
            <summary>
            Import informations contained by <paramref name="other"/> into this instance.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetPushItems(NBitcoin.Script)">
            <summary>
            conovert partial sigs to suitable form for ScriptSig (or Witness).
            This will preserve the ordering of redeem script even if it did not follow bip67.
            </summary>
            <param name="redeem"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.ClearForFinalize">
            <summary>
            Delete superflous information from a finalized input.
            This will not clear utxos since tx extractor might want to check the validity
            </summary>
            <exception cref="T:System.InvalidOperationException">The input need to be finalized</exception>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetSignableCoin">
            <summary>
            Represent this input as a coin that can be used for signing operations.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/>, <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> are not set
            or if <see cref="P:NBitcoin.PSBTCoin.WitnessScript"/> or <see cref="P:NBitcoin.PSBTCoin.RedeemScript"/> are missing but needed.
            </summary>
            <returns>The input as a signable coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetSignableCoin(System.String@)">
            <summary>
            Represent this input as a coin that can be used for signing operations.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/>, <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> are not set
            or if <see cref="P:NBitcoin.PSBTCoin.WitnessScript"/> or <see cref="P:NBitcoin.PSBTCoin.RedeemScript"/> are missing but needed.
            </summary>
            <param name="error">If it is not possible to retrieve the signable coin, a human readable reason.</param>
            <returns>The input as a signable coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.TrySlimUTXO">
            <summary>
            Check if this satisfies criteria for witness. if it does, delete non_witness_utxo
            This is useful for following reasons.
            1. It will make a data smaller which is an obviously good thing.
            2. Future HW Wallet may not support non segwit tx and thus won't recognize non_witness_utxo
            3. To pass test in BIP174
            </summary>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetCoin">
            <summary>
            Represent this input as a coin.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/> or <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> is not set.
            </summary>
            <returns>The input as a coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTOutput.UpdateFrom(NBitcoin.PSBTOutput)">
            <summary>
            Import informations contained by <paramref name="other"/> into this instance.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:NBitcoin.BitcoinExtKey">
            <summary>
            Base58 representation of an ExtKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(NBitcoin.ExtKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.IsValid">
            <summary>
            Gets whether the data is the correct expected length.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ExtKey">
            <summary>
            Gets the extended key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponing to the private key 
            of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.Neuter">
            <summary>
            Gets the Base58 representation, in the same network, of the neutered extended key.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.PrivateKey">
            <summary>
            Gets the private key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.op_Implicit(NBitcoin.BitcoinExtKey)~NBitcoin.ExtKey">
            <summary>
            Implicit cast from BitcoinExtKey to ExtKey.
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinExtPubKey">
            <summary>
            Base58 representation of an ExtPubKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended public key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended public key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ExtPubKey">
            <summary>
            Gets the extended public key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.op_Implicit(NBitcoin.BitcoinExtPubKey)~NBitcoin.ExtPubKey">
            <summary>
            Implicit cast from BitcoinExtPubKey to ExtPubKey.
            </summary>
        </member>
        <member name="T:NBitcoin.ExtKey">
            <summary>
            A private Hierarchical Deterministic key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Parse(System.String,NBitcoin.Network)">
            <summary>
            Parses the Base58 data (checking the network if specified), checks it represents the
            correct type of item, and then returns the corresponding ExtKey.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Depth">
            <summary>
            Gets the depth of this extended key from the root key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Child">
            <summary>
            Gets the child number of this key (in reference to the parent).
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.BitcoinExtPubKey,NBitcoin.BitcoinSecret)">
            <summary>
            Constructor. Reconstructs an extended key from the Base58 representations of 
            the public key and corresponding private key.  
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Key)">
            <summary>
            Constructor. Creates an extended key from the public key and corresponding private key.  
            </summary>
            <remarks>
            <para>
            The ExtPubKey has the relevant values for child number, depth, chain code, and fingerprint.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[],System.Byte,NBitcoin.HDFingerprint,System.UInt32)">
            <summary>
            Constructor. Creates an extended key from the private key, and specified values for
            chain code, depth, fingerprint, and child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[])">
            <summary>
            Constructor. Creates an extended key from the private key, with the specified value
            for chain code. Depth, fingerprint, and child number, will have their default values.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor">
            <summary>
            Constructor. Creates a new extended key with a random 64 byte seed.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes, from the given hex string.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.PrivateKey">
            <summary>
            Get the private key of this extended key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Neuter">
            <summary>
            Create the public key from this key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.UInt32)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.Int32,System.Boolean)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number, 
            setting the high bit if hardened is specified.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(NBitcoin.KeyPath)">
            <summary>
            Derives a new extended key in the hierarchy at the given path below the current key,
            by deriving the specified child at each step.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetWif(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, within the specified network.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.ToString(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, as a string, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponding to the private key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.IsHardened">
            <summary>
            Gets whether or not this extended key is a hardened child.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetParentExtKey(NBitcoin.ExtPubKey)">
            <summary>
            Recreates the private key of the parent from the private key of the child 
            combinated with the public key of the parent (hardened children cannot be
            used to recreate the parent).
            </summary>
        </member>
        <member name="T:NBitcoin.ExtPubKey">
            <summary>
            A public HD key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.Byte[])">
            <summary>
            Constructor. Creates a new extended public key from the specified extended public key bytes.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new extended public key from the specified extended public key bytes.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended public key from the specified extended public key bytes, from the given hex string.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtPubKey.ScriptPubKey">
            <summary>
            The P2PKH payment script
            </summary>
        </member>
        <member name="T:NBitcoin.KeyPath">
            <summary>
            Represent a path in the hierarchy of HD keys (BIP32)
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.Parse(System.String)">
            <summary>
            Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.KeyPath.TryParse(System.String,NBitcoin.KeyPath@)">
            <summary>
            Try Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <param name="keyPath">The successfully parsed Key path</param>
            <returns>True if the string is parsed successfully; otherwise false</returns>
        </member>
        <member name="P:NBitcoin.KeyPath.IsHardened">
            <summary>
            True if the last index in the path is hardened
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.GetAddressKeyPath">
            <summary>
            Returns the longest non-hardened keypath to the leaf.
            For example, if the keypath is "49'/0'/0'/1/23", then the address key path is "1/23"
            </summary>
            <returns>Return the address key path</returns>
        </member>
        <member name="M:NBitcoin.KeyPath.GetAccountKeyPath">
            <summary>
            Returns the longest hardened keypath from the root.
            For example, if the keypath is "49'/0'/0'/1/23", then the account key path is "49'/0'/0'"
            </summary>
            <returns>Return the account key path</returns>
        </member>
        <member name="P:NBitcoin.KeyPath.IsHardenedPath">
            <summary>
            True if at least one index in the path is hardened
            </summary>
        </member>
        <member name="T:NBitcoin.RootedKeyPath">
            <summary>
            KeyPath with the fingerprint of the root it should derive from
            </summary>
        </member>
        <member name="M:NBitcoin.RootedKeyPath.GetAccountKeyPath">
            <summary>
            Returns the longest hardened keypath from the root.
            For example, if the keypath is "49'/0'/0'/1/23", then the account key path is "49'/0'/0'"
            </summary>
            <returns>Return the account key path</returns>
        </member>
        <member name="M:NBitcoin.RootedKeyPath.ToStringWithEmptyKeyPathAware">
            <summary>
            Mostly works same with `ToString()`, but if the `KeyPath` is empty, it just returns master finger print
            without `/` in the suffix
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecretEC.HashAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecret.GetKey(System.String)">
            <summary>
            Get the decrypted private key
            </summary>
            <param name="password">The password</param>
            <returns>The decrypted key</returns>
            <exception cref="T:System.Security.SecurityException">Invalid password</exception>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecret.TryGetKey(System.String,NBitcoin.Key@)">
            <summary>
            Get the decrypted private key
            </summary>
            <param name="password">The password</param>
            <param name="key">The decrypted key if successfull</param>
            <returns>True if successfull</returns>
        </member>
        <member name="T:NBitcoin.Mnemonic">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I  Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:NBitcoin.Mnemonic.#ctor(NBitcoin.Wordlist,System.Byte[])">
            <summary>
            Generate a mnemonic
            </summary>
            <param name="wordList"></param>
            <param name="entropy"></param>
        </member>
        <member name="M:NBitcoin.Wordlist.#ctor(System.String[],System.Char,System.String)">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:NBitcoin.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:NBitcoin.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:NBitcoin.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
        <member name="F:NBitcoin.BIP9DeploymentsParameters.AlwaysActive">
            <summary>Special flag for timeout to indicate always active.</summary>
        </member>
        <member name="T:NBitcoin.BitcoinScriptAddress">
            <summary>
            Base58 representation of a script hash
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinAddress">
            <summary>
            Base58 representation of a bitcoin address
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinAddress.Create(System.String,NBitcoin.Network)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="str">The string to parse</param>
            <param name="expectedNetwork">The expected network to which it belongs</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="T:NBitcoin.BitcoinPubKeyAddress">
            <summary>
            Base58 representation of a pubkey hash and base class for the representation of a script hash
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinStream.ConsensusFactory">
            <summary>
            Set the format to use when serializing and deserializing consensus related types.
            </summary>
        </member>
        <member name="T:NBitcoin.BlockHeader">
            <summary>
            Nodes collect new transactions into a block, hash them into a hash tree,
            and scan through nonce values to make the block's hash satisfy proof-of-work
            requirements.  When they solve the proof-of-work, they broadcast the block
            to everyone and the block is added to the block chain.  The first transaction
            in the block is a special one that creates a new coin owned by the creator
            of the block.
            </summary>
        </member>
        <member name="M:NBitcoin.BlockHeader.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the block header hash so that later calls to GetHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="network">Network</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="network">Network</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.Block.GetCoinbaseHeight">
            <summary>
            Get the coinbase height as specified by the first tx input of this block (BIP 34)
            </summary>
            <returns>Null if block has been created before BIP34 got enforced, else, the height</returns>
        </member>
        <member name="M:NBitcoin.Block.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a block with the specified option only. (useful for stripping data from a block)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new block with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Block.Check">
            <summary>
            Check proof of work and merkle root
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.BlockLocator">
            <summary>
            Compact representation of one's chain position which can be used to find forks with another chain
            </summary>
        </member>
        <member name="T:NBitcoin.BloomFilter">
            <summary>
            Used by SPV client, represent the set of interesting addresses tracked by SPV client with plausible deniability
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier.On(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor(NBitcoin.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor(NBitcoin.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Init(NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(NBitcoin.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher,NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(NBitcoin.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator,System.Boolean)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.#ctor(NBitcoin.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ExtEuclid(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Round(NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Tau(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,NBitcoin.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.SetPreCompInfo(NBitcoin.BouncyCastle.Math.EC.ECPoint,System.String,NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.NormalizeAll(NBitcoin.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.NormalizeAll(NBitcoin.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadradicEquation(NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the quadratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.X">
            Normalizes this point, and then returns the affine x-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.Y">
            Normalizes this point, and then returns the affine y-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPointBase.Multiply(NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Joye's double-add algorithm.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement,NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[],NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(NBitcoin.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeros as necessary given the size of n.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IMemoable.Reset(NBitcoin.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NBitcoin.BuilderExtensions.BuilderExtension">
            <summary>
            Base extension class to derive from for extending the TransactionBuilder
            </summary>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(NBitcoin.ChainBase)">
            <summary>
            Returns the first common block between two chains
            </summary>
            <param name="chain">The other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(System.Collections.Generic.IEnumerable{NBitcoin.uint256})">
            <summary>
            Returns the first found block
            </summary>
            <param name="hashes">Hash to search for</param>
            <returns>First found block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.ChainedBlock">
            <summary>
            A BlockHeader chained with all its ancestors
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripCachedData">
            <summary>
            Free up some memory (cached HashBlock and ChainWork) at the price of efficiency
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripHeader">
            <summary>
            Strip the Header to free up memory
            </summary>
        </member>
        <member name="P:NBitcoin.ChainedBlock.HasHeader">
            <summary>
            Returns true if this ChainedBlock has the underlying header
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.TryGetHeader(NBitcoin.BlockHeader@)">
            <summary>
            Get the BlockHeader
            </summary>
            <param name="header">The block header</param>
            <returns>True if this ChainedBlock has block header</returns>
        </member>
        <member name="P:NBitcoin.ChainedBlock.Header">
            <summary>
            Get the underlying block header, throws if the Header is not present.
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.GetChainWork(System.Boolean)">
            <summary>
            Get the value of the chain work
            </summary>
            <param name="cacheResult">If true, called GetChainWork on this block and future block will be faster, but this trade for space</param>
            <returns>The chain work value</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Network)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="network">The network being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Consensus)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="consensus">The consensus being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.FindFork(NBitcoin.ChainedBlock)">
            <summary>
            Find first common block between two chains
            </summary>
            <param name="block">The tip of the other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ICoin.GetScriptCode">
            <summary>
            Returns the script actually signed and executed
            </summary>
            <exception cref="T:System.InvalidOperationException">Additional information needed to get the ScriptCode</exception>
            <returns>The executed script</returns>
        </member>
        <member name="T:NBitcoin.ScriptCoin">
            <summary>
            Represent a coin which need a redeem script to be spent (P2SH or P2WSH)
            </summary>
        </member>
        <member name="M:NBitcoin.ScriptCoin.GetP2SHRedeem">
            <summary>
            Get the P2SH redeem script
            </summary>
            <returns>The P2SH redeem script or null if this coin is not P2SH.</returns>
        </member>
        <member name="M:NBitcoin.ScriptCoin.GetRedeemHash(NBitcoin.Script)">
            <summary>
            Returns the hash contained in the scriptPubKey (P2SH or P2WSH)
            </summary>
            <param name="scriptPubKey">The scriptPubKey</param>
            <returns>The hash of the scriptPubkey</returns>
        </member>
        <member name="P:NBitcoin.CompactSignature.RecoveryId">
            <summary>
            
            </summary>
        </member>
        <member name="P:NBitcoin.CompactSignature.Signature">
            <summary>
            The signature of 64 bytes
            </summary>
        </member>
        <member name="T:NBitcoin.ConcurrentChain">
            <summary>
            Thread safe class representing a chain of headers from genesis
            </summary>
        </member>
        <member name="M:NBitcoin.ConcurrentChain.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.Crypto.Pbkdf2">
             <summary>
             Implements the PBKDF2 key derivation function.
             </summary>
             
             <example>
             <code title="Computing a Derived Key">
             using System.Security.Cryptography;
             using CryptSharp.Utility;
             
             // Compute a 128-byte derived key using HMAC-SHA256, 1000 iterations, and a given key and salt.
             byte[] derivedKey = Pbkdf2.ComputeDerivedKey(new HMACSHA256(key), salt, 1000, 128);
             </code>
             <code title="Creating a Derived Key Stream">
             using System.IO;
             using System.Security.Cryptography;
             using CryptSharp.Utility;
            
             // Create a stream using HMAC-SHA512, 1000 iterations, and a given key and salt.
             Stream derivedKeyStream = new Pbkdf2(new HMACSHA512(key), salt, 1000);
             </code>
             </example>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.#ctor(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32)">
            <summary>
            Creates a new PBKDF2 stream.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique PBKDF2 stream, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Int32)">
            <summary>
            Reads from the derived key stream.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>Bytes from the derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.ComputeDerivedKey(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique derived key, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Dispose(System.Boolean)">
            <summary>
            Closes the stream, clearing memory and disposing of the HMAC algorithm.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Flush">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.SetLength(System.Int64)">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanRead">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanSeek">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanWrite">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Length">
            <summary>
            The maximum number of bytes that can be derived is 2^32-1 times the HMAC size.
            </summary>
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Position">
            <summary>
            The position within the derived key stream.
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.Salsa20Core">
            <summary>
            Implements the Salsa20 hash function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Salsa20Core.Compute(System.Int32,System.UInt32[],System.Int32,System.UInt32[],System.Int32)">
            <summary>
            Applies the Salsa20 hash function.
            It maps a 16 element input to an output of the same size.
            </summary>
            <param name="rounds">The number of rounds. SCrypt uses 8.</param>
            <param name="input">The input buffer.</param>
            <param name="inputOffset">The offset into the input buffer.</param>
            <param name="output">The output buffer.</param>
            <param name="outputOffset">The offset into the output buffer.</param>
        </member>
        <member name="T:NBitcoin.Crypto.SCrypt">
            <summary>
            Implements the SCrypt key derivation function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.ComputeDerivedKey(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetEffectivePbkdf2Salt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            The SCrypt algorithm creates a salt which it then uses as a one-iteration
            PBKDF2 key stream with SHA256 HMAC. This method lets you retrieve this intermediate salt.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The effective salt.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetStream(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a derived key stream from which a derived key can be read.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique scrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.ToDER">
            What we get back from the signer are the two components of a signature, r and s. To get a flat byte stream
            of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
            components into a structure.
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.HashStream">
            <summary>
            Double SHA256 hash stream
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.BufferedHashStream">
            <summary>
            Unoptimized hash stream, bufferize all the data
            </summary>
        </member>
        <member name="M:NBitcoin.DataEncoders.Base58CheckEncoder.IsMaybeEncoded(System.String)">
            <summary>
            Fast check if the string to know if base58 str
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.DataEncoders.Base58Encoder.IsMaybeEncoded(System.String)">
            <summary>
            Fast check if the string to know if base58 str
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:NBitcoin.FeeRate.FeePerK">
            <summary>
            Fee per KB
            </summary>
        </member>
        <member name="P:NBitcoin.FeeRate.SatoshiPerByte">
            <summary>
            Satoshi per Byte
            </summary>
        </member>
        <member name="M:NBitcoin.FeeRate.GetFee(System.Int32)">
            <summary>
            Get fee for the size
            </summary>
            <param name="virtualSize">Size in bytes</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.IDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.IAddressableDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey which can be represented as an address
            </summary>
        </member>
        <member name="T:NBitcoin.IHDScriptPubKey">
            <summary>
            A IHDScriptPubKey represent an object which represent a tree of scriptPubKeys
            </summary>
        </member>
        <member name="M:NBitcoin.IpExtensions.ToEndpointString(System.Net.EndPoint)">
            <summary>
            Return {host}:{port} of this endpoint.
            </summary>
            <param name="endpoint"></param>
            <returns>{host}:{port} representation of this endpoint</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.AsOnionDNSEndpoint(System.Net.EndPoint)">
            <summary>
            Convert an onion cat IPEndpoint to an onion DnsEndpoint
            If endpoint is already an onion DnsEndpoint, return it.
            Else returns null.
            </summary>
            <param name="endpoint"></param>
            <returns>An onion DNS endpoint or null</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.TryConvertToOnionDNSEndpoint(System.Net.EndPoint,System.Net.DnsEndPoint@)">
            <summary>
            Convert an onion cat IPEndpoint to an onion DnsEndpoint
            If endpoint is already an onion DnsEndpoint, return it.
            If the endpoint is not an onion endpoint v2, return false.
            </summary>
            <param name="endpoint">The tor endpoint</param>
            <param name="dnsEndpoint">The onion dns enpoint</param>
            <returns>True if the onioncat address has been successfully parsed as a dns onion address</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.AsOnionCatIPEndpoint(System.Net.EndPoint)">
            <summary>
            Convert an onion DNS endpoint to an onioncat IpEndpoint
            If endpoint is already an onioncat IPEndpoint, return it.
            Else returns null.
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.ResolveToIPEndpointsAsync(System.Net.EndPoint)">
            <summary>
            <para>Will properly convert <paramref name="endpoint"/> to IPEndpoint
            If <paramref name="endpoint"/> is a DNSEndpoint is an onion host (Tor v2), it will be converted into onioncat address
            else, a DNS resolution will be made and all resolved addresses will be returned</para>
            <para>If <paramref name="endpoint"/> is a IPEndpoint, it will be returned as-is.</para>
            You can pass any endpoint parsed by <see cref="M:NBitcoin.Utils.ParseEndpoint(System.String,System.Int32)"/>
            </summary>
            <param name="endpoint">The endpoint to convert to IPEndpoint</param>
            <exception cref="T:System.ArgumentNullException">The endpoint is null</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error is encountered when resolving the dns name.</exception>
            <exception cref="T:System.NotSupportedException">The endpoint passed can't be converted into an Ip (eg. An onion host which is not TorV2)</exception>
        </member>
        <member name="M:NBitcoin.IpExtensions.ResolveToIPEndpointsAsync(System.Net.EndPoint,NBitcoin.Protocol.IDnsResolver,System.Threading.CancellationToken)">
            <summary>
            <para>Will properly convert <paramref name="endpoint"/> to IPEndpoint
            If <paramref name="endpoint"/> is a DNSEndpoint is an onion host (Tor v2), it will be converted into onioncat address
            else, a DNS resolution will be made and all resolved addresses will be returned</para>
            <para>If <paramref name="endpoint"/> is a IPEndpoint, it will be returned as-is.</para>
            You can pass any endpoint parsed by <see cref="M:NBitcoin.Utils.ParseEndpoint(System.String,System.Int32)"/>
            </summary>
            <param name="endpoint">The endpoint to convert to IPEndpoint</param>
            <param name="dnsResolver">The DNS Resolver</param>
            <param name="cancellationToken">The cancellation token</param>
            <exception cref="T:System.ArgumentNullException">The endpoint is null</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error is encountered when resolving the dns name.</exception>
            <exception cref="T:System.NotSupportedException">The endpoint passed can't be converted into an Ip (eg. An onion host which is not TorV2)</exception>
        </member>
        <member name="T:NBitcoin.ITransactionRepository">
            <summary>
            Represent a transaction map
            </summary>
        </member>
        <member name="M:NBitcoin.Key.GetWif(NBitcoin.Network)">
            <summary>
            Same as GetBitcoinSecret
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.WitScriptId._HashForLookUp">
            <summary>
            When we store internal ScriptId -> Script lookup, having another
            WitScriptId -> WitScript KVMap will complicate implementation. And require
            More space because WitScriptId is bigger than ScriptId. But if we use Hash160 as ID,
            It will cause a problem in case of p2sh-p2wsh because we must hold two scripts
            (witness program and witness script) with one ScriptId. So instead we use single-RIPEMD160
            This is the same way with how bitcoin core handles scripts internally.
            </summary>
        </member>
        <member name="T:NBitcoin.Logging.NullLogger">
            <summary>
            Minimalistic logger that does nothing.
            </summary>
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.BeginScope``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc />
        </member>
        <member name="T:NBitcoin.Logging.NullScope">
            <summary>
            An empty scope without any logic
            </summary>
        </member>
        <member name="M:NBitcoin.Logging.NullScope.Dispose">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.MoneyBag.GetAmount(NBitcoin.OpenAsset.AssetId)">
            <summary>
            Get the Money corresponding to the input assetId
            </summary>
            <param name="assetId">The asset id, if null, will assume bitcoin amount</param>
            <returns>Never returns null, either the AssetMoney or Money if assetId is null</returns>
        </member>
        <member name="M:NBitcoin.MoneyBag.Split(System.Int32)">
            <summary>
            Split the MoneyBag in several one, without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.TryParse(System.String,NBitcoin.Money@)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <param name="nRet"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Parse(System.String)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.ToUnit(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToDecimal)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToDecimal(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToUnit)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <param name="fplus">True if show + for a positive amount</param>
            <param name="trimExcessZero">True if trim excess zeros</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,NBitcoin.Money)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="dust">more or less amount</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,System.Decimal)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="margin">error margin (between 0 and 1)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Network.GetDefaultDataFolder(System.String)">
            <summary>
            Returns the default data directory of bitcoin correctly accross OS
            </summary>
            <param name="folderName">The name of the folder</param>
            <returns>The full path to the data directory of Bitcoin</returns>
        </member>
        <member name="M:NBitcoin.Network.CreateBitcoinAddress(System.String)">
            <summary>
            Create a bitcoin address from base58 data, return a BitcoinAddress or BitcoinScriptAddress
            </summary>
            <param name="base58">base58 address</param>
            <exception cref="T:System.FormatException">Invalid base58 address</exception>
            <returns>BitcoinScriptAddress, BitcoinAddress</returns>
        </member>
        <member name="M:NBitcoin.Network.GetNetwork(System.String)">
            <summary>
            Get network from name
            </summary>
            <param name="name">main,mainnet,testnet,test,testnet3,reg,regtest,sig,signet</param>
            <returns>The network or null of the name does not match any network</returns>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP34">
            <summary>
            Height in coinbase
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP65">
            <summary>
            Height in OP_CLTV
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP66">
            <summary>
            Strict DER signature
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.CoinType">
            <summary>
            Specify the BIP44 coin type for this network
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.LitecoinWorkCalculation">
            <summary>
            Specify using litecoin calculation for difficulty
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkBuilder.BuildAndRegister">
            <summary>
            Create an immutable Network instance, and register it globally so it is queriable through Network.GetNetwork(string name) and Network.GetNetworks().
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.NetworkStringParser">
            <summary>
            This class provide a hook for additional string format in altcoin network
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkStringParser.TryParse``1(System.String,NBitcoin.Network,``0@)">
            <summary>
            Try to parse a string
            </summary>
            <param name="str">The string to parse</param>
            <param name="result">The result</param>
            <returns>True if it was possible to parse the string</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.AssetId">
            <summary>
            A unique Id for an asset
            </summary>
        </member>
        <member name="P:NBitcoin.OpenAsset.AssetMoney.Id">
            <summary>
            AssetId of the current amount
            </summary>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.BitcoinAssetId">
            <summary>
            Base58 representation of an asset id
            </summary>
        </member>
        <member name="T:NBitcoin.OpenAsset.NullColoredTransactionRepository">
            <summary>
            A colored transaction repository which does not save ColoredTransaction
            </summary>
        </member>
        <member name="M:NBitcoin.PartialMerkleTree.Trim(NBitcoin.uint256[])">
            <summary>
            Remove superfluous branches
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Payment.BitcoinUrlBuilder">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
            </summary>
        </member>
        <member name="M:NBitcoin.Policy.ITransactionPolicy.Check(NBitcoin.Transaction,NBitcoin.ICoin[])">
            <summary>
            Check if the given transaction violate the policy
            </summary>
            <param name="transaction">The transaction</param>
            <param name="spentCoins">The previous coins</param>
            <returns>Policy errors</returns>
        </member>
        <member name="T:NBitcoin.Policy.NotEnoughFundsPolicyError">
            <summary>
            Error when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.NotEnoughFundsPolicyError.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.MaxTxFee">
            <summary>
            Safety check, if the FeeRate exceed this value, a policy error is raised
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.CheckScriptPubKey">
            <summary>
            Check the standardness of scriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.PrecomputedTransactionData">
            <summary>
            A data structure precomputing some hash values that are needed for all inputs to be signed in the transaction.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddressManager">
            <summary>
            The AddressManager, keep a set of peers discovered on the network in cache can update their actual states.
            Replicate AddressManager of Bitcoin Core, the Buckets and BucketPosition are not guaranteed to be coherent with Bitcoin Core
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.AddAsync(System.Net.EndPoint,System.Net.IPAddress)">
            <summary>
            Will properly convert a endpoint to IPEndpoint
            If endpoint is a DNSEndpoint, a DNS resolution will be made and all addresses added
            If endpoint is a DNSEndpoint for onion, it will be converted into onioncat address
            If endpoint is an IPEndpoint it is added to AddressManager
            </summary>
            <param name="endpoint">The endpoint to add to the address manager</param>
            <param name="source">The source which advertized this endpoint (default: IPAddress.Loopback)</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.AddAsync(System.Net.EndPoint,System.Net.IPAddress,System.Threading.CancellationToken)">
            <summary>
            Will properly convert a endpoint to IPEndpoint
            If endpoint is a DNSEndpoint, a DNS resolution will be made and all addresses added
            If endpoint is a DNSEndpoint for onion, it will be converted into onioncat address
            If endpoint is an IPEndpoint it is added to AddressManager
            </summary>
            <param name="endpoint">The endpoint to add to the address manager</param>
            <param name="source">The source which advertized this endpoint (default: IPAddress.Loopback)</param>
            <param name="cancellationToken">The cancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.Select">
            <summary>
            Choose an address to connect to.
            </summary>
            <returns>The network address of a peer, or null if none are found</returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.GetAddr">
            <summary>
            Return a bunch of addresses, selected at random.
            </summary>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.None">
            <summary>
            Do not advertise or discover new peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Advertize">
            <summary>
            Only advertise known peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Discover">
            <summary>
            Only discover peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.AdvertizeDiscover">
            <summary>
            Advertise known peer and discover peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.AddressManagerBehavior">
            <summary>
            The AddressManagerBehavior class will respond to getaddr and register advertised nodes from addr messages to the AddressManager.
            The AddressManagerBehavior will also receive feedback about connection attempt and success of discovered peers to the AddressManager, so it can be used later to find valid peer faster.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.AddressManagerBehavior.PeersToDiscover">
            <summary>
            The minimum number of peers to discover before trying to connect to a node using the AddressManager (Default: 1000)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Broadcast a transaction on the hub
            </summary>
            <param name="transaction">The transaction to broadcast</param>
            <returns>The cause of the rejection or null</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.BroadcastHub.ManualBroadcast">
            <summary>
            If true, the user need to call BroadcastTransactions to ask to the nodes to broadcast it
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactions">
            <summary>
            Ask the nodes in the hub to broadcast transactions in the Hub manually
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.ChainBehavior">
            <summary>
            The Chain Behavior is responsible for keeping a ConcurrentChain up to date with the peer, it also responds to getheaders messages.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.StripHeader">
            <summary>
            If true, the Chain maintained by the behavior with have its ChainedBlock with no Header (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.SkipPoWCheck">
            <summary>
            If true, skip PoW checks (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanSync">
            <summary>
            Keep the chain in Sync (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanRespondToGetHeaders">
            <summary>
            Respond to getheaders messages (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.Synching">
            <summary>
            Using for test, this might not be reliable
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.CheckAnnouncedBlocks">
            <summary>
            Check if any past blocks announced by this peer is in the invalid blocks list, and set InvalidHeaderReceived flag accordingly
            </summary>
            <returns>True if no invalid block is received</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.AutoSync">
            <summary>
            Sync the chain as headers come from the network (Default : true)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.TrySync">
            <summary>
            Asynchronously try to sync the chain
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.State.HighestValidatedPoW">
            <summary>
            ChainBehaviors sharing this state will not broadcast headers which are above HighestValidatedPoW
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.NodesGroupBehavior">
            <summary>
            Maintain connection to a given set of nodes
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.PingPongBehavior">
            <summary>
            The PingPongBehavior is responsible for firing ping message every PingInterval and responding with pong message, and close the connection if the Ping has not been completed after TimeoutInterval.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.Mode">
            <summary>
            Whether the behavior send Ping and respond with Pong (Default : Both)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.TimeoutInterval">
            <summary>
            Interval after which an unresponded Ping will result in a disconnection. (Default : 20 minutes)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.PingInterval">
            <summary>
            Interval after which a Ping message is fired after the last received Pong (Default : 2 minutes)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.PingPongBehavior.Probe">
            <summary>
            Send a ping asynchronously
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.SlimChainBehavior">
            <summary>
            Behavior to keep a SlimChain in sync with the remote node
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.SocksEndpoint">
            <summary>
            If the socks endpoint to connect to
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.OnlyForOnionHosts">
            <summary>
            If the socks proxy is only used for Tor traffic (default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.NetworkCredential">
            <summary>
            Credentials to connect to the SOCKS proxy (Use StreamIsolation instead if you want Tor isolation)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.StreamIsolation">
            <summary>
            Randomize the NetworkCredentials to the Socks proxy
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Connectors.DefaultEndpointConnector.AllowOnlyTorEndpoints">
            <summary>
            Connect to only hidden service nodes over Tor.
            Prevents connecting to clearnet nodes over Tor.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.DnsSocksResolver.NetworkCredential">
            <summary>
            Credentials to connect to the SOCKS proxy (Use StreamIsolation instead if you want Tor isolation)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.DnsSocksResolver.StreamIsolation">
            <summary>
            Randomize the NetworkCredentials to the Socks proxy
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Filters.INodeFilter">
            <summary>
            A NodeFilter can intercept messages received and sent.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnReceivingMessage(NBitcoin.Protocol.IncomingMessage,System.Action)">
            <summary>
            Intercept a message before it can be processed by listeners
            </summary>
            <param name="message">The message</param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnSendingMessage(NBitcoin.Protocol.Node,NBitcoin.Protocol.Payload,System.Action)">
            <summary>
            Intercept a message before it is sent to the peer
            </summary>
            <param name="node"></param>
            <param name="payload"></param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="F:NBitcoin.Protocol.Message._SkipMagic">
            <summary>
            When parsing, maybe Magic is already parsed
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Unroutable">
            Addresses from these networks are not publicly routable on the global Internet.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Onion">
            TOR (v2 or v3)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.I2P">
            I2P
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Cjdns">
            CJDNS
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.AddrV2Format">
            see: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Unroutable">
            Addresses from these networks are not publicly routable on the global Internet.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Onion">
            TOR (v2 or v3)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.I2P">
            I2P
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Cjdns">
            CJDNS
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_IPV4_SIZE">
            Size of IPv4 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_IPV6_SIZE">
            Size of IPv6 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_TORV2_SIZE">
            Size of TORv2 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_TORV3_SIZE">
            Size of TORv3 address (in bytes). This is the length of just the address
            as used in BIP155, without the checksum and the version byte.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_I2P_SIZE">
            Size of I2P address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_CJDNS_SIZE">
            Size of CJDNS address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV3_ADDR_CHECKSUM_LEN">
            Size of the TORv3 address checksum (in bytes)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV3_ADDR_VERSION_LEN">
            Size of the TORv3 address version number (in bytes)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.IPV4_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded IPv4 address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV2_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded TORv2 address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
            Such dummy IPv6 addresses are guaranteed to not be publicly routable as they
            fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.INTERNAL_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded "internal" address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
            The prefix comes from 0xFD + SHA256("bitcoin")[0:5].
            Such dummy IPv6 addresses are guaranteed to not be publicly routable as they
            fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.HashStop">
            <summary>
            Location until which synchronization should be stopped (default: null)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.SkipPoWCheck">
            <summary>
            Skip PoW check
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.StripHeaders">
            <summary>
            Strip headers from the retrieved chain
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.AddressManager,NBitcoin.Protocol.NodeConnectionParameters,System.Net.EndPoint[])">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="addrman">The addrman used for finding peers</param>
            <param name="parameters">The parameters used by the found node</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters,System.Net.EndPoint[],System.Func{System.Net.EndPoint,System.Byte[]})">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="parameters">The parameters used by the found node, use AddressManagerBehavior.GetAddrman for finding peers</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <param name="getGroup">Group selector, by default NBicoin.IpExtensions.GetGroup</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.ConnectToLocal(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters)">
            <summary>
            Connect to the node of this machine
            </summary>
            <param name="network"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessageAsync(NBitcoin.Protocol.Payload)">
            <summary>
            Send a message to the peer asynchronously
            </summary>
            <param name="payload">The payload to send</param>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected</param>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessage(NBitcoin.Protocol.Payload,System.Threading.CancellationToken)">
            <summary>
            Send a message to the peer synchronously
            </summary>
            <param name="payload">The payload to send</param>
            <exception cref="T:System.ArgumentNullException">Payload is null</exception>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected, or the cancellation token has been set to canceled</param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Version">
            <summary>
            The negociated protocol version (minimum of supported version between MyVersion and the PeerVersion)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Advertize">
            <summary>
            Send addr unsolicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.RespondToHandShake(System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="cancellation"></param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.PreferredTransactionOptions">
            <summary>
            Transaction options we would like
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.SupportedTransactionOptions">
            <summary>
            Transaction options supported by the peer
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.PreferAddressV2">
            <summary>
            Transaction options supported by the peer
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.ActualTransactionOptions">
            <summary>
            Transaction options we prefer and which is also supported by peer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="options">The synchronization chain options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetSlimChain(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the chain of block hashes from the peer (thread safe)
            </summary>
            <param name="hashStop">Location until which synchronization should be stopped (default: null)</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="hashStop">The highest block wanted</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="options">The synchronisation options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="hashStop">The location until which it synchronize</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeSlimChain(NBitcoin.SlimChain,NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given SlimChain to the tip of this node if its height is higher.
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="hashStop">The location until which it synchronize</param>
            <param name="cancellationToken"></param>
            <returns>Task which finish when complete</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.CreateListener">
            <summary>
            Create a listener that will queue messages until disposed
            </summary>
            <returns>The listener</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if used on the listener's thread, as it would result in a deadlock</exception>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Transactions in the mempool</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(NBitcoin.uint256[],System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool by ids
            </summary>
            <param name="txIds">Transaction ids to retrieve</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>The transactions, if a transaction is not found, then it is not returned in the array.</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.AddSupportedOptions(NBitcoin.Protocol.InventoryType)">
            <summary>
            Add supported option to the input inventory type
            </summary>
            <param name="inventoryType">Inventory type (like MSG_TX)</param>
            <returns>Inventory type with options (MSG_TX | MSG_WITNESS_FLAG)</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.PingPong(System.Threading.CancellationToken)">
            <summary>
            Emit a ping and wait the pong
            </summary>
            <param name="cancellation"></param>
            <returns>Latency</returns>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.Advertize">
            <summary>
            Send addr unsolicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.IsRelay">
            <summary>
            If true, the node will receive all incoming transactions if no bloomfilter are set
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeServer.InboundNodeConnectionParameters">
            <summary>
            The parameters that will be cloned and applied for each node connecting to the NodeServer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Connect">
            <summary>
            Start connecting asynchronously to remote peers
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Disconnect">
            <summary>
            Drop connection to all connected nodes
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Purge(System.String)">
            <summary>
            Asynchronously create a new set of nodes
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.MaximumNodeConnection">
            <summary>
            The number of node that this behavior will try to maintain online (Default : 8)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.AllowSameGroup">
            <summary>
            If false, the search process will do its best to connect to Node in different network group to prevent sybil attacks. (Default : false)
            If CustomGroupSelector is set, AllowSameGroup is ignored.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.CustomGroupSelector">
            <summary>
            How to calculate a group of an ip, by default using NBitcoin.IpExtensions.GetGroup.
            Overrides AllowSameGroup.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Dispose">
            <summary>
            Same as Disconnect
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddrPayload">
            <summary>
            An available peer address in the bitcoin network is announced (unsolicited or after a getaddr)
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddrV2Payload">
            <summary>
            An available peer address in the bitcoin network is announced (unsolicited or after a getaddrv2)
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.BlockPayload">
            <summary>
            A block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.CompactFilterPayload">
            <summary>
            Represents the p2p message payload used for sharing a block's compact filter.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.FilterBytes">
            <summary>
            Gets the serialized compact filter for this block.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.BlockHash">
            <summary>
            Gets block hash of the Bitcoin block for which the filter is being returned.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.FilterLoadPayload">
            <summary>
            Load a bloomfilter in the peer, used by SPV clients
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetAddrPayload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetBlocksPayload">
            <summary>
            Ask for the block hashes (inv) that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.CompactFiltersQueryPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter/headers.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.StartHeight">
            <summary>
            Gets the height of the first block in the requested range.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.StopHash">
            <summary>
            Gets the hash of the last block in the requested range.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetCompactFiltersPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetCompactFilterHeadersPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter headers.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.GetCompactFilterCheckPointPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.GetCompactFilterCheckPointPayload.StopHash">
            <summary>
            Gets the hash of the last block in the requested range.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetDataPayload">
            <summary>
            Ask for transaction, block or merkle block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetHeadersPayload">
            <summary>
            Ask block headers that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.HeadersPayload">
            <summary>
            Block headers received after a getheaders messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.InvPayload">
            <summary>
            Announce the hash of a transaction or block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MempoolPayload">
            <summary>
            Ask for the mempool, followed by inv messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MerkleBlockPayload">
            <summary>
            A merkle block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.NotFoundPayload">
            <summary>
            A getdata message for an asked hash is not found by the remote peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.SendAddrV2Payload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.TxPayload">
            <summary>
            Represents a transaction being sent on the network, is sent after being requested by a getdata (of Transaction or MerkleBlock) message.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.Network">
            <summary>
            NODE_NETWORK means that the node is capable of serving the block chain. It is currently
            set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want
            network services but don't provide them.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.GetUTXO">
            <summary>
             NODE_GETUTXO means the node is capable of responding to the getutxo protocol request.
            Bitcoin Core does not support this but a patch set called Bitcoin XT does.
            See BIP 64 for details on how this is implemented.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_BLOOM">
            <summary> NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections.
            Bitcoin Core nodes used to support this by default, without advertising this bit,
            but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_WITNESS">
            <summary> Indicates that a node can be asked for blocks and transactions including
            witness data. 
            </summary> 
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_NETWORK_LIMITED">
            <summary> NODE_NETWORK_LIMITED means the same as NODE_NETWORK with the limitation of only
            serving the last 288 (2 day) blocks
            See BIP159 for details on how this is implemented.
            </summary> 
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.ReceiveTimeout">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.SendTimeout">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.SendTimeout"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.ReceiveBufferSize">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.ReceiveBufferSize"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.SendBufferSize">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.SendBufferSize"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.PeerTooOld">
            <summary>
            Disconnect from peers older than this protocol version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportTimeAddress">
            <summary>
            nTime field added to CAddress, starting with this version;
            if possible, avoid requesting addresses nodes older than this
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportPingPong">
            <summary>
            BIP 0031, pong message, is enabled for all versions AFTER this one
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportMempoolQuery">
            <summary>
            "mempool" command, enhanced "getdata" behavior starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportNodeBloom">
            <summary>
            ! "filter*" commands are disabled without NODE_BLOOM after and including this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportSendHeaders">
            <summary>
            ! "sendheaders" command and announcing blocks with headers starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportWitness">
            <summary>
            ! Version after which witness support potentially exists
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCompactBlocks">
            <summary>
            short-id-based block download starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCheckSum">
            <summary>
            Support checksum at p2p message level
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.Legacy">
            <summary>
            Derive P2PKH addresses (P2PKH)
            Only use this for legacy code or coins not supporting segwit
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.Segwit">
            <summary>
            Derive Segwit (Bech32) addresses (P2WPKH)
            This will result in the cheapest fees. This is the recommended choice.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.SegwitP2SH">
            <summary>
            Derive P2SH address of a Segwit address (P2WPKH-P2SH)
            Use this when you worry that your users do not support Bech address format.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.TaprootBIP86">
            <summary>
            Derive the taproot address of this pubkey following BIP86. This public key is used as the internal key, the output key is computed without script path. (The tweak is SHA256(internal_key))
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.String)">
            <summary>
            Create a new Public key from string
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[])">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
        </member>
        <member name="M:NBitcoin.PubKey.SanityCheck(System.Byte[])">
            <summary>
            Quick sanity check on public key format. (size + first byte)
            </summary>
            <param name="data">bytes array</param>
        </member>
        <member name="M:NBitcoin.PubKey.GetSharedPubkey(NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared pubkey</returns>
        </member>
        <member name="T:NBitcoin.RPC.GetBlockVerbosity">
            <summary>
            Verbosity option you can pass to `GetBlock` rpc call.
            If you want a raw block without metadata, (i.e. `0` verbosity for the rpc call) you should just call the method
            without this option.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.GetBlockVerbosity.WithOnlyTxId">
            <summary>
            Verbosity `1` for the rpc call. Block itself will not be included in response if you specify this.
            However, txids in the block will be included in `TxIds` field in the response anyway.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.GetBlockVerbosity.WithFullTx">
            <summary>
            Verbosity `2` for the rpc call. Use this if you want *both* full block and its metadata.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetBlockRPCResponse.NextBlockHash">
            <summary>
             This field exists only when the block is not on the tip.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetBlockRPCResponse.Block">
            <summary>
            This field exists only when you specified `WithFullTx` verbosity
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.BestBlock">
            <summary>
            the block hash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.Confirmations">
            <summary>
            The number of confirmations
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.IsCoinBase">
            <summary>
            Coinbase or not
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.ScriptPubKeyType">
            <summary>
            The type, eg pubkeyhash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.ScriptPubKeyObject.IsAddress">
             <summary>
             Returns true if Address property is populated AND ScriptPubKey is not. If Address and ScriptPubKey are populated, ScriptPubKey takes precedence.
             </summary>
            
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.Timestamp">
            <summary>
            Creation time of the key, keep null if this address has just been generated
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.ImportMultiScriptPubKeyConverter">
            <summary>
            Custom JsonConverter to deal with loose type of scriptPubKey property in the ImportMulti method
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MinimumAmount">
            <summary>
            Minimum value of each UTXO
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MaximumAmount">
            <summary>
            Maximum value of each UTXO
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MaximumCount">
            <summary>
            Maximum number of UTXOs
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MinimumSumAmount">
            <summary>
            Minimum sum value of all UTXOs
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RestClient">
            <summary>
            Client class for the unauthenticated REST Interface
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RestClient.Network">
            <summary>
            Gets the <see cref="P:NBitcoin.RPC.RestClient.Network"/> instance for the client.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri,NBitcoin.Network)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <param name="network">The network to operate with</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransactionAsync(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransaction(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeadersAsync(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeaders(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetChainInfoAsync">
            <summary>
            Gets the chain information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetUnspentOutputsAsync(System.Collections.Generic.IEnumerable{NBitcoin.OutPoint},System.Boolean)">
            <summary>
            Gets unspect outputs.
            </summary>
            <param name="outPoints">The out points identifiers (TxIn-N).</param>
            <param name="checkMempool">if set to <c>true</c> [check mempool].</param>
            <returns>The unspent transaction outputs (UTXO) for the given outPoints.</returns>
            <exception cref="T:System.ArgumentNullException">outPoints cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(NBitcoin.Network)">
            <summary>
            Use default bitcoin parameters to configure a RPCClient.
            </summary>
            <param name="network">The network used by the node. Must not be null.</param>
        </member>
        <member name="P:NBitcoin.RPC.RPCClient.Capabilities">
            <summary>
            The RPC Capabilities of this RPCClient instance, this property will be set by a call to ScanRPCCapabilitiesAsync
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ScanRPCCapabilitiesAsync(System.Threading.CancellationToken)">
            <summary>
            Run several RPC function to scan the RPC capabilities, then set RPCClient.Capabilities
            </summary>
            <returns>The RPCCapabilities</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ScanRPCCapabilities">
            <summary>
            Run several RPC function to scan the RPC capabilities, then set RPCClient.RPCCapabilities
            </summary>
            <returns>The RPCCapabilities</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.String,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password, the content of the .cookie file, or cookiefile=pathToCookieFile</param>
            <param name="hostOrUri"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.Uri,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password or the content of the .cookie file or null to auto configure</param>
            <param name="address"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatch">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.CancelBatch">
            <summary>
            Cancel all commands
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.Uptime">
            <summary>
            Returns the total uptime of the server.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.UptimeAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the total uptime of the server.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetStatusScanTxoutSetAsync(System.Threading.CancellationToken)">
            <summary>
            Get the progress report (in %) of the current scan
            </summary>
            <returns>The progress in %</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetStatusScanTxoutSet">
            <summary>
            Get the progress report (in %) of the current scan
            </summary>
            <returns>The progress in %</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbortScanTxoutSetAsync(System.Threading.CancellationToken)">
            <summary>
            Aborting the current scan
            </summary>
            <returns>Returns true when abort was successful</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbortScanTxoutSet">
            <summary>
            Aborting the current scan
            </summary>
            <returns>Returns true when abort was successful</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatchAsync(System.Threading.CancellationToken)">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCClient.AllowBatchFallback">
             <summary>
             Since bitcoin core 0.20, if a RPC batch request is made, and one of the request fails due
             to permission issue (whitelisting feature), the whole RPC Batch would fail, throwing a
             HttpRequestException.
            
             If we set AllowBatchFallback to true, we will fallback by sending all requests in the batch
             one by one.
             However, only use this for idempotent operations.
             When a batch operation fails because of permission issue, some of the requests in the batch
             may nevertheless have succeed without Bitcoin Core giving a clue about which one.
             </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockFilter(NBitcoin.uint256)">
            <summary>
            Retrieve a BIP 157 content filter for a particular block.
            </summary>
            <param name="blockHash">The hash of the block.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockFilterAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Retrieve a BIP 157 content filter for a particular block.
            </summary>
            <param name="blockHash">The hash of the block.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOut(NBitcoin.uint256,System.Int32,System.Boolean)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOutAsync(NBitcoin.uint256,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxoutSetInfo">
            <summary>
            Returns statistics about the unspent transaction output (UTXO) set
            </summary>
            <returns>Parsed object containing all info</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTransactions(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            GetTransactions only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="blockHash"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetRawTransaction(NBitcoin.uint256,System.Boolean)">
            <summary>
            getrawtransaction only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">The Fee rate couldn't be estimated because of insufficient data from Bitcoin Core</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">when fee couldn't be estimated</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeImplAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14)
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.BitcoinAddress,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.BitcoinAddress,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.Script,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.Script,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.Script,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="scriptPubKey">The scriptPubKey where the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.Script,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="scriptPubKey">The scriptPubKey where the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.BitcoinAddress,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.BitcoinAddress,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlock(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AddPeerAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Add the address of a potential peer to the address manager. This RPC is for testing only.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AddPeerAddressAsync(System.Net.IPAddress,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Add the address of a potential peer to the address manager. This RPC is for testing only.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetAddressInfo(NBitcoin.IDestination)">
            <summary>
            throws an error if an address is not from the wallet.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before
            it is counted towards the balance. Transactions generated by this node are counted immediately.
            Typically, externally-generated transactions are payments to this wallet and transactions
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions.
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before
            it is counted towards the balance. Transactions generated by this node are counted immediately.
            Typically, externally-generated transactions are payments to this wallet and transactions
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions.
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ImportMultiAsync(NBitcoin.RPC.ImportMultiAddress[],System.Boolean,NBitcoin.ISigningRepository,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
             <param name="addresses"></param>
             <param name="rescan"></param>
             <param name="signingRepository">If you specify this, This method tries to serialize OutputDescriptor with the private key (If there is any entry in the repository).</param>
             <returns></returns>
             <exception cref="T:NBitcoin.RPC.RPCException"></exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet.
            </summary>
            <remarks>
            <para>
            Note: as of Bitcoin Core 0.10.0, outputs affecting watch-only addresses will be returned;
            see the spendable field in the results.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync(NBitcoin.RPC.ListUnspentOptions,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            with query_options and the list of addresses to include.
            </summary>
            <param name="options">
            MinimumAmount - Minimum value of each UTXO
            MaximumAmount - Maximum value of each UTXO
            MaximumCount - Maximum number of UTXOs
            MinimumSumAmount - Minimum sum value of all UTXOs
            </param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransaction(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransactionAsync(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphrase(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphraseAsync(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransaction(NBitcoin.Transaction)">
            <summary>
            Sign a transaction, if RPCClient.Capabilities is set, will call SignRawTransactionWithWallet if available
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Sign a transaction, if RPCClient.Capabilities is set, will call SignRawTransactionWithWallet if available
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithKey(NBitcoin.RPC.SignRawTransactionWithKeyRequest)">
            <summary>
            Sign a transaction
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithKeyAsync(NBitcoin.RPC.SignRawTransactionWithKeyRequest,System.Threading.CancellationToken)">
            <summary>
            Sign a transaction
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithWallet(NBitcoin.RPC.SignRawTransactionRequest)">
            <summary>
            Sign a transaction with wallet keys
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithWalletAsync(NBitcoin.RPC.SignRawTransactionRequest,System.Threading.CancellationToken)">
            <summary>
            Sign a transaction with wallet keys
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.TransactionId">
            <summary>
            The transaction id (must be in mempool.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.VirtualSizeBytes">
            <summary>
            Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Time">
            <summary>
            Local time transaction entered pool in seconds since 1 Jan 1970 GMT.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Height">
            <summary>
            Block height when transaction entered pool.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantCount">
            <summary>
            Number of in-mempool descendant transactions (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantVirtualSizeBytes">
            <summary>
            Virtual transaction size of in-mempool descendants (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorCount">
            <summary>
            Number of in-mempool ancestor transactions (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorVirtualSizeBytes">
            <summary>
            Virtual transaction size of in-mempool ancestors (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.TransactionIdWithWitness">
            <summary>
            Hash of serialized transaction, including witness data.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.BaseFee">
            <summary>
            Transaction fee.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.ModifiedFee">
            <summary>
            Transaction fee with fee deltas used for mining priority.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorFees">
            <summary>
            Modified fees (see above) of in-mempool ancestors (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantFees">
            <summary>
            Modified fees (see above) of in-mempool descendants (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Depends">
            <summary>
            Unconfirmed transactions used as inputs for this transaction.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.SpentBy">
            <summary>
            Unconfirmed transactions spending outputs from this transaction.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.Comment">
            <summary>
            A locally-stored (not broadcast) comment assigned to this transaction. Default is no comment.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.CommentTo">
            <summary>
            A locally-stored (not broadcast) comment assigned to this transaction. Meant to be used for describing who the payment was sent to. Default is no comment.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.SubstractFeeFromAmount">
            <summary>
            The fee will be deducted from the amount being sent. The recipient will receive less bitcoins than you enter in the amount field. Default is false.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.Replaceable">
            <summary>
            Allow this transaction to be replaced by a transaction with higher fees. 
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.ConfTarget">
            <summary>
            Confirmation target in blocks
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.EstimateMode">
            <summary>
            The fee estimate mode
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.FeeRate">
            <summary>
            Specify a fee rate in sat/vB.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UseDefault">
            <summary>
            Use default connection settings of the chain
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.WalletName">
            <summary>
            Name of the wallet in multi wallet mode
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.CookieFile">
            <summary>
            Path to cookie file
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UserPassword">
            <summary>
            Username and password
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RPCErrorCode">
            <summary>
            RPC error code thrown by the <see cref="T:NBitcoin.RPC.RPCClient"/>
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_REQUEST">
            <summary>
            RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
            It should not be used for application-layer errors. 
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_NOT_FOUND">
            <summary>
            RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
            It should not be used for application-layer errors.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INTERNAL_ERROR">
            <summary>
            RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
            (for example datadir corruption).
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_MISC_ERROR">
            <summary>
            std::exception thrown in command handling
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_FORBIDDEN_BY_SAFE_MODE">
            <summary>
            Server is in safe mode, and command is not allowed in safe mode
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_TYPE_ERROR">
            <summary>
            Unexpected type was passed as parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_ADDRESS_OR_KEY">
            <summary>
            Invalid address or key
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_OUT_OF_MEMORY">
            <summary>
            Ran out of memory during operation
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_PARAMETER">
            <summary>
            Invalid, missing or duplicate parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DATABASE_ERROR">
            <summary>
            Database error
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DESERIALIZATION_ERROR">
            <summary>
            Error parsing or validating structure in raw format
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ERROR">
            <summary>
            General error during transaction or block submission
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_REJECTED">
            <summary>
            Transaction or block was rejected by network rules
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ALREADY_IN_CHAIN">
            <summary>
            Transaction already in chain
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_IN_WARMUP">
            <summary>
            Client still warming up
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_DEPRECATED">
            <summary>
            RPC method is deprecated
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NOT_CONNECTED">
            <summary>
            Bitcoin is not connected
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_IN_INITIAL_DOWNLOAD">
            <summary>
            Still downloading initial blocks
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_ALREADY_ADDED">
            <summary>
            Node is already added
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_ADDED">
            <summary>
            Node has not been added before
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_CONNECTED">
            <summary>
            Node to disconnect not found in connected nodes
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_INVALID_IP_OR_SUBNET">
            <summary>
            Invalid IP/Subnet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_P2P_DISABLED">
            <summary>
            No valid connection manager instance found
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ERROR">
            <summary>
            Unspecified problem with wallet (key not found etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INSUFFICIENT_FUNDS">
            <summary>
            Not enough funds in wallet or account
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INVALID_ACCOUNT_NAME">
            <summary>
            Invalid account name
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_KEYPOOL_RAN_OUT">
            <summary>
            Keypool ran out, call keypoolrefill first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_UNLOCK_NEEDED">
            <summary>
            Enter the wallet passphrase with walletpassphrase first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_PASSPHRASE_INCORRECT">
            <summary>
            The wallet passphrase entered was incorrect
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_WRONG_ENC_STATE">
            <summary>
            Command given in wrong wallet encryption state (encrypting an encrypted wallet etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ENCRYPTION_FAILED">
            <summary>
            Failed to encrypt the wallet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ALREADY_UNLOCKED">
            <summary>
            Wallet is already unlocked
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_FOUND">
            <summary>
            Invalid wallet specified
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_SPECIFIED">
            <summary>
            No wallet specified (error when there are multiple wallets loaded)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ScanTxoutDescriptor.Begin">
            <summary>
            The range of HD chain indexes to explore
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ScanTxoutDescriptor.End">
            <summary>
            The range of HD chain indexes to explore
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.PrevTx.RedeemScript">
            <summary>
            Redeem script (required for P2SH or P2WSH)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.PreviousTransactions">
            <summary>
            An json array of previous dependent transaction outputs
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.Transaction">
            <summary>
            The transaction to sign
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.SigHash">
            <summary>
            The signature hash type
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionWithKeyRequest.PrivateKeys">
            <summary>
            A json array of base58-encoded private keys for signing
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.ScriptError.OutPoint">
            <summary>
            The outpoint referenced
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.SignedTransaction">
            <summary>
            The raw transaction with signature
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.Complete">
            <summary>
            If the transaction has a complete set of signatures
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.Errors">
            <summary>
            Script verification errors (if there are any)
            </summary>
        </member>
        <member name="T:NBitcoin.ScriptVerify">
            <summary>
            Script verification flags
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.P2SH">
            <summary>
            Evaluate P2SH subscripts (softfork safe, BIP16).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.StrictEnc">
            <summary>
            Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
            Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
            +
            skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DerSig">
            <summary>
            Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.LowS">
            <summary>
            Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
            (softfork safe, BIP62 rule 5).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullDummy">
            <summary>
            verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.SigPushOnly">
            <summary>
            Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalData">
            <summary>
            Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
            pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
            any other push causes the script to fail (BIP62 rule 3).
            In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
            (softfork safe)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableNops">
             <summary>
             Discourage use of NOPs reserved for upgrades (NOP1-10)
            
             Provided so that nodes can avoid accepting or mining transactions
             containing executed NOP's whose meaning may change after a soft-fork,
             thus rendering the script invalid; with this flag set executing
             discouraged NOPs fails the script. This verification flag will never be
             a mandatory flag applied to scripts in a block. NOPs that are not
             executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CleanStack">
            <summary>
            Require that only a single stack element remains after evaluation. This changes the success criterion from
            "At least one stack element must remain, and when interpreted as a boolean, it must be true" to
            "Exactly one stack element must remain, and when interpreted as a boolean, it must be true".
            (softfork safe, BIP62 rule 6)
            Note: CLEANSTACK should never be used without P2SH.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckLockTimeVerify">
             <summary>
             Verify CHECKLOCKTIMEVERIFY
            
             See BIP65 for details.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckSequenceVerify">
            <summary>
            See BIP68 for details.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Witness">
            <summary>
            Support segregated witness
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableWitnessProgram">
            <summary>
            Making v2-v16 witness program non-standard
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalIf">
            <summary>
            Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullFail">
            <summary>
            Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.WitnessPubkeyType">
            <summary>
            Public keys in segregated witness scripts must be compressed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.ForkId">
            <summary>
            Some altcoins like BCash and BGold requires ForkId inside the sigHash
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NBitcoin.ScriptVerify.Taproot" -->
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableTaprootVersion">
            <summary>
            Making unknown Taproot leaf versions non-standard
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Mandatory">
             <summary>
             Mandatory script verification flags that all new blocks must comply with for
             them to be valid. (but old blocks may not comply with) Currently just P2SH,
             but in the future other flags may be added, such as a soft-fork to enforce
             strict DER encoding.
            
             Failing one of these tests may trigger a DoS ban - see CheckInputs() for
             details.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Standard">
            <summary>
            Standard script verification flags that standard transactions will comply
            with. However scripts violating these flags may still be present in valid
            blocks and we must accept those blocks.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Consensus">
            <summary>
            Strict consensus script verification flags that are checked by the Bitcoin Core
            consensus library before validating the transaction.
            </summary>
        </member>
        <member name="T:NBitcoin.SigHash">
            <summary>
            Signature hash types/flags
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.TaprootSigHash">
            <summary>
            Signature hash types/flags for taproot transactions
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.OpcodeType">
            <summary>
            Script opcodes
            </summary>
        </member>
        <member name="F:NBitcoin.HashVersion.Taproot">
            <summary>
            Key spend
            </summary>
        </member>
        <member name="F:NBitcoin.HashVersion.Tapscript">
            <summary>
            Script spend
            </summary>
        </member>
        <member name="M:NBitcoin.Script.ExtractScriptCode(System.Int32)">
            <summary>
            Extract the ScriptCode delimited by the codeSeparatorIndex th OP_CODESEPARATOR.
            </summary>
            <param name="codeSeparatorIndex">Index of the OP_CODESEPARATOR, or -1 for fetching the whole script</param>
            <returns></returns>
        </member>
        <member name="P:NBitcoin.Script.PaymentScript">
            <summary>
            Get the P2SH scriptPubKey of this script
            </summary>
        </member>
        <member name="M:NBitcoin.Script.GetSignerAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH or P2PKH address from scriptSig
            </summary>
            <param name="network">The network</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetSigner">
            <summary>
            Extract P2SH or P2PKH id from scriptSig
            </summary>
            <returns>The network</returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH/P2PKH/P2WSH/P2WPKH/P2TR address from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestination">
            <summary>
            Extract P2SH/P2PKH/P2WSH/P2WPKH/P2TR id from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationPublicKeys">
            <summary>
            Extract public keys if this script is a multi sig or pay to pub key scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.VerifyScriptConsensus(System.Byte[],System.UInt32,System.Byte[],System.UInt32,System.UInt32,NBitcoin.ScriptVerify,NBitcoin.Script.BitcoinConsensusError@)">
            Returns 1 if the input nIn of the serialized transaction pointed to by
            txTo correctly spends the scriptPubKey pointed to by scriptPubKey under
            the additional constraints specified by flags.
            If not NULL, err will contain an error/success code for the operation
        </member>
        <member name="M:NBitcoin.ScriptEvaluationContext.CScriptNum.#ctor(System.Int64)">
            Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
            The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
            but results may overflow (and are valid as long as they are not used in a subsequent
            numeric operation). CScriptNum enforces those semantics by storing results as
            an int64 and allowing out-of-range values to be returned as a vector of bytes but
            throwing an exception if arithmetic is done or the result is interpreted as an integer.
        </member>
        <member name="T:NBitcoin.ContextStack`1">
            <summary>
            ContextStack is used internally by the bitcoin script evaluator. This class contains
            operations not typically available in a "pure" Stack class, as example:
            Insert, Swap, Erase and Top (Peek w/index)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> class.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor(NBitcoin.ContextStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/>
            base on another stack. This is for copy/clone.
            </summary>
            <param name="stack">The stack.</param>
        </member>
        <member name="P:NBitcoin.ContextStack`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Push(`0)">
            <summary>
            Pushes the specified item on the stack.
            </summary>
            <param name="item">The item to by pushed.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Pop">
            <summary>
            Pops this element in top of the stack.
            </summary>
            <returns>The element in top of the stack</returns>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Clear(System.Int32)">
            <summary>
            Pops as many items as specified.
            </summary>
            <param name="n">The number of items to be poped</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Cannot remove more elements</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Top(System.Int32)">
            <summary>
            Returns the i-th element from the top of the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <returns>the i-th element from the top of the stack</returns>
            <exception cref="T:System.IndexOutOfRangeException">topIndex</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the specified i and j elements in the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <param name="j">The j-th index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            i or  j
            </exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item in the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32)">
            <summary>
            Removes the i-th item.
            </summary>
            <param name="from">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes items from the i-th position to the j-th position.
            </summary>
            <param name="from">The item position</param>
            <param name="to">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.AsInternalArray">
            <summary>
            Returns a copy of the internal array.
            </summary>
            <returns>A copy of the internal array</returns>
        </member>
        <member name="T:NBitcoin.ContextStack`1.Enumerator">
            <summary>
            Implements a reverse enumerator for the ContextStack
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.TryExpand(System.UInt32,NBitcoin.ISigningRepository,NBitcoin.ISigningRepository,System.Collections.Generic.List{NBitcoin.Script}@,System.Collections.Generic.IDictionary{System.UInt32,NBitcoin.ExtPubKey})">
            <summary>
            Expand descriptor into actual scriptPubKeys.
            </summary>
            <param name="pos">position index to expand</param>
            <param name="privateKeyProvider">provider to inject private keys in case of hardened derivation</param>
            <param name="repo">repository to which to put resulted information.</param>
            <param name="outputScripts">resulted scriptPubKey</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.TryExpand(System.UInt32,System.Func{NBitcoin.KeyId,NBitcoin.Key},NBitcoin.ISigningRepository,System.Collections.Generic.List{NBitcoin.Script}@,System.Collections.Generic.IDictionary{System.UInt32,NBitcoin.ExtPubKey})">
            <summary>
            Expand descriptor into actual scriptPubKeys.
            TODO: cache
            </summary>
            <param name="pos">position index to expand</param>
            <param name="privateKeyProvider">provider to inject private keys in case of hardened derivation</param>
            <param name="repo">repository to which to put resulted information.</param>
            <param name="outputScripts">resulted scriptPubKey</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.GetScriptPubKeyType">
            <summary>
            Infer the address type for that descriptor.
            When it is impossible, just return null.
            e.g. In case of descriptors those are agnostic to the actual scriptpubkey format (e.g. "multi"),
            it just returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Scripting.OutputDescriptor.CHECKSUM_CHARSET">
            The character set for the checksum itself (same as bech32). 
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.String(System.String)">
            <summary>
            Parse a string of characters.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Text(NBitcoin.Scripting.Parser.Parser{System.Char,System.Collections.Generic.IEnumerable{System.Char}})">
            <summary>
            Convert a stream of characters to a string.
            </summary>
            <param name="characters"></param>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Scripting.Parser.Parse.Number">
            <summary>
            Parse a number.
            </summary>
        </member>
        <member name="F:NBitcoin.Scripting.Parser.Parse.Decimal">
            <summary>
            Parse a decimal number with separator '.'.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XMany``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            Parse a stream of elements, failing if any element is only partially parsed.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T">The type of element to parse.</typeparam>
            <param name="parser">A parser that matches a single element.</param>
            <returns>A <see cref="T:NBitcoin.Scripting.Parser.Parser`1"/> that matches the sequence.</returns>
            <remarks>
            <para>
            Using <seealso cref="M:NBitcoin.Scripting.Parser.Parse.XMany``2(NBitcoin.Scripting.Parser.Parser{``0,``1})"/> may be preferable to <seealso cref="M:NBitcoin.Scripting.Parser.Parse.Many``2(NBitcoin.Scripting.Parser.Parser{``0,``1})"/>
            where the first character of each match identified by <paramref name="parser"/>
            is sufficient to determine whether the entire match should succeed. The X*
            methods typically give more helpful errors and are easier to debug than their
            unqualified counterparts.
            </para>
            </remarks>
            <seealso cref="M:NBitcoin.Scripting.Parser.Parse.XOr``2(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``1})"/>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.AtLeastOnce``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            TryParse a stream of elements with at least one item.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XAtLeastOnce``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            TryParse a stream of elements with at least one item. Except the first
            item, all other items will be matched with the <code>XMany</code> operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Return``2(``1)">
            <summary>
            Lift to a parser monad world
            </summary>
            <param name="v"></param>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Select``3(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,``2})">
            <summary>
            Take the result of parsing, and project it onto a different domain.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="convert"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Ref``2(System.Func{NBitcoin.Scripting.Parser.Parser{``0,``1}})">
            <summary>
            Refer to another parser indirectly. This allows circular compile-time dependency between parsers.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="reference"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XOr``2(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            Parse first, if it succeeds, return first, otherwise try second.
            Assumes that the first parsed character will determine the parser chosen (see Try).
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Concat``2(NBitcoin.Scripting.Parser.Parser{``0,System.Collections.Generic.IEnumerable{``1}},NBitcoin.Scripting.Parser.Parser{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Concatenate two streams of elements.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Return``3(NBitcoin.Scripting.Parser.Parser{``0,``1},``2)">
            <summary>
            Version of Return with simpler inline syntax.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Except``3(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``2})">
            <summary>
            Attempt parsing only if the <paramref name="except"/> parser fails.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="except"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Until``3(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``2})">
            <summary>
            Parse a sequence of items until a terminator is reached.
            Returns the sequence, discarding the terminator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="until"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Where``2(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Succeed if the parsed value matches predicate.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.SelectMany``4(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,NBitcoin.Scripting.Parser.Parser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Monadic combinator Then, adapted for Linq comprehension syntax.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser"></param>
            <param name="selector"></param>
            <param name="projector"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.ChainOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a left-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XChainOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a left-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.ChainRightOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a right-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XChainRightOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a right-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParserExtension.TryParse``1(NBitcoin.Scripting.Parser.Parser{System.Char,``0},System.String,NBitcoin.Network)">
            <summary>
            Tries to parse the input without throwing an exception.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParserExtension.Parse``1(NBitcoin.Scripting.Parser.Parser{System.Char,``0},System.String,NBitcoin.Network)">
            <summary>
            Parses the specified input string.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:NBitcoin.Scripting.Parser.ParsingException">It contains the details of the parsing error.</exception>
        </member>
        <member name="T:NBitcoin.Scripting.Parser.ParsingException">
            <summary>
            Represents an error that occurs during parsing.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message
            and the position where the error occured.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="position">The position where the error occured.</param>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, 
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="P:NBitcoin.Scripting.Parser.ParsingException.Position">
            <summary>
            Gets the position of the parsing failure if one is available; otherwise, null.
            </summary>
        </member>
        <member name="T:NBitcoin.Scripting.PubKeyProvider">
            <summary>
            Public key objects in descriptors.
            </summary>
        </member>
        <member name="T:NBitcoin.Scripting.PubKeyProvider.Origin">
            <summary>
            Wrapper for other pubkey provider which contains (parent key finger print + relative derivation path to inner Pubkey provider)
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.PubKeyProvider.TryGetPubKey(System.UInt32,System.Func{NBitcoin.KeyId,NBitcoin.Key},NBitcoin.RootedKeyPath@,NBitcoin.PubKey@)">
             <summary>
            
             </summary>
             <param name="pos"></param>
             <param name="privateKeyProvider">In case of the hardend derivation.
             You must give private key by this to derive child</param>
             <param name="keyOriginInfo"></param>
             <param name="pubkey"></param>
             <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NBitcoin.Scripting.PubKeyProvider.TryGetPrivateString(NBitcoin.ISigningRepository,System.String@)" -->
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_DISABLE_FLAG">
            <summary>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time and this flag
            is set, the relative lock-time has units of 512 seconds,
            otherwise it specifies blocks with a granularity of 1. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_MASK">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time, this mask is
            applied to extract that lock-time from the sequence field.
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_FINAL">
            <summary>
            Setting nSequence to this value for every input in a transaction
            disables nLockTime. */
            </summary>
            <remarks>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. Setting the most significant bit of a
            sequence number disabled relative lock-time.
            </remarks>
        </member>
        <member name="F:NBitcoin.Sequence.MAX_BIP125_RBF_SEQUENCE">
            <summary>
            Setting nSequence to this value on any input in a transaction
            to signal the transaction is replaceable. */
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_GRANULARITY">
            <summary>
            In order to use the same number of bits to encode roughly the
            same wall-clock duration, and because blocks are naturally
            limited to occur every 600s on average, the minimum granularity
            for time-based relative lock-time is fixed at 512 seconds.
            Converting from CTxIn::nSequence to seconds is performed by
            multiplying by 512 = 2^9, or equivalently shifting up by
            9 bits. 
            </summary>
        </member>
        <member name="T:NBitcoin.ISigningRepository">
            <summary>
            Interface for injecting security sensitive stuffs to other objects.
            This is equivalent to `SigningProvider` class in bitcoin core.
            Currently used in OutputDescriptor to safely inject private key information
            </summary>
        </member>
        <member name="M:NBitcoin.ISigningRepository.TryGetScript(NBitcoin.ScriptId,NBitcoin.Script@)">
            <summary>
            In case of Witness Script, use HashForLookup Property as a key.
            </summary>
            <param name="scriptId"></param>
            <param name="script"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ISigningRepository.SetScript(NBitcoin.ScriptId,NBitcoin.Script)">
            <summary>
            In case of Witness Script, use HashForLookup property as a key.
            </summary>
            <param name="scriptId"></param>
            <param name="script"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ISigningRepository.Merge(NBitcoin.ISigningRepository)">
            <summary>
            Consume the argument and take everything it holds.
            This method should at least support consuming `FlatSigningRepository`.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:NBitcoin.SlimChain">
            <summary>
            A thread safe, memory optimized chain of hashes representing the current chain
            </summary>
        </member>
        <member name="M:NBitcoin.SlimChain.TrySetTip(NBitcoin.uint256,NBitcoin.uint256,System.Boolean)">
            <summary>
            Set a new tip in the chain
            </summary>
            <param name="newTip">The new tip</param>
            <param name="previous">The block hash before the new tip</param>
            <param name="nopIfContainsTip">If true and the new tip is already included somewhere in the chain, do nothing</param>
            <returns>True if newTip is the new tip</returns>
        </member>
        <member name="M:NBitcoin.SlimChain.FindFork(NBitcoin.BlockLocator)">
            <summary>
            Returns the first found block
            </summary>
            <param name="hashes">Hash to search for</param>
            <returns>First found block or null</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script)">
            <summary>
            Extract the public key or null from the script, perform quick check on pubkey
            </summary>
            <param name="scriptPubKey"></param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script,System.Boolean)">
            <summary>
            Extract the public key or null from the script
            </summary>
            <param name="scriptPubKey"></param>
            <param name="deepCheck">Whether deep checks are done on public key</param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToWitScriptHashTemplate.ExtractWitScriptParameters(NBitcoin.WitScript,NBitcoin.WitScriptId)">
            <summary>
            Extract witness redeem from WitScript
            </summary>
            <param name="witScript">Witscript to extract information from</param>
            <param name="expectedScriptId">Expected redeem hash</param>
            <returns>The witness redeem</returns>
        </member>
        <member name="M:NBitcoin.WitProgramParameters.NeedWitnessRedeemScript">
            <summary>
            Check if this program represent P2WSH
            </summary>
            <returns>True if P2WSH</returns>
        </member>
        <member name="T:NBitcoin.Target">
            <summary>
            Represent the challenge that miners must solve for finding a new block
            </summary>
        </member>
        <member name="M:NBitcoin.OutPoint.TryParse(System.String,NBitcoin.OutPoint@)">
            <summary>
            Parse an outpoint with either the format:
            [txid]:[outputindex]
            [txid]-[outputindex]
            [txid][outputindex] where outputindex is in hexadecimal, 4 bytes in little endian (serialization format)
            </summary>
            <param name="str">The string to parse</param>
            <param name="result">The outpoint</param>
            <returns>True if parsing succeed</returns>
        </member>
        <member name="M:NBitcoin.OutPoint.Parse(System.String)">
            <summary>
            Parse an outpoint with either the format:
            [txid]:[outputindex]
            [txid]-[outputindex]
            [txid][outputindex] where txid is little endian and outputindex is in hexadecimal, 4 bytes in little endian (serialization format)
            </summary>
            <param name="str">The string to parse</param>
            <returns>The outpoint</returns>
        </member>
        <member name="M:NBitcoin.TxIn.GetSigner">
            <summary>
            Try to get the expected scriptPubKey of this TxIn based on its scriptSig and witScript.
            </summary>
            <returns>Null if could not infer the scriptPubKey, else, the expected scriptPubKey</returns>
        </member>
        <member name="P:NBitcoin.TxIn.WitScript">
            <summary>
            The witness script (Witness script is not serialized and deserialized at the TxIn level, but at the Transaction level)
            </summary>
        </member>
        <member name="P:NBitcoin.IndexedTxIn.Index">
            <summary>
            The index of this TxIn in its transaction
            </summary>
        </member>
        <member name="M:NBitcoin.TxInList.FindIndexedInput(NBitcoin.OutPoint)">
            <summary>
            Returns the IndexedTxIn whose PrevOut is equal to <paramref name="outpoint"/> or null.
            </summary>
            <param name="outpoint">The outpoint being searched for</param>
            <returns>The IndexedTxIn which PrevOut is equal to <paramref name="outpoint"/> or null if not found</returns>
        </member>
        <member name="M:NBitcoin.TxInList.FindIndexedInput(System.Int32)">
            <summary>
            Returns the IndexedTxIn at index.
            </summary>
            <param name="index">the index</param>
            <returns>A IndexedTxIn</returns>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Byte[][],System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
            <param name="unsafe">If false, make a copy of the input script array</param>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Collections.Generic.IEnumerable{System.Byte[]},System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
        </member>
        <member name="M:NBitcoin.Transaction.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the transaction hash and witness hash so that later calls to GetHash() and GetWitHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.Transaction.GetVirtualSize">
            <summary>
            Size of the transaction discounting the witness (Used for fee calculation)
            </summary>
            <returns>Transaction size</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.BitcoinSecret,NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.BitcoinSecret,System.Collections.Generic.IEnumerable{NBitcoin.ICoin})">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(System.Collections.Generic.IEnumerable{NBitcoin.BitcoinSecret},System.Collections.Generic.IEnumerable{NBitcoin.ICoin})">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.GetFee(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:NBitcoin.Transaction.GetFee(NBitcoin.TxOut[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentOutputs">Outputs being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:NBitcoin.Transaction.GetFeeRate(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee rate of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.VerifySequence">
            <summary>
            Interpret sequence numbers as relative lock-time constraints.
            </summary>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.MedianTimePast">
            <summary>
             Use GetMedianTimePast() instead of nTime for end point timestamp.
            </summary>
        </member>
        <member name="M:NBitcoin.Transaction.CheckSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.CalculateSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a transaction with the specified option only. (useful for stripping data from a transaction)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new transaction with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Check">
            <summary>
            Context free transaction check
            </summary>
            <returns>The error or success of the check</returns>
        </member>
        <member name="P:NBitcoin.SigningOptions.SigHash">
            <summary>
            What are we signing (default: SigHash.All)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.TaprootSigHash">
            <summary>
            What are we signing for taproot (default: SigHash.Default)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.EnforceLowR">
            <summary>
            Do we try to get shorter signatures? (default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.PrecomputedTransactionData">
            <summary>
            Providing the PrecomputedTransactionData speed up signing time, by pre computing one several hashes need
            for the calculation of the signatures of every input.
            
            For taproot transaction signing, the precomputed transaction data is required if some of the inputs does not
            belong to the signer.
            </summary>
        </member>
        <member name="T:NBitcoin.DefaultCoinSelector">
            <summary>
            Algorithm implemented by bitcoin core https://github.com/bitcoin/bitcoin/blob/3015e0bca6bc2cb8beb747873fdf7b80e74d679f/src/wallet.cpp#L1276
            Minimize the change
            </summary>
        </member>
        <member name="P:NBitcoin.DefaultCoinSelector.GroupByScriptPubKey">
            <summary>
            Select all coins belonging to same scriptPubKey together to protect privacy. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.DefaultCoinSelector.Iterations">
            <summary>
            Number of iterations in the knapsack algorithm (Default: 100)
            </summary>
        </member>
        <member name="T:NBitcoin.NotEnoughFundsException">
            <summary>
            Exception thrown when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Group">
            <summary>
            The group name who is missing the funds
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="T:NBitcoin.TransactionBuilder">
            <summary>
            A class for building and signing all sort of transactions easily (http://www.codeproject.com/Articles/835098/NBitcoin-Build-Them-All)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.LeftOverChange">
            <summary>
            Additional change that should be swept to change later
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.DustPreventionTotalRemoved">
            <summary>
            Total of output value that was removed via dust prevention mechanism
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.SentOutput">
            <summary>
            What is curently sent
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FeeTxOut">
            <summary>
            The fee txout (change or substracted output)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FeePaid">
            <summary>
            Whether fee are already paid
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FixedFee">
            <summary>
            Fixed fee of SendFee
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.MinFee">
            <summary>
            Dogecoin has weird requirement.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.SizeFee">
            <summary>
            Size fee is initially sent to 0 for the first pass.
            Then we can do a second pass with the right Size fee.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.MinValue">
            <summary>
            The minimum UTXO value to select
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleRandom">
            <summary>
            The random number generator used for shuffling transaction outputs or selected coins
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.DustPrevention">
            <summary>
            If true, it will remove any TxOut below Dust, so the transaction get correctly relayed by the network. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.OptInRBF">
            <summary>
            If true, it will signal the transaction replaceability in every input. (Default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleInputs">
            <summary>
            If true, the transaction builder tries to shuffle inputs
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleOutputs">
            <summary>
            If true, the transaction builder tries to shuffles outputs
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.MergeOutputs">
            <summary>
            If true and the transaction has two outputs sending to the same scriptPubKey, those will be merged into a single output. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins">
            <summary>
            If true, the TransactionBuilder will not select coins whose fee to spend is higher than its value. (Default: true)
            The cost of spending a coin is based on the <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate">
            <summary>
            If <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins"/> is true, this rate is used to know if an output is economical.
            This property is set automatically when calling <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)"/> or <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.CoinFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the coin for an input
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.KeyFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the key for a scriptPubKey
            </summary>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetGroupName(System.String)">
            <summary>
            Set the name of this group (group are separated by call to Then())
            </summary>
            <param name="groupName">Name of the group</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAll(NBitcoin.IDestination)">
            <summary>
            Send all coins added so far with no change (sweep), substracting fees from the total amount
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAll(NBitcoin.Script)">
            <summary>
            Send all coins added so far with no change (sweep), substracting fees from the total amount
            </summary>
            <param name="scriptPubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemaining(NBitcoin.IDestination)">
            <summary>
            Send all the remaining available coins to this destination
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemaining(NBitcoin.Script)">
            <summary>
            Send all the remaining available coins to this destination
            </summary>
            <param name="scriptPubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemainingToChange">
            <summary>
            Send all the remaining available coins to the change
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SubtractFees">
            <summary>
            Will subtract fees from the previous TxOut added by the last TransactionBuilder.Send() call
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetMoney)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetId,System.UInt64)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="assetId">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetTransactionPolicy(NBitcoin.Policy.StandardTransactionPolicy)">
            <summary>
            Set transaction policy fluently
            </summary>
            <param name="policy">The policy</param>
            <returns>this</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)">
            <summary>
            Split the estimated fees across the several groups (separated by Then())
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)">
            <summary>
            Estimate the fee needed for the transaction, and split among groups according to their fee weight
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendFeesSplit(NBitcoin.Money)">
            <summary>
            Send the fee splitted among groups according to their fee weight
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetFeeWeight(System.Decimal)">
            <summary>
            If using SendFeesSplit or SendEstimatedFeesSplit, determine the weight this group participate in paying the fees
            </summary>
            <param name="feeWeight">The weight of fee participation</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildPSBT(System.Boolean)">
            <summary>
            Build a PSBT (Partially signed bitcoin transaction)
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <param name="sigHash">The sighash for signing (ignored if sign is false)</param>
            <returns>A PSBT</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CreatePSBTFrom(NBitcoin.Transaction,System.Boolean)">
            <summary>
            Create a PSBT from a transaction
            </summary>
            <param name="tx">The transaction</param>
            <param name="sign">If true, the transaction builder will sign this transaction</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.ExtractSignatures(NBitcoin.PSBT,NBitcoin.Transaction)">
            <summary>
            Try to extract the signatures from <paramref name="transaction"/> into the <paramref name="psbt"/>.
            </summary>
            <param name="psbt">The PSBT to extract signatures to.</param>
            <param name="transaction">The transaction from which signatures will get extracted.</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.UpdatePSBT(NBitcoin.PSBT)">
            <summary>
            Update information in the PSBT with informations that the transaction builder is holding
            </summary>
            <param name="psbt">A PSBT</param>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SignTransactionInPlace(NBitcoin.Transaction)">
            <summary>
            Sign the transaction passed as parameter
            </summary>
            <param name="transaction">The transaction</param>
            <returns>The transaction object as the one passed as parameter</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFeeRate(NBitcoin.Transaction)">
            <summary>
            Estimate the fee rate of the transaction once it is fully signed.
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The fee rate, or null if the transaction builder is missing previous coins</returns>
            <exception cref="T:NBitcoin.CoinNotFoundException">If the transaction builder is missing some coins</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Money,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.FeeRate,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFee">The expected fee</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.FindSpentCoins(NBitcoin.Transaction)">
            <summary>
            Find spent coins of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <returns>Array of size tx.Input.Count, if a coin is not fund, a null coin is returned.</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction)">
            <summary>
            Estimate the physical size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction,System.Boolean)">
            <summary>
            Estimate the size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <param name="virtualSize">If true, returns the size on which fee calculation are based, else returns the physical byte size</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSizes(NBitcoin.Transaction,System.Int32@,System.Int32@)">
            <summary>
            Estimate the witness size and the base size of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <param name="witSize">The witness size</param>
            <param name="baseSize">The base size</param>
            <exception cref="T:NBitcoin.CoinNotFoundException">If the transaction builder is missing some coins</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.FeeRate)">
            <summary>
            Estimate fees of the built transaction
            </summary>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then">
            <summary>
            Create a new participant in the transaction with its own set of coins and keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then(System.String)">
            <summary>
            Switch to another participant in the transaction, or create a new one if it is not found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">Signature in bytes</param>
            <param name="scriptVerify">Verification rules</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify,NBitcoin.ScriptError@)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">The signature</param>
            <param name="scriptVerify">Verification rules</param>
            <param name="error">Error</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="M:NBitcoin.uint256.#ctor(System.String)">
            <summary>
            Create a uint256 from a string in big endian
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:NBitcoin.uint256.ToBytes(System.Byte[])">
            <summary>
            Write this instance to the output in little endian
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:NBitcoin.uint256.ToBytes(System.Byte[],System.Boolean)">
            <summary>
            Write this instance to the output
            </summary>
            <param name="output"></param>
            <param name="lendian"></param>
        </member>
        <member name="M:NBitcoin.Extensions.AsHDKeyCache(NBitcoin.IHDKey)">
            <summary>
            Deriving an HDKey is normally time consuming, this wrap the IHDKey in a new HD object which can cache derivations
            </summary>
            <param name="hdkey">The hdKey to wrap</param>
            <returns>An hdkey which cache derivations, of the parameter if it is already itself a cache</returns>
        </member>
        <member name="M:NBitcoin.Extensions.AsHDKeyCache(NBitcoin.IHDScriptPubKey)">
            <summary>
            Deriving an IHDScriptPubKey is normally time consuming, this wrap the IHDScriptPubKey in a new IHDScriptPubKey object which can cache derivations
            </summary>
            <param name="hdScriptPubKey">The hdScriptPubKey to wrap</param>
            <returns>An hdkey which cache derivations, of the parameter if it is already itself a cache</returns>
        </member>
        <member name="M:NBitcoin.Extensions.Derive(NBitcoin.IHDKey,NBitcoin.KeyPath[])">
            <summary>
            Derive keyPaths as fast as possible using caching and parallelism
            </summary>
            <param name="hdkey">The hdKey to derive</param>
            <param name="keyPaths">keyPaths to derive</param>
            <returns>An array of keyPaths.Length size with the derived keys</returns>
        </member>
        <member name="M:NBitcoin.Extensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a given DateTime into a Unix timestamp
            </summary>
            <param name="value">Any DateTime</param>
            <returns>The given DateTime in Unix timestamp format</returns>
        </member>
        <member name="M:NBitcoin.Extensions.UnixTimestamp(System.DateTime)">
            <summary>
            Gets a Unix timestamp representing the current moment
            </summary>
            <param name="ignored">Parameter ignored</param>
            <returns>Now expressed as a Unix timestamp</returns>
        </member>
        <member name="M:NBitcoin.ThreadSafeCollection`1.Add(`0)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="item"></param>
            <returns>When disposed, the item is removed</returns>
        </member>
        <member name="M:NBitcoin.ThreadSafeList`1.Add(`0)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="item"></param>
            <returns>When disposed, the item is removed</returns>
        </member>
    </members>
</doc>

'''
'''--- Lib/Toolblox.Ada.App.Model.deps.json ---
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v6.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v6.0": {
      "Toolblox.Ada.App.Model/1.0.0": {
        "dependencies": {
          "Dahomey.Json": "1.12.2",
          "Flurl.Http": "3.2.4",
          "Toolblox.Cryptography": "1.0.0",
          "Toolblox.Model": "1.0.0",
          "VCards": "1.0.0"
        },
        "runtime": {
          "Toolblox.Ada.App.Model.dll": {}
        }
      },
      "Dahomey.Json/1.12.2": {
        "dependencies": {
          "Dahomey.Json.Attributes": "1.0.1"
        },
        "runtime": {
          "lib/net6.0/Dahomey.Json.dll": {
            "assemblyVersion": "1.12.2.0",
            "fileVersion": "1.12.2.0"
          }
        }
      },
      "Dahomey.Json.Attributes/1.0.1": {
        "runtime": {
          "lib/net6.0/Dahomey.Json.Attributes.dll": {
            "assemblyVersion": "1.0.1.0",
            "fileVersion": "1.0.1.0"
          }
        }
      },
      "Flurl/3.0.6": {
        "runtime": {
          "lib/netstandard2.0/Flurl.dll": {
            "assemblyVersion": "3.0.6.0",
            "fileVersion": "3.0.6.0"
          }
        }
      },
      "Flurl.Http/3.2.4": {
        "dependencies": {
          "Flurl": "3.0.6",
          "Newtonsoft.Json": "12.0.2",
          "System.Text.Encoding.CodePages": "4.5.1"
        },
        "runtime": {
          "lib/netstandard2.0/Flurl.Http.dll": {
            "assemblyVersion": "3.2.4.0",
            "fileVersion": "3.2.4.0"
          }
        }
      },
      "Microsoft.Extensions.Configuration.Abstractions/6.0.0": {
        "dependencies": {
          "Microsoft.Extensions.Primitives": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.0/Microsoft.Extensions.Configuration.Abstractions.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "Microsoft.Extensions.Primitives/6.0.0": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/net6.0/Microsoft.Extensions.Primitives.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "Microsoft.NETCore.Platforms/2.1.2": {},
      "Newtonsoft.Json/12.0.2": {
        "runtime": {
          "lib/netstandard2.0/Newtonsoft.Json.dll": {
            "assemblyVersion": "12.0.0.0",
            "fileVersion": "12.0.2.23222"
          }
        }
      },
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {},
      "System.Text.Encoding.CodePages/4.5.1": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "2.1.2",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        }
      },
      "VCards/1.0.0": {
        "runtime": {
          "lib/net5.0/VCards.dll": {
            "assemblyVersion": "1.0.0.0",
            "fileVersion": "1.0.0.0"
          }
        }
      },
      "Toolblox.Cryptography/1.0.0": {
        "runtime": {
          "Toolblox.Cryptography.dll": {}
        }
      },
      "Toolblox.Model/1.0.0": {
        "dependencies": {
          "Dahomey.Json.Attributes": "1.0.1",
          "Microsoft.Extensions.Configuration.Abstractions": "6.0.0"
        },
        "runtime": {
          "Toolblox.Model.dll": {}
        }
      },
      "NBitcoin/7.0.17.0": {
        "runtime": {
          "NBitcoin.dll": {
            "assemblyVersion": "7.0.17.0",
            "fileVersion": "7.0.17.0"
          }
        }
      }
    }
  },
  "libraries": {
    "Toolblox.Ada.App.Model/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Dahomey.Json/1.12.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-lguY4WN14f6kQuKJTGX+nsTT0V31PWHa+jcPx86B/xmOBgm4FwdLKtymMFBKAE5yBDDKhO7iQIvFwQNHufWLRw==",
      "path": "dahomey.json/1.12.2",
      "hashPath": "dahomey.json.1.12.2.nupkg.sha512"
    },
    "Dahomey.Json.Attributes/1.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-5V73KuRVnyvyB8+BEkCvxpbI3MZpG6PQNdfKGxeKFBabotepbrnJ+Xz00P84BD4zdg7UPGybo9Nsl988Y8/tfw==",
      "path": "dahomey.json.attributes/1.0.1",
      "hashPath": "dahomey.json.attributes.1.0.1.nupkg.sha512"
    },
    "Flurl/3.0.6": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XMIlB/tJ4nTYF2+79xDsnnlgbXHpKyizKX2fffrECekI6pEsa9MSLzf5tPVMdLy4k4AcJPLs356Sa2Le5VRDCw==",
      "path": "flurl/3.0.6",
      "hashPath": "flurl.3.0.6.nupkg.sha512"
    },
    "Flurl.Http/3.2.4": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Me9Vm4Lm21vt/pbR0G2Dww/ZOjJgh6mB2FiH28aiUYStJD10ZecDp8jxg2zKxcy6lnkvLm99pjG4yC/k7a/d8w==",
      "path": "flurl.http/3.2.4",
      "hashPath": "flurl.http.3.2.4.nupkg.sha512"
    },
    "Microsoft.Extensions.Configuration.Abstractions/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-qWzV9o+ZRWq+pGm+1dF+R7qTgTYoXvbyowRoBxQJGfqTpqDun2eteerjRQhq5PQ/14S+lqto3Ft4gYaRyl4rdQ==",
      "path": "microsoft.extensions.configuration.abstractions/6.0.0",
      "hashPath": "microsoft.extensions.configuration.abstractions.6.0.0.nupkg.sha512"
    },
    "Microsoft.Extensions.Primitives/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-9+PnzmQFfEFNR9J2aDTfJGGupShHjOuGw4VUv+JB044biSHrnmCIMD+mJHmb2H7YryrfBEXDurxQ47gJZdCKNQ==",
      "path": "microsoft.extensions.primitives/6.0.0",
      "hashPath": "microsoft.extensions.primitives.6.0.0.nupkg.sha512"
    },
    "Microsoft.NETCore.Platforms/2.1.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-mOJy3M0UN+LUG21dLGMxaWZEP6xYpQEpLuvuEQBaownaX4YuhH6NmNUlN9si+vNkAS6dwJ//N1O4DmLf2CikVg==",
      "path": "microsoft.netcore.platforms/2.1.2",
      "hashPath": "microsoft.netcore.platforms.2.1.2.nupkg.sha512"
    },
    "Newtonsoft.Json/12.0.2": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-rTK0s2EKlfHsQsH6Yx2smvcTCeyoDNgCW7FEYyV01drPlh2T243PR2DiDXqtC5N4GDm4Ma/lkxfW5a/4793vbA==",
      "path": "newtonsoft.json/12.0.2",
      "hashPath": "newtonsoft.json.12.0.2.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    },
    "System.Text.Encoding.CodePages/4.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-4J2JQXbftjPMppIHJ7IC+VXQ9XfEagN92vZZNoG12i+zReYlim5dMoXFC1Zzg7tsnKDM7JPo5bYfFK4Jheq44w==",
      "path": "system.text.encoding.codepages/4.5.1",
      "hashPath": "system.text.encoding.codepages.4.5.1.nupkg.sha512"
    },
    "VCards/1.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-VQdqf5LEB0fcMQux5nehPqabfRINNmjuTO1WCBlesq2nYMKFxnIrvQjhebkCTtRiv5iGZ5G9vs4+xjO13DQxng==",
      "path": "vcards/1.0.0",
      "hashPath": "vcards.1.0.0.nupkg.sha512"
    },
    "Toolblox.Cryptography/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Toolblox.Model/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "NBitcoin/7.0.17.0": {
      "type": "reference",
      "serviceable": false,
      "sha512": ""
    }
  }
}
'''
'''--- Lib/Toolblox.Cryptography.deps.json ---
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.0/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.0": {},
    ".NETStandard,Version=v2.0/": {
      "Toolblox.Cryptography/1.0.0": {
        "dependencies": {
          "NETStandard.Library": "2.0.3",
          "NBitcoin": "7.0.17.0"
        },
        "runtime": {
          "Toolblox.Cryptography.dll": {}
        }
      },
      "Microsoft.NETCore.Platforms/1.1.0": {},
      "NETStandard.Library/2.0.3": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0"
        }
      },
      "NBitcoin/7.0.17.0": {
        "runtime": {
          "NBitcoin.dll": {
            "assemblyVersion": "7.0.17.0",
            "fileVersion": "7.0.17.0"
          }
        }
      }
    }
  },
  "libraries": {
    "Toolblox.Cryptography/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Microsoft.NETCore.Platforms/1.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kz0PEW2lhqygehI/d6XsPCQzD7ff7gUJaVGPVETX611eadGsA3A877GdSlU0LRVMCTH/+P3o2iDTak+S08V2+A==",
      "path": "microsoft.netcore.platforms/1.1.0",
      "hashPath": "microsoft.netcore.platforms.1.1.0.nupkg.sha512"
    },
    "NETStandard.Library/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-st47PosZSHrjECdjeIzZQbzivYBJFv6P2nv4cj2ypdI204DO+vZ7l5raGMiX4eXMJ53RfOIg+/s4DHVZ54Nu2A==",
      "path": "netstandard.library/2.0.3",
      "hashPath": "netstandard.library.2.0.3.nupkg.sha512"
    },
    "NBitcoin/7.0.17.0": {
      "type": "reference",
      "serviceable": false,
      "sha512": ""
    }
  }
}
'''
'''--- Lib/Toolblox.Model.deps.json ---
{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v6.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v6.0": {
      "Toolblox.Model/1.0.0": {
        "dependencies": {
          "Dahomey.Json.Attributes": "1.0.1",
          "Microsoft.Extensions.Configuration.Abstractions": "6.0.0"
        },
        "runtime": {
          "Toolblox.Model.dll": {}
        }
      },
      "Dahomey.Json.Attributes/1.0.1": {
        "runtime": {
          "lib/net6.0/Dahomey.Json.Attributes.dll": {
            "assemblyVersion": "1.0.1.0",
            "fileVersion": "1.0.1.0"
          }
        }
      },
      "Microsoft.Extensions.Configuration.Abstractions/6.0.0": {
        "dependencies": {
          "Microsoft.Extensions.Primitives": "6.0.0"
        },
        "runtime": {
          "lib/netstandard2.0/Microsoft.Extensions.Configuration.Abstractions.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "Microsoft.Extensions.Primitives/6.0.0": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        },
        "runtime": {
          "lib/net6.0/Microsoft.Extensions.Primitives.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.21.52210"
          }
        }
      },
      "System.Runtime.CompilerServices.Unsafe/6.0.0": {}
    }
  },
  "libraries": {
    "Toolblox.Model/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Dahomey.Json.Attributes/1.0.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-5V73KuRVnyvyB8+BEkCvxpbI3MZpG6PQNdfKGxeKFBabotepbrnJ+Xz00P84BD4zdg7UPGybo9Nsl988Y8/tfw==",
      "path": "dahomey.json.attributes/1.0.1",
      "hashPath": "dahomey.json.attributes.1.0.1.nupkg.sha512"
    },
    "Microsoft.Extensions.Configuration.Abstractions/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-qWzV9o+ZRWq+pGm+1dF+R7qTgTYoXvbyowRoBxQJGfqTpqDun2eteerjRQhq5PQ/14S+lqto3Ft4gYaRyl4rdQ==",
      "path": "microsoft.extensions.configuration.abstractions/6.0.0",
      "hashPath": "microsoft.extensions.configuration.abstractions.6.0.0.nupkg.sha512"
    },
    "Microsoft.Extensions.Primitives/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-9+PnzmQFfEFNR9J2aDTfJGGupShHjOuGw4VUv+JB044biSHrnmCIMD+mJHmb2H7YryrfBEXDurxQ47gJZdCKNQ==",
      "path": "microsoft.extensions.primitives/6.0.0",
      "hashPath": "microsoft.extensions.primitives.6.0.0.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/6.0.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg==",
      "path": "system.runtime.compilerservices.unsafe/6.0.0",
      "hashPath": "system.runtime.compilerservices.unsafe.6.0.0.nupkg.sha512"
    }
  }
}
'''
'''--- README.md ---
# Toolblox.Ada.App
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/.vscode/extensions.json ---
{
  "recommendations": [
    "ms-azuretools.vscode-azurefunctions"
  ]
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/.vscode/launch.json ---
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach to Node Functions",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "preLaunchTask": "func: host start"
    }
  ]
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/.vscode/settings.json ---
{
  "azureFunctions.deploySubpath": ".",
  "azureFunctions.postDeployTask": "npm install (functions)",
  "azureFunctions.projectLanguage": "TypeScript",
  "azureFunctions.projectRuntime": "~4",
  "debug.internalConsoleOptions": "neverOpen",
  "azureFunctions.preDeployTask": "npm prune (functions)"
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/.vscode/tasks.json ---
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "func",
      "command": "host start",
      "problemMatcher": "$func-node-watch",
      "isBackground": true,
      "dependsOn": "npm build (functions)"
    },
    {
      "type": "shell",
      "label": "npm build (functions)",
      "command": "npm run build",
      "dependsOn": "npm install (functions)",
      "problemMatcher": "$tsc"
    },
    {
      "type": "shell",
      "label": "npm install (functions)",
      "command": "npm install"
    },
    {
      "type": "shell",
      "label": "npm prune (functions)",
      "command": "npm prune --production",
      "dependsOn": "npm build (functions)",
      "problemMatcher": []
    }
  ]
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/NftMetadataFunction/function.json ---
{
  "bindings": [
    {
        "authLevel": "anonymous",
        "type": "httpTrigger",
        "direction": "in",
        "name": "req",
        "route": "metadata"
    },
    {
        "type": "http",
        "direction": "out",
        "name": "res"
    }
  ],
  "scriptFile": "../dist/NftMetadataFunction/index.js"
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/NftMetadataFunction/index.ts ---
import { AzureFunction, Context, HttpRequest } from "@azure/functions";
import { TableClient } from "@azure/data-tables";
import * as ethers from 'ethers';
const nearAPI = require("near-api-js");
const { keyStores, KeyPair, connect } = nearAPI;
const myKeyStore = new keyStores.InMemoryKeyStore();

const tableStorageConnection = process.env["toolblox_STORAGE"] || "";

const httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {
    const itemId = req.query.id;
    const workflowUrl = req.query.workflowId.replace(/['"-]/g, "");
    console.log("=============== req initiated for item: " + itemId + ", workflow: " + workflowUrl + ", url: " + req.url + ", query: " + req.query);
    const client = TableClient.fromConnectionString(tableStorageConnection, `Workflows`);
    const workflowList = client.listEntities<Workflow>({
        queryOptions: {
            filter: `Url eq '${workflowUrl}'`,
            select: [ "Project", "Object", "SelectedChain", "SelectedBlockchainKind", "NearTestnet", "NearMainnet", "Abi" ]
        },
    });
    let workflow: Workflow = undefined;
    for await (const workflowLine of workflowList) {
        workflow = workflowLine;
        break;
    }
    if (workflow == undefined) {
        throw new Error('Cannot find workflow with url ' + workflowUrl);
    }
    //console.log("++++++++++ WORKFLOW: " + JSON.stringify(workflow));
    //const workflow = await client.getEntity<Workflow>("testnet", req.query.workflowId);
    // adds the keyPair you created to keyStore
    let cid = "";
    let name = "";
    let description = "";
    let contractAddress = workflow.NearTestnet;
    let traits = [];
    if (workflow.SelectedBlockchainKind == 1)
    {
        contractAddress = workflow.NearMainnet;
    }
    try {
        if (workflow.SelectedChain == 1) {
            const connectionConfig = workflow.SelectedBlockchainKind == 0
            ? {
                networkId: "testnet",
                keyStore: myKeyStore,
                nodeUrl: "https://rpc.testnet.near.org",
                walletUrl: "https://wallet.testnet.near.org",
                helperUrl: "https://helper.testnet.near.org",
                explorerUrl: "https://explorer.testnet.near.org",
            } : {
                networkId: "mainnet",
                keyStore: myKeyStore,
                nodeUrl: "https://rpc.mainnet.near.org",
                walletUrl: "https://wallet.mainnet.near.org",
                helperUrl: "https://helper.mainnet.near.org",
                explorerUrl: "https://explorer.mainnet.near.org",
            };
            const nearConnection = await connect(connectionConfig);
            const contract = new nearAPI.Contract(await nearConnection.account(contractAddress), contractAddress, {
                viewMethods: ['getItem'],
                changeMethods: []
            });
            var item = await contract.getItem({ "id": itemId });
            cid = item.image;
            name = item.name;
            description = item.description;
        } else {
            let network = "";
            switch (workflow.SelectedChain) {
                case 0:
                throw "No selected chain!";
                case 2:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://rpc-mumbai.maticvigil.com/"
                        : "https://polygon-rpc.com/";
                break;
                case 3:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://testnet.aurora.dev"
                        : "https://mainnet.aurora.dev";
                break;
                case 4:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://api.avax-test.network/ext/bc/C/rpc"
                        : "https://api.avax.network/ext/bc/C/rpc";
                break;
                case 5:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://eth.bd.evmos.dev:8545"
                        : "https://eth.bd.evmos.org:8545";
                break;
                case 6:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://rpc.sepolia.org"
                        : "https://mainnet.infura.io/v3/";
                break;
                case 7:
                    network = workflow.SelectedBlockchainKind == 0
                        ? "https://data-seed-prebsc-2-s2.binance.org:8545/"
                        : "https://bsc-dataseed.binance.org/";
                case 1:
                default:
                    break;
            }
            //const abi = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getDescription","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getImage","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getStatus","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"}]');
            console.log("================ contract: " + contractAddress + ", workflowId : " + req.query.workflowId + ", network: " + network + ", itemId = " + itemId)
            //console.log("================ abi to parse: " + workflow.Abi);
            const abi = JSON.parse(workflow.Abi);
            const contract = new ethers.Contract(contractAddress, abi, new ethers.providers.JsonRpcProvider(network));
            // var methods = abi
            //     .filter(method => method.inputs !== undefined && method.inputs.length == 1 && method.inputs[0].name === "id")
            //     .filter(method => method.outputs !== undefined && method.outputs.length == 1 && method.outputs[0].components === undefined)
            //     .filter(method => method.name.startsWith("get"))
            //     .map(method => method.name);

            // for (let i = 0; i < methods.length; i++) {
            //     traits.push({
            //         trait_type : methods[i].name.replace(/get([A-Z])/g, ' $1').trim(),
            //         value: await await contract[methods[i].name].apply(contract, [ itemId ]),
            //     });
            // }

            var traitNames = abi
                .filter(method => method.name === "getItem")
                .flatMap(method => method.outputs[0].components)
                .map(prop => prop.name.replace(/([A-Z])/g, ' $1').trim())
                .map(prop => prop.charAt(0).toUpperCase() + prop.slice(1));
            var traitValues = await contract.getItem(itemId);

            for (let i = 0; i < traitNames.length; i++) {
                traits.push({
                    trait_type : traitNames[i],
                    value: traitValues[i],
                });
            }
            //console.log(JSON.stringify(traits));

            name = traits.filter(t => t.trait_type == "Name")[0].value;
            cid = traits.filter(t => t.trait_type == "Image")[0].value;
            description = traits.filter(t => t.trait_type == "Description")[0].value;

            console.log("================== got " + name +", cid" + cid);
        }
        context.res = {
            status: 200, /* Defaults to 200 */
            body: {
                name : name,
                description : description,
                image : "ipfs://" + cid,
                external_link : "https://app.toolblox.net/flow/" + req.query.workflowId + "/" + itemId,
                attributes: traits
            },
            headers: {
                'Content-Type': 'application/json'
            }
        }
    }
    catch (error) {
        throw error;
    }
};

interface Workflow {
    partitionKey: string;
    rowKey: string;
    Abi?: string;
    Project: string;
    Object: string;
    SelectedChain: number;
    SelectedBlockchainKind: number;
    NearTestnet?: string;
    NearMainnet?: string;
}
export default httpTrigger;

'''
'''--- Toolblox.Ada.App.Blockchain.Functions/ProcessInvoiceFunction/function.json ---
{
  "bindings": [
    {
      "name": "myQueueItem",
      "type": "queueTrigger",
      "direction": "in",
      "queueName": "invoices-to-process",
      "connection": "adawillhandlestorage_STORAGE"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "outQueueItem",
      "queueName": "invoices-to-automate",
      "connection": "adawillhandlestorage_STORAGE"
    }
  ],
  "scriptFile": "../dist/ProcessInvoiceFunction/index.js"
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/ProcessInvoiceFunction/index.ts ---
import { AzureFunction, Context } from "@azure/functions";
import { Edm, TableClient } from "@azure/data-tables";
import * as redstone from 'redstone-api';
import * as ethers from 'ethers';
const nearAPI = require("near-api-js");
const { keyStores, KeyPair, connect } = nearAPI;
const myKeyStore = new keyStores.InMemoryKeyStore();
const PRIVATE_KEY = process.env.NearAccountPrivateKey;
const EVM_PRIVATE_KEY = process.env.EvmAccountPrivateKey;
const connectionConfig = {
    networkId: "testnet",
    keyStore: myKeyStore, // first create a key store 
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
    helperUrl: "https://helper.testnet.near.org",
    explorerUrl: "https://explorer.testnet.near.org",
};

const tableStorageConnection = process.env["adawillhandlestorage_STORAGE"] || "";

const queueTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {
    // creates a public / private key pair using the provided private key
    const keyPair = KeyPair.fromString(PRIVATE_KEY);
    const client = TableClient.fromConnectionString(tableStorageConnection, `Invoices`);
    let accountantId = myQueueItem.split(':')[0].replace(/\"/gi, "");
    const invoice = await client.getEntity<Invoice>(accountantId, myQueueItem.split(':')[1]);

    // adds the keyPair you created to keyStore 
    await myKeyStore.setKey("testnet", "accountant-ada.testnet", keyPair);
    try {
        const accountantClient = TableClient.fromConnectionString(tableStorageConnection, `Accountants`);
        const accountantList = accountantClient.listEntities<Accountant>({
            queryOptions: {
                filter: `Contract eq '${accountantId}' or Workflow eq '${accountantId}'`,
            },
        });
        let accountant: Accountant = undefined;
        for await (const accountantLine of accountantList) {
            accountant = accountantLine;
            break;
        }
        if (accountant == undefined) {
            throw new Error('Cannot find accountant with id ' + accountantId);
        }

        let processFee: number = Number(accountant.ProcessFee);

        var alternativeCurrency = invoice.AlternativeCurrency;
        var alternativeFxValue = invoice.AlternativeFxValue;

        //todo get alternative currency
        if (!invoice.IsFiat && invoice.AlternativeFxValue == undefined) {
            if (invoice.Currency == "NEAR") {
                //get multiplier for wrap.testnet
                const nearConnection = await connect(connectionConfig);
                const oracleContract = new nearAPI.Contract(await nearConnection.account("accountant-ada.testnet"), "priceoracle.testnet", {
                    viewMethods: ['get_price_data'],
                    changeMethods: []
                });
                var multiplier = (await oracleContract.get_price_data({ "asset_ids": ["wrap.testnet"] })).prices[0].price.multiplier;
                alternativeFxValue = (Number(multiplier.toString()) / 10000).toString();
                alternativeCurrency = "USD";
            }
            else {
                try {
                    // const price = await redstone.getPrice(invoice.Currency.toUpperCase());
                    // alternativeFxValue = price.value.toString();
                    // alternativeCurrency = "USD";
                }
                catch (ex) {
                    console.error(ex);
                }
            }
        }

        if (invoice.ProcessedAt == undefined) {
            if (accountant.SelectedChain == 1) {
                const nearConnection = await connect(connectionConfig);
                const contract = new nearAPI.Contract(await nearConnection.account("accountant-ada.testnet"), accountant.Workflow, {
                    viewMethods: ['getItem'],
                    changeMethods: ['process', 'processExternal']
                });
                //Near
                if (invoice.InvoiceNr == undefined || Number(invoice.InvoiceNr) == 0) {
                    console.log("Running processExternal");
                    var item = await contract.processExternal({ "name": invoice.Article, "amount": invoice.Amount, "currency": invoice.Currency, "from": invoice.From, "to": invoice.To, "receipt": invoice.rowKey, "processFee": processFee.toString() });
                    var itemId = item.id;
                    invoice.InvoiceNr = BigInt(itemId);
                } else {
                    //process
                    console.log("Running process for invoice " + invoice.InvoiceNr);
                    await contract.process({ "id": Number(invoice.InvoiceNr), "receipt": invoice.rowKey, "processFee": processFee.toString() });
                }
            }
            if (accountant.SelectedChain == 5) {
                //evmos
                const signer = new ethers.Wallet(new ethers.utils.SigningKey(EVM_PRIVATE_KEY), new ethers.providers.JsonRpcProvider("https://eth.bd.evmos.dev:8545"));
                const abi = JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"string","name":"article","type":"string"},{"indexed":false,"internalType":"string","name":"currency","type":"string"},{"indexed":false,"internalType":"string","name":"amount","type":"string"}],"name":"IssueInvoice","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_id","type":"uint256"}],"name":"ItemUpdated","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"accountantList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"adr","type":"address"}],"name":"addAccountant","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"adr","type":"address"}],"name":"addSource","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"fromList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"}],"name":"generate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getItem","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"accountant","type":"address"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"source","type":"address"}],"internalType":"struct InvoiceWorkflow.Invoice","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cnt","type":"uint256"}],"name":"getLatest","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"accountant","type":"address"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"source","type":"address"}],"internalType":"struct InvoiceWorkflow.Invoice[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cursor","type":"uint256"},{"internalType":"uint256","name":"howMany","type":"uint256"},{"internalType":"bool","name":"onlyMine","type":"bool"}],"name":"getPage","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"accountant","type":"address"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"source","type":"address"}],"internalType":"struct InvoiceWorkflow.Invoice[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getStatus","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"items","outputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"accountant","type":"address"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"source","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"uint256","name":"processFee","type":"uint256"}],"name":"process","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"amount","type":"string"},{"internalType":"string","name":"currency","type":"string"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"string","name":"receipt","type":"string"},{"internalType":"uint256","name":"processFee","type":"uint256"}],"name":"processExternal","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"sourceList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"toList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]');
                const contract = new ethers.Contract(accountant.Workflow, abi, signer);
                if (invoice.InvoiceNr == undefined || Number(invoice.InvoiceNr) == 0) {
                    let itemTransaction = await contract.processExternal(invoice.Article, invoice.Amount, invoice.Currency, invoice.From, invoice.To, invoice.rowKey, BigInt(processFee / 1000), { "gasLimit": 3000000 });
                    let receipt = await itemTransaction.wait();
                    invoice.InvoiceNr = BigInt(receipt.events.at(-1).args["_id"]);
                }
                else {
                    let itemTransaction = await contract.process(BigInt(Number(invoice.InvoiceNr)), invoice.rowKey, BigInt(processFee / 1000), { "gasLimit": 3000000 });
                    await itemTransaction.wait();
                }
            }
        }

        invoice.ProcessedAt = new Date();
        invoice.ProcessFee = accountant.ProcessFee;
        invoice.Error = '';
        invoice.AlternativeCurrency = alternativeCurrency;
        invoice.AlternativeFxValue = alternativeFxValue;
        await client.upsertEntity(invoice, "Merge");
        context.bindings.outQueueItem = myQueueItem;
    } catch (error) {
        const errorEntity = {
            partitionKey: invoice.partitionKey,
            rowKey: invoice.rowKey,
            Error: error.toString(),
        };
        await client.upsertEntity(errorEntity, "Merge");
        throw error;
    }
};

interface Invoice {
    partitionKey: string;
    rowKey: string;
    InvoiceNr?: bigint;
    CreatedAt: Date;
    From?: string;
    To?: string;
    Article?: string;
    ProcessedAt?: Date;
    Amount?: string;
    IsFiat?: boolean;
    ProcessFee?: number;
    Error?: string;
    Currency?: string;
    AlternativeCurrency?: string;
    AlternativeFxValue?: string;
}
interface Accountant {
    partitionKey: string;
    rowKey: string;
    ProcessFee: number;
    Workflow: string;
    SelectedChain: number;
}
export default queueTrigger;

'''
'''--- Toolblox.Ada.App.Blockchain.Functions/ProcessInvoiceFunction/readme.md ---
# QueueTrigger - TypeScript

The `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.

## How it works

For a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.

## Learn more

<TODO> Documentation
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/UpdateSubscriptionFunction/function.json ---
{
  "bindings": [
    {
        "authLevel": "anonymous",
        "type": "httpTrigger",
        "direction": "in",
        "name": "req",
        "route": "subscription"
    },
    {
        "type": "http",
        "direction": "out",
        "name": "res"
    }
  ],
  "scriptFile": "../dist/UpdateSubscriptionFunction/index.js"
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/UpdateSubscriptionFunction/index.ts ---
import { AzureFunction, Context, HttpRequest } from "@azure/functions";
import { TableClient } from "@azure/data-tables";
import * as ethers from 'ethers';
var jwt = require('jsonwebtoken');
var jwksClient = require('jwks-rsa');
const nearAPI = require("near-api-js");
const { keyStores, connect } = nearAPI;
const myKeyStore = new keyStores.InMemoryKeyStore();

const tableStorageConnection = process.env["toolblox_STORAGE"] || "";

var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://toolblox.eu.auth0.com/.well-known/jwks.json'
});

function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

const httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {
    var bearer = (req.headers.authorization ?? "").replace("Bearer ", "");
    var login = () => new Promise<string>((resolve) => 
        {
            jwt.verify(
                bearer,
                getKey,
                { audience: 'http://localhost:7071/api/Function1', issuer: 'https://toolblox.eu.auth0.com/' },
                function(err, decoded) {
                    console.log("decoded: " + JSON.stringify(decoded));
                    if (err)
                    {
                        throw err;
                    }
                    resolve(decoded.sub);
                });
        });
    var userId = await login();

    const island = req.query.island;

    const client = TableClient.fromConnectionString(tableStorageConnection, `Subscriptions`);
    var subscription : Subscription;
    try{
        subscription = await client.getEntity<Subscription>(userId, userId + ":" + island);
    } catch {}
    if (subscription == undefined) {
        subscription = {
            partitionKey: userId,
            rowKey: userId + ":" + island,
            SelectedChain: island.includes("Near") ? 1
                : (island.includes("Polygon") ? 2
                : (island.includes("Aurora") ? 3
                : (island.includes("Avalanche") ? 4
                : (island.includes("Evmos") ? 5
                : (island.includes("Ethereum") ? 6
                : (island.includes("Binance") ? 7 : 0)))))),
            SelectedBlockchainKind: island.includes("Testnet") ? 0 : 1,
            ValidUntil: { value: "0", type: "Int64" }
        }
    }
    //const timeSeconds = Math.floor(new Date().getTime() / 1000);
    
    try {
        if (subscription.SelectedChain == 1) {
            const connectionConfig = subscription.SelectedBlockchainKind == 0
            ? {
                networkId: "testnet",
                keyStore: myKeyStore,
                nodeUrl: "https://rpc.testnet.near.org",
                walletUrl: "https://wallet.testnet.near.org",
                helperUrl: "https://helper.testnet.near.org",
                explorerUrl: "https://explorer.testnet.near.org",
            } : {
                networkId: "mainnet",
                keyStore: myKeyStore,
                nodeUrl: "https://rpc.mainnet.near.org",
                walletUrl: "https://wallet.mainnet.near.org",
                helperUrl: "https://helper.mainnet.near.org",
                explorerUrl: "https://explorer.mainnet.near.org",
            };
            let contractAddress = "TESTNET";
            if (subscription.SelectedBlockchainKind == 1)
            {
                contractAddress = "MAINNET";
            }
            const nearConnection = await connect(connectionConfig);
            const contract = new nearAPI.Contract(await nearConnection.account(contractAddress), contractAddress, {
                viewMethods: ['getItemIdByExternalId', 'getValidUntil'],
                changeMethods: []
            });
            var itemId = await contract.getItemIdByExternalId({ "externalId": userId });
            var validUntil = await contract.getValidUntil({ "id": itemId });
            subscription.ValidUntil = { value: validUntil.toString(), type: "Int64" };
            console.log("Found valid until for user: " + userId + ", sub:" + itemId + ", subscription: " + subscription);
        } else {
            let network = "";
            let contractAddress = "";
            switch (subscription.SelectedChain) {
                case 0:
                throw "No selected chain!";
                case 2:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://rpc-mumbai.maticvigil.com/"
                        : "https://polygon-rpc.com/";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "";
                break;
                case 3:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://testnet.aurora.dev"
                        : "https://mainnet.aurora.dev";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "0xE0c0085F879aB55Def44b164021e576DA9acd0f0";
                break;
                case 4:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://api.avax-test.network/ext/bc/C/rpc"
                        : "https://api.avax.network/ext/bc/C/rpc";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "";
                break;
                case 5:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://eth.bd.evmos.dev:8545"
                        : "https://eth.bd.evmos.org:8545";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "";
                break;
                case 6:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://rpc.sepolia.dev"
                        : "https://mainnet.infura.io/v3/";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "";
                    console.log("using ethereum: " + network + ", contract: " + contractAddress);
                break;
                case 7:
                    network = subscription.SelectedBlockchainKind == 0
                        ? "https://data-seed-prebsc-2-s2.binance.org:8545/"
                        : "https://bsc-dataseed.binance.org/";
                    contractAddress = subscription.SelectedBlockchainKind == 0
                        ? ""
                        : "";
                    console.log("using ethereum: " + network + ", contract: " + contractAddress);
                break;
                case 1:
                default:
                    break;
            }
            const provider = new ethers.providers.JsonRpcProvider(network);
            await provider.ready;
            const contract = new ethers.Contract(contractAddress, [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_id","type":"uint256"}],"name":"ItemUpdated","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"uint256","name":"feeTier","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"}],"name":"create","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"customerList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getCustomer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getExternalId","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getItem","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"internalType":"struct SubscriptionWorkflow.Subscription","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"customer","type":"address"}],"name":"getItemByCustomer","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"internalType":"struct SubscriptionWorkflow.Subscription","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"externalId","type":"string"}],"name":"getItemByExternalId","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"internalType":"struct SubscriptionWorkflow.Subscription","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"customer","type":"address"}],"name":"getItemIdByCustomer","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"externalId","type":"string"}],"name":"getItemIdByExternalId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cnt","type":"uint256"}],"name":"getLatest","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"internalType":"struct SubscriptionWorkflow.Subscription[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cursor","type":"uint256"},{"internalType":"uint256","name":"howMany","type":"uint256"},{"internalType":"bool","name":"onlyMine","type":"bool"}],"name":"getPage","outputs":[{"components":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"internalType":"struct SubscriptionWorkflow.Subscription[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getPublicKey","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getStatus","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getValidUntil","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"items","outputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint64","name":"status","type":"uint64"},{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"customer","type":"address"},{"internalType":"uint256","name":"validUntil","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"},{"internalType":"string","name":"publicKey","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"itemsByCustomer","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"itemsByExternalId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"remove","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newOwner","type":"address"}],"name":"setOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"feeTier","type":"uint256"},{"internalType":"string","name":"externalId","type":"string"}],"name":"topUp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"string","name":"publicKey","type":"string"}],"name":"updateKey","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}], provider);
            const subscriptionId = await contract.getItemIdByExternalId(userId);
            subscription.ValidUntil = { value: ((await contract.getValidUntil(subscriptionId))?.toNumber() ?? 0).toString(), type: "Int64" };
            console.log("Found valid until for user: " + userId + ", sub:" + subscriptionId + ", subscription: " + JSON.stringify(subscription));
        }
        await client.upsertEntity(subscription, "Merge");
        console.log("Returning " + subscription.ValidUntil.value);
        context.res = {
            status: 200,
            body: {
                island : island,
                validUntil : Number(subscription.ValidUntil.value)
            },
            headers: {
                'Content-Type': 'application/json'
            }
        }
    }
    catch (error) {
        throw error;
    }
};

interface Subscription {
    partitionKey: string;
    rowKey: string;
    SelectedChain: number;
    SelectedBlockchainKind: number;
    ValidUntil: { value: string, type: string};
}
export default httpTrigger;

'''
'''--- Toolblox.Ada.App.Blockchain.Functions/host.json ---
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[3.*, 4.0.0)"
  },
  "extensions": {
      "queues": {
          "maxPollingInterval": "00:00:02"
      }
  }
}
'''
'''--- Toolblox.Ada.App.Blockchain.Functions/package-lock.json ---
{
  "name": "toolblox.ada.app.blockchain.functions",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "toolblox.ada.app.blockchain.functions",
      "version": "1.0.0",
      "dependencies": {
        "@azure/data-tables": "^13.2.0",
        "ethers": "^5.7.2",
        "jsonwebtoken": "^9.0.0",
        "jwks-rsa": "^3.0.1",
        "near-api-js": "^1.1.0",
        "redstone-api": "^0.4.11"
      },
      "devDependencies": {
        "@azure/functions": "^3.0.0",
        "@types/node": "^18.11.10"
      }
    },
    "node_modules/@azure/abort-controller": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@azure/abort-controller/-/abort-controller-1.1.0.tgz",
      "integrity": "sha512-TrRLIoSQVzfAJX9H1JeFjzAoDGcoK1IYX1UImfceTZpsyYfWr09Ss1aHW1y5TrrR3iq6RZLBwJ3E24uwPhwahw==",
      "dependencies": {
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-auth": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@azure/core-auth/-/core-auth-1.4.0.tgz",
      "integrity": "sha512-HFrcTgmuSuukRf/EdPmqBrc5l6Q5Uu+2TbuhaKbgaCpP2TfAeiNaQPAadxO+CYBRHGUzIDteMAjFspFLDLnKVQ==",
      "dependencies": {
        "@azure/abort-controller": "^1.0.0",
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-client": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@azure/core-client/-/core-client-1.6.1.tgz",
      "integrity": "sha512-mZ1MSKhZBYoV8GAWceA+PEJFWV2VpdNSpxxcj1wjIAOi00ykRuIQChT99xlQGZWLY3/NApWhSImlFwsmCEs4vA==",
      "dependencies": {
        "@azure/abort-controller": "^1.0.0",
        "@azure/core-auth": "^1.4.0",
        "@azure/core-rest-pipeline": "^1.9.1",
        "@azure/core-tracing": "^1.0.0",
        "@azure/core-util": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-paging": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@azure/core-paging/-/core-paging-1.3.0.tgz",
      "integrity": "sha512-H6Tg9eBm0brHqLy0OSAGzxIh1t4UL8eZVrSUMJ60Ra9cwq2pOskFqVpz2pYoHDsBY1jZ4V/P8LRGb5D5pmC6rg==",
      "dependencies": {
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-rest-pipeline": {
      "version": "1.9.2",
      "resolved": "https://registry.npmjs.org/@azure/core-rest-pipeline/-/core-rest-pipeline-1.9.2.tgz",
      "integrity": "sha512-8rXI6ircjenaLp+PkOFpo37tQ1PQfztZkfVj97BIF3RPxHAsoVSgkJtu3IK/bUEWcb7HzXSoyBe06M7ODRkRyw==",
      "dependencies": {
        "@azure/abort-controller": "^1.0.0",
        "@azure/core-auth": "^1.4.0",
        "@azure/core-tracing": "^1.0.1",
        "@azure/core-util": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "form-data": "^4.0.0",
        "http-proxy-agent": "^5.0.0",
        "https-proxy-agent": "^5.0.0",
        "tslib": "^2.2.0",
        "uuid": "^8.3.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-tracing": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@azure/core-tracing/-/core-tracing-1.0.1.tgz",
      "integrity": "sha512-I5CGMoLtX+pI17ZdiFJZgxMJApsK6jjfm85hpgp3oazCdq5Wxgh4wMr7ge/TTWW1B5WBuvIOI1fMU/FrOAMKrw==",
      "dependencies": {
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-util": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@azure/core-util/-/core-util-1.1.1.tgz",
      "integrity": "sha512-A4TBYVQCtHOigFb2ETiiKFDocBoI1Zk2Ui1KpI42aJSIDexF7DHQFpnjonltXAIU/ceH+1fsZAWWgvX6/AKzog==",
      "dependencies": {
        "@azure/abort-controller": "^1.0.0",
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/core-xml": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@azure/core-xml/-/core-xml-1.3.0.tgz",
      "integrity": "sha512-HYulCHr/3eMDxGubmbm+KIUxpOKPGtRxpaKBN6GpgPDQzREefdQ5bDlTuwHWhtqwyUG4RicKtZu8rhv5Sbg8jQ==",
      "dependencies": {
        "fast-xml-parser": "^4.0.8",
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/data-tables": {
      "version": "13.2.0",
      "resolved": "https://registry.npmjs.org/@azure/data-tables/-/data-tables-13.2.0.tgz",
      "integrity": "sha512-o16WVzcCYuZRh8M43R+twJyB9fZnhG2Y4ZfGmV2jX3HgV7TSBIXysuwgVYkdqYd3cyBVzpHW3pLY7IasOjvO7w==",
      "dependencies": {
        "@azure/core-auth": "^1.3.0",
        "@azure/core-client": "^1.0.0",
        "@azure/core-paging": "^1.1.1",
        "@azure/core-rest-pipeline": "^1.1.0",
        "@azure/core-tracing": "^1.0.0",
        "@azure/core-xml": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "tslib": "^2.2.0",
        "uuid": "^8.3.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@azure/functions": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/@azure/functions/-/functions-3.2.0.tgz",
      "integrity": "sha512-HbE7iORnYcjLzKNf5mIQRJQDTsVxhoXHRWEZ6KWdGh4e7+F9xTloiBicavbSoVmlAYivenIVpryHanVwsQaHUw==",
      "dev": true
    },
    "node_modules/@azure/logger": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@azure/logger/-/logger-1.0.3.tgz",
      "integrity": "sha512-aK4s3Xxjrx3daZr3VylxejK3vG5ExXck5WOHDJ8in/k9AqlfIyFMMT1uG7u8mNjX+QRILTIn0/Xgschfh/dQ9g==",
      "dependencies": {
        "tslib": "^2.2.0"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/@ethersproject/abi": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abi/-/abi-5.7.0.tgz",
      "integrity": "sha512-351ktp42TiRcYB3H1OP8yajPeAQstMW/yCFokj/AthP9bLHzQFPlOrxOcwYEDkUAICmOHljvN4K39OMTMUa9RA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/abstract-provider": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-provider/-/abstract-provider-5.7.0.tgz",
      "integrity": "sha512-R41c9UkchKCpAqStMYUpdunjo3pkEvZC3FAwZn5S5MGbXoMQOHIdHItezTETxAO5bevtMApSyEhn9+CHcDsWBw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/networks": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/web": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/abstract-signer": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-signer/-/abstract-signer-5.7.0.tgz",
      "integrity": "sha512-a16V8bq1/Cz+TGCkE2OPMTOUDLS3grCpdjoJCYNnVBbdYEMSgKrU0+B90s8b6H+ByYTBZN7a3g76jdIJi7UfKQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/address": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/address/-/address-5.7.0.tgz",
      "integrity": "sha512-9wYhYt7aghVGo758POM5nqcOMaE168Q6aRLJZwUmiqSrAungkG74gSSeKEIR7ukixesdRZGPgVqme6vmxs1fkA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/base64": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/base64/-/base64-5.7.0.tgz",
      "integrity": "sha512-Dr8tcHt2mEbsZr/mwTPIQAf3Ai0Bks/7gTw9dSqk1mQvhW3XvRlmDJr/4n+wg1JmCl16NZue17CDh8xb/vZ0sQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/basex": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/basex/-/basex-5.7.0.tgz",
      "integrity": "sha512-ywlh43GwZLv2Voc2gQVTKBoVQ1mti3d8HK5aMxsfu/nRDnMmNqaSJ3r3n85HBByT8OpoY96SXM1FogC533T4zw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/properties": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/bignumber": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/bignumber/-/bignumber-5.7.0.tgz",
      "integrity": "sha512-n1CAdIHRWjSucQO3MC1zPSVgV/6dy/fjL9pMrPP9peL+QxEg9wOsVqwD4+818B6LUEtaXzVHQiuivzRoxPxUGw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "bn.js": "^5.2.1"
      }
    },
    "node_modules/@ethersproject/bytes": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/bytes/-/bytes-5.7.0.tgz",
      "integrity": "sha512-nsbxwgFXWh9NyYWo+U8atvmMsSdKJprTcICAkvbBffT75qDocbuggBU0SJiVK2MuTrp0q+xvLkTnGMPK1+uA9A==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/constants": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/constants/-/constants-5.7.0.tgz",
      "integrity": "sha512-DHI+y5dBNvkpYUMiRQyxRBYBefZkJfo70VUkUAsRjcPs47muV9evftfZ0PJVCXYbAiCgght0DtcF9srFQmIgWA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/contracts": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/contracts/-/contracts-5.7.0.tgz",
      "integrity": "sha512-5GJbzEU3X+d33CdfPhcyS+z8MzsTrBGk/sc+G+59+tPa9yFkl6HQ9D6L0QMgNTA9q8dT0XKxxkyp883XsQvbbg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abi": "^5.7.0",
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/hash": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/hash/-/hash-5.7.0.tgz",
      "integrity": "sha512-qX5WrQfnah1EFnO5zJv1v46a8HW0+E5xuBBDTwMFZLuVTx0tbU2kkx15NqdjxecrLGatQN9FGQKpb1FKdHCt+g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/hdnode": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/hdnode/-/hdnode-5.7.0.tgz",
      "integrity": "sha512-OmyYo9EENBPPf4ERhR7oj6uAtUAhYGqOnIS+jE5pTXvdKBS99ikzq1E7Iv0ZQZ5V36Lqx1qZLeak0Ra16qpeOg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/basex": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/pbkdf2": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/wordlists": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/json-wallets": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/json-wallets/-/json-wallets-5.7.0.tgz",
      "integrity": "sha512-8oee5Xgu6+RKgJTkvEMl2wDgSPSAQ9MB/3JYjFV9jlKvcYHUXZC+cQp0njgmxdHkYWn8s6/IqIZYm0YWCjO/0g==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hdnode": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/pbkdf2": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "aes-js": "3.0.0",
        "scrypt-js": "3.0.1"
      }
    },
    "node_modules/@ethersproject/keccak256": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/keccak256/-/keccak256-5.7.0.tgz",
      "integrity": "sha512-2UcPboeL/iW+pSg6vZ6ydF8tCnv3Iu/8tUmLLzWWGzxWKFFqOBQFLo6uLUv6BDrLgCDfN28RJ/wtByx+jZ4KBg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "js-sha3": "0.8.0"
      }
    },
    "node_modules/@ethersproject/logger": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/logger/-/logger-5.7.0.tgz",
      "integrity": "sha512-0odtFdXu/XHtjQXJYA3u9G0G8btm0ND5Cu8M7i5vhEcE8/HmF4Lbdqanwyv4uQTr2tx6b7fQRmgLrsnpQlmnig==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ]
    },
    "node_modules/@ethersproject/networks": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/networks/-/networks-5.7.1.tgz",
      "integrity": "sha512-n/MufjFYv3yFcUyfhnXotyDlNdFb7onmkSy8aQERi2PjNcnWQ66xXxa3XlS8nCcA8aJKJjIIMNJTC7tu80GwpQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/pbkdf2": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/pbkdf2/-/pbkdf2-5.7.0.tgz",
      "integrity": "sha512-oR/dBRZR6GTyaofd86DehG72hY6NpAjhabkhxgr3X2FpJtJuodEl2auADWBZfhDHgVCbu3/H/Ocq2uC6dpNjjw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/properties": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/properties/-/properties-5.7.0.tgz",
      "integrity": "sha512-J87jy8suntrAkIZtecpxEPxY//szqr1mlBaYlQ0r4RCaiD2hjheqF9s1LVE8vVuJCXisjIP+JgtK/Do54ej4Sw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/providers": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/providers/-/providers-5.7.2.tgz",
      "integrity": "sha512-g34EWZ1WWAVgr4aptGlVBF8mhl3VWjv+8hoAnzStu8Ah22VHBsuGzP17eb6xDVRzw895G4W7vvx60lFFur/1Rg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/basex": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/networks": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/web": "^5.7.0",
        "bech32": "1.1.4",
        "ws": "7.4.6"
      }
    },
    "node_modules/@ethersproject/random": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/random/-/random-5.7.0.tgz",
      "integrity": "sha512-19WjScqRA8IIeWclFme75VMXSBvi4e6InrUNuaR4s5pTF2qNhcGdCUwdxUVGtDDqC00sDLCO93jPQoDUH4HVmQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/rlp": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/rlp/-/rlp-5.7.0.tgz",
      "integrity": "sha512-rBxzX2vK8mVF7b0Tol44t5Tb8gomOHkj5guL+HhzQ1yBh/ydjGnpw6at+X6Iw0Kp3OzzzkcKp8N9r0W4kYSs9w==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/sha2": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/sha2/-/sha2-5.7.0.tgz",
      "integrity": "sha512-gKlH42riwb3KYp0reLsFTokByAKoJdgFCwI+CCiX/k+Jm2mbNs6oOaCjYQSlI1+XBVejwH2KrmCbMAT/GnRDQw==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "hash.js": "1.1.7"
      }
    },
    "node_modules/@ethersproject/signing-key": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/signing-key/-/signing-key-5.7.0.tgz",
      "integrity": "sha512-MZdy2nL3wO0u7gkB4nA/pEf8lu1TlFswPNmy8AiYkfKTdO6eXBJyUdmHO/ehm/htHw9K/qF8ujnTyUAD+Ry54Q==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "bn.js": "^5.2.1",
        "elliptic": "6.5.4",
        "hash.js": "1.1.7"
      }
    },
    "node_modules/@ethersproject/solidity": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/solidity/-/solidity-5.7.0.tgz",
      "integrity": "sha512-HmabMd2Dt/raavyaGukF4XxizWKhKQ24DoLtdNbBmNKUOPqwjsKQSdV9GQtj9CBEea9DlzETlVER1gYeXXBGaA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/strings": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/strings/-/strings-5.7.0.tgz",
      "integrity": "sha512-/9nu+lj0YswRNSH0NXYqrh8775XNyEdUQAuf3f+SmOrnVewcJ5SBNAjF7lpgehKi4abvNNXyf+HX86czCdJ8Mg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/transactions": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/transactions/-/transactions-5.7.0.tgz",
      "integrity": "sha512-kmcNicCp1lp8qanMTC3RIikGgoJ80ztTyvtsFvCYpSCfkjhD0jZ2LOrnbcuxuToLIUYYf+4XwD1rP+B/erDIhQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/units": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/units/-/units-5.7.0.tgz",
      "integrity": "sha512-pD3xLMy3SJu9kG5xDGI7+xhTEmGXlEqXU4OfNapmfnxLVY4EMSSRp7j1k7eezutBPH7RBN/7QPnwR7hzNlEFeg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/wallet": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/wallet/-/wallet-5.7.0.tgz",
      "integrity": "sha512-MhmXlJXEJFBFVKrDLB4ZdDzxcBxQ3rLyCkhNqVu3CDYvR97E+8r01UgrI+TI99Le+aYm/in/0vp86guJuM7FCA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/hdnode": "^5.7.0",
        "@ethersproject/json-wallets": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/wordlists": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/web": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/web/-/web-5.7.1.tgz",
      "integrity": "sha512-Gueu8lSvyjBWL4cYsWsjh6MtMwM0+H4HvqFPZfB6dV8ctbP9zFAO73VG1cMWae0FLPCtz0peKPpZY8/ugJJX2w==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "node_modules/@ethersproject/wordlists": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/wordlists/-/wordlists-5.7.0.tgz",
      "integrity": "sha512-S2TFNJNfHWVHNE6cNDjbVlZ6MgE17MIxMbMg2zv3wn+3XSJGosL1m9ZVv3GXCf/2ymSsQ+hRI5IzoMJTG6aoVA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "node_modules/@tootallnate/once": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/@tootallnate/once/-/once-2.0.0.tgz",
      "integrity": "sha512-XCuKFP5PS55gnMVu3dty8KPatLqUoy/ZYzDzAGCQ8JNFCkLXzmI7vNHCR+XpbZaMWQK/vQubr7PkYq8g470J/A==",
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.2",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.2.tgz",
      "integrity": "sha512-ALYone6pm6QmwZoAgeyNksccT9Q4AWZQ6PvfwR37GT6r6FWUPguq6sUmNGSMV2Wr761oQoBxwGGa6DR5o1DC9g==",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.35",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.35.tgz",
      "integrity": "sha512-cdeYyv4KWoEgpBISTxWvqYsVy444DOqehiF3fM3ne10AmJ62RSyNkUnxMJXHQWRQQX2eR94m5y1IZyDwBjV9FQ==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/express": {
      "version": "4.17.16",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.16.tgz",
      "integrity": "sha512-LkKpqRZ7zqXJuvoELakaFYuETHjZkSol8EV6cNnyishutDBCCdv6+dsKPbKkCcIk57qRphOLY5sEgClw1bO3gA==",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.31",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.17.33",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.17.33.tgz",
      "integrity": "sha512-TPBqmR/HRYI3eC2E5hmiivIzv+bidAfXofM+sbonAGvyDhySGw9/PQZFt2BLOrjUUR++4eJVpx6KnLQK1Fk9tA==",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*"
      }
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.1.tgz",
      "integrity": "sha512-c5ltxazpWabia/4UzhIoaDcIza4KViOQhdbjRlfcIGVnsE3c3brkz9Z+F/EeJIECOQP7W7US2hNE930cWWkPiw==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/mime": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-3.0.1.tgz",
      "integrity": "sha512-Y4XFY5VJAuw0FgAqPNd6NNoV44jbq9Bz2L7Rh/J6jLTiHBSBJa9fxqQIvkIld4GsoDOcCbvzOUAbLPsSKKg+uA=="
    },
    "node_modules/@types/node": {
      "version": "18.11.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.11.11.tgz",
      "integrity": "sha512-KJ021B1nlQUBLopzZmPBVuGU9un7WJd/W4ya7Ih02B4Uwky5Nja0yGYav2EfYIk0RR2Q9oVhf60S2XR1BCWJ2g=="
    },
    "node_modules/@types/qs": {
      "version": "6.9.7",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.7.tgz",
      "integrity": "sha512-FGa1F62FT09qcrueBA6qYTrJPVDzah9a+493+o2PCXsesWHIn27G98TsSMs3WPNbZIEj4+VJf6saSFpvD+3Zsw=="
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.4.tgz",
      "integrity": "sha512-EEhsLsD6UsDM1yFhAvy0Cjr6VwmpMWqFBCb9w07wVugF7w9nfajxLuVmngTIpgS6svCnm6Vaw+MZhoDCKnOfsw=="
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.0.tgz",
      "integrity": "sha512-z5xyF6uh8CbjAu9760KDKsH2FcDxZ2tFCsA4HIMWE6IkiYMXfVoa+4f9KX+FN0ZLsaMw1WNG2ETLA6N+/YA+cg==",
      "dependencies": {
        "@types/mime": "*",
        "@types/node": "*"
      }
    },
    "node_modules/aes-js": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/aes-js/-/aes-js-3.0.0.tgz",
      "integrity": "sha512-H7wUZRn8WpTq9jocdxQ2c8x2sKo9ZVmzfRE13GiNJXfp7NcKYEdvl3vspKjXox6RIG2VtaRe4JFvxG4rqp2Zuw=="
    },
    "node_modules/agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "dependencies": {
        "debug": "4"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/ar-gql": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/ar-gql/-/ar-gql-0.0.6.tgz",
      "integrity": "sha512-eXKsXGQcx8uwxwlFJzBXA17Qsg+Gty6tcp85IB5SX1iop7NsXLQ/iH2WEz69NCz2/Zcb81C1QryIiNTgw0/4aA==",
      "dependencies": {
        "axios": "^0.21.1"
      }
    },
    "node_modules/arconnect": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/arconnect/-/arconnect-0.4.2.tgz",
      "integrity": "sha512-Jkpd4QL3TVqnd3U683gzXmZUVqBUy17DdJDuL/3D9rkysLgX6ymJ2e+sR+xyZF5Rh42CBqDXWNMmCjBXeP7Gbw==",
      "dependencies": {
        "arweave": "^1.10.13"
      }
    },
    "node_modules/arweave": {
      "version": "1.11.8",
      "resolved": "https://registry.npmjs.org/arweave/-/arweave-1.11.8.tgz",
      "integrity": "sha512-58ODeNPIC4OjaOCl2bXjKbOFGsiVZFs+DkQg3BvQGvFWNqw1zTJ4Jp01xGUz+GbdOaDyJcCC0g3l0HwdJfFPyw==",
      "dependencies": {
        "arconnect": "^0.4.2",
        "asn1.js": "^5.4.1",
        "axios": "^0.27.2",
        "base64-js": "^1.5.1",
        "bignumber.js": "^9.0.2",
        "util": "^0.12.4"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/arweave-multihost": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/arweave-multihost/-/arweave-multihost-0.1.0.tgz",
      "integrity": "sha512-biIkzQ3oc4RLV1MORQnqWz51IazP++K/8SsYMjUokK0cUfBLqom4pufKFCjTkGQIZMWWanXxnZqL66hHPgTCgA==",
      "dependencies": {
        "arweave": "^1.10.15",
        "axios": "^0.21.1"
      }
    },
    "node_modules/arweave/node_modules/axios": {
      "version": "0.27.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.27.2.tgz",
      "integrity": "sha512-t+yRIyySRTp/wua5xEr+z1q60QmLq8ABsS5O9Me1AsE5dfKqgnCFzwiCZZ/cGNd1lq4/7akDWMxdhVlucjmnOQ==",
      "dependencies": {
        "follow-redirects": "^1.14.9",
        "form-data": "^4.0.0"
      }
    },
    "node_modules/asn1.js": {
      "version": "5.4.1",
      "resolved": "https://registry.npmjs.org/asn1.js/-/asn1.js-5.4.1.tgz",
      "integrity": "sha512-+I//4cYPccV8LdmBLiX8CYvf9Sp3vQsrqu2QNXRcrbiWvcx/UdlFiqUJJzxRQxgsZmvhXhn4cSKeSmoFjVdupA==",
      "dependencies": {
        "bn.js": "^4.0.0",
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0",
        "safer-buffer": "^2.1.0"
      }
    },
    "node_modules/asn1.js/node_modules/bn.js": {
      "version": "4.12.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
      "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "node_modules/available-typed-arrays": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz",
      "integrity": "sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/axios": {
      "version": "0.21.4",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz",
      "integrity": "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==",
      "dependencies": {
        "follow-redirects": "^1.14.0"
      }
    },
    "node_modules/base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/bech32": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/bech32/-/bech32-1.1.4.tgz",
      "integrity": "sha512-s0IrSOzLlbvX7yp4WBfPITzpAU8sqQcpsmwXDiKwrG4r491vwCO/XpejasRNl0piBMe/DvP4Tz0mIS/X1DPJBQ=="
    },
    "node_modules/bignumber.js": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.1.0.tgz",
      "integrity": "sha512-4LwHK4nfDOraBCtst+wOWIHbu1vhvAPJK8g8nROd4iuc3PSEjWif/qwbkh8jwCJz6yDBvtU4KPynETgrfh7y3A==",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/bn.js": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.1.tgz",
      "integrity": "sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ=="
    },
    "node_modules/borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "dependencies": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "node_modules/brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w=="
    },
    "node_modules/bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "dependencies": {
        "base-x": "^3.0.2"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA=="
    },
    "node_modules/call-bind": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
      "dependencies": {
        "function-bind": "^1.1.1",
        "get-intrinsic": "^1.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha512-rsJZYVCgXd08sPqwmaIqjAd5SUTfonV0z/gDJ8D6cN8wQphky1kkAYEqQ+hmDxTw7UihvBfjUVUSY+DBEe44jg=="
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/debug": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
      "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-sort-object": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/deep-sort-object/-/deep-sort-object-1.0.2.tgz",
      "integrity": "sha512-Ko2XVMhRhz5Mxyb+QhLX13SHgcK1vuxc6XEfOyTMlbRbv7bhSmMqUw4ywqRwKgV25W+FDIaZjPWQrdblHCTwdA==",
      "dependencies": {
        "is-plain-object": "^2.0.1"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/elliptic": {
      "version": "6.5.4",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
      "integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
      "dependencies": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/elliptic/node_modules/bn.js": {
      "version": "4.12.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
      "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
    },
    "node_modules/error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "dependencies": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "node_modules/ethers": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/ethers/-/ethers-5.7.2.tgz",
      "integrity": "sha512-wswUsmWo1aOK8rR7DIKiWSw9DbLWe6x98Jrn8wcTflTVvaXhAMaB5zGAXy0GYQEQp9iO1iSHWVyARQm11zUtyg==",
      "funding": [
        {
          "type": "individual",
          "url": "https://gitcoin.co/grants/13/ethersjs-complete-simple-and-tiny-2"
        },
        {
          "type": "individual",
          "url": "https://www.buymeacoffee.com/ricmoo"
        }
      ],
      "dependencies": {
        "@ethersproject/abi": "5.7.0",
        "@ethersproject/abstract-provider": "5.7.0",
        "@ethersproject/abstract-signer": "5.7.0",
        "@ethersproject/address": "5.7.0",
        "@ethersproject/base64": "5.7.0",
        "@ethersproject/basex": "5.7.0",
        "@ethersproject/bignumber": "5.7.0",
        "@ethersproject/bytes": "5.7.0",
        "@ethersproject/constants": "5.7.0",
        "@ethersproject/contracts": "5.7.0",
        "@ethersproject/hash": "5.7.0",
        "@ethersproject/hdnode": "5.7.0",
        "@ethersproject/json-wallets": "5.7.0",
        "@ethersproject/keccak256": "5.7.0",
        "@ethersproject/logger": "5.7.0",
        "@ethersproject/networks": "5.7.1",
        "@ethersproject/pbkdf2": "5.7.0",
        "@ethersproject/properties": "5.7.0",
        "@ethersproject/providers": "5.7.2",
        "@ethersproject/random": "5.7.0",
        "@ethersproject/rlp": "5.7.0",
        "@ethersproject/sha2": "5.7.0",
        "@ethersproject/signing-key": "5.7.0",
        "@ethersproject/solidity": "5.7.0",
        "@ethersproject/strings": "5.7.0",
        "@ethersproject/transactions": "5.7.0",
        "@ethersproject/units": "5.7.0",
        "@ethersproject/wallet": "5.7.0",
        "@ethersproject/web": "5.7.1",
        "@ethersproject/wordlists": "5.7.0"
      }
    },
    "node_modules/fast-xml-parser": {
      "version": "4.0.11",
      "resolved": "https://registry.npmjs.org/fast-xml-parser/-/fast-xml-parser-4.0.11.tgz",
      "integrity": "sha512-4aUg3aNRR/WjQAcpceODG1C3x3lFANXRo8+1biqfieHmg9pyMt7qB4lQV/Ta6sJCTbA5vfD8fnA8S54JATiFUA==",
      "dependencies": {
        "strnum": "^1.0.5"
      },
      "bin": {
        "fxparser": "src/cli/cli.js"
      },
      "funding": {
        "type": "paypal",
        "url": "https://paypal.me/naturalintelligence"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.15.2",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.2.tgz",
      "integrity": "sha512-VQLG33o04KaQ8uYi2tVNbdrWp1QWxNNea+nmIB4EVM28v0hmP17z7aG1+wAkNzVq4KeXTq3221ye5qTJP91JwA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/for-each": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz",
      "integrity": "sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==",
      "dependencies": {
        "is-callable": "^1.1.3"
      }
    },
    "node_modules/form-data": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz",
      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
    },
    "node_modules/get-intrinsic": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
      "dependencies": {
        "function-bind": "^1.1.1",
        "has": "^1.0.3",
        "has-symbols": "^1.0.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gopd": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
      "dependencies": {
        "get-intrinsic": "^1.1.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dependencies": {
        "function-bind": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz",
      "integrity": "sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==",
      "dependencies": {
        "has-symbols": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "dependencies": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "node_modules/hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "dependencies": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "dependencies": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-errors/node_modules/depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-proxy-agent": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-5.0.0.tgz",
      "integrity": "sha512-n2hY8YdoRE1i7r6M0w9DIw5GgZN0G25P8zLCRQ8rjXtTU3vsNFBI/vWK/UIeE6g5MUUz6avwAPXmL6Fy9D/90w==",
      "dependencies": {
        "@tootallnate/once": "2",
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "dependencies": {
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/is-arguments": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz",
      "integrity": "sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==",
      "dependencies": {
        "call-bind": "^1.0.2",
        "has-tostringtag": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-callable": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-generator-function": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.0.10.tgz",
      "integrity": "sha512-jsEjy9l3yiXEQ+PsXdmBwEPcOxaXWLspKdplFUVI9vq1iZgIekeC0L167qeu86czQaxed3q/Uzuw0swL0irL8A==",
      "dependencies": {
        "has-tostringtag": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-plain-object": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
      "dependencies": {
        "isobject": "^3.0.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-typed-array": {
      "version": "1.1.10",
      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz",
      "integrity": "sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==",
      "dependencies": {
        "available-typed-arrays": "^1.0.5",
        "call-bind": "^1.0.2",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "has-tostringtag": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/isobject": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
      "integrity": "sha512-WhB9zCku7EGTj/HQQRz5aUQEUeoQZH2bWcltRErOpymJ4boYE6wL9Tbr23krRPSZ+C5zqNSrSw+Cc7sZZ4b7vg==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/jose": {
      "version": "4.11.2",
      "resolved": "https://registry.npmjs.org/jose/-/jose-4.11.2.tgz",
      "integrity": "sha512-njj0VL2TsIxCtgzhO+9RRobBvws4oYyCM8TpvoUQwl/MbIM3NFJRR9+e6x0sS5xXaP1t6OCBkaBME98OV9zU5A==",
      "funding": {
        "url": "https://github.com/sponsors/panva"
      }
    },
    "node_modules/js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "node_modules/js-sha3": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha3/-/js-sha3-0.8.0.tgz",
      "integrity": "sha512-gF1cRrHhIzNfToc802P800N8PpXS+evLLXfsVpowqmAFR9uwbi89WvXg2QspOmXL8QL86J4T1EpFu+yUkwJY3Q=="
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.0.tgz",
      "integrity": "sha512-tuGfYXxkQGDPnLJ7SibiQgVgeDgfbPq2k2ICcbgqW8WxWLBAxKQM/ZCu/IT8SOSwmaYl4dpTFCW5xZv7YbbWUw==",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash": "^4.17.21",
        "ms": "^2.1.1",
        "semver": "^7.3.8"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jwks-rsa": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/jwks-rsa/-/jwks-rsa-3.0.1.tgz",
      "integrity": "sha512-UUOZ0CVReK1QVU3rbi9bC7N5/le8ziUj0A2ef1Q0M7OPD2KvjEYizptqIxGIo6fSLYDkqBrazILS18tYuRc8gw==",
      "dependencies": {
        "@types/express": "^4.17.14",
        "@types/jsonwebtoken": "^9.0.0",
        "debug": "^4.3.4",
        "jose": "^4.10.4",
        "limiter": "^1.1.5",
        "lru-memoizer": "^2.1.4"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/limiter": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/limiter/-/limiter-1.1.5.tgz",
      "integrity": "sha512-FWWMIEOxz3GwUI4Ts/IvgVy6LPvoMPgjMdQ185nN6psJyBJ4yOpzqm695/h5umdLJg2vW3GR5iG11MAkR2AzJA=="
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "node_modules/lodash.clonedeep": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
      "integrity": "sha512-H5ZhCF25riFd9uB5UCkVKo61m3S/xZk1x4wA6yp/L3RFP6Z/eHH1ymQcGLo7J3GMPfm0V/7m1tryHuGVxpqEBQ=="
    },
    "node_modules/lru-cache": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-4.0.2.tgz",
      "integrity": "sha512-uQw9OqphAGiZhkuPlpFGmdTU2tEuhxTourM/19qGJrxBPHAr/f8BT1a0i/lOclESnGatdJG/UCkP9kZB/Lh1iw==",
      "dependencies": {
        "pseudomap": "^1.0.1",
        "yallist": "^2.0.0"
      }
    },
    "node_modules/lru-memoizer": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/lru-memoizer/-/lru-memoizer-2.1.4.tgz",
      "integrity": "sha512-IXAq50s4qwrOBrXJklY+KhgZF+5y98PDaNo0gi/v2KQBFLyWr+JyFvijZXkGKjQj/h9c0OwoE+JZbwUXce76hQ==",
      "dependencies": {
        "lodash.clonedeep": "^4.5.0",
        "lru-cache": "~4.0.0"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A=="
    },
    "node_modules/minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg=="
    },
    "node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "node_modules/mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
      "bin": {
        "mustache": "bin/mustache"
      }
    },
    "node_modules/near-api-js": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-1.1.0.tgz",
      "integrity": "sha512-qYKv1mYsaDZc2uYndhS+ttDhR9+60qFc+ZjD6lWsAxr3ZskMjRwPffDGQZYhC7BRDQMe1HEbk6d5mf+TVm0Lqg==",
      "dependencies": {
        "bn.js": "5.2.1",
        "borsh": "^0.7.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha512-f+4n+vC6s4ysy7YO7O2gslWZBUu8Qj2i2OUJOvjRxQva7jVjYjB29jrr9NCjmxZQR0gzrOcv1RnqoYOeMs5VRQ==",
      "dependencies": {
        "capability": "^0.2.5"
      }
    },
    "node_modules/pako": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/pako/-/pako-2.1.0.tgz",
      "integrity": "sha512-w+eufiZ1WuJYgPXbV/PO3NCMEc3xqylkKHzp8bxp1uW4qaSNQUkwmLLEc3kKsfz8lpV1F8Ht3U1Cm+9Srog2ug=="
    },
    "node_modules/pseudomap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/pseudomap/-/pseudomap-1.0.2.tgz",
      "integrity": "sha512-b/YwNhb8lk1Zz2+bXXpS/LK9OisiZZ1SNsSLxN1x2OXVEhW2Ckr/7mWE5vrC1ZTiJlD9g19jWszTmJsB+oEpFQ=="
    },
    "node_modules/redstone-api": {
      "version": "0.4.11",
      "resolved": "https://registry.npmjs.org/redstone-api/-/redstone-api-0.4.11.tgz",
      "integrity": "sha512-X0gj7UU5aLQPmNjdnhBUCvi6tkj5SpQJ7heT6+TIPx7Od707n4oqKHoJa41V8QOGjudbxaM1BIv6+2+hp0wFGQ==",
      "dependencies": {
        "ar-gql": "^0.0.6",
        "arweave": "^1.10.16",
        "arweave-multihost": "^0.1.0",
        "axios": "^0.21.1",
        "deep-sort-object": "^1.0.2",
        "lodash": "^4.17.21",
        "pako": "^2.0.3"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/scrypt-js": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/scrypt-js/-/scrypt-js-3.0.1.tgz",
      "integrity": "sha512-cdwTTnqPu0Hyvf5in5asVdZocVDTNRmR7XEcJuIzMjJeSHybHl7vpB66AzwTaIg6CLSbtjcxc8fqcySfnTkccA=="
    },
    "node_modules/semver": {
      "version": "7.3.8",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/semver/node_modules/lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/semver/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha512-OpZ3zP+jT1PI7I8nemJX4AKmAX070ZkYPVWV/AaKTJl+tXCTGyVdC1a4SL8RUQYEwk/f34ZX8UTykN68FwrqAA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/strnum": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/strnum/-/strnum-1.0.5.tgz",
      "integrity": "sha512-J8bbNyKKXl5qYcR36TIO8W3mVGVHrmmxsd5PAItGkmyzwJvybiw2IVq5nqd0i4LSNSkB/sx9VHllbfFdr9k1JA=="
    },
    "node_modules/text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ=="
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "node_modules/u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "node_modules/util": {
      "version": "0.12.5",
      "resolved": "https://registry.npmjs.org/util/-/util-0.12.5.tgz",
      "integrity": "sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==",
      "dependencies": {
        "inherits": "^2.0.3",
        "is-arguments": "^1.0.4",
        "is-generator-function": "^1.0.7",
        "is-typed-array": "^1.1.3",
        "which-typed-array": "^1.1.2"
      }
    },
    "node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/which-typed-array": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz",
      "integrity": "sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==",
      "dependencies": {
        "available-typed-arrays": "^1.0.5",
        "call-bind": "^1.0.2",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "has-tostringtag": "^1.0.0",
        "is-typed-array": "^1.1.10"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/ws": {
      "version": "7.4.6",
      "resolved": "https://registry.npmjs.org/ws/-/ws-7.4.6.tgz",
      "integrity": "sha512-YmhHDO4MzaDLB+M9ym/mDA5z0naX8j7SIlT8f8z+I0VtzsRbekxEutHSme7NPS2qE8StCYQNUnfWdXta/Yu85A==",
      "engines": {
        "node": ">=8.3.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": "^5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/yallist": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-2.1.2.tgz",
      "integrity": "sha512-ncTzHV7NvsQZkYe1DW7cbDLm0YpzHmZF5r/iyP3ZnQtMiJ+pjzisCiMNI+Sj+xQF5pXhSHxSB3uDbsBTzY/c2A=="
    }
  },
  "dependencies": {
    "@azure/abort-controller": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@azure/abort-controller/-/abort-controller-1.1.0.tgz",
      "integrity": "sha512-TrRLIoSQVzfAJX9H1JeFjzAoDGcoK1IYX1UImfceTZpsyYfWr09Ss1aHW1y5TrrR3iq6RZLBwJ3E24uwPhwahw==",
      "requires": {
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-auth": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@azure/core-auth/-/core-auth-1.4.0.tgz",
      "integrity": "sha512-HFrcTgmuSuukRf/EdPmqBrc5l6Q5Uu+2TbuhaKbgaCpP2TfAeiNaQPAadxO+CYBRHGUzIDteMAjFspFLDLnKVQ==",
      "requires": {
        "@azure/abort-controller": "^1.0.0",
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-client": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@azure/core-client/-/core-client-1.6.1.tgz",
      "integrity": "sha512-mZ1MSKhZBYoV8GAWceA+PEJFWV2VpdNSpxxcj1wjIAOi00ykRuIQChT99xlQGZWLY3/NApWhSImlFwsmCEs4vA==",
      "requires": {
        "@azure/abort-controller": "^1.0.0",
        "@azure/core-auth": "^1.4.0",
        "@azure/core-rest-pipeline": "^1.9.1",
        "@azure/core-tracing": "^1.0.0",
        "@azure/core-util": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-paging": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@azure/core-paging/-/core-paging-1.3.0.tgz",
      "integrity": "sha512-H6Tg9eBm0brHqLy0OSAGzxIh1t4UL8eZVrSUMJ60Ra9cwq2pOskFqVpz2pYoHDsBY1jZ4V/P8LRGb5D5pmC6rg==",
      "requires": {
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-rest-pipeline": {
      "version": "1.9.2",
      "resolved": "https://registry.npmjs.org/@azure/core-rest-pipeline/-/core-rest-pipeline-1.9.2.tgz",
      "integrity": "sha512-8rXI6ircjenaLp+PkOFpo37tQ1PQfztZkfVj97BIF3RPxHAsoVSgkJtu3IK/bUEWcb7HzXSoyBe06M7ODRkRyw==",
      "requires": {
        "@azure/abort-controller": "^1.0.0",
        "@azure/core-auth": "^1.4.0",
        "@azure/core-tracing": "^1.0.1",
        "@azure/core-util": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "form-data": "^4.0.0",
        "http-proxy-agent": "^5.0.0",
        "https-proxy-agent": "^5.0.0",
        "tslib": "^2.2.0",
        "uuid": "^8.3.0"
      }
    },
    "@azure/core-tracing": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@azure/core-tracing/-/core-tracing-1.0.1.tgz",
      "integrity": "sha512-I5CGMoLtX+pI17ZdiFJZgxMJApsK6jjfm85hpgp3oazCdq5Wxgh4wMr7ge/TTWW1B5WBuvIOI1fMU/FrOAMKrw==",
      "requires": {
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-util": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@azure/core-util/-/core-util-1.1.1.tgz",
      "integrity": "sha512-A4TBYVQCtHOigFb2ETiiKFDocBoI1Zk2Ui1KpI42aJSIDexF7DHQFpnjonltXAIU/ceH+1fsZAWWgvX6/AKzog==",
      "requires": {
        "@azure/abort-controller": "^1.0.0",
        "tslib": "^2.2.0"
      }
    },
    "@azure/core-xml": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@azure/core-xml/-/core-xml-1.3.0.tgz",
      "integrity": "sha512-HYulCHr/3eMDxGubmbm+KIUxpOKPGtRxpaKBN6GpgPDQzREefdQ5bDlTuwHWhtqwyUG4RicKtZu8rhv5Sbg8jQ==",
      "requires": {
        "fast-xml-parser": "^4.0.8",
        "tslib": "^2.2.0"
      }
    },
    "@azure/data-tables": {
      "version": "13.2.0",
      "resolved": "https://registry.npmjs.org/@azure/data-tables/-/data-tables-13.2.0.tgz",
      "integrity": "sha512-o16WVzcCYuZRh8M43R+twJyB9fZnhG2Y4ZfGmV2jX3HgV7TSBIXysuwgVYkdqYd3cyBVzpHW3pLY7IasOjvO7w==",
      "requires": {
        "@azure/core-auth": "^1.3.0",
        "@azure/core-client": "^1.0.0",
        "@azure/core-paging": "^1.1.1",
        "@azure/core-rest-pipeline": "^1.1.0",
        "@azure/core-tracing": "^1.0.0",
        "@azure/core-xml": "^1.0.0",
        "@azure/logger": "^1.0.0",
        "tslib": "^2.2.0",
        "uuid": "^8.3.0"
      }
    },
    "@azure/functions": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/@azure/functions/-/functions-3.2.0.tgz",
      "integrity": "sha512-HbE7iORnYcjLzKNf5mIQRJQDTsVxhoXHRWEZ6KWdGh4e7+F9xTloiBicavbSoVmlAYivenIVpryHanVwsQaHUw==",
      "dev": true
    },
    "@azure/logger": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@azure/logger/-/logger-1.0.3.tgz",
      "integrity": "sha512-aK4s3Xxjrx3daZr3VylxejK3vG5ExXck5WOHDJ8in/k9AqlfIyFMMT1uG7u8mNjX+QRILTIn0/Xgschfh/dQ9g==",
      "requires": {
        "tslib": "^2.2.0"
      }
    },
    "@ethersproject/abi": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abi/-/abi-5.7.0.tgz",
      "integrity": "sha512-351ktp42TiRcYB3H1OP8yajPeAQstMW/yCFokj/AthP9bLHzQFPlOrxOcwYEDkUAICmOHljvN4K39OMTMUa9RA==",
      "requires": {
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "@ethersproject/abstract-provider": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-provider/-/abstract-provider-5.7.0.tgz",
      "integrity": "sha512-R41c9UkchKCpAqStMYUpdunjo3pkEvZC3FAwZn5S5MGbXoMQOHIdHItezTETxAO5bevtMApSyEhn9+CHcDsWBw==",
      "requires": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/networks": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/web": "^5.7.0"
      }
    },
    "@ethersproject/abstract-signer": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/abstract-signer/-/abstract-signer-5.7.0.tgz",
      "integrity": "sha512-a16V8bq1/Cz+TGCkE2OPMTOUDLS3grCpdjoJCYNnVBbdYEMSgKrU0+B90s8b6H+ByYTBZN7a3g76jdIJi7UfKQ==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0"
      }
    },
    "@ethersproject/address": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/address/-/address-5.7.0.tgz",
      "integrity": "sha512-9wYhYt7aghVGo758POM5nqcOMaE168Q6aRLJZwUmiqSrAungkG74gSSeKEIR7ukixesdRZGPgVqme6vmxs1fkA==",
      "requires": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0"
      }
    },
    "@ethersproject/base64": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/base64/-/base64-5.7.0.tgz",
      "integrity": "sha512-Dr8tcHt2mEbsZr/mwTPIQAf3Ai0Bks/7gTw9dSqk1mQvhW3XvRlmDJr/4n+wg1JmCl16NZue17CDh8xb/vZ0sQ==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0"
      }
    },
    "@ethersproject/basex": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/basex/-/basex-5.7.0.tgz",
      "integrity": "sha512-ywlh43GwZLv2Voc2gQVTKBoVQ1mti3d8HK5aMxsfu/nRDnMmNqaSJ3r3n85HBByT8OpoY96SXM1FogC533T4zw==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/properties": "^5.7.0"
      }
    },
    "@ethersproject/bignumber": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/bignumber/-/bignumber-5.7.0.tgz",
      "integrity": "sha512-n1CAdIHRWjSucQO3MC1zPSVgV/6dy/fjL9pMrPP9peL+QxEg9wOsVqwD4+818B6LUEtaXzVHQiuivzRoxPxUGw==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "bn.js": "^5.2.1"
      }
    },
    "@ethersproject/bytes": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/bytes/-/bytes-5.7.0.tgz",
      "integrity": "sha512-nsbxwgFXWh9NyYWo+U8atvmMsSdKJprTcICAkvbBffT75qDocbuggBU0SJiVK2MuTrp0q+xvLkTnGMPK1+uA9A==",
      "requires": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/constants": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/constants/-/constants-5.7.0.tgz",
      "integrity": "sha512-DHI+y5dBNvkpYUMiRQyxRBYBefZkJfo70VUkUAsRjcPs47muV9evftfZ0PJVCXYbAiCgght0DtcF9srFQmIgWA==",
      "requires": {
        "@ethersproject/bignumber": "^5.7.0"
      }
    },
    "@ethersproject/contracts": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/contracts/-/contracts-5.7.0.tgz",
      "integrity": "sha512-5GJbzEU3X+d33CdfPhcyS+z8MzsTrBGk/sc+G+59+tPa9yFkl6HQ9D6L0QMgNTA9q8dT0XKxxkyp883XsQvbbg==",
      "requires": {
        "@ethersproject/abi": "^5.7.0",
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0"
      }
    },
    "@ethersproject/hash": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/hash/-/hash-5.7.0.tgz",
      "integrity": "sha512-qX5WrQfnah1EFnO5zJv1v46a8HW0+E5xuBBDTwMFZLuVTx0tbU2kkx15NqdjxecrLGatQN9FGQKpb1FKdHCt+g==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "@ethersproject/hdnode": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/hdnode/-/hdnode-5.7.0.tgz",
      "integrity": "sha512-OmyYo9EENBPPf4ERhR7oj6uAtUAhYGqOnIS+jE5pTXvdKBS99ikzq1E7Iv0ZQZ5V36Lqx1qZLeak0Ra16qpeOg==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/basex": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/pbkdf2": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/wordlists": "^5.7.0"
      }
    },
    "@ethersproject/json-wallets": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/json-wallets/-/json-wallets-5.7.0.tgz",
      "integrity": "sha512-8oee5Xgu6+RKgJTkvEMl2wDgSPSAQ9MB/3JYjFV9jlKvcYHUXZC+cQp0njgmxdHkYWn8s6/IqIZYm0YWCjO/0g==",
      "requires": {
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hdnode": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/pbkdf2": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "aes-js": "3.0.0",
        "scrypt-js": "3.0.1"
      }
    },
    "@ethersproject/keccak256": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/keccak256/-/keccak256-5.7.0.tgz",
      "integrity": "sha512-2UcPboeL/iW+pSg6vZ6ydF8tCnv3Iu/8tUmLLzWWGzxWKFFqOBQFLo6uLUv6BDrLgCDfN28RJ/wtByx+jZ4KBg==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "js-sha3": "0.8.0"
      }
    },
    "@ethersproject/logger": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/logger/-/logger-5.7.0.tgz",
      "integrity": "sha512-0odtFdXu/XHtjQXJYA3u9G0G8btm0ND5Cu8M7i5vhEcE8/HmF4Lbdqanwyv4uQTr2tx6b7fQRmgLrsnpQlmnig=="
    },
    "@ethersproject/networks": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/networks/-/networks-5.7.1.tgz",
      "integrity": "sha512-n/MufjFYv3yFcUyfhnXotyDlNdFb7onmkSy8aQERi2PjNcnWQ66xXxa3XlS8nCcA8aJKJjIIMNJTC7tu80GwpQ==",
      "requires": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/pbkdf2": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/pbkdf2/-/pbkdf2-5.7.0.tgz",
      "integrity": "sha512-oR/dBRZR6GTyaofd86DehG72hY6NpAjhabkhxgr3X2FpJtJuodEl2auADWBZfhDHgVCbu3/H/Ocq2uC6dpNjjw==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0"
      }
    },
    "@ethersproject/properties": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/properties/-/properties-5.7.0.tgz",
      "integrity": "sha512-J87jy8suntrAkIZtecpxEPxY//szqr1mlBaYlQ0r4RCaiD2hjheqF9s1LVE8vVuJCXisjIP+JgtK/Do54ej4Sw==",
      "requires": {
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/providers": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/@ethersproject/providers/-/providers-5.7.2.tgz",
      "integrity": "sha512-g34EWZ1WWAVgr4aptGlVBF8mhl3VWjv+8hoAnzStu8Ah22VHBsuGzP17eb6xDVRzw895G4W7vvx60lFFur/1Rg==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/basex": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/networks": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/strings": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/web": "^5.7.0",
        "bech32": "1.1.4",
        "ws": "7.4.6"
      }
    },
    "@ethersproject/random": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/random/-/random-5.7.0.tgz",
      "integrity": "sha512-19WjScqRA8IIeWclFme75VMXSBvi4e6InrUNuaR4s5pTF2qNhcGdCUwdxUVGtDDqC00sDLCO93jPQoDUH4HVmQ==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/rlp": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/rlp/-/rlp-5.7.0.tgz",
      "integrity": "sha512-rBxzX2vK8mVF7b0Tol44t5Tb8gomOHkj5guL+HhzQ1yBh/ydjGnpw6at+X6Iw0Kp3OzzzkcKp8N9r0W4kYSs9w==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/sha2": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/sha2/-/sha2-5.7.0.tgz",
      "integrity": "sha512-gKlH42riwb3KYp0reLsFTokByAKoJdgFCwI+CCiX/k+Jm2mbNs6oOaCjYQSlI1+XBVejwH2KrmCbMAT/GnRDQw==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "hash.js": "1.1.7"
      }
    },
    "@ethersproject/signing-key": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/signing-key/-/signing-key-5.7.0.tgz",
      "integrity": "sha512-MZdy2nL3wO0u7gkB4nA/pEf8lu1TlFswPNmy8AiYkfKTdO6eXBJyUdmHO/ehm/htHw9K/qF8ujnTyUAD+Ry54Q==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "bn.js": "^5.2.1",
        "elliptic": "6.5.4",
        "hash.js": "1.1.7"
      }
    },
    "@ethersproject/solidity": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/solidity/-/solidity-5.7.0.tgz",
      "integrity": "sha512-HmabMd2Dt/raavyaGukF4XxizWKhKQ24DoLtdNbBmNKUOPqwjsKQSdV9GQtj9CBEea9DlzETlVER1gYeXXBGaA==",
      "requires": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/sha2": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "@ethersproject/strings": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/strings/-/strings-5.7.0.tgz",
      "integrity": "sha512-/9nu+lj0YswRNSH0NXYqrh8775XNyEdUQAuf3f+SmOrnVewcJ5SBNAjF7lpgehKi4abvNNXyf+HX86czCdJ8Mg==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/transactions": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/transactions/-/transactions-5.7.0.tgz",
      "integrity": "sha512-kmcNicCp1lp8qanMTC3RIikGgoJ80ztTyvtsFvCYpSCfkjhD0jZ2LOrnbcuxuToLIUYYf+4XwD1rP+B/erDIhQ==",
      "requires": {
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/rlp": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0"
      }
    },
    "@ethersproject/units": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/units/-/units-5.7.0.tgz",
      "integrity": "sha512-pD3xLMy3SJu9kG5xDGI7+xhTEmGXlEqXU4OfNapmfnxLVY4EMSSRp7j1k7eezutBPH7RBN/7QPnwR7hzNlEFeg==",
      "requires": {
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/constants": "^5.7.0",
        "@ethersproject/logger": "^5.7.0"
      }
    },
    "@ethersproject/wallet": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/wallet/-/wallet-5.7.0.tgz",
      "integrity": "sha512-MhmXlJXEJFBFVKrDLB4ZdDzxcBxQ3rLyCkhNqVu3CDYvR97E+8r01UgrI+TI99Le+aYm/in/0vp86guJuM7FCA==",
      "requires": {
        "@ethersproject/abstract-provider": "^5.7.0",
        "@ethersproject/abstract-signer": "^5.7.0",
        "@ethersproject/address": "^5.7.0",
        "@ethersproject/bignumber": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/hdnode": "^5.7.0",
        "@ethersproject/json-wallets": "^5.7.0",
        "@ethersproject/keccak256": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/random": "^5.7.0",
        "@ethersproject/signing-key": "^5.7.0",
        "@ethersproject/transactions": "^5.7.0",
        "@ethersproject/wordlists": "^5.7.0"
      }
    },
    "@ethersproject/web": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/@ethersproject/web/-/web-5.7.1.tgz",
      "integrity": "sha512-Gueu8lSvyjBWL4cYsWsjh6MtMwM0+H4HvqFPZfB6dV8ctbP9zFAO73VG1cMWae0FLPCtz0peKPpZY8/ugJJX2w==",
      "requires": {
        "@ethersproject/base64": "^5.7.0",
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "@ethersproject/wordlists": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/@ethersproject/wordlists/-/wordlists-5.7.0.tgz",
      "integrity": "sha512-S2TFNJNfHWVHNE6cNDjbVlZ6MgE17MIxMbMg2zv3wn+3XSJGosL1m9ZVv3GXCf/2ymSsQ+hRI5IzoMJTG6aoVA==",
      "requires": {
        "@ethersproject/bytes": "^5.7.0",
        "@ethersproject/hash": "^5.7.0",
        "@ethersproject/logger": "^5.7.0",
        "@ethersproject/properties": "^5.7.0",
        "@ethersproject/strings": "^5.7.0"
      }
    },
    "@tootallnate/once": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/@tootallnate/once/-/once-2.0.0.tgz",
      "integrity": "sha512-XCuKFP5PS55gnMVu3dty8KPatLqUoy/ZYzDzAGCQ8JNFCkLXzmI7vNHCR+XpbZaMWQK/vQubr7PkYq8g470J/A=="
    },
    "@types/body-parser": {
      "version": "1.19.2",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.2.tgz",
      "integrity": "sha512-ALYone6pm6QmwZoAgeyNksccT9Q4AWZQ6PvfwR37GT6r6FWUPguq6sUmNGSMV2Wr761oQoBxwGGa6DR5o1DC9g==",
      "requires": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "@types/connect": {
      "version": "3.4.35",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.35.tgz",
      "integrity": "sha512-cdeYyv4KWoEgpBISTxWvqYsVy444DOqehiF3fM3ne10AmJ62RSyNkUnxMJXHQWRQQX2eR94m5y1IZyDwBjV9FQ==",
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/express": {
      "version": "4.17.16",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.16.tgz",
      "integrity": "sha512-LkKpqRZ7zqXJuvoELakaFYuETHjZkSol8EV6cNnyishutDBCCdv6+dsKPbKkCcIk57qRphOLY5sEgClw1bO3gA==",
      "requires": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.31",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "@types/express-serve-static-core": {
      "version": "4.17.33",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.17.33.tgz",
      "integrity": "sha512-TPBqmR/HRYI3eC2E5hmiivIzv+bidAfXofM+sbonAGvyDhySGw9/PQZFt2BLOrjUUR++4eJVpx6KnLQK1Fk9tA==",
      "requires": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*"
      }
    },
    "@types/jsonwebtoken": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.1.tgz",
      "integrity": "sha512-c5ltxazpWabia/4UzhIoaDcIza4KViOQhdbjRlfcIGVnsE3c3brkz9Z+F/EeJIECOQP7W7US2hNE930cWWkPiw==",
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/mime": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-3.0.1.tgz",
      "integrity": "sha512-Y4XFY5VJAuw0FgAqPNd6NNoV44jbq9Bz2L7Rh/J6jLTiHBSBJa9fxqQIvkIld4GsoDOcCbvzOUAbLPsSKKg+uA=="
    },
    "@types/node": {
      "version": "18.11.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.11.11.tgz",
      "integrity": "sha512-KJ021B1nlQUBLopzZmPBVuGU9un7WJd/W4ya7Ih02B4Uwky5Nja0yGYav2EfYIk0RR2Q9oVhf60S2XR1BCWJ2g=="
    },
    "@types/qs": {
      "version": "6.9.7",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.7.tgz",
      "integrity": "sha512-FGa1F62FT09qcrueBA6qYTrJPVDzah9a+493+o2PCXsesWHIn27G98TsSMs3WPNbZIEj4+VJf6saSFpvD+3Zsw=="
    },
    "@types/range-parser": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.4.tgz",
      "integrity": "sha512-EEhsLsD6UsDM1yFhAvy0Cjr6VwmpMWqFBCb9w07wVugF7w9nfajxLuVmngTIpgS6svCnm6Vaw+MZhoDCKnOfsw=="
    },
    "@types/serve-static": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.0.tgz",
      "integrity": "sha512-z5xyF6uh8CbjAu9760KDKsH2FcDxZ2tFCsA4HIMWE6IkiYMXfVoa+4f9KX+FN0ZLsaMw1WNG2ETLA6N+/YA+cg==",
      "requires": {
        "@types/mime": "*",
        "@types/node": "*"
      }
    },
    "aes-js": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/aes-js/-/aes-js-3.0.0.tgz",
      "integrity": "sha512-H7wUZRn8WpTq9jocdxQ2c8x2sKo9ZVmzfRE13GiNJXfp7NcKYEdvl3vspKjXox6RIG2VtaRe4JFvxG4rqp2Zuw=="
    },
    "agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "requires": {
        "debug": "4"
      }
    },
    "ar-gql": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/ar-gql/-/ar-gql-0.0.6.tgz",
      "integrity": "sha512-eXKsXGQcx8uwxwlFJzBXA17Qsg+Gty6tcp85IB5SX1iop7NsXLQ/iH2WEz69NCz2/Zcb81C1QryIiNTgw0/4aA==",
      "requires": {
        "axios": "^0.21.1"
      }
    },
    "arconnect": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/arconnect/-/arconnect-0.4.2.tgz",
      "integrity": "sha512-Jkpd4QL3TVqnd3U683gzXmZUVqBUy17DdJDuL/3D9rkysLgX6ymJ2e+sR+xyZF5Rh42CBqDXWNMmCjBXeP7Gbw==",
      "requires": {
        "arweave": "^1.10.13"
      }
    },
    "arweave": {
      "version": "1.11.8",
      "resolved": "https://registry.npmjs.org/arweave/-/arweave-1.11.8.tgz",
      "integrity": "sha512-58ODeNPIC4OjaOCl2bXjKbOFGsiVZFs+DkQg3BvQGvFWNqw1zTJ4Jp01xGUz+GbdOaDyJcCC0g3l0HwdJfFPyw==",
      "requires": {
        "arconnect": "^0.4.2",
        "asn1.js": "^5.4.1",
        "axios": "^0.27.2",
        "base64-js": "^1.5.1",
        "bignumber.js": "^9.0.2",
        "util": "^0.12.4"
      },
      "dependencies": {
        "axios": {
          "version": "0.27.2",
          "resolved": "https://registry.npmjs.org/axios/-/axios-0.27.2.tgz",
          "integrity": "sha512-t+yRIyySRTp/wua5xEr+z1q60QmLq8ABsS5O9Me1AsE5dfKqgnCFzwiCZZ/cGNd1lq4/7akDWMxdhVlucjmnOQ==",
          "requires": {
            "follow-redirects": "^1.14.9",
            "form-data": "^4.0.0"
          }
        }
      }
    },
    "arweave-multihost": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/arweave-multihost/-/arweave-multihost-0.1.0.tgz",
      "integrity": "sha512-biIkzQ3oc4RLV1MORQnqWz51IazP++K/8SsYMjUokK0cUfBLqom4pufKFCjTkGQIZMWWanXxnZqL66hHPgTCgA==",
      "requires": {
        "arweave": "^1.10.15",
        "axios": "^0.21.1"
      }
    },
    "asn1.js": {
      "version": "5.4.1",
      "resolved": "https://registry.npmjs.org/asn1.js/-/asn1.js-5.4.1.tgz",
      "integrity": "sha512-+I//4cYPccV8LdmBLiX8CYvf9Sp3vQsrqu2QNXRcrbiWvcx/UdlFiqUJJzxRQxgsZmvhXhn4cSKeSmoFjVdupA==",
      "requires": {
        "bn.js": "^4.0.0",
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0",
        "safer-buffer": "^2.1.0"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.12.0",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
          "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
        }
      }
    },
    "asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "available-typed-arrays": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz",
      "integrity": "sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw=="
    },
    "axios": {
      "version": "0.21.4",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.21.4.tgz",
      "integrity": "sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==",
      "requires": {
        "follow-redirects": "^1.14.0"
      }
    },
    "base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA=="
    },
    "bech32": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/bech32/-/bech32-1.1.4.tgz",
      "integrity": "sha512-s0IrSOzLlbvX7yp4WBfPITzpAU8sqQcpsmwXDiKwrG4r491vwCO/XpejasRNl0piBMe/DvP4Tz0mIS/X1DPJBQ=="
    },
    "bignumber.js": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.1.0.tgz",
      "integrity": "sha512-4LwHK4nfDOraBCtst+wOWIHbu1vhvAPJK8g8nROd4iuc3PSEjWif/qwbkh8jwCJz6yDBvtU4KPynETgrfh7y3A=="
    },
    "bn.js": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.1.tgz",
      "integrity": "sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ=="
    },
    "borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "requires": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w=="
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA=="
    },
    "call-bind": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
      "requires": {
        "function-bind": "^1.1.1",
        "get-intrinsic": "^1.0.2"
      }
    },
    "capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha512-rsJZYVCgXd08sPqwmaIqjAd5SUTfonV0z/gDJ8D6cN8wQphky1kkAYEqQ+hmDxTw7UihvBfjUVUSY+DBEe44jg=="
    },
    "combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "requires": {
        "delayed-stream": "~1.0.0"
      }
    },
    "debug": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
      "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
      "requires": {
        "ms": "2.1.2"
      }
    },
    "deep-sort-object": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/deep-sort-object/-/deep-sort-object-1.0.2.tgz",
      "integrity": "sha512-Ko2XVMhRhz5Mxyb+QhLX13SHgcK1vuxc6XEfOyTMlbRbv7bhSmMqUw4ywqRwKgV25W+FDIaZjPWQrdblHCTwdA==",
      "requires": {
        "is-plain-object": "^2.0.1"
      }
    },
    "delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ=="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw=="
    },
    "ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "elliptic": {
      "version": "6.5.4",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
      "integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
      "requires": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.12.0",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.0.tgz",
          "integrity": "sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA=="
        }
      }
    },
    "error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "requires": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "ethers": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/ethers/-/ethers-5.7.2.tgz",
      "integrity": "sha512-wswUsmWo1aOK8rR7DIKiWSw9DbLWe6x98Jrn8wcTflTVvaXhAMaB5zGAXy0GYQEQp9iO1iSHWVyARQm11zUtyg==",
      "requires": {
        "@ethersproject/abi": "5.7.0",
        "@ethersproject/abstract-provider": "5.7.0",
        "@ethersproject/abstract-signer": "5.7.0",
        "@ethersproject/address": "5.7.0",
        "@ethersproject/base64": "5.7.0",
        "@ethersproject/basex": "5.7.0",
        "@ethersproject/bignumber": "5.7.0",
        "@ethersproject/bytes": "5.7.0",
        "@ethersproject/constants": "5.7.0",
        "@ethersproject/contracts": "5.7.0",
        "@ethersproject/hash": "5.7.0",
        "@ethersproject/hdnode": "5.7.0",
        "@ethersproject/json-wallets": "5.7.0",
        "@ethersproject/keccak256": "5.7.0",
        "@ethersproject/logger": "5.7.0",
        "@ethersproject/networks": "5.7.1",
        "@ethersproject/pbkdf2": "5.7.0",
        "@ethersproject/properties": "5.7.0",
        "@ethersproject/providers": "5.7.2",
        "@ethersproject/random": "5.7.0",
        "@ethersproject/rlp": "5.7.0",
        "@ethersproject/sha2": "5.7.0",
        "@ethersproject/signing-key": "5.7.0",
        "@ethersproject/solidity": "5.7.0",
        "@ethersproject/strings": "5.7.0",
        "@ethersproject/transactions": "5.7.0",
        "@ethersproject/units": "5.7.0",
        "@ethersproject/wallet": "5.7.0",
        "@ethersproject/web": "5.7.1",
        "@ethersproject/wordlists": "5.7.0"
      }
    },
    "fast-xml-parser": {
      "version": "4.0.11",
      "resolved": "https://registry.npmjs.org/fast-xml-parser/-/fast-xml-parser-4.0.11.tgz",
      "integrity": "sha512-4aUg3aNRR/WjQAcpceODG1C3x3lFANXRo8+1biqfieHmg9pyMt7qB4lQV/Ta6sJCTbA5vfD8fnA8S54JATiFUA==",
      "requires": {
        "strnum": "^1.0.5"
      }
    },
    "follow-redirects": {
      "version": "1.15.2",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.2.tgz",
      "integrity": "sha512-VQLG33o04KaQ8uYi2tVNbdrWp1QWxNNea+nmIB4EVM28v0hmP17z7aG1+wAkNzVq4KeXTq3221ye5qTJP91JwA=="
    },
    "for-each": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz",
      "integrity": "sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==",
      "requires": {
        "is-callable": "^1.1.3"
      }
    },
    "form-data": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz",
      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",
      "requires": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      }
    },
    "function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
    },
    "get-intrinsic": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
      "requires": {
        "function-bind": "^1.1.1",
        "has": "^1.0.3",
        "has-symbols": "^1.0.3"
      }
    },
    "gopd": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
      "requires": {
        "get-intrinsic": "^1.1.3"
      }
    },
    "has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "requires": {
        "function-bind": "^1.1.1"
      }
    },
    "has-symbols": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A=="
    },
    "has-tostringtag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz",
      "integrity": "sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==",
      "requires": {
        "has-symbols": "^1.0.2"
      }
    },
    "hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "requires": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "requires": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "dependencies": {
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ=="
        }
      }
    },
    "http-proxy-agent": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-5.0.0.tgz",
      "integrity": "sha512-n2hY8YdoRE1i7r6M0w9DIw5GgZN0G25P8zLCRQ8rjXtTU3vsNFBI/vWK/UIeE6g5MUUz6avwAPXmL6Fy9D/90w==",
      "requires": {
        "@tootallnate/once": "2",
        "agent-base": "6",
        "debug": "4"
      }
    },
    "https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "requires": {
        "agent-base": "6",
        "debug": "4"
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "is-arguments": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz",
      "integrity": "sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==",
      "requires": {
        "call-bind": "^1.0.2",
        "has-tostringtag": "^1.0.0"
      }
    },
    "is-callable": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA=="
    },
    "is-generator-function": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.0.10.tgz",
      "integrity": "sha512-jsEjy9l3yiXEQ+PsXdmBwEPcOxaXWLspKdplFUVI9vq1iZgIekeC0L167qeu86czQaxed3q/Uzuw0swL0irL8A==",
      "requires": {
        "has-tostringtag": "^1.0.0"
      }
    },
    "is-plain-object": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
      "requires": {
        "isobject": "^3.0.1"
      }
    },
    "is-typed-array": {
      "version": "1.1.10",
      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz",
      "integrity": "sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==",
      "requires": {
        "available-typed-arrays": "^1.0.5",
        "call-bind": "^1.0.2",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "has-tostringtag": "^1.0.0"
      }
    },
    "isobject": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
      "integrity": "sha512-WhB9zCku7EGTj/HQQRz5aUQEUeoQZH2bWcltRErOpymJ4boYE6wL9Tbr23krRPSZ+C5zqNSrSw+Cc7sZZ4b7vg=="
    },
    "jose": {
      "version": "4.11.2",
      "resolved": "https://registry.npmjs.org/jose/-/jose-4.11.2.tgz",
      "integrity": "sha512-njj0VL2TsIxCtgzhO+9RRobBvws4oYyCM8TpvoUQwl/MbIM3NFJRR9+e6x0sS5xXaP1t6OCBkaBME98OV9zU5A=="
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "js-sha3": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/js-sha3/-/js-sha3-0.8.0.tgz",
      "integrity": "sha512-gF1cRrHhIzNfToc802P800N8PpXS+evLLXfsVpowqmAFR9uwbi89WvXg2QspOmXL8QL86J4T1EpFu+yUkwJY3Q=="
    },
    "jsonwebtoken": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.0.tgz",
      "integrity": "sha512-tuGfYXxkQGDPnLJ7SibiQgVgeDgfbPq2k2ICcbgqW8WxWLBAxKQM/ZCu/IT8SOSwmaYl4dpTFCW5xZv7YbbWUw==",
      "requires": {
        "jws": "^3.2.2",
        "lodash": "^4.17.21",
        "ms": "^2.1.1",
        "semver": "^7.3.8"
      }
    },
    "jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "requires": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "jwks-rsa": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/jwks-rsa/-/jwks-rsa-3.0.1.tgz",
      "integrity": "sha512-UUOZ0CVReK1QVU3rbi9bC7N5/le8ziUj0A2ef1Q0M7OPD2KvjEYizptqIxGIo6fSLYDkqBrazILS18tYuRc8gw==",
      "requires": {
        "@types/express": "^4.17.14",
        "@types/jsonwebtoken": "^9.0.0",
        "debug": "^4.3.4",
        "jose": "^4.10.4",
        "limiter": "^1.1.5",
        "lru-memoizer": "^2.1.4"
      }
    },
    "jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "requires": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "limiter": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/limiter/-/limiter-1.1.5.tgz",
      "integrity": "sha512-FWWMIEOxz3GwUI4Ts/IvgVy6LPvoMPgjMdQ185nN6psJyBJ4yOpzqm695/h5umdLJg2vW3GR5iG11MAkR2AzJA=="
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "lodash.clonedeep": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
      "integrity": "sha512-H5ZhCF25riFd9uB5UCkVKo61m3S/xZk1x4wA6yp/L3RFP6Z/eHH1ymQcGLo7J3GMPfm0V/7m1tryHuGVxpqEBQ=="
    },
    "lru-cache": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-4.0.2.tgz",
      "integrity": "sha512-uQw9OqphAGiZhkuPlpFGmdTU2tEuhxTourM/19qGJrxBPHAr/f8BT1a0i/lOclESnGatdJG/UCkP9kZB/Lh1iw==",
      "requires": {
        "pseudomap": "^1.0.1",
        "yallist": "^2.0.0"
      }
    },
    "lru-memoizer": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/lru-memoizer/-/lru-memoizer-2.1.4.tgz",
      "integrity": "sha512-IXAq50s4qwrOBrXJklY+KhgZF+5y98PDaNo0gi/v2KQBFLyWr+JyFvijZXkGKjQj/h9c0OwoE+JZbwUXce76hQ==",
      "requires": {
        "lodash.clonedeep": "^4.5.0",
        "lru-cache": "~4.0.0"
      }
    },
    "mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="
    },
    "mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "requires": {
        "mime-db": "1.52.0"
      }
    },
    "minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A=="
    },
    "minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg=="
    },
    "ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ=="
    },
    "near-api-js": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-1.1.0.tgz",
      "integrity": "sha512-qYKv1mYsaDZc2uYndhS+ttDhR9+60qFc+ZjD6lWsAxr3ZskMjRwPffDGQZYhC7BRDQMe1HEbk6d5mf+TVm0Lqg==",
      "requires": {
        "bn.js": "5.2.1",
        "borsh": "^0.7.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "requires": {
        "whatwg-url": "^5.0.0"
      }
    },
    "o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha512-f+4n+vC6s4ysy7YO7O2gslWZBUu8Qj2i2OUJOvjRxQva7jVjYjB29jrr9NCjmxZQR0gzrOcv1RnqoYOeMs5VRQ==",
      "requires": {
        "capability": "^0.2.5"
      }
    },
    "pako": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/pako/-/pako-2.1.0.tgz",
      "integrity": "sha512-w+eufiZ1WuJYgPXbV/PO3NCMEc3xqylkKHzp8bxp1uW4qaSNQUkwmLLEc3kKsfz8lpV1F8Ht3U1Cm+9Srog2ug=="
    },
    "pseudomap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/pseudomap/-/pseudomap-1.0.2.tgz",
      "integrity": "sha512-b/YwNhb8lk1Zz2+bXXpS/LK9OisiZZ1SNsSLxN1x2OXVEhW2Ckr/7mWE5vrC1ZTiJlD9g19jWszTmJsB+oEpFQ=="
    },
    "redstone-api": {
      "version": "0.4.11",
      "resolved": "https://registry.npmjs.org/redstone-api/-/redstone-api-0.4.11.tgz",
      "integrity": "sha512-X0gj7UU5aLQPmNjdnhBUCvi6tkj5SpQJ7heT6+TIPx7Od707n4oqKHoJa41V8QOGjudbxaM1BIv6+2+hp0wFGQ==",
      "requires": {
        "ar-gql": "^0.0.6",
        "arweave": "^1.10.16",
        "arweave-multihost": "^0.1.0",
        "axios": "^0.21.1",
        "deep-sort-object": "^1.0.2",
        "lodash": "^4.17.21",
        "pako": "^2.0.3"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "scrypt-js": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/scrypt-js/-/scrypt-js-3.0.1.tgz",
      "integrity": "sha512-cdwTTnqPu0Hyvf5in5asVdZocVDTNRmR7XEcJuIzMjJeSHybHl7vpB66AzwTaIg6CLSbtjcxc8fqcySfnTkccA=="
    },
    "semver": {
      "version": "7.3.8",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
      "requires": {
        "lru-cache": "^6.0.0"
      },
      "dependencies": {
        "lru-cache": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
          "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
          "requires": {
            "yallist": "^4.0.0"
          }
        },
        "yallist": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
          "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
        }
      }
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha512-OpZ3zP+jT1PI7I8nemJX4AKmAX070ZkYPVWV/AaKTJl+tXCTGyVdC1a4SL8RUQYEwk/f34ZX8UTykN68FwrqAA=="
    },
    "strnum": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/strnum/-/strnum-1.0.5.tgz",
      "integrity": "sha512-J8bbNyKKXl5qYcR36TIO8W3mVGVHrmmxsd5PAItGkmyzwJvybiw2IVq5nqd0i4LSNSkB/sx9VHllbfFdr9k1JA=="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA=="
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "tslib": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
      "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ=="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "util": {
      "version": "0.12.5",
      "resolved": "https://registry.npmjs.org/util/-/util-0.12.5.tgz",
      "integrity": "sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==",
      "requires": {
        "inherits": "^2.0.3",
        "is-arguments": "^1.0.4",
        "is-generator-function": "^1.0.7",
        "is-typed-array": "^1.1.3",
        "which-typed-array": "^1.1.2"
      }
    },
    "uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg=="
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "which-typed-array": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz",
      "integrity": "sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==",
      "requires": {
        "available-typed-arrays": "^1.0.5",
        "call-bind": "^1.0.2",
        "for-each": "^0.3.3",
        "gopd": "^1.0.1",
        "has-tostringtag": "^1.0.0",
        "is-typed-array": "^1.1.10"
      }
    },
    "ws": {
      "version": "7.4.6",
      "resolved": "https://registry.npmjs.org/ws/-/ws-7.4.6.tgz",
      "integrity": "sha512-YmhHDO4MzaDLB+M9ym/mDA5z0naX8j7SIlT8f8z+I0VtzsRbekxEutHSme7NPS2qE8StCYQNUnfWdXta/Yu85A==",
      "requires": {}
    },
    "yallist": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-2.1.2.tgz",
      "integrity": "sha512-ncTzHV7NvsQZkYe1DW7cbDLm0YpzHmZF5r/iyP3ZnQtMiJ+pjzisCiMNI+Sj+xQF5pXhSHxSB3uDbsBTzY/c2A=="
    }
  }
}

'''
'''--- Toolblox.Ada.App.Blockchain.Functions/package.json ---
{
  "name": "toolblox.ada.app.blockchain.functions",
  "version": "1.0.0",
  "description": "",
  "scripts": {
    "build": "tsc",
    "watch": "tsc -w",
    "prestart": "npm run build",
    "start": "func start",
    "test": "echo \"No tests yet...\""
  },
  "dependencies": {
    "@azure/data-tables": "^13.2.0",
    "ethers": "^5.7.2",
    "jsonwebtoken": "^9.0.0",
    "jwks-rsa": "^3.0.1",
    "near-api-js": "^1.1.0",
    "redstone-api": "^0.4.11"
  },
  "devDependencies": {
    "@azure/functions": "^3.0.0",
    "@types/node": "^18.11.10"
  }
}

'''
'''--- Toolblox.Ada.App.Blockchain.Functions/tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es6",
    "outDir": "dist",
    "rootDir": ".",
    "sourceMap": true,
    "strict": false
  }
}
'''
'''--- Toolblox.Ada.App.Functions/AccountantFunctions.cs ---
using Azure.Data.Tables;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using Toolblox.Ada.App.Functions.Helpers;
using Toolblox.Ada.App.Functions.Services;
using Toolblox.Ada.App.Model;
using Toolblox.Cryptography;
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;

namespace Toolblox.Ada.App.Functions
{
    public class AccountantFunctions
    {
	    [FunctionName("Accountants")]
        public static async Task<IActionResult> Accountants(
            [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = "Accountant/List")] HttpRequestMessage req,
            [Table("Invoices")] TableClient invoiceTable,
            [Table("Accountants")] TableClient todoTable,
            ILogger log)
        {
            log.LogInformation("C# HTTP trigger function processed a request.");
            var userId = await Security.GetUser(req, false);
            var filter = !string.IsNullOrWhiteSpace(userId)
                ? $"PartitionKey eq '{userId.Sanitize()}' or (IsPublic and IsDeployed)"
                : $"IsPublic and IsDeployed";

            var pages = await todoTable.QueryAsync<TableEntity>(filter: filter).AsPages().ToListAsync();
            var accountants = pages.SelectMany(x => x.Values).Select(TableEntityExtensions.ToAccountant).ToList();

            var invoices = await invoiceTable.QueryAsync<TableEntity>(select: new List<string> { "PartitionKey" }).ToListAsync();
            var invoiceCounts = invoices
	            .ToLookup(x => x.GetString("PartitionKey"));

            foreach (var accountant in accountants.Where(x => x.IsActive))
            {
	            accountant.InvoiceCount = invoiceCounts[accountant.Contract].Count() +
	                                      (accountant.Workflow != accountant.Contract ? invoiceCounts[accountant.Workflow].Count() : 0);
            }

            return new SystemTextJsonResult(accountants);
        }

        [FunctionName("UpsertAccountant")]
        public static async Task<IActionResult> UpsertAccountant(
            [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "Accountant/Upsert")] HttpRequestMessage req,
            [Table("Accountants")] TableClient todoTable,
            ILogger log)
        {
            dynamic body = await req.Content.ReadAsStringAsync();
            var serializerOptions = new JsonSerializerOptions().ConfigureAdaDtoInheritance();
            var accountant = JsonSerializer.Deserialize<Accountant>(body as string, serializerOptions);
            var userId = await Security.GetUser(req);
            if (string.IsNullOrWhiteSpace(accountant.User) || accountant.User != userId)
            {
                //check if not exist already
                var existingAccountant = await todoTable.QueryAsync<TableEntity>(filter: $"RowKey eq '{accountant.Id.Sanitize()}'").FirstOrDefaultAsync();
                if (existingAccountant != null && existingAccountant.PartitionKey != userId)
                {
                    throw new Exception("Accountant already exists");
                }
            }
            var entity = new TableEntity(userId, accountant.Id.ToString())
			{
				{ "IsDeployed", accountant.IsDeployed },
				{ "AddressBookUrl", accountant.AddressBookUrl },
				{ "IsActive", accountant.IsActive },
				{ "PublicKey", accountant.PublicKey },
				{ "NearTestnet", accountant.NearTestnet },
				{ "NearMainnet", accountant.NearMainnet },
				{ "Name", accountant.Name },
				{ "SelectedBlockchainKind", (int)accountant.SelectedBlockchainKind },
				{ "SelectedChain", (int)accountant.SelectedChain },
				{ "EditStep", (int)accountant.EditStep },
				{ "CreatedAt", accountant.CreatedAt != DateTimeOffset.MinValue ? accountant.CreatedAt : DateTimeOffset.Now },
				{ "ActivatedAt", accountant.ActivatedAt.HasValue && accountant.ActivatedAt != DateTimeOffset.MinValue ? accountant.ActivatedAt : null },
				{ "ModifiedAt", DateTimeOffset.Now },
				{ "DeployedAt", accountant.DeployedAt },
				{ "ContactInfo", accountant.ContactInfo },
				{ "Contract", accountant.Contract },
				{ "Workflow", accountant.Workflow },
				{ "Logo", accountant.Logo },
				{ "ProcessFee", accountant.ProcessFee },
				{ "Tasks", JsonSerializer.Serialize(accountant.Tasks, serializerOptions) },
				{ "AddressBookAccessRights", JsonSerializer.Serialize(accountant.AddressBookAccessRights, serializerOptions) },
			};
            todoTable.UpsertEntity(entity);
            return new OkObjectResult("OK");
		}

        [FunctionName("DeleteAccountant")]
        public static async Task<IActionResult> DeleteAccountant(
	        [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "Accountant/Delete")] HttpRequestMessage req,
	        [Table("Accountants")] TableClient todoTable,
	        ILogger log)
        {
	        var query = req.RequestUri.ParseQueryString();
	        var id = query.Get("id");
	        var userId = await Security.GetUser(req);
	        var tableEntity = await todoTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{userId.Sanitize()}' and RowKey eq '{id.Sanitize()}'").FirstOrDefaultAsync();
	        if (tableEntity == null)
	        {
		        return new NotFoundObjectResult(null);
	        }
	        await todoTable.DeleteEntityAsync(tableEntity.PartitionKey, tableEntity.RowKey);
	        return new OkObjectResult("OK");
		}

        [FunctionName("GeneratePublicKey")]
        public static async Task<IActionResult> GeneratePublicKey(
	        [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "Accountant/GeneratePublicKey")] HttpRequestMessage req,
	        [Table("Accountants")] TableClient todoTable,
	        ILogger log)
        {
	        var query = req.RequestUri.ParseQueryString();
	        var id = query.Get("id");
	        var userId = await Security.GetUser(req);
	        var tableEntity = await todoTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{userId.Sanitize()}' and RowKey eq '{id.Sanitize()}'").FirstOrDefaultAsync();
	        if (tableEntity == null)
	        {
		        return new NotFoundObjectResult(null);
			}
			var newKeyPair = new Mnemonic().GetKeyPair(id);
			var client = new SecretClient(vaultUri: new Uri("https://adaaddressbookkeys.vault.azure.net/"), credential: new DefaultAzureCredential());
			await client.SetSecretAsync(new KeyVaultSecret($"ada{id}".Replace("-", ""), newKeyPair.Serialize()));
			return new OkObjectResult(newKeyPair.PublicKey);
        }

		[FunctionName("AccountantById")]
        public static async Task<IActionResult> AccountantById(
            [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = "Accountant/GetById")] HttpRequestMessage req,
            [Table("Accountants")] TableClient todoTable,
            ILogger log)
        {
            var query = req.RequestUri.ParseQueryString();
            var id = query.Get("id");
            var tableEntity = await todoTable.QueryAsync<TableEntity>(filter: $"RowKey eq '{id.Sanitize()}'").FirstOrDefaultAsync();
            var workflowMetadata = tableEntity.ToAccountant();
            if (workflowMetadata == null)
            {
                return new EmptyResult();
            }
            return new SystemTextJsonResult(workflowMetadata);
		}

        [FunctionName("UploadLogo")]
        public static async Task<IActionResult> UploadLogo(
	        [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "UploadLogo")] HttpRequestMessage req,
	        [Table("Accountants")] TableClient todoTable,
			ILogger log)
        {
	        log.LogInformation("C# HTTP trigger function processed a request.");
	        var query = req.RequestUri.ParseQueryString();
			var id = query.Get("id");
			var userId = await Security.GetUser(req);
			var tableEntity = await todoTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{userId.Sanitize()}' and RowKey eq '{id.Sanitize()}'").FirstOrDefaultAsync();
			if (tableEntity == null)
			{
				return new NotFoundObjectResult(null);
			}
			var blobConnection = Environment.GetEnvironmentVariable("AzureWebJobsStorage");

	        var content = await req.Content.ReadAsMultipartAsync();

	        if (content.Contents.Count != 1 || content.Contents[0].Headers.ContentDisposition == null)
	        {
		        throw new ArgumentException("Content headers");
	        }
	        var fileName = content.Contents[0].Headers.ContentDisposition.FileName;
			var blobClient = new BlobContainerClient(blobConnection, "ada-logos");
			await blobClient.CreateIfNotExistsAsync(PublicAccessType.Blob);
			var logoFileName = $"{id.Replace("-", "")}{Guid.NewGuid().ToString().Substring(0, 8)}{fileName}";
			var blob = blobClient.GetBlobClient(logoFileName);
			await blob.UploadAsync(await content.Contents[0].ReadAsStreamAsync(), overwrite: true);
			return new JsonResult(new { cid = blob.Uri.AbsoluteUri });
        }
	}
}

'''
'''--- Toolblox.Ada.App.Functions/Helpers/Sanitize.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Toolblox.Ada.App.Functions.Helpers
{
	internal static class StringExtensions
	{
		internal static string Sanitize(this string obj)
		{
			return obj == null ? null : obj.ToString().Replace("'", "");
		}
	}
}

'''
'''--- Toolblox.Ada.App.Functions/Helpers/TableEntityExtensions.cs ---
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text.Json;
using Azure.Data.Tables;
using Toolblox.Ada.App.Model;
using Toolblox.Model;

namespace Toolblox.Ada.App.Functions.Helpers
{
	public static class TableEntityExtensions
	{
		public static Accountant ToAccountant(this TableEntity tableEntity)
		{
			if (tableEntity == null)
			{
				return null;
			}
			var serializerOptions = new JsonSerializerOptions().ConfigureAdaDtoInheritance();
			var tasks = tableEntity.GetString("Tasks");
			var addressBookAccessRights = tableEntity.GetString("AddressBookAccessRights");
			return new Accountant
			{
				Name = tableEntity.GetString("Name"),
				NearMainnet = tableEntity.GetString("NearMainnet"),
				Contract = tableEntity.GetString("Contract"),
				Logo = tableEntity.GetString("Logo"),
				AddressBookUrl = tableEntity.GetString("AddressBookUrl"),
				ContactInfo = tableEntity.GetString("ContactInfo"),
				PublicKey = tableEntity.GetString("PublicKey"),
				NearTestnet = tableEntity.GetString("NearTestnet"),
				SelectedBlockchainKind = (BlockchainKind)tableEntity.GetInt32("SelectedBlockchainKind").GetValueOrDefault(),
				SelectedChain = (Blockchain)tableEntity.GetInt32("SelectedChain").GetValueOrDefault(),
				Id = Guid.TryParse(tableEntity.RowKey, out var id) ? id.ToString() : Guid.NewGuid().ToString(),
				User = tableEntity.PartitionKey,
				CreatedAt = tableEntity.GetDateTimeOffset("CreatedAt").GetValueOrDefault(),
				ModifiedAt = tableEntity.GetDateTimeOffset("ModifiedAt").GetValueOrDefault(),
				IsDeployed = tableEntity.GetBoolean("IsDeployed") ?? false,
				IsActive = tableEntity.GetBoolean("IsActive") ?? false,
				DeployedAt = tableEntity.GetDateTimeOffset("DeployedAt").GetValueOrDefault(),
				ActivatedAt = tableEntity.GetDateTimeOffset("ActivatedAt").GetValueOrDefault(),
				EditStep = (AccountantEditStep)tableEntity.GetInt32("EditStep"),
				Tasks = tasks == null
					? new List<AccountingTaskBase>()
					: JsonSerializer.Deserialize<List<AccountingTaskBase>>(tasks, serializerOptions)!,
				AddressBookAccessRights = addressBookAccessRights == null
					? new List<ContentAccessRight>()
					: JsonSerializer.Deserialize<List<ContentAccessRight>>(addressBookAccessRights, serializerOptions)!
			};
		}

		public static Invoice ToInvoice(this TableEntity tableEntity)
		{
			if (tableEntity == null)
			{
				return null;
			}
			var invoice = new Invoice
			{
				Id = $"{tableEntity.PartitionKey}:{tableEntity.RowKey}",
				Contract = tableEntity.RowKey,
				AlternativeCurrency = tableEntity.GetString("AlternativeCurrency"),
				AlternativeFxValue = tableEntity.GetString("AlternativeFxValue"),
				From = tableEntity.GetString("From"),
				To = tableEntity.GetString("To"),
				InvoiceNr = tableEntity.GetInt64("InvoiceNr"),
				Article = tableEntity.GetString("Article"),
				Currency = tableEntity.GetString("Currency"),
				AmountString = tableEntity.GetString("Amount"),
				Error = tableEntity.GetString("Error"),
				CreatedAt = tableEntity.GetDateTimeOffset("CreatedAt").GetValueOrDefault(),
				ProcessedAt = tableEntity.GetDateTimeOffset("ProcessedAt"),
				IsFiat = tableEntity.GetBoolean("IsFiat").GetValueOrDefault(),
				ProcessFee = tableEntity.GetInt64("ProcessFee"),
				AutomationFinishedAt = tableEntity.GetDateTimeOffset("AutomationFinishedAt"),
			};
			if (BigInteger.TryParse(invoice.AmountString, out var amount))
			{
				invoice.Amount = amount;
			}
			else
			{
				invoice.Error = "Cannot parse number from Amount";
			}
			return invoice;
		}
	}
}

'''
'''--- Toolblox.Ada.App.Functions/Properties/ServiceDependencies/adawillhandlefunctions/appInsights1.arm.json ---
{
  "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "resourceGroupName": {
      "type": "string",
      "defaultValue": "AdaResourceGroup",
      "metadata": {
        "_parameterType": "resourceGroup",
        "description": "Name of the resource group for the resource. It is recommended to put resources under same resource group for better tracking."
      }
    },
    "resourceGroupLocation": {
      "type": "string",
      "defaultValue": "switzerlandnorth",
      "metadata": {
        "_parameterType": "location",
        "description": "Location of the resource group. Resource groups could have different location than resources."
      }
    },
    "resourceLocation": {
      "type": "string",
      "defaultValue": "[parameters('resourceGroupLocation')]",
      "metadata": {
        "_parameterType": "location",
        "description": "Location of the resource. By default use resource group's location, unless the resource provider is not supported there."
      }
    }
  },
  "resources": [
    {
      "type": "Microsoft.Resources/resourceGroups",
      "name": "[parameters('resourceGroupName')]",
      "location": "[parameters('resourceGroupLocation')]",
      "apiVersion": "2019-10-01"
    },
    {
      "type": "Microsoft.Resources/deployments",
      "name": "[concat(parameters('resourceGroupName'), 'Deployment', uniqueString(concat('adawillhandlefunctions', subscription().subscriptionId)))]",
      "resourceGroup": "[parameters('resourceGroupName')]",
      "apiVersion": "2019-10-01",
      "dependsOn": [
        "[parameters('resourceGroupName')]"
      ],
      "properties": {
        "mode": "Incremental",
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "resources": [
            {
              "name": "adawillhandlefunctions",
              "type": "microsoft.insights/components",
              "location": "[parameters('resourceLocation')]",
              "kind": "web",
              "properties": {},
              "apiVersion": "2015-05-01"
            }
          ]
        }
      }
    }
  ],
  "metadata": {
    "_dependencyType": "appInsights.azure"
  }
}
'''
'''--- Toolblox.Ada.App.Functions/Properties/ServiceDependencies/adawillhandlefunctions/storage1.arm.json ---
{
  "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "resourceGroupName": {
      "type": "string",
      "defaultValue": "AdaResourceGroup",
      "metadata": {
        "_parameterType": "resourceGroup",
        "description": "Name of the resource group for the resource. It is recommended to put resources under same resource group for better tracking."
      }
    },
    "resourceGroupLocation": {
      "type": "string",
      "defaultValue": "switzerlandnorth",
      "metadata": {
        "_parameterType": "location",
        "description": "Location of the resource group. Resource groups could have different location than resources."
      }
    },
    "resourceLocation": {
      "type": "string",
      "defaultValue": "[parameters('resourceGroupLocation')]",
      "metadata": {
        "_parameterType": "location",
        "description": "Location of the resource. By default use resource group's location, unless the resource provider is not supported there."
      }
    }
  },
  "resources": [
    {
      "type": "Microsoft.Resources/resourceGroups",
      "name": "[parameters('resourceGroupName')]",
      "location": "[parameters('resourceGroupLocation')]",
      "apiVersion": "2019-10-01"
    },
    {
      "type": "Microsoft.Resources/deployments",
      "name": "[concat(parameters('resourceGroupName'), 'Deployment', uniqueString(concat('adawillhandlestorage', subscription().subscriptionId)))]",
      "resourceGroup": "[parameters('resourceGroupName')]",
      "apiVersion": "2019-10-01",
      "dependsOn": [
        "[parameters('resourceGroupName')]"
      ],
      "properties": {
        "mode": "Incremental",
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "resources": [
            {
              "sku": {
                "name": "Standard_RAGRS",
                "tier": "Standard"
              },
              "kind": "StorageV2",
              "name": "adawillhandlestorage",
              "type": "Microsoft.Storage/storageAccounts",
              "location": "[parameters('resourceLocation')]",
              "apiVersion": "2017-10-01"
            }
          ]
        }
      }
    }
  ],
  "metadata": {
    "_dependencyType": "storage.azure"
  }
}
'''
'''--- Toolblox.Ada.App.Functions/Properties/serviceDependencies.adawillhandlefunctions.json ---
{
  "dependencies": {
    "appInsights1": {
      "resourceId": "/subscriptions/[parameters('subscriptionId')]/resourceGroups/[parameters('resourceGroupName')]/providers/microsoft.insights/components/adawillhandlefunctions",
      "type": "appInsights.azure",
      "connectionId": "APPLICATIONINSIGHTS_CONNECTION_STRING"
    },
    "storage1": {
      "resourceId": "/subscriptions/[parameters('subscriptionId')]/resourceGroups/[parameters('resourceGroupName')]/providers/Microsoft.Storage/storageAccounts/adawillhandlestorage",
      "type": "storage.azure",
      "connectionId": "AzureWebJobsStorage"
    }
  }
}
'''
'''--- Toolblox.Ada.App.Functions/Properties/serviceDependencies.json ---
{
  "dependencies": {
    "appInsights1": {
      "type": "appInsights",
      "connectionId": "APPLICATIONINSIGHTS_CONNECTION_STRING"
    },
    "storage1": {
      "type": "storage",
      "connectionId": "AzureWebJobsStorage"
    }
  }
}
'''
'''--- Toolblox.Ada.App.Functions/Properties/serviceDependencies.local.json ---
{
  "dependencies": {
    "appInsights1": {
      "type": "appInsights.sdk"
    },
    "storage1": {
      "type": "storage.emulator",
      "connectionId": "AzureWebJobsStorage"
    }
  }
}
'''
'''--- Toolblox.Ada.App.Functions/Security.cs ---
using Microsoft.IdentityModel.Tokens;
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Net.Http;
using System.Security.Authentication;
using System.Security.Claims;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.IdentityModel.Protocols;
using Microsoft.IdentityModel.Protocols.OpenIdConnect;

namespace Toolblox.Ada.App.Functions
{
    public static class Security
    {
        private static readonly IConfigurationManager<OpenIdConnectConfiguration> _configurationManager;

        //TODO:Config
        private static readonly string ISSUER = "https://toolblox.eu.auth0.com/";
        private static readonly string AUDIENCE = "http://localhost:7071/api/Function1";

        static Security()
        {
            var documentRetriever = new HttpDocumentRetriever { RequireHttps = ISSUER.StartsWith("https://") };

            _configurationManager = new ConfigurationManager<OpenIdConnectConfiguration>(
                $"{ISSUER}.well-known/openid-configuration",
                new OpenIdConnectConfigurationRetriever(),
                documentRetriever
            );
        }

        public static async Task<string> GetUser(HttpRequestMessage req, bool throwOnError = true)
        {
            var user = await Security.ValidateTokenAsync(req.Headers.Authorization?.ToString());
            if (user == null && throwOnError)
            {
                throw new AuthenticationException();
            }
            var userId = user?.Claims.FirstOrDefault(c => c.Type == "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier")?.Value;
            return userId;
        }

        public static async Task<ClaimsPrincipal> ValidateTokenAsync(string authorizationHeader)
        {
            if (string.IsNullOrEmpty(authorizationHeader))
            {
                return null;
            }

            if (!authorizationHeader.Contains("Bearer"))
            {
                return null;
            }

            var accessToken = authorizationHeader.Substring("Bearer ".Length);

            var config = await _configurationManager.GetConfigurationAsync(CancellationToken.None);

            var validationParameter = new TokenValidationParameters
            {
                RequireSignedTokens = true,
                ValidAudience = AUDIENCE,
                ValidateAudience = true,
                ValidIssuer = ISSUER,
                ValidateIssuer = true,
                ValidateIssuerSigningKey = true,
                ValidateLifetime = true,
                IssuerSigningKeys = config.SigningKeys
            };

            ClaimsPrincipal result = null;
            var tries = 0;

            while (result == null && tries <= 1)
            {
                try
                {
                    var handler = new JwtSecurityTokenHandler();
                    result = handler.ValidateToken(accessToken, validationParameter, out var token);
                }
                catch (SecurityTokenSignatureKeyNotFoundException ex1)
                {
                    // This exception is thrown if the signature key of the JWT could not be found.
                    // This could be the case when the issuer changed its signing keys, so we trigger a 
                    // refresh and retry validation.
                    _configurationManager.RequestRefresh();
                    tries++;
                }
                catch (SecurityTokenException ex2)
                {
                    return null;
                }
            }

            return result;
        }
    }
}

'''
'''--- Toolblox.Ada.App.Functions/Services/SystemTextJsonResult.cs ---
using Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using Toolblox.Ada.App.Model;

namespace Toolblox.Ada.App.Functions.Services
{
    public class SystemTextJsonResult : ContentResult
    {
        private const string ContentTypeApplicationJson = "application/json";

        public SystemTextJsonResult(object value, JsonSerializerOptions options = null)
        {
            ContentType = ContentTypeApplicationJson;
            Content = options == null ? JsonSerializer.Serialize(value, new JsonSerializerOptions().ConfigureAdaDtoInheritance()) : JsonSerializer.Serialize(value, options);
        }
    }
}

'''
'''--- Toolblox.Ada.App.Functions/Startup.cs ---
using Microsoft.Azure.Functions.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection;
using Toolblox.Ada.App.Functions;
using DinkToPdf;

[assembly: FunctionsStartup(typeof(Startup))]
namespace Toolblox.Ada.App.Functions
{
	public class Startup : FunctionsStartup
	{
		public override void Configure(IFunctionsHostBuilder builder)
		{
			builder.Services.AddSingleton<SynchronizedConverter>((s)
				=> new(new PdfTools()));
		}
	}
}

'''
'''--- Toolblox.Ada.App.Functions/StoreEventFunction.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Azure.Data.Tables;
using Azure.Identity;
using Azure.Security.KeyVault.Secrets;
using DinkToPdf;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.EventHubs;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using SendGrid.Helpers.Mail;
using Toolblox.Ada.App.Functions.Helpers;
using Toolblox.Ada.App.Functions.Services;
using Toolblox.Ada.App.Model;
using Toolblox.Ada.App.Model.Helpers;
using Toolblox.Ada.App.Model.Services;
using VCards;
using VCards.Types;

namespace Toolblox.Ada.App.Functions
{
	public class BlockchainEventInvoice
	{
		/*         *
         * {"contract":"silver-test.testnet","from":"silverdemo2.testnet","to":"silverdemo2.testnet","article":"kekuleku"}
         */
		[JsonProperty("id")]
		public long Id { get; set; }
		[JsonProperty("receiptId")]
		public string ReceiptId { get; set; }
		[JsonProperty("contract")]
		public string Contract { get; set; }
		[JsonProperty("from")]
		public string From { get; set; }
		[JsonProperty("to")]
		public string To { get; set; }
		[JsonProperty("article")]
		public string Article { get; set; }
		[JsonProperty("amount")]
		public string Amount { get; set; }
		[JsonProperty("currency")]
		public string Currency { get; set; }
	}

	public class StoreEventFunction
	{
		private readonly SynchronizedConverter _converter;

		public StoreEventFunction(SynchronizedConverter converter)
		{
			_converter = converter;
		}

		[FunctionName("Invoices")]
		public static async Task<IActionResult> Invoices(
			[HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = "Invoice/List")] HttpRequestMessage req,
			[Table("Accountants")] TableClient accountantsTable,
			[Table("Invoices")] TableClient todoTable,
			ILogger log)
		{
			log.LogInformation("C# HTTP trigger function processed a request.");
			var userId = await Security.GetUser(req, false);
			var query = req.RequestUri.ParseQueryString();
			var id = query.Get("id");

			var accountEntity = await accountantsTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{userId.Sanitize()}' and RowKey eq '{id.Sanitize()}'").FirstOrDefaultAsync();
			var accountant = accountEntity.ToAccountant();

			if (accountant == null)
			{
				throw new Exception("Cannot find accountant");
			}

			var invoiceEntities = await todoTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{accountant.Contract?.Sanitize()}' or PartitionKey eq '{accountant.Workflow?.Sanitize()}'").ToListAsync();

			var invoices = invoiceEntities.Select(TableEntityExtensions.ToInvoice).ToList();

			return new SystemTextJsonResult(invoices);
		}

		[FunctionName("Reprocess")]
		public static async Task<IActionResult> ReprocessInvoice(
			[HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = "Invoice/Reprocess")] HttpRequestMessage req,
			[Table("Accountants")] TableClient accountantsTable,
			[Table("Invoices")] TableClient invoiceTable,
			[Queue("invoices-to-process")] ICollector<string> invoicesToProcess,
			ILogger log)
		{
			log.LogInformation("C# HTTP trigger function processed a request.");
			var userId = await Security.GetUser(req, false);
			var query = req.RequestUri.ParseQueryString();
			var accountantId = query.Get("accountantId").Sanitize();
			var invoiceId = query.Get("id");
			var accountEntity = await accountantsTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{userId.Sanitize()}' and RowKey eq '{accountantId}'").FirstOrDefaultAsync();
			var accountant = accountEntity.ToAccountant();
			if (accountant == null)
			{
				throw new Exception("Cannot find accountant");
			}
			if (!accountant.IsActive)
			{
				throw new Exception("Accountant not deployed");
			}

			var partitionKey = invoiceId.Split(":")[0].Sanitize();
			var rowKey = invoiceId.Split(":")[1].Sanitize();

			var invoiceEntity = await invoiceTable.GetEntityAsync<TableEntity>(partitionKey, rowKey);

			if (invoiceEntity == null || (partitionKey != accountant.Contract && partitionKey != accountant.Workflow))
			{
				throw new Exception("Invoice not found");
			}

			invoicesToProcess.Add(invoiceId);

			return new OkObjectResult("Started");
		}

		[FunctionName("AutomateInvoice")]
		public async Task AutomateInvoice(
			[QueueTrigger("invoices-to-automate")] string invoiceKey,
			[Table("Accountants")] TableClient accountantsTable,
			[Table("Invoices")] TableClient invoicesTable,
			[SendGrid(ApiKey = "CustomSendGridKeyAppSettingName")] IAsyncCollector<SendGridMessage> messageCollector,
			ILogger log)
		{
			if (string.IsNullOrWhiteSpace(invoiceKey) || invoiceKey.Split(":").Length != 2)
			{
				//Ignore invalid item
				return;
			}

			var adaContract = invoiceKey.Split(":")[0];
			var receipt = invoiceKey.Split(":")[1];
			var invoiceEntity = await invoicesTable.QueryAsync<TableEntity>(filter: $"PartitionKey eq '{adaContract.Sanitize()}' and RowKey eq '{receipt.Sanitize()}'").FirstOrDefaultAsync();
			if (invoiceEntity == null)
			{
				throw new Exception("Invoice not found: " + invoiceKey);
			}

			try
			{
				var invoice = invoiceEntity.ToInvoice();
				var accountantEntity = await accountantsTable.QueryAsync<TableEntity>(filter: $"Contract eq '{adaContract.Sanitize()}' or Workflow eq '{adaContract.Sanitize()}'").ToListAsync();
				if (!accountantEntity.Any())
				{
					throw new Exception("No accountants found to process invoice: " + invoiceKey);
				}
				foreach (var accountant in accountantEntity.Select(TableEntityExtensions.ToAccountant))
				{
					var client = new SecretClient(vaultUri: new Uri("https://adaaddressbookkeys.vault.azure.net/"), credential: new DefaultAzureCredential());
					var keys = KeysSerializer.Deserialize((await client.GetSecretAsync($"ada{accountant.Id}".Replace("-", "")))?.Value?.Value);
					if (keys == null)
					{
						throw new Exception("Ada has no access to address book of accountant " + accountant.Id);
					}

					var service = new EncryptionServiceClient(null);
					var masterKey = await service.GetAddressBookMasterKey(accountant, keys);
					var addressBook = await service.GetAddressBook(accountant, masterKey);

					var contacts = addressBook.ToLookup(accountant);

					byte[] pdf = null;
					var seller = contacts.FindContact(invoice.From);
					var buyer = contacts.FindContact(invoice.To, false);
					if (accountant.Tasks.Any())
					{
						pdf = BuildPdf(invoice, seller, buyer);
					}
					foreach (var task in accountant.Tasks.OfType<SendEmailAccountingTask>())
					{
						var message = new SendGridMessage();
						switch (task.Type)
						{
							case SendEmailTaskType.Buyer:
								message.AddTo(buyer.GetEmail()?.EmailAddress);
								break;
							case SendEmailTaskType.Seller:
								message.AddTo(seller.GetEmail()?.EmailAddress);
								break;
							case SendEmailTaskType.Custom:
								message.AddTo(task.Email);
								break;
							default:
								throw new ArgumentOutOfRangeException();
						}

						var alternativeAmountString = "";
						if (invoice.HasAlternativeAmount())
						{
							alternativeAmountString = $"$ {invoice.GetAmountInAlternativeCurrency():0.00}<br/>";
						}
						message.AddContent("text/html", $"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n <head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\r\n  <title>Invoice details</title>\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\r\n </head>\r\n  \r\n  <body style=\"margin: 0; padding: 0; background-color:#eaeced \" bgcolor=\"#eaeced\">\r\n   <table bgcolor=\"#eaeced\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background-color: #eaeced; \">\r\n     <tr>\r\n     \t<td>&nbsp;</td>\r\n     </tr>\r\n     <tr>\r\n     \t<td>&nbsp;</td>\r\n     </tr>\r\n    <tr>\r\n     <td>\r\n      \r\n       <table align=\"center\" bgcolor=\"#ffffff\" cellpadding=\"20\" cellspacing=\"0\" width=\"600\" \r\n              style=\"border-collapse: collapse; background-color: #ffffff; border: 1px solid #f0f0f0;\">\r\n         <tr style=\"border-top: 4px solid #ff0000;\">\r\n          <td align=\"left\" style=\"padding: 15px 20px 20px;\">\r\n            <table width=\"100%\">\r\n              <tr>\r\n                <td><img style=\"width: 200px;\" src='{accountant.Logo}' width=\"220px\" alt=\"Company Logo\"/></td>\r\n                <td align=\"right\" style=\"font-family: 'Open Sans',Helvetica,Arial,sans-serif;\">\r\n                  <span>Inovice no: #{invoice.InvoiceNr.GetValueOrDefault().ToString("0000")}</span><br>\r\n                  <span style=\"padding: 5px 0; display: block;\">{invoice.CreatedAt.DateTime.ToShortDateString()}</span>\r\n                </td>\r\n              </tr>\r\n            </table>\r\n           \r\n          </td>\r\n         </tr>\r\n         <tr>\r\n          <td align=\"center\" style=\"padding: 20px; border-top: 1px solid #f0f0f0; background: #fafafa; font-family: 'Open Sans',Helvetica,Arial,sans-serif; \">\r\n           <div>Total Due:</div>\r\n           <h2 style=\"margin: 10px 0; color: #333; font-weight: 500; font-size: 48px;\">\r\n              {invoice.GetAmount():0.00} {invoice.Currency}\r\n           </h2>\r\n            <div style=\"line-height: 1.4; font-size: 1.2; font-size: 14px; color: #777;\">{alternativeAmountString}{(buyer?.Kind == Kind.Organization ? $"For {buyer.Organization}, " : "")}Issued on {invoice.CreatedAt.DateTime.ToLongDateString()}<br>by {seller.Organization}</div>\r\n          </td>\r\n         </tr>\r\n         <tr>\r\n          <td align=\"center\" style=\"padding: 20px 40px; font-family: 'Open Sans',Helvetica,Arial,sans-serif;font-size: 16px;line-height: 1.4;color: #333;\">\r\n            <div>Note: For {invoice.Article}</div>\r\n            <div><br></div>\r\n            <div><br></div>\r\n          </td>\r\n         </tr>\r\n         <tr style=\"border-top: 1px solid #eaeaea;\">\r\n           <td align=\"center\">\r\n             <div style=\"font-family: 'Open Sans',Helvetica,Arial,sans-serif;font-size: 14px;line-height: 1.4;color: #777;\">\r\n              Regards,<br>\r\n              {seller.Organization}\r\n            </div>\r\n           </td>\r\n         </tr>\r\n       </table>\r\n       \r\n     </td>\r\n    </tr>\r\n     <tr>\r\n     \t<td>&nbsp;</td>\r\n     </tr>\r\n     <tr>\r\n     \t<td>&nbsp;</td>\r\n     </tr>\r\n   </table>\r\n  </body>\r\n  \r\n</html>");
						if (pdf != null)
						{
							message.AddAttachment("invoice.pdf", Convert.ToBase64String(pdf));
						}
						message.SetFrom(new EmailAddress("ada@toolblox.net", accountant.Name));
						message.SetSubject("Invoice from " + accountant.Name);

						await messageCollector.AddAsync(message);
					}

					invoiceEntity["AutomationFinishedAt"] = DateTimeOffset.Now;
					invoiceEntity["Error"] = "";
					await invoicesTable.UpsertEntityAsync(invoiceEntity);
				}
			}
			catch (Exception e)
			{
				invoiceEntity["Error"] = e.Message;
				await invoicesTable.UpsertEntityAsync(invoiceEntity);
				log.LogError(e, "Error automating");
				throw;
			}
		}

		private byte[] BuildPdf(Invoice invoice, VCard seller, VCard buyer)
		{
			var htmlContent = invoice.GetInvoiceAsHtml(seller, buyer);
			var pdf = BuildPdf(htmlContent, "8.5in", "11in", new MarginSettings(0, 0, 0, 0));
			return pdf;
		}

		private byte[] BuildPdf(string HtmlContent, string Width, string Height, MarginSettings Margins, int? DPI = 180)
		{
			// Call the Convert method of SynchronizedConverter "pdfConverter"
			return _converter.Convert(new HtmlToPdfDocument()
			{
				// Set the html content
				Objects =
				{
					new ObjectSettings
					{
						HtmlContent = HtmlContent
					}
				},
				// Set the configurations
				GlobalSettings = new GlobalSettings
				{
					// PaperKind.A4 can also be used instead PechkinPaperSize
					PaperSize = new PechkinPaperSize(Width, Height),
					DPI = DPI,
					Margins = Margins
				}
			});
		}

#if !DEBUG
        [FunctionName("InvoiceFunction")]
		public async Task Run(
			[EventHubTrigger("invoiceevent", Connection = "EventHub")] EventData[] events,
			[Table("Invoices")] TableClient todoTable,
			[Queue("invoices-to-process")] ICollector<string> invoicesToProcess,
			ILogger log)
		{
			var exceptions = new List<Exception>();
			var actions = new List<TableTransactionAction>();

			foreach (EventData eventData in events)
			{
				try
				{
					string messageBody = Encoding.UTF8.GetString(eventData.Body.Array, eventData.Body.Offset, eventData.Body.Count);
					//var userId = await Security.GetUser(null);
					var invoice = JsonConvert.DeserializeObject<BlockchainEventInvoice>(messageBody);
					// Replace these two lines with your processing logic.
					log.LogInformation($"C# Event Hub trigger function processed a message: {JsonConvert.SerializeObject(invoice, Formatting.Indented)}");

					invoicesToProcess.Add($"{invoice.Contract}:{invoice.ReceiptId}");
					var currencyIso = invoice.Currency?.ToUpper();
					actions.Add(new TableTransactionAction(
						TableTransactionActionType.UpsertReplace,
						new TableEntity(invoice.Contract, invoice.ReceiptId)
						{
							{ "InvoiceNr", invoice.Id },
							{ "From", invoice.From },
							{ "To", invoice.To },
							{ "Article", invoice.Article },
							{ "IsFiat", Invoice.CheckIfFiat(currencyIso) },
							{ "Currency", currencyIso },
							{ "AmountString", invoice.Amount },
							{ "Amount", invoice.Amount },
							{ "CreatedAt", DateTimeOffset.Now },
							{ "ProcessedAt", (DateTimeOffset?)null },
							{ "AutomationFinishedAt", (DateTimeOffset?)null },
						}));
				}
				catch (Exception e)
				{
					// We need to keep processing the rest of the batch - capture this exception and continue.
					// Also, consider capturing details of the message that failed processing so it can be processed again later.
					exceptions.Add(e);
				}
			}

			try
			{
				await todoTable.SubmitTransactionAsync(actions);
			}
			catch (Exception ex)
			{
				exceptions.Add(ex);
			}
			// Once processing of the batch is complete, if any messages in the batch failed processing throw an exception so that there is a record of the failure.

			if (exceptions.Count > 1)
				throw new AggregateException(exceptions);

			if (exceptions.Count == 1)
				throw exceptions.Single();
		}
#endif
	}
}

'''
'''--- Toolblox.Ada.App.Functions/host.json ---
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensions": {
    "queues": {
      "maxPollingInterval": "00:00:30"
    }
  }
}
'''
'''--- Toolblox.Ada.App.sln ---

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.32916.344
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Toolblox.Ada.App.Functions", "Toolblox.Ada.App.Functions\Toolblox.Ada.App.Functions.csproj", "{66EC993B-E7AE-4C2A-9F85-96237F001E9A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{66EC993B-E7AE-4C2A-9F85-96237F001E9A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{66EC993B-E7AE-4C2A-9F85-96237F001E9A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{66EC993B-E7AE-4C2A-9F85-96237F001E9A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{66EC993B-E7AE-4C2A-9F85-96237F001E9A}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F959F040-D102-4A1E-BF93-B45872A3F047}
	EndGlobalSection
EndGlobal

'''