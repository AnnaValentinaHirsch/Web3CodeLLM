*GitHub Repository "JoeHank9/FareFlow"*

'''--- README.md ---
# FareFlow

DApp que permite el fondeo de tarjetas para el pago de transporte pÃºblico, las cuales se utilizan en varios estados dentro de la repÃºblica, con esto buscamos innovar la forma de realizar pagos fortaleciendo el uso de las nuevas tecnologÃ­as en Web 3.

# Links importantes
### App en Android
https://github.com/efrain968/FareFlow-AppMovil.git

### App en Android
https://github.com/efrain968/FareFlow-AppMovil.git

### FrontEnd Desing
https://github.com/efrain968/FlareFLow.git

### Video
https://www.loom.com/share/9d3ee02e70f64b29b3625af0cf399d2b

# Quickstart

### 1. Install Dependencies
```
npm install
```

### 2. Deploy the Contract
Build the contract and deploy it in a testnet account
```
npm run deploy
```

### 3. Start the Frontend
Start the web application to interact with your smart contract 
```
npm run start
```

'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
# Donation Contract

The smart contract exposes multiple methods to handle donating money to a `beneficiary` set on initialization.

## 1. Build and Deploy the Contract
You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
./deploy.sh
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

The contract will be automatically initialized with a default `beneficiary`.

To initialize the contract yourself do:

```bash
# Use near-cli to initialize contract (optional)
near call <dev-account> new '{"beneficiary":"<account>"}' --accountId <dev-account>
```

<br />

## 2. Get Beneficiary
`beneficiary` is a read-only method (`view` method) that returns the beneficiary of the donations.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
near view <dev-account> beneficiary
```

<br />

## 3. Get Number of Donations

`donate` forwards any attached money to the `beneficiary` while keeping track of it.

`donate` is a payable method for which can only be invoked using a NEAR account. The account needs to attach money and pay GAS for the transaction.

```bash
# Use near-cli to donate 1 NEAR
near call <dev-account> donate --amount 1 --accountId <account>
```

**Tip:** If you would like to `donate` using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.

````
near call meta-v2.pool.testnet deposit_and_stake '{"amount":}' --accountId ejemplo.testnet --deposit 1

near call meta-v2.pool.testnet ft_transfer '{}' --accountId ejemplo.testnet

near view meta-v2.pool.testnet ft_balance_of '{"account_id": "ejemplo.testnet"}'

near call meta-v2.pool.testnet ft_transfer '{"receiver_id": "joehank.testnet", "amount": "1000000000000000000000000", "msg": ""}' --accountId ejemplo.testnet --depositYocto 1 --gas 300000000000000
````
'''
'''--- contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- contract/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

 near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm
# near deploy two.stakedemy.testnet --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm
'''
'''--- contract/src copy/deposit.rs ---
use crate::Contract;
use crate::ContractExt;
use crate::Timestamp;
use crate::*;

use near_sdk::serde::Serialize;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Promise, Balance, Gas};
use near_sdk::json_types::U128;

pub type TokenId = String;

pub const STORAGE_COST: u128 = 1_000_000_000_000_000_000_000;
const NO_DEPOSIT: Balance = 0;
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(300000000000000);

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Donation {
  pub account_id: AccountId, 
  pub total_amount: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Deposit_st {
  pub account_id: AccountId, 
  pub total_amount: U128,
}

#[near_bindgen]
impl Contract {
  #[payable] // Public - People can attach money
  pub fn deposit(&mut self, time: Timestamp) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let donor: AccountId = env::predecessor_account_id();
    let deposit_amount: Balance = env::attached_deposit();

    let mut deposit_so_far = self.total_deposit.get(&donor).unwrap_or(0);

    let to_transfer: Balance = if deposit_so_far == 0 {
      // This is the user's first donation, lets register it, which increases storage
      assert!(deposit_amount > STORAGE_COST, "Attach at least {} yoctoNEAR", STORAGE_COST);

      // Subtract the storage cost to the amount to transfer
      deposit_amount - STORAGE_COST
    }else{
      deposit_amount
    };

    // Persist in storage the amount donated so far
    deposit_so_far += deposit_amount;
    self.total_deposit.insert(&donor, &deposit_so_far);
    self.internal_add_deposit_to_owner(&donor, &time);
    
    log!("Thank you {} for deposit {}! You donated a total of {}", donor.clone(), deposit_amount, deposit_so_far);
    
    // Send the money to the beneficiary
    Promise::new(self.beneficiary.clone()).transfer(to_transfer);

    // Return the total amount donated so far
    U128(deposit_so_far)
  }

  #[payable]
  pub fn depositst(&mut self, time: Timestamp, amount: String) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let donor: AccountId = env::predecessor_account_id();
    let receiver: AccountId= "joehank.testnet".parse::<AccountId>().unwrap();
    let mut deposit_amount: Balance = amount.parse().unwrap();
    deposit_amount = deposit_amount * 1000000000000000000000000;
    let mut deposit_so_far = self.deposit_st.get(&donor).unwrap_or(0);

    let to_transfer: Balance = if deposit_so_far == 0 {
      // This is the user's first donation, lets register it, which increases storage
      assert!( deposit_amount > STORAGE_COST, "Attach at least {} yoctostNEAR", STORAGE_COST);

      // Subtract the storage cost to the amount to transfer
      deposit_amount
    }else{
      deposit_amount
    };

    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .with_attached_deposit(1)
    .ft_transfer(receiver.clone(),deposit_amount.to_string());

    // Persist in storage the amount donated so far
    deposit_so_far += deposit_amount;
    self.deposit_st.insert(&donor, &deposit_so_far);
    self.internal_add_deposit_to_owner(&donor, &time);
    
    log!("Thank you {} for deposit {}! You donated a total of {}", donor.clone(), deposit_amount, deposit_so_far);
    
    // Send the money to the beneficiary
    Promise::new(self.beneficiary.clone()).transfer(to_transfer);

    // Return the total amount donated so far
    U128(deposit_so_far)
  } 

  pub fn payment(&mut self, time: Timestamp, amount: String) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let payer: AccountId = env::predecessor_account_id();
    let payment_amount: Balance = amount.parse().unwrap();

    let mut deposit_so_far = self.total_deposit.get(&payer).unwrap_or(0);

    assert!(payment_amount <= deposit_so_far, "You need to deposit first NEAR");

    // Persist in storage the amount donated so far
    deposit_so_far -= payment_amount;
    self.total_deposit.insert(&payer, &deposit_so_far);
    //self.internal_add_payment_to_owner(&payer, &time);
    
    log!("Gracias {} for pagar {}! Te queda un saldo total de {}", payer.clone(), payment_amount, deposit_so_far);

    // Return the total amount donated so far
    U128(deposit_so_far)
  }

}
'''
'''--- contract/src copy/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    // Public - get donation by account ID
  pub fn get_donation_for_account(&self, account_id: AccountId) -> Donation {
    Donation {
      account_id: account_id.clone(),
      total_amount: U128(self.total_deposit.get(&account_id).unwrap_or(0))
    }
  }

  pub fn get_deposit_for_account(&self, account_id: AccountId) -> Deposit_st {
    Deposit_st {
      account_id: account_id.clone(),
      total_amount: U128(self.deposit_st.get(&account_id).unwrap_or(0))
    }
  }

  // Public - get total number of donors
  pub fn number_of_donors(&self) -> u64 {
    self.total_deposit.len()
  }

  pub fn number_of_depositors(&self) -> u64 {
    self.deposit_st.len()
  }

  // Public - paginate through all donations on the contract
  pub fn get_donations(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Donation> {
    //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    let start = u128::from(from_index.unwrap_or(U128(0)));

    //iterate through donation
    self.total_deposit.keys()
      //skip to the index we specified in the start variable
      .skip(start as usize) 
      //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
      .take(limit.unwrap_or(50) as usize) 
      .map(|account| self.get_donation_for_account(account))
      //since we turned map into an iterator, we need to turn it back into a vector to return
      .collect()
  }

  pub fn get_deposits(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Deposit_st> {
    //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    let start = u128::from(from_index.unwrap_or(U128(0)));

    //iterate through donation
    self.deposit_st.keys()
      //skip to the index we specified in the start variable
      .skip(start as usize) 
      //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
      .take(limit.unwrap_or(50) as usize) 
      .map(|account| self.get_deposit_for_account(account))
      //since we turned map into an iterator, we need to turn it back into a vector to return
      .collect()
  }

    //Query for nft tokens on the contract regardless of the owner using pagination
    // pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
    //     //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    //     let start = u128::from(from_index.unwrap_or(U128(0)));

    //     //iterate through each token using an iterator
    //     self.token_metadata_by_id.keys_as_vector().iter()
    //         //skip to the index we specified in the start variable
    //         .skip(start as usize) 
    //         //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
    //         .take(limit.unwrap_or(50) as usize) 
    //         //we'll map the token IDs which are strings into Json Tokens
    //         .map(|token_id| self.nft_token(token_id.clone()).unwrap())
    //         //since we turned the keys into an iterator, we need to turn it back into a vector to return
    //         .collect()
    // }

    // //get the total supply of NFTs for a given owner
    pub fn deposit_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of tokens for the passed in owner
        let deposit_for_owner_set = self.deposit_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(deposit_for_owner_set) = deposit_for_owner_set {
            U128(deposit_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    // //Query for all the tokens for an owner
    // pub fn deposit_for_owner(
    //     &self,
    //     account_id: AccountId,
    //     from_index: Option<U128>,
    //     limit: Option<u64>,
    // ) -> Vec <Donation> {
    //     //get the set of tokens for the passed in owner
    //     let deposit_for_owner_set = self.deposit_per_owner.get(&account_id);
    //     //if there is some set of tokens, we'll set the tokens variable equal to that set
    //     let tokens = if let Some(deposit_for_owner_set) = deposit_for_owner_set {
    //         deposit_for_owner_set
    //     } else {
    //         //if there is no set of tokens, we'll simply return an empty vector. 
    //         return vec![];
    //     };

    //     //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    //     let start = u128::from(from_index.unwrap_or(U128(0)));

    //     //iterate through the keys vector
    //     tokens.iter()
    //         //skip to the index we specified in the start variable
    //         .skip(start as usize) 
    //         //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
    //         .take(limit.unwrap_or(50) as usize) 
    //         //we'll map the token IDs which are strings into Json Tokens
    //         .map(|token_id| self.nft_token(token_id.clone()).unwrap())
    //         //since we turned the keys into an iterator, we need to turn it back into a vector to return
    //         .collect()
    // }
    
}

'''
'''--- contract/src copy/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};
use std::mem::size_of;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_deposit_to_owner(
        &mut self,
        account_id: &AccountId,
        timestamp: &Timestamp,
    ) {
        //get the set of tokens for the given account
        let mut deposit_set = self.deposit_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::DepositPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        deposit_set.insert(timestamp);

        //we insert that set for the given account ID. 
        self.deposit_per_owner.insert(account_id, &deposit_set);
    }

    
    
} 
'''
'''--- contract/src copy/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::collections::HashMap;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::U128;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;
/// Raw type for 32 bytes of the hash.
pub type CryptoHash = [u8; 32];

use crate::internal::*;
pub use crate::xcc::*;
pub use crate::metadata::*;
pub use crate::deposit::*;
pub use crate::enumeration::*;

mod internal;
mod deposit;
mod xcc;
mod metadata;
mod enumeration;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
  pub beneficiary: AccountId,
  pub total_deposit: UnorderedMap<AccountId, u128>,
  pub deposit_st: UnorderedMap<AccountId, u128>,
  pub deposit: UnorderedMap<Timestamp, Deposit>,
  pub deposit_per_owner: LookupMap<AccountId, UnorderedSet<Timestamp>>,
  pub metapoolcontract: String
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    DepositPerOwner,
    DepositPerOwnerInner { account_id_hash: CryptoHash },
}

impl Default for Contract {
  fn default() -> Self {
    Self{
      beneficiary: "v1.faucet.nonofficial.testnet".parse().unwrap(),
      metapoolcontract: "meta-v2.pool.testnet".parse().unwrap(),
      total_deposit: UnorderedMap::new(b"a"),
      deposit_st: UnorderedMap::new(b"b"),
      deposit: UnorderedMap::new(b"c"),
      deposit_per_owner: LookupMap::new(StorageKey::DepositPerOwner.try_to_vec().unwrap()),
    }
  }
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn init(beneficiary: AccountId, metapoolcontract: String) -> Self {
    Self {
      beneficiary,
      metapoolcontract,
      deposit: UnorderedMap::new(b"d"),
      total_deposit: UnorderedMap::new(b"a"),
      deposit_st: UnorderedMap::new(b"b"),
      deposit_per_owner: LookupMap::new(StorageKey::DepositPerOwner.try_to_vec().unwrap()),
    }
  }

  // Public - beneficiary getter
  pub fn get_beneficiary(&self) -> AccountId {
    self.beneficiary.clone()
  }

  // Public - but only callable by env::current_account_id(). Sets the beneficiary
  #[private]
  pub fn change_beneficiary(&mut self, beneficiary: AccountId) {
    self.beneficiary = beneficiary;
  }
}
'''
'''--- contract/src copy/metadata.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Deposit {
    pub deposit: u64,
    pub mxn: u64,
}
'''
'''--- contract/src copy/xcc.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, Balance};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
const MIN_GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(100_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_transfer)]
pub trait ExtTransfer {
    fn ft_transfer(&self, receiver_id: AccountId, amount: String) -> String;
    fn nft_mint(&self, token_id: TokenId, receiver_id: AccountId, ) -> String;
}
'''
'''--- contract/src/deposit.rs ---
use crate::Contract;
use crate::ContractExt;
use crate::Timestamp;
use crate::*;

use near_sdk::serde::Serialize;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Promise, Balance, Gas};
use near_sdk::json_types::U128;

pub const STORAGE_COST: u128 = 1_000_000_000_000_000_000_000;
//const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(300000000000000);

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Donation {
  pub account_id: AccountId, 
  pub total_amount: U128,
}

#[near_bindgen]
impl Contract {
  #[payable] // Public - People can attach money
  pub fn deposit(&mut self) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let donor: AccountId = env::predecessor_account_id();
    let time: Timestamp = env::block_timestamp();
    let deposit_amount: Balance = env::attached_deposit();
    let mut deposit_so_far = self.total_deposit.get(&donor).unwrap_or(0);
    let end_time_stake = time + 31556926000000000;

    log!("Tiempo recibido {}, tiempo al finalizar {}", time, end_time_stake);
    let to_transfer: Balance = if deposit_so_far == 0 {
      // This is the user's first donation, lets register it, which increases storage
      assert!(deposit_amount > 2000000000000000000000000, "Attach at least 2 NEARs");

      // Subtract the storage cost to the amount to transfer
      deposit_amount - STORAGE_COST
    }else{
      deposit_amount
    };

    // Send the money to the beneficiary
    Promise::new(self.beneficiary.clone()).transfer(to_transfer);

    // Persist in storage the amount donated so far
    deposit_so_far += deposit_amount;
    self.total_deposit.insert(&donor, &deposit_so_far);
    self.internal_add_deposit_to_owner(&donor, &time);
    self.timelocked.insert(&donor, &end_time_stake);

    //stake the deposit
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .with_attached_deposit(deposit_amount)
    .deposit_and_stake();
    
    log!("Thank you {} for deposit {}! You donated a total of {}, your NEARs will be staked until {}", 
    donor.clone(), deposit_amount, deposit_so_far, end_time_stake.clone());

    // Return the total amount donated so far
    U128(deposit_so_far)
  }

  pub fn unstake(&mut self) -> U128 {

    let donor: AccountId = env::predecessor_account_id();
    let time: Timestamp = env::block_timestamp();
    let mut end_time_stake = self.timelocked.get(&donor).unwrap_or(0);
    let mut amount: Balance = self.total_deposit.get(&donor).unwrap_or(0);

    assert!(
      amount > 2000000000000000000000000,
      "Deposit at least 2 NEAR",
    );

    assert!(
      time >= end_time_stake,
      "locked until {}",end_time_stake
    );

    let mut float_amount: f64 = amount as f64;
    float_amount = float_amount * 1.03;
    amount = float_amount as u128;
    end_time_stake = end_time_stake + 259200000000000;

    // unstake the deposit
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .unstake(amount);

    //log!("Tiempo recibido {}, tiempo al finalizar {}", &time, &end_time_stake);
    self.timelocked.insert(&donor, &end_time_stake);
    self.total_deposit.insert(&donor, &0);
    self.deposit_to_withdraw.insert(&donor, &amount);

    U128(amount)
  }

  pub fn withdraw(&mut self) -> U128 {
    
    let time: Timestamp = env::block_timestamp();
    let donor: AccountId = env::predecessor_account_id();
    let amount = self.deposit_to_withdraw.get(&donor).unwrap_or(0);
    let amount_unstaked = self.total_deposit.get(&donor).unwrap_or(0);
    let end_time_stake = self.timelocked.get(&donor).unwrap_or(0);

    assert!(
      amount == 0,
      "You don't have amount unstaked to withdraw",
    );

    assert!(
      amount_unstaked > 2000000000000000000000000,
      "Unstake at least 2 NEAR",
    );

    assert!(
      time >= end_time_stake,
      "locked until {}",end_time_stake
    );

    // withdraw the amount unstaked
    ext_transfer::ext(self.metapoolcontract.parse::<AccountId>().unwrap())
    .with_unused_gas_weight(300_000_000_000_000)
    .withdraw_unstaked();

    //transfer amount unstaked
    Promise::new(donor.clone()).transfer(amount_unstaked);

    U128(amount)

  }

}
'''
'''--- contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    // Public - get donation by account ID
  pub fn get_donation_for_account(&self, account_id: AccountId) -> Donation {
    Donation {
      account_id: account_id.clone(),
      total_amount: U128(self.total_deposit.get(&account_id).unwrap_or(0))
    }
  }

  pub fn get_amount_to_unstake(&self, account_id: AccountId) -> Donation {
    Donation {
      account_id: account_id.clone(),
      total_amount: U128(self.deposit_to_withdraw.get(&account_id).unwrap_or(0))
    }
  }

  // Public - get total number of donors
  pub fn number_of_donors(&self) -> u64 {
    self.total_deposit.len()
  }

  // Public - paginate through all donations on the contract
  pub fn get_donations(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Donation> {
    //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    let start = u128::from(from_index.unwrap_or(U128(0)));

    //iterate through donation
    self.total_deposit.keys()
      //skip to the index we specified in the start variable
      .skip(start as usize) 
      //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
      .take(limit.unwrap_or(50) as usize) 
      .map(|account| self.get_donation_for_account(account))
      //since we turned map into an iterator, we need to turn it back into a vector to return
      .collect()
  }

    //Query for nft tokens on the contract regardless of the owner using pagination
    // pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
    //     //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    //     let start = u128::from(from_index.unwrap_or(U128(0)));

    //     //iterate through each token using an iterator
    //     self.token_metadata_by_id.keys_as_vector().iter()
    //         //skip to the index we specified in the start variable
    //         .skip(start as usize) 
    //         //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
    //         .take(limit.unwrap_or(50) as usize) 
    //         //we'll map the token IDs which are strings into Json Tokens
    //         .map(|token_id| self.nft_token(token_id.clone()).unwrap())
    //         //since we turned the keys into an iterator, we need to turn it back into a vector to return
    //         .collect()
    // }

    // //get the total supply of NFTs for a given owner
    pub fn deposit_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of tokens for the passed in owner
        let deposit_for_owner_set = self.deposits_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(deposit_for_owner_set) = deposit_for_owner_set {
            U128(deposit_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    // //Query for all the tokens for an owner
    // pub fn deposit_for_owner(
    //     &self,
    //     account_id: AccountId,
    //     from_index: Option<U128>,
    //     limit: Option<u64>,
    // ) -> Vec <Donation> {
    //     //get the set of tokens for the passed in owner
    //     let deposit_for_owner_set = self.deposit_per_owner.get(&account_id);
    //     //if there is some set of tokens, we'll set the tokens variable equal to that set
    //     let tokens = if let Some(deposit_for_owner_set) = deposit_for_owner_set {
    //         deposit_for_owner_set
    //     } else {
    //         //if there is no set of tokens, we'll simply return an empty vector. 
    //         return vec![];
    //     };

    //     //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
    //     let start = u128::from(from_index.unwrap_or(U128(0)));

    //     //iterate through the keys vector
    //     tokens.iter()
    //         //skip to the index we specified in the start variable
    //         .skip(start as usize) 
    //         //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
    //         .take(limit.unwrap_or(50) as usize) 
    //         //we'll map the token IDs which are strings into Json Tokens
    //         .map(|token_id| self.nft_token(token_id.clone()).unwrap())
    //         //since we turned the keys into an iterator, we need to turn it back into a vector to return
    //         .collect()
    // }
    
}

'''
'''--- contract/src/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};
use std::mem::size_of;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_deposit_to_owner(
        &mut self,
        account_id: &AccountId,
        timestamp: &Timestamp,
    ) {
        //get the set of tokens for the given account
        let mut deposit_set = self.deposits_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::DepositsPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        deposit_set.insert(timestamp);

        //we insert that set for the given account ID. 
        self.deposits_per_owner.insert(account_id, &deposit_set);
    }

    
    
} 
'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::collections::HashMap;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::U128;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;
/// Raw type for 32 bytes of the hash.
pub type CryptoHash = [u8; 32];

use crate::internal::*;
pub use crate::xcc::*;
pub use crate::metadata::*;
pub use crate::deposit::*;
pub use crate::enumeration::*;

mod internal;
mod deposit;
mod xcc;
mod metadata;
mod enumeration;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
  pub beneficiary: AccountId,
  pub total_deposit: UnorderedMap<AccountId, u128>,
  pub timelocked: UnorderedMap<AccountId, Timestamp>,
  pub deposit_to_withdraw: UnorderedMap<AccountId, u128>,
  pub deposits_per_owner: LookupMap<AccountId, UnorderedSet<Timestamp>>,
  pub metapoolcontract: String
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    DepositsPerOwner,
    DepositsPerOwnerInner { account_id_hash: CryptoHash },
}

impl Default for Contract {
  fn default() -> Self {
    Self{
      beneficiary: "stakedemy.testnet".parse().unwrap(),
      metapoolcontract: "meta-v2.pool.testnet".parse().unwrap(),
      total_deposit: UnorderedMap::new(b"a"),
      timelocked: UnorderedMap::new(b"d"),
      deposit_to_withdraw: UnorderedMap::new(b"c"),
      deposits_per_owner: LookupMap::new(StorageKey::DepositsPerOwner.try_to_vec().unwrap()),
    }
  }
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn init(beneficiary: AccountId) -> Self {
    Self {
      beneficiary,
      metapoolcontract: "meta-v2.pool.testnet".parse().unwrap(),
      deposit_to_withdraw: UnorderedMap::new(b"c"),
      timelocked: UnorderedMap::new(b"d"),
      total_deposit: UnorderedMap::new(b"a"),
      deposits_per_owner: LookupMap::new(StorageKey::DepositsPerOwner.try_to_vec().unwrap()),
    }
  }

  // Public - beneficiary getter
  pub fn get_beneficiary(&self) -> AccountId {
    self.beneficiary.clone()
  }

  // Public - but only callable by env::current_account_id(). Sets the beneficiary
  #[private]
  pub fn change_beneficiary(&mut self, beneficiary: AccountId) {
    self.beneficiary = beneficiary;
  }
}
'''
'''--- contract/src/metadata.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Deposit {
    pub deposit: u64,
    pub mxn: u64,
}
'''
'''--- contract/src/xcc.rs ---
use crate::*;
use near_sdk::{ext_contract};

// const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
// const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
// const MIN_GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(100_000_000_000_000);

#[ext_contract(ext_transfer)]
pub trait ExtTransfer {
    //fn ft_transfer(&self, receiver_id: AccountId, amount: String) -> String;
    fn deposit_and_stake(&self) -> String;
    fn unstake(&self, amount: u128) -> String;
    fn withdraw_unstaked(&self) -> String;
}
'''
'''--- frontend/assets/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #e7f3ff;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  line-height: 1.3;
}

body {
  margin: 0;
  background-color: var(--bg);
}

.donation-box {
  max-width: 24em;
  box-shadow: #bac4cd 0px 0px 18px;
  border-radius: 8px;
}

.column{
  width: 50%;
  float:left;
}

main {
  padding: 2em;
  text-align: justify;
  background-color: #f2f2f2;
  z-index: 1;
  border-radius: 8px;
}

.donation-box-head {
  text-align: center;
  background-color: #fff;
  margin: 0;
  border-radius: 8px 8px 0 0;
  padding: 1em 0em 2em 0em;
}

.logo {
  background-image: url(logo-black.svg);
  background-position: center 0em;
  background-repeat: no-repeat;
  position: relative;
  top: -2em;
  transform: translateX(-50%);
  background-color: #fff;
  padding: 15px 25px;
  height: 40px;
  border-radius: 50px;
  width: 50px;
  box-shadow: #bbb 0px 2px 5px;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

.btn-outline-primary{
  width: 100%;
}

button, input {
  font: inherit;
  outline: none;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

fieldset {
  border: none;
  padding: 2em 0;
}

form {
  margin: 0.2em -0.5em -1em -0.5em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

'''
'''--- frontend/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- frontend/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
  <link rel="icon" href="./assets/favicon.ico" />
  <link rel="apple-touch-icon" href="./assets/favicon.ico" />
  <link rel="stylesheet" href="./assets/global.css">
  <title>Welcome to NEAR</title>
</head>

<body class="p-4 p-sm-5">

  <div class="row">
    <div class="col-sm-8 pe-2 pe-sm-5">
      <h4> Ãšltimos Depositos </h4>

      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col">User</th>
            <th scope="col">Depositos â“ƒ</th>
            <th scope="col">Depositos ðŸ‡²ðŸ‡½</th>
            <th scope="col">stNEAR </th>
            <th scope="col">Valor ðŸ‡²ðŸ‡½</th>
          </tr>
        </thead>
        <tbody id="donations-table"> </tbody>
      </table>

    </div>
    <p></p>
    <p></p>
    <div class="col-sm-4">
      <div class="donation-box mt-md-4">

        <div class="donation-box-head">
          <i class="logo"></i>
          <h4> Saldo Actual</h4>
          <label
            for="saldo"
            data-behavior="saldo"
            style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
          >
          </label>
          <h4> Recarga tu cuenta  <!--<label
            for="beneficiary"
            data-behavior="beneficiary"
            style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
          >
          </label>--> </h4> 
        </div>

        <main class="donation-body signed-out-flow" style="display: none">
          <p>
            Por favor inicia sesiÃ³n con tu NEAR wallet para realizar una recarga.
          </p>
          <p style="text-align: center; margin-top: 2.5em">
            <button id="sign-in-button" class="btn btn-primary">Sign in</button>
          </p>
        </main>
      
        <main class="signed-in-flow" class="donation-body" style="display: none">
          <div class="row">
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(1)"> 1 usd </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donationmx(20)"> 20 mx</button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donationmx(50)"> 50 mx</button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donationmx(100)"> 100 mx</button></div>
          </div>
  
          <form>
            <fieldset id="fieldset">
              <label for="donation" class="form-label" >
                Cantidad por recargar (en â“ƒ)
              </label>
              <div class="input-group">
                <input id="donation" class="form-control" data-behavior="donation" />
                <span class="input-group-text">â“ƒ</span>
                <button class="btn btn-primary" >Recarga</button>
              </div>
            </fieldset>
          </form>
        </main>
  
      <p></p>
      </div>

    </div>

    <div class="col-sm-4">
      <div class="donation-box mt-md-4">

        <div class="donation-box-head">
          <h4> Elije transporte por pagar</h4> 
        </div>      
        <main class="signed-in-flow" class="donation-body" style="display: none">
          <div class="row">
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="payBus()">Bus </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="payTren()">Tren</button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="payMetro()">Metro</button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="payMBus()">MBus</button></div>
          </div>
        </main>
        <p></p>
        <button class="link signed-in-flow" style="display: none; float: right" id="sign-out-button">
          Sign out
        </button>
      </div>
    </div>
  </div>
  <p></p>
  <aside data-behavior="notification" style="display:none" class="bg-success p-2 text-white bg-opacity-75">
    Gracias! Haz realizado una recarga:
    <label for="donation-number" data-behavior="donation-so-far" > </label>â“ƒ
    <footer>
      <div>âœ” Succeeded</div>
    </footer>
  </aside>

  <script src="index.js" type="module"></script>
</body>
</html>
'''
'''--- frontend/index.js ---
import 'regenerator-runtime/runtime'
import { Contract } from './near-interface';
import { Wallet } from './near-wallet'

// When creating the wallet you can choose to create an access key, so the user
// can skip signing non-payable methods when interacting with the contract
const wallet = new Wallet({ createAccessKeyFor: process.env.CONTRACT_NAME })

// Abstract the logic of interacting with the contract to simplify your project
const contract = new Contract({ contractId: process.env.CONTRACT_NAME, walletToUse: wallet });

// Setup on page load
window.onload = async () => {
  const isSignedIn = await wallet.startUp();

  if (isSignedIn){
    signedInFlow()
  }else{
    signedOutFlow()
  }

  fetchBeneficiary()
  getAndShowDonations()
}

// On submit, get the greeting and send it to the contract
document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, donation } = event.target.elements

  //get timestamp date
  let date = new Date().getTime();
  date.toString();
  console.log(date);

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    await contract.deposit(date,donation.value)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }

  // re-enable the form, whether the call succeeded or failed
  fieldset.disabled = false
}

document.querySelector('#sign-in-button').onclick = () => { wallet.signIn() }
document.querySelector('#sign-out-button').onclick = () => { wallet.signOut() }

async function fetchBeneficiary() {
  // Get greeting from the contract
  const currentGreeting = await contract.getBeneficiary()

  // Set all elements marked as greeting with the current greeting
  document.querySelectorAll('[data-behavior=beneficiary]').forEach(el => {
    el.innerText = currentGreeting
    el.value = currentGreeting
  })
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('.signed-out-flow').style.display = 'block'
}

async function signedInFlow() {
  // Displaying the signed in flow container
  document.querySelectorAll('.signed-in-flow').forEach(elem => elem.style.display = 'block')

  // Check if there is a transaction hash in the URL
  const urlParams = new URLSearchParams(window.location.search);
  const txhash = urlParams.get("transactionHashes")

  if(txhash !== null){
    // Get result from the transaction
    let result = await contract.getDonationFromTransaction(txhash)
    document.querySelector('[data-behavior=donation-so-far]').innerText = result

    // show notification
    document.querySelector('[data-behavior=notification]').style.display = 'block'

    // remove notification again after css animation completes
    setTimeout(() => {
      document.querySelector('[data-behavior=notification]').style.display = 'none'
    }, 11000)
  }

}

async function donationmx (amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=mxn").then(response => response.json())
  const near2usd = data['near']['mxn']
  const near_in_pesos = amount * near2usd
  const rounded_two_decimals = Math.round(near_in_pesos * 100) / 100
  console.log(rounded_two_decimals);
  return rounded_two_decimals;
}

async function getAndShowDonations(){
  document.getElementById('donations-table').innerHTML = 'Loading ...'

  // Load last 10 donations
  let donations = await contract.latestDonations()

  document.getElementById('donations-table').innerHTML = ''

  donations.forEach(async elem => {
    let tr = document.createElement('tr')
    let pesos = await donationmx(elem.total_amount)
    document.querySelectorAll('[data-behavior=saldo]').forEach(el => {
      el.innerText = pesos
      el.value = pesos
    })
    tr.innerHTML = `
      <tr>
        <th scope="row">${elem.account_id}</th>
        <td>${elem.total_amount}</td>
        <td>${pesos}</td>
      </tr>
    `
    document.getElementById('donations-table').appendChild(tr)
  })
}

window.set_donation = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=staked-near&vs_currencies=usd").then(response => response.json())
  const near2usd = data['staked-near']['usd']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}

window.set_donationmx = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=mxn").then(response => response.json())
  const near2usd = data['near']['mxn']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}
//https://api.coingecko.com/api/v3/simple/price?ids=staked-near&vs_currencies=usd
window.payBus = async function(){
  //get timestamp date
  let date = new Date().getTime();
  date.toString();
  console.log("Pagando Bus");
  await contract.payment(date,".01".toString())
  location.reload()
}

window.payTren = async function(){
  //get timestamp date
  let date = new Date().getTime();
  date.toString();
  console.log("Pagando Tren");
  await contract.payment(date,".09".toString())
  location.reload()
}

window.payMetro = async function(){
  //get timestamp date
  let date = new Date().getTime();
  date.toString();
  console.log("Pagando Metro");
  await contract.payment(date,".05".toString())
  location.reload()
}

window.payMBus = async function(){
  //get timestamp date
  let date = new Date().getTime();
  date.toString();
  console.log("Pagando MetroBus");
  await contract.payment(date,".06".toString())
  location.reload()
}

'''
'''--- frontend/near-interface.js ---
/* Talking with a contract often involves transforming data, we recommend you to encapsulate that logic into a class */

import { utils } from 'near-api-js'

export class Contract {

  constructor({ contractId, walletToUse }) {
    this.contractId = contractId;
    this.wallet = walletToUse;
  }

  async getBeneficiary() {
    return await this.wallet.viewMethod({ contractId: this.contractId, method: "get_beneficiary" })
  }

  async latestDonations() {
    const number_of_donors = await this.wallet.viewMethod({ contractId: this.contractId, method: "number_of_donors" })
    const min = number_of_donors > 10 ? number_of_donors - 9 : 0

    let donations = await this.wallet.viewMethod({ contractId: this.contractId, method: "get_donations", args: { from_index: min.toString(), limit: number_of_donors } })

    donations.forEach(elem => {
      elem.total_amount = utils.format.formatNearAmount(elem.total_amount);
    })

    return donations
  }

  async latestDeposits() {
    const number_of_depositors = await this.wallet.viewMethod({ contractId: this.contractId, method: "number_of_depositors" })
    const min = number_of_depositors > 10 ? number_of_depositors - 9 : 0

    let deposits = await this.wallet.viewMethod({ contractId: this.contractId, method: "get_deposits", args: { from_index: min.toString(), limit: number_of_depositors } })

    deposits.forEach(elem => {
      elem.total_amount = utils.format.formatNearAmount(elem.total_amount);
    })

    return deposits
  }

  async getDonationFromTransaction(txhash) {
    let donation_amount = await this.wallet.getTransactionResult(txhash);
    return utils.format.formatNearAmount(donation_amount);
  }

  async deposit(date,amount) {
    let deposit = utils.format.parseNearAmount(amount.toString())
    let response = await this.wallet.callMethod({ contractId: this.contractId, method: "deposit", args: { time: parseInt(date)}, deposit })
    return response
  }

  async depositstN(date,amount) {
    let deposit = utils.format.parseNearAmount(amount.toString())
    let response = await this.wallet.callMethod({ contractId: this.contractId, method: "depositst", args: { time: parseInt(date)}, deposit })
    return response
  }

  async payment(date,amount) {
    let deposit = utils.format.parseNearAmount(amount.toString())
    let response = await this.wallet.callMethod({ contractId: this.contractId, method: "payment", args: { time: parseInt(date), amount: deposit} })
    return response
  }

}
'''
'''--- frontend/near-wallet.js ---
/* A helper file that simplifies using the wallet selector */

// near api js
import { providers } from 'near-api-js';

// wallet selector UI
import '@near-wallet-selector/modal-ui/styles.css';
import { setupModal } from '@near-wallet-selector/modal-ui';
import LedgerIconUrl from '@near-wallet-selector/ledger/assets/ledger-icon.png';
import MyNearIconUrl from '@near-wallet-selector/my-near-wallet/assets/my-near-wallet-icon.png';
import NearIconUrl from '@near-wallet-selector/near-wallet/assets/near-wallet-icon.png'

// wallet selector options
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupLedger } from '@near-wallet-selector/ledger';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';
import { setupNearWallet } from '@near-wallet-selector/near-wallet';

const THIRTY_TGAS = '30000000000000';
const NO_DEPOSIT = '0';

// Wallet that simplifies using the wallet selector
export class Wallet {
  walletSelector;
  wallet;
  network;
  createAccessKeyFor;

  constructor({ createAccessKeyFor = undefined, network = 'testnet' }) {
    // Login to a wallet passing a contractId will create a local
    // key, so the user skips signing non-payable transactions.
    // Omitting the accountId will result in the user being
    // asked to sign all transactions.
    this.createAccessKeyFor = createAccessKeyFor
    this.network = network
  }

  // To be called when the website loads
  async startUp() {
    this.walletSelector = await setupWalletSelector({
      network: this.network,
      modules: [setupMyNearWallet({ iconUrl: MyNearIconUrl }),
      setupLedger({ iconUrl: LedgerIconUrl }),setupNearWallet({iconUrl:NearIconUrl})],
    });

    const isSignedIn = this.walletSelector.isSignedIn();

    if (isSignedIn) {
      this.wallet = await this.walletSelector.wallet();
      this.accountId = this.walletSelector.store.getState().accounts[0].accountId;
    }

    return isSignedIn;
  }

  // Sign-in method
  signIn() {
    const description = 'Please select a wallet to sign in.';
    const modal = setupModal(this.walletSelector, { contractId: this.createAccessKeyFor, description });
    modal.show();
  }

  // Sign-out method
  signOut() {
    this.wallet.signOut();
    this.wallet = this.accountId = this.createAccessKeyFor = null;
    window.location.replace(window.location.origin + window.location.pathname);
  }

  // Make a read-only call to retrieve information from the network
  async viewMethod({ contractId, method, args = {} }) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    let res = await provider.query({
      request_type: 'call_function',
      account_id: contractId,
      method_name: method,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
      finality: 'optimistic',
    });
    return JSON.parse(Buffer.from(res.result).toString());
  }

  // Call a method that changes the contract's state
  async callMethod({ contractId, method, args = {}, gas = THIRTY_TGAS, deposit = NO_DEPOSIT }) {
    // Sign a transaction with the "FunctionCall" action
    const outcome = await this.wallet.signAndSendTransaction({
      signerId: this.accountId,
      receiverId: contractId,
      actions: [
        {
          type: 'FunctionCall',
          params: {
            methodName: method,
            args,
            gas,
            deposit,
          },
        },
      ],
    });

    return providers.getTransactionLastResult(outcome)
  }

  // Get transaction result from the network
  async getTransactionResult(txhash) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    // Retrieve transaction result from the network
    const transaction = await provider.txStatus(txhash, 'unnused');
    return providers.getTransactionLastResult(transaction);
  }
}
'''
'''--- frontend/package.json ---
{
  "name": "my-near-app",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "./start.sh",
    "build": "parcel build index.html --public-url ./"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@parcel/transformer-sass": "^2.9.2",
    "@types/node": "^18.6.2",
    "env-cmd": "^10.1.0",
    "nodemon": "^2.0.16",
    "parcel": "^2.6.0",
    "process": "^0.11.10",
    "react-test-renderer": "^18.1.0",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^7.0.0",
    "@near-wallet-selector/ledger": "^7.0.0",
    "@near-wallet-selector/math-wallet": "^7.0.0",
    "@near-wallet-selector/meteor-wallet": "^7.0.0",
    "@near-wallet-selector/modal-ui": "^7.0.0",
    "@near-wallet-selector/my-near-wallet": "^7.0.0",
    "@near-wallet-selector/near-wallet": "^7.0.0",
    "@near-wallet-selector/nightly": "^7.0.0",
    "@near-wallet-selector/nightly-connect": "^7.0.0",
    "@near-wallet-selector/sender": "^7.0.0",
    "@near-wallet-selector/wallet-connect": "^7.0.0",
    "near-api-js": "^0.44.2",
    "prop-types": "^15.8.1",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/start.sh ---
#!/bin/sh

GREEN='\033[1;32m'
NC='\033[0m' # No Color

CONTRACT_DIRECTORY=../contract
DEV_ACCOUNT_FILE="${CONTRACT_DIRECTORY}/neardev/dev-account.env"

start () {
  echo The app is starting!
  env-cmd -f $DEV_ACCOUNT_FILE parcel index.html --open
}

alert () {
  echo "======================================================"
  echo "It looks like you forgot to deploy your contract"
  echo ">> Run ${GREEN}'npm run deploy'${NC} from the 'root' directory"
  echo "======================================================"
}

if [ -f "$DEV_ACCOUNT_FILE" ]; then
  start
else
  alert
fi

'''
'''--- package.json ---
{
  "name": "guest-book-rust",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "cd frontend && npm run start",
    "deploy": "cd contract && ./deploy.sh",
    "build": "npm run build:contract",
    "build:web": "cd frontend && npm run build",
    "build:contract": "cd contract && ./build.sh"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}

'''