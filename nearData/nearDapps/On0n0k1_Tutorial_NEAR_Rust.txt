*GitHub Repository "On0n0k1/Tutorial_NEAR_Rust"*

'''--- EN/README.md ---
# Tutorial_NEAR_Rust

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

A step-by-step course for learning Smart Contract development using Rust. In this set of lessons, we will discuss the main features of the Rust language, 
as well as going over the NEAR platform. 

---

## Contact

[top](#tutorial_near_rust)

For any questions, complaints or suggestions, look me up on Discord On0n0k1#3800. If this course makes your life easier, feel free to buy me a cup of coffe by sending a bit of $NEAR to stiltztinkerstein.near . Thank you!

---

## Topics

[top](#tutorial_near_rust)

 - [What is the Rust language](#what-is-the-rust-language)
 - [Using Rust](#using-rust)
 - [Learning Rust](#learning-rust)
 - [Comparing Rust to Javascript and Python](#comparing-rust-to-javascript-and-python)
 - [Installing](#installing)
 - [Lessons](#lessons)

---

## What is the Rust language

[topo](#tutorial_near_rust)

In short, Rust is a low-level systems programming language with the following features:

 - Execution time in the likes of C or C++.
 - Doesn't have the risk involved with memory management as other low-level languages.
 - It has a steep learning curve (but is is well worth it!).
 - Doesn't have and doesn't need garbage collection. At compile time, the compiler can determine when variables are created and freed. 
 - Easy to do parallel programming. 
 - Async programming has about the same level of difficult as other popular languages.
 - Project and Dependency management is way easier than Python or JavaScript.
 - Has been, for years, the most loved language by the developer community!

---

## Using Rust

[top](#tutorial_near_rust)

A Rust developer can:

 - Create web3 applications using decentralized platforms such as NEAR.
 - Create applications that don't need a virtual machine to run them. Only the compiler is needed to produce an executable.
 - Create fast and compact server software hosted in Docker containers.
 - Create robust applications like Lambda functions that can be hosted on AWS (better web3 performance).
 - Create dynamic libs that can used from C.
 - Compile modules to WebAssembly, which can then be imported in a browser that supports javascript or a runtime (like node.js).
 - Compile robust and fast modules for Python using the PyO3 crate.
 - Compile code that target Embedded systems.
 - Have an edge in the job market where there's very few Rust developers worlwide.

---

## Learning Rust
[top](#tutorial_near_rust)

In my opinion, learning Rust is similar to taming a dragon in a fantasy-world. It is slow, difficult, with a lot of different, and simpler, alternatives. 
But if you do tame it, you will have a **powerful** dragon by your side.

Studies show that it takes as much as 30 times more to write code in a low-level language (like C), than in a higher lever language (like Python or JavaScript). 
It is my experience that for a newcomer learning Rust, it is even slower than writing C. 

But, with practice, we get better at everything. With time, we learn what the compiler expects from us. We can leverage code snippets to generate "boilerplate" code automatically. Then, for the developer, everything just becomes a matter of understanding, memory and patience. There were times when I wrote 800 lines of Rust code
in just 2 days. 

We must always take a break to assess our process and make sure we are making the right calls. if we do, every future step will be easier than the one that came before it. 

---

## Comparing Rust to Javascript and Python

[top](#tutorial_near_rust)

A clever person might ask: "Why would I learn a difficult language if I can already solve the same problems in another language I already know?"... and that is a good question! if I already get good results writing a few lines of code in Python, why would I learn Rust? 

Easy of use and quick problem solving: that is the main focus of those languages. How to get to a solution for our problem the most easiest way. 
Processors were getting faster with each generation, so you could just buy new hardware that was faster and better and increase performance. 

But Moore's Law doesn't apply anymore. So, developers are needing better and more efficient algorithms. This need makes them take a closer look at the code and ask
"What is this instruction doing, exactly?". 

When we write `"a = 3"` in Python, a virtual machine is creating a number object, which entails creating a pointer to that number and then associating variable `a` to that pointer. That's why Python is generally limited to one processor core. When we want to take advantage of larger processing power on our machine, the code complexity increases exponentially in both JavaScript and Python.

Rust's focus isn't about the final result of that execution. It is about the path the processor and memory take to reach that result. An experienced Rust developer can take a look at a block of code and say: 
 - "That memory is going to be freed at this point in code";
 - "The processor is going to request freeing memory here and create a shallow copy of that variable here.";
 - "This function is going to borrow this address, use the value in this part of the code, and then give back that address to the owner.";

---

## Installing

[top](#tutorial_near_rust)

You need to install the following before starting the lessons:

 - Install [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/setup-nearcli.md) to interact with the NEAR platform.
 - Install [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/rust.md) to be able to compile and test projects.

---

## Lessons

[top](#tutorial_near_rust)

 - [Lesson 1: Smart Contracts](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_1_contract)
 - [Lesson 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership)
 - [Lesson 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_3_structs)
 - [Lesson 4: Modules](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_4_modules)
 - [Lesson 5: Using Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage)
 - [Lesson 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums)

'''
'''--- EN/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_1_contract/Readme.md ---
# Lesson 1: Smart Contracts

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Also see:
 - Using [cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md).
 - Using [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/nearcli.md).

---

## Topics
 - [Structure of a NEAR Smart Contract](#structure-of-a-near-smart-contract)
 - [Importing Dependencies](#importing-dependencies)
 - [Allocation macro](#allocation-macro)
 - [Smart Contract declaration](#smart-contract-declaration)
 - [Smart Contract API](#smart-contract-api)
 - [Unit tests](#unit-tests)

---

### Structure of a NEAR Smart Contract
[top](#topics)

Creating a NEAR Smart Contract in Rust can be summarized as:
 - Import crates, modules and other needed dependencies.
 - Allocation Macro (sdk 3.x, but not 4.x)
 - Smart Contract code.
 - Smart Contract API.
 - Unit tests.

The developer is free to add anything to the above list as needed; the steps outlined are just to help memorize the basic steps required to start.

---

### Importing Dependencies
[top](#topics)

Explained in detail in Lesson 4, we need at this point to know the differences between `use` and `mod`. 

```rust
use near_sdk::near_bindgen;
```

Access the `near_sdk` crate and include the macro `near_bindgen` in this namespace. Without this, we would need to write `near_sdk::near_bindgen` every time we needed the macro! Now, we can just write instead a shorter `near_bindgen`. 

Now, let's go over `mod`: 

```rust
mod another_module;
```

This statement means there's a file called "another_module.rs" or a directory with a name "another_module", located in the same place as this Rust file.

If you see a `pub` modifier before the statement, like this:

```rust
pub mod another_module;
```

Or this:

```rust
mod another_module;

pub use another_module::some_dependency;
```

Then it means "another_module" or "some_dependency" can be imported by another external module or crate. 
Importing and Exporting modules is a Rust feature and doesn't have anything to do with the NEAR platform per-se. 

As for Smart Contracts: 

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

We are accessing a crate `near_sdk` declared in `Cargo.toml`, and then we're importing `self`, `BorshDeserialize` and `BorshSerialize` from the borsh module. We're also importing `near_bindgen`. 

 - `self`: Needed for BorshDeserialize and BorshSerialize to work correctly.
 - `BorshDeserialize`: When we call a function in our Smart Contract, we sometimes need to provide arguments. Unless they are an empty JSON, these arguments need to be deserialized. This is what BorshDeserialize does: converts from JSON to an actual type we can use.
 - `BorshSerialize`: The reverse of BorshDeserialize. When we want to send back a result, we need to convert from a type or value to valid JSON. 
 - `near_bindgen`: An annotation (actually, a macro) used on a struct to indicate that **"This is a Smart Contract"**. We need to have at least one `struct` annotated with `near_bindgen` for each contract.

---

### Allocation Macro
[top](#topics)

```rust
near_sdk::setup_alloc!(); // (sdk v.3.x)
```

Macros look like functions, however, they are not executed prior to compilation, but rather used as code generators that can be given configuration arguments. Macros don't exist on the program's final binary output. 

In this case, `setup_alloc` generates the necessary boilerplate code so our Smart Contract can work. This macro only runs once, before the Smart Contract declaration.

:warning: **Heads up**: Adding `setup_alloc` applies to **version 3.x** of the NEAR SDK. Starting from v.4.x you might not need it. Be sure to double check the official NEAR SDK documentation.

---

### Smart Contract declaration
[top](#topics)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```
This code might be easier to explain from the inside-out: 
 - `counter`: is a number. the "i" in i32 means "signed", so it can be either positive or negative. 32 in this case is the number of bits it has.
 - `pub struct Contract`: a struct declaration that specifies the name of the Smart Contract. "pub" means this Smart Contract is publicly accessible.
 - `#[derive(BorshDeserialize, BorshSerialize)]`: Apply the _traits_ BorshDeserialize and BorshSerialize to this struct. Think for now of _traits_ as similar to the concept of interfaces (behavior-wise).
 - `[near_bindgen]`: An annotation that indicates "this is a Smart Contract". The functions on this struct are also Smart Contract functions. When we execute a Smart Contract function, we are basically executing a function on this struct. 

Next, we have: 
```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

`Default` is a "pattern" trait. Think of it as a default constructor (a constructor without parameters) for our struct. `Default` is there to provide a type with a useful default value. `near_sdk` implements this trait for our Smart Contracts, so we need to apply it or we might run into a compilation error. 

`default` is a function of the `Default` trait that returns a struct of the same type. _`Self`_ refers to the Smart Contract itself. The functions return an instance of `Contract` with a `counter` value of `0`.

If we deploy this contract to a NEAR Account, and then we execute a contract function (one that is not an initializer), NEAR's virtual machine would initialize the contract using `default` before executing our contract's function.

---

### Smart Contract API
[top](#topics)

Now, we've come to the actual functions of our Smart Contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - `#[near_bindgen]` is an annotation that indicates "these are the functions of the contract".
 - `impl Contract` is where we declare the functions for our Smart Contract.
 - `&self` and `&mut self` are described in the next lesson. For now, we just need to know that for this type of function that follows the "dot call convention" of `struct_name.function_name`, _`self`_ refers to an instance of the struct.
 - `-> i32` means the return value is a signed 32-bit integer.
 - At the end of the function, the **last line** `self.counter` doesnt end with `;`. the Rust compiler knows how to handle this, as it is the same as having a complete `return self.counter;` statement.

We can now see that the function `get` returns the actual value of `counter` which is being stored on the Smart Contract's `struct` data structure. As for our two contract functions, `increment` adds one to the counter's value, while `decrement` subtracts one from the counter's value.

---

### Unit tests
[top](#topics)

We'll deep dive in more detail in Lesson 4, as we don't need to have all our unit tests for now. We can include unit tests at the end of each Rust module. We can also create a directory `tests`, where all files ending in `.rs` will be considered tests in a test module. 

```rust
#[cfg(test)]
mod tests {
```

`mod tests` is simply a module with a name of `tests`. Nothing special!

`#[cfg(test)]` is quite interesting. `cfg` is a compiler instruction that tells it to "compile the following module if the condition between parenthesis is true". In our case, `(test)` will be true when we run `cargo test`. If we are not running unit tests, this module won't be compiled. 

if, instead of `#[cfg(test)]`, we had:

```rust
#[cfg(not(test))]
mod another_module {
```
Then we would have the opposite scenario, where `another_module` won't be compiled when doing unit testing.

Let's see how we go about unit testing: 
```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
We first need to import the above dependencies for our unit tests. And now:   

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Error.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Before each unit test, we need to set up a mock blockchain environment. One way is to use `VMContextBuilder`, as we just use it to create and configure the desired mock environment, and then use `builder` (which is a VMContextBuilder instance) as an argument to the `testing_env` macro. 

So we don't have to write this code on each test, we can create a function that is re-used.

`assert_eq` isn't really necessary. It just checks the environment variable `env::current_account_id` is the same as the account id specified for the `builder`.

We have three tests:
```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

You can probably see there's a pattern in these tests: 
 - Set up the environment.
 - Initialize the contract. 
 - Execute (exercise) the function we want to test. 
 - Confirm that the function returns the value we expected (or not). 

The function `get` was tested first and this is because it will be used in the following tests. If this function would have not passed the test, we would have to fix it first, before moving on to the other functions. 

---
Lesson 1 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership) will be about Rust's concept of **Ownership**.

'''
'''--- EN/lesson_1_contract/src/lib.rs ---
//! Source <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Documentation Tips:
// Double-slash comments // don't show up in documentation.
// Three-slash comments /// show un as description for what comes next (mod, fn, struct, enum, trait...)
// Bang comments //! can appear at the beginning of the file, and they provide documentation about the entire module.

// imports
use near_sdk::{
    // Arguments received and return values will be converted to/from JSON with borsh
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Creates boilerplatecode needed for NEAR virtual machine
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Smart Contract. This struct contains the state in the VM.
/// Functions here are Smart Contract functions.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Counter.
    counter: i32
}

// Default is used for auto-initialization
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Returns the counter value
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Increments the counter by 1
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decreases the counter by 1
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Unit tests go here
// cfg(test) means this mod will be compiled when doing unit testings
#[cfg(test)]
mod tests{
    // super::* imports all modules
    use super::*;
    // import some near_sdk modules needed for these tests 
    use near_sdk::{
        // an account id, like "stiltztinkerstein.near"
        AccountId,
        // has functions related to the execution environment
        // e.g.: we wanted to know the user account that executed this contract
        // we would use a function found here
        env,
        // Mocks (simulates) the Blockchain
        MockedBlockchain,
        // Macro that sets up the test environment with a valid context
        testing_env,
        // Used to create a test context
        test_utils::VMContextBuilder,
        // A valid account id
        // An account id is a string, but the entire string does not represent the actual valid id
        json_types::ValidAccountId,
    };

    /// This function is not a test. It is used by the tests to setup our mock test environment
    fn env_setup(){
        // Initializes a context builder for our tests 
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes that can be modified using the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // account id string
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tries to convert a string to a valid account id
            // panics if the id is invalid
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // sets up the mock
        testing_env!(builder.build());

        // if the first two arguments are not equal, 
        // return the error message
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// As it is annotated as #[test] this will execute automatically
    /// when we do unit testing
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- EN/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_2_ownership/Readme.md ---
# Lesson 2: Ownership

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Let's learn about Ownership in Rust!

---

## Topics
 - [Functions](#functions)
 - [Background](#background)
 - [Ownership](#ownership)
 - [References](#references)
 - [Using References](#using-references)
 - [Examples](#examples)
 - [Unit tests](#unit-tests)

---

### Functions
[top](#topics)

```rust
/// Returns the length of the string
pub fn get_length(&self) -> u32;

/// Returns the length of the string and changes `name` to another value.
pub fn get_length_again(&mut self) -> u32;
```

---

### Background
[top](#topics)

We'll explain the concept of **Ownership** in the next section, but let's first focus on the problem it solves. 

Consider the following statement:

```
A = B;
```

We know `A`  is equal to `B`, since `A` is being assigned the value of `B`. But what is really happening? 

Are we creating a copy of the value of `B`, and assigning `A` that value? Creating a copy means to allocate memory, get that memory's address and set that memory's address to the value of `B`.  For an integer that seems simple, but what about a 2.000 character string? 

And if we are using a variable as an argument to a function... are we creating a copy of the variable and then dropping it after the function finishes? 

You will realize we need a way to reuse the same memory address in different parts of our application. The C language solved this through the use of pointers. Instead of storing the value of a variable, we store the memory address for that type of variable. 

But that solutions brings another problem. If a function has access to the memory address of a very important variable, then this function has a lot of power. What if this function was implemented without thinking of potential security issues? A hacker could use an implementation flaw or bug to break the application or gain access to the system. 

 - We need a method of handling memory that avoids unnecessary overhead and provides safety. 
 - And, we need to avoid that our chosen memory handling strategy provides more power than it needs to. 

**:hand: NOTE:** Rust also has pointers, but there are different kinds of pointers, with different advantages and disadvantages. C style pointers can be used but the code where they're used (code block) **must** to be annotated as **"unsafe"** ([More](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

### Ownership
[top](#topics)

The following statement:

```
A = B;
```

Can be done in two ways: 
 - If `B` implements a `Copy` trait, it will create a copy automatically. 
 - If `B` doesn't implement `Copy`, `A` will **own** `B`. The compiler will restrict the use of `B`, because the value of `B` was **"moved"** to `A`. 

 - Numbers (`u32`, `f32`, `i32`, ...) implement `Copy` and `Clone`. 
 - String implements `Clone`, but **not** `Copy`.

**:hand: NOTE:** [Whatâ€™s the difference between Copy and Clone?](https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone)

So, in order to create a copy of a String, we need to do it explicitly. 

Ownership guarantees that a variable is the owner of ("owns") a memory address for that variable. Keep in mind, that ownership can be transfered, but to "share" a variable, we can just use pointers or references. 

---

### References
[top](#topics)

References, or borrowing ("borrow") are a way of sharing memory addresses with limited permissions. These references can be mutable or immutable, and are specified as: 

```rust
let a = 10; // Create a variable with a value of 10
let b = &a; // Create a variable b that references variable a
```

```rust
let mut a = 10; // Create a mutable variable with a value of 10
let b = &mut a; // Create a variable that is a mutable reference to variable a
```

Variables are, by default, immutable or more like constants. That's why you need to explicitly declare `a` as mutable. 

 - Immutable references can access a value, but they can't change it.
 - Mutable reference can access **and** change a value.

Here are some rules to remember:
 - You can't change the original value while there's still a reference to it.
 - You can have many immutable references.
 - There can be only **one** mutable reference. 
 - You can't have immutable references if there is one mutable reference.

When we create a reference, we're basically having an "owner" variable "borrow" its value to another variable The "borrowing" ends on the last line the variable is used. 

---

### :warning: Using References
[top](#topics)

**Don't return references just yet!** While returning them is possible, you have to specify the "lifetime" of the return value. You're beginning to learn Rust, and the whole concept of lifetimes can be avoided by simply returning copies when necessary. If you want to know more, then [learn more about lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html) first.

Lifetimes are a **powerful** concept if used correctly. Tools like `serde` and `borsh` use it to convert JSON to the type we need without any copying. That means, memory allocation is only made for our JSON string and for the type we need, nothing more. 

---

### Examples
[top](#topics)

This is our Smart Contract ...
```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

... and here are the functions we will go over as we learn: 

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Both have the same size {} and {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

But before getting into details, let's talk about `String` and `&str`.

---

### What is a `String`

A `String` is a variable that has an owner. It stores a string and will be freed from memory when the variable is dropped. Unlike other languages, keep in a mind a string in quotes, such as `"A text like this"` is not a String, but rather something called a string slice, or `&str`. A reference to a String is denoted as `&String` or `&mut String`.

---

### What is an `&str` (or string slice)

This type simplifies string use in our code. Think of it as an immutable reference to a String, but as it is allocated by the compiler, the compiler gets to decide how to best optimize its memory use.

---

### Using `String` in Functions

Let's take a look at an example of `String` and `&str`:

```rust
let variable: String = String::from("A Variable");
let reference: &str = "A Variable";
```

The function below takes a `&str` and returns its length. The "borrow" ends when the function finishes. 

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    name.len()
}
```
Let's provide the function some arguments:

```rust
this_takes_a_reference(&variable);
this_takes_a_reference(reference);
```
The following functions takes a `String` as argument and returns its length. The functions becomes the **owner** of the memory and drops it when it finishes. 

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```
In order to use arguments with `this_takes_the_ownership` ...

```rust
this_takes_the_ownership(variable);
this_takes_the_ownership(String::from(reference));
```
... we need to convert `&str` to a `String` before passing it.  Also, this function acquired ownership but that wasn't really needed.

Both functions `this_takes_a_reference` and `this_takes_the_ownership` do the same thing, don't cause errors and return the same result. **But**, the first one is more efficient than the second one. Be mindful to prefer using `&str` instead of `String` on function declarations.

You also need to keep in mind that Smart Contract functions annotated with `#[near_bindgen]` need to use the `String` type in their arguments. That's only because the deserialization traits are implemented for `String`, but not for `&str`.

The following function ...

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Both have the same length {} and {}", length_reference, length_ownership,
    );
}
```
... calls `this_takes_a_reference` and `this_takes_the_ownership`, making sure both return the same value (by ussing an `assert_eq`) before actually returning it. 

Let's take a look a another function:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);

    self.name = String::from("Changed name"); // change value of name

    length as u32
}
```
Calls `this_takes_a_reference` and changes the value of `name` stored in the Smart Contract. You can see that there can be many references to the same variable, but be sure to change these as specified [in the code's comments](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership/src/lib.rs) to see how the compiler reacts.

---
Lesson 2 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_3_structs) will be about Rust's structs.

'''
'''--- EN/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// A Macro that generates boilerplate code for NEAR. For v.4 setup_alloc() will be deprecated. 
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Initialize name with a value of "A default string"
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str is a string reference
    // strings between " " are string literals or 'static &str
    // and having a &str as a parameter allows for &String as well as String literals such as "a string like this"
    /// Returns the length of a string
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // This functions does the same as the previous one, but uses a String parameter
    // We can create a String by using the function String::from("our text")
    /// Returns the size of a string
    fn this_takes_the_ownership(name: String) -> usize {
        // return usze, which is u32 in 32-bit systems, and u64 in 64-bit sytems
        name.len()
    }

    /// Returns the size of the string stored in the name variable
    pub fn get_length(&self) -> u32 {
        // Let's call both functions to show they do the same thing
        //
        // Borrowing: Adding & to each argument is allowing the function to use the variable's value, but not modify it
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // Ownership: this function takes ownership of the string, and therefore we need to clone it 
        // notice there's no &
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Let's use assert_eq to test both functions returned the same value
        // if they are different, the code will panic
        assert_eq!(
            // first value to compare
            length_reference, 
            // second value to compare
            length_ownership, 
            // if they're not equal, panic with the provided message
            "The are not the same size {} and {}", length_reference, length_ownership,
        );

        // Convert to u32, this is simple format for json serialization
        // types can be converted using traits, by implementing "into" and "from"
        length_reference as u32
    }

    /// Return the size of the string stored in the name variable, but change its value
    pub fn get_length_again(&mut self) -> u32 {
        // we can declare variables that store references to another value
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // We can have many immutable references
        // but we can't change a variable's value while these references exist
        // If we needed a mutable reference, you can't have any existing immutable references

        // Uncomment the following line to raise an error: existing borrow
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // this next line is Ok, since a reference is no longer used (borrow)
        // and the compiler can drop the borrow
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // fields that can be changed via the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Both functions to the same thing, so both must return the same value
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again also modified the stored string value or the name field
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- EN/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_3_structs/Readme.md ---
# Lesson 3: Structs

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Let's go over `struct` and how ownership is used in our struct functions.

---

## Topics

 - [Introduction](#introduction)
 - [Contract functions](#contract-functions)
 - [Project](#project)
   - [Contract Structure](#contract-structure)
   - [`Clone` trait](#clone-trait)
   - [`just_a_function`](#just_a_function)
   - [Macros](#macros)
   - [`take_ownership`](#take_ownership)

---

## Introduction
[back](#topics)

A `struct` is similar to a class in other object-oriented programming languages. The difference is that a `struct` doens't support inheritance, but we can implement one or more traits on them, and these traits specify behavior. 

We'll dive into traits in future lessons, but for now, consider traits as sets of functions that represent behavior supported by types. The trait `Clone` allows using the `.clone()` function to create copies of an instance. The trait `BorshDeserialize` lets you build an instance of a type by using a JSON formatted string. 

Later on, we'll learn how to create trait functions that can be applied to any type. For now, we'll just focus on structs.

---

## Smart Contract functions
[top](#topics)

```rust
// gets and sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// A function that doesn't change the contract's state
pub fn just_a_function();

// A function using StructExample that takes ownership of itself and is dropped at the end
pub fn take_ownership(&self) -> u32;
```
See their implementations for details.

---

## Project

[top](#topics)

We'll first create a `struct` called `StructExample`.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
This type has the following fields: 
 - `an_integer`: an unsigned 32-bit integer.
 - `another_integer`: a signed 32-bit integer.
 - `a_floating`: a floating 32-bit number.
 - `a_string`: a String, described in the previous lesson.

In other languages, we might have to write `long int` for i32, or `long long int` for i64. However, in Rust, we just need to specify the `i` for "signed" (positive or negative) and `u` for "unsigned" (positive). All types such as `u8`, `u16`, `u32`, `u64` and `u128` are all valid "unsigned" types.

---

### Contract Structure

[top](#topics)

Here's the Smart Contract code:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```
See how this Smart Contract is annotated with `derive`? When you `derive`, it means the compiler is able to provide a basic implementation for some traits, but you can manually implement them if more complex behavior is needed. Here, `derive` for `Default` will make sure **all fields** of `Contract` have a `.default()` function. This also means that `StructExample` must also implement the `Default` trait. 

:hand: Be sure to read about [Serialization Protocols](https://www.near-sdk.io/contract-interface/serialization-interface) if you want a deeper understanding of how BorshSerialize and BorshDeserialize works in NEAR. 

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```
We used some random values for this example. We also don't need to specify `an_integer: an_integer` or `a_floating: a_floating` when the names of the variables are the same.

---

### `Clone` trait
[top](#topics)

Let's implement the `Clone` trait on our `StructExample`:

```rust
impl Clone for StructExample{
    // self is an instance of StructExample, Self (uppercase) is of type StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self and StructExample are the same
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```
:hand: **NOTE:** Remember, I'm intentionally writing code in a more complex way just to show the different ways our implementation could be made. 

There really isn't much to say on `get` and `set` functions, you can just check the comments. 

Let's go over `just_a_function` and `take_ownership`:

---

### just_a_function

[top](#topics)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
This function outputs two lines of text. 

The `log` function receives a sequence of bytes as an argument. 
So, in our first call, you can use "b" as a way to indicate that the following string should be treated as bytes. 

The second time, we use the macro `format!` to format a String. The String type has a function `.as_bytes()` that converts its value to bytes. If you want to learn more, then be sure to read about [as_bytes()](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[top](#topics)

For now, let's consider a **macro** as a function that will execute prior to code being compiled. These functions generate code for you. After the code is generated, the compiler runs and error checking happens. The most common scenario for a **macro** is to allow for functions with a variable number of parameters. 

Another way to see macros would be as a way to trade code complexity for ease of use. 

---

### take_ownership
[top](#topics)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self will be dropped / freed here
}
```

This is an interesting piece of code: 
 - Prints "Taking ownership of itself" on screen. 
 - Prints the value of `an_integer`, which is a contract variable. 
 - Finally, returns the value of `an_integer`.

However, as we used `self` instead of `&self`, as well as `&mut self` as an argument, this function will take ownership of itself and will "self-destruct" after finishing execution. 

:hand: **NOTE:** a beginner will probably get a confusing error from the compiler while attempting to write the code above, such as "value used here after move".

---
Lesson 3 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_4_modules) will be about Rust's modules.
'''
'''--- EN/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive is a macro that generates code for the specifiec traits between ()
// we use it so the contract gets trait implementations of BorshDeserialize and BorshSerialize
// StructExample is the state of a contract, so we need these two traits in place
#[derive(BorshDeserialize, BorshSerialize)]
// A struct with primitive types
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default is executed when the code loads and prior to initialization
// it can be called manually to create an instance with default values
impl Default for StructExample{
    fn default() -> Self {
        // you can set field values using name: value
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        // and here we return the struct with the default field values we specified
        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone creates a copy of the struct
impl Clone for StructExample{
    // self is an instance of StructExample, and Self (uppercase) is the actual StructExample type.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self and StructExample are the same here
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Let's implement the functions for StructExample
impl StructExample{

    // &self means borrowing a StructExample instance, but it can't modify it
    /// Returns a String copy of the a_string field value
    pub fn get_a_string(&self) -> String {

        // String implements the Clone trait, but not Copy
        // Copy creates an instance (a copy) automatically with an instruction like a = b 
        // Clone creates an instance (a copy) when the code calls clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implements Copy, so this will create a copy of a_floating automatically
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // you dont' need to write the 'return' statement every time
        // if the line is the last one and it doesn't have ';' at the end, assume return
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // '&mut self' will borrow a StructExample instance and also make changes to it
    pub fn set_a_string(
        &mut self, 
        // For the following a_string_arg, the function will take ownership since we are not borrowing it using &
        // This means this function now owns this piece of memory and 
        // that code that called this function won't need this string again
        //
        // This is one of Rust's superpowers: It allows to minimze the amount of copies we need
        a_string_arg: String,
    ) {
        // as we borrow a mutable self, we can change its field values
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 is unsigned, only positive values
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 is signed, values can be positive or negative. This halves the max value allowed
        self.another_integer = another_integer;
    }

    // if the function doesn't have 'self', then it is a function associated with the type itself
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // if 'self' is an argument, the function will take ownership of the instance
    // this meand the struct will be dropped at the end of the function (unless we return it)
    // this is just an example, you probably won't ever need to do this
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self will be dropped/free from memory here
    }
}

// #[near_bindgen] instructs near-sdk that this struct is the state of our Smart Contract
// we can use any name, but 'Contract' is easy to understand
#[near_bindgen]
// derive is a macro that generates the specified trait implementations on our StructExample
// we use it so our contract supports BorshDeserialize and BorshSerialize
// These traits define how data structures are translated into bytes which are needed for passing data
// into methods of the smart contract or storing data in state.
//
// For method parameters, JSON (default) and Borsh are supported.
// For storing data on-chain Borsh is used.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // The functions below redirect to the struct functions. 
    // The difference being is that these ones below, represent how we interact with the actual Smart Contract
    
    
    // get_* functions need &self, and set_* need to make changes so we use &mut self
    // using '&self' for get_* functions
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // using 'mut &self' for get_* functions
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function doesn't use '&self', '&mut self' or 'self'
    // so is is just a function in the same namespace as our struct
    pub fn just_a_function(){
        // you can use :: to reference items in namespaces. Our function here is not an instance of our struct. 
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A funÃ§Ã£o take_ownership libera o objeto da memÃ³ria.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador nÃ£o irÃ¡ nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessÃ£o (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy serÃ¡ removido no fim dessa funÃ§Ã£o abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irÃ¡ aparecer.
        // Isso Ã© porque chamamos uma funÃ§Ã£o de uma instÃ¢ncia que nÃ£o existe mais.
        // env::log(format!("Essa linha de cÃ³digo irÃ¡ gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg instructs the compiler to consider the 'tests' module as a test harness. You can then use 'cargo test' to use this module 
// for running functions with a #[test] attribute, automatically
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // fields that can be changed via the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // We declare a Contract instance with default field values
        // You can use an underscore _ in front of a variable name if you know in advance
        // you are not going to use it immediately (that way the compiler won't complain)
        let _contract: Contract = Contract::default();

        
        // Note we use :: since this function doesn't require state
        Contract::just_a_function();
    }

    #[test]
    // take_ownership is just an example of another way to do things in Rust
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- EN/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_4_modules/Readme.md ---
# Lesson 4: Modules

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

In this lesson we will talk about organizing our code and using modules.

We could have all our code in a single `lib.rs` file, but this would file would increase in size and complexity very fast, and it would also be very difficult to organize a large project around a single file with all our code in it.

Here's some ways we can organize our code: 

 - We can declare external modules; 
 - We can declare directories as modules;
 - We can control when our modules are public (can be used by anyone);
 - We can control the path for each public module;
 - We can put our tests in a `./tests/` directory. 

---

## Contract API

```rust
/// Returns the stored String
pub fn get_phrase(&self) -> String;

/// This function will print "Hello from crate::a_module"
/// and store that value
pub fn hello(&mut self);

/// This function will print "Hello from crate::a_module::specific_module"
/// and store that value
pub fn hello1(&mut self);

/// This function will print "Hello from another module" 
/// and store that value
pub fn hello2(&mut self);

/// This function will print "Hello from yet_another_module" 
/// and store that value
pub fn hello3(&mut self);

/// This function will print "Called a deep function"
/// and store that value
pub fn hello4(&mut self);

/// This function will panic and print "A panic just happened"
/// when called
pub fn this_will_panic();
```

---

## Topics
 - [How to declare an external module](#how-to-declare-an-external-module)
 - [How to use a file or directory as a module](#how-to-use-a-file-or-directory-as-a-module)
 - [Using or Importing modules](#using-or-importing-modules)
   - [Aliases](#aliases)
   - [Public access](#public-access)
 - [Tests](#tests)
   - [NEAR integration tests](#near-integration-tests)
   - [Rust tests](#rust-integration-tests)
  - [Disable compiler warnings](#disable-compiler-warnings)
  - [Testing errors](#testing-errors)

---

## How to declare an external module

[top](#topics)

An external module must be declared prior to using or importing it.

```rust
mod yet_another_module;
```

This declaration tells the compiler there is a module with this name in the same directory. There are three ways to declare a module. If two or more modules with the same name are found, an ambiguity error will be raised.

The module above is private, so it can be used where it was declared. We can turn it public by using:

```rust
pub mod a_module;
```

`a_module` is now public... this means that it can be imported by other code, including external crates.
If you want to restrict that, you can write:

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```
`pub(crate)` means this function will only be public in this crate. This means that if `lesson_4_modules` was a dependency of another project, that crate would not have access to this function.

---

## How to use a file or directory as a module

[top](#topics)

We can use a file or directory as a module, and there are two ways to do it. 

The first one: 
 - Create a directory with the name we want for our module.
 - Create a file with name `mod.rs` inside that directory. This file will be our module's implementation.

![Image of a directory with mod.rs file](../static/images/mod-diretorios.png)

 In the above image, directory `a_module` with a `mod.rs` is our module.

The second one:
  - Create a Rust file with the same name as our module. This file is the module's implementation.

![Image of a directory with a Rust file that is also a module](../static/images/mod-diretorios2.png)

`internal_module.rs` is our module and the file contains the module's implementation.

---

## Using or Importing modules

[top](#topics)

You can import modules, functions, structs, traits and enums by using the `use` keyword.

Let's look at an example: below, we are bringing both `env` and `near_bindgen` from `near_sdk` (which happens to be a crate in this case) into scope. 

```rust
use near_sdk::{env, near_bindgen};
```
Just keep in mind that you actually don't have to use `use` (pun intended). If we wanted to, we could access `env` by writing `near_sdk::env` every time we needed it (meaning, write the full path).

---

### Aliases

[top](#topics)

We can use the `as` keyword to alias an import to another name:

```rust
use a_module::specific_module::hello as hello1;
```
There are a few `hello` functions in this example. Let's alias their names using the `as` keyword. In the above example, calling `hello1()` will be the same as calling `a_module::specific_module::hello()`.

---

### Public access

[top](#topics)

Let's see some ways to organize access to modules and functions:

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

The above will bring both `hello` functions into scope, aliasing `hello2` and `hello3` while making them public; just as-if they were declared in this module. 

If we had a file `yet_another_module.rs` with:
```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```
We are declaring `internal_module` exists and is private. However, we are also bringing `a_deep_function` into scope **and** making it public; and so, you can access this function using the path `yet_another_module::a_deep_function` without even knowing (or caring) that function resides in a completely different directory. 

Organize your modules (and directories) according to your project's needs, and then use `pub use` to export or make items available for external users. 

:hand: `pub use` and `pub mod` are used for public modules and crates when using them as libraries in other projects. These are language features and have no relation to NEAR contracts. 

:warning: Remember Rust changes often, so be sure to keep up-to-date. You can always check the docs for the [Rust Editions](https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html).

---

## Tests

[top](#topics)

NEAR has its own way to do testing which is different than Rust's tests; the former are more so integration tests while the latter are unit tests. This is because NEAR's tests are more about simulating interaction between different smart contracts on the blockchain.

---

### NEAR integration tests

[top](#topics)

The testing tool commonly used for testing NEAR Smart Contracts is called [workspaces-rs](https://github.com/near/workspaces-rs).

But just to complicate things, there's _also_ something called **workspaces** in Rust, but they are very different things. A [Workspace](https://doc.rust-lang.org/cargo/reference/workspaces.html) in Rust is a collection of one or more packages that share dependencies, target and other settings such as profiles.

Integration testing was done with the crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), but this tool will deprecated in favor of the [sandbox](https://docs.near.org/docs/develop/contracts/sandbox).

---

### Rust integration tests

[top](#topics)

We usually declare our tests in the same file: 

```rust
#[cfg(test)]
mod tests{
    // load everything from this module
    use super::*;

    #[test]
    fn hello_test(){
```

But most of the time, we declare tests in their own directory and with their own file structure. 
We can create a directory `tests` alongside `src`.

![Image of root directory with directory "tests" highlighted](../static/images/testsdirectory.png)

We can then execute `cargo test`, and every `.rs` file will be treated as a test. All functions with an attribute of `#[test]` will be executed automatically. You can just place tests in `.rs` files, there's no need to create a `mod` for them. 

For our lesson, the directory `tests` acts as a separate crate. Let's import the `common` module found under `tests`, and bring it into scope in `contract.rs`.

```rust
mod common;

use common::env_setup;
```
To import modules in the same create, we can use the crate's name: 

```rust
use lesson_4_modules::Contract;
```

---

## Disable compiler warnings

[top](#topics)

Warnings are sometimes generated during compilation, but you can opt-out of them by using attributes before code: 

```rust
#[allow(unused)]
```
The above attribute would allow unused code to exist following the attribute and not generate a compiler warning.

However, you should always fix any compiler warnings and not ignore them. But here's an example when these attributes come in handy: the naming convention for JavaScript is to use `CamelCase`, while the naming convention for Rust is `snake_case`. If we are interacting with a contract using near-api-js, readability could be improved by using JavaScript's naming convention. 

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

We could also allow to ignore any warnings related to imports not being used:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```
While these can sometimes be useful, **please** get into the habit of **fixing any warnings**, and do not ignore or hide them from the compiler by using attributes.

---

## Testing errors

[top](#topics)

We can also create tests that expect an error, and therefore testing in this manner guarantees that we are also taking care of any possible (expected) errors in our functions. 

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

The function above is **expected** to panic, and therefore when it does, our test passes.

On the flip side, if our functions doesn't panic or does so with a different message that the one we specified, our test will fail. 

---
Lesson 4 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage) will be about Rust's modules.
'''
'''--- EN/lesson_4_modules/src/a_module/mod.rs ---
//! Declaring modules:
//! Use a directory name for the module you want and put a mod.rs file in it, 
//! or create a .rs file with the same filename as the module you want
pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- EN/lesson_4_modules/src/a_module/specific_module.rs ---
// Specifying (crate) after pub allows a function (or module, trait, etc) to be available to 
// other local modules (the same crate), but not to external crates
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// use the panic! macro to raise an error and halt/terminate the application
/// we can call panic! whenever we need it
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) tells the compiler these is a module with tests (test harness)
// and you can then use 'cargo test'
#[cfg(test)]
mod tests{
    // load everything 
    use super::*;

    #[test]
    fn hello_test(){
        // hello() is public for modules in the same crate
        // we'll try to import it from the test directory, which would cause an error
        // the test directory is its own crate
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // we can also test scenarios where an error is raised (panic)
    // and so we can ensure we panic for the right reason
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- EN/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A funÃ§Ã£o abaixo Ã© privada.
// this is a private function
// #[allow(unused)] tells the compiler to ignore this 'unused code' warning (no warning)
// Comment #[allow(unused)] so the compiler raises a warning
#[allow(unused)]
fn this_is_private() -> String {
    String::from("This will never be used because it's private")
}

'''
'''--- EN/lesson_4_modules/src/lib.rs ---
//! This example focused on module management
//! 
//! 
//!
//! The search order for crates and modules is normally:
//! 
//!  - default (std), 
//!  - other crates (like near-sdk), 
//!  - crates in the workspace, 
//!  - local modules.
//!
//! 
//! 'mod modname' tells the compiler to compile files in the directory, or file, with that name
//! and to use bring into scope the module we then use the keyword 'use'
//! 
//! 'pub mod' allows other modules to access and use the module
//! 'pub use' works like the above (bring into scope)

// Here we declare there's a module called 'a_module' and it is public
// (which can be either a file with that name, or a directory with that name and a mod.rs file inside the directory)
pub mod a_module;
// Here we declare 'another_module' (in our example, a file called 'another_module.rs')
mod another_module;

// and one more file based module
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// we can use the 'as' keyword to alias functions
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// and we can use 'pub use' to export function as public to external crates
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// the actual location (path) of 'a_deep_function' is 'yet_another_module::internal_module::a_deep_module::a_deep_function'
// but this full path is private. 
// however, remember we used 'pub use' for this function on 'yet_another_module' and so we can use that shorter path 
use yet_another_module::a_deep_function as hello4;

// uncomment the following line to get a compiler error (private access)
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// this function will help to keep cleaner code
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Returns the stored string value
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// Logs "Hello from crate::a_module" and 
    /// stores that string value 
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// Logs "Hello from crate::a_module::specific_module" and 
    /// stores that string value 
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// Logs "Hello from another module" and 
    /// stores that string value 
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// Logs "Hello from yet_another_module" and 
    /// stores that string value 
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// Logs "Called a deep function" and 
    /// stores that string value 
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// this function will panic when called, with a message "A panic just happened"
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Tests can be found in the 'tests' directory. This best practice helps with keeping our code organized. 

'''
'''--- EN/lesson_4_modules/src/yet_another_module.rs ---
// internal_module is private
// no access by external modules
mod internal_module;

// we export a_deep_function as public so other modules can access it
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- EN/lesson_4_modules/src/yet_another_module/internal_module.rs ---
// export a_deep_module as public
pub mod a_deep_module;

'''
'''--- EN/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// a public function found in a_deep_module
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- EN/lesson_4_modules/tests/another.rs ---
//! Each rust file in the tests directory will be run individually

// Uncomment the line below to get a 'private' warning from the compiler
// this happens because this module is public within the same crate, but 'tests' is its own crate
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- EN/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // fields than can be set with the builder
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- EN/lesson_4_modules/tests/contract.rs ---
//! This module tests the Smart Contract

// the 'common' module contains utility functions to be used in all our tests
mod common;

// The 'test' directory is its own crate, 
// So when we import our own modules we need to refer to them as
// "lesson_4_modules::" instead of "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // we used derive(Default) in our contract
    // and the default for String is an empty string
    assert_eq!(contract.get_phrase(), "");
}

/// Assigns "Hello from crate::a_module" to phrase and test the value afterwards
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Assigns "Hello from crate::a_module::specific_module"  to phrase and test the value afterwards
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Assigns "Hello from another_module"  to phrase and test the value afterwards
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Assigns "Hello from yet_another_module"  to phrase and test the value afterwards
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Assigns "Called a deep function"  to phrase and test the value afterwards
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

// We can also test error situations, known as 'panic'
// This function will raise an error (panic) with the message "A panic just happened"
// Our test checks if indeed panic happened, and will pass if this was the case
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora nÃ£o utilizemos o state, Ã© bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- EN/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_5_macro_usage/Readme.md ---
# Lesson 5 - Macros

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Macros are a fundamental tool if you want to be an effective Rust developer. While it is not necessary to learn how to create them, you definitely need to learn how to use them.

---

## Smart Contract API

```rust
/// This function shows the differences between println and env::log
/// Run `cargo test -- --nocapture`, compile, deploy and run in NEAR.
/// Note how some messages will show up and some will not. 
pub fn print_examples();

/// Format examples. Check the output depending on how it is implemented.
pub fn format_examples();

/// Panic examples.
pub fn panic_example();

/// Using Vec (vectors) examples
pub fn vec_examples();
```

## Topics

 - [What is a Macro?](#what-is-a-macro)
 - ["function-like" Macros](#"function-like"-macros)
 - [Advantages](#advantages)
 - [Disadvantages](#disadvantages)
 - [Useful Macros](#useful-macros)
   - [format, println and panic](#format-println-and-panic)
   - [Compound types](#compound-types)
   - [setup_alloc](#setup_alloc)
 - [Extra: String and str](#extra-string-and-str) 

---

## What is a Macro?

[top](#topics)

Quite simply, a **macro** is a tool run at compile time that generates code. They're part of something called _metaprogramming_, which helps you write less code, which in turn also decreases the amount of code you have to maintain down the road.

The annotation `derive` is a Macro: 

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```
In this case, the `derive` annotation is used to apply a trait to new types. 

There's another type of Macro, in which you annotate types with "attributes":

```rust
#[near_bindgen]
impl Contract{
```

Finally, let's go over some "function-like" macros. As the name implies, these resemble a function call where you can even provide arguments. Some examples would be:

```rust
// Prints a string using the provided format pattern
println!("{}", message);

// Format arguments as a String
format!("7");

// Panic and provide an error message formatted to match the given pattern
panic!("Panic with arguments: {} {} {}", 1, second, 3);

// Creates a Vec with the the list of arguments
vec![1, 2, 3, 4];

// Create boilerplate code for Smart Contract
near_sdk::setup_alloc!();

// Used in Tests.
// Uses the builder argument to create a Context for the virtual machine environment
testing_env!(builder.build());

``` 
---

## "function-like" Macros

[top](#topics)

These macros are used like functions, but there are some differences between them. For one, they are more flexible since they can take an unknown number of arguments. 

Let's use `vec` to see another difference: 

```rust
vec![1, 2, 3, 4];
```
`Vec!` uses square brackets `[]` instead of parentheses `()`, but remember that macros also use curly brackets `{}` in their definition. Macros can use any type of text inside these delimiters, and a developer can pass anything as an argument as long as the macro implementation understands it. 

---

## Advantages

[top](#topics)

 - Simplifies code.
 - They're run at compilation time, so if they are well implemented, they are very efficient and carry little or no overhead. 

---

## Disadvantages

[top](#topics)

 - A developer need to take a close look at the documentation for each macro that is in the code. 
 - They can make debugging harder. 
 - They increase overall compilation time.
 - They can "blow up" your code base with "ghost" (invisible) code. 

---

## Useful Macros

Here are some macros we find very useful.

### `format!`, `println!` and `panic!`

[top](#topics)

 - `format!` returns a formatted String.
 - `println!` prints a String using a formatting pattern.
 - `panic!` stops execution and prints a String as an error message.

```rust
println!("This is println!, it wont show up in the virtual machine");

// We create a "message" variable of type String with a value of "format returns a formatted string."
let message: String = format!("remember format {}", "returns a formatted string");

// Stops execution with an error message "Panic with some arguments: 1 2 3"
let second = 2;
panic!("Panic with some arguments: {} {} {}", 1, second, 3);

```
Using these macros is quite simple: your first argument would be a formatting string, which includes placeholders "{}" for arguments you'll be providing as arguments later. 

You can customize string formatting in several ways, so be sure to learn more about [formatting](https://doc.rust-lang.org/std/fmt/index.html). Here are some examples:

```rust
// format Examples
log("\n\nformat_examples:\n");
 
let message: String = format!("Format returns a formatted string");

let an_arg = "third";

// format! can receive sequential arguments using {}. 
let message = format!("format can receive argument using {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// we can specify arguments by using their names
let message = format!("We can also specify argument by variable names: {first}, {second}, {third}.");

// we can also specify them by position
let message = format!("We can also specify them by position: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// we can also specify formatting options, in this case, number-formatting (digits)
let message = format!("We can specify digits for numbers: {:02}, {:04}, {:6}.", first, second, third);

// specifying position and number-formatting
let message = format!("And specify digits and ordering: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// we can also specify precision for floating points
let message = format!("We can specify precision for floating points: {:.2}, {:.4}, {:.6}", first, second, third);

// specify precision and number of digits
let message = format!("And specify precision and number of digits: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// specify precision, number of digits and argument position
let message = format!("We can specify precision, digits and ordering of arguments: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// same as the previous one, but using argument names
let message = format!("Same as the previous one, but using argument names: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### Compound types

[top](#topics)

Let's go over some ways to group data (formally called compound types).

Tuples are fixed-length (they cannot grow or shrink):

```rust
// an integer tuple
// you can have different types for each of the tuple's elements
// tuples use ()
let a_tuple: (u32, u32, u32) = (0, 1, 4);

// we can access tuple values by index number
println!("The 2nd value is {}", a_tuple.1);
```

Arrays are also fixed-length, and are stored on the stack. 
Unlike tuples, every element of an array must have the same type.

```rust
// declaring an array
// arrays use []
let an_array = [0, 1, 2];

// we access array values using indices
// remember we start at 0
println!("The 3rd value is {}", an_array[2]);

// here we declare an array with 10 integers that have a default value of 0
let mut another_array: [i32; 10] = [0; 10];

// let's change the first element, at index 0
another_array[0] = -1;

// let's get the first element's value, which we changed from 0 to -1 above
println!("The first element's value is {}", another_array[0]);
```
Arrays and Tuples are primitive types, and always keep in mind that these are fixed length. If we needed more flexibility, we can use collections. We have Rust collections and NEAR collections; the former are a part of the language, while the latter are stored on a data structure called a ["trie"](https://en.wikipedia.org/wiki/Trie). You need to learn about Rust collections in order to come up with quality code and logic, and you need to learn NEAR collections to come up with the most efficient way to save state on the blockchain.

 - Learn about [Rust collections]((https://doc.rust-lang.org/std/collections/)).
 - Learn about [NEAR collections](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) (use these when developing Smart Contracts).

Probably the most useful (and used) collection in Rust is `Vec`. [Learn more](https://doc.rust-lang.org/std/vec/struct.Vec.html) about it. Using this type, we can store data, known as elements, count them, access and change them too. 

:hand: **NOTE:** lowercase `vec!` is a macro to generate vectors (note the ! at the end), while uppercase `Vec` is a type (a struct actually).

We can create a vector specifying explicit values: 
```rust
// Vec with integers 1 2 3 4
let example = vec![1, 2, 3, 4];
```

We can also create a vector specifying the default value and the quantity of elements we want:
```rust
// Vec with 5 elements, default value of 0, which is then vector [0, 0, 0, 0, 0]
let example = vec![0;5];
```
Formatting and printing values can be a bother, but Rust comes to our rescue by providing out-of-the-box solutions with Debug and Pretty-print formatting utilities that work with `println!`, `format!` and `panic!`. 

```rust
let example = vec![1, 2, 3, 4];

// using debug formatting
log(&format!("Let's print a vector with debug formatting:\n{:?}\n\n", example));
// using pretty-print formatting
log(&format!("Let's print it using \"pretty print\":\n{:#?}\n\n", example));

// using debug formatting
log(&format!("We can do the same with tuples:\n{:#?}\n\n", (1, 2, 3)));
// using debug formatting
log(&format!("Let's create vectors with default values:\n{:?}\n\n", vec![0;5]));
```

When you specify `{:?}`, that means apply debug formatting.
You can also use `{:#?}` for pretty-print formatting, which makes the values more legible. Most of the time pretty-print will output an element per line.

Feel free to learn more about [module std::fmt](https://doc.rust-lang.org/std/fmt/index.html), and deep dive into utilities for formatting and printing strings.

You can also learn more about implementing the [Debug trait](https://doc.rust-lang.org/std/fmt/trait.Debug.html) on structs or enums.

---

### setup_alloc

[top](#topics)

This macro needs to be placed prior to declaring a Smart Contract. Its will generate the boilerplate code needed for everthing to work. 

```rust
near_sdk::setup_alloc!();
```

:warning: **NOTE:** Starting from version 4.x of the NEAR SDK, this macro will be deprecated. However, adding the `setup_alloc!()` macro is needed for version 3.x.

---

## Extra: `String` and `str`

[top](#topics)

`String` e `str` are two very different types. `String` is a type which keeps ownership of a string, but `str` (known as a string slice), is commonly used to keep references to strings; this type exists to minimize string copies at runtime. 

:warning: **Remember:**
 - The `str` type will be used as `&str`. This applies to a "string like this one in quotes" but also `&String`.
 - Anytime you need a reference to a `String` in a function, use `&str` and not `&String`. 
 - String literals like "this one in quotes" are actually `&'static str`. If this looks complicated, don't worry, you'll learn all about this when we discuss Lifetimes. In theory, this type of strings will never be dropped from memory, but that behavior will actually depend on optimizations done by the compiler. 

--- 
Lesson 5 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums) will be about Enums.

'''
'''--- EN/lesson_5_macro_usage/src/lib.rs ---
//! Examples for the following macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// This function is used in print_examples and compiled when test option is used.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// This function is used in print_examples and NOT compiled when test option is used.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // This smart contract doesn't have state
}

#[near_bindgen]
impl Contract{
    /// This function shows differences between println! and env::log
    /// Run with `cargo test -- --nocapture`, compile, deply and execute on NEAR
    /// You'll notice some of these will print out, but others will not
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("This println! will not output in the virtual machine");
        let a = String::from("something");
        println!("Another println! with some arguments, {}, {}, {}", 1, "thingy", a);

        env::log(b"This is a log, it will not output in test.");
        env::log("another log".as_bytes());

        env::log(
            format!("A log with some arguments: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("A message that shows up in the virtual machine during when testing.");

        log(
            &format!("Another message with arguments, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// examples for format!
    /// check the message output for each format! use
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format returns a formatted string");
        log(&message);

        let an_arg ="third";
        let message = format!("format can receive argument using {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("We can specify arguments by variable name: {first}, {second}, {third}.");

        log(&message);

        let message = format!("We can specify the ordering of arguments for format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("We can show integers with specified digits: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Specifying digits and argument ordering: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Specify precision for floating points: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Specifying both precision and digits: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Specify precision, digits and ordering of arguments: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Same as previous one but with variable names: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Example for panic!
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("The panic! macro is used just like println! and format!");

        let second = 2;
        panic!("panic! with arguments: {} {} {}", 1, second, 3);

    }

    /// Example for vec!
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Let's print a vector with debug formatting:\n{:?}\n\n", example));
        
        log(&format!("Let's print it using \"pretty print\":\n{:#?}\n\n", example));

        log(&format!("We can do the same with tuples:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Let's create vectors with default values:\n{:?}\n\n", vec![0;5]));

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Run test with this command
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture will print everything as output, 
// Without --test-threads, all tests will run async and so output will be confusing
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // our contract is stateless, we declare it but we don't use it
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "PÃ¢nico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- EN/lesson_6_enums/Cargo.toml ---
[workspace]
members=[
    "lesson_6_1_simple", 
    "lesson_6_2_thermometer",
    "lesson_6_3_game_score"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_6_enums/Readme.md ---
# Lesson 6 - Enums

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

This lesson is sub-divided into four sessions. As each session will be a crate of its own, we will take the time to learn about workspaces and how to use them.

Here's a quick overview of sessions:
 - [Session 1 - Declaring and using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).
 - [Session 2 - Implementing a Thermometer using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_2_thermometer/).
 - [Session 3 - Pragmatic and Efficient error handling.](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_3_game_score/).
 
---

## Workspaces

A workspace is, quite simply, a directory shared by a set of packages. At compile time, all packages share the same target directory and Cargo.lock file, with each package compiling to a crate in that shared target directory. 

Here are some features of workspaces: 
 - Local dependencies: We create a package for our project, and then add packages our project depends on. 
 - Project management: we can compile and execute testing of all related packages and/or projects in one place. 
 - Smart Contract orchestration: A project usually has multiple smart contracts that handle different concerns (responsibilites). A workspace can include Smart Contracts in a test crate for testing cross-contract calls. There's such a test tool called [workspaces-rs](https://github.com/near/workspaces-rs) which can help you quite a lot when developing your own Smart Contracts.
 

---

## Cargo.toml
[top](#workspaces)

You need to add a special section called `[workspace]`.

```toml
[workspace]
members = [
    "lesson_6_1_simple",
]
```

`members` is a list of packages (projects) managed in this workspace.

:hand: **NOTE:** every package found in the workspace directory, will be included in the workspace. You can also leave packages out, using the `exclude` key in the `[workspace]` section. [Learn more](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section) about it. 

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```
In the example above, we included 3 paths, and excluded 2. There's support for wildcards, called [globs](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) (or Unix shell style patterns), to match multiple paths. 

---

## Using the CLI with workspaces
[top](#workspaces)

If we execute the command `cargo build` and `cargo test` in a package that is a member of a workspace, that command will apply to all other packages that are members of that workspace. 

If we want to limit the command's execution to a single package, we can add the flag `-p` / `--package` or `--workspace` to the command. 

Let's test `lesson_6_1_simple` by running the following command:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

`--nocapture` will print all output.

`--test-threads=1` will run all tests in one thread, making the output legible.

Now, let's compile our package to our wasm target and a (fully optimized) **release** version, by running: 

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```
WASM (WebAssembly) files will be located in './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

Finally, let's generate our documentation. Let's run: 
```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```
This will generate all documentation, and open it in the default browser. 

 - `--lib` specifies this is a library.
 - `--document-private-items` generates documentation for all items.
 - `--open` will open the default browser pointing to the generated documentation. 

All documentation will be located in './target/doc/lesson_6_1_simple/index.html'.

---

Lesson 6 - Intro :white_check_mark: ... **Done! Congratulations!**

Let's move on to the next section to learn more about [declaring and using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).

'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# Lesson 6 - Using Enums

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

In this lesson, we will learn all about enums and the ```match``` keyword.

---

## Contract API

```rust
// /src/lib.rs

/// We can use this function to match Strings and string slices &str
/// return 1, 2, 3, 4, 5, if the parameter given is one of those values
/// otherwise, panic!
pub fn string_match_example(&self, arg: String) -> u32;

/// Returns example_0.
pub fn get_example_0(&self) -> Example0;

/// Returns example_1.
pub fn get_example_1(&self) -> Example1;

/// Returns example_2.
pub fn get_example_2(&self) -> Example2User;

/// Calls Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Calls Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Calls Example1::get.
pub fn example_1_get(&self) -> String;

/// Calls Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Calls Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Calls Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Calls Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Calls Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Calls Example2User::get_actions.
/// 
/// When we return a Vec, the serialiyer will try to use serde::json.
/// Using #[result_serializer] allows to specify borsh as the serializer.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

---

## Compiling and testing

This crate belongs to the Lesson 6 workspace. You can find how to compile and test it in the [intro page for the lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).

:hand: **NOTE:**  All commands like `cargo test` and `cargo build` will affect all crates in the workspace, unless you provide a specific crate. 

---

## Topics

 - [What are enums](#what-are-enums)
 - [The `match` keyword](#the-match-keyword)
   - [String patterns](#string-patterns)
   - [`match` needs to match on all patterns](#match-needs-to-match-on-all-patterns)
   - [Using just one enum value](#using-just-one-enum-value)
 - [Enums that "box" values](#enums-that-box-values)
 - [Functions must specify return type](#functions-must-specify-return-type)
   - [Function is_no_value](#function-is_no_value)
   - [Function get_an_integer](#function-get_an_integer)
   - [Function has_an_odd_number](#function-has_an_odd_number)
 - [Usage scenario: user](#usage-scenario-user)
   - [Enums limit choices](#enums-limit-choices)
   - [Function get_name](#function-get_name)
   - [Function has_permission](#function-has_permission)
   - [Function get_actions](#function-get_actions)
   - [Choosing a serializer](#choosing-a-serializer)
 
---

## What are enums

[top](#topics)

While `Structs` are a type *composed* of other types, `Enums` are a type that can have only *one value at a time*. The values an enum can take are specified in its definition.

Here's an example of a simple `enum`:
```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```
 - `pub` allows an enum to be used in external modules.
 - `Example0` is the name of the `enum`.
 - `First`, `Second`, `Third`, `Fourth` and `Fifth` are the actual values this `enum` can have. 

So now that we have declared an `enum`, how do we create an instance? Here's an example for each possible value: 

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```
In order to check for a value, we could use `if | else` but Rust provide a much powerful tool. Let's learn about the `match` keywork next. 

---

## The `match` keyword

[top](#topics)
The `match` keyword allows to compare a value with all possible values for an enum.

```rust
// /src/model.rs
impl Example0{

    /// Check its assigned value and returns a number between 1 and 5.
    /// 
    /// Note the &self reference, meaning this function access its value 
    /// but it doesnt modify it (mutate)
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // Here we match all possible enum values and 
        // return something, based on the enum value
        // remember: since this is the last statement of the function,
        // a return is implicit, you don't have to use the return keyword
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }
```
The example above simply matches an enum value to a number, and returns the matching number (an integer in this case)

 - `Example0::First` returns 1;
 - `Example0::Second` returns 2;
 - `Example0::Third` returns 3;
 - `Example0::Fourth` returns 4;
 - `Example0::Fifth` returns 5;

`match` is similar a `switch` in other languages like C, Python, Java and Javascript, however, while `switch` compares for booleans, Rust's `match` compares against patterns.

---

### String patterns

[top](#topics)

We can use `match` on `String` and `&str`: 

```rust
// /src/lib.rs

impl Contract{
    /// We can use this function to match Strings and string slices &str
    /// return 1, 2, 3, 4, 5, if the parameter given is one of those values
    /// otherwise, panic!
    pub fn string_match_example(&self, arg: String) -> u32 {

        // treat &String as &str
        match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }
```
In the example above, `match` goes over each pattern in order.
 - &arg is "1"? No.
 - &arg is "2"? No.
 - &arg is "3"? No.
 - &arg is "4"? No.
 - &arg is "5"? No.
 - `value` is a variable whose value will be any other value not matching the above cases.
 You can think of it as the last case in the match, which actually will match anything.
 Any string that isn't "1", "2", "3", "4" or "5", will be `value`, and so the function will panic.

---

### `match` needs to match on all patterns

[top](#topics)

On our first example, our enaum had 5 possible values. If you comment out one, the compiler will complain! (throw an error)

```rust
match self {
    Example0::First => {1},
    Example0::Second => {2},
    Example0::Third => {3},
    Example0::Fourth => {4},
    // if we comment the last possible value for the Example0 enum, 
    // the compiler will error out!
    // match needs to account for ALL possible values for the enum
    // Example0::Fifth => {5},
}
```

Our second examples compares a String. As a String can have basically any value, we need to have a 'last resort' case which matches 'any other value given', like so: 

```rust
value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
```

You can have any variable name, it doesn't have to be `value`. It is also the case that sometimes you don't care for the actual value of the varibale but you **do** have to account for this 'whatever else' case when using `match`. In Rust, you'll see the underscore `_` being used as a variable name in those cases. Also, any variable that starts with an underscore `_` tells the compiler that we might not even use that variable later on (so the compiler will ignore its non-usage and not give you a *not used warning*, which is how it behaves by default). 

Let's say we write our `match` like this:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        value => {
            // We are not using our value in panic! below
            // so the compiler will warn you that value is not being used
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```
To avoid the warning, we just need to modify things a bit... by adding an underscore: 

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _value => {
            // see? we added a _ , making it _value and not just value
            // we are STILL not using it in our panic! below
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Do bear in mind that convention is imnportant, so we use "_" for patterns where we truly don't care about the 'whatever else' value: 

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _ => {
            // see? we used the _ for anything
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

---

### Using just one enum value

[top](#topics)

Sometimes we have a function that only needs to do something based on just one case or value of our `enum`. We can also use `match`! 

In the following example, we only match `true` when our enum is `Example0::Third`. 

```rust
// /src/model.rs
/// true but checking only for Example0::Third
pub fn is_third(&self) -> bool {
    log("Calling Example0::is_third");

    match self {
        Example0::Third => true,
        _ => false,
    }
}
```

---

## Enums that "box" values

[top](#topics)

This is a powerful fact you need to keep in mind... in Rust, `enum` can also have different underlying types; all possible enum values don't have to be same type!

```rust
// /src/model.rs
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}
```
:hand: **NOTE:** Read the above carefully. We have primitive types (i32, f32, String) as `enum` choices, as well as tuples, **and** we can also have a C-like `struct`. All of these are part of one `enum`, `Example1`.

---

## Functions must specify return type

[top](#topics)

Functions that use enums can sometimes be difficult to implement, due to static typing. 

- Argument types must be specified.
- Return type must be specified.
 
That also includes generic functions. The compiler **must** know the argument types as well as the return type. Generic function are but a way to create function that also follow those rules.

For our enum, a developer might run into trouble with the compiler, since we have different underlying types for our enum choices (an integer, a string, a struct).
However, we can certainly implement functions! We just need to focus on thing: what type should we choose for our return value? 

In our case, let's choose a String:

```rust
// /src/model.rs

// Our method returns a String
pub fn get(&self) -> String {
    log("Calling Example1::get");

    match self{
        Example1::NoValue => String::from(""),
        Example1::AnInteger(value) => format!("{}", value),
        Example1::AFloat(value) => format!("{}", value),
        Example1::AString(value) => format!("{}", value),
        Example1::ATuple(value0, value1) => format!("({}, {})", value0, value1),
        Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
    }
}
```

`format!` is a macro that creates a String. We went over macros in [Lesson #5](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage/), so feel free to go back if you need a recap. Anyway, since we only want to print a value on screen, we can simply return a String.

In our lesson about Traits, we wil go over how to use borsh and serde. We use these to convert a struct into bytes, as well as convert from bytes or a string, into a struct (if they are compatible). In that lesson, we wil also cover how to use Generics, which allows to write functions that work for multiple types.

---

### Function is_no_value
[top](#topics)
Sometimes, we need to only check for one value. This function returns true if the enum value is `NoValue`.
```rust
// /src/model.rs
/// true if enum is Example1::NoValue.
pub fn is_no_value(&self) -> bool{
    log("Calling Example1::is_no_value");

    match self{
        Example1::NoValue => true,
        _ => false,
    }
}
```
---

### Function get_an_integer
[top](#topics)
Returns an integer if the enum's value is `Example1::AnInteger`.

```rust
// /src/model.rs
pub fn get_an_integer(&self) -> Option<i32>{
    log("Calling Example1::get_an_integer");

    match self{
        Example1::AnInteger(valor) => Some(valor.clone()),
        _ => None
    }
}
```
:hand: **NOTE:** if you looked at the code above you'll see the return value is actually something called an `Option`. We'll learn more about `Option` later on, but you can think of right now as an enum that *can* have a value, *or not*. If there is a value, you can retrieve it using `Some(value)` (where `value` is just a variable name), and if there is no value, then Option would be set to `None` (`Option::None`).
There is no **NULL** in Rust. 

By the way, take a look at this code:

```rust
match self {
```

Shouldn't this code be taking ownership of itself, and if not, why is that?

Well, that's because of how this argument is being passed:

```rust
pub fn get_an_integer(&self) -> Option<i32>{
```
As `&self` is being used, the compiler knows this value is just a reference (or borrow).

So, in summary:

```rust
match self{
    Example1::AnInteger(valor) => Some(valor.clone()),
    _ => None
}
```
The functions returns `Option<i32>` and therefore, our `match` must provide a return of either `Some(value)` or `None`. 

---

### Function has_an_odd_number

[top](#topics)
Returns true only if the argument is an odd integer.
Take a closer look at the code, since this is a more detailed usage scenario for `match`.

```rust
// /src/model.rs
/// Returns true only if the argument is an odd integer.
pub fn has_an_odd_number(&self) -> bool {
    log("Calling Example1::has_an_odd_number");

    match self {
        Example1::NoValue => false,
        Example1::AnInteger(valor) => {
            if valor%2 == 1{
                return true;
            }
                
            return false;
        },
        Example1::AFloat(_valor) => false,
        Example1::AString(_valor) => false,
        Example1::ATuple(valor0, valor1) => {
            return (valor0%2 == 1) || (valor1%2 == 1);
        },
        Example1::ACLikeStruct { first, second: _ } => {
            // we don't care about 'second' since it is a string
            first%2 == 1
        },
    }
}
```
So, the only alternatives that have integers are `Example1::AnInteger`, `Example1::ATuple` and `Example1::ACLikeStruct`. All other return false.

:warning: Variables starting with an underscore `_`, such as `_value` and `_`, hold **values** we don't really care about. The convention is to just an underscore `_`, but any variable names starting with an underscore will be ignored by the compiler when checking and raising any 'unused variable' warnings.

---

## Usage scenario: User

[top](#topics)
Let's see how we could use an enum in an application.

```rust
// /src/model.rs
pub enum Example2User {
    Admin { name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}
```
We have three types of people who can access our system:
 - Employees: they can access the system and make limited modifications to data but can't alter business or system rules.
 - Admins: they have permissions to alter any business or system rules (basically do anything).
 - Clients: they can't change any system data, but are allowed to change their own data.
 
Employees, Admins and Clients are different types, and have different functions and data. But in the context of a User, they can be thought of in a similar manner.

You can group types using Enums but also Traits; however, consider that:
 - You use enums for grouping different types as a single concept or entity that will be used by a function.
 - You use traits for applying a single set of behaviors to different types. 

---

### Enums limit choices

[top](#topics)
Restricting choices can be good or bad depending on the case, so let's consider a few examples in order to get a grasp of the concepts.

Think about Chess. There are different pieces on the board, and so we made an enum for all the piece names:

```rust
// https://github.com/On0n0k1/NCD.L1--Chess/blob/main/src/pieces/piece.rs
pub enum Piece {
    BISHOP( Bishop ),
    EMPTY(  Empty  ),
    KING(   King   ),
    KNIGHT( Knight ),
    PAWN(   Pawn   ),
    QUEEN(  Queen  ),
    ROOK(   Rook   ),
}
```
Each piece has its own behavior, but the board itself doesn't care about it. However, the board does need to know each piece's possible movement in order to know if there's a check-mate. 

In this case, the restriction imposed by using enums is useful, since there are only so many piece types, plus one for empty space, and this will never change (so there won't be a need to add to the enum).

Enums are also useful for error handling. Let's think about an application used in a library. A function that retrieves information about a book could also return the following errors:

```rust
pub enum MessageError{
    BookNotFound(String),
    InvalidArg(String),
    MissingArg(String),
    NoPermission,
}
```
The errors are: 
 - `BookNotFound`: book not found, with the string being the name of the book that was not found.
 - `InvalidArg`: an argument was not recognized, with the string being the argument. 
 - `MissingArg`: a mandatory argument is needed but wasn't provided. The string is the required argument.
 - `NoPermission`: You don't have permission to access this book. Maybe the user is underage, and this book has adult content.

It becomes apparent that an advantage of restrictions imposed by enums is that a developer can well know all of the errors that can or should occur when calling a function.

---

### Function get_name

[top](#topics)
The function get_name of `Example2User` simply returns the 'name' of the user (which is a String). Remember, the underscores are values we choose to ignore. 

```rust
// /src/model.rs
/// returns the name of the user
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
        Example2User::Client { name, id: _, orders: _ } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```
Also, when there are multiple fields that have values you don't care about, you can simply use '`..`', like so: 
```rust
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, .. } => { name.clone() },
        Example2User::Client { name, .. } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```
---
### Function has_permission

[top](#topics)
Returns true if a user has permissions for an action in the application.
 - Admins always have all permissions granted.
 - Clients never have them.
 - Employees are granted permissions. Granted permissions are stored in a list.

:warning: Using String is never a good idea for permissions. This would be an ideal use case for enums, but we are doing it this way to keep complexity low.

```rust
// /src/model.rs
pub fn has_permission(&self, permission: String) -> bool{
    log("Calling Example2User::has_permission");

    match self{
        Example2User::Client { name: _, id: _, orders: _ } => { false },
        Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
        Example2User::Employee(employee) => {

            // Vec implements the Iterator trait, which means we have 
            // the .iter() function available to go over all 
            // value in the Vec, without needing to copy them
            for employee_permission in employee.permissions.iter(){
                if permission == *employee_permission {
                    return true;
                }
            }

            false
        }
    }
}
```
Employees have a `Vec` (vector) of strings where permissions are stored. We'll get to `Vec` when learn more about collections, but think of Vec (vector) as a modifiable list.

We already learned about `Clone` and `Copy`, so it is time to introduce [iterators](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and iter(). This trait allows us to go over each value in a vector using `for`.

The `iter()` function generates a reference iterator. That means, that each `employee_permission` is a reference to an element contained in `Vec`. We **can't alter or modify** the values, but we also don't waste computing resources generating any copies of these values. 

Take a look at this code, and keep an eye out for the * operator:
```rust
if permission == *employee_permission {
    return true;
}
```
`employee_permission` is a &String (remember, iter() provides references) but we need to access the **actual** value of the string, not its reference. So, we use the * operator to *de-reference* the variable to get the actual value. 

Going back to the function, the argument `permission` will be compared to the permissions found in vec and if there's a match, the function returns true immediately. 

---

### Function get_actions

[top](#topic)
The function `get_actions` return a list of actions recently performed by the user. 

We'll use this function to introduce the `Result` enum, which we'll go in-depth in the next lesson, but for now think of `Result` as an action outcome that may have also caused an error. 

In our example, let's make this function return an error if the user is of type Client.

```rust
// /src/model.rs
pub fn get_actions(&self) -> Result<Vec<String>, String> {
    log("Calling Example2User::get_actions");
    
    // If Client, return an error.
    // If admin or employee, we can return a reference to the vec actions
    let actions = match self {
        Example2User::Client { name: _, id: _, orders: _ } => { 
                return Err(format!("User is Client")); 
        },
        Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
        Example2User::Employee( employee ) => { &employee.actions },
    };

    // create an empty, but mutable vector
    let mut result: Vec<String> = Vec::new();
    // let's create a copy of Vec with the actions from our last match
    for action in actions {
        result.push(action.clone());
    }

    Ok(result)
}
```
:hand:**NOTE:** The function returns `Result<Vec<String>, String>`. The first type `Vec<String>` is what we choose to be the return of a sucessful outcome. The second type, `String`, is what we choose to return if there was an error (note we say error, not panic, they are very different). 

There's code to return an error, as a String (the second type): 
```rust
return Err(format!("User is Client"));
```

And there's code to return a `Vec<String>` if everything went OK:

```rust
Ok(result)
```
:warning: **REMEMBER:** `Result::Ok(value)` or simply `Ok(value)` is for a succesful outcome, and `Result::Err(err)` or just `Err(err)` is used when an error occurred. 
Also note that the variable names for these don't have to be `value` or `err`, that's just a convention when using `Result`.

---

:hand:**NOTE:** in our example we can't just return the found vec, as it is owned by the enum. So, we have to create a copy: 

```rust
let mut result: Vec<String> = Vec::new();

for action in actions{
    result.push(action.clone());
}
```

 - Create an empty `Vec<String>`. 
 - We iterate over the elements in the `actions` vec.
 - In each iteration, we create a copy of the element using `action.clone()`, and we append this to our new vec using `result.push();`.

---

### Choosing a serializer

[top](#topics)

Our `example_2_get_actions` function has something different about it, can you see it? 
```rust
// /src/lib.rs
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>{
```
I hope you spotted `#[result_serializer(borsh)]`. By using it, we're being explicit that we want to use `borsh` as our serializer for our function return. 

There are two options available for the near_sdk when it comes to serialization/deserialization: `serde` and `borsh`. If you want to use `serde`, then you need to implement the traits `Serialize` and `Deserialize` in your Smart Contract. However, if choosing `borsh`, you don't have to, and `borsh` has higher performance. 

Why not take a small detour from the lessons, and learn more about them? The best way is to read about [serialization protocols](https://www.near-sdk.io/contract-interface/serialization-interface) in the NEAR docs. 

---

Lesson 6 - Using Enums :white_check_mark: ... **Done! Congratulations!**

Let's put everything we've learned into developing an app on our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_2_thermometer/).
'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// logs the function being called
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// We can use this function to match Strings and string slices &str
    /// return 1, 2, 3, 4, 5, if the parameter given is one of those values
    /// otherwise, panic!
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Handle &String as &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Returns example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Returns example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Returns example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Call Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Call Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Call Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Call Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Call Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Calls Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Calls Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Calls Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Calls Example2User::get_actions.
    /// 
    /// 
    /// When returing vec, the default serializer is serde (serde::json).
    /// So let's be explicit about using borsh.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Test an error using argument with 0
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{ Serialize, Deserialize },
};    

// As duas funÃ§Ãµes a seguir sÃ£o declaradas para
// termos duas implementaÃ§Ãµes diferentes de uma mesma funÃ§Ã£o "log".
// As mensagens chamadas com essa funÃ§Ã£o log aparecerÃ£o 
// em testes e na mÃ¡quina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultÃ¢neos, um enum sÃ³ pode possuir um valor.
/// Os possiveis valores de um enum sÃ£o descritos em sua declaraÃ§Ã£o.
/// 
/// Os possiveis valores de Exemplo0 sÃ£o:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Similar to structs, let's implement some function on our enum Example0
impl Example0{

    /// Check its own value and returns a number from 1..5.
    /// 
    /// We use a reference &self, meaning we only access the value, not modify it
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // and here we match enum choices/options to return values
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true if own enum value is set to Example0::Third
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compares value in the order specified, 
        // and if assign a variable to a match, that variable will have the return value
        // of the match block.
        //
        // A variable starting with an underscore, is a variable whose value we don't care about
        // and that we will probably not be using later on
        //
        // So, a _ for our last case, as seen below, will match to anything else
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // uncomment the above
            //     // and you'll get an error beause _ is above it 
            //     // and that means this SECOND enum option will never be reached
            //     false
            // },
        }
    }
}

/// An enum allows different typs to be grouped into a single concept or entity
/// 
/// This example shows that using enums for complex types (composability) is not really a good idea.
/// 
/// Function in enums should return simple results.
/// Having to 'extract' the underlying values in enums so they can be used only adds complexity.
/// 
/// Use enums to group different types that seem to share similar concepts.
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Remember that functions must return one specific result type
    //
    // A developer might be tempted to create a get function to return the stored value but that 
    // can be difficult to implement.
    // 
    // The simplest way to go about it is to have your function convert enum options as needed into a single (common) return type
    // Here are some examples:
    //  - Return a value as a String
    //  - Use borsh or serde to serialize the value to bytes, to later deserialize after receiving the result
    //  - Implement generic. We'll go over this in a future lesson.
    //  - Return a "pointer"? There's a VERY low probability that is really necessary, and the complexity increases a lot.
    // 

    // Our function will return just a String type 
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    /// true if enum is Example1::NoValue.
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Return an integer, if the enum value is that choice
    ///
    /// Option will be exlained in a future lesson. 
    ///
    /// Option is an enum of the std library.
    /// It means that we can have a value or not
    /// Option could be Option::Some(value) or Option::None.
    /// There's no NULL in Rust!
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // value is a reference, so we clone the value to return an actual value and not a reference.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Returns true if the enum represents an odd number
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // We don't care about the second value, so we use an underscore
                first%2 == 1
            },
        }
    }
}

/// A simple struct with Default
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// A user for an application.
/// 
/// A user can be any of these three:
///  - Client
///  - Employee
///  - Administrator
/// 
/// We cantrol permission of each of them using enums
/// 
/// All have name and id, and each has in addition:
///  - Admin: password (encrypted) and  a list of action they can do in the app. 
///  - Employee: password (encrypted), a list of actions they can do and a list of permissions for the app.
///  - Client: only list of orders.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{
    /// Returns the user name
    /// 
    /// The caller doesn't need to know the type of the user.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Check if an user has a permission.
    /// 
    /// Having Strings to keep permissions is not a good idea, due to possible errors. A better choice would be enums
    /// 
    ///  - Clientes don't have permissions. Always return false.
    ///  - Administrators have all permissions (can do anything). Always returns true.
    ///  - Employees might have the permission. 
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implement the Iterator trait, 
                // so we have the iter() function available.
                // This functions allows to iterate over references to strings,
                // but no copies are made while iterating 
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Returns a list of actions for Admin or Employee. 
    /// 
    /// Result is similar to Option, but is used to provide more detail into the outcome while also accounting for errors
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // If user is Client, return error Err()
        // If user is Admin or Employee, return reference to Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Create a copy of vec, using references
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Create some instance to test
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Return a tuple with different types available
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Check for valid return strings
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    `   
    /// Check that only true is returned for no_value
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Create 3 instances of Example2User for our tests
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // destructure names into variables
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // check all names are OK 
        // we are comparing a String against a &str
        // because we implemented the trait partial_eq
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // Check if users have the log permission
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    #[test]
    fn example2_get_actions(){

        // helper function to compare vectors
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // vectors must have the same number of elements
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // get actions for each user
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // check admin actions
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // check employee actions
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // check client, and make sure it returns an error.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/Cargo.toml ---
[package]
name = "lesson_6_2_thermometer"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/Readme.md ---
# Lesson 6 - Thermometer

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

Time to build a Rust application with all of the concepts we have covered! We will also learn about: 

 - Project Documentation.
 - User Access Control.
 - Cross-Contract Calls.
 - Input Control.
 - Output Control.
 - Using Traits to convert types.

---

## Topics

 - [Overview](#overview)
 - [Pre-requisites](#pre-requisites)
   - [Rust](#rust)
   - [Visual Studio Code](#visual-studio-code)
   - [near-cli](#near-cli)
 - [Bash commands: compiling](#bash-commands-compiling)
   - [Documentation](#documentation)
   - [Tests](#tests)
   - [Creating a sub-account for the Smart Contract](#creating-a-sub-account-for-the-smart-contract)
   - [Creating sub-accounts for Sensors](#creating-sub-accounts-for-sensors)
   - [Deleting sub-accounts](#deleting-sub-accounts)
 - [Smart Contract](#smart-contract)
   - [Initialization](#initialization)
   - [Deployment](#deployment)
   - [allow_user](#allow_user)
   - [remove_user](#remove_user)
   - [set_format](#set_format)
   - [new_entry](#new_entry)
     - [Examples](#examples-new_entry)
   - [list_update_entries](#list_update_entries)
     - [Examples](#examples-list_update_entries)
   - [clear_entries](#clear_entries)
     - [Examples](#examples-clear_entries)
   - [view_get_format](#view_get_format)
   - [view_get](#view_get)
     - [Examples](#examples-view_get)
 - [Project Development](#project-development)
   - [Project Documentation](#project-documentation)
     - [File comments](#file-comments)
     - [Comments in code](#comments-in-code)
   - [Modules](#modules)
   - [User access control](#user-access-control)
   - [Cross-Contract calls](#cross-contract-calls)
   - [Handling Output](#handling-output)
   - [Handling Input](#handling-input)
   - [Implementing Traits](#implementing-traits)

---

## Overview

[top](#topics)
In our previous lesson, we learned about `enum` and how to use the `match` keyword. We can also use enums to handle I/O (input/output) of data.

Let's image we are an embedded developer working on a device that monitors temperature, and so we need input from several thermometers at the same time. We realized the following constraints: 

 - **Connecting** all devices to a single computer is impractical.  
 - **Keeping** a server up 24x7 receiving sensor data is also impractical.
 - **Have** a server up in the cloud is also impractical, because the developer doesn't want to pay a centralized entity (and give even **more** money to a billionarie).

So, the developer decides to create a smart contract to store the data. Some clear advantages are:

 - **Easy to implement**. The user only requires an account to store a smart contract, and so an account-per-sensor seems a good solution.
 - **Easy to automate**. The only thing that changes is the smart contract's name (per sensor). With a few scripts, a developer can have a fully working system in minutes.
 - **Easy to extend**. In this example we only focus on temperature readings but the smart contract can be easily changed to receive and save other data.

Now, does the contract only store data? There's no computation on the data received? Actually, computing could be made locally in the device, and there's no need to waste [gas](https://docs.near.org/concepts/basics/transactions/gas) on computing that can be done off-chain. Plus, there's a lot of libraries out there for data-science, no need to re-invent the wheel. 

:warning: **Always "think in gas" (gas usage) when it comes to on-chain data or computation**.

In summary, sensors send data to the smart contract, who stores on-chain the sensor name, temperature and date/time of the measurement. Then, any consumer (e.g. our own computer) can later on access on-demand this data from all contracts and do further processing and analysis. 

---

## Pre-requisites

[top](#topics)
 - Install Rust.
 - Download and Install Visual Studio Code.
 - Install near-cli.

### Rust
The easiest way to install Rust is to follow the steps in https://www.rust-lang.org/tools/install, where you'll find instructions for all major operating systems (even Windows Subsytem for Linux). There's also [other installation methods](https://forge.rust-lang.org/infra/other-installation-methods.html) available.

Once you have Rust installed, you'll need to add a target so you can compile to webassembly (WASM). Run the following command in your shell:

```bash
rustup target add wasm32-unknown-unknown
```
If you ever need to uninstall Rust, that's pretty easy too:
```bash
rustup self uninstall
```

### Visual Studio Code
 - Download and install from https://code.visualstudio.com
 - Once you have installed Visual Studio, add this extension to have additional tooling that will help you with Rust programming  https://marketplace.visualstudio.com/items?itemName=Zerotaskx.rust-extension-pack

:hand: **NOTE:** an old version of the extension mentioned above added a dependency (extension) called `rust` which has been deprecated in favor of `rust-analyzer`. You should always use `rust-analyzer` as it is kept up-to-date (and be sure **not** to have both `rust` and `rust-analyzer` installed and running!)

### near-cli
An npm-installable tool for interacting with the NEAR backend (RPC server). For near-cli to work, you need [node.js](https://nodejs.org/) and npm installed (npm is installed with node.js). If you need to learn more about node.js, be sure to visit their [guides](https://nodejs.org/en/docs/guides/), but in short, node.js is a javascript runtime environment (which lets you develop applications using javascript and run them outside of the browser as regular app). 

Once you have node (and npm) installed, you can install near-cli using npm: 

```bash
npm install -g near-cli
```
The `-g` option will install near-cli globally (for all users).

There's quite a lot of options that you **need** to learn in order to use near-cli, so be sure to [read the docs](https://docs.near.org/docs/tools/near-cli).

---

## Bash commands: compiling
[top](#topics)

You can compile the project using: 

```bash
cargo build --target wasm32-unknown-unknown --release -p lesson_6_2_thermometer
```
 - `--target wasm32-unknown-unknown`: Compile to webassembly.
 - `--release`: Output production-ready code; compile using most compiler optimizations.
 - `-p`: Remember this crate is part of the workspace defined as `lesson_6_enums`. Using the flag `-p` tells the compiler that only `lesson_6_2_thermometer` should be compiled.

---

### Documentation
[top](#topics)
Did you know you can generate documentation using cargo? This command will generate documentation (as a webiste) for all modules on this crate:

```bash
cargo doc --open -p lesson_6_2_thermometer
```
 - `-p`: Remember, you need to specify that only `lesson_6_2_thermometer` is the crate we want to generate documentation for.

---

### Tests

[top](#topics)
Execute tests (including those found in documentation) by running:

```bash
cargo test -p lesson_6_2_thermometer
```
Rust has a tool called `rustdoc` that extracts code samples from documentation comments and executes them. Learn more about [rustdoc](https://doc.rust-lang.org/rustdoc/) for more information on writing doc tests.

---

### Creating a sub-account for the Smart Contract

[top](#topics)
This is the account where the smart contract will be deployed. 

Let's use near-cli to create sub-accounts. Using the `near` command, you need to specify two options:
- your **existing** NEAR testnet account. So, replace `your-main-account.testnet` with **your testnet account name**.
- the name you want for the **new** sub-account where the smart contract will be deployed. So, replace `smart-contract-account-name` with the name you want.

```bash
near create-account smart-contract-account-name.your-main-account.testnet --masterAccount your-main-account.testnet --initialBalance 90
```
`--masterAccount`: master account, able to create sub-accounts. 
`--initialBalance`: amount of NEAR to be transferred to the sub-account from the master account. If you don't specify an amount, 100 NEAR will be sent from the master account. 

If you need a refresher about accounts on NEAR, be sure to [read the docs](https://docs.near.org/concepts/basics/account) once more.

---

### Creating sub-accounts for Sensors

[top](#topics)
We won't deploy any contracts to these sub-accounts but they will be used to sync with the master account.

You need to replace:

 - `sensor-sub-account`: account name for the sensor.
 - `smart-contract-account-name`: account name where the smart contract will be deployed.
 - `your-main-account`: master account name.

```bash
near create-account sensor-sub-account.smart-contract-account-name.your-main-account.testnet --masterAccount smart-contract-account-name.your-main-account.testnet --initialBalance 10
```
`--masterAccount`: master account, able to create sub-accounts. 
`--initialBalance`: amount of NEAR to be transferred to the sub-account from the master account. If you don't specify an amount, 100 NEAR will be sent from the master account. 

---

### Deleting sub-accounts

[top](#topics)
You need to delete sensor sub-accounts prior to deleting the smart contract account. You specify the account to delete, and also the account that will receive any NEAR found on the account to be deleted.

```bash
near delete sub-account-to-delete.testnet receiver-beneficiary.testnet
```

 - `sub-account-to-delete.testnet`: account name to delete
 - `receiver-beneficiary.testnet`: account name to receive any funds from the deleted account. If you specify an invalid name, any funds from the deleted account will be distributed among validators.

---

## Smart Contract
[top](#topics)

Before reviewing the code, keep in mind that just after being deployed, the only user than can "call" functions in the smart contract is its **owner** (the account where you deployed it). So, you need to specify that account for the first calls. 

Other users (sensors) can, and will, later be included on a list of allowed users, so that each user (sensor) will have their own data storage. 

---

### Initialization

[top](#topics)

The contract initializes using Kelvin (as temperature unit) and only a single user (the owner).

---

### Deployment
[top](#topics)

Deploy your contract to NEAR's testnet by running: 
```bash
near deploy --accountId smart-contract-account-name.your-main-account.testnet --wasmFile .\target\wasm32-unknown-unknown\release\lesson_6_2_thermometer.wasm
```
:hand: **NOTE:** depending on how you built your project, the path to the _.wasm_ file might be different on your machine. 

:warning: Remember that the account where you'll deploy your contract to has to have enough NEAR for storage. Read about [storage staking](https://docs.near.org/concepts/storage/storage-staking).

---

### add_user

[top](#topics)

```bash
near call my-contract add_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract

```
Adds the specified user to the list of allowed users. Only the owner can call this function, and it cannot be used cross-contract.

Parameters:
 - account_id: String. Account name to add to the allowed user list.

Panics:
 - If cross-contract call.
 - If caller is not the owner.
 - If account name is invalid.
 - If account name already exists.

---

### remove_user

[top](#topics)

```bash
near call my-contract remove_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```
Remove the specified user from the list of allowed users, all data stored for this user will be lost. You can't remove the owner. Only the owner can call this function, and it cannot be used cross-contract.

Parameters:
 - account_id: String. Account name to remove from the allowed user list.

Panics: 
 - If cross-contract call.
 - If the caller is not the owner.
 - If account name is invalid.
 - If account name doesn't exist.
 - If acount name to remove is the owner.

---

### set_default_temperature_unit

[top](#topics)

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Fahrenheit}' --accountId my-contract
```

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Kelvin}' --accountId my-contract
```

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Celsius}' --accountId my-contract
```
Changes the default temperature unit (Fahrenheit, Kelvin, Celius), but it will not update/convert any values previously stored.

All temperature readings are converted into an internal system unit (the default). That allows sensors with different temperature units to simply send their measurements. Only the owner can call this function, and it cannot be used cross-contract.

 - The **call** function `list_update_entries` converts all stored values to the new default temperature unit.
 - The **view** function `view_get` returns all stored values.

Panics:
 - If account name is invalid.
 - If cross-contract call.
 - If the caller is not the owner.

---

### new_entry

[top](#topics)

This **call** function stored a new temperature measurement from any allowed user (can be cross-contract call too). 

Parameters:
 - **time**: optional. A tuple `(u8, u8, f32)` representing hour, minute and second. If ommited, the default value will be the current time (UTC) when the function was called.
 - **date**: optional. A tuple `(i32, String, u8)` representing year, month and day. If ommited, the default value will be the current date when the function was called.
 - **temp_value**: A `f32`, which is the measured temperature value, which cannot be less than absolute zero. 
 - **temp_format**: Optional. A `String`, representing the temperature unit. If ommited, the default system unit will be used. If the unit is different to the default system unit, a conversion will be made to the default system unit prior to storing.

#### Examples new_entry

[top](#topics)

Store a new measurement of 100 using the default system temperature unit, and current date and time:
```bash
near call my-contract new_entry '{"temp_value": 100 }' --accountID my-sensor-id
```

Store a new measurement of 100 degrees Celsius, using the current date and time:
```bash
near call my-contract new_entry '{"temp_value": 100, "temp_format": "Celsius"}' --accountID my-sensor-id
```

Store a new measurement of 50.5 degrees Fahrenheit, using the provided date and the current time:
```bash
near call my-contract new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}' --accountID my-sensor-id
```

Store a new measurement of 11.5 degrees Fahrenheit, using the provided date and the provided time:

```bash
near call my-contract new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}' --accountID my-sensor-id
```

Store a new measurement of -45.4 degrees Celsius, using the current date and the provided time:

```bash
near call my-contract new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 44.13 Kelvin. HorÃ¡rio do recebimento da mensagem. Data atual do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}' --accountID my-sensor-id
```

### list_update_entries

[top](#topics)

This **call** fuction returns all temperature readings (measurements) for a specified account, converting to the default temperature unit, if needed.

All allowed users can access their own data, but only the owner can access other user's data. This restriction is in place to keep in check gas usage. Any user or account can still take advantage of **view** functions to gather all data. 

Parameters:
 - account_id: Optional. A `String` representing the account to retrieve data for. If not specified, it will return data for the caller account.

**Returns**: A `Vec` with all temperature readings (measurements) associated with a user.

#### Examples list_update_entries

[top](#topics)

This will return all temperature readings associated with the user (account) "my-sensor-id":

```bash
near call my-contract list_update_entries '{}' --accountID my-sensor-id
```

This will return all temperature readings associated with another user (specified with account_id). Only the owner can call retrieve data for another user:

```bash
near call my-contract list_update_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Panic list_update_entries

[top](#topics)

 - If the user is not on the allowed user list.
 - If the user is not owner and is trying to update other user's data.
 - If the user is not found.

---

### clear_entries

[top](#topics)

This **call** function clears all user data (temperature readings) for a user. Can be cross-contract call and only the owner can call this function.

The reason this function can be cross-contract is to make it easier for automation. Other contracts can't add or remove users, but they can add temperature readings and collect user data.

Users don't have permissions to use this function in order to increase security. If one sensor was hacked, the hacker would only have the most limited functionality. Sensors only exist to provide temperature readings. 

#### Parameters clear_entries

[top](#topics)

 - **account_id**: Optional. A `String`, representing the account to remove data from. If ommited, **all data for the owner** will be removed.

#### Examples clear_entries

[top](#topics)

This will remove all temperature readings (measurements) associated with the user "my-sensor-id".

```rust
near call my-contract clear_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Panic clear_entries

[top](#topics)

 - If user is not the owner.
 - If account is not found.

---

### view_get_format

[top](#topics)

A **view** function. Returns a `String` representing the default temperature unit.

```bash
near view my-contract view_get_format '{}'
```

--- 

### view_get

[top](#topics)

A **view** function. Returns temperature readings (measurements) associated with an account.

:hand: **NOTE:** this is a **view** function and so there's not gas involved. However, it can still return two different result types. Take a look at `ViewGet` in `./src/utils.rs`.

```rust
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(TemperatureReading),
    Multiple(Vec<TemperatureReading>),
}
```
Let's take a closer look at the declaration:
 - serde is used for JSON serialization and deserialization.
 - `#[serde(untagged)]` allows not using an explicit JSON tag for a type, and so we can have any type of variant in the enum. In our enum `ViewGet`, we can then have two variants:`Single(TemperatureReading)` and `Multiple(Vec<TemperatureReading>)`. 
 
 Learn about serde's [enum representations](https://serde.rs/enum-representations.html), or specifically more about [untagged](https://serde.rs/enum-representations.html#untagged).

This is a way to allow the developer to take advantage of enums to simply focus on getting a result.

:hand: **NOTE:**: this example was just made this way to show the possibility of returning different variants as a result. It could lead to increasing system complexity!

#### Parameters view_get

[top](#topics)

 - index: u64. Optional. The index for the temperature reading to return. If omitted, return all temperature readings. 
 - account_id: A `String` representing the account that has associated temperature readings to return.

#### Examples view_get

[top](#topics)

This will return the first (with an index of 0) temperature reading, if found, associated with the account "sensor-id":

```bash
near view my-contract view_get '{"index": 0, "account_id": "sensor-id.testnet"}'
```
This will return all temperature readings associated with the account "sensor-id":

```bash
near view my-contract view_get '{"account_id": "sensor-id.testnet"}'
```

---

## Project Development

[top](#topics)

In this section, let's explain how we developed this project by going over a checklist:

 - Project documentation.
 - Module organization.
 - Access control for users.
 - Cross-contract calls.
 - Handling input;
 - Handling output;
 - Implemmenting Traits.

---

### Project documentation

[top](#topics)
In order to create documentation, we can take advantage of `cargo` by running: 

```bash
cargo doc --open --lesson_6_2_thermometer
```
This will create a website with all documentation for our project.

However, there are some rules we need to follow. Let's go over them next:

#### File comments
Use `//!` at the beginning of files for module-level documentation.

Here's an example from our `Day` module, found in `./src/schedule/date/day.rs`.

```rust
//! Module with all functions related to a day
//! 
//! We use an u8 for the day, but we also need to 
//! check the day is valid. So, we'll need to make
//! day a struct Day(u8).
//! 
//! When serialized to JSON, the value would just be
//! an u8, so there won't be any additional complexity
//! for the user.
```
These comments should be a summary of module functionality and features.

#### Comments in code
Comments in code `//` are not included in the generated documentation. 
Comments using `///` are used to describe types following them.

As an example, here's the code for the function `Day::assert_valid` which is a private function:
```rust
/// # Panics
/// - if day is invalid
fn assert_valid(&self, current_month: &Month, current_year: &Year) {
    let &Day(day) = self;

    let mut current_year: i32 = current_year.get();

    // Se for negativo, converte para positivo
    if current_year < 0 {
        current_year = -current_year;
    }

    // true if "leap year".
    let leap_year: bool = (current_year % 4) == 0;
    // convert true = 1, false = 0.
    let leap_year: u8 = leap_year as u8;

    // source: https://www.rapidtables.com/calc/time/months-of-year.html
    let max_day: u8 = match current_month {
        &Month::January(_) => 31,
        &Month::February(_) => 28 + leap_year,
        &Month::March(_) => 31,
        &Month::April(_) => 30,
        &Month::May(_) => 31,
        &Month::June(_) => 30,
        &Month::July(_) => 31,
        &Month::August(_) => 31,
        &Month::September(_) => 30,
        &Month::October(_) => 31,
        &Month::November(_) => 30,
        &Month::December(_) => 31,
    };

    // check if day is within valid range
    assert!(day <= max_day,
        "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
            day,
            current_month,
            current_year,
            max_day,
    )
}
```
Comments using `//` provide insight into how the code is implemented, and they will not be included in the generated documentation.

Comments using `///` provide more information on the function's behavior. Here, we see the function can panic if the 
day is invalid. 

A seguir hÃ¡ um exemplo da funÃ§Ã£o ```Month::new``` no caminho ```./src/entry/schedule/month/Month.rs```.

```rust
/// Create a month instance.
/// 
/// All possible values on the left are converted
/// to an enum value on the right:
/// 
///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
///  - "march", "mar", "marÃ§o", "marzo" => Month::March("March")
///  - "april", "apr", "abril", "abr" => Month::April("April")
///  - "may", "maio", "mayo" => Month::May("May")
///  - "june", "jun", "junho", "junio" => Month::June("June")
///  - "july", "jul", "julho", "julio" => Month::July("July")
///  - "august", "aug", "agosto", "ago" => Month::August("August")
///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
/// 
/// # Panics
/// - if an invalid argument is provided. Month name is not valid.
/// 
pub fn new(month: &str) -> Self {
    let lower_case: String = month.to_ascii_lowercase();
    
    match &lower_case[..] {
        "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
        "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
        "march" | "mar" | "marÃ§o" | "marzo" => Month::March(String::from("March")),
        "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
        "may" | "maio" | "mayo" => Month::May(String::from("May")),
        "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
        "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
        "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
        "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
        "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
        "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
        "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
        invalid => panic!("Invalid value for month: {}.", invalid),
    }
}
```
The documentation above the function has a lot of details; the reason being that not only users need information about what the function does and the arguments it needs, but also to inform developers how they can change or modify the function to extend to other use cases.

---

### Modules

[top](#topics)

Modules in Rust can be a bit confusing... some directories have a `mod.rs` file while others do not. That's just because there is more than one way to declare a module in Rust. 

You declare a Rust module by either:
 - A rust file with a matching directory name on the level.
 - Having a `mod.rs` file inside a directory.

Examples:

 - Module `entry` is located in ```./src/entry/mod.rs```
 - Module `temperature` is defined by ```./src/temperature/mod.rs```
 - Module `date` is located in ```./src/schedule/date.rs```, inside a directory on the path ```./src/schedule/```
 - Module `time` is located in ```./src/schedule/time.rs```, inside a directory on the path ```./src/schedule/```

Learn more about [module organization](https://aloso.github.io/2021/03/28/module-system.html).

---

### User access control

[top](#topics)

Function calls needs to be mde from a NEAR account. We can control access by checking for the account's name who made the call. When the contract is initialized, only the owner can make calls. Additional accounts can be included using the function `Contract::add_user`. 

Each account we add does not have admin permissions, but they do have some storage space for data. It will also have the permission to add new entries, as well as the permission to update their values. 

A reason for limiting access by account is due to the possibility of a bad actor gaining acesss to a device and using them to also access the smart contract. If this happens, with the security put in place, that bad actor could only include new entries or update the values, which are very limited actions due to the amount of gas they spend for an account related to a sensor. 

Functions that control access are private functions: 
 - ```Contract::assert_owner_only```: panics if the caller is not the owner; the owner is the account that was used to deploy the smart contract.
 - ```Contract::assert_user_allowed```: panics if the caller is not a user in the allowed user list. Owner is, of course, on the allowed user list.

```rust
// assert the owner is the caller
fn assert_owner_only(&self){
    let predecessor: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = AccountId::from(env::current_account_id());

    assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
}

// check user permissions
fn assert_user_allowed(&self) {
    let predecessor_id: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = env::current_account_id();

    // is the caller the owner? call assert_owner_only
    if owner_id == predecessor_id {
        return;
    }

    // check if user is in the allowed list
    assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
}
```

The module `near_sdk::env` provides all the information related to the virtual machine's environment as well as all the message details. Here's a quick glance at some of the information available: 

 - `env::predecessor_account_id`: Id of the account who is _currently_ calling the function.
 - `env::signer_account_id`: Id of the account who _first signed_ the transaction that initiated the call(s).
 - `env::current_account_id`: Id of the current account, who is the owner of the _currently executing_ smart contract.

In the most simple scenarios, `predecessor_account_id` and `signer_account_id` are the same. However, do keep in mind that smart contracts can call other contract's functions (in a chain like manner); when this happens, we call them _cross contract calls_. 

Let's say account **A** calls contract **B**, and contract **B** calls contract **C**, who in turn, calls yet another contract **D**:

```
A -> B -> C -> D
```

In the scenario above, the `signer_account_id` will always be **Account A**. 
Let's find out who is the `predecessor_account_id`: 
 
 - For **B**, the `predecessor_account_id` is **A**.
 - For **C**, the `predecessor_account_id` is **B**.
 - For **D**, the `predecessor_account_id` is **C**.

In our contract, we check if the `owner_account_id` and `predecessor_account_id` are the same. If they are, then the function caller is the **owner**; otherwise, we check if `predecessor_account_id` is included in the allowed user list. 

We could have used the `signer_account_id` but that will rule out any possibility of cross contract calls. A developer could add more features to this contract, so we have to keep our smart contract flexible (yet secure). 

[Learn more](https://docs.near.org/tutorials/crosswords/beginner/actions#predecessor-signer-and-current-account) about predecessor, signer, and current account. 

---

### Cross-Contract calls

[top](#topics)
A "cross contract call" is when a smart contract calls another smart contract's function. Sometimes, you want to prevent cross contract calls, such as when having function that make critical changes to the system. 

For our smart contract, we have implemented a function called `Contract::no_cross_contract`: 

```rust
// don't allow cross-contract calls
fn assert_no_cross_contract(&self){
    let signer_id: AccountId = env::signer_account_id();
    let predecessor_id: AccountId = env::predecessor_account_id();
    assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
}
```

Our check simply compaers if the `signer_account_id` is the same as `predecessor_account_id`.

We prevent cross contract calls in some of our functions, such as `Contract::add_user`, `Contract::remove_user` and `Contract::set_default_temperature_unit` since these are admin operations that could add or remove users, as well as affect our system's data.
 
 - `Contract::set_default_temperature_unit`: could result in high gas use due to changing a lot of data.
 - `Contract::add_user`: could include unneeded users to the system.
 - `Contract::remove_user`: could remove users as well as their data. Unproper usage of this function could bring the whole system down.

---

### Handling Output

[top](#topics)
The same function can return diferent data types if we handle them using `enums`. We first need to create an enum that has all the variants:

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

 - `#[derive(Deserialize, Serialize)]` implements the traits `near_sdk::serde::Deserialize` and `near_sdk::serde::Serialize` on our enum. These are needed to serialize and deserialize to and from JSON.
 - `#[serde(crate) = "near_sdk::serde"]` hints to the compiler to use the serde crate found in the NEAR SDK.
 - `#[serde(untagged)]` is an attribute that hints serde  **not** to use JSON tags such as `{ Single: value }` or `{ Multiple: [value1, value2, ...] }`, but just use the actual values like so: `value`, and `[value1, value2, ...]`.

[Learn more](https://serde.rs/enum-representations.html) about using Serde and enums. 

Com o enum declarado e configurado. Basta retornar o tipo em uma funÃ§Ã£o de contrato:
Since we declared and decorated our enum with the proper attributes, we can simply return it from our functions:

```rust
pub fn view_get(
    &self, 
    index: Option<u64>, 
    account_id: String,
) -> ViewGet {
    match index{
        None => {
            let result = self.entries.get(&account_id)
                .unwrap()
                .to_vec();

            ViewGet::Multiple(result)
        },
        Some(index) => {
            let result = self.entries.get(&account_id)
                .unwrap()
                .get(index)
                .unwrap();

            ViewGet::Single(result)
        }
    }
}
```
:warning: **NOTE:** The function above is a **view** function which is free to call (doesn't use gas).

The function just returns a `ViewGet` variant. If the `index` argument is found we will return a `ViewGet::Single(result)` with the value found. If no `index` was specified, then we'll return a list of values found as a `ViewGet::Multiple(result)`.

---

### Handling Input

[top](#topics)

Let's see how we can use the `Option` type. Let's review the following function:

```rust
pub fn new_entry(
    &mut self, 
    time: Option<(u8, u8, f32)>,
    date: Option<(i32, String, u8)>,
    temp_value: f32, 
    temp_format: Option<String>,
) {
    self.assert_user_allowed();
    let user: AccountId = env::predecessor_account_id();

    log("Called new_entry.");

    log("Creating Entry.");
    let entry: TemperatureReading = TemperatureReading::new(time, date, &self.temp_format, temp_value, temp_format);

    log("Acquiring entries for this user.");
    let mut entries = match self.entries.get(&user){
        None => panic!("Unexpected Behavior: Failed to find entries for this user."),
        Some(value) => value,
    };
    
    log("Pushing entry to Vector.");
    entries.push(&entry);
    assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

    log("Operation Successful.");
}
```

`Option` is a type that allows having optional values or alternatives, such as `Some(value)` or `None`. 
 - If there is a value, we can wrap it as `Some(value)`.
 - If there is none, then we can just `None`.

:hand: There are no **nulls** in Rust. [Here's](https://www.kirillvasiltsov.com/writing/optional-arguments-in-rust/) an interesting and quick read about optional arguments in Rust. 

In order to check our option, we use the `match` keyword, which forces us to consider all possibilities. 

```rust
pub fn list_update_entries(
    &mut self, 
    account_id: Option<String>,
) -> Vec<TemperatureReading> {
    self.assert_user_allowed();

    // let account_id: AccountId = env::predecessor_account_id();
    let account_id = match account_id {
        None => {
            env::predecessor_account_id()
        },
        Some(value) => {
            let predecessor = env::predecessor_account_id();

            if predecessor != value {
                let signer_id: AccountId = env::signer_account_id();
                let owner_id: AccountId = env::current_account_id();

                assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
            }

            value
        }
    };    
```

You can see above how we specify our `account_id` as `Option<String>`. 

If an `account_id` is indeed provided, we do some checking and if everything is ok, we assign its value to `account_id` But, if we didn't specify it (we specified `None` as the argument) then we just assign `account_id` to whoever called this function (by know you should read that `predecessor_account_id` as second nature!).

---

### Implementing Traits

[top](#topics)

A `Day`, which is part of a `Date`, belongs to a `Timestamp`. Here's how we implemented them:

```rust
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);
```

So `Day` is just an `u8`. However, we do want to put in place some additional behavior that has to do with a `Day`, so let's implement some traits:

```rust
/// Convert to u8 from Day
impl From<&Day> for u8 {
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Convert to String from Day
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Convert struct to String. Implementing this trait allows using Day in format!, println! and panic!
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}
```

The `From` trait allows converting from one type to another. Having implemented the traits above, we can now convert to and from `u8` as well as `String`, by using `u8::from(&day)` and `String::from(&day)`. 

The trait `Display` seems complex, but it simply allows that macros such as `panic!`, `format!` and `println!` can be used with the type implementing the trait. If you don't implement `Display`, then something simple like `println!("The day is {}", day)` would panic. 

---

Lesson 6 - Thermometer :white_check_mark: ... **Done! Congratulations!**

Let's learn next all we can about `Result` on our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_3_game_score/).

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/contract.rs ---
//! Smart Contract module

use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        Vector,
        LookupMap, 
        UnorderedSet,
    },
    env,
    json_types::ValidAccountId,
    near_bindgen,
};

near_sdk::setup_alloc!();

use crate::{
    temperature::temp_format::TemperatureUnit,
    utils::{
        log,
        ViewGet,
    },
    entry::TemperatureReading,
};

/// Used to access smart contract blockchain data
/// 
/// Each Vector, LookupMap or UnderorderedSet needs a unique key.
/// So we use this enum as key.
/// 
#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    Entries,
    Users,
    UserEntry(String),
}

/// Smrart Contract API
/// 
/// Only owner or allowed user can use call functions
///
/// Functions:
///  - **add_user**: add user to allowed user list.
///  - **remove_user**: remove user from allowed user list.
///  - **set_default_temperature_unit**: converts from one temperature unit to another.
///  - **new_entry**: add a new temperature measurement.
///  - **list_update_entries**: updates all measurements for a user (converting from/to units if necessary).
///  - **clear_entries**: clear all temperature measurements for a user.
///  - **view_get_format**: view function. Returns default temperature unit.
///  - **view_get**: view function. If given an index returns a specific measurement, if not returns all measurements
/// 
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    temp_format: TemperatureUnit,
    entries: LookupMap<AccountId, Vector<TemperatureReading>>,
    users: UnorderedSet<AccountId>,
    temp_length: u32,
}

// initialize smart contract
impl Default for Contract {
    fn default() -> Self {        
        let mut entries = LookupMap::new(StorageKey::Entries);

        let owner_account: String = env::current_account_id();
        let temperature_readings: Vector<TemperatureReading> = Vector::new(StorageKey::UserEntry(String::from(&owner_account)));
        let inserting = entries.insert(&owner_account, &temperature_readings);

        assert!(inserting.is_none(), "Something impossible just happened. Created a LookupMap that already had a value stored.");

        Contract {
            temp_format: TemperatureUnit::default(),
            entries,
            users: UnorderedSet::new(StorageKey::Users),
            temp_length: 0,
        }
    }
}

#[near_bindgen]
impl Contract{
    // assert the owner is the caller
    fn assert_owner_only(&self) {
        let predecessor: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
    }

    // don't allow cross-contract calls
    fn assert_no_cross_contract(&self) {
        let signer_id: AccountId = env::signer_account_id();
        let predecessor_id: AccountId = env::predecessor_account_id();
        assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
    }

    // check user permissions
    fn assert_user_allowed(&self) {
        let predecessor_id: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        // is the caller the owner? call assert_owner_only
        if owner_id == predecessor_id {
            return;
        }

        // check if user is in the allowed list
        assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
    }

    /// Add user to allowed user list.
    /// 
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If caller is not owner.
    ///  - If invalid account name.
    ///  - If user already in the allowed user list.
    /// 
    pub fn add_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called add_user.");

        // test if account has a well formed format and follows some simple rules... this doesn't mean it ACTUALLY EXISTS in the blockchain!!
        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        log("Checking if user already exists.");
        let contains: bool = self.users.contains(&account_id);
        assert!(!contains, "User {} is already included in allowed list.", &account_id);
        
        // Create vector for user data
        log("New user detected. Storing User.");
        let user_vector: Vector<TemperatureReading> = Vector::new(StorageKey::UserEntry(String::from(&account_id)));
        let inserting = self.entries.insert(&account_id, &user_vector);
        
        // last check for any implementation error
        assert!(inserting.is_none(), "Unexpected behavior. User is already included in entries.");

        // add user to list
        self.users.insert(&account_id);
    }

    /// Removes user from allowed list.
    /// 
    /// Only the owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If caller is not the owner.
    ///  - If invalid user name.
    /// 
    pub fn remove_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        // you can't remove the owner
        let owner_id: AccountId = env::current_account_id();
        assert_ne!(&owner_id[..], &account_id[..], "Owner account can't be removed from contract.");

        log("Called remove_user");

        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        log("Checking if user exists.");
        let contains: bool = self.users.contains(&account_id);
        // panic if user not in list
        assert!(contains, "User {} not found.", &account_id);

        // remove vector for user data
        let entries: Option<Vector<TemperatureReading>> = self.entries.remove(&account_id);
        assert!(entries.is_some(), "Unexpected Behavior. Found user, but didn't find entry list for user.");

        // clear all user data (security)
        let mut entries: Vector<TemperatureReading> = entries.unwrap();
        entries.clear();

        match self.users.remove(&account_id){
            true => {
                log("User successfully removed.");
            },
            false => {
                log("Unexpected Behavior. Account exists in entries but doesn't exist in user list.");
            },
        };
    }

    
    /// Update default temperature unit (system default).
    /// Doesn't modify any existing entries (Data).
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If user not in allowed user list.
    ///  - If caller is not owner
    /// 
    pub fn set_default_temperature_unit(&mut self, unit_name: String) {
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called set_default_temperature_unit");

        let temperature_unit = TemperatureUnit::new(&unit_name);

        log(
            &format!("Setting default temperature unit to {}", &temperature_unit)
        );

        self.temp_format = temperature_unit;
    }
    

    /// Stores a new temperature measurement associated with a user.
    /// 
    /// time and date are optional. If not specified, these will be the current date and time. 
    /// format is optional. If not specified, the default temperature unit (system default) will be used.
    /// 
    /// # Panics
    ///  - If user is not on the allowed list
    ///  - If hour is negative or larger than 23.
    ///  - If minute is negative or larger than 59.
    ///  - If second is negative or larger than 59.9
    ///  - If day is invalid for year and month;
    ///  - If month name is an invalid String.
    ///  - If temp_format is an invalid String.
    /// 
    /// # Examples (bash)
    ///  - new_entry '{"temp_value": 100 }'
    ///  - new_entry '{"temp_value": 100, "temp_format": "Celsius"}'
    ///  - new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}'
    ///  - new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}'
    ///  - new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}'
    ///  - new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}'
    /// 
    pub fn new_entry(
        &mut self, 
        time: Option<(u8, u8, f32)>,
        date: Option<(i32, String, u8)>,
        temp_value: f32, 
        temp_format: Option<String>,
    ){
        self.assert_user_allowed();
        let user: AccountId = env::predecessor_account_id();

        log("Called new_entry.");

        log("Creating Entry.");
        let entry: TemperatureReading = TemperatureReading::new(time, date, &self.temp_format, temp_value, temp_format);

        log("Acquiring entries for this user.");
        let mut entries = match self.entries.get(&user){
            None => panic!("Unexpected Behavior: Failed to find entries for this user."),
            Some(value) => value,
        };
        
        log("Pushing entry to Vector.");
        entries.push(&entry);
        assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

        log("Operation Successful.");
    }

    /// Return user data, updating the values to the default temperature unit.
    /// 
    /// If account_id not specified, return data for the caller account.
    /// 
    /// Only owner can change other user's data.
    /// 
    /// # Panics
    ///  - If user is not allowed.
    ///  - If caller is not owner.
    ///  - If user not found.
    /// 
    pub fn list_update_entries(
        &mut self, 
        account_id: Option<String>,
    ) -> Vec<TemperatureReading> {
        self.assert_user_allowed();

        // let account_id: AccountId = env::predecessor_account_id();
        let account_id = match account_id {
            None => {
                env::predecessor_account_id()
            },
            Some(value) => {
                let predecessor = env::predecessor_account_id();

                if predecessor != value {
                    let signer_id: AccountId = env::signer_account_id();
                    let owner_id: AccountId = env::current_account_id();

                    assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
                }

                value
            }
        };
        
        let mut entries: Vector<TemperatureReading> = match self.entries.get(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(value) => value,
        };

        let mut entries_vec = entries.to_vec();

        let temp_format: TemperatureUnit = self.temp_format.clone();
        let mut changed: bool = false;
        
        // MW: check index needed?
        let mut index: u64 = 0;

        // entries.to_vec()
        for entry in entries_vec.iter_mut(){
            if entry.update_temp_format(&temp_format) {
                changed = true;
                entries.replace(index, &entry);
            };

            index += 1;
        };

        if changed {
            self.entries.insert(&account_id, &entries);
        }
        
        entries_vec
    }

    /// Clears all user data.
    /// 
    /// If account_id not specified, clear all user data for the caller.
    /// 
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If user is not owner
    ///  - If specified user is not found (no data)
    /// 
    pub fn clear_entries(
        &mut self, 
        account_id: Option<String>,
    ){
        self.assert_owner_only();
        
        let account_id: String = match account_id {
            None => env::predecessor_account_id(),
            Some(value) => {
                log("Validating user account.");

                match ValidAccountId::try_from(value){
                    Ok(account_id) => String::from(account_id),
                    Err(err) => panic!("Invalid user account id: {}.", err),
                }
            }
        };

        assert!(self.users.contains(&account_id), "Account {} not found.", &account_id);
        
        // entries.remove: 
        // Removes a key from the map, returning the value at the key if the key was previously in the map
        let entries: Vector<TemperatureReading> = match self.entries.remove(&account_id) {
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(mut value) => {
                value.clear();
                value
            },
        };

        assert!(
            self.entries.insert(&account_id, &entries).is_none(),
            "Unexpected behavior, attempted to remove the vector for {}, but it still exists after removing.", 
            &account_id,
        );

        log(&format!("Successfully removed all entries for {}.", &account_id));
    }

    // View Functions

    /// Returns default temperature unit name
    pub fn view_get_format(&self) -> String {
        String::from(&self.temp_format)
    }

    /// Return user data for a given user.
    /// 
    /// If index not specified, return all temperature measurements for a user.
    /// 
    pub fn view_get(
        &self, 
        index: Option<u64>, 
        account_id: String,
    ) -> ViewGet {
        match index{
            None => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .to_vec();

                ViewGet::Multiple(result)
            },
            Some(index) => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .get(index)
                    .unwrap();

                ViewGet::Single(result)
            }
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/entry/mod.rs ---
//! Entry represents a single input value from a user
//! 
//! Periodically each sensor will send temperature readings. The Smart Contract will save these as it receives them.
//! 
//! Each temperature reading has the following attributes: 
//!  - temperature: a temperature value (f32) with a temperature unit (Kelvin, Celsius, Fahrenheit).
//!  - schedule: a timestamp when the the measurement was taken. UTC.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use crate::{
    schedule::Timestamp,
    temperature::{
        Temperature,
        temp_format::TemperatureUnit,
    }
};

/// Represents a temperature reading 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TemperatureReading {
    timestamp: Timestamp,
    measurement: Temperature,
}

impl TemperatureReading {
    /// Creates a temperature reading
    /// 
    ///  - If time is omitted, the call time will be used as default.
    ///  - Id date is omitted, the call date will be used as default.
    ///  - If temperature unit is ommited, the system's default will be used as default.
    ///  - Value represents the actual temperature value/measurement.
    /// 
    ///  # Panics
    ///  - if temperature below absolute zero.
    ///  - On invalid day.
    ///  - On invalid month.
    /// 
    pub fn new(
            time: Option<(u8, u8, f32)>,
            date: Option<(i32, String, u8)>,
            temperature_unit: &TemperatureUnit, 
            temperature_value: f32, 
            arg_temp: Option<String>,
        ) -> Self {
        
        TemperatureReading { 
            timestamp: Timestamp::new(date, time), 
            measurement: Temperature::new(temperature_value, temperature_unit, arg_temp),
        }
    }

    /// If there's a new temperature unit given, perform conversion
    pub fn update_temp_format(&mut self, new_format: &TemperatureUnit) -> bool {
        self.measurement.update_temp_format(new_format)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/lib.rs ---
// We don't want this module on the docs, so we make it public to our crate only.
pub(crate) mod contract;
pub mod entry;
pub mod schedule;
pub mod temperature;
pub mod utils;

pub use contract::Contract;

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date.rs ---
//! Date module
//! 
//! Used by timestamp
//! contains day, month and year
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod day;
pub mod month;
pub mod year;

use day::Day;
use month::Month;
use year::Year;

/// Represents a Date (day, month, year).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Date {
    day: Day,
    month: Month,
    year: Year,
}

impl Date{
    /// Creates a Date 
    /// 
    /// # Panics
    ///  - If day is negative.
    ///  - If day is higher than the max allowed for a particular month.
    ///  - If month is an invalid String.
    /// 
    pub fn new(day: u8, month: &str, year: i32) -> Date {
        // Creates a year 
        let year: Year = Year::new(year);
        // Creates a month
        let month: Month = Month::new(month);
        // Creates a day
        let day: Day = Day::new(day, &month, &year);

        Date{
            day,
            month,
            year,
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/day.rs ---
//! Module with all functions related to a day
//! 
//! We use an u8 for the day, but we also need to 
//! check the day is valid. So, we'll need to make
//! day a struct Day(u8).
//! 
//! When serialized to JSON, the value would just be
//! an u8, so there won't be any additional complexity
//! for the user.
//! 
//! You can build Day using Day::new. 
//! This function needs both month and year to know
//! the max value for day and if it is a leap year.
//! Other features:
//!  - u8::from(day) allows converting a Day to u8.
//!  - String::from(day) allows converting a Day to String.
//!  - std::fmt::Display is implemented, and so it allows to 
//! use Daz in macros println! and panic!
//! 
//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Serialize, Deserialize },
};

use crate::schedule::date::{
    month::Month,
    year::Year,
};

/// Represents a day
/// 
/// When serialized, it will become an u8.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);

impl Day{
    /// Creates an instance of Day.
    ///  - day: 1 to 31, depending on month and year.
    ///  - current_month: current month, for validation
    ///  - current_year: current year, for validation
    /// 
    /// # Panics
    /// - invalid day
    /// 
    pub fn new(day: u8, current_month: &Month, current_year: &Year) -> Self {
        let day = Day(day);
        day.assert_valid(current_month, current_year);

        day
    }

    /// # Panics
    /// - if day is invalid
    fn assert_valid(&self, current_month: &Month, current_year: &Year) {
        let &Day(day) = self;

        let mut current_year: i32 = current_year.get();

        // Se for negativo, converte para positivo
        if current_year < 0 {
            current_year = -current_year;
        }

        // true if "leap year".
        let leap_year: bool = (current_year % 4) == 0;
        // convert true = 1, false = 0.
        let leap_year: u8 = leap_year as u8;

        // source: https://www.rapidtables.com/calc/time/months-of-year.html
        let max_day: u8 = match current_month {
            &Month::January(_) => 31,
            &Month::February(_) => 28 + leap_year,
            &Month::March(_) => 31,
            &Month::April(_) => 30,
            &Month::May(_) => 31,
            &Month::June(_) => 30,
            &Month::July(_) => 31,
            &Month::August(_) => 31,
            &Month::September(_) => 30,
            &Month::October(_) => 31,
            &Month::November(_) => 30,
            &Month::December(_) => 31,
        };

        // check if day is within valid range
        assert!(day <= max_day,
            "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
                day,
                current_month,
                current_year,
                max_day,
        )
    }
}

/// Convert to u8 from Day
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Convert to String from Day
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Convert struct to String. Implementing this trait allows using Day in format!, println! and panic!
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/month.rs ---
//! Module with all functions related to a month
//! 
//! We'll use an enum with all possible month value
//! For JSON, it is better to use a string or a number.
//! 
//! Using serde, we can choose the best option. 
//! Let's first declare our enum.
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! If month is Month::December(String::from("December")), 
//! then our value JSON will be {December: "December"}.
//! 
//! But, if we use untagged, 
//! serde(untagged), 
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! #[serde(untagged)]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Then no tag will be used and so 
//! Month::december(String::from("December")), 
//! will be represented as month: "December". 
//! which is more user-friendly.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a month
/// 
/// Using serde(untagged) this enum will
/// be represented as string (no tag)
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Month{
    January(String),
    February(String),
    March(String),
    April(String),
    May(String),
    June(String),
    July(String),
    August(String),
    September(String),
    October(String),
    November(String),
    December(String),
}

impl Month{
    /// Create a month instance.
    /// 
    /// All possible values on the left are converted
    /// to an enum value on the right:
    /// 
    ///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
    ///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
    ///  - "march", "mar", "marÃ§o", "marzo" => Month::March("March")
    ///  - "april", "apr", "abril", "abr" => Month::April("April")
    ///  - "may", "maio", "mayo" => Month::May("May")
    ///  - "june", "jun", "junho", "junio" => Month::June("June")
    ///  - "july", "jul", "julho", "julio" => Month::July("July")
    ///  - "august", "aug", "agosto", "ago" => Month::August("August")
    ///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
    ///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
    ///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
    ///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
    /// 
    /// # Panics
    /// - if an invalid argument is provided. Month not valid.
    /// 
    pub fn new(month: &str) -> Self {
        let lower_case: String = month.to_ascii_lowercase();
        
        match &lower_case[..]{
            "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
            "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
            "march" | "mar" | "marÃ§o" | "marzo" => Month::March(String::from("March")),
            "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
            "may" | "maio" | "mayo" => Month::May(String::from("May")),
            "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
            "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
            "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
            "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
            "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
            "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
            "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
            invalid => panic!("Invalid value for month: {}.", invalid),
        }
    }

    // jan 31
    // feb 59
    // mar 90
    // apr 120
    // may 151
    // jun 181
    // jul 212
    // aug 243
    // sep 273
    // octo 304
    // nov 334
    // dec 365

    /// Value in range 0 and 365. 
    /// Return month and day, based on year
    /// 
    /// if is_leap_year then the range can be 0 to 366.
    /// 
    pub fn new_from_days(mut days: u64, is_leap_year: bool) -> (String, u8) {
        // 0 false 1 true
        let leap_year: u64 =  is_leap_year as u64;
        assert!(days < 365 + leap_year, "Unexpected Behavior. Days should be lower than {}. Got {}.", 365 + leap_year, days);
        // day 0 = jan 1
        days += 1;

        if days <= 31 {
            return (String::from("jan"), days as u8);
        }
        if days <= 59 + leap_year {
            // include feb 29 for leap year
            return (String::from("feb"), days as u8 - 31);
        }
        if days <= 90 + leap_year {
            return (String::from("mar"), (days - 59 - leap_year) as u8);
        }
        if days <= 120 + leap_year {
            return (String::from("apr"), (days - 90 - leap_year) as u8);
        }
        if days <= 151 + leap_year {
            return (String::from("may"), (days - 120 - leap_year) as u8);
        }
        if days <= 181 + leap_year {
            return (String::from("jun"), (days - 151 - leap_year) as u8);
        }
        if days <= 212 + leap_year {
            return (String::from("jul"), (days - 181 - leap_year) as u8);
        }
        if days <= 243 + leap_year {
            return (String::from("aug"), (days - 212 - leap_year) as u8);
        }
        if days <= 273 + leap_year {
            return (String::from("sep"), (days - 243 - leap_year) as u8);
        }
        if days <= 304 + leap_year {
            return (String::from("oct"), (days - 273 - leap_year) as u8);
        }
        if days <= 334 + leap_year {
            return (String::from("nov"), (days - 304 - leap_year) as u8);
        }

        (String::from("dec"), (days - 334 - leap_year) as u8)  
    }

    /// Returns month name as a String
    pub fn get(&self) -> String {
        match self {
            Month::January(value) => value.clone(),
            Month::February(value) => value.clone(),
            Month::March(value) => value.clone(),
            Month::April(value) => value.clone(),
            Month::May(value) => value.clone(),
            Month::June(value) => value.clone(),
            Month::July(value) => value.clone(),
            Month::August(value) => value.clone(),
            Month::September(value) => value.clone(),
            Month::October(value) => value.clone(),
            Month::November(value) => value.clone(),
            Month::December(value) => value.clone(),
        }
    }
}

/// Convert to u8 from month
impl From<&Month> for u8 {
    fn from(month: &Month) -> u8 {
        match month {
            Month::January(_) => 0,
            Month::February(_) => 1,
            Month::March(_) => 2,
            Month::April(_) => 3,
            Month::May(_) => 4,
            Month::June(_) => 5,
            Month::July(_) => 6,
            Month::August(_) => 7,
            Month::September(_) => 8,
            Month::October(_) => 9,
            Month::November(_) => 10,
            Month::December(_) => 11,
        }
    }
}

/// Convert to Month from u8
impl From<u8> for Month {
    fn from(month: u8) -> Month {
        match month{
            0 => Month::new("jan"),
            1 => Month::new("feb"),
            2 => Month::new("mar"),
            3 => Month::new("apr"),
            4 => Month::new("may"),
            5 => Month::new("jun"),
            6 => Month::new("jul"),
            7 => Month::new("aug"),
            8 => Month::new("sep"),
            9 => Month::new("oct"),
            10 => Month::new("nov"),
            11 => Month::new("dec"),
            invalid => panic!("Invalid value for month: {}. Number value must be positive, lower than 12.", invalid),
        }
    }
}

/// Convert to String from &Month
impl From<&Month> for String{
    fn from(month: &Month) -> String {
        month.get()
    }
}

/// Convert to String from Month
impl From<Month> for String{
    fn from(month: Month) -> String {
        String::from(&month)
    }
}

/// String representation, useful for using format!, println! and panic!
impl std::fmt::Display for Month {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

#[cfg(test)]
mod tests{
    use crate::utils::log;
    use crate::schedule::Month;

    #[test]
    /// Test Month::new_from_days 
    /// for all days of year and leap year 
    fn new_from_days(){

        /// testing year. parameters:
        ///  - days: range 0 to 365. 0 to 366 if is_leap_year = true.
        ///  - is_leap_year: true if leap year
        ///  - expected_month: range 0 to 12.
        ///  - expected_day: range 0 to 31, depending on month and if leap year
        /// 
        fn util_day_constructor(days: u64, is_leap_year: bool, expected_month: u8, expected_day: u8) {
            let (month_str, day) = Month::new_from_days(days, is_leap_year);
            let month_number = u8::from(&Month::new(&month_str));
    
            assert_eq!(
                month_number, 
                expected_month, 
                "Comparison error when constructing day. Expected month: {}, number: {}. Got {}.", 
                Month::from(expected_month), 
                expected_month, 
                month_number,
            );

            assert_eq!(
                day, 
                expected_day, 
                "Comparison error when constructing day. Expected day: {}. Got: {}.", 
                expected_day, 
                day,
            );
        }

        /// Use util_day_constructor to test all days of the year
        fn testing_year(is_leap_year: bool){
            let leap_year = is_leap_year as u64;

            #[allow(unused_mut)]
            let mut day_number;
            #[allow(unused_mut)]
            let mut month_number;

            for day in 0..(365 + leap_year) {
                if day < 31 { 
                    day_number = day;
                    month_number = 0; 
                } else if day < 59 + leap_year{ 
                    day_number = day - 31;
                    month_number = 1; 
                } else if day < 90 + leap_year { 
                    day_number = day - 59 - leap_year;
                    month_number = 2;  
                } else if day < 120 + leap_year{ 
                    day_number = day - 90 - leap_year;
                    month_number = 3; 
                } else if day < 151 + leap_year{ 
                    day_number = day - 120 - leap_year;
                    month_number = 4; 
                } else if day < 181 + leap_year { 
                    day_number = day - 151 - leap_year;
                    month_number = 5; 
                } else if day < 212 + leap_year{ 
                    day_number = day - 181 - leap_year;
                    month_number = 6; 
                } else if day < 243 + leap_year{ 
                    day_number = day - 212 - leap_year;
                    month_number = 7; 
                } else if day < 273 + leap_year{ 
                    day_number = day - 243 - leap_year;
                    month_number = 8; 
                } else if day < 304 + leap_year{ 
                    day_number = day - 273 - leap_year;
                    month_number = 9; 
                } else if day < 334 + leap_year{ 
                    day_number = day - 304 - leap_year;
                    month_number = 10; 
                } else { 
                    day_number = day - 334 - leap_year;
                    month_number = 11; 
                }

                // first day of month is 1
                util_day_constructor(day, is_leap_year, month_number, day_number as u8 + 1)
             }
        }

        log("Testing for non leap year.");
        testing_year(false);

        log("Testing for leap year.");
        testing_year(true);
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/year.rs ---
//! Module with all functions related to a year
//! 
//! Year is represented as a tuple of an integer and string
//! 
use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tuple representing a year. 
/// 
/// An integer representing the year. 
/// A String representing a formatted year.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Year(i32, String);

impl Year{
    /// create an instance of year
    pub fn new(mut value: i32) -> Year {
        let is_negative = value < 0;
        if is_negative{
            value = -value;
        }

        let text: &str = match is_negative{
            true => {
                "BC"
            },
            false => {
                "AD"
            }
        };

        let text: String = format!("{} {}", value, text);
        if is_negative {
            value = -value;
        }

        Year(value, text)
    }

    /// Returns year
    pub fn get(&self) -> i32 {
        // Year is a tuple, so using .0 is the first value.
        // i32 implements copy, so there's no need to self.0.clone()
        self.0
    }
}

/// Convert to String from &Year
impl From<&Year> for String{
    fn from(year: &Year) -> String {
        year.1.clone()
    }
}

/// Convert to String from Year
impl From<Year> for String{
    fn from(year: Year) -> String {
        String::from(&year)
    }
}

// Convert struct to String. Implementing this trait allows using Year in format!, println! and panic!
impl std::fmt::Display for Year {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/mod.rs ---
//! Timestamp module
//! 
//! Um valor de temperatura nÃ£o possui muita utilidade sem um tempo associado. Este Ã© o objetivo desse tipo.
//! 
//! Contains Date and Time, both used to create a Timestamp type
//! 
//! Pode ser fornecido como parÃ¢metro ou gerado automaticamente com o momento do sistema.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub mod date;
pub mod time;

use date::Date;
use time::Time;

use self::date::month::Month;

use crate::utils::log;

/// Represents a timestamp
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Timestamp {
    date: Date,
    time: Time,
}

impl Timestamp {
    
    fn remainder_from_value(mut value: u64, max: u64) -> (u64, u64) {
        let remainder: u64 = value % max;
        value = (value - remainder) / max;

        (value, remainder)
    }

    fn time_from_nanoseconds(nano: u64) -> (u8, u8, f32) {
        let (_, remainder) = Self::remainder_from_value(nano, 24 * 60 * 60 * 1_000_000_000);
        let (hours, remainder) = Self::remainder_from_value(remainder, 60 * 60 * 1_000_000_000);
        let (minutes, seconds) = Self::remainder_from_value(remainder, 60 * 1_000_000_000);

        (hours as u8, minutes as u8, seconds as f32 / 1_000_000_000.)
    }

    fn date_from_nanoseconds(nano: u64) -> (i32, String, u8) {
        // add 2 years, account for leap years
        let nano: u64 = nano + 2 * 365 * 24 * 60 * 60 * 1_000_000_000;

        let max: u64 = (365.25 as f64 * 24. * 60. * 60. * 1_000_000_000.) as u64;
        let (year, remainder) = Self::remainder_from_value(nano, max);

        let is_leap_year = year % 4 == 0;

        let max = 24 * 60 * 60 * 1_000_000_000;

        // full days is numbers of days 0 - 360
        // the remainder is discarded
        let (full_days, _) = Self::remainder_from_value(remainder, max);
        let (month, day) = Month::new_from_days(full_days, is_leap_year);
        
        // No inicio do calculo de data por nanosegundos. Somamos 2 anos ao valor recebido, para garantir que estÃ¡ em sincronia com os leap years.
        (year as i32 + 1968, month, day)
    }

    /// Creates a Timestamp
    /// 
    /// date: (year, month, day) tuple.
    /// time: (hour, minute, second) tuple.
    /// 
    pub fn new(date: Option<(i32, String, u8)>, time: Option<(u8, u8, f32)>) -> Self {
        
        // block_timestamp() = transaction signature time 
        let block_time: u64 = env::block_timestamp();

        let (year, month, day) = match date{
            Some(value) => value,
            None => {
                log("Date wasn't specified, using current date.");
                Self::date_from_nanoseconds(block_time)
            },
        };
        
        let (hour, minute, second) = match time{
            Some(value) => value,
            None => {
                log("Time wasn't specified, using current time");
                Self::time_from_nanoseconds(block_time)
            }
        };

        log(&format!("Epoch time is {}.", block_time));
        log(&format!("Day: {}, Month: {}, Year: {}", day, &month, year));
        log(&format!("Hour: {}, Minute: {}, Second: {}", hour, minute, second));

        let date: Date = Date::new(day, &month, year);
        let time: Time = Time::new(hour, minute, second);

        Timestamp { 
            date,
            time,
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time.rs ---
//! Time module
//! 
//! Used by timestamp
//! Contains Hour, Minute, Second
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod hour;
pub mod minute;
pub mod second;

use hour::Hour;
use minute::Minute;
use second::Second;

/// Represents Time (hour, minute, second)
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Time{
    hour: Hour,
    minute: Minute,
    second: Second,
}

impl Time {
    /// Creates a time instance
    /// 
    /// # Panics
    ///  - if hour >= 24;
    ///  - if minute >= 60;
    ///  - if second >= 60. ;
    ///  - if second < 0. ;
    /// 
    pub fn new(hour: u8, minute: u8, second: f32) -> Time{
        let hour: Hour = Hour::new(hour);
        let minute: Minute = Minute::new(minute);
        let second: Second = Second::new(second);

        Time{
            hour,
            minute,
            second
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/hour.rs ---
//! Hour module
//! 
//! This type is only an u8
//! 
//!  - u8::from(&hour) converts hour reference to u8 
//!  - u8::from(hour) converts hour value to u8
//!  - Hour::from(value u8) converts u8 value to Hour
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// A type represening an Hour
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Hour(u8);

impl Hour{
    pub fn new(hour: u8) -> Hour {
        assert!(hour < 24, "Invalid value for hour. Must be lower than 24. Current: {}.", hour);

        Hour(hour)
    }
}

/// Convert to u8 from &Hour
impl From<&Hour> for u8{
    fn from(hour: &Hour) -> u8 {
        let &Hour(result) = hour;

        result
    }
}

/// Convert to u8 from Hour
impl From<Hour> for u8{
    fn from(hour: Hour) -> u8 {
        u8::from(&hour)
    }
}

/// Convert to Hour from u8
impl From<u8> for Hour{
    fn from(hour: u8) -> Hour {
        Hour::new(hour)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/minute.rs ---
//! Minute module
//! 
//! This type is only an u8
//! 
//!  - u8::from(&minute) converts minute reference to u8 
//!  - u8::from(minute) converts minute to u8 
//!  - Minute::from(esteu8) converts u8 to Minute
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a minute
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Minute(u8);

impl Minute {
    /// Builds an instance of Minute
    /// 
    /// # Panics
    /// If value is less than 60
    /// 
    pub fn new(minute: u8) -> Minute{
        assert!(minute < 60, "Invalid value for minute. Must be lower than 60. Current: {}.", minute);

        Minute(minute)
    }
}

/// Convert to u8 from &minute
impl From<&Minute> for u8 {
    fn from(minute: &Minute) -> u8 {
        let &Minute(result) = minute;

        result
    }
}

/// Convert to u8 from minute
impl From<Minute> for u8{
    fn from(minute: Minute) -> u8 {
        u8::from(&minute)
    }
}

/// Convert to minute from u8
impl From<u8> for Minute{
    fn from(minute: u8) -> Minute {
        Minute::new(minute)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/second.rs ---
//! Second module
//! 
//! This type is only an f32
//! 
//!  - f32::from(&second) converts minute reference to f32.
//!  - f32::from(second) converts minute to f32.
//!  - Minute::from(value f32) converts f32 to Second
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a second
/// # Panics
///  - If value is higher than 60.
///  - If value is negative.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Second(f32);

impl Second {
    pub fn new(second: f32) -> Second{
        assert!(second < 60., "Invalid value for second. Must be lower than 60. Current: {}.", second);
        assert!(second >= 0., "Invalid value for second. Can't be negative. Current: {}.", second);

        Second(second)
    }
}

/// Convert to f32 from &Second
impl From<&Second> for f32 {
    fn from(second: &Second) -> f32 {
        let &Second(result) = second;

        result
    }
}

/// Convert to f32 from Second
impl From<Second> for f32{
    fn from(second: Second) -> f32 {
        f32::from(&second)
    }
}

/// Convert to Second from f32
impl From<f32> for Second{
    fn from(second: f32) -> Second {
        Second::new(second)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/temperature/mod.rs ---
//! Module: temperature
//! Has a temperature value (value) an a temperature unit (temp_format).
//! 
//! Smart Contract has a default temperature unit.
//! If you don't specify a temperature unit, we use the default system unit.
//! 
//! If the temperature unit sent in a message is different from the system-specified one, 
//! we convert it to the system temperature unit
//! 
pub mod temp_format;

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use temp_format::TemperatureUnit;
use crate::utils::log;

/// A Temperature.
/// temperature value is f32.
/// temperature unit can be Kelvin, Celsius or Fahrenheit.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Temperature {
    degrees: f32,
    unit: TemperatureUnit,
}

impl Temperature {
    /// Create an instance of temperature
    /// 
    /// # Panic
    /// if temperature value is less than absolute 0
    /// 
    fn new_assert(temperature_value: f32, temperature_unit: TemperatureUnit) -> Self {
        let (min_allowed, name) = match &temperature_unit {
            TemperatureUnit::Celsius(unit_name) => {(-273.15, unit_name)},
            TemperatureUnit::Fahrenheit(unit_name) => {(-459.67, unit_name)},
            TemperatureUnit::Kelvin(unit_name) => {(0., unit_name)},
        };

        assert!(temperature_value >= min_allowed, "For temperature unit {}, temperature value can not be lower than {}. Temperature value passed: {}.", name, min_allowed, temperature_value);
        
        Temperature { 
            degrees: temperature_value, 
            unit: temperature_unit,
        }
    }

    /// Creates an instance of Temperature using the system temperature unit
    /// 
    /// "arg_temp" is a temperature unit
    /// 
    /// if arg_temp is different from temp_format:
    ///  - Creates a temperature instance in arg_temp unit.
    ///  - Converts to temp_format.
    ///  - Returns temperature.
    /// 
    pub fn new(temperature_value: f32, temperature_unit: &TemperatureUnit, arg_temp: Option<String>) -> Self {
        match arg_temp {
            None => {
                Temperature::new_assert(temperature_value, temperature_unit.clone())
            },
            Some(arg_string) => {
                let mut arg_temp = Temperature::new_assert(temperature_value, TemperatureUnit::new(&arg_string));

                // Convert temperature reading into system temperature unit
                arg_temp.convert(temperature_unit);
                arg_temp
            }
        }

    }

    /// Udpate temperature if different unit.
    /// 
    /// Returns true if conversion was needed.
    /// 
    pub fn update_temp_format(&mut self, temperature_unit: &TemperatureUnit) -> bool {
        let comparison = self.unit == *temperature_unit;

        if !comparison {
            self.convert(temperature_unit);
        }

        !comparison
    }
    
    /// Convert temperature units
    pub fn convert(&mut self, temperature_unit: &TemperatureUnit){
        let current_unit: TemperatureUnit = self.unit.clone();
        let current_value = self.degrees;
        
        log(&format!("Converting temperature to system format. System Unit: {}, Current Unit: {}.", temperature_unit, &current_unit));

        match (current_unit, temperature_unit) {
            (TemperatureUnit::Kelvin(_), &TemperatureUnit::Celsius(_)) => {
                // C = K âˆ’ 273.15
                self.degrees = current_value - 273.15;    
                self.unit = TemperatureUnit::new("c");
            },
            (TemperatureUnit::Kelvin(_), &TemperatureUnit::Fahrenheit(_)) => {
                // F = (K â€“ 273.15) Ã— 9â„5 + 32
                self.degrees = (current_value - 273.15) * 9.0 / 5.0 + 32.0;
                self.unit = TemperatureUnit::new("f");
            },
            (TemperatureUnit::Celsius(_), &TemperatureUnit::Kelvin(_)) => {
                // K = C + 273.15
                self.degrees = current_value + 273.15;
                self.unit = TemperatureUnit::new("k");
            },
            (TemperatureUnit::Celsius(_), &TemperatureUnit::Fahrenheit(_)) => {
                // F = C(9â„5) + 32
                self.degrees = current_value * (9.0 / 5.0) + 32.0;
                self.unit = TemperatureUnit::new("f");
            },
            (TemperatureUnit::Fahrenheit(_), &TemperatureUnit::Kelvin(_)) => {
                // K = (F âˆ’ 32) Ã— 5â„9 + 273.15
                self.degrees = (current_value - 32.0) * 5.0 / 9.0 + 273.15;
                self.unit = TemperatureUnit::new("k");
            },
            (TemperatureUnit::Fahrenheit(_), &TemperatureUnit::Celsius(_)) => {
                // C = (F âˆ’ 32) Ã— 5â„9
                self.degrees = (current_value - 32.0) * 5.0 / 9.0;
                self.unit = TemperatureUnit::new("c");
            },
            (_, _) => {
                // all alternatives considered, therefore nothing to do
                return;
            }
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/temperature/temp_format.rs ---
//! Temperature Unit module
//! 
//! Unit can be Kelvin, Celsius or Fahrenheit.
//! The default is to use Kelvin.
//! 
//! Implemented TraitsÃ–
//!  - Default. Default unit is Celsius::Kelvin.
//!  - PartialEq and Eq. Allows comparing between Units.
//!  - String::from(&temperature_unit) converts a &temperature_unit reference to String;
//!  - String::from(temperature_unit) converts temperature_unit to String;
//!  - TemperatureUnit::from("a str") converts an &str to TemperatureUnit;
//!  - TemperatureUnit::from(aString) converts a String to TemperatureUnit;
//!  - TemperatureUnit::from(&aString) converts a &String reference to TemperatureUnit;
//!  - std::fmt::Display. Allows display of value using macros like println!, format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a TemperatureUnit (Kelvin, Celsius and Fahrenheit).
/// 
/// Temperature unit management, as we can have multiple sensors using different temperature units.
/// This guarantees all possibilities are in sync and correct.
/// 
/// This enum is seen a String when ser/deserialzing JSON.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum TemperatureUnit {
    Celsius(String),
    Fahrenheit(String),
    Kelvin(String),
}

impl TemperatureUnit {
    /// Creates a TemperatureUnit
    /// 
    /// Not case-sensitive. You can specify temperature units like:
    /// 
    ///  - "celsius", "c" => TempFormat::Celsius("Celsius")
    ///  - "fahrenheit", "f" => TempFormat::Fahrenheit("Fahrenheit")
    ///  - "kelvin", "k" => TempFormat::Kelvin("Kelvin")
    /// 
    /// # Panics
    /// - If unit name is invalid.
    /// 
    pub fn new(unit_name: &str) -> Self{
        // This conversion for &str to TemperatureUnit is possible due to From<&str> being implemented
        let lower_case: String = unit_name.to_ascii_lowercase();

        // let's return what matches OR panic!
        match &lower_case[..] {
            "celsius" | "c" => TemperatureUnit::Celsius(String::from("Celsius")),
            "fahrenheit" | "f" => TemperatureUnit::Fahrenheit(String::from("Fahrenheit")),
            "kelvin" | "k" => TemperatureUnit::Kelvin(String::from("Kelvin")),
            invalid_name => panic!("Invalid temperature unit name ({}). Valid args: ['Celsius', 'c', 'Fahrenheit', 'f', 'Kelvin', 'k']", invalid_name),
        }
    }
}

/// The default unit will set to Kelvin, but 
/// this can later be changed after contract initialization
/// 
impl Default for TemperatureUnit {
    fn default() -> Self {
        TemperatureUnit::new("k")
    }
}

// Allows partial comparison between temperate units
//
// A = B doesn't mean B = A
// A = B and A = C doesn't mean B = C
//
impl PartialEq for TemperatureUnit {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (TemperatureUnit::Celsius(_), TemperatureUnit::Celsius(_)) => true,
            (TemperatureUnit::Fahrenheit(_), TemperatureUnit::Fahrenheit(_)) => true,
            (TemperatureUnit::Kelvin(_), TemperatureUnit::Kelvin(_)) => true,
            (_, _) => false,
        }
    }
}

// This trait allows total comparison between temperature units
//
// A = B guarantees B = A
//
// A = B and A = C guarantees B = C
//
impl Eq for TemperatureUnit {}

/// Conversion to String fro &TemperatureUnit
impl From<&TemperatureUnit> for String{
    fn from(temperature_unit: &TemperatureUnit) -> String {
        match &temperature_unit {
            TemperatureUnit::Celsius(value) => (*value).clone(),
            TemperatureUnit::Kelvin(value) => (*value).clone(),
            TemperatureUnit::Fahrenheit(value) => (*value).clone(),
        }
    }
}

/// Conversion to String from TemperatureUnit
impl From<TemperatureUnit> for String {
    fn from(temperature_unit: TemperatureUnit) -> String {
        String::from(&temperature_unit)
    }
}

/// Conversion to TemperatureUnit from &str
impl From<&str> for TemperatureUnit{
    fn from(temperature_unit_name: &str) -> TemperatureUnit {
        TemperatureUnit::new(temperature_unit_name)
    }
}

/// Conversion to TemperatureUnit from &String
impl From<&String> for TemperatureUnit{
    fn from(temperature_unit_name: &String) -> TemperatureUnit {
        TemperatureUnit::from(&temperature_unit_name[..])
    }
}

/// Conversion to TemperatureUnit from String
impl From<String> for TemperatureUnit{
    fn from(temperature_unit_name: String) -> TemperatureUnit{
        TemperatureUnit::from(&temperature_unit_name[..])
    }
}

/// Allos displaying the enum as a String and is used by macros such as format!, println! and panic!.
impl std::fmt::Display for TemperatureUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/utils.rs ---
//! Utilities module
//! 
//!  - log: print a message on testing or production environments (different target output)
//!  - ViewGet: allows having different return typs for the same function.
//! 

use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::TemperatureReading;

#[allow(unused_imports)]
use near_sdk::env;

/// Prints using println when in a test environment. 
#[cfg(test)]
pub fn log(msg: &str){
    println!("{}", msg);
}

/// Prints using env::log when in a production environment. 
#[cfg(not(test))]
pub fn log(msg: &str) {
    env::log(msg.as_bytes());
}

/// Used as return type for view_get function
/// 
///  - If using an index returns a single temperature reading.
///  - If not using an index, then return a list of all temperature readings.
/// 
/// Not efficient when a contract has a lot of readings for a user/sensor, 
/// but best practice would be for the user to collect values locally and remove old ones
/// to save on both storage and computing fees
/// 
/// Using #[serde(untagged)] will keep our JSON very lean.
/// 
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(TemperatureReading),
    Multiple(Vec<TemperatureReading>),
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/Cargo.toml ---
[package]
name = "lesson_6_3_game_score"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/Readme.md ---
# Lesson 6 - 3 Game Score

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

In this example, we will see how to easily escape errors using the ```#[handle_result]``` macro, and also a way to update data about several users at each update (in this case, highscores).

This lesson is a simple simulation of a possible browser "rogue-like" game. "Rogue-likes" are games where your character goes through a series of randomly generated arenas, with randomly generated rewards. A few examples of popular games like this are "The Binding of Isaac", by Edmund McMillen and Florian Himsl and "Hades", by Supergiant Games.

This contract can't be used _(yet)_ for running a real game. But it has much of the structure that could be used for such games. We will go over the structure of the contract, and I would love to have a feedback from readers about their thoughts about this example.

Each player stores information about their characters. There's information on each of their highscores, plus there's a global (limited) highscore that can be updated whenever a new one is achieved. How to best save gas doing these operations is still an open question, but I left my suggestions on this example.

---

## Topics

 - [Building](#building)
 - [Smart Contract API](#smart-contract-api)
 - [How the contract is intended to be used](#how-the-contract-is-intended-to-be-used)
 - [Error management](#error-management)
 - [What each module does](#what-each-module-does)
   - [Chapter](#chapter)
     - [Chapter Reward](#chapter-reward)
   - [Character](#character)
      - [Class](#class)
      - [Stats](#stats)
   - [Player](#player)
      - [View](#view)
    - [Score](#score)
      - [HighScore](#highscore)
      - [Ranking](#ranking)

---

## Building

[top](#topics)

This crate belongs to the workspace at lesson_6_enums. Cargo commands will affect all the crates of the workspace. To specify only this crate, include the option `-p lesson_6_3_game_score`.

Build with:

`cargo build -p lesson_6_3_game_score --target wasm32-unknown-unknown --release`

Test with:

`cargo test -p lesson_6_3_game_score --nocapture`, where `--nocapture` will show output of each test.

---

## Smart Contract API

[top](#topics)

```rust
/// Update the player state.
/// 
/// This is going to be replaced by direct pointer access later.
/// 
fn save_player(&mut self, player: &Player) -> Result<(), Errors>;

/// If a  user does not exist in the database redirect to registry
fn load_player(&self) -> Result<Player, Errors>;

/// A user that is not registered can't access the smart contract.
/// 
/// Add the predecessor to the smart contract.
#[handle_result]
pub fn register_user(&mut self) -> Result<(), Errors>

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors>;

/// Loads and returns an instance of player.
#[handle_result]
pub fn check_status(&self) -> Result<player_view, Errors>;

/// Load a character with the given name and return it.
#[handle_result]
pub fn load_character(&self, name: String) -> Result<Character, Errors>;

/// Get current ranking.
pub fn get_ranking(&self) -> Ranking;

/// Get information about the next match.
#[handle_result]
pub fn start_match(&mut self) -> Result<Chapter, Errors>;

/// Report the match finished.
/// 
/// Some validations should be done about it.
/// 
/// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
/// 
/// A report should be a replay of the entire match. Including the AI of non-player-characters.
/// 
#[handle_result]
pub fn report_match(
    &mut self, 
    character: CharacterName, 
    score: Score, 
    // validation_report: ValidationReport,
) -> Result<bool, Errors>;

/// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
#[handle_result]
pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>;
```

## How the contract is intended to be used

[top](#topics)

We're considering that the game is running on a users' browser. We can't update the game in real time, like most online games would, because of latency and costs. But, when it comes to rogue-like games, each arena is small, and is intended to be finished in a short time: 1 or 2 minutes for each arena. 

We could require, as in-game mechanics, for the arenas to run for a limited time. As the player completes each of these small chapters, the browsers sends a report, a small replay, to the smart contract. The smart contract validates this report, and only then, updates the player's state.

Since the game isn't developed yet our implementation will not receive a report for now and will always consider the validation successful. I encourage you to try implementing a simple game to check how expensive it can be. 

When it comes to ranking of players we'll store it as a small Vector. This is because computing the ranking will become exponentially more expensive the higher the number of players, so let's limit it to something like 100 or 1000 players, and sort the Vector whenever a new entry is achieved.

The first step a browser has to take is call `register_user` so the user is stored in the state. 

 - `check_status` returns information about the current player.
 - `get_ranking` returns the current ranking between players.
 - `create_character` creates a new character associated with that player.
 - `load_character` returns a character owned by that player, with the given name.
 - `start_match` returns information about the current chapter, then resets the timer.
 - `report_match` validates your replay and if successful, give rewards to your character, update highscores and moves to the next chapter.
 - The owner of the smart contract account can call `set_max_highscore_players` to change the max number of players that can exist in ranking.

## Error management

[top](#topics)

In ```/src/model/errors.rs``` we have this enum.

```rust
#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
```

Each possible value for this enum represents an error that might happen in our project. The trait `std::fmt::Display` is used for turning a type into a String when we use macros like `println!` and `format!`. 

We also derive a new trait called `FunctionError`, and thanks to this trait we don't need to manually call ```env::panic_str``` or assert statements whenever something in the code breaks; we just return the error and the deserializer will raise the error for us. 

```rust
/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
/// 
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
    log!("Create Character function called.");
    
    let class: Class = Class::new(&class)?;
    let character: Character = Character::new(name, class)?;
    let mut player: Player = self.load_player()?;

    player.assign_character(character)?;

    self.save_player(&player)?;

    log!("Character successfully created.");

    Ok(())
}
```

In this example for creating characters, keep an eye out on three things:
 - The function returns `Result<(), Errors>`.
 - The `#[handle_result]` macro on top of the contract function.
 - `?` operators.

The `?` operator is useful for both Option and Result enums.
 - If we use it with `Option`, it unwraps the value or panics if it's `None`.
 - If we use it with `Result`, it unwraps the value or returns the error type as `Err`.

Notice that the return type of each of the functions with the `?` operator is a `Result` with the same `Err` type as this function (which is `Errors`).

This is a very clean way of handling errors. Don't you agree? We know where the errors are coming from. And we are not cluttering our code with error checking.

Having one enum to represent all the errors in the entire smart contract could easily get bloated in large projects. But that's easy to fix! Just have errors within errors, an enum that contains another enum. 
Create a method that wraps the smaller error into the larger error.

## What each module does

[top](#topics)

Some of these modules are very simple and can be easily expanded. The intention of this lesson is to offer an example of a game architecture, not the game itself. To offer inspiration on this uncharted web3 territory. The less specific the game mechanics are, the easier it is to incorporate to multiple different games.

### Chapter

[top](#topics)

This module represents a single chapter of the game. Each chapter is a small arena that the player stays for a limited time (e.g. 2 minutes). Rogue-like games include randomly generated elements in each chapter. Like random enemies, random bonuses for the player, random rewards, etc.

The `Chapter` type can be seen below: 

```rust
// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}
```

Each Chapter represents a unique "arena". The value within the tuple is used to count match length. 

When a player calls the function "start_match", the tuple stores when the match started. When the player calls "report_match", the chapter will calculater running time `(time_when_finished - time_when_started)` to make sure that the game wasn't run by a machine. 

Let's see how this works: imagine the player calls `start_match`, then, two seconds later, calls `validate_match` with a report that technically lasted two minutes.

The smart contract can't allow that. So, if the time in the report is greater than the time it took since the match started, the contract will panic. That's the only reason for storing time in a chapter.

If the validation is successful, then reward is awarded to the character.

#### Chapter reward

[top](#topics)

Chapter Reward calculates how much "EXP (experience)" was earned from a chapter. 

```rust
pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}
```

 - `exp`: How much base EXP is earned from this match. Regardless of player performance, they will always receive at least this amount.
 - `expected_level`: What level the player is expected to be at, before starting this chapter. Lower levels means harder matches, so higher rewards.
 - `level_multiplier`: For each level of difference, this will be multiplied an extra time, up to 5 times. Check the values in the tests to see some examples.
 - `score_multiplier`: The higher the score, the more exp. This is a  multiplier that applies to the score.

Check the implementation of `Chapter::compute_reward` for more information on how the bonuses are implemented.

### Character

[top](#topics)

Contains basic information about a game character. Each player has their own list of characters.

```rust
// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}
```

 - `name`: character's name. Will be show on high scores.
 - `class`: class is a model for how a character is built and what it can do later.
 - `level`: character's progression is marked by it's level. Exp raises this value automatically.
 - `xp`: how much exp this character has. Each new level resets this value.
 - `stats`: character actions are determined by their stats. 
 - `high_score`: the highest score achieved by the player in any chapter. If a new highscore is achieved, it will be sent for a comparison with the ranking of players.

#### Class

[top](#topics)

A few examples of classes just to show how each could affect stats in a unique way.

```rust
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}
```

We implement a constructor:

```rust
impl Class{
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }
}
```

Notice how this returns a `Rethe where th; jrror is of type ``Erthe`. Thi; js because we use the `?` operator in the contract methods. There's no need to manually raise errors in the implementation; just return a `Result::Err` instead.

Some type conversions below:

```rust
impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}
```

These are trait implementations for converting one type to another.

`From<&String> for Class` will allow us to pick a string, then attempt to convert it into a class through the function `from`. Here is an example:

```rust
let a = "Druid";
let b: Class = Class::from(a);
```

In the example above we create a `&str` with value "Druid", then create a class using that string slice. 

We implement owned Strings, move on to references of String and finally we end up doing conversion from a reference Class to a String (the reverse way).

#### Stats

[top](#topics)

Stats represent what your character can do in the arena. The success rate of each of their actions. To be used in chapter validation.

Because of the classes shown above. We want to show that each affect the stats in a unique way. So we chose these 3 basic stats: dexterity, strength and inteligence.

```rust
/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}
```

Base is the minimum value for that stat. Rate is how much that stat grows with each level. By calling the method `Stats::update` we update the value of each stat whenever the character levels up.

### Player

[top](#topics)

Each user represents one instance of `Player`.

```rust
/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, doesn't supports iteration
    characters: LookupMap<character::Name, Character>,
    // For storing character names, supports iteration
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.
    latest_chapter: Chapter,
}
```

 - `name`: name of the player;
 - `high_score`: high score achieved by the player. `None` if no chapter has been played yet.
 - `characters`: all characters owned by this player;
 - `character_names`: list of character names owned by the player;
 - `latest_chapter`: the next chapter the player is about to play;

The `LookupMap` is constant _O(1)_ for getting and inserting values. The ```UnorderedSet``` is used for iterating through the names. Both are updated simultaneously.

#### View

[top](#topics)

The collections for `characters` and `character_names` can't be serialized to readable json. So we create this type just to use as a return type.

```rust
/// This type exists only needs to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}
```

We only get player name, highscore and a list of characters for the view, which is all the player needs.

`Vec` is a collection that can be serialized with `serde`. It is updated every time the list of characters changes and its cost increases exponentially the higher the number of characters, so limiting the number of characters is recommended.

### Score

There are two types in this module: HighScore and Ranking.

#### HighScore

[top](#topics)

Represents a character or player's highscore.

```rust
/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}
```

The most important topic to discuss for this type is the following method:

```rust
/// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved
/// update current and return a copy.
pub fn update_highscore(
    current_highscore: &mut Option<HighScore>,
    new_high_score: Option<HighScore>,
) -> Result<Option<HighScore>, Errors> {

    // This match will stop assigning the new highscore if one has not been achieved.
    match (&current_highscore, &new_high_score) {
        (_, None) => { 
            // No highscore was achieved by the character.
            return Ok(None); 
        },
        (None, Some(_)) => {},
        (Some(old_high_score), Some(new_high_score)) => {
            // A character achieved a highscore
            // there is a highscore recorded.
            // makes a comparison and maintain the highest.
            if old_high_score > new_high_score {
                return Ok(None);
            }
        },
    }

    // assign the new highscore
    *current_highscore = new_high_score.clone();

    return Ok(new_high_score);
}
```

Both player and character store an `Option<HighScore>`. So, instead of making functions that pass `HighScore` as arguments we have just one that receives `Option<HighScore>` instead.

When a report is validated, a new highscore for the character may be achieved, so we check all the player's highscores, to confirm if a new highscore for the player was achieved. If this happened, we check if the player highscore is among the ranking of top highscores.

Notice how ranking is only calculated when players achieve their highest score. That saves a lot of computing.

So, `HighScore::update_highscore` receives the current highscore and the latest possible highscore. If latest is higher than the current, we update the current and return a copy.

There is also the possibility of any of these being `None`. Maybe no highscore was achieved. Maybe there were no highscores before this one. The function considers both cases.

#### Ranking

[top](#topics)

Ranking is stored as a vector of `HighScore`. The maximum number of elements stored is limited to reduce sorting costs.

```rust
/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}
```

When a player achieves a new `HighScore`, this function runs: 

```rust
pub fn check_highscore(
    &mut self, 
    high_score: &Option<HighScore>,
) -> bool {
    match high_score {
        None => { 
            // Player didn't achieve a high score.
            false
        },
        Some(high_score) => {
            log!("New High Score for this Player.");

            // Compiler will apply branchless optimization to all these if/else statements.
            if self.lowest_high_score.is_none() {
                // This is the first entry, so just include it.
                self.new_entry(high_score.clone());

                return true;
            } else {
                // This is not the first entry.
                // The list may be full or not.
                let ranking_is_full: bool = self.values.len() == self.max_size;

                if !ranking_is_full {
                    // If the list is not full, just include it.
                    self.new_entry(high_score.to_owned());

                    return true;
                } else {
                    // .unwrap will never panic because of the first "if" above. It is always Some.
                    // We are cloning because unwrap will take ownership of this mutable reference.
                    let lowest_high_score = self.lowest_high_score
                        .clone()
                        .unwrap();

                    if lowest_high_score < *high_score {
                        self.new_entry(high_score.clone());

                        return true;
                    }
                    
                    false
                }
            }
        }
    }
}
```

In summary, what this method does is:
 - If a new HighScore is **not** achieved, do nothing.
 - If the list is empty, just include the entry.
 - If the list is not full, just include the entry.
 - If the list is full, before including the entry, only include if the value is higher than the lowest 
entry in the list.

Each inclusion in the list will result in the list being sorted. Comparison with the lowest entry helps reduce computing costs.

---

Lesson 6 - Game Score :white_check_mark: ... **Done! Congratulations!**

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/lib.rs ---
use near_sdk::{
    AccountId,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        LookupMap, 
    },
    env,
    log,
    near_bindgen,
};

mod model;

use crate::{
    model::{
        character::{
            Character,
            Class,
            Name as CharacterName,
        },
        Errors,
        Chapter,
        player_view,
        Player,
        score::{
            HighScore,
            Score,
            Ranking,
        },
        StorageKey,
    }
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    players: LookupMap<AccountId, Player>,

    ranking: Ranking,
}

// initialize colletions
impl Default for Contract {
    fn default() -> Self {
        let players: LookupMap<AccountId, Player> = LookupMap::new(StorageKey::Players);
        let ranking: Ranking = Ranking::default();

        Contract{
            players,
            ranking,
        }
    }
}

#[near_bindgen]
impl Contract{

    fn is_owner() -> bool {
        let predecessor_account_id: AccountId =  env::predecessor_account_id();
        let current_account_id: AccountId = env::current_account_id();

        predecessor_account_id == current_account_id
    }

    /// Guarantees that the user is not registered.
    fn assert_user_not_registered(&self) -> Result<(), Errors> {
        let predecessor_account_id = env::predecessor_account_id();

        if self.players.contains_key(&predecessor_account_id) ||  Self::is_owner() {
            // Panic because account already exists.
            return Err(Errors::AccountIsAlreadyRegistered(predecessor_account_id));
        }

        Ok(())
    }

    fn assert_user_registered(&self) -> Result<(), Errors> {
        if Self::is_owner(){
            return Ok(());
        }

        let predecessor_account_id = env::predecessor_account_id();

        if ! self.players.contains_key(&predecessor_account_id) {
            // Panic because account already exists.
            return Err(Errors::AccountIsNotRegistered(predecessor_account_id));
        }

        Ok(())
    }

    /// Update the player state.
    /// 
    /// This is going to be replaced by direct pointer access later.
    /// 
    fn save_player(&mut self, player: &Player) -> Result<(), Errors>{
        self.assert_user_registered()?;

        let predecessor_account_id: AccountId = env::predecessor_account_id();

        self.players.insert(&predecessor_account_id, player).unwrap();

        Ok(())
    }

    /// If user does not exist in the database. Ask for registry.
    fn load_player(&self) -> Result<Player, Errors>{
        let predecessor_account_id = env::predecessor_account_id();

        match self.players.get(&predecessor_account_id){
            None => Err(Errors::UserNotRegistered(predecessor_account_id)),
            Some(player) => Ok(player),
        }
    }

    

    /// A user that is not registered can't access the smart contract.
    /// 
    /// Add the predecessor to the smart contract.
    #[handle_result]
    pub fn register_user(&mut self) -> Result<(), Errors> {
        log!("Register User function called.");
        self.assert_user_not_registered()?;

        // While technically we are calling env::predecessor_account_id twice, LLVM compiler will optimize it away.
        // We can write both low level and high level code efficiently in rust. 
        // We just need to decide when a function represents a low level or high level need.
        let predecessor_account_id = env::predecessor_account_id();
        let player = Player::default();
        assert!(self.players.insert(&predecessor_account_id, &player).is_none(), "Smart contract error: Expected None after asserting user is not registered. Got some.");

        log!("User successfully registered.");
        
        Ok(())
    }

    /// User must be registered before using this.
    /// 
    /// Create a character with given name and class.
    /// 
    /// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
    /// 
    #[handle_result]
    pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
        log!("Create Character function called.");
        
        let class: Class = Class::new(&class)?;
        let character: Character = Character::new(name, class)?;
        let mut player: Player = self.load_player()?;

        player.assign_character(character)?;

        self.save_player(&player)?;

        log!("Character successfully created.");

        Ok(())
    }

    /// Loads and returns an instance of player.
    #[handle_result]
    pub fn check_status(&self) -> Result<player_view, Errors>{
        log!("Check Player Status function called.");

        Self::load_player(&self)?
            .get_view()
    }

    /// Load a character with the given name and return it.
    #[handle_result]
    pub fn load_character(&self, name: String) -> Result<Character, Errors> {
        let player = self.load_player()?;

        player.load_character(name)
    }

    /// Get current ranking.
    pub fn get_ranking(&self) -> Ranking {
        self.ranking.clone()
    }

    /// Get information about the next match.
    #[handle_result]
    pub fn start_match(&mut self) -> Result<Chapter, Errors> {
        log!("Start Match function called.");

        let mut player = self
            .load_player()?;

        let chapter = player.start_match();

        self.save_player(&player)?;

        Ok(chapter)
    }

    /// Report the match finished.
    /// 
    /// Some validations should be done about it.
    /// 
    /// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
    /// 
    /// A report should be a replay of the entire match. Including the AI of non-player-characters.
    /// 
    #[handle_result]
    pub fn report_match(
        &mut self, 
        character: CharacterName, 
        score: Score, 
        // validation_report: ValidationReport,
    ) -> Result<bool, Errors>{
        log!("Report Match function called.");

        let mut player: Player = self.load_player()?;

        let high_score: Option<HighScore> = player.report_match(character, score)?;

        self.save_player(&player)?;

        // So, if player didn't achieve a highscore of their own, it won't checked in the rankings. 
        // This is to stop a few players from overwhelming the ranking with their name.
        Ok(self.ranking.check_highscore(&high_score))
    }

    /// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
    #[handle_result]
    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors> {
        if env::signer_account_id() != env::current_account_id() {
            return Result::Err(Errors::OwnerOnly);
        }

        self.ranking.set_max_highscore_players(max_size)?;

        Ok(())
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/mod.rs ---
mod reward;

use near_sdk::{
    borsh,
    borsh::{ BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub use reward::ChapterReward;
use crate::model::{
    character::{
        Character,
        EXP,
    },
    score::Score,
    Errors,
};

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}

impl Default for Chapter{
    fn default() -> Self {
        Chapter::Chapter1(None)
    }
}

impl Chapter {
    fn get_time(&self) -> Option<u64> {
        match self{
            Chapter::Chapter1(value) => value.clone(),
            Chapter::Chapter2(value) => value.clone(),
            Chapter::Chapter3(value) => value.clone(),
        }
    }

    /// Used by Self::clear_time and Self::start_time. Change the value of the last time a match was started.
    fn set_time(&mut self, value: Option<u64>) {
        *self = match self{
            Chapter::Chapter1(_) => Self::Chapter1(value),
            Chapter::Chapter2(_) => Self::Chapter2(value),
            Chapter::Chapter3(_) => Self::Chapter3(value),
        };
    }

    /// Used after reporting. Means that no match is going at the moment.
    fn stop_time(&mut self) {
        self.set_time(None);
    }

    /// Used when loading a chapter. Get the latest time for starting the match. Report can't have a longer time than this.
    fn start_time(&mut self) {
        let current_time_ms: u64 = env::block_timestamp_ms();

        self.set_time(Some(current_time_ms));
    }

    /// Returns the multipliers for each chapter reward.
    pub fn check_reward(&self) -> ChapterReward {
        match self {
            Chapter::Chapter1(_) => {
                ChapterReward::new(
                    10, 
                    0.9, 
                    1, 
                    0.9,
                )
            },
            Chapter::Chapter2(_) => {
                ChapterReward::new(
                    100, 
                    0.9, 
                    5, 
                    0.9,
                )
            },
            Chapter::Chapter3(_) => {
                ChapterReward::new(
                    1000, 
                    0.9, 
                    10, 
                    0.9,
                )
            },
        }
    }

    
    /// Doesn't do anything in this tutorial.
    /// 
    /// The idea is that the user will send a report that includes everything that happened during the match.
    /// 
    /// The contract guarantees that the user didn't attempt to cheat at the game.
    /// 
    fn validate_get_reward(
        &self,
        _character: &Character,
        _score: &Score,
        // Validation_report: EncryptedValidationType,
    ) -> Result<ChapterReward, Errors> {

        if self.get_time().is_none(){
            return Err(Errors::ChapterNotStarted);
        }

        // Do something with the validation_report and given character and score.
        // validation_report should be a block of bytes signed with a public key owned by the smart contract.
        // The report should have information about everything that happened in the match.
        // Since the gameplay happens in the browser. It's very easy for the user to cheat and send a fake report.
        // So maybe the report should be an entire replay of the match.
        //
        // One useful check that could be done is making sure that the match between start and report can't

        
        Result::Ok(
            Self::check_reward(&self)
        )
    }

    /// Can only be called after the timer has started (with Self::start_match). Receives a chapter report and validates it before returning rewards.
    pub fn validate_match(
        &mut self, 
        character: &Character, 
        score: &Score,
        // Validation_report: ValidationReport,
    ) -> Result<EXP, Errors> {
        let reward = self.validate_get_reward(character, score)?;

        self.stop_time();
        Ok(reward.compute_reward(character.get_level(), score))
    }

    /// Go to the next chapter and stop the timer.
    pub fn next_match(&mut self) {
        *self = match self {
            Chapter::Chapter1(_) => Chapter::Chapter2(None),
            Chapter::Chapter2(_) => Chapter::Chapter3(None),
            Chapter::Chapter3(_) => Chapter::Chapter1(None),
        };
    }

    /// Start match timer. Needed for validation.
    pub fn start_match(&mut self) -> Self {
        self.start_time();

        self.clone()
    }

}

#[cfg(test)]
mod tests{
    use super::Chapter;

    fn new_chapter_1() -> Chapter{
        Chapter::default()
    }

    fn new_chapter_2() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter
    }

    fn new_chapter_3() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter.next_match();
        chapter
    }

    fn assert_chapter_number(chapter: &Chapter, number: u8) {
        if number < 1 && number > 3 {
            panic!("Invalid argument for test. Chapter can only be 1, 2 or 3.")
        }

        match chapter {
            Chapter::Chapter1(_) => assert!(number == 1),
            Chapter::Chapter2(_) => assert!(number == 2),
            Chapter::Chapter3(_) => assert!(number == 3),
        }
    }

    #[test]
    fn chapter_next_chapter() {
        let (chapter1, chapter2, chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        assert_chapter_number(&chapter1, 1);
        assert_chapter_number(&chapter2, 2);
        assert_chapter_number(&chapter3, 3);
    }

    #[test]
    fn chapter_clear_timer() {
        
        let (mut chapter1, mut chapter2, mut chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        chapter1.start_match();
        chapter2.start_match();
        chapter3.start_match();

        assert!(chapter1.get_time().is_some());
        assert!(chapter2.get_time().is_some());
        assert!(chapter3.get_time().is_some());

        chapter1.stop_time();
        chapter2.stop_time();
        chapter3.stop_time();

        assert!(chapter1.get_time().is_none());
        assert!(chapter2.get_time().is_none());
        assert!(chapter3.get_time().is_none());
    }

}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/reward.rs ---
use crate::model::{
    character::{
        EXP,
        Level,
    },
    score::Score,
};

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}

impl ChapterReward{
    
    /// Returns the proportion of extra EXP based on level difference.
    /// 
    /// Max difference is 5.
    /// 
    /// If level is higher than expected, receive less EXP.
    /// 
    /// If level is lower, receive more EXP.
    /// 
    fn compute_level_multiplier(
        mut multiplier: f32, 
        level: Level, 
        expected_level: Level,
    ) -> f32{
        let mut difference = level as f32 - expected_level as f32;

        let result: f32 = 1.0;

        // As example, if proportion is 0.9, having a lower level will multiply the bonus by 1.1 per level (up to 5)
        // 0.8 would multiply the bonus by 1.2/level (up to 5).
        if difference < 0. {
            multiplier = 2. - multiplier;
            difference *= -1.;
        }

        if difference >= 5. {
            return result * multiplier * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 4. {
            return result * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 3. {
            return result * multiplier * multiplier * multiplier
        }
        if difference >= 2. {
            return result * multiplier * multiplier
        }

        if difference >= 1. {
            return result * multiplier
        }

        result
    }

    pub fn new(
        exp: EXP,
        score_multiplier: f32,
        expected_level: Level,
        level_multiplier: f32,
    ) -> Self {

        ChapterReward { 
            exp, 
            score_multiplier, 
            expected_level, 
            level_multiplier,
        }
    }

    pub fn compute_reward(
        &self, 
        character_level: Level,
        score: &Score,
    ) -> EXP {
        let exp = self.exp;
        let score_bonus = self.score_multiplier * *score as f32;

        let expected_level = self.expected_level;
        let level_multiplier = self.level_multiplier;

        let computed_multiplier = Self::compute_level_multiplier(
            level_multiplier, 
            character_level,
            expected_level,
        );

        ((exp as f32 + score_bonus as f32) * computed_multiplier) as EXP
    }
}

#[cfg(test)]
mod tests{
    use super::ChapterReward;

    fn setup_test() -> ChapterReward {
        let (
            exp,
            score_multiplier,
            expected_level,
            level_multiplier,
        ) = (10, 0.8, 10, 0.9);

        ChapterReward::new(exp, score_multiplier, expected_level, level_multiplier)
    }

    #[test]
    fn chapter_reward_new(){
        
        let chapter_reward: ChapterReward = setup_test();

        assert_eq!(chapter_reward.exp, 10);
        assert_eq!(chapter_reward.score_multiplier, 0.8);
        assert_eq!(chapter_reward.expected_level, 10);
        assert_eq!(chapter_reward.level_multiplier, 0.9);
    }

    #[test]
    fn chapter_reward_compute_reward(){
        let chapter_reward: ChapterReward = setup_test();

        // Lower level means more exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(9, &100), 99);
        assert_eq!(chapter_reward.compute_reward(8, &100), 108);
        assert_eq!(chapter_reward.compute_reward(7, &100), 119);
        assert_eq!(chapter_reward.compute_reward(6, &100), 131);
        assert_eq!(chapter_reward.compute_reward(5, &100), 144);
        assert_eq!(chapter_reward.compute_reward(4, &100), 144);
        assert_eq!(chapter_reward.compute_reward(3, &100), 144);
        assert_eq!(chapter_reward.compute_reward(2, &100), 144);

        // Higher level means less exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(11, &100), 81);
        assert_eq!(chapter_reward.compute_reward(12, &100), 72);
        assert_eq!(chapter_reward.compute_reward(13, &100), 65);
        assert_eq!(chapter_reward.compute_reward(14, &100), 59);
        assert_eq!(chapter_reward.compute_reward(15, &100), 53);
        assert_eq!(chapter_reward.compute_reward(16, &100), 53);
        assert_eq!(chapter_reward.compute_reward(17, &100), 53);
        assert_eq!(chapter_reward.compute_reward(18, &100), 53);
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/class.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use near_sdk::env;

use crate::model::{
    character::Stats,
    Errors,
};

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}

impl Class {
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }

    /// Return base stats for given class, used by Character;
    pub fn get_stats(&self) -> Stats {

        let (
            dexterity_base,
            strength_base,
            inteligence_base,
            strength_rate,
            dexterity_rate,
            inteligence_rate,
        ) = match self{
            Class::Druid => (
                5,
                7,
                7,
                1,
                2,
                2,
            ),
            Class::Priest => (
                4,
                5,
                7,
                1,
                2,
                1,
            ),
            Class::Rogue => (
                8,
                4,
                4,
                2,
                1,
                1,
            ),
            Class::Warrior => (
                4,
                8,
                4,
                1,
                2,
                1,
            ),
        };

        Stats::new(
            dexterity_base,
            dexterity_rate,
            strength_base,
            strength_rate,
            inteligence_base,
            inteligence_rate,
        )
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/mod.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self,},
    env,
    serde::{ Deserialize, Serialize },
};

mod class;
mod stats;

pub(crate) use class::Class;
pub(crate) use stats::Stats;

use crate::model::{
    Errors,
    score::{
        Score,
        // HighScore,
    },
};

use super::score::HighScore;

pub type Name = String;
pub type EXP = u32;
pub type Level = u32;

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}

impl Character {

    fn update_level(&mut self) {
        let level: u32 = self.level;

        // just an exponential function to work as an example of how level scaling could work.
        // It gets exponentially higher each level. Level 1 requirement is 100.
        let next_level: u32 = 100 + level * 10 + 3 * level * level;

        if self.xp >= next_level { 
            self.level += 1;
            self.xp -= next_level;
            self.stats.update(self.level);
        }
    }

    /// Create a new character to be used by the player.
    pub fn new(name: Name, class: Class) -> Result<Character, Errors> {
        let level: Level = 1;
        let xp: EXP = 0;
        let stats: Stats = Stats::from(&class);
        let high_score: Score = 0;

        let first_character = &name[0..1];
        match first_character{
            "" => Err(Errors::InvalidCharacterName(name)),
            _ => Ok(Character {
                name,
                class,
                level,
                xp,
                stats,
                high_score,
            })
        }

        
    }

    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    pub fn get_class(&self) -> Class {
        self.class.clone()
    }

    pub fn get_level(&self) -> Level {
        self.level.clone()
    }

    pub fn get_xp(&self) -> EXP {
        self.xp.clone()
    }

    pub fn get_stats(&self) -> Stats {
        self.stats.clone()
    }

    pub fn get_high_score(&self) -> Score {
        self.high_score.clone()
    }

    pub fn reward_exp(&mut self, exp: EXP) {
        self.xp += exp;
        self.update_level();
    }

    /// Makes a comparison with the highscore. 
    /// 
    /// 
    /// If a highscore is achieved, return it.
    /// 
    /// Else return None.
    /// 
    pub fn check_highscore(&mut self, score: Score) -> Option<HighScore> {

        if score > self.high_score {
            self.high_score = score;
            let player = env::predecessor_account_id();

            let high_score: HighScore = HighScore::new(score, &self, player);

            return Some(high_score);
        }

        None
    }

}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/stats.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use crate::model::character::Class;

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}

impl Stats{
    pub fn new(
        dexterity_base: u32,
        dexterity_rate: u32,
        strength_base: u32,
        strength_rate: u32,
        intelligence_base: u32,
        intelligence_rate: u32,
    ) -> Self {
        let (dexterity, strength, intelligence) = (dexterity_base, strength_base, intelligence_base);

        Stats { 
            dexterity, 
            dexterity_rate,
            dexterity_base,
            strength,
            strength_rate,
            strength_base,
            intelligence,
            intelligence_rate,
            intelligence_base,
        }
    }

    pub fn update(&mut self, level: u32) {
        // dexterity, strength, inteligence
        // all these temporary variables won't exist in the machine code.
        // LLVM compiler optimizes these things away.
        // So don't worry about making your code more readable.

        let dexterity: u32 = self.dexterity_base + self.dexterity_rate * level;
        let strength: u32 = self.strength_base + self.strength_rate * level;
        let inteligence: u32 = self.intelligence_base + self.intelligence_rate * level;

        self.dexterity = dexterity;
        self.strength = strength;
        self.intelligence = inteligence;
    }
}

impl From<&Class> for Stats {
    fn from(class: &Class) -> Stats {
        class.get_stats()
    }
}

impl From<Class> for Stats {
    fn from(class: Class) -> Stats {
        Stats::from(&class)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/errors.rs ---
use near_sdk::{
    AccountId,
    borsh::{ self, BorshSerialize },
    FunctionError,
};

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/mod.rs ---

mod player;
mod chapter;
mod errors;
mod storage;

pub mod character;
pub mod score;

pub(crate) use player::Player;
pub(crate) use player::View as player_view;
pub(crate) use errors::Errors;
pub(crate) use chapter::Chapter;
pub(crate) use storage::StorageKey;

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/player/mod.rs ---
use near_sdk::{
    AccountId,
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    collections::{
        LookupMap,
        UnorderedSet,
    },
    env,
};

mod view;

use crate::model::{
    chapter::Chapter,
    character,
    character::Character,
    score::HighScore,
    score::Score,
    Errors,
};

use crate::StorageKey;

pub type Name = AccountId;

pub use view::View;

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}

// Initial state of the player.
impl Default for Player{
    fn default() -> Self {
        let name = env::predecessor_account_id();

        let high_score = None;
        let characters = 
            LookupMap::new(
                StorageKey::Characters(name.clone())
            );

        let character_names: UnorderedSet<character::Name> = UnorderedSet::new(
            StorageKey::CharacterNames(name.clone())
        );

        let latest_chapter: Chapter = Chapter::default();
        
        Player{
            name,
            high_score,
            characters,
            character_names,
            latest_chapter,
        }
    }
}

impl Player{
    /// Will panic if a character with that name already exists.
    fn assert_character_doesnt_exist(&self, character_name: &character::Name) -> Result<(), Errors> {
        if self.characters.contains_key(character_name) {
            return Err(Errors::CharacterAlreadyExists(character_name.clone()));
        }

        Ok(())
    }

    fn assert_character_exists(&self, character_name: &character::Name) -> Result<(), Errors> {
        if !self.characters.contains_key(character_name) {
            return Err(Errors::CharacterNotFound(character_name.clone()));
        }

        Ok(())
    }

    /// Returns the character state. Should be replaced by pointer access later.
    pub fn load_character(&self, name: character::Name) -> Result<Character, Errors> {
        match self.characters.get(&name){
            None => Err(Errors::CharacterNotFound(name.to_string())),
            Some(character) => Ok(character),
        }
    }

    /// This should be replaced by pointer access later.
    fn save_character(&mut self, character: &Character) -> Result<(), Errors> {
        let character_name = character.get_name();

        self.assert_character_exists(&character_name)?;

        self.characters.insert(&character_name, character).unwrap();

        Ok(())
    }

    pub fn assign_character(&mut self, character: Character) -> Result<(), Errors> {
        let character_name = character.get_name();
        
        self.assert_character_doesnt_exist(&character_name)?;

        // If this error happens. It's an unexpected server error. That means that something else is going wrong.
        // It should be reported.
        assert!(self.characters.insert(&character_name, &character).is_none(), "Server error: Character doesn't exist. Please Report.");
        self.character_names.insert(&character_name);

        Ok(())
    }

    /// Move to the next chapter.
    pub fn next_match(&mut self){
        self.latest_chapter.next_match();
    }

    /// Start timer and return the current chapter.
    pub fn start_match(&mut self) -> Chapter {
        self.latest_chapter.start_match()
    }

    /// End the timer and reward the character. Then update highscores.
    /// 
    /// Returns a HighScore if it was achieved,
    pub fn report_match(
        &mut self,
        character: String,
        score: Score,
        // validation_report: ValidationReport,
    ) -> Result<Option<HighScore>, Errors> {
        let mut character: Character = self.load_character(character)?;

        let exp: character::EXP = self.latest_chapter.validate_match(
            &character, 
            &score,
        )?;

        let new_character_highscore: Option<HighScore> = character.check_highscore(score);

        let high_score: Option<HighScore> = HighScore::update_highscore(
            &mut self.high_score, 
            new_character_highscore,
        );

        character.reward_exp(exp);
        self.save_character(&character)?;

        Ok(high_score)
    }

    /// Get characters' name.
    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    /// Returns information about this player as json.
    /// 
    /// LookupMap and UnorderedSet can't be serialized into json. We create a View with serializable data types and return it instead.
    pub fn get_view(&self) -> Result<View, Errors> {
        let name: Name = self.name.clone();
        let high_score: Option<HighScore> = self.high_score.clone();
        let mut characters: Vec<Character> = Vec::with_capacity(self.character_names.len() as usize);

        for character_name in self.character_names.iter() {
            let character: Character = self.load_character(character_name)?;
            characters.push(character);
        };

        Ok(View { name, high_score, characters })
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/player/view.rs ---
//! When a user loads a player type. This type is what they will receive.
//! 
//! 

use near_sdk::{
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    player,
    score::HighScore,
};

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/high_score.rs ---
use near_sdk::{
    AccountId,
    borsh::{ BorshDeserialize, BorshSerialize, self },
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    score::Score,
};

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}

// Used for ordering HighScores within a Vec
impl Ord for HighScore {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.score.cmp(&other.score)
    }
}

// Required by Ord.
impl PartialOrd for HighScore {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

// Used for partial comparisons between HighScores. Required by Ord and Eq.
//
// A = B sometimes doesn't mean B = A.
impl PartialEq for HighScore {
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

// Used for comparisons between HighScores. Required by Ord.
//
// This implies that A = B means B = A.
impl Eq for HighScore {}

impl HighScore{
    /// Returns a new instance of Highscore.
    pub fn new(
        score: Score,
        character: &Character,
        player: AccountId,
    ) -> Self {

        HighScore{
            score,
            character: character.clone(),
            player,
        }
    }

    /// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
    pub fn update_highscore(
        current_highscore: &mut Option<HighScore>,
        new_high_score: Option<HighScore>,
    ) -> Option<HighScore> {

        // This match will stop assigning the new highscore if one has not been achieved.
        match (&current_highscore, &new_high_score) {
            (_, None) => { 
                // No highscore was achieved by the character.
                return None; 
            },
            (None, Some(_)) => {},
            (Some(old_high_score), Some(new_high_score)) => {
                // A character achieved a highscore
                // there is a highscore recorded.
                // makes a comparison and maintain the highest.
                if old_high_score > new_high_score {
                    return None;
                }
            },
        }

        // assign the new highscore
        *current_highscore = new_high_score.clone();

        return new_high_score;
    }

    /// Returns score achieved.
    pub fn get_score(&self) -> Score {
        self.score
    }

    /// Returns character for this highscore.
    pub fn get_character(&self) -> Character {
        self.character.clone()
    }

}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/mod.rs ---
mod high_score;
mod ranking;

pub(crate) use high_score::HighScore;
pub(crate) use ranking::Ranking;
pub type Score = u32;

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/ranking.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self},
    env,
    log, 
    serde::{Deserialize, Serialize},
};

use crate::model::{
    score::HighScore,
    Errors,
    // StorageKey,
};

// Just for this exampÄºe, we just want max 10 values in the ranking.
// const RANKSIZE: usize = 10;

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}

impl Serialize for Ranking {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: near_sdk::serde::Serializer {

        serializer.collect_seq(self.values.iter().map(|x| x))
    }
}

impl Default for Ranking{
    fn default() -> Self {
        // let values: Vec<HighScore> = Vector::new(StorageKey::Ranking);
        let max_size: usize = 10;
        let values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = None;

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Clone for Ranking{
    fn clone(&self) -> Self {
        let max_size: usize = self.max_size.clone();
        let mut values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = self.lowest_high_score.clone();
        
        for value in self.values.iter(){
            values.push(value.clone());
        }

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Ranking{

    fn sort_and_resize(&mut self) {
        self.values.sort();
        self.values.truncate(self.max_size);
    }

    /// This is only called when the ranking list is full.
    /// Add the entry to the list, sort it, then remove all the excess elements.
    /// Finally, set the lowest high score value to the element at the end of the list.
    fn new_entry(&mut self, entry: HighScore) {
        self.values.push(entry);

        // Sort the highscores and resize it to RANKSIZE (If it has more values than RANKSIZE)
        self.sort_and_resize();

        let lowest_high_score = self.values.last();

        match lowest_high_score {
            None => env::panic_str("Smart contract implementation error. This should never happen. Called Ranking::new_entry and got a None."),
            Some(lowest) => {
                self.lowest_high_score = Some(lowest.clone());
            }
        }
    }

    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>{
        let limit = 1000;

        if max_size > limit {
            return Err(Errors::ExcessiveMaxRankingPlayers(limit, max_size));
        }

        self.max_size = max_size;

        Ok(())
    }

    pub fn check_highscore(
        &mut self, 
        high_score: &Option<HighScore>,
    ) -> bool {
        match high_score {
            None => { 
                // Player didn't achieve a high score.
                false
            },
            Some(high_score) => {
                log!("New High Score for this Player.");

                // Compiler will apply branchless optimization to all these if/else statements.
                if self.lowest_high_score.is_none() {
                    // This is the first entry, so just include it.
                    self.new_entry(high_score.clone());

                    return true;
                } else {
                    // This is not the first entry.
                    // The list may be full or not.
                    let ranking_is_full: bool = self.values.len() == self.max_size;

                    if !ranking_is_full {
                        // If the list is not full, just include it.
                        self.new_entry(high_score.to_owned());

                        return true;
                    } else {
                        // .unwrap will never panic because of the first "if" above. It is always Some.
                        // We are cloning because unwrap will take ownership of this mutable reference.
                        let lowest_high_score = self.lowest_high_score
                            .clone()
                            .unwrap();

                        if lowest_high_score < *high_score {
                            self.new_entry(high_score.clone());

                            return true;
                        }
                        
                        false
                    }
                }
            }
        }
    }

}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/storage.rs ---
use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshSerialize},
};

/// Keys used for storing values in trie. Required for collections like UnorderedSet and LookupMap.
/// 
/// We have to make sure that each collection has a unique prefix.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    // Holds no argument because only one LookupMap for Players in the entire smart contract.
    Players,
    
    // Holds an account Id because Each player has one UnorderedSet for the characters. The AccountId is used to tell these types apart.
    Characters(AccountId),

    // Same for character names. It's an UnorderedSet that is different between each player. 
    // So we use the AccountId (unique for each player) within the tuple.
    CharacterNames(AccountId),
}
'''
'''--- EN/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- EN/static/tutorials/cargo.md ---
# IntroduÃ§Ã£o a Cargo

Cargo Ã© a ferramenta que usamos para administrar nossos projetos da linguagem rust. DocumentaÃ§Ã£o completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que Ã© crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informaÃ§Ãµes meta sobre este diretÃ³rio. CaracterÃ­sticas como nome e versÃ£o, mas tambÃ©m configuraÃ§Ãµes sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrÃ£o. Identico ao Cargo.toml da liÃ§Ã£o 1.](../images/cargo.png)

NÃ£o Ã© necessÃ¡rio saber tudo sobre essas configuraÃ§Ãµes. As configuraÃ§Ãµes que precisaremos alterar sÃ£o ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tÃ³picos principais:
 - **package**: ConfiguraÃ§Ãµes sobre a crate. Nome, versÃ£o, licensa, ediÃ§Ã£o do Rust, etc; 
 - **lib**: Isso determina que esta crate nÃ£o Ã© um executÃ¡vel. E sim Ã© uma biblioteca que serÃ¡ acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configuraÃ§Ãµes.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrÃ£o Ã© vindo do site "crates.io", mas podemos tambÃ©m incluir crates locais; podemos incluir atravÃ©s de um link github, etc.
 - **profile.release**: ConfiguraÃ§Ã£o para projetos compilados para "release". NÃ£o Ã© necessÃ¡rio entender cada instruÃ§Ã£o. Simplesmente fala para o compilador tentar optimizar o mÃ¡ximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que Ã© crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretÃ³rio com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretÃ³rio "target" com o arquivo compilado. Mas se criarmos um workspace, que Ã© um conjunto de vÃ¡rias crates compartilhando um "Cargo.toml", os arquivos compilados sÃ£o todos agrupados na mesma pasta. Para mais detalhes, cheque a liÃ§Ã£o sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

DependÃªncias como ```near_sdk``` sÃ£o baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condiÃ§Ã£o**: Deve ser open-source.

O site intencionalmente nÃ£o disponibiliza opÃ§Ã£o para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versÃ£o do registry usando o comando "yank", projetos nÃ£o poderÃ£o mais baixar a versÃ£o, mas ainda continuarÃ£o funcionando se tiverem a versÃ£o baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

SÃ³ isso. Existem vÃ¡rios outros comandos que podemos executar com cargo. Mas nÃ£o sÃ£o necessÃ¡rios para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilaÃ§Ã£o feitas para auxiliar o debug e otimiza o cÃ³digo para produÃ§Ã£o
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estarÃ¡ no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instruÃ§Ã£o irÃ¡ resultar em **erro** se nÃ£o instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instruÃ§Ã£o (apenas uma vez para cada instalaÃ§Ã£o de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma funÃ§Ã£o possui o marcador ```#[test]```, essa funÃ§Ã£o serÃ¡ executada.

Testes de unidade simplesmente procuram por situaÃ§Ãµes de pÃ¢nico. Se um pÃ¢nico inesperado acontece, ou um pÃ¢nico esperado nÃ£o acontece, o teste falha.

Macros como panic, assert e assert_eq sÃ£o usados para garantir nossas condiÃ§Ãµes.
 - ```panic!("Mensagem");```: Causa pÃ¢nico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pÃ¢nico se a condiÃ§Ã£o for falsa. EstÃ¡ "garantindo" que a condiÃ§Ã£o serÃ¡ verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pÃ¢nico com a dada mensagem.

Exemplo de situaÃ§Ã£o em que nÃ£o esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 Ã© sempre igual a 2. EntÃ£o nunca haverÃ¡ panic.

Exemplo de situaÃ§Ã£o em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este Ã© um exemplo da "liÃ§Ã£o 4 - mÃ³dulos". A funÃ§Ã£o ```this_will_panic()``` Ã© uma funÃ§Ã£o que eu criei que sempre causa pÃ¢nico.

```#[should_panic]``` significa que o teste vai falhar se nÃ£o entrar em panic. ```expected``` especifica qual a mensagem de pÃ¢nico esperada.

Isso Ã© tudo sobre testes para contrato. Para simular a comunicaÃ§Ã£o entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma pÃ¡gina de web com a documentaÃ§Ã£o do projeto. Muito fÃ¡cil de compartilhar. A pagina de web estarÃ¡ no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
IrÃ¡ abrir a pagina de web no navegador padrÃ£o.

![](../images/cargodoc.png)

Clique em Contract para ver as funÃ§Ãµes implementadas:

![](../images/cargodoccontract.png)

ComentÃ¡rios com ```//``` nÃ£o aparecem na documentaÃ§Ã£o.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

'''
'''--- EN/static/tutorials/nearcli.md ---
# IntroduÃ§Ã£o a near-cli

Near CLI ("command line interface") Ã© a ferramenta que utilizamos para interagir com o protocolo blockchain. DocumentaÃ§Ã£o completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funÃ§Ãµes em contratos inteligentes de outras contas, criar chaves de acesso com certas permissÃµes, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas nÃ£o Ã© obrigatÃ³rio para que essa exista. Cada conta ou sub-conta NEAR sÃ³ pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissÃµes administrativas) de vÃ¡rias sub-contas.

Ou seja, quando precisarmos de implementar vÃ¡rios contratos, podemos distribui-los em uma hierarquia de diversas contas com maior seguranÃ§a. As subcontas sÃ³ precisam das permissÃµes necessÃ¡rias para seus objetivos. As subcontas sÃ³ precisam da quantidade de gas necessÃ¡rias para se manterem em operaÃ§Ã£o.

**gas**: Ã‰ NEAR gasto para computaÃ§Ã£o, armazenamento de dados, criaÃ§Ã£o de contas, etc. A cada clock de computaÃ§Ã£o, uma fraÃ§Ã£o de NEAR Ã© consumida da conta. As mÃ¡quinas que mantÃ©m nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** Ã© consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando InicializaÃ§Ã£o Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar FunÃ§Ãµes de Contrato](#executando-funÃ§Ãµes-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando Ã  plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

NÃ£o Ã© a nossa mÃ¡quina que executa as funÃ§Ãµes de contrato descentralizadas. A nossa conta na blockchain que faz isso. NÃ³s conectamos a uma conta testnet com este comando.

**testnet**: Ã© uma plataforma de teste NEAR. Os tokens nÃ£o tem valor e nÃ£o Ã© possivel comercializÃ¡-los. A plataforma oficial Ã© a **mainnet**. Garanta que nÃ£o hÃ¡ riscos no contrato antes de implementar para produÃ§Ã£o.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. Ã‰ informaÃ§Ã£o pÃºblica.

![Imagem de terminal apÃ³s o uso do comando acima.](../images/nearstate.png)

Lembrar que esta Ã© uma conta **testnet**. NÃ£o Ã© dinheiro de verdade. Os atributos que conseguimos sÃ£o estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10Â²â´ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de cÃ³digo for uma sequÃªncia de "1", entÃ£o nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informaÃ§Ãµes sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviarÃ¡ 10 NEAR para a subconta;

Para criar uma conta de topo nÃ­vel, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

ApÃ³s compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/EN/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato serÃ¡ a trait ```Default``` que implementamos no cÃ³digo rust. Essa trait nÃ£o recebe parÃ¢metros para inicializaÃ§Ã£o. Se quisermos usar um construtor com parÃ¢metros de inicializaÃ§Ã£o, precisamos de seguir dois passos:

O primeiro passo Ã© declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da funÃ§Ã£o ```new``` nÃ£o Ã© obrigatÃ³rio. Mas Ã© convenÃ§Ã£o criar construtores com este nome.

O segundo passo Ã© incluir os parÃ¢metros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a funÃ§Ã£o e argumentos, respectivamente.

O comando de implantaÃ§Ã£o poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicializaÃ§Ã£o sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` Ã© um requisito para o funcionamento do contrato, mesmo se nÃ£o pretendermos utilizÃ¡-la. Se a inicializaÃ§Ã£o com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pÃ¢nico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" sÃ£o descritos a seguir:

Na implementaÃ§Ã£o de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaraÃ§Ã£o de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funÃ§Ãµes do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funÃ§Ãµes de contrato:
 - **view**: NÃ£o realiza computaÃ§Ã£o e nÃ£o altera estado do contrato. NÃ£o consome gÃ¡s. Ou seja, Ã© de graÃ§a.
 - **call**: Todos os outros tipos de funÃ§Ã£o. Consomem gÃ¡s. Podem necessitar um pagamento. A implementaÃ§Ã£o da funÃ§Ã£o pode incluir outras restriÃ§Ãµes, como restriÃ§Ãµes de chave, restriÃ§Ãµes de usuÃ¡rio, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos sÃ£o publicos.

Se uma funÃ§Ã£o simplesmente retorna um valor armazenado no estado, entÃ£o pode ser uma funÃ§Ã£o view. FunÃ§Ãµes view nÃ£o consomem gÃ¡s, e nÃ£o precisam de pagamento.

FunÃ§Ãµes view nÃ£o podem realizar nenhum cÃ¡lculo, e nÃ£o podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo sÃ£o exemplos vÃ¡lidos para funÃ§Ãµes view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String nÃ£o implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicaÃ§Ã£o sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cÃ³pia desse tipo com o mÃ©todo ```clone()```. Se um tipo implementar Copy, a cÃ³pÃ­a serÃ¡ feita automaticamente quando necessÃ¡rio. A instruÃ§Ã£o seguinte para i32:

```rust
return self.counter;
```

Se counter nÃ£o implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereÃ§o de variÃ¡vel para outro lugar. Counter nÃ£o teria um valor, pois a "ownership" foi perdida. O compilador nÃ£o irÃ¡ permitir essa transferÃªncia.

O exemplo a seguir **nÃ£o** pode ser funÃ§Ã£o view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a funÃ§Ã£o simplesmente retorna um nÃºmero, Ã© ainda considerada computaÃ§Ã£o. Relembrando, funÃ§Ãµes view apenas retornam o valor de um estado do contrato (que Ã© informaÃ§Ã£o pÃºblica).

#### Executando uma funÃ§Ã£o view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de funÃ§Ã£o que nÃ£o Ã© ```view```, Ã© ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de funÃ§Ã£o ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "liÃ§Ã£o 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a funÃ§Ã£o da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento Ã© o nome da sub-conta a deletar. O segundo argumento Ã© o nome da conta que irÃ¡ receber todo o NEAR armazenado.

'''
'''--- EN/static/tutorials/rust.md ---
# InstalaÃ§Ã£o Rust

Este tutorial descreve a instalaÃ§Ã£o das ferramentas recomendadas para criaÃ§Ã£o de projetos NEAR em Rust.

 - [Scripts de InstalaÃ§Ã£o](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos vÃ¡rias ferramentas diferentes com uma Ãºnica linha de comando. Ã€s que destacaremos nesse tutorial sÃ£o: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o cÃ³digo rust para linguagem de mÃ¡quina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentaÃ§Ã£o, realizar testes de unidade, executar projeto como binÃ¡rio.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versÃµes. rustup controla estas versÃµes.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

Ã‰ apenas uma analogia, existem algumas diferenÃ§as que serÃ£o encontradas em pratica.

## Scripts de instalaÃ§Ã£o
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalaÃ§Ã£o de Rust. A primeira Ã© recomendada para estudo, a segunda Ã© recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessÃ¡rias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositÃ³rio](https://github.com/rust-lang/rustlings) e siga as instruÃ§Ãµes de instalaÃ§Ã£o.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalaÃ§Ã£o
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissÃµes de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessÃ¡rias.

'''
'''--- EN/static/tutorials/setup-nearcli.md ---
# InstalaÃ§Ã£o NEAR CLI

NEAR CLI (NEAR Command Line Interface) Ã© utilizado para fazer login e interagir com contas NEAR.

Uma explicaÃ§Ã£o detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos sÃ£o descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descriÃ§Ãµes do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- ES/README.md ---
# Tutorial_NEAR_Rust

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

Tutorial em etapas para desenvolvimento de contratos inteligentes em rust. Neste conjunto de tutoriais serÃ£o discutidos todas as principais caracterÃ­sticas da linguagem, assim como seu uso na plataforma NEAR.

---

## Contato

[topo](#tutorial_near_rust)

Para dÃºvidas, reclamaÃ§Ãµes ou sugestÃµes, por favor me adicione no discord On0n0k1#3800. Se este tutorial facilitar a sua vida, considere comprar um cafÃ© para mim enviando uma fraÃ§Ã£o de NEAR para stiltztinkerstein.near .

---

## TÃ³picos

[topo](#tutorial_near_rust)

 - [O Que Ã© a linguagem Rust](#o-que-Ã©-a-linguagem-rust)
 - [Usos da linguagem Rust](#usos-da-linguagem-rust)
 - [Aprendendo a Linguagem Rust](#aprendendo-a-linguagem-rust)
 - [ComparaÃ§Ãµes com Javascript e Python](#compara%C3%A7%C3%B5es-com-javascript-e-python)
 - [InstalaÃ§Ã£o](#instala%C3%A7%C3%A3o)
 - [LiÃ§Ãµes](#li%C3%A7%C3%B5es)

---

## O que Ã© a linguagem Rust

[topo](#tutorial_near_rust)

De forma bem resumida, Ã© uma linguagem de programaÃ§Ã£o de baixo nÃ­vel com as seguintes caracterÃ­sticas:

 - ExecuÃ§Ã£o aproximadamente tÃ£o rÃ¡pida quanto linguagem c ou c++.
 - NÃ£o tem os riscos de vazamento de memÃ³ria que outras linguagens de baixo nÃ­vel possuem.
 - Ã‰ dificil de comeÃ§ar a aprender.
 - NÃ£o **usa** e nem **precisa** de coleta de lixo de memÃ³ria. Pois no periodo de compilaÃ§Ã£o, o compilador sabe exatamente quando variÃ¡veis sÃ£o criadas e liberadas.
 - Processamento em paralelo Ã© fÃ¡cil.
 - Processamento assÃ­ncrono Ã© de dificuldade semelhante a outras linguagens populares.
 - Muito mais simples organizaÃ§Ã£o de projeto e dependÃªncias do que python e javascript.
 - Ganhou repetidos anos consecutivos como a linguagem mais popular do stackoverflow.

---

## Usos da linguagem Rust

[topo](#tutorial_near_rust)

Um desenvolvedor Rust pode:

 - Criar apps decentralizados em plataformas web3 como NEAR.
 - Pode criar aplicativos que nÃ£o precisam de uma mÃ¡quina virtual para serem executados. Precisa do compilador Rust para compilar, mas nÃ£o precisa para executar.
 - Criar servidores compactos e rÃ¡pidos em conteineres docker.
 - Criar aplicaÃ§Ãµes potentes como funÃ§Ãµes lambda para serem implantados em servidores aws (web3 Ã© melhor porÃ©m).
 - Usar o linker para criar bibliotecas que podem ser usadas por um compilador como c.
 - Compilar bibliotecas que podem ser importadas em um browser javascript ou em um runtime nodejs com o formato WebAssembly.
 - Compilar bibliotecas potentes e eficientes para Python usando a crate PyO3.
 - Compilar cÃ³digo para dispositivos embarcados (embedded).
 - Competir em um mercado de trabalho que possui 1 ou 2 inscritos por vaga (incluindo internacional).

---

## Aprendendo a linguagem Rust
[topo](#tutorial_near_rust)

No meu ponto de vista, aprender a linguagem rust Ã© semelhante a idÃ©ia de domar um dragÃ£o em um mundo de fantasia. Ã‰ demorado, Ã© dificil, existem muitas alternativas diferentes e mais simples do que essa. Mas, se conseguir, vocÃª vai ter um terrÃ­vel dragÃ£o ao seu lado.

Existem estudos que destacaram que o tempo para escrever uma certa quantidade de linhas de cÃ³digo em linguagens de baixo nÃ­vel (como c) Ã© atÃ© 30 vezes mais devagar do que as de alto nÃ­vel (como python e javascript). Pela minha prÃ¡tica, Ã© mais demorado ainda para uma pessoa aprendendo Rust escrever cÃ³digo do que c. 

Mas, com prÃ¡tica, ficamos mais Ã¡geis em tudo. Com o tempo acostumamos com o que o compilador precisa e espera de nÃ³s. Podemos tambÃ©m configurar snippets para gerar cÃ³digos de "boilerplate" (forma) automaticamente. EntÃ£o, Ã© apenas uma questÃ£o de entendimento, memorizaÃ§Ã£o e paciÃªncia para o desenvolvedor. Houveram vezes em que eu escrevi 800 linhas de cÃ³digo Rust em 2 dias.

Quase sempre teremos que dar pausas para estudar o nosso mÃ©todo e garantir que estamos fazendo as decisÃµes corretas. PorÃ©m, cada tentativa seguinte serÃ¡ mais fÃ¡cil que a anterior.

---

## ComparaÃ§Ãµes com javascript e Python

[topo](#tutorial_near_rust)

PorÃ©m uma pessoa astuta perguntaria "Porque eu iria aprender uma linguagem dessas se eu ja posso resolver os mesmos problemas com as linguagens que sei?" . Ã‰ uma Ã³tima pergunta, se eu ja posso conseguir o resultado escrevendo algumas linhas de cÃ³digo em python no terminal, porque eu iria querer aprender Rust?

Facilidade de uso e resoluÃ§Ã£o de problemas. Este Ã© o foco principal dessas linguagens. Como conseguir a soluÃ§Ã£o para o nosso problema da forma mais simples possivel. Os processadores ficavam cada vez mais rÃ¡pido cada geraÃ§Ã£o, entÃ£o bastava comprar as geraÃ§Ãµes de hardware mais recentes.

PorÃ©m a lei de Moore nÃ£o se aplica mais. Os desenvolvedores estÃ£o precisando de algoritmos mais eficientes. Esta necessidade nos faz olhar para nossas linhas de cÃ³digo e perguntar "O que estÃ¡ instruÃ§Ã£o estÃ¡ fazendo exatamente?"

Quando escrevemos uma instruÃ§Ã£o em python "a = 3". A mÃ¡quina virtual python estÃ¡ criando um objeto numero, criando um ponteiro mutex que aponta para o numero, e associando "a" a este ponteiro. Por isso que python normalmente Ã© limitado a um core do processador. Quando tentamos aproveitar mais a capacidade de processamento de nossa mÃ¡quina, a complexidade de cÃ³digo em javascript e python cresce exponencialmente.

O foco da linguagem Rust nÃ£o Ã© o resultado final dessa execuÃ§Ã£o. E sim, o caminho que o processador e memÃ³ria levam atÃ© alcanÃ§ar este resultado. Um(a) desenvolvedor(a) rust experiente sabe olhar um bloco de cÃ³digo e dizer:
 - "Essa memÃ³ria vai ser liberada nessa linha de cÃ³digo";
 - "O processador irÃ¡ pedir pra liberar um espaÃ§o de memÃ³ria nessa linha e criar uma cÃ³pia dessa variÃ¡vel aqui.";
 - "Essa funÃ§Ã£o irÃ¡ pegar esse endereÃ§o emprestado, usar este valor nessa parte, e retornar o endereÃ§o para o dono ao fim.";

---

## InstalaÃ§Ã£o

[topo](#tutorial_near_rust)

Antes de comeÃ§armos, devemos realizar os seguintes passos:

 - Instalar [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/setup-nearcli.md) para interagir com a plataforma NEAR.
 - Instalar [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/rust.md) para compilar e testar os projetos.

---

## LiÃ§Ãµes

[topo](#tutorial_near_rust)

 - [LiÃ§Ã£o 1: Contratos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_1_contract)
 - [LiÃ§Ã£o 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_2_ownership)
 - [LiÃ§Ã£o 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_3_structs)
 - [LiÃ§Ã£o 4: MÃ³dulos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_4_modules)
 - [LicÃ£o 5: Usando Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_5_macro_usage)
 - [LiÃ§Ã£o 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums)
 - LiÃ§Ã£o 7: Traits
 - LiÃ§Ã£o 8: ColeÃ§Ãµes

'''
'''--- ES/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_1_contract/Readme.md ---
# LiÃ§Ã£o 1: Contrato

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Veja tambÃ©m:
 - Usos da [ferramenta cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/cargo.md).
 - Usos da [ferramenta near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/nearcli.md).

---

## TÃ³picos
 - [Estrutura de um contrato NEAR](#estrutura-de-um-contrato-near)
 - [Importar DependÃªncias](#importar-depend%C3%AAncias)
 - [Macro de AlocaÃ§Ã£o](#macro-de-aloca%C3%A7%C3%A3o)
 - [DeclaraÃ§Ã£o de Contrato](#declara%C3%A7%C3%A3o-de-contrato)
 - [DeclaraÃ§Ã£o de API do Contrato](#declara%C3%A7%C3%A3o-de-api-do-contrato)
 - [Testes de Unidade](#testes-de-unidade)

---

## Estrutura de um contrato NEAR
[topo](#li%C3%A7%C3%A3o-1-contrato)

Um contrato NEAR na linguagem Rust pode ser resumido aos seguintes passos:
 - Importar crates, mÃ³dulos e outras dependÃªncias necessÃ¡rias.
 - Macro de alocaÃ§Ã£o.
 - DeclaraÃ§Ã£o de contrato.
 - DeclaraÃ§Ã£o de api do contrato.
 - Testes de unidade.

O desenvolvedor Ã© livre para adicionar o que julgar necessÃ¡rio ao projeto. Os passos acima sÃ£o apenas para acelerar a memorizaÃ§Ã£o.

---

### Importar DependÃªncias
[topo](#li%C3%A7%C3%A3o-1-contrato)

Isto Ã© explicado em detalhes na "liÃ§Ã£o 4 - mÃ³dulos". SÃ³ precisamos saber sobre as diferenÃ§as entre mod e use. Por exemplo:

```rust
use near_sdk::near_bindgen;
```

Acessa a crate near_sdk e inclui o macro near_bindgen neste namespace. Sem isso, precisariamos escrever "near_sdk::near_bindgen" todas as vezes que precisarmos deste elemento. Mas agora podemos simplesmente escrever "near_bindgen".

Por outro lado, a instruÃ§Ã£o:

```rust
mod outro_modulo;
```

Significa que existe um arquivo de nome "outro_modulo.rs" ou um diretÃ³rio com o nome "outro_modulo" no mesmo diretÃ³rio deste arquivo rust. Para mais detalhes, procure por lesson_4_modules.

Se houvesse pub antes da instruÃ§Ã£o, como os exemplos:

```rust
pub mod outro_modulo;
```

Ou:

```rust
mod outro_modulo;

pub use outro_modulo::alguma_dependencia;
```

Demonstram que "outro_modulo" e "alguma_dependencia" podem ser importados por um outro mÃ³dulo ou crate (projeto rust) externos. 

Para mais detalhes, procure por lesson_4_modules. Importar e exportar mÃ³dulos Ã© uma caracterÃ­stica da linguagem Rust. NÃ£o tem nenhum efeito direto na plataforma NEAR.

Agora, referindo ao contrato:

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

Estamos acessando a crate "near_sdk" declarado em "Cargo.toml". Importando self, BorshDeserialize e BorshSerialize no mÃ³dulo borsh. E importando near_bindgen. Seguem as descriÃ§Ãµes simplificadas:

 - **self**: Nem eu sei exatamente o que isso faz, mas Ã© necessÃ¡rio para BorshDeserialize e BorshSerialize funcionarem corretamente.
 - **BorshDeserialize**: Quando chamamos uma funÃ§Ã£o do nosso contrato, devemos enviar parÃ¢metros. Mesmo que estes parÃ¢metros sejam um json vazio, este deve ser deserializado. Este Ã© o objetivo de BorshDeserialize, recebe um json em texto, transforma nos tipos que precisamos.
 - **BorshSerialize**: Caminho inverso do BorshDeserialize. Quando vamos retornar um resultado para o usuÃ¡rio, devemos transformar aquele valor para um json em texto.
 - **near_bindgen**: Isso Ã© um marcador para um struct que diz **"Este Ã© o contrato principal do nosso projeto"**. Damos o nome "Contract" apenas para facilitar o entendimento, nÃ£o Ã© obrigatÃ³rio. PorÃ©m deve-se ter pelo menos um struct com **near_bindgen** em cada contrato.

---

### Macro de alocaÃ§Ã£o
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
near_sdk::setup_alloc!();
```

Macros parecem com funÃ§Ãµes. Mas sÃ£o executadas antes da compilaÃ§Ã£o. SÃ£o ferramentas para gerar cÃ³digo de acordo com os parÃ¢metros. Macros nÃ£o existem no runtime do programa.

Neste caso, "setup_alloc" gera o cÃ³digo "boilerplate" (forma) para o funcionamento do nosso contrato. SÃ³ deve ser executado uma vez, antes da declaraÃ§Ã£o do contrato.

Aviso: Nas prÃ³ximas versÃµes esta instruÃ§Ã£o serÃ¡ deprecada. NÃ£o serÃ¡ necessÃ¡rio usar mais.

---

### DeclaraÃ§Ã£o de contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```

SerÃ¡ mais fÃ¡cil descrever de dentro para fora.
 - **counter**: Ã© um nÃºmero. i32 quer dizer que Ã© "signed", pode ser positivo ou negativo. 32 quer dizer que Ã© um nÃºmero de 32 bits.
 - **pub struct Contract**: Ã© a declaraÃ§Ã£o de um struct de nome Contract. "pub" quer dizer que este struct Ã© pÃºblico.
 - **#[derive(BorshDeserialize, BorshSerialize)]**: Simplificando, aplica as traits BorshDeserialize e BorshSerialize neste struct. Descritos acima.
 - **[near_bindgen]**: Ã‰ um marcador que diz "Este Ã© o Contrato". As funÃ§Ãµes deste struct sÃ£o as funÃ§Ãµes do contrato. Quando executamos uma funÃ§Ã£o do contrato, executamos uma funÃ§Ã£o deste struct.

Logo a seguir temos tambÃ©m:

```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

Default Ã© uma trait (caracterÃ­stica) de "padrÃ£o". Ã‰ praticamente um construtor sem parÃ¢metros para o nosso struct. Mas, Default Ã© uma trait padronizada da linguagem Rust. near_sdk usa essa trait no funcionamento do nosso contrato. EntÃ£o precisamos aplicar ao nosso contrato, senÃ£o teremos um erro de compilaÃ§Ã£o.

default Ã© uma funÃ§Ã£o da trait Default que retorna um struct do mesmo tipo Self. Self nesta declaraÃ§Ã£o Ã© o mesmo que Contract. A funÃ§Ã£o retorna uma instÃ¢ncia de Contract com o valor de counter igual a 0.

Se implementarmos este contrato em uma conta NEAR, e depois executarmos uma primeira funÃ§Ã£o que nÃ£o seja de inicializaÃ§Ã£o. A mÃ¡quina irÃ¡ inicializar o contrato com  default antes de executar nossa funÃ§Ã£o.

---

### DeclaraÃ§Ã£o de API do contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

A seguir se encontram as funÃ§Ãµes do smart contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - ```#[near_bindgen]``` Ã© um marcador que diz "estas sÃ£o as funÃ§Ãµes do contrato".
 - ```impl Contract``` Ã© onde declaramos as funÃ§Ãµes e mÃ©todos associados ao struct Contract.
 - ```&self``` e ```&mut self``` sÃ£o descritos na liÃ§Ã£o seguinte. SÃ³ precisamos saber que esse tipo de funÃ§Ã£o Ã© invocada no formato ```nome_do_struct.nome_da_funcao```, self neste caso se refere a instÃ¢ncia existente deste struct.
 - ```-> i32``` significa que a funÃ§Ã£o retorna um inteiro i32.
 - No fim da funÃ§Ã£o temos uma linha ```self.counter``` sem ponto-virgula ";". Isso Ã© o mesmo que ```return self.counter```.

Com estes detalhes, vemos que a funÃ§Ã£o ```get``` retorna o valor atual de counter armazenado no struct do contrato. ```increment``` incrementa o valor de counter em 1. ```decrement``` reduz o valor de counter em 1.

---

### Testes de unidade
[topo](#li%C3%A7%C3%A3o-1-contrato)

Descrito com mais detalhes na liÃ§Ã£o 4 - mÃ³dulos, nÃ£o Ã© necessÃ¡rio ter todos os testes do projeto aqui. Podemos incluir testes no fim de cada mÃ³dulo rust. Podemos tambÃ©m criar um diretÃ³rio ```tests```. Todos os arquivos ".rs" na pasta ```tests``` serÃ¡ considerado um mÃ³dulo de testes.

```rust
#[cfg(test)]
mod tests{
```

```mod tests``` Ã© simplesmente um mÃ³dulo local com nome tests. Nada de especial.

```#[cfg(test)]``` este Ã© bem interessante. ```cfg``` Ã© uma instruÃ§Ã£o que diz ao compilador "Compile o mÃ³dulo abaixo de mim apenas se a condiÃ§Ã£o entre parenteses for verdadeira.". ```(test)``` Ã© verdadeiro quando executamos ```cargo test```. Se nÃ£o estivermos realizando testes de unidade, este mÃ³dulo nÃ£o existe.

Se em vez de ```#[cfg(test)]``` tivÃ©ssemos:

```rust
#[cfg(not(test))]
mod another_module{
```

Teriamos a situaÃ§Ã£o oposta, este mÃ³dulo nÃ£o seria compilado durante testes de unidade.

```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
Acima importamos as dependÃªncias usadas nos testes abaixo.

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Erro assert.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Antes de cada teste, precisamos iniciar uma simulaÃ§Ã£o do ambiente de blockchain. Uma das formas de fazer isso Ã© utilizando ```VMContextBuilder```. Basta criar uma instÃ¢ncia desse tipo, alterar os atributos que queremos, e usar o builder como argumento para o macro ```testing_env```.

Para nÃ£o termos que escrever estas linhas em cada teste, criamos uma funÃ§Ã£o para ser usada.

```assert_eq``` nÃ£o Ã© necessÃ¡rio. SÃ³ mostra que o atributo de ambiente ```env::current_account_id``` Ã© o mesmo id de conta que escolhi para o builder.

A seguir teremos os trÃªs testes: 

```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

Percebe-se um padrÃ£o em cada um dos testes:
 - Inicializar o ambiente;
 - Inicializar o contrato;
 - Executar a funÃ§Ã£o que queremos testar;
 - Confirmar que a funÃ§Ã£o deu o resultado que esperamos;

A funÃ§Ã£o ```get``` foi testada primeiro. Isto porque esta serÃ¡ usada nos testes seguidos. Se esta funÃ§Ã£o nÃ£o funcionasse da forma que esperassemos, temos que ver este erro primeiro na lista. Bom para evitar confusÃµes nos testes. 

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_2_ownership) serÃ¡ sobre ownership.

'''
'''--- ES/lesson_1_contract/src/lib.rs ---
//! Fonte <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Dicas sobre documentaÃ§Ã£o:
// comentarios com // nÃ£o aparecem na documentaÃ§Ã£o.
// comentarios com /// aparecem como descriÃ§Ã£o para o que estiver a seguir (mod, fn, struct, enum, trait...)
// comentarios com //! podem apenas existir no inicio do arquivo, representam a descriÃ§Ã£o de todo o mÃ³dulo.

// mÃ³dulos importados
use near_sdk::{
    // ParÃ¢metros recebidos e valores retornados sÃ£o convertidos para json com esse mÃ³dulo
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Cria o boilerplate necessÃ¡rio para mÃ¡quinas virtuais NEAR
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Contrato. Este struct contÃ©m o estado (state) da mÃ¡quina virtual.
/// As funÃ§Ãµes deste struct sÃ£o as funÃ§Ãµes do contrato.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Contador.
    counter: i32
}

// Default Ã© executado quando o contrato nÃ£o inicializado manualmente.
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Retorna o contador.
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Incrementa o contador em 1.
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decrementa o contador em 1.
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Nossos testes de unidade ficam aqui.
// cfg(test) quer dizer que esse mod sÃ³ serÃ¡ compilado em ambientes de teste.
#[cfg(test)]
mod tests{
    // super::* importa todos os mÃ³dulos acima.
    use super::*;
    // alguns mÃ³dulos que sÃ³ usaremos em situaÃ§Ãµes de teste
    use near_sdk::{
        // um id de conta como por exemplo "stiltztinkerstein.near"
        AccountId,
        // possui mÃ©todos relacionados ao ambiente de execuÃ§Ã£o.
        // por exemplo, se quisermos saber o nome do usuÃ¡rio que executou
        // esse contrato, usaremos uma funÃ§Ã£o no mÃ³dulo env.
        env,
        // Simula o blockchain
        MockedBlockchain,
        // Macro que inicializa o ambiente de text com o contexto informado.
        testing_env,
        // Usado para criar um contexto de teste.
        test_utils::VMContextBuilder,
        // Simplesmente representa um Id de Conta valido.
        // Um id de conta Ã© um string, mas nÃ£o Ã© todo string que Ã© um id vÃ¡lido.
        json_types::ValidAccountId,
    };

    /// Essa funÃ§Ã£o nÃ£o Ã© um teste. Ã‰ usada pelos testes para simular
    /// um ambiente de teste.
    fn env_setup(){
        // inicializa um construtor de contexto de teste.
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podem ser editados com o builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // string com nome account_id
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tenta converter o string acima para um id valido
            // panic se o id Ã© invalido.
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // inicializa simulaÃ§Ã£o
        testing_env!(builder.build());

        // Se os dois primeiros parametros nÃ£o sÃ£o iguais, 
        // retorna a mensagem de erro seguinte.
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// Como tem o marcador #[test] vai executar automaticamente
    /// quando realizarmos testes de unidade.
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- ES/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_2_ownership/Readme.md ---
# LiÃ§Ã£o 2: Ownership

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Este curto tutorial possui o objetivo de explicar sobre ownership.

---

## FunÃ§Ãµes de Contrato

```rust
/// Retorna o comprimento da String armazenada
pub fn get_length(&self) -> u32;

/// Retorna o comprimento da String e altera o nome armazenado para "Changed name"
pub fn get_length_again(&mut self) -> u32;
```

---

## HipÃ³tese

Ownership Ã© explicado na seÃ§Ã£o seguinte. Esta discute o problema que ownership soluciona.

Consideremos a instruÃ§Ã£o exemplo a seguir:

```
A = B;
```

Sabemos que A Ã© igual a B. A recebe o valor de B. Mas o que estÃ¡ acontecendo? 

Estamos criando uma cÃ³pia do valor de B e associando A a este valor? Criar uma cÃ³pia significa requisitar alocaÃ§Ã£o de memÃ³ria, adiquirir o endereÃ§o da memÃ³ria e igualar o valor desse endereÃ§o ao valor de B. Para um nÃºmero inteiro isso parece simples, mas e se fosse uma string de 2 mil caracteres?

E se usarmos uma variÃ¡vel como parÃ¢metro de funÃ§Ã£o. Estariamos criando uma cÃ³pia da variÃ¡vel e depois apagando a cÃ³pia no fim da funÃ§Ã£o?

Percebe-se que precisamos de uma forma de reutilizar o mesmo endereÃ§o de memÃ³ria em vÃ¡rias partes diferentes do programa. A linguagem C solucionou isso atravÃ©s do uso de ponteiros. Em vez de armazenarmos o valor da variÃ¡vel, nÃ³s armazenamos o endereÃ§o de memÃ³ria daquele tipo de variÃ¡vel.

Mas isso nos trÃ¡s outro problema. Se uma funÃ§Ã£o tem acesso ao endereÃ§o de memÃ³ria de uma variÃ¡vel importante, essa funÃ§Ã£o agora tem muito poder. E se o mÃ©todo foi implementado de uma forma insegura? Um hacker poderia aproveitar essa falha de seguranÃ§a para acessar um sistema.

 - Precisamos de uma forma de reutilizar memÃ³ria para evitar sobrecarregar o sistema com operaÃ§Ãµes desnecessÃ¡rias.
 - Mas precisamos evitar que esse uso de memÃ³ria dÃª mais poder as instruÃ§Ãµes do que Ã© necessÃ¡rio.

**Extra:** Ponteiros existem em Rust tambÃ©m. Mas existem vÃ¡rios tipos de ponteiros, com diferentes vantagens e desvantagens. Ponteiros semelhantes Ã  linguagem C podem ser utilizados tambÃ©m, mas os blocos que os utilizam precisam ser marcados como "unsafe" ([Mais InformaÃ§Ãµes](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

## Ownership

A instruÃ§Ã£o a seguir:

```
A = B;
```

Pode agir de duas formas diferentes:
 - Se **B** implementa a trait Copy, irÃ¡ criar uma cÃ³pia automaticamente.
 - Se **B** nÃ£o implementa Copy, **A** serÃ¡ dona de **B** agora. O compilador nÃ£o deixarÃ¡ realizarmos instruÃ§Ãµes com **B**, porque o valor de **B** foi "movido" para **A**.

Dos tipos primitivos: 
 - NÃºmeros (```u32```, ```f32```, ```i32```, ...) implementam ```Copy``` e ```Clone```. 
 - String implementa ```Clone```, mas nÃ£o implementa ```Copy```. 

Em outras palavras, para criarmos uma cÃ³pia de um String, precisamos fazer isso manualmente.

Ownership garante que apenas uma variÃ¡vel Ã© dona ("owns") de um endereÃ§o de vÃ¡riÃ¡vel. Essa possessÃ£o pode ser transferida. Mas para compartilharmos uma variÃ¡vel, usamos ponteiros ou referÃªncias.

---

## ReferÃªncias

ReferÃªncias, ou emprÃ©stimos ("borrows") sÃ£o uma forma de compartilhar um endereÃ§o de memÃ³ria com permissÃµes limitadas. As referÃªncias podem ser mutÃ¡veis ou imutÃ¡veis. SÃ£o escritas, respectivamente, da seguinte forma:

```rust
let a = 10; // Criando uma variÃ¡vel com valor 10
let b = &a; // Criando uma variÃ¡vel que Ã© uma referÃªncia Ã  variavel a
```

```rust
let mut a = 10; // Criando uma variÃ¡vel mutÃ¡vel com valor 10
let b = &mut a; // Criando uma variÃ¡vel que Ã© uma referÃªncia mutÃ¡vel Ã  variavel a
```

VariÃ¡veis sÃ£o, por padrÃ£o, imutÃ¡veis, constantes. Por isso declarei ```a``` mutavel no segundo exemplo.

 - ReferÃªncias imutÃ¡veis permitem acessar o valor, mas nÃ£o permitem alterÃ¡-lo.
 - ReferÃªncias mutÃ¡veis permitem acessar o valor e permitem alterÃ¡-lo.

Algumas regras a considerar:
 - NÃ£o se pode alterar a variÃ¡vel original enquanto uma referÃªncia ainda existe.
 - VÃ¡rias referÃªncias imutÃ¡veis podem existir.
 - SÃ³ uma referÃªncia mutÃ¡vel pode existir.
 - NÃ£o podem existir referÃªncias imutÃ¡veis se uma referÃªncia mutÃ¡vel existe.

Quando criamos uma referÃªncia, digamos que a variÃ¡vel dona estÃ¡ "emprestando" ("borrow") para a outra. A linha em que o emprÃ©stimo Ã© utilizado por ultimo Ã© a linha em que o emprÃ©stimo Ã© devolvido.

---

## Importante

NÃ£o retorne referÃªncias. Retornar referÃªncias Ã© possivel, mas Ã© preciso marcar o tempo-de-vida (lifetime) do valor retornado. NÃ£o recomendamos estudar isso enquanto estÃ¡ aprendendo a linguagem rust. Todo o conceito de lifetimes pode ser evitado simplesmente retornando cÃ³pias quando necessÃ¡rio. Para os interessados, referÃªncias [aqui](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).

Lifetimes sÃ£o um conceito bem poderoso quando usado corretamente. As ferramentas serde e borsh usam isso para converter texto json para o tipo que precisamos com zero cÃ³pia. Ou seja, existe alocaÃ§Ã£o de memÃ³ria para o String json, para o tipo que precisamos, e nada mais. O processador nÃ£o precisa esperar alocaÃ§Ã£o de memÃ³ria, ou seja, muito rÃ¡pido.

---

## Exemplos

Para o contrato descrito a seguir:

```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

Temos os exemplos a seguir:

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Antes de iniciarmos com os detalhes falaremos sobre String e &str.

---

### O que Ã© String

Uma String Ã© uma variÃ¡vel que possui dono. Armazena um "string" e irÃ¡ ser liberado da memÃ³ria quando a variÃ¡vel ser liberada. Mas "Um texto entre aspas como este nÃ£o Ã© um String, Ã© um &str". Uma referÃªncia a um String Ã© um &String ou &mut String.

---

### O que Ã© &str

Isso Ã© um tipo criado para simplificar o uso de Strings em nosso cÃ³digo. Age como uma referÃªncia imutÃ¡vel Ã  um String. Mas este serÃ¡ alocado pelo compilador, e o compilador decide como melhor otimizÃ¡-lo na memÃ³ria.

---

### Strings em FunÃ§Ãµes

Consideraremos as duas variÃ¡veis abaixo para o exemplo:

```rust
let variavel: String = String::from("Uma Variavel");
let referencia: &str = "Uma Variavel";
```

A funÃ§Ã£o abaixo recebe um &str e retorna o comprimento da string. O emprÃ©stimo Ã© devolvido no fim da funÃ§Ã£o.

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    return name.len();
}
```

Para utilizar a funÃ§Ã£o com os parÃ¢metros:

```rust
this_takes_a_reference(&variavel);
this_takes_a_reference(referencia);
```

A funÃ§Ã£o abaixo recebe um String como parÃ¢metro e retorna o comprimento. A funÃ§Ã£o se torna dona do endereÃ§o de memÃ³ria e o deleta no fim.

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```

Para utilizar a funÃ§Ã£o com os parÃ¢metros:

```rust
this_takes_the_ownership(variavel);
this_takes_the_ownership(String::from(referencia));
```

Precisamos de transformar o &str em um String antes de usar como parÃ¢metro. A funÃ§Ã£o adiquiriu ownership quando nÃ£o precisava tambÃ©m.

Ambas as funÃ§Ãµes ```this_takes_a_reference``` e ```this_takes_the_ownership``` fazem a mesma coisa, nÃ£o causam erros, e retornam o mesmo resultado. Mas a primeira Ã© bem mais eficiente do que a segunda.

Por isso, Ã© boa prÃ¡tica usar ```&str``` em vez de ```String``` nas declaraÃ§Ãµes de funÃ§Ã£o.

Eu lamento ter que adicionar mais um detalhe nessa explicaÃ§Ã£o, mas funÃ§Ãµes de contrato, aquelas em que precisamos de marcar com ```#[near_bindgen]``` precisam de receber String como parÃ¢metro. Isso Ã© porque as traits de deserializaÃ§Ã£o sÃ£o implementadas para String, mas nÃ£o sÃ£o implementadas para referÃªncias de string.

A funÃ§Ã£o:

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
    );
}
```

Chama ```this_takes_a_reference``` e ```this_takes_the_ownership```, garantindo que ambas retornam o mesmo valor antes de retornÃ¡-lo. Como ```this_takes_the_ownership``` nÃ£o pega o valor emprestado, criamos uma cÃ³pia para ser usada como necessÃ¡rio.

A funÃ§Ã£o:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Simplesmente chama ```this_takes_a_reference``` e altera o "nome" armazenado no contrato. Este exemplo mostra que podem haver vÃ¡rias referÃªncias para uma variÃ¡vel. FaÃ§a as alteraÃ§Ãµes recomendadas nos comentÃ¡rios para ver as reaÃ§Ãµes do compilador.

A [prÃ³xima LiÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_3_structs) serÃ¡ sobre structs.

'''
'''--- ES/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Macro que gera codigo boilerplate para o projeto. Vai ser deprecado nas proximas versÃµes.
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Inicializar com a String "A default string" como exemplo
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str Ã© uma referencia para uma string
    // strings entre aspas " " sÃ£o 'static &str
    // entÃ£o ter &str como parÃ¢metro permite ter tanto &String como "uma string estatica como essa"
    /// Retorna o tamanho da string.
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // Essa funÃ§Ã£o faz o mesmo que o de cima, mas recebe uma String como parÃ¢metro.
    // Teriamos que converter para uma String dessa forma: String::from("essa")
    /// Retorna o tamanho da string.
    fn this_takes_the_ownership(name: String) -> usize {
        // retorna usize, usize Ã© u32 em sistemas 32 bit, u64 em sistemas 64 bit
        name.len()
    }

    /// Retorna o tamanho da string armazenada.
    pub fn get_length(&self) -> u32 {
        // IrÃ¡ chamar ambos os mÃ©todos para mostrar que ambos fazem a mesma coisa.
        //
        // Adicionando & antes de cada parametro Ã© o mesmo que dizer:
        // "Estou dando permissÃ£o para esta funÃ§Ã£o olhar o valor dessa variÃ¡vel, mas nÃ£o estou dando permissÃ£o para modificÃ¡-lo".
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // this_takes_the_ownership quer ter possessÃ£o de uma String, entÃ£o precisamos criar uma cÃ³pia para essa.
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Chamando assert_eq para provar que ambas sÃ£o iguais.
        // Se os valores sÃ£o diferentes, o cÃ³digo entra em pÃ¢nico.
        assert_eq!(
            // primeiro parÃ¢metro para comparar
            length_reference, 
            // segundo parÃ¢metro para comparar
            length_ownership, 
            // Se ambas nÃ£o sÃ£o iguais, entra em pÃ¢nico com a mensagem de erro abaixo
            "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
        );

        // Converter para u32 porque Ã© um formato simples para json
        // tipos podem ser convertidos usando as traits "into" e "from" tambÃ©m
        length_reference as u32
    }

    /// Retorna o tamanho da String armazenada. TambÃ©m muda o nome para "Changed name"
    pub fn get_length_again(&mut self) -> u32 {
        // podemos declarar variaveis que armazenam referencias para um outro valor.
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // Podemos ter varias referÃªncias imutaveis ao mesmo tempo.
        // Mas nÃ£o podemos alterar uma variavel enquanto referÃªncias imutÃ¡veis existirem.
        // Se precisarmos tirar uma referÃªncia mutavel, nÃ£o devem haver referÃªncias imutaveis existindo.

        // Descomente a linha adiante para receber um erro devido a referÃªncias existentes.
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // A linha adiante Ã© ok porÃ©m, porque as referÃªncias acima nÃ£o sÃ£o usadas novamente.
        // Como nÃ£o sÃ£o usadas novamente, o compilador sabe que pode liberÃ¡-las da memÃ³ria.
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos modificar com o builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Ambas funÃ§Ãµes fazem a mesma coisa, entÃ£o ambas devem retornar o mesmo valor.
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again tambÃ©m modifica a string armazenada.
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- ES/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_3_structs/Readme.md ---
# LiÃ§Ã£o 3 - Structs

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Esta liÃ§Ã£o discute sobre o formato de structs e como ownership Ã© usada nos mÃ©todos.

---

## TÃ³picos

 - [DescriÃ§Ã£o](#descri%C3%A7%C3%A3o)
 - [FunÃ§Ãµes de Contrato](#fun%C3%A7%C3%B5es-de-contrato)
 - [Projeto](#projeto)
   - [Estrutura de Contrato](#estrutura-de-contrato)
   - [Trait Clone](#trait-clone)
   - [just_a_function](#just_a_function)
   - [macros](#macros)
   - [take_ownership](#take_ownership)

---

## DescriÃ§Ã£o
[voltar](#li%C3%A7%C3%A3o-3---structs)

Structs sÃ£o um pouco semelhantes a classes em algumas linguagens orientadas a objetos. A diferenÃ§a Ã© que ```structs``` nÃ£o podem herdar outros ```structs```, sÃ³ podem implementar ```traits```.

Aprofundaremos o conceito de traits em uma liÃ§Ã£o adiante. Mas considere traits como um conjunto de funÃ§Ãµes representando uma caracterÃ­stica que vÃ¡rios tipos diferentes podem implementar. A trait ```Clone``` permite usar o mÃ©todo ```.clone()``` para criar uma cÃ³pia do elemento. A trait ```BorshDeserialize``` permite tentar construir uma instÃ¢ncia do tipo utilizando um string no formato json.

Mais adiante aprenderemos a criar funÃ§Ãµes que aplicam a qualquer tipo de variÃ¡vel que implementa uma trait especifica. PorÃ©m, essa liÃ§Ã£o serÃ¡ apenas sobre structs.

---

## FunÃ§Ãµes de Contrato
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
// gets e sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// Uma funÃ§Ã£o que nÃ£o altera nem acessa o estado do contrato
pub fn just_a_function();

// Uma funÃ§Ã£o StructExample que toma ownership de si mesmo, se deletando no final.
pub fn take_ownership(&self) -> u32;
```

Cheque a implementaÃ§Ã£o para mais detalhes.

---

## Projeto

[voltar](#li%C3%A7%C3%A3o-3---structs)

Criamos um tipo de nome ```StructExample```.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
O tipo possui os seguintes valores internos:
 - an_integer: um inteiro positivo de 32 bits;
 - another_integer: um inteiro positivo ou negativo de 32 bits;
 - a_floating: um nÃºmero real de 32 bits;
 - a_string: um string, descrito na liÃ§Ã£o anterior;

Em muitas linguagens teriamos que escrever algo como ```long int``` para i32, ```long long int``` para i64. Em rust e assemblyscript, simplesmente usamos i para "signed" (positivo e negativo) e u para "unsigned" (positivo). u8, u16, u32, u64 e u128 sÃ£o todos tipos vÃ¡lidos de inteiros "unsigned".

---

### Estrutura de Contrato

[voltar](#li%C3%A7%C3%A3o-3---structs)

O contrato possui a seguinte estrutura:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```

Este exemplo de contrato deriva a trait ```Default``` em vez de implementar manualmente. Essa forma de implementar executa o mÃ©todo ```.default()``` para todos os valores internos. Devido a isso, o tipo ```struct_example``` deve implementar ```Default``` tambÃ©m.

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```

Escolhemos alguns valores aleatÃ³rios para servir de exemplo. Vemos que nÃ£o Ã© necessÃ¡rio escrever algo como ```an_integer: an_integer``` ou ```a_floating: a_floating``` quando os nomes sÃ£o iguais.

---

### Trait Clone

[voltar](#li%C3%A7%C3%A3o-3---structs)

Implementamos a trait Clone para o tipo:

```rust
impl Clone for StructExample{
    // self Ã© uma instancia de StructExample, Self (Letra maiÃºscula) Ã© o tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample sÃ£o a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```

**Vale relembrar que estou intencionalmente escrevendo o cÃ³digo de forma mais complexa apenas para demonstrar as diversas liberdades que temos na implementaÃ§Ã£o de nossos projetos.**

NÃ£o hÃ¡ muito o que adicionar sobre as implementaÃ§Ãµes dos ```get```s e ```set```s. Recomendo checar os comentÃ¡rios. Mas discutiremos sobre ```just_a_function``` e ```take_ownership``` a seguir:

---

### just_a_function

[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
Esta funÃ§Ã£o imprime duas linhas de texto. 

A funÃ§Ã£o ```log``` recebe uma sequÃªncia de bytes como parÃ¢metro. Devido a isso, a primeira linha mostra que podemos incluir a letra "b" antes das aspas para tratar a string como bytes.

Na segunda instruÃ§Ã£o usamos o macro ```format!``` para formatar uma String dinamicamente. O tipo String possui um mÃ©todo ```.as_bytes``` que converte o tipo para bytes. Para mais detalhes sobre String, cheque os [docs oficiais](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[voltar](#li%C3%A7%C3%A3o-3---structs)

SerÃ£o explicados mais adiante. Para simplificar o entendimento inicial, considere **macros** como funÃ§Ãµes que sÃ£o executadas antes do cÃ³digo ser compilado. SÃ£o funÃ§Ãµes que geram cÃ³digo. SÃ³ depois do **macro** gerar cÃ³digo que o compilador checa por erros. O uso mais comum de **macros** Ã© para agir como funÃ§Ãµes que recebem um nÃºmero variado de parÃ¢metros.

Outra forma de vermos **macros** Ã©: uma forma de trocar complexidade de cÃ³digo por praticidade de uso.

---

### take_ownership
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self serÃ¡ liberado da memÃ³ria aqui
}
```

Acho esse exemplo interessante. 
 - Imprime "Taking ownership of itself" na tela. 
 - Imprime o valor de ```an_integer``` no contrato. 
 - E retorna o valor de ```an_integer```.

Mas como declaramos ```self``` em vez de ```&self``` ou ```&mut self``` como argumento, o mÃ©todo tomarÃ¡ possessÃ£o (ownership) de si mesmo e se auto-destruira no fim. 

Um usuÃ¡rio iniciante provavelmente receberÃ¡ um aviso de erro muito confuso se tentar escrever o mÃ©todo dessa forma. Um erro similar a "valor nÃ£o pode ser usado pois um move aconteceu aqui.".

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_4_modules) serÃ¡ sobre mÃ³dulos.

'''
'''--- ES/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// StructExample Ã© um state do Contract, entÃ£o declaramos derive aqui tambÃ©m.
#[derive(BorshDeserialize, BorshSerialize)]
// Um struct com tipos primitivos
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default Ã© executado quando o codigo Ã© carregado ao contrato e nÃ£o Ã© inicializado.
// Pode ser chamado manualmente para criar uma instÃ¢ncia com valores padrÃ£o.
impl Default for StructExample{
    fn default() -> Self {
        // Cada atributo do StructExample Ã© setado da forma Nome: Valor,
        // NÃ£o Ã© preciso setar da forma nome: nome,
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone Ã© uma forma de criar uma copia desse struct manualmente.
impl Clone for StructExample{
    // self Ã© uma instancia de StructExample, Self (Letra maiÃºscula) Ã© o Tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample sÃ£o a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Aqui que mÃ©todos e funcÃµes para o struct sÃ£o implementados.
impl StructExample{

    // &self quer dizer que irÃ¡ emprestar uma instÃ¢ncia de StructExample, mas nÃ£o irÃ¡ alterÃ¡-la
    /// Retorna a copia de a_string
    pub fn get_a_string(&self) -> String {

        // Strings implementam a trait Clone mas nÃ£o implementam Copy
        // Copy cria uma cÃ³pia da instÃ¢ncia automaticamente quando ha uma instruÃ§Ã£o a = b
        // Clone cria uma cÃ³pia da instÃ¢ncia quando o cÃ³digo chama clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implementa Copy, entÃ£o esta linha irÃ¡ automaticamente criar uma copia de a_floating
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // NÃ£o precisamos escrever "return" sempre.
        // Se a expressÃ£o nÃ£o termina com ponto e virgula ";" retorna a expressÃ£o
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // &mut self quer dizer que irÃ¡ emprestar uma instÃ¢ncia de StructExample e fazer modificaÃ§Ãµes a este.
    pub fn set_a_string(
        &mut self, 
        // detalhe importante: como nÃ£o hÃ¡ referÃªncia & para a String, estamos tomando possessÃ£o (ownership) desta.
        // Quer dizer que a funÃ§Ã£o Ã© dona desta parte de memÃ³ria.
        // PossessÃ£o de a_string_arg quer dizer que o cÃ³digo que o chamou nÃ£o precisarÃ¡ usar a String novamente.
        //
        // Este Ã© um dos superpoderes de Rust. Podemos criar cÃ³digo que cria o menor nÃºmero de cÃ³pias possivel.
        a_string_arg: String,
    ) {
        // como emprestamos self mutavel, podemos alterar os valores internos
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 Ã© unsigned, apenas valores positivos
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 Ã© signed, pode ser positivo e negativo. Mas apenas metade do alcance mÃ¡ximo.
        self.another_integer = another_integer;
    }

    // Se o mÃ©todo nÃ£o possui self, Ã© apenas uma funÃ§Ã£o comum associada ao tipo.
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // Se self estÃ¡ nos argumentos, a funÃ§Ã£o toma possessÃ£o do tipo.
    // Quer dizer que o struct serÃ¡ deletado no fim da funÃ§Ã£o (a nÃ£o ser que retornemos ela).
    // Ã‰ sÃ³ um exemplo. Quase nunca terÃ¡ que implementar uma funÃ§Ã£o dessa forma.
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self serÃ¡ liberado da memÃ³ria aqui
    }
}

// #[near_bindgen] instrui near-sdk que esta struct representa o state principal do contrato.
// Podemos usar qualquer nome. Contract Ã© sÃ³ mais facil de entender.
#[near_bindgen]
// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// BorshSerialize converte o nosso tipo de retorno para json.
// BorshDeserialize converte os parÃ¢metros em json para os tipos que nossa funÃ§Ã£o chama.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // Abaixo sÃ£o as mesmas funÃ§Ãµes do struct sendo chamadas aqui.
    // A diferenÃ§a sendo que estas sÃ£o como interagimos com o contrato.
    //
    // O mÃ©todo para get_a_string precisa de &self, entÃ£o usamos &self ou &mut self
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // O mÃ©todo para set_a_string precisa de &mut self, entÃ£o sÃ³ podemos usar &mut self
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function nÃ£o tem &self, &mut self nem self
    // Ã‰ apenas uma funÃ§Ã£o no namespace da struct. NÃ£o precisamos de usar self tambÃ©m.
    pub fn just_a_function(){
        // :: Ã© usado para referenciar namespaces. NÃ£o Ã© um metodo de uma instÃ¢ncia de struct, apenas uma funÃ§Ã£o.
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A funÃ§Ã£o take_ownership libera o objeto da memÃ³ria.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador nÃ£o irÃ¡ nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessÃ£o (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy serÃ¡ removido no fim dessa funÃ§Ã£o abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irÃ¡ aparecer.
        // Isso Ã© porque chamamos uma funÃ§Ã£o de uma instÃ¢ncia que nÃ£o existe mais.
        // env::log(format!("Essa linha de cÃ³digo irÃ¡ gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg diz ao compilador para considerar esse modulo apenas em um ambiente de teste. Este nÃ£o existe fora dessas condiÃ§Ãµes.
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos alterar com esse builder
        //
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // Declaramos isso no inÃ­cio do contrato, mas nÃ£o precisamos de usa-lo aqui
        // ComeÃ§ar a variÃ¡vel com _ se nÃ£o tiver intenÃ§Ã£o de usÃ¡-la
        let _contract: Contract = Contract::default();

        // Note o :: devido a funÃ§Ã£o nÃ£o precisar de um state.
        Contract::just_a_function();
    }

    #[test]
    // take_ownership Ã© sÃ³ um exemplo de uma gambiarra em rust. NÃ£o ha muito uso aqui.
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- ES/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_4_modules/Readme.md ---
# LiÃ§Ã£o 4 - MÃ³dulos

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Esta liÃ§Ã£o discute sobre como mÃ³dulos sÃ£o importados. 

Podemos ter todo nosso cÃ³digo implementado no arquivo ```lib.rs```. Mas percebe-se como seria dificil de organizar um projeto grande dessa forma. 

 - Podemos declarar mÃ³dulos externos; 
 - Declarar diretÃ³rios externos como mÃ³dulos;
 - Controlar quais mÃ³dulos sÃ£o pÃºblicos;
 - Controlar o caminho para cada mÃ³dulo pÃºblico;
 - TambÃ©m podemos organizar nossos testes no diretÃ³rio ```./tests/```.

---

## API de Contrato

```rust
/// Retorna a String armazenada.
pub fn get_phrase(&self) -> String;

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from crate::a_module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from 
/// crate::a_module::specific_module" e atribuir essa string ao 
/// valor armazenado.
pub fn hello1(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from another module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello2(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from yet_another_module" 
/// e atribuir essa string ao valor armazenado.
pub fn hello3(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Called a deep function" e 
/// atribuir essa string ao valor armazenado.
pub fn hello4(&mut self);

/// Esta funÃ§Ã£o irÃ¡ entrar em pÃ¢nico com a mensagem "A panic 
/// just happened" quando chamado.
pub fn this_will_panic();
```

---

## TÃ³picos
 - [Como declarar um mÃ³dulo externo](#como-declarar-um-m%C3%B3dulo-externo)
 - [Como declarar e usar diretÃ³rios](#como-declarar-e-usar-diret%C3%B3rios)
 - [Usando/importando mÃ³dulos](#usandoimportando-m%C3%B3dulos)
   - [Apelidos](#apelidos)
   - [Usos pÃºblicos](#usos-p%C3%BAblicos)
 - [Testes de integraÃ§Ã£o](#testes-de-integra%C3%A7%C3%A3o)
   - [Testes de integraÃ§Ã£o NEAR](#testes-de-integra%C3%A7%C3%A3o-near)
   - [Testes de integraÃ§Ã£o Rust](#testes-de-integra%C3%A7%C3%A3o-rust)
  - [Desativar avisos de compilador](#desativar-avisos-de-compilador)
  - [Testando Falhas](#testando-falhas)

---

## Como declarar um mÃ³dulo externo

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Um mÃ³dulo externo deve ser declarado antes de usado/importado.

```rust
mod yet_another_module;
```

Essa linha diz ao compilador que existe um mÃ³dulo com este nome no mesmo diretÃ³rio. Existem trÃªs formas de se declarar um mÃ³dulo. Se dois mÃ³dulos ou mais com mesmo nome forem encontrados, um erro de ambiguidade serÃ¡ gerado.

O mÃ³dulo acima Ã© privado. SÃ³ pode ser usado onde foi declarado. O mÃ³dulo abaixo Ã© pÃºblico:

```rust
pub mod a_module;
```

```a_module``` Ã© pÃºblico aqui. Ou seja, pode ser importado por outros. Isso inclui crates externas. O exemplo abaixo restringe isso.

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```

```pub(crate)``` significa que esta funÃ§Ã£o Ã© pÃºblica apenas nessa crate. Ou seja, se ```lesson_4_modules``` for dependÃªncia de um outro projeto rust, o crate externo nÃ£o terÃ¡ acesso a essa funÃ§Ã£o.

---

## Como declarar e usar diretÃ³rios

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos declarar diretÃ³rios como mÃ³dulos tambÃ©m. Existem duas formas para isso. A primeira Ã©:
 - Criar um diretÃ³rio com o nome do seu mÃ³dulo.
 - Criar um arquivo com nome ```mod.rs``` dentro desse diretÃ³rio. Este arquivo possui a implementaÃ§Ã£o do mÃ³dulo.

![Imagem de um diretÃ³rio com um arquivo mod.rs](../static/images/mod-diretorios.png)

```a_module``` Ã© uma implementaÃ§Ã£o de mÃ³dulo. 

A segunda forma Ã©:

 - Criar um diretÃ³rio com o nome do seu mÃ³dulo.
 - Criar um arquivo rust com o mesmo nome do seu mÃ³dulo junto com o diretÃ³rio. Este arquivo possui a implementaÃ§Ã£o do mÃ³dulo.

![Imagem de um diretÃ³rio com um arquivo de mesmo nome ao lado](../static/images/mod-diretorios2.png)

```internal_module``` Ã© outra implementaÃ§Ã£o de mÃ³dulo.

O arquivo rust fica dentro ou fora do diretÃ³rio? Essa Ã© a questÃ£o.

---

## Usando/Importando mÃ³dulos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Qualquer item (mÃ³dulos, funÃ§Ãµes, structs, traits, enums, et cetera) pode ser importado com a instruÃ§Ã£o use.

No exemplo abaixo, acessamos o caminho ```near_sdk``` (uma crate neste caso), e incluimos ```env``` e ```near_bindgen``` no nosso namespace.

```rust
use near_sdk::{env, near_bindgen};
```

NÃ£o Ã© necessÃ¡rio usar a instruÃ§Ã£o use. PorÃ©m, se quisÃ©ssemos acessar o mÃ³dulo ```env```, teriamos que escrever ```near_sdk::env``` todas as vezes.

---

### Apelidos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos dar um apelido ao item importado:

```rust
use a_module::specific_module::hello as hello1;
```

Existem vÃ¡rias funÃ§Ãµes ```hello``` neste exemplo. EntÃ£o alteramos o nome de cada uma com o operador ```as```. Ou seja, importando dessa forma, a instruÃ§Ã£o ```hello1()``` Ã© o mesmo que ```a_module::specific_module::hello()```.

---

### Usos pÃºblicos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

As instruÃ§Ãµes

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

Trazem as duas funÃ§Ãµes hello para este namespace, alteram o nome para ```hello2``` e ```hello3```, e as tornam pÃºblicas, como se tivessem sido declaradas neste mÃ³dulo. Isso Ã© uma boa forma de organizar nosso projeto. Por exemplo, no arquivo ```yet_another_module```:

```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```

Declaramos que o mÃ³dulo ```internal_module``` existe, e Ã© privado. Mas a funÃ§Ã£o ```a_deep_function``` Ã© pÃºblica. Um usuÃ¡rio pode acessar esse item pelo caminho ```yet_another_module::a_deep_function```. Sem saber que a funÃ§Ã£o estÃ¡ em um diretÃ³rio completamente diferente.

Organize mÃ³dulos e diretÃ³rios de acordo com as necessidades do seu projeto. Use ```pub use``` para organizar os itens disponÃ­veis de acordo com as necessidades dos usuÃ¡rios externos.

**Detalhe**: ```pub use``` e ```pub mod``` sÃ£o usados para mÃ³dulos pÃºblicos e crates feitos para serem importados (library) por outros projetos rust. NÃ£o possui nenhuma interaÃ§Ã£o no contexto de contratos NEAR.

---

## Testes de IntegraÃ§Ã£o

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

A linguagem rust tem um formato para testes de integraÃ§Ã£o, e o formato NEAR possui outro.

Isso porque testes de integraÃ§Ã£o em NEAR consistem na interaÃ§Ã£o entre diversos contratos em uma simulaÃ§Ã£o de estrutura blockchain.

---

### Testes de IntegraÃ§Ã£o NEAR

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Para isso usamos uma ferramenta chamada [workspaces-rs](https://github.com/near/workspaces-rs)

Agora, como se ja nÃ£o estivesse confuso o suficiente, workspaces em rust e workspaces-rs sÃ£o duas coisas diferentes. [Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html) em rust sÃ£o uma forma de organizar vÃ¡rias crates em um Ãºnico pacote, todas compartilhando um diretÃ³rio ```./target/``` e um arquivo ```Cargo.lock```. [workspaces-rs](https://github.com/near/workspaces-rs) Ã© uma forma de realizar testes de integraÃ§Ã£o de contratos NEAR utilizando a linguagem rust.

Testes de integraÃ§Ã£o eram feitos com a crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), mas esta ferramenta serÃ¡ deprecada pela [sandbox](https://docs.near.org/docs/develop/contracts/sandbox). Use a ferramenta que lhe servir melhor.

---

### Testes de integraÃ§Ã£o Rust

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Geralmente declaramos testes no mesmo arquivo. da seguinte forma:

```rust
#[cfg(test)]
mod tests{
    // carrega tudo que estÃ¡ neste arquivo, fora deste mÃ³dulo.
    use super::*;

    #[test]
    fn hello_test(){
```

Mas as vezes, precisamos declarar testes em sua prÃ³pria estrutura de arquivos e diretÃ³rios.

Podemos criar um diretÃ³rio ```tests``` junto com o ```src```.

![Imagem do diretÃ³rio root com destaque no diretÃ³rio "tests"](../static/images/testsdirectory.png)

Quando executarmos o comando ```cargo test```, cada arquivo ```.rs``` serÃ¡ tratado como um mÃ³dulo de teste. Todas as funÃ§Ãµes marcadas com ```#[test]``` serÃ£o executadas automaticamente.

Os arquivos ```.rs``` nÃ£o precisam ser declarados com a instruÃ§Ã£o ```mod``` para serem compilados.

O diretÃ³rio ```tests``` age como uma crate separada. Podemos importar mÃ³dulos no mesmo diretÃ³rio:

```rust
mod common;

use common::env_setup;
```

Para importarmos mÃ³dulos na crate principal, referimos Ã  essa pelo nome da crate:

```rust
use lesson_4_modules::Contract;
```

---

## Desativar avisos de compilador

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Avisos ("warnings") sÃ£o gerados durante a compilaÃ§Ã£o. Podemos desativar avisos da seguinte forma:

```rust
#[allow(unused)]
```

O exemplo acima permite uma falha de cÃ³digo "nÃ£o utilizado" na linha abaixo.

O recomendado Ã© corrigir avisos do compilador. Mas existem situaÃ§Ãµes em que talvez isso seja Ãºtil. Por exemplo, a convenÃ§Ã£o para funÃ§Ãµes javascript Ã© ```CamelCase```, mas a convenÃ§Ã£o para funÃ§Ãµes em rust Ã© ```snake_case```. Quando comunicarmos com o nosso contrato atravÃ©s do near-api-js, talvez seja melhor ter as funÃ§Ãµes na convenÃ§Ã£o javascript.

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

Podemos permitir avisos de imports nÃ£o utilizados:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```

Repetindo, avisos existem para nos ajudar. O recomendado Ã© **corrigir** os avisos, nÃ£o escondÃª-los.

---

## Testando falhas

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Criamos testes para garantir que erros aconteÃ§am quando erros devem acontecer tambÃ©m.

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

O teste acima irÃ¡ causar pÃ¢nico, mas esperamos pÃ¢nico. EntÃ£o o teste serÃ¡ um sucesso.

Se a operaÃ§Ã£o nÃ£o causar pÃ¢nico, ou causar pÃ¢nico com uma mensagem diferente do esperado ("expected"). O teste irÃ¡ falhar.

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_5_macro_usage) serÃ¡ sobre uso de macros.

'''
'''--- ES/lesson_4_modules/src/a_module/mod.rs ---
//! Entre usar mod.rs ou um arquivo rust com mesmo nome. 
//! Ã‰ apenas uma questÃ£o de manter o arquivo rust no diretorio pai ou filho.
//! 
//! 

pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- ES/lesson_4_modules/src/a_module/specific_module.rs ---
// Ter (crate) apÃ³s pub torna a funÃ§Ã£o (ou mÃ³dulo, trait, ...) disponivel 
// para mÃ³dulos locais, mas nÃ£o para crates externos.
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// panic Ã© quando algo de errado acontece e tudo deve parar imediatamente.
/// Podemos causar panic sob demanda.
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) diz ao compilador que isto apenas existe em ambientes de teste.
#[cfg(test)]
mod tests{
    // carrega tudo que estÃ¡ neste arquivo, fora deste mÃ³dulo.
    use super::*;

    #[test]
    fn hello_test(){
        // Hello Ã© pÃºblico apenas para mÃ³dulos desta crate.
        // Tentaremos importÃ¡-lo no diretÃ³rio de tests, o que causarÃ¡ um erro.
        // Pois o diretÃ³rio de testes atua como a prÃ³pria crate.
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // Podemos testar em situaÃ§Ãµes que causam panic.
    // expected garante que entraremos em pÃ¢nico pelo motivo correto.
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- ES/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A funÃ§Ã£o abaixo Ã© privada.
// #[allow(unused)] Ã© uma forma de dizer ao compilador/linter para ignorar o aviso. Mesmo em um situaÃ§Ã£o como essa, em que Ã© uma mÃ¡ ideia. Pois esta funÃ§Ã£o Ã© inutil.
// Comente o #[allow(unused)] para ver o aviso
#[allow(unused)]
fn this_is_private() -> String {
    // TraduÃ§Ã£o: Esta funÃ§Ã£o nunca serÃ¡ usada pois Ã© privada.
    String::from("This will never be used because it's private")
}

'''
'''--- ES/lesson_4_modules/src/lib.rs ---
//! Este exemplo foca na administraÃ§Ã£o de mÃ³dulos.
//! 
//! 
//!
//! A ordem para importaÃ§Ã£o de crates e modulos Ã©, normalmente:
//! 
//!  - padrÃ£o (std), 
//!  - outras crates (como near-sdk), 
//!  - crates nesta workspace, 
//!  - e mÃ³dulos locais.
//!
//! 
//! "mod file" diz ao compilador que o arquivo nesse diretÃ³rio local deve ser compilado tambÃ©m.
//! Para usarmos o mÃ³dulo utilizamos "use".
//! 
//! "pub mod" quer dizer que outros mÃ³dulos podem usar dito mÃ³dulo, senÃ£o Ã© privado.
//! "pub use" pode ser usado para o mesmo propÃ³sito.
//! A diferenÃ§a sendo que arquivos podem ser organizados de certa forma, e mÃ³dulos de library em outra, mais conveniente.
//! 

// Esta linha estÃ¡ dizendo que existe um arquivo ou diretÃ³rio com nome "a_module" e deve ser compilado.
// "mod.rs" Ã© uma forma necessÃ¡ria de um diretÃ³rio ser reconhecido como mÃ³dulo.
pub mod a_module;
// Esta linha esta dizendo que o arquivo "another_module.rs" Ã© parte deste projeto e deve ser compilado.
mod another_module;

// Esta linha Ã© outra forma de declarar mÃ³dulos, nÃ£o precisa de "mod.rs", mas acho mais desorganizado.
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Podemos usar "as" para dar apelidos a funÃ§Ãµes ou mÃ³dulos importados.
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// pub use torna a funÃ§Ã£o disponÃ­vel para crates externos.
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// A localizaÃ§Ã£o atual de "a_deep_function"  Ã© "yet_another_module::internal_module::a_deep_module::a_deep_function."
// Mas este endereÃ§o Ã© privado, e "yet_another_modulo" chamou "pub use" para a funÃ§Ã£o. Em outras palavras, mais limpo.
use yet_another_module::a_deep_function as hello4;

// Descomente a linha adiante para receber um aviso de erro "isto Ã© privado".
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// Esta funÃ§Ã£o irÃ¡ fazer nosso cÃ³digo menos bagunÃ§ado.
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Retorna a String armazenada.
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from crate::a_module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from 
    /// crate::a_module::specific_module" e atribuir essa string ao 
    /// valor armazenado.
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from another module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from yet_another_module" 
    /// e atribuir essa string ao valor armazenado.
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Called a deep function" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// Esta funÃ§Ã£o irÃ¡ entrar em pÃ¢nico com a mensagem "A panic 
    /// just happened" quando chamado.
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Testes estÃ£o no diretÃ³rio tests. Muito Ãºtil para projetos grandes.

'''
'''--- ES/lesson_4_modules/src/yet_another_module.rs ---
// internal_module Ã© privado para mÃ³dulos externos.
mod internal_module;

// Mas fizemos a_deep_function publico para outros na declaraÃ§Ã£o aqui.
// Bom para organizar cÃ³digo.
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- ES/lesson_4_modules/src/yet_another_module/internal_module.rs ---
pub mod a_deep_module;

'''
'''--- ES/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// Uma funÃ§Ã£o profunda.
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- ES/lesson_4_modules/tests/another.rs ---
//! Cada arquivo rusts no diretÃ³rio tests Ã© testado individualmente.
//! NÃ£o hÃ¡ necessidade de incluÃ­-los usando mod.

// Descomente a linha abaixo e verÃ¡ um aviso de erro "privado".
// Isso Ã© porque Ã© pÃºblico apenas dentro da crate. E "tests" age como a prÃ³pria crate.
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- ES/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // attributes we can set with the builder:
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- ES/lesson_4_modules/tests/contract.rs ---
//! Este mÃ³dulo irÃ¡ testar a funcionalidade do contrato.

// common serÃ¡ um mÃ³dulo com funÃ§Ãµes Ãºteis para todos outros testes.
mod common;

// DiretÃ³rio tests age como a prÃ³pria crate.
// So when we import our own modules, 
// EntÃ£o quando importamos nossos prÃ³prios mÃ³dulos,
// referimos a estes como "lesson_4_modules::" em vez de "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // Usamos derive(Default) para Contract.
    // o padrÃ£o derivado para String Ã© uma string vazia.
    assert_eq!(contract.get_phrase(), "");
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from crate::a_module".
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from crate::a_module::specific_module".
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from another_module".
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from yet_another_module".
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Called a deep function".
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

/// Esta funÃ§Ã£o entrarÃ¡ em panico com a messagem "A panic has just happened" quando chamado.
// Podemos testar situaÃ§Ãµes que causam pÃ¢nico.
// expected garante que estamos entrando em pÃ¢nico pelo motivo certo.
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora nÃ£o utilizemos o state, Ã© bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- ES/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_5_macro_usage/Readme.md ---
# LiÃ§Ã£o 5 - Uso de Macros

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Macros sÃ£o a ferramenta principal para a utilizaÃ§Ã£o efetiva da linguagem rust. NÃ£o Ã© necessÃ¡rio saber como criar macros. Mas Ã© essencial entender o que sÃ£o e como usÃ¡-los.

---

## API de Contrato

```rust
/// Esta funÃ§Ã£o mostra as diferenÃ§as entre println e env::log
/// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
/// Note como algumas mensagens aparecem e outras nÃ£o.
pub fn print_examples();

/// Exemplos de format. Compare o output com a implementaÃ§Ã£o.
pub fn format_examples();

/// Exemplo de panico.
pub fn panic_example();

/// Exemplo de usos de vec.
pub fn vec_examples();
```

## TÃ³picos

 - [O que sÃ£o macros](#o-que-sÃ£o-macros)
 - [Macros "function-like"](#macros-"function-like")
 - [Vantagens](#vantagens)
 - [Desvantagens](#desvantagens)
 - [Exemplos](#exemplos)
   - [format, println e panic](#format-println-e-panic)
   - [vec](#vec)
   - [setup_alloc](#setup_alloc)
 - [Extra: String e str](#extra-string-e-str) 

---

## O que sÃ£o macros

[topo](#liÃ§Ã£o-5---uso-de-macros)

Macros sÃ£o ferramentas que geram cÃ³digo. Macros sÃ£o executados em tempo de compilaÃ§Ã£o. 

As instruÃ§Ãµes derive sÃ£o um macro:

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```

InstruÃ§Ãµes derive servem para aplicar traits a novos tipos. A instruÃ§Ã£o a seguir Ã© outro tipo de macro chamado "atributo":

```rust
#[near_bindgen]
impl Contract{
```

Mas discutiremos macros "function-like" (semelhantes a funÃ§Ãµes). Como o nome descreve, sÃ£o usados com a mesma lÃ³gica do chamado de funÃ§Ãµes. Alguns exemplos:

```rust
// Imprime o string formatado ao output padrÃ£o
println!("{}", message);

// Formata os argumentos em um String
format!("7");

// Formata uma String e entra em pÃ¢nico com a mensagem formatada
// "Entrar em pÃ¢nico" Encerra o runtime retornando uma mensagem de erro.
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

// Recebe uma lista de argumentos e retorna um Vec com os valores alocados.
vec![1, 2, 3, 4];

// Gera cÃ³digo de fÃ´rma (boilerplate) necessÃ¡rio para o funcionamento do contrato
near_sdk::setup_alloc!();

// Usado em testes.
// Usa o argumento Context para gerar o contexto de ambiente da mÃ¡quina virtual.
testing_env!(builder.build());

``` 

---

## Macros "function-like"

[topo](#liÃ§Ã£o-5---uso-de-macros)

Esses macros sÃ£o usados como funÃ§Ãµes, mas existem algumas diferenÃ§as.

Podem ter um nÃºmero variado de parÃ¢metros. Rust Ã© uma linguagem "statically typed", ou seja, o compilador precisa saber exatamente onde memÃ³ria Ã© criada e onde Ã© liberada. PorÃ©m, macros podem retornar cÃ³digo. Ou seja, um macro como ```println``` ou ```format``` recebem os argumentos e montam um bloco de cÃ³digo antes do compilador checar por erros.

Outra diferenÃ§a que pode ser vista com o exemplo de ```vec```:

```rust
vec![1, 2, 3, 4];
```

Esta implementaÃ§Ã£o vec Ã© demarcada com ``` [ ] ``` em vez de ``` ( ) ```, macros tambÃ©m podem ser demarcados com ``` { } ```. Macros podem ter literalmente qualquer tipo de texto dentro dos demarcadores. Um desenvolvedor pode escrever qualquer coisa como argumento macro, contanto que a implementaÃ§Ã£o entenda os parÃ¢metros.

---

## Vantagens

[topo](#liÃ§Ã£o-5---uso-de-macros)

 - Simplifica o cÃ³digo.
 - Ã‰ executado durante compilaÃ§Ã£o. Se bem implementado, macros podem ser eficientes com pouco ou nenhum overhead.

---

## Desvantagens

[topo](#liÃ§Ã£o-5---uso-de-macros)

 - Um desenvolvedor precisa pesquisar a documentaÃ§Ã£o de cada novo macro que encontram.
 - Podem ser mais dificeis de "debugar".
 - Aumentam o tempo de compilaÃ§Ã£o.
 - Podem "inflar" o cÃ³digo com implementaÃ§Ã£o "invisivel".

---

## Exemplos

A seguir recomendamos alguns macros "function-like" Ãºteis.

---

### format, println e panic

[topo](#liÃ§Ã£o-5---uso-de-macros)

Os macros ```panic```, ```println``` e ```format``` sÃ£o escritos da mesma forma.

 - ```format``` retorna um String.
 - ```println``` imprime o String no output padrÃ£o.
 - ```panic``` encerra a execuÃ§Ã£o e retorna o String como mensagem de erro.

```rust
println!("Isso Ã© um println!, nÃ£o aparece na mÃ¡quina virtual");

// Criamos uma variavel "message" e associamos uma String de valor "format retorna uma String formatada".
let message: String = format!("format retorna uma string formatada.");

// Encerra execuÃ§Ã£o com a mensagem de erro "Panico com alguns argumentos: 1 2 3"
let second = 2;
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

```

A utilizaÃ§Ã£o destes macros Ã© bem simples. Um str como primeiro argumento ([detalhes](#extra-string-e-str)). Cada "{}" Ã© substituido pelos argumentos apÃ³s o primeiro.

Podemos customizar a formataÃ§Ã£o de diversas formas. Mais informaÃ§Ãµes, cheque o [link de documentaÃ§Ã£o sobre formataÃ§Ã£o](https://doc.rust-lang.org/std/fmt/index.html). Abaixo incluimos algumas Ãºteis utilizaÃ§Ãµes:

```rust
// Exemplos de format
log("\n\nformat_examples:\n");
 
let message: String = format!("Format retorna uma String formatada");

let an_arg = "third";

// format pode receber argumentos usando {} 1 second third
let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// Podemos especificar argumentos dessa forma: 1 second third
let message = format!("Podemos especificar argumentos dessa forma: {first}, {second}, {third}.");

// Podemos especificar a ordem de argumentos de format: 1 second third
let message = format!("Podemos especificar a ordem de argumentos de format: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: 01 0002      3
let message = format!("Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: {:02}, {:04}, {:6}.", first, second, third);

// Escolhendo nÃºmero de digitos e ordem: 01    2 000003
let message = format!("Escolhendo nÃºmero de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// Podemos escolhar a precisÃ£o de nÃºmeros racionais: 0.10 1.230 -2.450000
let message = format!("Podemos escolhar a precisÃ£o de nÃºmeros racionais: {:.2}, {:.4}, {:.6}", first, second, third);

// Podemos escolher a precisÃ£o e nÃºmero de digitos: 0.10 0001.2300 -00002.450000
let message = format!("Podemos escolher a precisÃ£o e nÃºmero de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: 00.10    1.2300 -00002.450000
let message = format!("Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// Mesmo que o acima:  0.10 0001.2300      -2.450000
let message = format!("Mesmo que o acima: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### vec

[topo](#liÃ§Ã£o-5---uso-de-macros)

Uma rÃ¡pida discussÃ£o sobre algumas formas de agrupar valores. 

Tuplas possuem tamanho imutavel:

```rust
// Uma tupla com inteiros
let tupla: (u32, u32, u32) = (0, 1, 4);

// Acessando um valor
// O segundo valor Ã© 1
println!("O segundo valor Ã© {}", tupla.1);
```

Arrays possuem tamanho imutÃ¡vel, sÃ£o armazenados na pilha (stack).

```rust
// Uma forma de declarar um array
let lista = [0, 1, 2];

// Acessando um valor
// O terceiro valor Ã© 2
println!("O terceiro valor Ã© {}", lista[2]);

// um array com 10 inteiros inicializados com 0.
// Esse mÃ©todo sÃ³ permite inicializar com valores iguais, nÃ£o tente inicializar com uma funÃ§Ã£o.
let mut lista: [i32; 10] = [0; 10];

// Alterando um valor
lista[0] = -1;

// Acessando um valor
// O primeiro valor Ã© -1
println!("O primeiro valor Ã© {}", lista[0]);
```

Arrays e tuplas sÃ£o primitivos. NÃ£o podemos alterar o nÃºmero de elementos desses grupos. Para armazenar conjuntos de valores de forma mais prÃ¡tica usamos coleÃ§Ãµes. Temos coleÃ§Ãµes rust, que sÃ£o mais generalizadas, e coleÃ§Ãµes Near, que sÃ£o armazenadas na "trie". O entendimento de coleÃ§Ãµes rust Ã© importante para uma boa lÃ³gica de funÃ§Ãµes. O entendimento de coleÃ§Ãµes Near Ã© importante para armazenamento eficiente de estado.

 - [Detalhes](https://doc.rust-lang.org/std/collections/) sobre coleÃ§Ãµes Rust para bom funcionamento de mÃ©todos.
 - [Detalhes](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) sobre coleÃ§Ãµes Near para bom armazenamento de estado.

A coleÃ§Ã£o rust mais utilizada Ã© ```Vec```([detalhes](https://doc.rust-lang.org/std/vec/struct.Vec.html)). Com este tipo, podemos armazenar dados, observar a quantidade de elementos, acessar e alterar os elementos. O que Ã© uma boa soluÃ§Ã£o para a maior parte dos casos.

**Detalhe:** ```vec``` (letra minuscula) Ã© o macro para criaÃ§Ã£o de vetores ```Vec```. ```Vec``` (letra maiuscula) refere-se ao tipo do vetor.

Podemos criar um ```Vec``` da seguinte forma:

```rust
// Vec com os nÃºmeros 1 2 3 4
let example = vec![1, 2, 3, 4];
```

Podemos criar um ```Vec``` com vÃ¡rios valores iguais:

```rust
// Vec com os nÃºmeros 0 0 0 0 0
let example = vec![0;5];
```

Imprimir valores de conjuntos pode demandar muito tempo de processamento. Devido a isso, para usar um conjunto de elementos em um ```println```, ```format``` ou ```panic```, precisamos explicitar que Ã© impresso em modo debug.

```rust
let example = vec![1, 2, 3, 4];

log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));

log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

log(&format!("Podemos criar vetores com valores padrÃ£o:\n{:?}\n\n", vec![0;5]));
```

FormataÃ§Ã£o ```{:?}``` Ã© "formataÃ§Ã£o debug".

FormataÃ§Ã£o ```{:#?}``` Ã© "formataÃ§Ã£o pretty print". Ã‰ o mesmo que o acima, porÃ©m escrito de uma forma mais legivel para um usuÃ¡rio. Normalmente simplesmente significa um elemento por linha.

Para implementar formataÃ§Ã£o debug em um struct ou enum, cheque o [link sobre formataÃ§Ã£o](https://doc.rust-lang.org/std/fmt/trait.Debug.html).

---

### setup_alloc

[topo](#liÃ§Ã£o-5---uso-de-macros)

Deve ser usado antes da declaraÃ§Ã£o do contrato. Gera cÃ³digo que deveria ser escrito repetidas vezes em cada contrato.

```rust
near_sdk::setup_alloc!();
```

Ã‰ necessÃ¡rio na versÃ£o de near_sdk atual (```3.1.0```). Nas versÃµes seguintes, serÃ¡ deprecado.

---

## Extra: String e str

[topo](#liÃ§Ã£o-5---uso-de-macros)

```String``` e ```str``` sÃ£o dois tipos diferentes. String Ã© um tipo que mantem ownership de uma string. ```str``` Ã© um tipo usado para referÃªncias a strings. Estes tipos existem para minimizar cÃ³pias de strings durante o runtime.

Lembrar: 
 - ```str``` Ã© sempre usado como ```&str```. ```&str``` aplica para "strings como essa" e ```&String```;
 - Sempre que for precisar de uma referÃªncia para uma ```String``` em uma funÃ§Ã£o, use ```&str```. NÃ£o use ```&String```.
 - "Strings como essa" sÃ£o do tipo ```&'static str```. Mais detalhes na seÃ§Ã£o sobre lifetimes. Teoricamente, sÃ£o strings que nunca sÃ£o removidas da memÃ³ria, mas isso depende da otimizaÃ§Ã£o do compilador.

A [proxima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums) serÃ¡ sobre enums.

'''
'''--- ES/lesson_5_macro_usage/src/lib.rs ---
//! Exemplos para os seguintes macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// Esta funÃ§Ã£o Ã© usada em ```print_examples```.
/// Ã‰ compilada em ambientes de teste.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// Esta funÃ§Ã£o Ã© usada em ```print_examples```.
/// Ã‰ compilada fora de ambientes de teste.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // Este contrato nÃ£o possui estado
}

#[near_bindgen]
impl Contract{

    /// Esta funÃ§Ã£o mostra as diferenÃ§as entre println e env::log
    /// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
    /// Note como algumas mensagens aparecem e outras nÃ£o.
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("Isto Ã© um println! NÃ£o aparece na mÃ¡quina virtual");
        let a = String::from("algo");
        println!("Isso Ã© outro println com diversos argumentos, {}, {}, {}", 1, "thingy", a);

        env::log(b"Isso e um log. Nao aparece em testes.");
        env::log("Isso Ã© outro log".as_bytes());

        env::log(
            format!("Isso Ã© outro log com diversos argumentos: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("Isso Ã© uma mensagem que aparecem em testes e na mÃ¡quina virtual.");

        log(
            &format!("Isso Ã© outra mensagem com argumentos, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// Exemplos de format. Compare o output com a implementaÃ§Ã£o.
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format retorna um String formatado");
        log(&message);

        let an_arg ="terceiro";
        let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("Podemos especificar argumentos format da seguinte forma: {first}, {second}, {third}.");

        log(&message);

        let message = format!("Podemos especificar a ordem dos argumentos format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Escolhendo um nÃºmero de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Podemos escolher a precisÃ£o de nÃºmeros racionais: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisÃ£o e o nÃºmero de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Mesmo que acima: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Exemplo de panico.
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("Macros de pÃ¢nico sÃ£o escritos da mesma forma que println e format.");

        let second = 2;
        panic!("PÃ¢nico com alguns argumentos: {} {} {}", 1, second, 3);

    }

    /// Exemplo de usos de vec.
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));
        
        log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

        log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Podemos criar vetores com valores padrÃ£o:\n{:?}\n\n", vec![0;5]));

        log("Mais informaÃ§Ãµes na liÃ§Ã£o de coleÃ§Ãµes (\"collections\").");

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Execute testes com o comando a seguir:
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture faz imprimir todo o output, incluindo testes sucedidos.
// Sem o argumento --test-threads, todos os testes serÃ£o async. O que significa que o output serÃ¡ uma bagunÃ§a.
//
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // O contrato Ã© stateless. Declaramos, mas nÃ£o usamos.
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "PÃ¢nico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- ES/lesson_6_enums/Cargo.toml ---
[workspace]
members=["lesson_6_1_simple"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_6_enums/Readme.md ---
# LiÃ§Ã£o 6 - Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES)

Esta liÃ§Ã£o Ã© dividida em 4 partes relacionadas a enums. Cada tÃ³pico Ã© uma crate. Aproveitaremos este momento para explicar sobre workspaces e como usÃ¡-los.

As sub-liÃ§Ãµes sÃ£o as seguintes:
 - [Declarando e usando enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/lesson_6_1_simple/).
 - Enums da biblioteca standard, Option e Result.
 - Como implementar erros de forma prÃ¡tica e eficiente.
 - Como usar enums para agrupar diversos tipos em um Ãºnico enum.

---

## Workspaces

[topo](#liÃ§Ã£o-6---enums)

Simplesmente, workspace Ã© um diretÃ³rio com vÃ¡rias crates. Quando compilados, todas as crates compartilham o mesmo diretÃ³rio target. Mas cada crate resulta em um arquivo compilado.

Algumas utilidades para uso de workspaces sÃ£o descritos a seguir:
 - DependÃªncias locais. Criamos uma crate customizada para o nosso projeto, e outra crate depende dela.
 - OrganizaÃ§Ã£o de projeto. Queremos executar testes e compilar todos os projetos simultaneamente.
 - CoordenaÃ§Ã£o de contratos. Um projeto que consiste em vÃ¡rios contratos responsÃ¡veis por diferentes funÃ§Ãµes. Um workspace pode incluir os contratos e uma crate de testes cross-contract (exemplo: [workspaces-rs](https://github.com/near/workspaces-rs)).

---

## Cargo.toml

[topo](#liÃ§Ã£o-6---enums)

O manifest possui a seÃ§Ã£o ```[workspace]```.

```toml
[workspace]
members=["lesson_6_1_simple"]
```

```members``` descreve cada crate do projeto.

**Detalhe**: Se uma crate existir neste diretÃ³rio, esta ainda serÃ¡ considerada. Para nÃ£o incluir a crate, devemos incluir o atributo ```exclude```. Como no exemplo a seguir (fonte: https://doc.rust-lang.org/cargo/reference/workspaces.html, acesso em 17-mar-2022):

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

No exemplo acima, foram incluidos 3 caminhos, e excluidos 2.

---

## CLI em workspaces

[topo](#liÃ§Ã£o-6---enums)

Se executarmos comandos como ```cargo build``` ou ```cargo test``` em uma crate que pertence a uma workspace, todos as crates serÃ£o afetadas tambÃ©m.

Para especificar o comando para apenas uma crate, adicionamos a "flag" ``` -p ```, ```--package``` ou ```--workspace``` ao comando.

Para testar ```lesson_6_1_simple``` execute:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

```--nocapture``` faz imprimir o output de todos os testes.

```--test-threads=1``` faz todos os testes serem executados em um thread. Tornando o output legivel.

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```

Os arquivos '.wasm' estarÃ£o em './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```

Gera documentaÃ§Ã£o da sub-liÃ§Ã£o 6-1 e abre no browser padrÃ£o.

 - ```--lib``` especifica que a crate Ã© um library.
 - ```--document-private-items``` pede para gerar documentaÃ§Ã£o de todos os items.
 - ```--open``` abre o website no navegador padrÃ£o.

DocumentaÃ§Ã£o estarÃ¡ em './target/doc/lesson_6_1_simple/index.html'.

---

 - A proxima sub-seÃ§Ã£o serÃ¡ sobre [declaraÃ§Ã£o e uso de enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/lesson_6_1_simple/).
 - A proxima liÃ§Ã£o serÃ¡ sobre traits.

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# LiÃ§Ã£o 6 - 1 Uso de Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/)

Essa liÃ§Ã£o descreve enums e instruÃ§Ãµes ```match```.

## API de contrato

```rust

/// Podemos usar instruÃ§Ãµes match para Strings e &str.
/// 
/// Esta funÃ§Ã£o Ã© um exemplo. 
/// 
/// Retorna 1, 2, 3, 4, 5, se o argumento for o nÃºmero.
/// 
/// Causa panic se for outro valor.
pub fn string_match_example(&self, arg: String) -> u32;

/// Retorna example_0.
pub fn get_example_0(&self) -> Example0;

/// Retorna example_1.
pub fn get_example_1(&self) -> Example1;

/// Retorna example_2.
pub fn get_example_2(&self) -> Example2User;

/// Chama Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Chama Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Chama Example1::get.
pub fn example_1_get(&self) -> String;

/// Chama Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Chama Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Chama Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Chama Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Chama Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Chama Example2User::get_actions.
/// 
/// Quando retornamos um Vec, o serializer tentarÃ¡ usar serde::json.
/// A instruÃ§Ã£o #[result_serializer] nos permite selecionar borsh como serializador.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

## Compilando, testando

Essa crate pertence ao workspace da liÃ§Ã£o 6. InstruÃ§Ãµes sobre compilaÃ§Ã£o e execuÃ§Ã£o de testes na pagina [anterior](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/lesson_6_1_simple/).

Executar comandos como ```cargo test``` e ```cargo build``` afetarÃ¡ todos as crates na workspace. A nÃ£o ser que uma crate seja especificada.

## TÃ³picos

 - O que sÃ£o enums.
 - InstruÃ§Ãµes match.
 - Exemplo 0: enums sem valores.
 - Exemplo 1: enums com primitivos.
 - Exemplo 2: usuÃ¡rios como enums.
 - InstruÃ§Ãµes match para strings.

## O que sÃ£o enums

Enquanto Structs armazenam diversos valores simultaneamente. Enums armazenam um valor de cada vez. As alternativas que um enum pode representar sÃ£o descritos na definiÃ§Ã£o.

```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```

Acima temos um exemplo de enum.
 - ```pub``` descreve que o enum estÃ¡ disponivel para ser usado em mÃ³dulos externos.
 - ```Example0``` Ã© o nome do enum.
 - ```First```, ```Second```, ```Third```, ```Fourth``` e ```Fifth``` sÃ£o os nomes dos valores que este enum pode possuir.

Acima temos a declaraÃ§Ã£o do enum, mas como criamos uma instÃ¢ncia de enum? A seguir criamos um exemplo para os 5 valores possiveis.

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```

## InstruÃ§Ãµes match

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// Imprime a funÃ§Ã£o sendo chamada.
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// Podemos usar instruÃ§Ãµes match para Strings e &str.
    /// 
    /// Esta funÃ§Ã£o Ã© um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o nÃºmero.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Retorna example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Retorna example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Retorna example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Chama Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Chama Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Chama Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Chama Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Chama Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Chama Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Chama Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Chama Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Chama Example2User::get_actions.
    /// 
    /// 
    /// Quando retornamos um Vec, o serializer tentarÃ¡ usar serde::json.
    /// A instruÃ§Ã£o #[result_serializer] nos permite selecionar borsh como serializador.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Testa situaÃ§Ã£o de erro com argumento 0.
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

// As duas funÃ§Ãµes a seguir sÃ£o declaradas para
// termos duas implementaÃ§Ãµes diferentes de uma mesma funÃ§Ã£o "log".
// As mensagens chamadas com essa funÃ§Ã£o log aparecerÃ£o 
// em testes e na mÃ¡quina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultÃ¢neos, um enum sÃ³ pode possuir um valor.
/// Os possiveis valores de um enum sÃ£o descritos em sua declaraÃ§Ã£o.
/// 
/// Os possiveis valores de Exemplo0 sÃ£o:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Semelhante a structs, implementamos mÃ©todos no namespace de Exemplo0 a seguir:
impl Example0{

    /// Observa o valor de si mesmo e retorna um nÃºmero entre 1 e 5.
    /// 
    /// Note o &self, significando que a funÃ§Ã£o acessa o valor, mas nÃ£o altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // InstruÃ§Ãµes match sÃ£o semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true se o valor for Exemplo0::THIRD
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compara os valores iniciando do topo
        // se colocarmos um nome de variavel, o branch acerta
        // e a variavel possui o valor no bloco associado.
        //
        // Uma variÃ¡vel que comeÃ§a com o caracter _ Ã© uma variÃ¡vel que
        // nÃ£o pretendemos utilizar.
        //
        // Devido a isso, _ sempre serÃ¡ "matched", as alternativas
        // abaixo nunca serÃ£o acessadas.
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // Descomente esse bloco e receberÃ¡ um aviso
            //     // Essa branch nunca serÃ¡ alcanÃ§ada
            //     // Porque a branch acima aplica a qualquer pattern.
            //     false
            // },
        }
    }
}

/// Um enum permite um objeto representar vÃ¡rios tipos diferentes:
/// 
/// Este exemplo possui o objetivo de mostrar que usar um enum como conteiner de valores nÃ£o Ã© uma boa ideia.
/// 
/// Os mÃ©todos de enum devem retornar resultados simples.
/// Tentar retirar os valores armazenados em enums para serem usados fora adiciona complexidade desnecessÃ¡ria ao cÃ³digo.
/// 
/// Use enums para agrupar tipos diferentes que compartilham uma funcionalidade semelhante.
/// 
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Porem, vale lembrar que um mÃ©todo ou funÃ§Ã£o deve retornar apenas um tipo de resultado especificado.
    //
    // Um desenvolvedor pode tentar criar uma funÃ§Ã£o get que retorna o valor armazenado.
    // Isso serÃ¡ dificil de implementar.
    // 
    // A forma mais simples de uma funÃ§Ã£o get seria converter para um mesmo tipo.
    // Seguem alguns exemplos:
    //  - Retornar o valor como String
    //  - Usar Borsh ou serde para serializar o valor para bytes, deserializando apÃ³s o recebimento.
    //  - Implementar genÃ©ricos. serÃ£o explicados em outra liÃ§Ã£o.
    //  - Retornar um ponteiro? A possibilidade disso ser necessÃ¡rio Ã© baixa. O custo de complexidade Ã© muito alto.
    // 

    // O mÃ©todo a seguir retorna apenas um tipo, isso Ã© aceitÃ¡vel para o compilador.
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    // TambÃ©m pode-se criar uma funÃ§Ã£o para retornar cada tipo.

    /// true se o valor do enum
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Retorna um inteiro, se o enum for essa alternativa.
    ///
    /// Option serÃ¡ explicado em detalhes na prÃ³xima seÃ§Ã£o.
    ///
    /// Option Ã© um enum da biblioteca padrÃ£o (standard).
    /// Representa a possibilidade de possuir um valor ou nÃ£o.
    /// Option pode ser Option::Some(valor) ou Option::None.
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // valor serÃ¡ uma referÃªncia, clonamos o valor para nÃ£o retornar uma referÃªncia.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Retorna true se possui algum numero inteiro impar,
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // NÃ£o temos interesse no segundo valor que Ã© String
                first%2 == 1
            },
        }
    }
}

/// Tipo criado para o exemplo abaixo.
/// 
/// Criado apenas para mostrar um exemplo de implementaÃ§Ã£o de struct em match.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// Exemplo mais prÃ¡tico. 
/// 
/// Representa o UsuÃ¡rio de um aplicativo.
/// 
/// Digamos que um usuÃ¡rio possa ser os seguintes tipos:
///  - Cliente
///  - Funcionario
///  - Administrador
/// 
/// Podemos controlar as permissÃµes de cada com um enum.
/// 
/// Seria melhor termos tipos struct pra cada valor, mas estamos com pressa.
/// 
/// Todos possuem nome e id, alem disso, cada um possui:
///  - Admin: passe (codificado, claro) para acesso. Lista de aÃ§Ãµes no sistema.
///  - Employee: passe (codificado) para acesso. Lista de aÃ§Ãµes. Lista de permissÃµes no sistema.
///  - Client: apenas lista de pedidos.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{

    /// Retorna nome do usuÃ¡rio.
    /// 
    /// O bloco que chama o mÃ©todo nÃ£o precisa de saber o que o usuÃ¡rio Ã©.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Checa se usuÃ¡rio possui permissÃ£o para aÃ§Ã£o.
    /// 
    /// NÃ£o Ã© uma boa ideia usar String para permissÃµes. Devido a possivel erros de caracteres, etc. Enums seriam melhor.
    /// 
    /// Mas o cÃ³digo ja estÃ¡ complexo o suficiente.
    /// 
    /// Neste exempÄºo:
    ///  - Clientes nÃ£o possuem permissÃ£o. Sempre retorna falso.
    ///  - Administradores sempre possuem permissÃ£o. Sempre retorna true.
    ///  - Empregados podem ou nÃ£o possuir permissÃ£o. Checa por permissÃµes.
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implementa a trait IntoIterator.
                // Isso disponibiliza o mÃ©todo .iter ao vetor.
                // Este mÃ©todo nos permite iterar referencias de String.
                // Nenhuma cÃ³pia de String Ã© feita.
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Retorna a lista de aÃ§Ãµes se for Admin ou Employee.
    /// 
    /// Como exemplo, digamos que o design de projeto necessita de retornar
    /// um erro, se o usuÃ¡rio for um Client.
    /// 
    /// Result Ã© semelhante a Option. Mas Ã© usado para representar aÃ§Ãµes que podem causar erros.
    /// Explicado na proxima sub-seÃ§Ã£o.
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // Se for client, retorna um erro (Como exemplo).
        // Se for admin ou employee, retorna referencia para o Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Usa a referÃªncia para criar uma cÃ³pia do Vec.
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Cria 6 instÃ¢ncias diferentes de Example1 para servir de exemplo.
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Retorna uma tupla com um exemplo de cada um dos valores.
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Garante que a funÃ§Ã£o get retorna as Strings esperadas.
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    /// Garante que apenas retorna true para no_value.
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Cria 3 instÃ¢ncias diferentes de Example2User para serem usadas nos testes.
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa get_name para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // Garante que o valor adiquirido para os 3 Ã© "Lucas"
        // Detalhe extra: Estamos comparando um String com um &str,
        // isso Ã© possivel porque implementam a trait partial_eq para os tipos.
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    // pub fn get_actions(&self) -> Result<Vec<String>, String> {
    
    #[test]
    fn example2_get_actions(){

        // FunÃ§Ã£o para comparar vetores
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // Ambos os vetores devem ter o mesmo nÃºmero de elementos
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // Garante que a funÃ§Ã£o retorna um Ok contendo os respectivos valores.
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // Mesmo para employee.
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // No caso de client, garante que retorna um erro.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- ES/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- ES/static/tutorials/cargo.md ---
# IntroduÃ§Ã£o a Cargo

Cargo Ã© a ferramenta que usamos para administrar nossos projetos da linguagem rust. DocumentaÃ§Ã£o completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que Ã© crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informaÃ§Ãµes meta sobre este diretÃ³rio. CaracterÃ­sticas como nome e versÃ£o, mas tambÃ©m configuraÃ§Ãµes sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrÃ£o. Identico ao Cargo.toml da liÃ§Ã£o 1.](../images/cargo.png)

NÃ£o Ã© necessÃ¡rio saber tudo sobre essas configuraÃ§Ãµes. As configuraÃ§Ãµes que precisaremos alterar sÃ£o ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tÃ³picos principais:
 - **package**: ConfiguraÃ§Ãµes sobre a crate. Nome, versÃ£o, licensa, ediÃ§Ã£o do Rust, etc; 
 - **lib**: Isso determina que esta crate nÃ£o Ã© um executÃ¡vel. E sim Ã© uma biblioteca que serÃ¡ acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configuraÃ§Ãµes.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrÃ£o Ã© vindo do site "crates.io", mas podemos tambÃ©m incluir crates locais; podemos incluir atravÃ©s de um link github, etc.
 - **profile.release**: ConfiguraÃ§Ã£o para projetos compilados para "release". NÃ£o Ã© necessÃ¡rio entender cada instruÃ§Ã£o. Simplesmente fala para o compilador tentar optimizar o mÃ¡ximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que Ã© crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretÃ³rio com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretÃ³rio "target" com o arquivo compilado. Mas se criarmos um workspace, que Ã© um conjunto de vÃ¡rias crates compartilhando um "Cargo.toml", os arquivos compilados sÃ£o todos agrupados na mesma pasta. Para mais detalhes, cheque a liÃ§Ã£o sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

DependÃªncias como ```near_sdk``` sÃ£o baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condiÃ§Ã£o**: Deve ser open-source.

O site intencionalmente nÃ£o disponibiliza opÃ§Ã£o para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versÃ£o do registry usando o comando "yank", projetos nÃ£o poderÃ£o mais baixar a versÃ£o, mas ainda continuarÃ£o funcionando se tiverem a versÃ£o baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

SÃ³ isso. Existem vÃ¡rios outros comandos que podemos executar com cargo. Mas nÃ£o sÃ£o necessÃ¡rios para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilaÃ§Ã£o feitas para auxiliar o debug e otimiza o cÃ³digo para produÃ§Ã£o
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estarÃ¡ no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instruÃ§Ã£o irÃ¡ resultar em **erro** se nÃ£o instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instruÃ§Ã£o (apenas uma vez para cada instalaÃ§Ã£o de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma funÃ§Ã£o possui o marcador ```#[test]```, essa funÃ§Ã£o serÃ¡ executada.

Testes de unidade simplesmente procuram por situaÃ§Ãµes de pÃ¢nico. Se um pÃ¢nico inesperado acontece, ou um pÃ¢nico esperado nÃ£o acontece, o teste falha.

Macros como panic, assert e assert_eq sÃ£o usados para garantir nossas condiÃ§Ãµes.
 - ```panic!("Mensagem");```: Causa pÃ¢nico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pÃ¢nico se a condiÃ§Ã£o for falsa. EstÃ¡ "garantindo" que a condiÃ§Ã£o serÃ¡ verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pÃ¢nico com a dada mensagem.

Exemplo de situaÃ§Ã£o em que nÃ£o esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 Ã© sempre igual a 2. EntÃ£o nunca haverÃ¡ panic.

Exemplo de situaÃ§Ã£o em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este Ã© um exemplo da "liÃ§Ã£o 4 - mÃ³dulos". A funÃ§Ã£o ```this_will_panic()``` Ã© uma funÃ§Ã£o que eu criei que sempre causa pÃ¢nico.

```#[should_panic]``` significa que o teste vai falhar se nÃ£o entrar em panic. ```expected``` especifica qual a mensagem de pÃ¢nico esperada.

Isso Ã© tudo sobre testes para contrato. Para simular a comunicaÃ§Ã£o entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma pÃ¡gina de web com a documentaÃ§Ã£o do projeto. Muito fÃ¡cil de compartilhar. A pagina de web estarÃ¡ no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
IrÃ¡ abrir a pagina de web no navegador padrÃ£o.

![](../images/cargodoc.png)

Clique em Contract para ver as funÃ§Ãµes implementadas:

![](../images/cargodoccontract.png)

ComentÃ¡rios com ```//``` nÃ£o aparecem na documentaÃ§Ã£o.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

'''
'''--- ES/static/tutorials/nearcli.md ---
# IntroduÃ§Ã£o a near-cli

Near CLI ("command line interface") Ã© a ferramenta que utilizamos para interagir com o protocolo blockchain. DocumentaÃ§Ã£o completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funÃ§Ãµes em contratos inteligentes de outras contas, criar chaves de acesso com certas permissÃµes, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas nÃ£o Ã© obrigatÃ³rio para que essa exista. Cada conta ou sub-conta NEAR sÃ³ pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissÃµes administrativas) de vÃ¡rias sub-contas.

Ou seja, quando precisarmos de implementar vÃ¡rios contratos, podemos distribui-los em uma hierarquia de diversas contas com maior seguranÃ§a. As subcontas sÃ³ precisam das permissÃµes necessÃ¡rias para seus objetivos. As subcontas sÃ³ precisam da quantidade de gas necessÃ¡rias para se manterem em operaÃ§Ã£o.

**gas**: Ã‰ NEAR gasto para computaÃ§Ã£o, armazenamento de dados, criaÃ§Ã£o de contas, etc. A cada clock de computaÃ§Ã£o, uma fraÃ§Ã£o de NEAR Ã© consumida da conta. As mÃ¡quinas que mantÃ©m nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** Ã© consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando InicializaÃ§Ã£o Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar FunÃ§Ãµes de Contrato](#executando-funÃ§Ãµes-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando Ã  plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

NÃ£o Ã© a nossa mÃ¡quina que executa as funÃ§Ãµes de contrato descentralizadas. A nossa conta na blockchain que faz isso. NÃ³s conectamos a uma conta testnet com este comando.

**testnet**: Ã© uma plataforma de teste NEAR. Os tokens nÃ£o tem valor e nÃ£o Ã© possivel comercializÃ¡-los. A plataforma oficial Ã© a **mainnet**. Garanta que nÃ£o hÃ¡ riscos no contrato antes de implementar para produÃ§Ã£o.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. Ã‰ informaÃ§Ã£o pÃºblica.

![Imagem de terminal apÃ³s o uso do comando acima.](../images/nearstate.png)

Lembrar que esta Ã© uma conta **testnet**. NÃ£o Ã© dinheiro de verdade. Os atributos que conseguimos sÃ£o estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10Â²â´ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de cÃ³digo for uma sequÃªncia de "1", entÃ£o nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informaÃ§Ãµes sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviarÃ¡ 10 NEAR para a subconta;

Para criar uma conta de topo nÃ­vel, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

ApÃ³s compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato serÃ¡ a trait ```Default``` que implementamos no cÃ³digo rust. Essa trait nÃ£o recebe parÃ¢metros para inicializaÃ§Ã£o. Se quisermos usar um construtor com parÃ¢metros de inicializaÃ§Ã£o, precisamos de seguir dois passos:

O primeiro passo Ã© declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da funÃ§Ã£o ```new``` nÃ£o Ã© obrigatÃ³rio. Mas Ã© convenÃ§Ã£o criar construtores com este nome.

O segundo passo Ã© incluir os parÃ¢metros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a funÃ§Ã£o e argumentos, respectivamente.

O comando de implantaÃ§Ã£o poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicializaÃ§Ã£o sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` Ã© um requisito para o funcionamento do contrato, mesmo se nÃ£o pretendermos utilizÃ¡-la. Se a inicializaÃ§Ã£o com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pÃ¢nico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" sÃ£o descritos a seguir:

Na implementaÃ§Ã£o de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaraÃ§Ã£o de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funÃ§Ãµes do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funÃ§Ãµes de contrato:
 - **view**: NÃ£o realiza computaÃ§Ã£o e nÃ£o altera estado do contrato. NÃ£o consome gÃ¡s. Ou seja, Ã© de graÃ§a.
 - **call**: Todos os outros tipos de funÃ§Ã£o. Consomem gÃ¡s. Podem necessitar um pagamento. A implementaÃ§Ã£o da funÃ§Ã£o pode incluir outras restriÃ§Ãµes, como restriÃ§Ãµes de chave, restriÃ§Ãµes de usuÃ¡rio, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos sÃ£o publicos.

Se uma funÃ§Ã£o simplesmente retorna um valor armazenado no estado, entÃ£o pode ser uma funÃ§Ã£o view. FunÃ§Ãµes view nÃ£o consomem gÃ¡s, e nÃ£o precisam de pagamento.

FunÃ§Ãµes view nÃ£o podem realizar nenhum cÃ¡lculo, e nÃ£o podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo sÃ£o exemplos vÃ¡lidos para funÃ§Ãµes view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String nÃ£o implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicaÃ§Ã£o sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cÃ³pia desse tipo com o mÃ©todo ```clone()```. Se um tipo implementar Copy, a cÃ³pÃ­a serÃ¡ feita automaticamente quando necessÃ¡rio. A instruÃ§Ã£o seguinte para i32:

```rust
return self.counter;
```

Se counter nÃ£o implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereÃ§o de variÃ¡vel para outro lugar. Counter nÃ£o teria um valor, pois a "ownership" foi perdida. O compilador nÃ£o irÃ¡ permitir essa transferÃªncia.

O exemplo a seguir **nÃ£o** pode ser funÃ§Ã£o view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a funÃ§Ã£o simplesmente retorna um nÃºmero, Ã© ainda considerada computaÃ§Ã£o. Relembrando, funÃ§Ãµes view apenas retornam o valor de um estado do contrato (que Ã© informaÃ§Ã£o pÃºblica).

#### Executando uma funÃ§Ã£o view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de funÃ§Ã£o que nÃ£o Ã© ```view```, Ã© ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de funÃ§Ã£o ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "liÃ§Ã£o 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a funÃ§Ã£o da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento Ã© o nome da sub-conta a deletar. O segundo argumento Ã© o nome da conta que irÃ¡ receber todo o NEAR armazenado.

'''
'''--- ES/static/tutorials/rust.md ---
# InstalaÃ§Ã£o Rust

Este tutorial descreve a instalaÃ§Ã£o das ferramentas recomendadas para criaÃ§Ã£o de projetos NEAR em Rust.

 - [Scripts de InstalaÃ§Ã£o](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos vÃ¡rias ferramentas diferentes com uma Ãºnica linha de comando. Ã€s que destacaremos nesse tutorial sÃ£o: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o cÃ³digo rust para linguagem de mÃ¡quina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentaÃ§Ã£o, realizar testes de unidade, executar projeto como binÃ¡rio.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versÃµes. rustup controla estas versÃµes.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

Ã‰ apenas uma analogia, existem algumas diferenÃ§as que serÃ£o encontradas em pratica.

## Scripts de instalaÃ§Ã£o
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalaÃ§Ã£o de Rust. A primeira Ã© recomendada para estudo, a segunda Ã© recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessÃ¡rias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositÃ³rio](https://github.com/rust-lang/rustlings) e siga as instruÃ§Ãµes de instalaÃ§Ã£o.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalaÃ§Ã£o
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissÃµes de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessÃ¡rias.

'''
'''--- ES/static/tutorials/setup-nearcli.md ---
# InstalaÃ§Ã£o NEAR CLI

NEAR CLI (NEAR Command Line Interface) Ã© utilizado para fazer login e interagir com contas NEAR.

Uma explicaÃ§Ã£o detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos sÃ£o descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descriÃ§Ãµes do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- PT-BR/README.md ---
# Tutorial_NEAR_Rust

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

Tutorial em etapas para desenvolvimento de contratos inteligentes em rust. Neste conjunto de tutoriais serÃ£o discutidos todas as principais caracterÃ­sticas da linguagem, assim como seu uso na plataforma NEAR.

---

## Contato

[topo](#tutorial_near_rust)

Para dÃºvidas, reclamaÃ§Ãµes ou sugestÃµes, por favor me adicione no discord On0n0k1#3800. Se este tutorial facilitar a sua vida, considere comprar um cafÃ© para mim enviando uma fraÃ§Ã£o de NEAR para stiltztinkerstein.near .

---

## TÃ³picos

[topo](#tutorial_near_rust)

 - [O Que Ã© a linguagem Rust](#o-que-Ã©-a-linguagem-rust)
 - [Usos da linguagem Rust](#usos-da-linguagem-rust)
 - [Aprendendo a Linguagem Rust](#aprendendo-a-linguagem-rust)
 - [ComparaÃ§Ãµes com Javascript e Python](#compara%C3%A7%C3%B5es-com-javascript-e-python)
 - [InstalaÃ§Ã£o](#instala%C3%A7%C3%A3o)
 - [LiÃ§Ãµes](#li%C3%A7%C3%B5es)

---

## O que Ã© a linguagem Rust

[topo](#tutorial_near_rust)

De forma bem resumida, Ã© uma linguagem de programaÃ§Ã£o de baixo nÃ­vel com as seguintes caracterÃ­sticas:

 - ExecuÃ§Ã£o aproximadamente tÃ£o rÃ¡pida quanto linguagem c ou c++.
 - NÃ£o tem os riscos de vazamento de memÃ³ria que outras linguagens de baixo nÃ­vel possuem.
 - Ã‰ dificil de comeÃ§ar a aprender.
 - NÃ£o **usa** e nem **precisa** de coleta de lixo de memÃ³ria. Pois no periodo de compilaÃ§Ã£o, o compilador sabe exatamente quando variÃ¡veis sÃ£o criadas e liberadas.
 - Processamento em paralelo Ã© fÃ¡cil.
 - Processamento assÃ­ncrono Ã© de dificuldade semelhante a outras linguagens populares.
 - Muito mais simples organizaÃ§Ã£o de projeto e dependÃªncias do que python e javascript.
 - Ganhou repetidos anos consecutivos como a linguagem mais popular do stackoverflow.

---

## Usos da linguagem Rust

[topo](#tutorial_near_rust)

Um desenvolvedor Rust pode:

 - Criar apps decentralizados em plataformas web3 como NEAR.
 - Pode criar aplicativos que nÃ£o precisam de uma mÃ¡quina virtual para serem executados. Precisa do compilador Rust para compilar, mas nÃ£o precisa para executar.
 - Criar servidores compactos e rÃ¡pidos em conteineres docker.
 - Criar aplicaÃ§Ãµes potentes como funÃ§Ãµes lambda para serem implantados em servidores aws (web3 Ã© melhor porÃ©m).
 - Usar o linker para criar bibliotecas que podem ser usadas por um compilador como c.
 - Compilar bibliotecas que podem ser importadas em um browser javascript ou em um runtime nodejs com o formato WebAssembly.
 - Compilar bibliotecas potentes e eficientes para Python usando a crate PyO3.
 - Compilar cÃ³digo para dispositivos embarcados (embedded).
 - Competir em um mercado de trabalho que possui 1 ou 2 inscritos por vaga (incluindo internacional).

---

## Aprendendo a linguagem Rust
[topo](#tutorial_near_rust)

No meu ponto de vista, aprender a linguagem rust Ã© semelhante a idÃ©ia de domar um dragÃ£o em um mundo de fantasia. Ã‰ demorado, Ã© dificil, existem muitas alternativas diferentes e mais simples do que essa. Mas, se conseguir, vocÃª vai ter um terrÃ­vel dragÃ£o ao seu lado.

Existem estudos que destacaram que o tempo para escrever uma certa quantidade de linhas de cÃ³digo em linguagens de baixo nÃ­vel (como c) Ã© atÃ© 30 vezes mais devagar do que as de alto nÃ­vel (como python e javascript). Pela minha prÃ¡tica, Ã© mais demorado ainda para uma pessoa aprendendo Rust escrever cÃ³digo do que c. 

Mas, com prÃ¡tica, ficamos mais Ã¡geis em tudo. Com o tempo acostumamos com o que o compilador precisa e espera de nÃ³s. Podemos tambÃ©m configurar snippets para gerar cÃ³digos de "boilerplate" (forma) automaticamente. EntÃ£o, Ã© apenas uma questÃ£o de entendimento, memorizaÃ§Ã£o e paciÃªncia para o desenvolvedor. Houveram vezes em que eu escrevi 800 linhas de cÃ³digo Rust em 2 dias.

Quase sempre teremos que dar pausas para estudar o nosso mÃ©todo e garantir que estamos fazendo as decisÃµes corretas. PorÃ©m, cada tentativa seguinte serÃ¡ mais fÃ¡cil que a anterior.

---

## ComparaÃ§Ãµes com javascript e Python

[topo](#tutorial_near_rust)

PorÃ©m uma pessoa astuta perguntaria "Porque eu iria aprender uma linguagem dessas se eu ja posso resolver os mesmos problemas com as linguagens que sei?" . Ã‰ uma Ã³tima pergunta, se eu ja posso conseguir o resultado escrevendo algumas linhas de cÃ³digo em python no terminal, porque eu iria querer aprender Rust?

Facilidade de uso e resoluÃ§Ã£o de problemas. Este Ã© o foco principal dessas linguagens. Como conseguir a soluÃ§Ã£o para o nosso problema da forma mais simples possivel. Os processadores ficavam cada vez mais rÃ¡pido cada geraÃ§Ã£o, entÃ£o bastava comprar as geraÃ§Ãµes de hardware mais recentes.

PorÃ©m a lei de Moore nÃ£o se aplica mais. Os desenvolvedores estÃ£o precisando de algoritmos mais eficientes. Esta necessidade nos faz olhar para nossas linhas de cÃ³digo e perguntar "O que estÃ¡ instruÃ§Ã£o estÃ¡ fazendo exatamente?"

Quando escrevemos uma instruÃ§Ã£o em python "a = 3". A mÃ¡quina virtual python estÃ¡ criando um objeto numero, criando um ponteiro mutex que aponta para o numero, e associando "a" a este ponteiro. Por isso que python normalmente Ã© limitado a um core do processador. Quando tentamos aproveitar mais a capacidade de processamento de nossa mÃ¡quina, a complexidade de cÃ³digo em javascript e python cresce exponencialmente.

O foco da linguagem Rust nÃ£o Ã© o resultado final dessa execuÃ§Ã£o. E sim, o caminho que o processador e memÃ³ria levam atÃ© alcanÃ§ar este resultado. Um(a) desenvolvedor(a) rust experiente sabe olhar um bloco de cÃ³digo e dizer:
 - "Essa memÃ³ria vai ser liberada nessa linha de cÃ³digo";
 - "O processador irÃ¡ pedir pra liberar um espaÃ§o de memÃ³ria nessa linha e criar uma cÃ³pia dessa variÃ¡vel aqui.";
 - "Essa funÃ§Ã£o irÃ¡ pegar esse endereÃ§o emprestado, usar este valor nessa parte, e retornar o endereÃ§o para o dono ao fim.";

---

## InstalaÃ§Ã£o

[topo](#tutorial_near_rust)

Antes de comeÃ§armos, devemos realizar os seguintes passos:

 - Instalar [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/setup-nearcli.md) para interagir com a plataforma NEAR.
 - Instalar [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/rust.md) para compilar e testar os projetos.

---

## LiÃ§Ãµes

[topo](#tutorial_near_rust)

 - [LiÃ§Ã£o 1: Contratos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_1_contract)
 - [LiÃ§Ã£o 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_2_ownership)
 - [LiÃ§Ã£o 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_3_structs)
 - [LiÃ§Ã£o 4: MÃ³dulos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_4_modules)
 - [LicÃ£o 5: Usando Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_5_macro_usage)
 - [LiÃ§Ã£o 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums)
 - LiÃ§Ã£o 7: Traits
 - LiÃ§Ã£o 8: ColeÃ§Ãµes

'''
'''--- PT-BR/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_1_contract/Readme.md ---
# LiÃ§Ã£o 1: Contrato

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Veja tambÃ©m:
 - Usos da [ferramenta cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md).
 - Usos da [ferramenta near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/nearcli.md).

---

## TÃ³picos
 - [Estrutura de um contrato NEAR](#estrutura-de-um-contrato-near)
 - [Importar DependÃªncias](#importar-depend%C3%AAncias)
 - [Macro de AlocaÃ§Ã£o](#macro-de-aloca%C3%A7%C3%A3o)
 - [DeclaraÃ§Ã£o de Contrato](#declara%C3%A7%C3%A3o-de-contrato)
 - [DeclaraÃ§Ã£o de API do Contrato](#declara%C3%A7%C3%A3o-de-api-do-contrato)
 - [Testes de Unidade](#testes-de-unidade)

---

## Estrutura de um contrato NEAR
[topo](#li%C3%A7%C3%A3o-1-contrato)

Um contrato NEAR na linguagem Rust pode ser resumido aos seguintes passos:
 - Importar crates, mÃ³dulos e outras dependÃªncias necessÃ¡rias.
 - Macro de alocaÃ§Ã£o.
 - DeclaraÃ§Ã£o de contrato.
 - DeclaraÃ§Ã£o de api do contrato.
 - Testes de unidade.

O desenvolvedor Ã© livre para adicionar o que julgar necessÃ¡rio ao projeto. Os passos acima sÃ£o apenas para acelerar a memorizaÃ§Ã£o.

---

### Importar DependÃªncias
[topo](#li%C3%A7%C3%A3o-1-contrato)

Isto Ã© explicado em detalhes na "liÃ§Ã£o 4 - mÃ³dulos". SÃ³ precisamos saber sobre as diferenÃ§as entre mod e use. Por exemplo:

```rust
use near_sdk::near_bindgen;
```

Acessa a crate near_sdk e inclui o macro near_bindgen neste namespace. Sem isso, precisariamos escrever "near_sdk::near_bindgen" todas as vezes que precisarmos deste elemento. Mas agora podemos simplesmente escrever "near_bindgen".

Por outro lado, a instruÃ§Ã£o:

```rust
mod outro_modulo;
```

Significa que existe um arquivo de nome "outro_modulo.rs" ou um diretÃ³rio com o nome "outro_modulo" no mesmo diretÃ³rio deste arquivo rust. Para mais detalhes, procure por lesson_4_modules.

Se houvesse pub antes da instruÃ§Ã£o, como os exemplos:

```rust
pub mod outro_modulo;
```

Ou:

```rust
mod outro_modulo;

pub use outro_modulo::alguma_dependencia;
```

Demonstram que "outro_modulo" e "alguma_dependencia" podem ser importados por um outro mÃ³dulo ou crate (projeto rust) externos. 

Para mais detalhes, procure por lesson_4_modules. Importar e exportar mÃ³dulos Ã© uma caracterÃ­stica da linguagem Rust. NÃ£o tem nenhum efeito direto na plataforma NEAR.

Agora, referindo ao contrato:

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

Estamos acessando a crate "near_sdk" declarado em "Cargo.toml". Importando self, BorshDeserialize e BorshSerialize no mÃ³dulo borsh. E importando near_bindgen. Seguem as descriÃ§Ãµes simplificadas:

 - **self**: Nem eu sei exatamente o que isso faz, mas Ã© necessÃ¡rio para BorshDeserialize e BorshSerialize funcionarem corretamente.
 - **BorshDeserialize**: Quando chamamos uma funÃ§Ã£o do nosso contrato, devemos enviar parÃ¢metros. Mesmo que estes parÃ¢metros sejam um json vazio, este deve ser deserializado. Este Ã© o objetivo de BorshDeserialize, recebe um json em texto, transforma nos tipos que precisamos.
 - **BorshSerialize**: Caminho inverso do BorshDeserialize. Quando vamos retornar um resultado para o usuÃ¡rio, devemos transformar aquele valor para um json em texto.
 - **near_bindgen**: Isso Ã© um marcador para um struct que diz **"Este Ã© o contrato principal do nosso projeto"**. Damos o nome "Contract" apenas para facilitar o entendimento, nÃ£o Ã© obrigatÃ³rio. PorÃ©m deve-se ter pelo menos um struct com **near_bindgen** em cada contrato.

---

### Macro de alocaÃ§Ã£o
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
near_sdk::setup_alloc!();
```

Macros parecem com funÃ§Ãµes. Mas sÃ£o executadas antes da compilaÃ§Ã£o. SÃ£o ferramentas para gerar cÃ³digo de acordo com os parÃ¢metros. Macros nÃ£o existem no runtime do programa.

Neste caso, "setup_alloc" gera o cÃ³digo "boilerplate" (forma) para o funcionamento do nosso contrato. SÃ³ deve ser executado uma vez, antes da declaraÃ§Ã£o do contrato.

Aviso: Nas prÃ³ximas versÃµes esta instruÃ§Ã£o serÃ¡ deprecada. NÃ£o serÃ¡ necessÃ¡rio usar mais.

---

### DeclaraÃ§Ã£o de contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```

SerÃ¡ mais fÃ¡cil descrever de dentro para fora.
 - **counter**: Ã© um nÃºmero. i32 quer dizer que Ã© "signed", pode ser positivo ou negativo. 32 quer dizer que Ã© um nÃºmero de 32 bits.
 - **pub struct Contract**: Ã© a declaraÃ§Ã£o de um struct de nome Contract. "pub" quer dizer que este struct Ã© pÃºblico.
 - **#[derive(BorshDeserialize, BorshSerialize)]**: Simplificando, aplica as traits BorshDeserialize e BorshSerialize neste struct. Descritos acima.
 - **[near_bindgen]**: Ã‰ um marcador que diz "Este Ã© o Contrato". As funÃ§Ãµes deste struct sÃ£o as funÃ§Ãµes do contrato. Quando executamos uma funÃ§Ã£o do contrato, executamos uma funÃ§Ã£o deste struct.

Logo a seguir temos tambÃ©m:

```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

Default Ã© uma trait (caracterÃ­stica) de "padrÃ£o". Ã‰ praticamente um construtor sem parÃ¢metros para o nosso struct. Mas, Default Ã© uma trait padronizada da linguagem Rust. near_sdk usa essa trait no funcionamento do nosso contrato. EntÃ£o precisamos aplicar ao nosso contrato, senÃ£o teremos um erro de compilaÃ§Ã£o.

default Ã© uma funÃ§Ã£o da trait Default que retorna um struct do mesmo tipo Self. Self nesta declaraÃ§Ã£o Ã© o mesmo que Contract. A funÃ§Ã£o retorna uma instÃ¢ncia de Contract com o valor de counter igual a 0.

Se implementarmos este contrato em uma conta NEAR, e depois executarmos uma primeira funÃ§Ã£o que nÃ£o seja de inicializaÃ§Ã£o. A mÃ¡quina irÃ¡ inicializar o contrato com  default antes de executar nossa funÃ§Ã£o.

---

### DeclaraÃ§Ã£o de API do contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

A seguir se encontram as funÃ§Ãµes do smart contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - ```#[near_bindgen]``` Ã© um marcador que diz "estas sÃ£o as funÃ§Ãµes do contrato".
 - ```impl Contract``` Ã© onde declaramos as funÃ§Ãµes e mÃ©todos associados ao struct Contract.
 - ```&self``` e ```&mut self``` sÃ£o descritos na liÃ§Ã£o seguinte. SÃ³ precisamos saber que esse tipo de funÃ§Ã£o Ã© invocada no formato ```nome_do_struct.nome_da_funcao```, self neste caso se refere a instÃ¢ncia existente deste struct.
 - ```-> i32``` significa que a funÃ§Ã£o retorna um inteiro i32.
 - No fim da funÃ§Ã£o temos uma linha ```self.counter``` sem ponto-virgula ";". Isso Ã© o mesmo que ```return self.counter```.

Com estes detalhes, vemos que a funÃ§Ã£o ```get``` retorna o valor atual de counter armazenado no struct do contrato. ```increment``` incrementa o valor de counter em 1. ```decrement``` reduz o valor de counter em 1.

---

### Testes de unidade
[topo](#li%C3%A7%C3%A3o-1-contrato)

Descrito com mais detalhes na liÃ§Ã£o 4 - mÃ³dulos, nÃ£o Ã© necessÃ¡rio ter todos os testes do projeto aqui. Podemos incluir testes no fim de cada mÃ³dulo rust. Podemos tambÃ©m criar um diretÃ³rio ```tests```. Todos os arquivos ".rs" na pasta ```tests``` serÃ¡ considerado um mÃ³dulo de testes.

```rust
#[cfg(test)]
mod tests{
```

```mod tests``` Ã© simplesmente um mÃ³dulo local com nome tests. Nada de especial.

```#[cfg(test)]``` este Ã© bem interessante. ```cfg``` Ã© uma instruÃ§Ã£o que diz ao compilador "Compile o mÃ³dulo abaixo de mim apenas se a condiÃ§Ã£o entre parenteses for verdadeira.". ```(test)``` Ã© verdadeiro quando executamos ```cargo test```. Se nÃ£o estivermos realizando testes de unidade, este mÃ³dulo nÃ£o existe.

Se em vez de ```#[cfg(test)]``` tivÃ©ssemos:

```rust
#[cfg(not(test))]
mod another_module{
```

Teriamos a situaÃ§Ã£o oposta, este mÃ³dulo nÃ£o seria compilado durante testes de unidade.

```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
Acima importamos as dependÃªncias usadas nos testes abaixo.

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Erro assert.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Antes de cada teste, precisamos iniciar uma simulaÃ§Ã£o do ambiente de blockchain. Uma das formas de fazer isso Ã© utilizando ```VMContextBuilder```. Basta criar uma instÃ¢ncia desse tipo, alterar os atributos que queremos, e usar o builder como argumento para o macro ```testing_env```.

Para nÃ£o termos que escrever estas linhas em cada teste, criamos uma funÃ§Ã£o para ser usada.

```assert_eq``` nÃ£o Ã© necessÃ¡rio. SÃ³ mostra que o atributo de ambiente ```env::current_account_id``` Ã© o mesmo id de conta que escolhi para o builder.

A seguir teremos os trÃªs testes: 

```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

Percebe-se um padrÃ£o em cada um dos testes:
 - Inicializar o ambiente;
 - Inicializar o contrato;
 - Executar a funÃ§Ã£o que queremos testar;
 - Confirmar que a funÃ§Ã£o deu o resultado que esperamos;

A funÃ§Ã£o ```get``` foi testada primeiro. Isto porque esta serÃ¡ usada nos testes seguidos. Se esta funÃ§Ã£o nÃ£o funcionasse da forma que esperassemos, temos que ver este erro primeiro na lista. Bom para evitar confusÃµes nos testes. 

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_2_ownership) serÃ¡ sobre ownership.

'''
'''--- PT-BR/lesson_1_contract/src/lib.rs ---
//! Fonte <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Dicas sobre documentaÃ§Ã£o:
// comentarios com // nÃ£o aparecem na documentaÃ§Ã£o.
// comentarios com /// aparecem como descriÃ§Ã£o para o que estiver a seguir (mod, fn, struct, enum, trait...)
// comentarios com //! podem apenas existir no inicio do arquivo, representam a descriÃ§Ã£o de todo o mÃ³dulo.

// mÃ³dulos importados
use near_sdk::{
    // ParÃ¢metros recebidos e valores retornados sÃ£o convertidos para json com esse mÃ³dulo
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Cria o boilerplate necessÃ¡rio para mÃ¡quinas virtuais NEAR
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Contrato. Este struct contÃ©m o estado (state) da mÃ¡quina virtual.
/// As funÃ§Ãµes deste struct sÃ£o as funÃ§Ãµes do contrato.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Contador.
    counter: i32
}

// Default Ã© executado quando o contrato nÃ£o inicializado manualmente.
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Retorna o contador.
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Incrementa o contador em 1.
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decrementa o contador em 1.
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Nossos testes de unidade ficam aqui.
// cfg(test) quer dizer que esse mod sÃ³ serÃ¡ compilado em ambientes de teste.
#[cfg(test)]
mod tests{
    // super::* importa todos os mÃ³dulos acima.
    use super::*;
    // alguns mÃ³dulos que sÃ³ usaremos em situaÃ§Ãµes de teste
    use near_sdk::{
        // um id de conta como por exemplo "stiltztinkerstein.near"
        AccountId,
        // possui mÃ©todos relacionados ao ambiente de execuÃ§Ã£o.
        // por exemplo, se quisermos saber o nome do usuÃ¡rio que executou
        // esse contrato, usaremos uma funÃ§Ã£o no mÃ³dulo env.
        env,
        // Simula o blockchain
        MockedBlockchain,
        // Macro que inicializa o ambiente de text com o contexto informado.
        testing_env,
        // Usado para criar um contexto de teste.
        test_utils::VMContextBuilder,
        // Simplesmente representa um Id de Conta valido.
        // Um id de conta Ã© um string, mas nÃ£o Ã© todo string que Ã© um id vÃ¡lido.
        json_types::ValidAccountId,
    };

    /// Essa funÃ§Ã£o nÃ£o Ã© um teste. Ã‰ usada pelos testes para simular
    /// um ambiente de teste.
    fn env_setup(){
        // inicializa um construtor de contexto de teste.
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podem ser editados com o builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // string com nome account_id
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tenta converter o string acima para um id valido
            // panic se o id Ã© invalido.
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // inicializa simulaÃ§Ã£o
        testing_env!(builder.build());

        // Se os dois primeiros parametros nÃ£o sÃ£o iguais, 
        // retorna a mensagem de erro seguinte.
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// Como tem o marcador #[test] vai executar automaticamente
    /// quando realizarmos testes de unidade.
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- PT-BR/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_2_ownership/Readme.md ---
# LiÃ§Ã£o 2: Ownership

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Este curto tutorial possui o objetivo de explicar sobre ownership.

---

## FunÃ§Ãµes de Contrato

```rust
/// Retorna o comprimento da String armazenada
pub fn get_length(&self) -> u32;

/// Retorna o comprimento da String e altera o nome armazenado para "Changed name"
pub fn get_length_again(&mut self) -> u32;
```

---

## HipÃ³tese

Ownership Ã© explicado na seÃ§Ã£o seguinte. Esta discute o problema que ownership soluciona.

Consideremos a instruÃ§Ã£o exemplo a seguir:

```
A = B;
```

Sabemos que A Ã© igual a B. A recebe o valor de B. Mas o que estÃ¡ acontecendo? 

Estamos criando uma cÃ³pia do valor de B e associando A a este valor? Criar uma cÃ³pia significa requisitar alocaÃ§Ã£o de memÃ³ria, adiquirir o endereÃ§o da memÃ³ria e igualar o valor desse endereÃ§o ao valor de B. Para um nÃºmero inteiro isso parece simples, mas e se fosse uma string de 2 mil caracteres?

E se usarmos uma variÃ¡vel como parÃ¢metro de funÃ§Ã£o. Estariamos criando uma cÃ³pia da variÃ¡vel e depois apagando a cÃ³pia no fim da funÃ§Ã£o?

Percebe-se que precisamos de uma forma de reutilizar o mesmo endereÃ§o de memÃ³ria em vÃ¡rias partes diferentes do programa. A linguagem C solucionou isso atravÃ©s do uso de ponteiros. Em vez de armazenarmos o valor da variÃ¡vel, nÃ³s armazenamos o endereÃ§o de memÃ³ria daquele tipo de variÃ¡vel.

Mas isso nos trÃ¡s outro problema. Se uma funÃ§Ã£o tem acesso ao endereÃ§o de memÃ³ria de uma variÃ¡vel importante, essa funÃ§Ã£o agora tem muito poder. E se o mÃ©todo foi implementado de uma forma insegura? Um hacker poderia aproveitar essa falha de seguranÃ§a para acessar um sistema.

 - Precisamos de uma forma de reutilizar memÃ³ria para evitar sobrecarregar o sistema com operaÃ§Ãµes desnecessÃ¡rias.
 - Mas precisamos evitar que esse uso de memÃ³ria dÃª mais poder as instruÃ§Ãµes do que Ã© necessÃ¡rio.

**Extra:** Ponteiros existem em Rust tambÃ©m. Mas existem vÃ¡rios tipos de ponteiros, com diferentes vantagens e desvantagens. Ponteiros semelhantes Ã  linguagem C podem ser utilizados tambÃ©m, mas os blocos que os utilizam precisam ser marcados como "unsafe" ([Mais InformaÃ§Ãµes](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

## Ownership

A instruÃ§Ã£o a seguir:

```
A = B;
```

Pode agir de duas formas diferentes:
 - Se **B** implementa a trait Copy, irÃ¡ criar uma cÃ³pia automaticamente.
 - Se **B** nÃ£o implementa Copy, **A** serÃ¡ dona de **B** agora. O compilador nÃ£o deixarÃ¡ realizarmos instruÃ§Ãµes com **B**, porque o valor de **B** foi "movido" para **A**.

Dos tipos primitivos: 
 - NÃºmeros (```u32```, ```f32```, ```i32```, ...) implementam ```Copy``` e ```Clone```. 
 - String implementa ```Clone```, mas nÃ£o implementa ```Copy```. 

Em outras palavras, para criarmos uma cÃ³pia de um String, precisamos fazer isso manualmente.

Ownership garante que apenas uma variÃ¡vel Ã© dona ("owns") de um endereÃ§o de vÃ¡riÃ¡vel. Essa possessÃ£o pode ser transferida. Mas para compartilharmos uma variÃ¡vel, usamos ponteiros ou referÃªncias.

---

## ReferÃªncias

ReferÃªncias, ou emprÃ©stimos ("borrows") sÃ£o uma forma de compartilhar um endereÃ§o de memÃ³ria com permissÃµes limitadas. As referÃªncias podem ser mutÃ¡veis ou imutÃ¡veis. SÃ£o escritas, respectivamente, da seguinte forma:

```rust
let a = 10; // Criando uma variÃ¡vel com valor 10
let b = &a; // Criando uma variÃ¡vel que Ã© uma referÃªncia Ã  variavel a
```

```rust
let mut a = 10; // Criando uma variÃ¡vel mutÃ¡vel com valor 10
let b = &mut a; // Criando uma variÃ¡vel que Ã© uma referÃªncia mutÃ¡vel Ã  variavel a
```

VariÃ¡veis sÃ£o, por padrÃ£o, imutÃ¡veis, constantes. Por isso declarei ```a``` mutavel no segundo exemplo.

 - ReferÃªncias imutÃ¡veis permitem acessar o valor, mas nÃ£o permitem alterÃ¡-lo.
 - ReferÃªncias mutÃ¡veis permitem acessar o valor e permitem alterÃ¡-lo.

Algumas regras a considerar:
 - NÃ£o se pode alterar a variÃ¡vel original enquanto uma referÃªncia ainda existe.
 - VÃ¡rias referÃªncias imutÃ¡veis podem existir.
 - SÃ³ uma referÃªncia mutÃ¡vel pode existir.
 - NÃ£o podem existir referÃªncias imutÃ¡veis se uma referÃªncia mutÃ¡vel existe.

Quando criamos uma referÃªncia, digamos que a variÃ¡vel dona estÃ¡ "emprestando" ("borrow") para a outra. A linha em que o emprÃ©stimo Ã© utilizado por ultimo Ã© a linha em que o emprÃ©stimo Ã© devolvido.

---

## Importante

NÃ£o retorne referÃªncias. Retornar referÃªncias Ã© possivel, mas Ã© preciso marcar o tempo-de-vida (lifetime) do valor retornado. NÃ£o recomendamos estudar isso enquanto estÃ¡ aprendendo a linguagem rust. Todo o conceito de lifetimes pode ser evitado simplesmente retornando cÃ³pias quando necessÃ¡rio. Para os interessados, referÃªncias [aqui](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).

Lifetimes sÃ£o um conceito bem poderoso quando usado corretamente. As ferramentas serde e borsh usam isso para converter texto json para o tipo que precisamos com zero cÃ³pia. Ou seja, existe alocaÃ§Ã£o de memÃ³ria para o String json, para o tipo que precisamos, e nada mais. O processador nÃ£o precisa esperar alocaÃ§Ã£o de memÃ³ria, ou seja, muito rÃ¡pido.

---

## Exemplos

Para o contrato descrito a seguir:

```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

Temos os exemplos a seguir:

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Antes de iniciarmos com os detalhes falaremos sobre String e &str.

---

### O que Ã© String

Uma String Ã© uma variÃ¡vel que possui dono. Armazena um "string" e irÃ¡ ser liberado da memÃ³ria quando a variÃ¡vel ser liberada. Mas "Um texto entre aspas como este nÃ£o Ã© um String, Ã© um &str". Uma referÃªncia a um String Ã© um &String ou &mut String.

---

### O que Ã© &str

Isso Ã© um tipo criado para simplificar o uso de Strings em nosso cÃ³digo. Age como uma referÃªncia imutÃ¡vel Ã  um String. Mas este serÃ¡ alocado pelo compilador, e o compilador decide como melhor otimizÃ¡-lo na memÃ³ria.

---

### Strings em FunÃ§Ãµes

Consideraremos as duas variÃ¡veis abaixo para o exemplo:

```rust
let variavel: String = String::from("Uma Variavel");
let referencia: &str = "Uma Variavel";
```

A funÃ§Ã£o abaixo recebe um &str e retorna o comprimento da string. O emprÃ©stimo Ã© devolvido no fim da funÃ§Ã£o.

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    return name.len();
}
```

Para utilizar a funÃ§Ã£o com os parÃ¢metros:

```rust
this_takes_a_reference(&variavel);
this_takes_a_reference(referencia);
```

A funÃ§Ã£o abaixo recebe um String como parÃ¢metro e retorna o comprimento. A funÃ§Ã£o se torna dona do endereÃ§o de memÃ³ria e o deleta no fim.

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```

Para utilizar a funÃ§Ã£o com os parÃ¢metros:

```rust
this_takes_the_ownership(variavel);
this_takes_the_ownership(String::from(referencia));
```

Precisamos de transformar o &str em um String antes de usar como parÃ¢metro. A funÃ§Ã£o adiquiriu ownership quando nÃ£o precisava tambÃ©m.

Ambas as funÃ§Ãµes ```this_takes_a_reference``` e ```this_takes_the_ownership``` fazem a mesma coisa, nÃ£o causam erros, e retornam o mesmo resultado. Mas a primeira Ã© bem mais eficiente do que a segunda.

Por isso, Ã© boa prÃ¡tica usar ```&str``` em vez de ```String``` nas declaraÃ§Ãµes de funÃ§Ã£o.

Eu lamento ter que adicionar mais um detalhe nessa explicaÃ§Ã£o, mas funÃ§Ãµes de contrato, aquelas em que precisamos de marcar com ```#[near_bindgen]``` precisam de receber String como parÃ¢metro. Isso Ã© porque as traits de deserializaÃ§Ã£o sÃ£o implementadas para String, mas nÃ£o sÃ£o implementadas para referÃªncias de string.

A funÃ§Ã£o:

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
    );
}
```

Chama ```this_takes_a_reference``` e ```this_takes_the_ownership```, garantindo que ambas retornam o mesmo valor antes de retornÃ¡-lo. Como ```this_takes_the_ownership``` nÃ£o pega o valor emprestado, criamos uma cÃ³pia para ser usada como necessÃ¡rio.

A funÃ§Ã£o:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Simplesmente chama ```this_takes_a_reference``` e altera o "nome" armazenado no contrato. Este exemplo mostra que podem haver vÃ¡rias referÃªncias para uma variÃ¡vel. FaÃ§a as alteraÃ§Ãµes recomendadas nos comentÃ¡rios para ver as reaÃ§Ãµes do compilador.

A [prÃ³xima LiÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_3_structs) serÃ¡ sobre structs.

'''
'''--- PT-BR/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Macro que gera codigo boilerplate para o projeto. Vai ser deprecado nas proximas versÃµes.
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Inicializar com a String "A default string" como exemplo
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str Ã© uma referencia para uma string
    // strings entre aspas " " sÃ£o 'static &str
    // entÃ£o ter &str como parÃ¢metro permite ter tanto &String como "uma string estatica como essa"
    /// Retorna o tamanho da string.
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // Essa funÃ§Ã£o faz o mesmo que o de cima, mas recebe uma String como parÃ¢metro.
    // Teriamos que converter para uma String dessa forma: String::from("essa")
    /// Retorna o tamanho da string.
    fn this_takes_the_ownership(name: String) -> usize {
        // retorna usize, usize Ã© u32 em sistemas 32 bit, u64 em sistemas 64 bit
        name.len()
    }

    /// Retorna o tamanho da string armazenada.
    pub fn get_length(&self) -> u32 {
        // IrÃ¡ chamar ambos os mÃ©todos para mostrar que ambos fazem a mesma coisa.
        //
        // Adicionando & antes de cada parametro Ã© o mesmo que dizer:
        // "Estou dando permissÃ£o para esta funÃ§Ã£o olhar o valor dessa variÃ¡vel, mas nÃ£o estou dando permissÃ£o para modificÃ¡-lo".
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // this_takes_the_ownership quer ter possessÃ£o de uma String, entÃ£o precisamos criar uma cÃ³pia para essa.
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Chamando assert_eq para provar que ambas sÃ£o iguais.
        // Se os valores sÃ£o diferentes, o cÃ³digo entra em pÃ¢nico.
        assert_eq!(
            // primeiro parÃ¢metro para comparar
            length_reference, 
            // segundo parÃ¢metro para comparar
            length_ownership, 
            // Se ambas nÃ£o sÃ£o iguais, entra em pÃ¢nico com a mensagem de erro abaixo
            "Ambos tamanhos nÃ£o sÃ£o o mesmo {} e {}", length_reference, length_ownership,
        );

        // Converter para u32 porque Ã© um formato simples para json
        // tipos podem ser convertidos usando as traits "into" e "from" tambÃ©m
        length_reference as u32
    }

    /// Retorna o tamanho da String armazenada. TambÃ©m muda o nome para "Changed name"
    pub fn get_length_again(&mut self) -> u32 {
        // podemos declarar variaveis que armazenam referencias para um outro valor.
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // Podemos ter varias referÃªncias imutaveis ao mesmo tempo.
        // Mas nÃ£o podemos alterar uma variavel enquanto referÃªncias imutÃ¡veis existirem.
        // Se precisarmos tirar uma referÃªncia mutavel, nÃ£o devem haver referÃªncias imutaveis existindo.

        // Descomente a linha adiante para receber um erro devido a referÃªncias existentes.
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // A linha adiante Ã© ok porÃ©m, porque as referÃªncias acima nÃ£o sÃ£o usadas novamente.
        // Como nÃ£o sÃ£o usadas novamente, o compilador sabe que pode liberÃ¡-las da memÃ³ria.
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos modificar com o builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Ambas funÃ§Ãµes fazem a mesma coisa, entÃ£o ambas devem retornar o mesmo valor.
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again tambÃ©m modifica a string armazenada.
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- PT-BR/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_3_structs/Readme.md ---
# LiÃ§Ã£o 3 - Structs

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta liÃ§Ã£o discute sobre o formato de structs e como ownership Ã© usada nos mÃ©todos.

---

## TÃ³picos

 - [DescriÃ§Ã£o](#descri%C3%A7%C3%A3o)
 - [FunÃ§Ãµes de Contrato](#fun%C3%A7%C3%B5es-de-contrato)
 - [Projeto](#projeto)
   - [Estrutura de Contrato](#estrutura-de-contrato)
   - [Trait Clone](#trait-clone)
   - [just_a_function](#just_a_function)
   - [macros](#macros)
   - [take_ownership](#take_ownership)

---

## DescriÃ§Ã£o
[voltar](#li%C3%A7%C3%A3o-3---structs)

Structs sÃ£o um pouco semelhantes a classes em algumas linguagens orientadas a objetos. A diferenÃ§a Ã© que ```structs``` nÃ£o podem herdar outros ```structs```, sÃ³ podem implementar ```traits```.

Aprofundaremos o conceito de traits em uma liÃ§Ã£o adiante. Mas considere traits como um conjunto de funÃ§Ãµes representando uma caracterÃ­stica que vÃ¡rios tipos diferentes podem implementar. A trait ```Clone``` permite usar o mÃ©todo ```.clone()``` para criar uma cÃ³pia do elemento. A trait ```BorshDeserialize``` permite tentar construir uma instÃ¢ncia do tipo utilizando um string no formato json.

Mais adiante aprenderemos a criar funÃ§Ãµes que aplicam a qualquer tipo de variÃ¡vel que implementa uma trait especifica. PorÃ©m, essa liÃ§Ã£o serÃ¡ apenas sobre structs.

---

## FunÃ§Ãµes de Contrato
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
// gets e sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// Uma funÃ§Ã£o que nÃ£o altera nem acessa o estado do contrato
pub fn just_a_function();

// Uma funÃ§Ã£o StructExample que toma ownership de si mesmo, se deletando no final.
pub fn take_ownership(&self) -> u32;
```

Cheque a implementaÃ§Ã£o para mais detalhes.

---

## Projeto

[voltar](#li%C3%A7%C3%A3o-3---structs)

Criamos um tipo de nome ```StructExample```.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
O tipo possui os seguintes valores internos:
 - an_integer: um inteiro positivo de 32 bits;
 - another_integer: um inteiro positivo ou negativo de 32 bits;
 - a_floating: um nÃºmero real de 32 bits;
 - a_string: um string, descrito na liÃ§Ã£o anterior;

Em muitas linguagens teriamos que escrever algo como ```long int``` para i32, ```long long int``` para i64. Em rust e assemblyscript, simplesmente usamos i para "signed" (positivo e negativo) e u para "unsigned" (positivo). u8, u16, u32, u64 e u128 sÃ£o todos tipos vÃ¡lidos de inteiros "unsigned".

---

### Estrutura de Contrato

[voltar](#li%C3%A7%C3%A3o-3---structs)

O contrato possui a seguinte estrutura:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```

Este exemplo de contrato deriva a trait ```Default``` em vez de implementar manualmente. Essa forma de implementar executa o mÃ©todo ```.default()``` para todos os valores internos. Devido a isso, o tipo ```struct_example``` deve implementar ```Default``` tambÃ©m.

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```

Escolhemos alguns valores aleatÃ³rios para servir de exemplo. Vemos que nÃ£o Ã© necessÃ¡rio escrever algo como ```an_integer: an_integer``` ou ```a_floating: a_floating``` quando os nomes sÃ£o iguais.

---

### Trait Clone

[voltar](#li%C3%A7%C3%A3o-3---structs)

Implementamos a trait Clone para o tipo:

```rust
impl Clone for StructExample{
    // self Ã© uma instancia de StructExample, Self (Letra maiÃºscula) Ã© o tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample sÃ£o a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```

**Vale relembrar que estou intencionalmente escrevendo o cÃ³digo de forma mais complexa apenas para demonstrar as diversas liberdades que temos na implementaÃ§Ã£o de nossos projetos.**

NÃ£o hÃ¡ muito o que adicionar sobre as implementaÃ§Ãµes dos ```get```s e ```set```s. Recomendo checar os comentÃ¡rios. Mas discutiremos sobre ```just_a_function``` e ```take_ownership``` a seguir:

---

### just_a_function

[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
Esta funÃ§Ã£o imprime duas linhas de texto. 

A funÃ§Ã£o ```log``` recebe uma sequÃªncia de bytes como parÃ¢metro. Devido a isso, a primeira linha mostra que podemos incluir a letra "b" antes das aspas para tratar a string como bytes.

Na segunda instruÃ§Ã£o usamos o macro ```format!``` para formatar uma String dinamicamente. O tipo String possui um mÃ©todo ```.as_bytes``` que converte o tipo para bytes. Para mais detalhes sobre String, cheque os [docs oficiais](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[voltar](#li%C3%A7%C3%A3o-3---structs)

SerÃ£o explicados mais adiante. Para simplificar o entendimento inicial, considere **macros** como funÃ§Ãµes que sÃ£o executadas antes do cÃ³digo ser compilado. SÃ£o funÃ§Ãµes que geram cÃ³digo. SÃ³ depois do **macro** gerar cÃ³digo que o compilador checa por erros. O uso mais comum de **macros** Ã© para agir como funÃ§Ãµes que recebem um nÃºmero variado de parÃ¢metros.

Outra forma de vermos **macros** Ã©: uma forma de trocar complexidade de cÃ³digo por praticidade de uso.

---

### take_ownership
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self serÃ¡ liberado da memÃ³ria aqui
}
```

Acho esse exemplo interessante. 
 - Imprime "Taking ownership of itself" na tela. 
 - Imprime o valor de ```an_integer``` no contrato. 
 - E retorna o valor de ```an_integer```.

Mas como declaramos ```self``` em vez de ```&self``` ou ```&mut self``` como argumento, o mÃ©todo tomarÃ¡ possessÃ£o (ownership) de si mesmo e se auto-destruira no fim. 

Um usuÃ¡rio iniciante provavelmente receberÃ¡ um aviso de erro muito confuso se tentar escrever o mÃ©todo dessa forma. Um erro similar a "valor nÃ£o pode ser usado pois um move aconteceu aqui.".

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_4_modules) serÃ¡ sobre mÃ³dulos.

'''
'''--- PT-BR/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// StructExample Ã© um state do Contract, entÃ£o declaramos derive aqui tambÃ©m.
#[derive(BorshDeserialize, BorshSerialize)]
// Um struct com tipos primitivos
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default Ã© executado quando o codigo Ã© carregado ao contrato e nÃ£o Ã© inicializado.
// Pode ser chamado manualmente para criar uma instÃ¢ncia com valores padrÃ£o.
impl Default for StructExample{
    fn default() -> Self {
        // Cada atributo do StructExample Ã© setado da forma Nome: Valor,
        // NÃ£o Ã© preciso setar da forma nome: nome,
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone Ã© uma forma de criar uma copia desse struct manualmente.
impl Clone for StructExample{
    // self Ã© uma instancia de StructExample, Self (Letra maiÃºscula) Ã© o Tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample sÃ£o a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Aqui que mÃ©todos e funcÃµes para o struct sÃ£o implementados.
impl StructExample{

    // &self quer dizer que irÃ¡ emprestar uma instÃ¢ncia de StructExample, mas nÃ£o irÃ¡ alterÃ¡-la
    /// Retorna a copia de a_string
    pub fn get_a_string(&self) -> String {

        // Strings implementam a trait Clone mas nÃ£o implementam Copy
        // Copy cria uma cÃ³pia da instÃ¢ncia automaticamente quando ha uma instruÃ§Ã£o a = b
        // Clone cria uma cÃ³pia da instÃ¢ncia quando o cÃ³digo chama clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implementa Copy, entÃ£o esta linha irÃ¡ automaticamente criar uma copia de a_floating
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // NÃ£o precisamos escrever "return" sempre.
        // Se a expressÃ£o nÃ£o termina com ponto e virgula ";" retorna a expressÃ£o
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // &mut self quer dizer que irÃ¡ emprestar uma instÃ¢ncia de StructExample e fazer modificaÃ§Ãµes a este.
    pub fn set_a_string(
        &mut self, 
        // detalhe importante: como nÃ£o hÃ¡ referÃªncia & para a String, estamos tomando possessÃ£o (ownership) desta.
        // Quer dizer que a funÃ§Ã£o Ã© dona desta parte de memÃ³ria.
        // PossessÃ£o de a_string_arg quer dizer que o cÃ³digo que o chamou nÃ£o precisarÃ¡ usar a String novamente.
        //
        // Este Ã© um dos superpoderes de Rust. Podemos criar cÃ³digo que cria o menor nÃºmero de cÃ³pias possivel.
        a_string_arg: String,
    ) {
        // como emprestamos self mutavel, podemos alterar os valores internos
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 Ã© unsigned, apenas valores positivos
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 Ã© signed, pode ser positivo e negativo. Mas apenas metade do alcance mÃ¡ximo.
        self.another_integer = another_integer;
    }

    // Se o mÃ©todo nÃ£o possui self, Ã© apenas uma funÃ§Ã£o comum associada ao tipo.
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // Se self estÃ¡ nos argumentos, a funÃ§Ã£o toma possessÃ£o do tipo.
    // Quer dizer que o struct serÃ¡ deletado no fim da funÃ§Ã£o (a nÃ£o ser que retornemos ela).
    // Ã‰ sÃ³ um exemplo. Quase nunca terÃ¡ que implementar uma funÃ§Ã£o dessa forma.
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self serÃ¡ liberado da memÃ³ria aqui
    }
}

// #[near_bindgen] instrui near-sdk que esta struct representa o state principal do contrato.
// Podemos usar qualquer nome. Contract Ã© sÃ³ mais facil de entender.
#[near_bindgen]
// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// BorshSerialize converte o nosso tipo de retorno para json.
// BorshDeserialize converte os parÃ¢metros em json para os tipos que nossa funÃ§Ã£o chama.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // Abaixo sÃ£o as mesmas funÃ§Ãµes do struct sendo chamadas aqui.
    // A diferenÃ§a sendo que estas sÃ£o como interagimos com o contrato.
    //
    // O mÃ©todo para get_a_string precisa de &self, entÃ£o usamos &self ou &mut self
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // O mÃ©todo para set_a_string precisa de &mut self, entÃ£o sÃ³ podemos usar &mut self
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function nÃ£o tem &self, &mut self nem self
    // Ã‰ apenas uma funÃ§Ã£o no namespace da struct. NÃ£o precisamos de usar self tambÃ©m.
    pub fn just_a_function(){
        // :: Ã© usado para referenciar namespaces. NÃ£o Ã© um metodo de uma instÃ¢ncia de struct, apenas uma funÃ§Ã£o.
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A funÃ§Ã£o take_ownership libera o objeto da memÃ³ria.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador nÃ£o irÃ¡ nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessÃ£o (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy serÃ¡ removido no fim dessa funÃ§Ã£o abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irÃ¡ aparecer.
        // Isso Ã© porque chamamos uma funÃ§Ã£o de uma instÃ¢ncia que nÃ£o existe mais.
        // env::log(format!("Essa linha de cÃ³digo irÃ¡ gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg diz ao compilador para considerar esse modulo apenas em um ambiente de teste. Este nÃ£o existe fora dessas condiÃ§Ãµes.
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos alterar com esse builder
        //
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor Ã© da implementaÃ§Ã£o padrÃ£o.
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // Declaramos isso no inÃ­cio do contrato, mas nÃ£o precisamos de usa-lo aqui
        // ComeÃ§ar a variÃ¡vel com _ se nÃ£o tiver intenÃ§Ã£o de usÃ¡-la
        let _contract: Contract = Contract::default();

        // Note o :: devido a funÃ§Ã£o nÃ£o precisar de um state.
        Contract::just_a_function();
    }

    #[test]
    // take_ownership Ã© sÃ³ um exemplo de uma gambiarra em rust. NÃ£o ha muito uso aqui.
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- PT-BR/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_4_modules/Readme.md ---
# LiÃ§Ã£o 4 - MÃ³dulos

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta liÃ§Ã£o discute sobre como mÃ³dulos sÃ£o importados. 

Podemos ter todo nosso cÃ³digo implementado no arquivo ```lib.rs```. Mas percebe-se como seria dificil de organizar um projeto grande dessa forma. 

 - Podemos declarar mÃ³dulos externos; 
 - Declarar diretÃ³rios externos como mÃ³dulos;
 - Controlar quais mÃ³dulos sÃ£o pÃºblicos;
 - Controlar o caminho para cada mÃ³dulo pÃºblico;
 - TambÃ©m podemos organizar nossos testes no diretÃ³rio ```./tests/```.

---

## API de Contrato

```rust
/// Retorna a String armazenada.
pub fn get_phrase(&self) -> String;

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from crate::a_module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from 
/// crate::a_module::specific_module" e atribuir essa string ao 
/// valor armazenado.
pub fn hello1(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from another module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello2(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Hello from yet_another_module" 
/// e atribuir essa string ao valor armazenado.
pub fn hello3(&mut self);

/// A funÃ§Ã£o irÃ¡ imprimir "Called a deep function" e 
/// atribuir essa string ao valor armazenado.
pub fn hello4(&mut self);

/// Esta funÃ§Ã£o irÃ¡ entrar em pÃ¢nico com a mensagem "A panic 
/// just happened" quando chamado.
pub fn this_will_panic();
```

---

## TÃ³picos
 - [Como declarar um mÃ³dulo externo](#como-declarar-um-m%C3%B3dulo-externo)
 - [Como declarar e usar diretÃ³rios](#como-declarar-e-usar-diret%C3%B3rios)
 - [Usando/importando mÃ³dulos](#usandoimportando-m%C3%B3dulos)
   - [Apelidos](#apelidos)
   - [Usos pÃºblicos](#usos-p%C3%BAblicos)
 - [Testes de integraÃ§Ã£o](#testes-de-integra%C3%A7%C3%A3o)
   - [Testes de integraÃ§Ã£o NEAR](#testes-de-integra%C3%A7%C3%A3o-near)
   - [Testes de integraÃ§Ã£o Rust](#testes-de-integra%C3%A7%C3%A3o-rust)
  - [Desativar avisos de compilador](#desativar-avisos-de-compilador)
  - [Testando Falhas](#testando-falhas)

---

## Como declarar um mÃ³dulo externo

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Um mÃ³dulo externo deve ser declarado antes de usado/importado.

```rust
mod yet_another_module;
```

Essa linha diz ao compilador que existe um mÃ³dulo com este nome no mesmo diretÃ³rio. Existem trÃªs formas de se declarar um mÃ³dulo. Se dois mÃ³dulos ou mais com mesmo nome forem encontrados, um erro de ambiguidade serÃ¡ gerado.

O mÃ³dulo acima Ã© privado. SÃ³ pode ser usado onde foi declarado. O mÃ³dulo abaixo Ã© pÃºblico:

```rust
pub mod a_module;
```

```a_module``` Ã© pÃºblico aqui. Ou seja, pode ser importado por outros. Isso inclui crates externas. O exemplo abaixo restringe isso.

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```

```pub(crate)``` significa que esta funÃ§Ã£o Ã© pÃºblica apenas nessa crate. Ou seja, se ```lesson_4_modules``` for dependÃªncia de um outro projeto rust, o crate externo nÃ£o terÃ¡ acesso a essa funÃ§Ã£o.

---

## Como declarar e usar diretÃ³rios

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos declarar diretÃ³rios como mÃ³dulos tambÃ©m. Existem duas formas para isso. A primeira Ã©:
 - Criar um diretÃ³rio com o nome do seu mÃ³dulo.
 - Criar um arquivo com nome ```mod.rs``` dentro desse diretÃ³rio. Este arquivo possui a implementaÃ§Ã£o do mÃ³dulo.

![Imagem de um diretÃ³rio com um arquivo mod.rs](../static/images/mod-diretorios.png)

```a_module``` Ã© uma implementaÃ§Ã£o de mÃ³dulo. 

A segunda forma Ã©:

 - Criar um diretÃ³rio com o nome do seu mÃ³dulo.
 - Criar um arquivo rust com o mesmo nome do seu mÃ³dulo junto com o diretÃ³rio. Este arquivo possui a implementaÃ§Ã£o do mÃ³dulo.

![Imagem de um diretÃ³rio com um arquivo de mesmo nome ao lado](../static/images/mod-diretorios2.png)

```internal_module``` Ã© outra implementaÃ§Ã£o de mÃ³dulo.

O arquivo rust fica dentro ou fora do diretÃ³rio? Essa Ã© a questÃ£o.

---

## Usando/Importando mÃ³dulos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Qualquer item (mÃ³dulos, funÃ§Ãµes, structs, traits, enums, et cetera) pode ser importado com a instruÃ§Ã£o use.

No exemplo abaixo, acessamos o caminho ```near_sdk``` (uma crate neste caso), e incluimos ```env``` e ```near_bindgen``` no nosso namespace.

```rust
use near_sdk::{env, near_bindgen};
```

NÃ£o Ã© necessÃ¡rio usar a instruÃ§Ã£o use. PorÃ©m, se quisÃ©ssemos acessar o mÃ³dulo ```env```, teriamos que escrever ```near_sdk::env``` todas as vezes.

---

### Apelidos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos dar um apelido ao item importado:

```rust
use a_module::specific_module::hello as hello1;
```

Existem vÃ¡rias funÃ§Ãµes ```hello``` neste exemplo. EntÃ£o alteramos o nome de cada uma com o operador ```as```. Ou seja, importando dessa forma, a instruÃ§Ã£o ```hello1()``` Ã© o mesmo que ```a_module::specific_module::hello()```.

---

### Usos pÃºblicos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

As instruÃ§Ãµes

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

Trazem as duas funÃ§Ãµes hello para este namespace, alteram o nome para ```hello2``` e ```hello3```, e as tornam pÃºblicas, como se tivessem sido declaradas neste mÃ³dulo. Isso Ã© uma boa forma de organizar nosso projeto. Por exemplo, no arquivo ```yet_another_module```:

```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```

Declaramos que o mÃ³dulo ```internal_module``` existe, e Ã© privado. Mas a funÃ§Ã£o ```a_deep_function``` Ã© pÃºblica. Um usuÃ¡rio pode acessar esse item pelo caminho ```yet_another_module::a_deep_function```. Sem saber que a funÃ§Ã£o estÃ¡ em um diretÃ³rio completamente diferente.

Organize mÃ³dulos e diretÃ³rios de acordo com as necessidades do seu projeto. Use ```pub use``` para organizar os itens disponÃ­veis de acordo com as necessidades dos usuÃ¡rios externos.

**Detalhe**: ```pub use``` e ```pub mod``` sÃ£o usados para mÃ³dulos pÃºblicos e crates feitos para serem importados (library) por outros projetos rust. NÃ£o possui nenhuma interaÃ§Ã£o no contexto de contratos NEAR.

---

## Testes de IntegraÃ§Ã£o

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

A linguagem rust tem um formato para testes de integraÃ§Ã£o, e o formato NEAR possui outro.

Isso porque testes de integraÃ§Ã£o em NEAR consistem na interaÃ§Ã£o entre diversos contratos em uma simulaÃ§Ã£o de estrutura blockchain.

---

### Testes de IntegraÃ§Ã£o NEAR

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Para isso usamos uma ferramenta chamada [workspaces-rs](https://github.com/near/workspaces-rs)

Agora, como se ja nÃ£o estivesse confuso o suficiente, workspaces em rust e workspaces-rs sÃ£o duas coisas diferentes. [Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html) em rust sÃ£o uma forma de organizar vÃ¡rias crates em um Ãºnico pacote, todas compartilhando um diretÃ³rio ```./target/``` e um arquivo ```Cargo.lock```. [workspaces-rs](https://github.com/near/workspaces-rs) Ã© uma forma de realizar testes de integraÃ§Ã£o de contratos NEAR utilizando a linguagem rust.

Testes de integraÃ§Ã£o eram feitos com a crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), mas esta ferramenta serÃ¡ deprecada pela [sandbox](https://docs.near.org/docs/develop/contracts/sandbox). Use a ferramenta que lhe servir melhor.

---

### Testes de integraÃ§Ã£o Rust

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Geralmente declaramos testes no mesmo arquivo. da seguinte forma:

```rust
#[cfg(test)]
mod tests{
    // carrega tudo que estÃ¡ neste arquivo, fora deste mÃ³dulo.
    use super::*;

    #[test]
    fn hello_test(){
```

Mas as vezes, precisamos declarar testes em sua prÃ³pria estrutura de arquivos e diretÃ³rios.

Podemos criar um diretÃ³rio ```tests``` junto com o ```src```.

![Imagem do diretÃ³rio root com destaque no diretÃ³rio "tests"](../static/images/testsdirectory.png)

Quando executarmos o comando ```cargo test```, cada arquivo ```.rs``` serÃ¡ tratado como um mÃ³dulo de teste. Todas as funÃ§Ãµes marcadas com ```#[test]``` serÃ£o executadas automaticamente.

Os arquivos ```.rs``` nÃ£o precisam ser declarados com a instruÃ§Ã£o ```mod``` para serem compilados.

O diretÃ³rio ```tests``` age como uma crate separada. Podemos importar mÃ³dulos no mesmo diretÃ³rio:

```rust
mod common;

use common::env_setup;
```

Para importarmos mÃ³dulos na crate principal, referimos Ã  essa pelo nome da crate:

```rust
use lesson_4_modules::Contract;
```

---

## Desativar avisos de compilador

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Avisos ("warnings") sÃ£o gerados durante a compilaÃ§Ã£o. Podemos desativar avisos da seguinte forma:

```rust
#[allow(unused)]
```

O exemplo acima permite uma falha de cÃ³digo "nÃ£o utilizado" na linha abaixo.

O recomendado Ã© corrigir avisos do compilador. Mas existem situaÃ§Ãµes em que talvez isso seja Ãºtil. Por exemplo, a convenÃ§Ã£o para funÃ§Ãµes javascript Ã© ```CamelCase```, mas a convenÃ§Ã£o para funÃ§Ãµes em rust Ã© ```snake_case```. Quando comunicarmos com o nosso contrato atravÃ©s do near-api-js, talvez seja melhor ter as funÃ§Ãµes na convenÃ§Ã£o javascript.

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

Podemos permitir avisos de imports nÃ£o utilizados:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```

Repetindo, avisos existem para nos ajudar. O recomendado Ã© **corrigir** os avisos, nÃ£o escondÃª-los.

---

## Testando falhas

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Criamos testes para garantir que erros aconteÃ§am quando erros devem acontecer tambÃ©m.

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

O teste acima irÃ¡ causar pÃ¢nico, mas esperamos pÃ¢nico. EntÃ£o o teste serÃ¡ um sucesso.

Se a operaÃ§Ã£o nÃ£o causar pÃ¢nico, ou causar pÃ¢nico com uma mensagem diferente do esperado ("expected"). O teste irÃ¡ falhar.

A [prÃ³xima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_5_macro_usage) serÃ¡ sobre uso de macros.

'''
'''--- PT-BR/lesson_4_modules/src/a_module/mod.rs ---
//! Entre usar mod.rs ou um arquivo rust com mesmo nome. 
//! Ã‰ apenas uma questÃ£o de manter o arquivo rust no diretorio pai ou filho.
//! 
//! 

pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- PT-BR/lesson_4_modules/src/a_module/specific_module.rs ---
// Ter (crate) apÃ³s pub torna a funÃ§Ã£o (ou mÃ³dulo, trait, ...) disponivel 
// para mÃ³dulos locais, mas nÃ£o para crates externos.
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// panic Ã© quando algo de errado acontece e tudo deve parar imediatamente.
/// Podemos causar panic sob demanda.
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) diz ao compilador que isto apenas existe em ambientes de teste.
#[cfg(test)]
mod tests{
    // carrega tudo que estÃ¡ neste arquivo, fora deste mÃ³dulo.
    use super::*;

    #[test]
    fn hello_test(){
        // Hello Ã© pÃºblico apenas para mÃ³dulos desta crate.
        // Tentaremos importÃ¡-lo no diretÃ³rio de tests, o que causarÃ¡ um erro.
        // Pois o diretÃ³rio de testes atua como a prÃ³pria crate.
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // Podemos testar em situaÃ§Ãµes que causam panic.
    // expected garante que entraremos em pÃ¢nico pelo motivo correto.
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- PT-BR/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A funÃ§Ã£o abaixo Ã© privada.
// #[allow(unused)] Ã© uma forma de dizer ao compilador/linter para ignorar o aviso. Mesmo em um situaÃ§Ã£o como essa, em que Ã© uma mÃ¡ ideia. Pois esta funÃ§Ã£o Ã© inutil.
// Comente o #[allow(unused)] para ver o aviso
#[allow(unused)]
fn this_is_private() -> String {
    // TraduÃ§Ã£o: Esta funÃ§Ã£o nunca serÃ¡ usada pois Ã© privada.
    String::from("This will never be used because it's private")
}

'''
'''--- PT-BR/lesson_4_modules/src/lib.rs ---
//! Este exemplo foca na administraÃ§Ã£o de mÃ³dulos.
//! 
//! 
//!
//! A ordem para importaÃ§Ã£o de crates e modulos Ã©, normalmente:
//! 
//!  - padrÃ£o (std), 
//!  - outras crates (como near-sdk), 
//!  - crates nesta workspace, 
//!  - e mÃ³dulos locais.
//!
//! 
//! "mod file" diz ao compilador que o arquivo nesse diretÃ³rio local deve ser compilado tambÃ©m.
//! Para usarmos o mÃ³dulo utilizamos "use".
//! 
//! "pub mod" quer dizer que outros mÃ³dulos podem usar dito mÃ³dulo, senÃ£o Ã© privado.
//! "pub use" pode ser usado para o mesmo propÃ³sito.
//! A diferenÃ§a sendo que arquivos podem ser organizados de certa forma, e mÃ³dulos de library em outra, mais conveniente.
//! 

// Esta linha estÃ¡ dizendo que existe um arquivo ou diretÃ³rio com nome "a_module" e deve ser compilado.
// "mod.rs" Ã© uma forma necessÃ¡ria de um diretÃ³rio ser reconhecido como mÃ³dulo.
pub mod a_module;
// Esta linha esta dizendo que o arquivo "another_module.rs" Ã© parte deste projeto e deve ser compilado.
mod another_module;

// Esta linha Ã© outra forma de declarar mÃ³dulos, nÃ£o precisa de "mod.rs", mas acho mais desorganizado.
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Podemos usar "as" para dar apelidos a funÃ§Ãµes ou mÃ³dulos importados.
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// pub use torna a funÃ§Ã£o disponÃ­vel para crates externos.
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// A localizaÃ§Ã£o atual de "a_deep_function"  Ã© "yet_another_module::internal_module::a_deep_module::a_deep_function."
// Mas este endereÃ§o Ã© privado, e "yet_another_modulo" chamou "pub use" para a funÃ§Ã£o. Em outras palavras, mais limpo.
use yet_another_module::a_deep_function as hello4;

// Descomente a linha adiante para receber um aviso de erro "isto Ã© privado".
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// Esta funÃ§Ã£o irÃ¡ fazer nosso cÃ³digo menos bagunÃ§ado.
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Retorna a String armazenada.
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from crate::a_module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from 
    /// crate::a_module::specific_module" e atribuir essa string ao 
    /// valor armazenado.
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from another module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Hello from yet_another_module" 
    /// e atribuir essa string ao valor armazenado.
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// A funÃ§Ã£o irÃ¡ imprimir "Called a deep function" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// Esta funÃ§Ã£o irÃ¡ entrar em pÃ¢nico com a mensagem "A panic 
    /// just happened" quando chamado.
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Testes estÃ£o no diretÃ³rio tests. Muito Ãºtil para projetos grandes.

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module.rs ---
// internal_module Ã© privado para mÃ³dulos externos.
mod internal_module;

// Mas fizemos a_deep_function publico para outros na declaraÃ§Ã£o aqui.
// Bom para organizar cÃ³digo.
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module/internal_module.rs ---
pub mod a_deep_module;

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// Uma funÃ§Ã£o profunda.
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- PT-BR/lesson_4_modules/tests/another.rs ---
//! Cada arquivo rusts no diretÃ³rio tests Ã© testado individualmente.
//! NÃ£o hÃ¡ necessidade de incluÃ­-los usando mod.

// Descomente a linha abaixo e verÃ¡ um aviso de erro "privado".
// Isso Ã© porque Ã© pÃºblico apenas dentro da crate. E "tests" age como a prÃ³pria crate.
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- PT-BR/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // attributes we can set with the builder:
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- PT-BR/lesson_4_modules/tests/contract.rs ---
//! Este mÃ³dulo irÃ¡ testar a funcionalidade do contrato.

// common serÃ¡ um mÃ³dulo com funÃ§Ãµes Ãºteis para todos outros testes.
mod common;

// DiretÃ³rio tests age como a prÃ³pria crate.
// So when we import our own modules, 
// EntÃ£o quando importamos nossos prÃ³prios mÃ³dulos,
// referimos a estes como "lesson_4_modules::" em vez de "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // Usamos derive(Default) para Contract.
    // o padrÃ£o derivado para String Ã© uma string vazia.
    assert_eq!(contract.get_phrase(), "");
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from crate::a_module".
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from crate::a_module::specific_module".
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from another_module".
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Hello from yet_another_module".
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Esta funÃ§Ã£o irÃ¡ atribuir "Called a deep function".
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

/// Esta funÃ§Ã£o entrarÃ¡ em panico com a messagem "A panic has just happened" quando chamado.
// Podemos testar situaÃ§Ãµes que causam pÃ¢nico.
// expected garante que estamos entrando em pÃ¢nico pelo motivo certo.
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora nÃ£o utilizemos o state, Ã© bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- PT-BR/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_5_macro_usage/Readme.md ---
# LiÃ§Ã£o 5 - Uso de Macros

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Macros sÃ£o a ferramenta principal para a utilizaÃ§Ã£o efetiva da linguagem rust. NÃ£o Ã© necessÃ¡rio saber como criar macros. Mas Ã© essencial entender o que sÃ£o e como usÃ¡-los.

---

## API de Contrato

```rust
/// Esta funÃ§Ã£o mostra as diferenÃ§as entre println e env::log
/// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
/// Note como algumas mensagens aparecem e outras nÃ£o.
pub fn print_examples();

/// Exemplos de format. Compare o output com a implementaÃ§Ã£o.
pub fn format_examples();

/// Exemplo de panico.
pub fn panic_example();

/// Exemplo de usos de vec.
pub fn vec_examples();
```

## TÃ³picos

 - [O que sÃ£o macros](#o-que-sÃ£o-macros)
 - [Macros "function-like"](#macros-"function-like")
 - [Vantagens](#vantagens)
 - [Desvantagens](#desvantagens)
 - [Exemplos](#exemplos)
   - [format, println e panic](#format-println-e-panic)
   - [vec](#vec)
   - [setup_alloc](#setup_alloc)
 - [Extra: String e str](#extra-string-e-str) 

---

## O que sÃ£o macros

[topo](#liÃ§Ã£o-5---uso-de-macros)

Macros sÃ£o ferramentas que geram cÃ³digo. Macros sÃ£o executados em tempo de compilaÃ§Ã£o. 

As instruÃ§Ãµes derive sÃ£o um macro:

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```

InstruÃ§Ãµes derive servem para aplicar traits a novos tipos. A instruÃ§Ã£o a seguir Ã© outro tipo de macro chamado "atributo":

```rust
#[near_bindgen]
impl Contract{
```

Mas discutiremos macros "function-like" (semelhantes a funÃ§Ãµes). Como o nome descreve, sÃ£o usados com a mesma lÃ³gica do chamado de funÃ§Ãµes. Alguns exemplos:

```rust
// Imprime o string formatado ao output padrÃ£o
println!("{}", message);

// Formata os argumentos em um String
format!("7");

// Formata uma String e entra em pÃ¢nico com a mensagem formatada
// "Entrar em pÃ¢nico" Encerra o runtime retornando uma mensagem de erro.
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

// Recebe uma lista de argumentos e retorna um Vec com os valores alocados.
vec![1, 2, 3, 4];

// Gera cÃ³digo de fÃ´rma (boilerplate) necessÃ¡rio para o funcionamento do contrato
near_sdk::setup_alloc!();

// Usado em testes.
// Usa o argumento Context para gerar o contexto de ambiente da mÃ¡quina virtual.
testing_env!(builder.build());

``` 

---

## Macros "function-like"

[topo](#liÃ§Ã£o-5---uso-de-macros)

Esses macros sÃ£o usados como funÃ§Ãµes, mas existem algumas diferenÃ§as.

Podem ter um nÃºmero variado de parÃ¢metros. Rust Ã© uma linguagem "statically typed", ou seja, o compilador precisa saber exatamente onde memÃ³ria Ã© criada e onde Ã© liberada. PorÃ©m, macros podem retornar cÃ³digo. Ou seja, um macro como ```println``` ou ```format``` recebem os argumentos e montam um bloco de cÃ³digo antes do compilador checar por erros.

Outra diferenÃ§a que pode ser vista com o exemplo de ```vec```:

```rust
vec![1, 2, 3, 4];
```

Esta implementaÃ§Ã£o vec Ã© demarcada com ``` [ ] ``` em vez de ``` ( ) ```, macros tambÃ©m podem ser demarcados com ``` { } ```. Macros podem ter literalmente qualquer tipo de texto dentro dos demarcadores. Um desenvolvedor pode escrever qualquer coisa como argumento macro, contanto que a implementaÃ§Ã£o entenda os parÃ¢metros.

---

## Vantagens

[topo](#liÃ§Ã£o-5---uso-de-macros)

 - Simplifica o cÃ³digo.
 - Ã‰ executado durante compilaÃ§Ã£o. Se bem implementado, macros podem ser eficientes com pouco ou nenhum overhead.

---

## Desvantagens

[topo](#liÃ§Ã£o-5---uso-de-macros)

 - Um desenvolvedor precisa pesquisar a documentaÃ§Ã£o de cada novo macro que encontram.
 - Podem ser mais dificeis de "debugar".
 - Aumentam o tempo de compilaÃ§Ã£o.
 - Podem "inflar" o cÃ³digo com implementaÃ§Ã£o "invisivel".

---

## Exemplos

A seguir recomendamos alguns macros "function-like" Ãºteis.

---

### format, println e panic

[topo](#liÃ§Ã£o-5---uso-de-macros)

Os macros ```panic```, ```println``` e ```format``` sÃ£o escritos da mesma forma.

 - ```format``` retorna um String.
 - ```println``` imprime o String no output padrÃ£o.
 - ```panic``` encerra a execuÃ§Ã£o e retorna o String como mensagem de erro.

```rust
println!("Isso Ã© um println!, nÃ£o aparece na mÃ¡quina virtual");

// Criamos uma variavel "message" e associamos uma String de valor "format retorna uma String formatada".
let message: String = format!("format retorna uma string formatada.");

// Encerra execuÃ§Ã£o com a mensagem de erro "Panico com alguns argumentos: 1 2 3"
let second = 2;
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

```

A utilizaÃ§Ã£o destes macros Ã© bem simples. Um str como primeiro argumento ([detalhes](#extra-string-e-str)). Cada "{}" Ã© substituido pelos argumentos apÃ³s o primeiro.

Podemos customizar a formataÃ§Ã£o de diversas formas. Mais informaÃ§Ãµes, cheque o [link de documentaÃ§Ã£o sobre formataÃ§Ã£o](https://doc.rust-lang.org/std/fmt/index.html). Abaixo incluimos algumas Ãºteis utilizaÃ§Ãµes:

```rust
// Exemplos de format
log("\n\nformat_examples:\n");
 
let message: String = format!("Format retorna uma String formatada");

let an_arg = "third";

// format pode receber argumentos usando {} 1 second third
let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// Podemos especificar argumentos dessa forma: 1 second third
let message = format!("Podemos especificar argumentos dessa forma: {first}, {second}, {third}.");

// Podemos especificar a ordem de argumentos de format: 1 second third
let message = format!("Podemos especificar a ordem de argumentos de format: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: 01 0002      3
let message = format!("Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: {:02}, {:04}, {:6}.", first, second, third);

// Escolhendo nÃºmero de digitos e ordem: 01    2 000003
let message = format!("Escolhendo nÃºmero de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// Podemos escolhar a precisÃ£o de nÃºmeros racionais: 0.10 1.230 -2.450000
let message = format!("Podemos escolhar a precisÃ£o de nÃºmeros racionais: {:.2}, {:.4}, {:.6}", first, second, third);

// Podemos escolher a precisÃ£o e nÃºmero de digitos: 0.10 0001.2300 -00002.450000
let message = format!("Podemos escolher a precisÃ£o e nÃºmero de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: 00.10    1.2300 -00002.450000
let message = format!("Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// Mesmo que o acima:  0.10 0001.2300      -2.450000
let message = format!("Mesmo que o acima: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### vec

[topo](#liÃ§Ã£o-5---uso-de-macros)

Uma rÃ¡pida discussÃ£o sobre algumas formas de agrupar valores. 

Tuplas possuem tamanho imutavel:

```rust
// Uma tupla com inteiros
let tupla: (u32, u32, u32) = (0, 1, 4);

// Acessando um valor
// O segundo valor Ã© 1
println!("O segundo valor Ã© {}", tupla.1);
```

Arrays possuem tamanho imutÃ¡vel, sÃ£o armazenados na pilha (stack).

```rust
// Uma forma de declarar um array
let lista = [0, 1, 2];

// Acessando um valor
// O terceiro valor Ã© 2
println!("O terceiro valor Ã© {}", lista[2]);

// um array com 10 inteiros inicializados com 0.
// Esse mÃ©todo sÃ³ permite inicializar com valores iguais, nÃ£o tente inicializar com uma funÃ§Ã£o.
let mut lista: [i32; 10] = [0; 10];

// Alterando um valor
lista[0] = -1;

// Acessando um valor
// O primeiro valor Ã© -1
println!("O primeiro valor Ã© {}", lista[0]);
```

Arrays e tuplas sÃ£o primitivos. NÃ£o podemos alterar o nÃºmero de elementos desses grupos. Para armazenar conjuntos de valores de forma mais prÃ¡tica usamos coleÃ§Ãµes. Temos coleÃ§Ãµes rust, que sÃ£o mais generalizadas, e coleÃ§Ãµes Near, que sÃ£o armazenadas na "trie". O entendimento de coleÃ§Ãµes rust Ã© importante para uma boa lÃ³gica de funÃ§Ãµes. O entendimento de coleÃ§Ãµes Near Ã© importante para armazenamento eficiente de estado.

 - [Detalhes](https://doc.rust-lang.org/std/collections/) sobre coleÃ§Ãµes Rust para bom funcionamento de mÃ©todos.
 - [Detalhes](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) sobre coleÃ§Ãµes Near para bom armazenamento de estado.

A coleÃ§Ã£o rust mais utilizada Ã© ```Vec```([detalhes](https://doc.rust-lang.org/std/vec/struct.Vec.html)). Com este tipo, podemos armazenar dados, observar a quantidade de elementos, acessar e alterar os elementos. O que Ã© uma boa soluÃ§Ã£o para a maior parte dos casos.

**Detalhe:** ```vec``` (letra minuscula) Ã© o macro para criaÃ§Ã£o de vetores ```Vec```. ```Vec``` (letra maiuscula) refere-se ao tipo do vetor.

Podemos criar um ```Vec``` da seguinte forma:

```rust
// Vec com os nÃºmeros 1 2 3 4
let example = vec![1, 2, 3, 4];
```

Podemos criar um ```Vec``` com vÃ¡rios valores iguais:

```rust
// Vec com os nÃºmeros 0 0 0 0 0
let example = vec![0;5];
```

Imprimir valores de conjuntos pode demandar muito tempo de processamento. Devido a isso, para usar um conjunto de elementos em um ```println```, ```format``` ou ```panic```, precisamos explicitar que Ã© impresso em modo debug.

```rust
let example = vec![1, 2, 3, 4];

log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));

log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

log(&format!("Podemos criar vetores com valores padrÃ£o:\n{:?}\n\n", vec![0;5]));
```

FormataÃ§Ã£o ```{:?}``` Ã© "formataÃ§Ã£o debug".

FormataÃ§Ã£o ```{:#?}``` Ã© "formataÃ§Ã£o pretty print". Ã‰ o mesmo que o acima, porÃ©m escrito de uma forma mais legivel para um usuÃ¡rio. Normalmente simplesmente significa um elemento por linha.

Para implementar formataÃ§Ã£o debug em um struct ou enum, cheque o [link sobre formataÃ§Ã£o](https://doc.rust-lang.org/std/fmt/trait.Debug.html).

---

### setup_alloc

[topo](#liÃ§Ã£o-5---uso-de-macros)

Deve ser usado antes da declaraÃ§Ã£o do contrato. Gera cÃ³digo que deveria ser escrito repetidas vezes em cada contrato.

```rust
near_sdk::setup_alloc!();
```

Ã‰ necessÃ¡rio na versÃ£o de near_sdk atual (```3.1.0```). Nas versÃµes seguintes, serÃ¡ deprecado.

---

## Extra: String e str

[topo](#liÃ§Ã£o-5---uso-de-macros)

```String``` e ```str``` sÃ£o dois tipos diferentes. String Ã© um tipo que mantem ownership de uma string. ```str``` Ã© um tipo usado para referÃªncias a strings. Estes tipos existem para minimizar cÃ³pias de strings durante o runtime.

Lembrar: 
 - ```str``` Ã© sempre usado como ```&str```. ```&str``` aplica para "strings como essa" e ```&String```;
 - Sempre que for precisar de uma referÃªncia para uma ```String``` em uma funÃ§Ã£o, use ```&str```. NÃ£o use ```&String```.
 - "Strings como essa" sÃ£o do tipo ```&'static str```. Mais detalhes na seÃ§Ã£o sobre lifetimes. Teoricamente, sÃ£o strings que nunca sÃ£o removidas da memÃ³ria, mas isso depende da otimizaÃ§Ã£o do compilador.

A [proxima liÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums) serÃ¡ sobre enums.

'''
'''--- PT-BR/lesson_5_macro_usage/src/lib.rs ---
//! Exemplos para os seguintes macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// Esta funÃ§Ã£o Ã© usada em ```print_examples```.
/// Ã‰ compilada em ambientes de teste.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// Esta funÃ§Ã£o Ã© usada em ```print_examples```.
/// Ã‰ compilada fora de ambientes de teste.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // Este contrato nÃ£o possui estado
}

#[near_bindgen]
impl Contract{

    /// Esta funÃ§Ã£o mostra as diferenÃ§as entre println e env::log
    /// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
    /// Note como algumas mensagens aparecem e outras nÃ£o.
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("Isto Ã© um println! NÃ£o aparece na mÃ¡quina virtual");
        let a = String::from("algo");
        println!("Isso Ã© outro println com diversos argumentos, {}, {}, {}", 1, "thingy", a);

        env::log(b"Isso e um log. Nao aparece em testes.");
        env::log("Isso Ã© outro log".as_bytes());

        env::log(
            format!("Isso Ã© outro log com diversos argumentos: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("Isso Ã© uma mensagem que aparecem em testes e na mÃ¡quina virtual.");

        log(
            &format!("Isso Ã© outra mensagem com argumentos, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// Exemplos de format. Compare o output com a implementaÃ§Ã£o.
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format retorna um String formatado");
        log(&message);

        let an_arg ="terceiro";
        let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("Podemos especificar argumentos format da seguinte forma: {first}, {second}, {third}.");

        log(&message);

        let message = format!("Podemos especificar a ordem dos argumentos format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("Podemos fazer inteiros mostrarem um nÃºmero arbitrÃ¡rio de digitos: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Escolhendo um nÃºmero de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Podemos escolher a precisÃ£o de nÃºmeros racionais: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisÃ£o e o nÃºmero de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisÃ£o, o nÃºmero de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Mesmo que acima: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Exemplo de panico.
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("Macros de pÃ¢nico sÃ£o escritos da mesma forma que println e format.");

        let second = 2;
        panic!("PÃ¢nico com alguns argumentos: {} {} {}", 1, second, 3);

    }

    /// Exemplo de usos de vec.
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));
        
        log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

        log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Podemos criar vetores com valores padrÃ£o:\n{:?}\n\n", vec![0;5]));

        log("Mais informaÃ§Ãµes na liÃ§Ã£o de coleÃ§Ãµes (\"collections\").");

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Execute testes com o comando a seguir:
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture faz imprimir todo o output, incluindo testes sucedidos.
// Sem o argumento --test-threads, todos os testes serÃ£o async. O que significa que o output serÃ¡ uma bagunÃ§a.
//
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // O contrato Ã© stateless. Declaramos, mas nÃ£o usamos.
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "PÃ¢nico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- PT-BR/lesson_6_enums/Cargo.toml ---
[workspace]
members=[
    "lesson_6_1_simple", 
    "lesson_6_2_thermometer",
    "lesson_6_3_game_score"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_6_enums/Readme.md ---
# LiÃ§Ã£o 6 - Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta liÃ§Ã£o Ã© dividida em 4 partes relacionadas a enums. Cada tÃ³pico Ã© uma crate. Aproveitaremos este momento para explicar sobre workspaces e como usÃ¡-los.

As sessÃµes sÃ£o as seguintes:
 - [Parte 1 - Declarando e usando enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_1_simple/).
 - [Parte 2 - Termometro implementado com enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_2_thermometer/).
 - [Parte 3 - Como implementar erros de forma prÃ¡tica e eficiente](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/).

---

## Workspaces

[topo](#liÃ§Ã£o-6---enums)

Simplesmente, workspace Ã© um diretÃ³rio com vÃ¡rias crates. Quando compilados, todas as crates compartilham o mesmo diretÃ³rio target. Mas cada crate resulta em um arquivo compilado.

Algumas utilidades para uso de workspaces sÃ£o descritos a seguir:
 - DependÃªncias locais. Criamos uma crate customizada para o nosso projeto, e outra crate depende dela.
 - OrganizaÃ§Ã£o de projeto. Queremos executar testes e compilar todos os projetos simultaneamente.
 - CoordenaÃ§Ã£o de contratos. Um projeto que consiste em vÃ¡rios contratos responsÃ¡veis por diferentes funÃ§Ãµes. Um workspace pode incluir os contratos e uma crate de testes cross-contract (exemplo: [workspaces-rs](https://github.com/near/workspaces-rs)).

---

## Cargo.toml

[topo](#liÃ§Ã£o-6---enums)

O manifest possui a seÃ§Ã£o ```[workspace]```.

```toml
[workspace]
members=["lesson_6_1_simple"]
```

```members``` descreve cada crate do projeto.

**Detalhe**: Se uma crate existir neste diretÃ³rio, esta ainda serÃ¡ considerada. Para nÃ£o incluir a crate, devemos incluir o atributo ```exclude```. Como no exemplo a seguir (fonte: https://doc.rust-lang.org/cargo/reference/workspaces.html, acesso em 17-mar-2022):

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

No exemplo acima, foram incluidos 3 caminhos, e excluidos 2.

---

## CLI em workspaces

[topo](#liÃ§Ã£o-6---enums)

Se executarmos comandos como ```cargo build``` ou ```cargo test``` em uma crate que pertence a uma workspace, todos as crates serÃ£o afetadas tambÃ©m.

Para especificar o comando para apenas uma crate, adicionamos a "flag" ``` -p ```, ```--package``` ou ```--workspace``` ao comando.

Para testar ```lesson_6_1_simple``` execute:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

```--nocapture``` faz imprimir o output de todos os testes.

```--test-threads=1``` faz todos os testes serem executados em um thread. Tornando o output legivel.

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```

Os arquivos '.wasm' estarÃ£o em './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```

Gera documentaÃ§Ã£o da sub-liÃ§Ã£o 6-1 e abre no browser padrÃ£o.

 - ```--lib``` especifica que a crate Ã© um library.
 - ```--document-private-items``` pede para gerar documentaÃ§Ã£o de todos os items.
 - ```--open``` abre o website no navegador padrÃ£o.

DocumentaÃ§Ã£o estarÃ¡ em './target/doc/lesson_6_1_simple/index.html'.

---

 - A proxima seÃ§Ã£o serÃ¡ sobre [declaraÃ§Ã£o e uso de enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_1_simple/).
 - A proxima liÃ§Ã£o serÃ¡ sobre traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# LiÃ§Ã£o 6 - 1 Uso de Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/)

Essa liÃ§Ã£o descreve enums e instruÃ§Ãµes ```match```.

---

## API de contrato

```rust
// /src/lib.rs

/// Podemos usar instruÃ§Ãµes match para Strings e &str.
/// 
/// Esta funÃ§Ã£o Ã© um exemplo. 
/// 
/// Retorna 1, 2, 3, 4, 5, se o argumento for o nÃºmero.
/// 
/// Causa panic se for outro valor.
pub fn string_match_example(&self, arg: String) -> u32;

/// Retorna example_0.
pub fn get_example_0(&self) -> Example0;

/// Retorna example_1.
pub fn get_example_1(&self) -> Example1;

/// Retorna example_2.
pub fn get_example_2(&self) -> Example2User;

/// Chama Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Chama Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Chama Example1::get.
pub fn example_1_get(&self) -> String;

/// Chama Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Chama Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Chama Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Chama Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Chama Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Chama Example2User::get_actions.
/// 
/// Quando retornamos um Vec, o serializer tentarÃ¡ usar serde::json.
/// A instruÃ§Ã£o #[result_serializer] nos permite selecionar borsh como serializador.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

---

## Compilando, testando

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Essa crate pertence ao workspace da liÃ§Ã£o 6. InstruÃ§Ãµes sobre compilaÃ§Ã£o e execuÃ§Ã£o de testes na pagina [anterior](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/lesson_6_1_simple/).

Executar comandos como ```cargo test``` e ```cargo build``` afetarÃ¡ todos as crates na workspace. A nÃ£o ser que uma crate seja especificada.

---

## TÃ³picos

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

 - [O que sÃ£o enums](#o-que-sÃ£o-enums)
 - [InstruÃ§Ãµes match](#instruÃ§Ãµes-match)
   - [String patterns](#string-patterns)
   - [Match precisa aplicar a todos possiveis patterns](#match-precisa-aplicar-a-todos-possiveis-patterns)
   - [Acessando apenas um valor de um enum](#acessando-apenas-um-valor-de-um-enum)
 - [Enums que "englobam" valores](#enums-que-"englobam"-valores)
 - [FunÃ§Ãµes devem especificar tipos](#funÃ§Ãµes-devem-especificar-tipos)
   - [FunÃ§Ã£o is_no_value](#funÃ§Ã£o-is_no_value)
   - [FunÃ§Ã£o get_an_integer](#funÃ§Ã£o-get_an_integer)
   - [FunÃ§Ã£o has_an_odd_number](#funÃ§Ã£o-hasanoddnumber)
 - [Exemplo de uso: UsuÃ¡rio](#exemplo-de-uso-usuÃ¡rio)
   - [Enums limitam as possibilidades](#enums-limitam-as-possibilidades)
   - [FunÃ§Ã£o get_name](#funÃ§Ã£o-get_name)
   - [FunÃ§Ã£o has_permission](#funÃ§Ã£o-has_permission)
   - [FunÃ§Ã£o get_actions](#funÃ§Ã£o-get_actions)
   - [Escolhendo serializador](#escolhendo-serializador)
 - [Proxima seÃ§Ã£o](#proxima-seÃ§Ã£o)

---

## O que sÃ£o enums

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Enquanto Structs armazenam diversos valores simultaneamente. Enums armazenam um valor de cada vez. As alternativas que um enum pode representar sÃ£o descritos na definiÃ§Ã£o.

```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```

Acima temos um exemplo de enum.
 - ```pub``` descreve que o enum estÃ¡ disponivel para ser usado em mÃ³dulos externos.
 - ```Example0``` Ã© o nome do enum.
 - ```First```, ```Second```, ```Third```, ```Fourth``` e ```Fifth``` sÃ£o os nomes dos valores que este enum pode possuir.

Acima temos a declaraÃ§Ã£o do enum, mas como criamos uma instÃ¢ncia de enum? A seguir criamos um exemplo para os 5 valores possiveis.

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```

Para implementar aÃ§Ãµes de acordo com os valores do enum. Poderiamos usar instruÃ§Ãµes ```if|else```. Mas existe uma ferramenta muito mais potente para isso. A seguir, discutiremos sobre instruÃ§Ãµes ```match```.

---

## InstruÃ§Ãµes match

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

InstruÃ§Ãµes match comparam um valor com diversos possiveis valores.

```rust
// /src/model.rs
impl Example0{

    /// Observa o valor de si mesmo e retorna um nÃºmero entre 1 e 5.
    /// 
    /// Note o &self, significando que a funÃ§Ã£o acessa o valor, mas nÃ£o altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // InstruÃ§Ãµes match sÃ£o semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }
```

O exemplo acima simplesmente compara o valor do enum e retorna um inteiro.
 - ```Example0::First``` retorna 1;
 - ```Example0::Second``` retorna 2;
 - ```Example0::Third``` retorna 3;
 - ```Example0::Fourth``` retorna 4;
 - ```Example0::Fifth``` retorna 5;

Ã‰ semelhante a uma instruÃ§Ã£o switch em linguagens como c, python, java e javascript. PorÃ©m, instruÃ§Ãµes ```switch``` comparavam ```booleans```, instruÃ§Ãµes ```match``` de rust comparam patterns.

---

### String patterns

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Podemos usar instruÃ§Ãµes match para ```String``` e ```&str```:

```rust
// /src/lib.rs

impl Contract{
    /// Podemos usar instruÃ§Ãµes match para Strings e &str.
    /// 
    /// Esta funÃ§Ã£o Ã© um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o nÃºmero.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }
```

No exemplo acima, a instruÃ§Ã£o match compara os padrÃµes de cima para baixo.
 - &arg Ã© "1"? NÃ£o.
 - &arg Ã© "2"? NÃ£o.
 - &arg Ã© "3"? NÃ£o.
 - &arg Ã© "4"? NÃ£o.
 - &arg Ã© "5"? NÃ£o.
 - ```value``` Ã© um nome de variÃ¡vel. Este pattern Ã© sempre verdadeiro. Patterns serÃ£o explicados em detalhes na prÃ³xima liÃ§Ã£o.

Qualquer String que nÃ£o seja "1", "2", "3", "4" ou "5", alcanÃ§arÃ¡ o ultimo branch. Ou seja, resultarÃ¡ em panic com o valor da String.

---

### match precisa aplicar a todos possiveis patterns

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

No [primeiro exemplo](#instruÃ§Ãµes-match), o enum possui 5 possiveis valores. Apague um dos branches e o compilador resultarÃ¡ em erro.

```rust
match self {
    Example0::First => {1},
    Example0::Second => {2},
    Example0::Third => {3},
    Example0::Fourth => {4},
    // Branch apagada, resultarÃ¡ em erro.
    // InstruÃ§Ãµes match precisam considerar todos possiveis valores.
    // Example0::Fifth => {5},
}
```

O [segundo exemplo](#string-patterns) compara um String. Strings podem possuir infinitos valores. Por isso, a ultima branch Ã©:

```rust
value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
```

O pattern ```value``` pode ser qualquer nome de variÃ¡vel. Este pattern Ã© o mais simples possivel. Portanto, este aplica para qualquer valor possivel. Muitas vezes este pattern Ã© demonstrado com "underline" "_", iniciar o nome de uma variÃ¡vel com "underline" descreve ao compilador que nÃ£o temos intenÃ§Ã£o de utiliza-la.

Um exemplo. Digamos que escrevamos o match de Strings da seguinte forma:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas nÃ£o utiliza value.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        value => {
            // Compilador irÃ¡ enviar um aviso acima: "VariÃ¡vel nÃ£o usada"
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Para corrigir o aviso em "value". Basta fazer a modificaÃ§Ã£o:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas nÃ£o utiliza _value.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _value => {
            // Aviso corrigido.
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Como convenÃ§Ã£o, simplesmente usamos "_" como o nome de patterns irrelevantes:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas nÃ£o utiliza _.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _ => {
            // Aviso corrigido.
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

---

### Acessando apenas um valor de um enum

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Digamos que tenhamos uma funÃ§Ã£o que sÃ³ precisa aplicar a um enum. InstruÃ§Ãµes match podem ser usadas tambÃ©m. A funÃ§Ã£o abaixo retorna verdadeiro apenas se o valor do enum for ```Example::Third```:

```rust
// /src/model.rs
/// true se o valor for Exemplo0::THIRD
pub fn is_third(&self) -> bool {
    log("Calling Example0::is_third");

    match self {
        Example0::Third => true,
        _ => false,
    }
}
```

---

## Enums que "englobam" valores

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Enums podem armazenar valores:

```rust
// /src/model.rs
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}
```

No exemplo acima. A primeira alternativa nÃ£o tem valor, as 4 seguintes sÃ£o tuplas com os respectivos tipos. A ultima alternativa Ã© semelhante a um "struct da linguagem C".

---

## FunÃ§Ãµes devem especificar tipos

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

FunÃ§Ãµes para enums podem ser dificeis de implementar, devido a uma regra de linguagens de programaÃ§Ã£o de tipo estÃ¡tico "statically typed":

 - Os tipos de argumentos devem ser especificados.
 - Os tipos de retorno devem ser especificados.

Isso inclui funÃ§Ãµes genÃ©ricas. Que serÃ£o explicados adiante. O compilador **deve** saber qual o tipo do argumento que recebe e qual tipo de valor irÃ¡ retornar. FunÃ§Ãµes genÃ©ricas sÃ£o apenas uma forma de gerar funÃ§Ãµes que seguem essas regras.

Ao implementar uma simples funÃ§Ã£o get ou set, um desenvolvedor pode ter dificuldades lidando com o compilador. A segunda alternativa Ã© um inteiro, a terceira Ã© um nÃºmero real, a quarta Ã© um string...

PorÃ©m, Ã© possivel implementar estas funÃ§Ãµes. A pergunta que precisamos fazer Ã©: Como usar o mesmo tipo para o argumento e retorno?

Explicaremos implementaÃ§Ã£o de genÃ©ricos na liÃ§Ã£o sobre traits. No caso de uso adiante, podemos simplesmente retornar um String:

```rust
// /src/model.rs

// O mÃ©todo a seguir retorna apenas um tipo, isso Ã© aceitÃ¡vel para o compilador.
pub fn get(&self) -> String {
    log("Calling Example1::get");

    match self{
        Example1::NoValue => String::from(""),
        Example1::AnInteger(valor) => format!("{}", valor),
        Example1::AFloat(valor) => format!("{}", valor),
        Example1::AString(valor) => format!("{}", valor),
        Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
        Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
    }
}
```

```format!``` Ã© um macro que formata uma String. Macros sÃ£o explicados na liÃ§Ã£o 5. Como a intenÃ§Ã£o Ã© simplesmente imprimir o valor na tela. Retornar um String Ã© aceitÃ¡vel, neste caso de uso.

A liÃ§Ã£o sobre traits explicarÃ¡ como usar as traits borsh e serde. Podemos usar essas ferramentas para converter um struct para uma fatia (slice) de bytes. Podemos tambÃ©m converter uma fatia de bytes ou String para um struct (se compativel).

A liÃ§Ã£o sobre traits tambÃ©m explicarÃ¡ sobre como usar genÃ©ricos. Que Ã© uma forma de implementar a mesma funÃ§Ã£o para diversos tipos simultaneamente.

---

### FunÃ§Ã£o is_no_value

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

As vezes, precisamos checar apenas um valor. Retorna verdadeiro se o valor interno for ```NoValue```.

```rust
// /src/model.rs
/// true se o enum for Example1::NoValue.
pub fn is_no_value(&self) -> bool{
    log("Calling Example1::is_no_value");

    match self{
        Example1::NoValue => true,
        _ => false,
    }
}
```

---

### FunÃ§Ã£o get_an_integer

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Retorna um inteiro, se a alternativa for ```Example1::AnInteger```.

Retorna um ```Option```, serÃ¡ explicado em detalhes na proxima seÃ§Ã£o. Simplificando, Ã© um enum que representa um valor que pode existir ou nÃ£o. Se o valor existir, Ã© ```Option::Some(valor)``` ou simplesmente ```Some(valor)```. Se o valor nÃ£o existir, Ã© entÃ£o ```Option::None``` ou simplesmente ```None```.

```rust
// /src/model.rs
pub fn get_an_integer(&self) -> Option<i32>{
    log("Calling Example1::get_an_integer");

    match self{
        Example1::AnInteger(valor) => Some(valor.clone()),
        _ => None
    }
}
```

Considere a instruÃ§Ã£o:

```rust
match self{
```

Esta instruÃ§Ã£o deveria estar coletando ```ownership``` de si mesmo, porque nÃ£o estÃ¡ fazendo isso?

Isso Ã© devido ao argumento:

```rust
pub fn get_an_integer(&self) -> Option<i32>{
```

Como apenas ```&self``` estÃ¡ sendo usado, o compilador entende que este valor Ã© apenas uma referÃªncia.

Finalizando:

```rust
match self{
    Example1::AnInteger(valor) => Some(valor.clone()),
    _ => None
}
```

A funÃ§Ã£o retorna ```Option<i32>```. Portanto, esta instruÃ§Ã£o ```match``` rust retorna ```Some(valor)``` ou ```None```. Representando se o valor foi encontrado ou nÃ£o.

---

### FunÃ§Ã£o has_an_odd_number

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Retorna verdadeiro se possui um inteiro impar.

O propÃ³sito desta funÃ§Ã£o Ã© demonstrar um uso mais detalhado de instruÃ§Ãµes match.

```rust
// /src/model.rs
/// Retorna true se possui algum numero inteiro impar,
pub fn has_an_odd_number(&self) -> bool {
    log("Calling Example1::has_an_odd_number");

    match self {
        Example1::NoValue => false,
        Example1::AnInteger(valor) => {
            if valor%2 == 1{
                return true;
            }
                
            return false;
        },
        Example1::AFloat(_valor) => false,
        Example1::AString(_valor) => false,
        Example1::ATuple(valor0, valor1) => {
            return (valor0%2 == 1) || (valor1%2 == 1);
        },
        Example1::ACLikeStruct { first, second: _ } => {
            // NÃ£o temos interesse no segundo valor que Ã© String
            first%2 == 1
        },
    }
}
```

As Ãºnicas alternativas que possuem inteiros sÃ£o ```Example1::AnInteger```, ```Example1::ATuple``` e ```Example1::ACLikeStruct```. Todas as outras alternativas retornam falso.

Note que variÃ¡veis com nome ```_valor``` e ```_``` sÃ£o valores que nÃ£o pretendemos usar. A convenÃ§Ã£o Ã© simplesmente usar underline ```_```. Usando outro nome apenas para demonstrar que todas as variÃ¡veis que comeÃ§am com o caractere underline ```_``` sÃ£o variÃ¡veis que consideramos "irrelevantes". O compilador ignora avisos de "variÃ¡vel nÃ£o utilizada" nestes casos.

---

## Exemplo de uso: UsuÃ¡rio

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

O prÃ³ximo exemplo descreve um exemplo de aplicaÃ§Ã£o para um enum.

```rust
// /src/model.rs
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}
```

Neste caso, existem 3 tipos de pessoas que podem acessar o nosso sistema:
 - FuncionÃ¡rios que podem acessar o sistema, podem fazer algumas alteraÃ§Ãµes limitadas, mas nÃ£o podem alterar regras crÃ­ticas.
 - Administradores que tem permissÃµes para alterar regras crÃ­ticas.
 - Clientes que nÃ£o tem permissÃµes para alterar dados do sistema. Mas podem alterar os prÃ³prios dados, alÃ©m de acessar os serviÃ§os do sistema.

Como descrito acima, funcionarios, administradores e clientes sÃ£o tipos/objetos diferentes. Possuem finalidades e estados diferentes. Mas, no contexto de usuÃ¡rio, sÃ£o usados da mesma forma.

Traits tambÃ©m sÃ£o usados para agrupamento. TambÃ©m devem ser considerados no planejamento de projeto. Aqui estÃ¡ a diferenÃ§a entre agrupamento com enums e agrupamento com traits:
 - Enums nos permitem agrupar diversos tipos diferentes para uma Ãºnica funcionalidade.
 - Traits nos permitem agrupar uma funcionalidade para diversos tipos diferentes.

---

### Enums limitam as possibilidades

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Isso Ã© bom em alguns casos, ruim em outros. Importante entender essa caracterÃ­stica. 

Por exemplo, digamos que tenhamos um jogo de xadrez. Existem diversas peÃ§as diferentes no tabuleiro. Eu implementei o meu projeto de xadrez da seguinte forma:

```rust
// https://github.com/On0n0k1/NCD.L1--Chess/blob/main/src/pieces/piece.rs
pub enum Piece{
    BISHOP( Bishop ),
    EMPTY(  Empty  ),
    KING(   King   ),
    KNIGHT( Knight ),
    PAWN(   Pawn   ),
    QUEEN(  Queen  ),
    ROOK(   Rook   ),
}
```

Cada peÃ§a tem sua funcionalidade, mas o tabuleiro nÃ£o tem interesse por isso. O tabuleiro precisa de receber uma lista de possiveis movimentos para calcular cheque-mate. Independente de qual peÃ§a esteja naquela posiÃ§Ã£o.

Neste caso, a limitaÃ§Ã£o de enums Ã© util, porque sabemos que existem 6 peÃ§as de xadrez diferentes (mais um para espaÃ§o vazio), e nunca serÃ¡ necessÃ¡rio expandir este enum.

Enums tambÃ©m sÃ£o Ãºteis para erros. Consideremos, como exemplo, um app de uma biblioteca. Uma funÃ§Ã£o para coletar informaÃ§Ã£o sobre um livro retorna os seguintes erros:

```rust
pub enum MessageError{
    BookNotFound(String),
    InvalidArg(String),
    MissingArg(String),
    NoPermission,

}
```

Os erros sÃ£o:
 - ```BookNotFound```: Livro nÃ£o encontrado. O String Ã© o nome do livro procurado.
 - ```InvalidArg```: Algum dos argumentos recebidos nÃ£o pode ser reconhecido. O String Ã© o argumento referido.
 - ```MissingArg```: Para o pedido especificado, um argumento necessÃ¡rio estava ausente. String Ã© o argumento.
 - ```NoPermission```: NÃ£o possui permissÃ£o para acessar o livro. Talvez seja um caso do usuÃ¡rio ser menor de idade, e o livro possuir conteÃºdo adulto.

Isso Ã© outra vantagem da "limitaÃ§Ã£o" de enums. Um desenvolvedor sabe exatamente todos os erros possÃ­veis que podem ocorrer com esse chamado de funÃ§Ã£o.

---

### FunÃ§Ã£o get_name

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

A funÃ§Ã£o get_name do ```Example2User``` simplesmente retorna o ```String``` "name" armazenado. As variÃ¡veis com nome "_" sÃ£o variÃ¡veis que iremos ignorar.

```rust
// /src/model.rs
/// Retorna nome do usuÃ¡rio.
/// 
/// O bloco que chama o mÃ©todo nÃ£o precisa de saber o que o usuÃ¡rio Ã©.
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
        Example2User::Client { name, id: _, orders: _ } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```

---

### FunÃ§Ã£o has_permission

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Esta funÃ§Ã£o retorna se o usuÃ¡rio possui permissÃ£o ou nÃ£o para uma dada aÃ§Ã£o no sistema.
 - Administradores sempre possuem permissÃ£o.
 - Clientes nunca possuem permissÃ£o.
 - FuncionÃ¡rios possuem uma lista alterÃ¡vel de permissÃµes.

Usar Strings nÃ£o Ã© uma boa idÃ©ia para permissÃµes. Enums seriam melhores, mas o exemplo jÃ¡ estÃ¡ complexo o suficiente.

```rust
// /src/model.rs
pub fn has_permission(&self, permission: String) -> bool{
    // imprime na tela que a funÃ§Ã£o foi chamada
    log("Calling Example2User::has_permission");

    match self{
        Example2User::Client { name: _, id: _, orders: _ } => { false },
        Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
        Example2User::Employee(employee) => {

            // Vec implementa a trait Iterator.
            // Isso disponibiliza o mÃ©todo .iter ao vetor.
            // Este mÃ©todo nos permite iterar referencias de String.
            // Nenhuma cÃ³pia de String Ã© feita.
            for employee_permission in employee.permissions.iter(){
                if permission == *employee_permission {
                    return true;
                }
            }

            false
        }
    }
}
```

FuncionÃ¡rio possui um ```Vec``` de Strings representando suas permissÃµes. ```Vec``` serÃ¡ explicado em detalhes na liÃ§Ã£o sobre coleÃ§Ãµes. Ã‰ uma lista alterÃ¡vel de valores.

JÃ¡ explicamos sobre as traits ```Clone``` e ```Copy```. Agora explicaremos sobre a trait ```Iterator``` ([detalhes oficiais](https://doc.rust-lang.org/std/iter/trait.Iterator.html)). Esta trait nos permite usar o vetor em uma instruÃ§Ã£o ```for```.

O mÃ©todo ```iter()```, disponilizado pela trait ```Iterator```, gera um iterador de referÃªncias. Ou seja, cada ```employee_permission``` Ã© uma referÃªncia a um elemento pertencente ao ```Vec```. NÃ£o podemos alterar os valores, mas nÃ£o gastamos computaÃ§Ã£o gerando cÃ³pias.

A instruÃ§Ã£o:

```rust
if permission == *employee_permission {
    return true;
}
```

Note o operador "*". ```employee_permission``` Ã© do tipo ```&String```. Precisamos acessar o valor do String, nÃ£o da referÃªncia. Se fosse ```&&String```, acessariamos o valor com ```**employee_permission```.

Ou seja, se o argumento da funÃ§Ã£o ```permission``` for igual Ã  String acessada, retorna verdadeiro. SenÃ£o, continua iterando.

---

### FunÃ§Ã£o get_actions

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

A funÃ§Ã£o ```get_actions``` retorna a lista de aÃ§Ãµes mais recentes realizadas pelo usuÃ¡rio.

Essa funÃ§Ã£o da uma breve introduÃ§Ã£o ao enum ```Result``` que serÃ¡ explicado em detalhes na proxima sub-liÃ§Ã£o. Simplificando, Ã© um enum que representa uma aÃ§Ã£o que pode causar um erro.

Neste exemplo, decidimos que a funÃ§Ã£o deve retornar um erro se o usuÃ¡rio for cliente.

```rust
// /src/model.rs
pub fn get_actions(&self) -> Result<Vec<String>, String> {
    log("Calling Example2User::get_actions");
    
    // Se for client, retorna um erro (Como exemplo).
    // Se for admin ou employee, retorna referencia para o Vec.
    let actions = match self{
        Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
        Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
        Example2User::Employee( employee ) => { &employee.actions },
    };

    let mut result: Vec<String> = Vec::new();
    // Usa a referÃªncia para criar uma cÃ³pia do Vec.
    for action in actions{
        result.push(action.clone());
    }

    Ok(result)
}
```

Note que a funÃ§Ã£o retorna ```Result<Vec<String>, String>```. O primeiro dos tipos ```Vec<String>``` Ã© o que consideramos uma operaÃ§Ã£o de sucesso. O segundo dos tipos ```String``` Ã© o tipo que serÃ¡ retornado se a operaÃ§Ã£o resultar em erro.

Note o bloco em que este erro Ã© chamado:

```rust
return Err(format!("User is Client"));
```

E o bloco em que a operaÃ§Ã£o Ã© um sucesso:

```rust
Ok(result)
```

```Result::Ok(value)``` ou simplesmente ```Ok(value)``` Ã© uma operaÃ§Ã£o de sucesso. ```Result::Err(err)``` ou simplesmente ```Err(err)``` Ã© uma operaÃ§Ã£o de falha. 

---

**Detalhe**: o valor entre parÃ¨nteses nÃ£o precisa de ser ```value``` ou ```err```. 

```err``` Ã© apenas convenÃ§Ã£o para erros em ```Result```.

---

**Outro detalhe**:

```rust
let mut result: Vec<String> = Vec::new();
// Usa a referÃªncia para criar uma cÃ³pia do Vec.
for action in actions{
    result.push(action.clone());
}
```

NÃ£o podemos simplesmente retornar o vetor encontrado. Este pertence ao enum. Neste caso, precisamos criar uma cÃ³pia. 
 - Criamos um ```Vec<String>``` vazio. 
 - Iteramos cada um dos valores.
 - Em cada iteraÃ§Ã£o, cria uma cÃ³pia ```action.clone()``` de um elemento, e inclui este valor ao fim do vetor ```result.push(action.clone());```

---

### Escolhendo serializador

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

Uma instruÃ§Ã£o diferente pode ser notada na implementaÃ§Ã£o de ```example_2_get_actions``` do contrato:

```rust
// /src/lib.rs
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>{
```

Isso Ã© para evitar um erro que irÃ¡ confundir muitos desenvolvedores comeÃ§ando na plataforma. A instruÃ§Ã£o ```#[result_serializer(borsh)]``` diz ao near_sdk para usar o serializador borsh na saida dessa funÃ§Ã£o.

Existem duas ferramentas de serializaÃ§Ã£o/deserializaÃ§Ã£o disponiveis para ```near_sdk```: serde e borsh. Como padrÃ£o, ```near_sdk``` usa serde para deserializar o coleÃ§Ãµes como Vec. Mas o problema Ã© que, para isso nÃ£o causar erros, precisamos implementar as traits ```Serialize``` e ```Deserialize``` ao nosso contrato.

Simplesmente selecionando borsh como serializador de resultado da funÃ§Ã£o, evitamos diversos erros. ```borsh``` Ã© mais rÃ¡pido que ```serde```. Tente evitar usar ```serde``` o mÃ¡ximo possivel.

---

## Proxima SeÃ§Ã£o

[topo](#liÃ§Ã£o-6---1-uso-de-enums)

A [prÃ³xima seÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_2_thermometer) serÃ¡ um exemplo prÃ¡tico utilizando Todos os conceitos discutidos anteriormente, mais alguns extras.

A prÃ³xima liÃ§Ã£o serÃ¡ sobre Traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// Imprime a funÃ§Ã£o sendo chamada.
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// Podemos usar instruÃ§Ãµes match para Strings e &str.
    /// 
    /// Esta funÃ§Ã£o Ã© um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o nÃºmero.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Retorna example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Retorna example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Retorna example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Chama Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Chama Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Chama Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Chama Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Chama Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Chama Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Chama Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Chama Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Chama Example2User::get_actions.
    /// 
    /// 
    /// Quando retornamos um Vec, o serializer tentarÃ¡ usar serde::json.
    /// A instruÃ§Ã£o #[result_serializer] nos permite selecionar borsh como serializador.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Testa situaÃ§Ã£o de erro com argumento 0.
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{ Serialize, Deserialize },
};    

// As duas funÃ§Ãµes a seguir sÃ£o declaradas para
// termos duas implementaÃ§Ãµes diferentes de uma mesma funÃ§Ã£o "log".
// As mensagens chamadas com essa funÃ§Ã£o log aparecerÃ£o 
// em testes e na mÃ¡quina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultÃ¢neos, um enum sÃ³ pode possuir um valor.
/// Os possiveis valores de um enum sÃ£o descritos em sua declaraÃ§Ã£o.
/// 
/// Os possiveis valores de Exemplo0 sÃ£o:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Semelhante a structs, implementamos mÃ©todos no namespace de Exemplo0 a seguir:
impl Example0{

    /// Observa o valor de si mesmo e retorna um nÃºmero entre 1 e 5.
    /// 
    /// Note o &self, significando que a funÃ§Ã£o acessa o valor, mas nÃ£o altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // InstruÃ§Ãµes match sÃ£o semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true se o valor for Exemplo0::THIRD
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compara os valores iniciando do topo
        // se colocarmos um nome de variavel, o branch acerta
        // e a variavel possui o valor no bloco associado.
        //
        // Uma variÃ¡vel que comeÃ§a com o caracter _ Ã© uma variÃ¡vel que
        // nÃ£o pretendemos utilizar.
        //
        // Devido a isso, _ sempre serÃ¡ "matched", as alternativas
        // abaixo nunca serÃ£o acessadas.
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // Descomente esse bloco e receberÃ¡ um aviso
            //     // Essa branch nunca serÃ¡ alcanÃ§ada
            //     // Porque a branch acima aplica a qualquer pattern.
            //     false
            // },
        }
    }
}

/// Um enum permite um objeto representar vÃ¡rios tipos diferentes:
/// 
/// Este exemplo possui o objetivo de mostrar que usar um enum como conteiner de valores nÃ£o Ã© uma boa ideia.
/// 
/// Os mÃ©todos de enum devem retornar resultados simples.
/// Tentar retirar os valores armazenados em enums para serem usados fora adiciona complexidade desnecessÃ¡ria ao cÃ³digo.
/// 
/// Use enums para agrupar tipos diferentes que compartilham uma funcionalidade semelhante.
/// 
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Porem, vale lembrar que um mÃ©todo ou funÃ§Ã£o deve retornar apenas um tipo de resultado especificado.
    //
    // Um desenvolvedor pode tentar criar uma funÃ§Ã£o get que retorna o valor armazenado.
    // Isso pode ser dificil de implementar.
    // 
    // A forma mais simples de uma funÃ§Ã£o get seria converter para um mesmo tipo.
    // Seguem alguns exemplos:
    //  - Retornar o valor como String
    //  - Usar Borsh ou serde para serializar o valor para bytes, deserializando apÃ³s o recebimento.
    //  - Implementar genÃ©ricos. serÃ£o explicados em outra liÃ§Ã£o.
    //  - Retornar um ponteiro? A possibilidade disso ser necessÃ¡rio Ã© baixa. O custo de complexidade Ã© muito alto.
    // 

    // O mÃ©todo a seguir retorna apenas um tipo, isso Ã© aceitÃ¡vel para o compilador.
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    /// true se o enum for Example1::NoValue.
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Retorna um inteiro, se o enum for essa alternativa.
    ///
    /// Option serÃ¡ explicado em detalhes na prÃ³xima seÃ§Ã£o.
    ///
    /// Option Ã© um enum da biblioteca padrÃ£o (standard).
    /// Representa a possibilidade de possuir um valor ou nÃ£o.
    /// Option pode ser Option::Some(valor) ou Option::None.
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // valor serÃ¡ uma referÃªncia, clonamos o valor para nÃ£o retornar uma referÃªncia.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Retorna true se possui algum numero inteiro impar,
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // NÃ£o temos interesse no segundo valor que Ã© String
                first%2 == 1
            },
        }
    }
}

/// Tipo criado para o exemplo abaixo.
/// 
/// Criado apenas para mostrar um exemplo de implementaÃ§Ã£o de struct em match.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// Exemplo mais prÃ¡tico. 
/// 
/// Representa o UsuÃ¡rio de um aplicativo.
/// 
/// Digamos que um usuÃ¡rio possa ser os seguintes tipos:
///  - Cliente
///  - Funcionario
///  - Administrador
/// 
/// Podemos controlar as permissÃµes de cada com um enum.
/// 
/// Seria melhor termos tipos struct pra cada valor, mas estamos com pressa.
/// 
/// Todos possuem nome e id, alem disso, cada um possui:
///  - Admin: passe (codificado, claro) para acesso. Lista de aÃ§Ãµes no sistema.
///  - Employee: passe (codificado) para acesso. Lista de aÃ§Ãµes. Lista de permissÃµes no sistema.
///  - Client: apenas lista de pedidos.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{

    /// Retorna nome do usuÃ¡rio.
    /// 
    /// O bloco que chama o mÃ©todo nÃ£o precisa de saber o que o usuÃ¡rio Ã©.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Checa se usuÃ¡rio possui permissÃ£o para aÃ§Ã£o.
    /// 
    /// NÃ£o Ã© uma boa ideia usar String para permissÃµes. Devido a possivel erros de caracteres, etc. Enums seriam melhor.
    /// 
    /// Mas o cÃ³digo ja estÃ¡ complexo o suficiente.
    /// 
    /// Neste exempÄºo:
    ///  - Clientes nÃ£o possuem permissÃ£o. Sempre retorna falso.
    ///  - Administradores sempre possuem permissÃ£o. Sempre retorna true.
    ///  - Empregados podem ou nÃ£o possuir permissÃ£o. Checa por permissÃµes.
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implementa a trait IntoIterator.
                // Isso disponibiliza o mÃ©todo .iter ao vetor.
                // Este mÃ©todo nos permite iterar referencias de String.
                // Nenhuma cÃ³pia de String Ã© feita.
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Retorna a lista de aÃ§Ãµes se for Admin ou Employee.
    /// 
    /// Como exemplo, digamos que o sistema precisa retornar
    /// um erro, se o usuÃ¡rio for um Client.
    /// 
    /// Result Ã© semelhante a Option. Mas Ã© usado para representar aÃ§Ãµes que podem causar erros.
    /// Explicado na proxima seÃ§Ã£o.
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // Se for client, retorna um erro (Como exemplo).
        // Se for admin ou employee, retorna referencia para o Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Usa a referÃªncia para criar uma cÃ³pia do Vec.
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Cria 6 instÃ¢ncias diferentes de Example1 para servir de exemplo.
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Retorna uma tupla com um exemplo de cada um dos valores.
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Garante que a funÃ§Ã£o get retorna as Strings esperadas.
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    /// Garante que apenas retorna true para no_value.
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Cria 3 instÃ¢ncias diferentes de Example2User para serem usadas nos testes.
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa get_name para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // Garante que o valor adiquirido para os 3 Ã© "Lucas"
        // Detalhe extra: Estamos comparando um String com um &str,
        // isso Ã© possivel porque implementam a trait partial_eq para os tipos.
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    // pub fn get_actions(&self) -> Result<Vec<String>, String> {
    
    #[test]
    fn example2_get_actions(){

        // FunÃ§Ã£o para comparar vetores
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // Ambos os vetores devem ter o mesmo nÃºmero de elementos
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Cria 3 instÃ¢ncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instÃ¢ncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // Garante que a funÃ§Ã£o retorna um Ok contendo os respectivos valores.
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // Mesmo para employee.
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // No caso de client, garante que retorna um erro.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/Cargo.toml ---
[package]
name = "lesson_6_2_thermometer"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/Readme.md ---
# LiÃ§Ã£o 6 - 2 TermÃ´metro

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/)

Neste exemplo, serÃ¡ visto uma aplicaÃ§Ã£o prÃ¡tica para os conceitos descritos nas liÃ§Ãµes anteriores. AlÃ©m dos conceitos anteriores, serÃ£o demonstrados tÃ³picos como:

 - DocumentaÃ§Ã£o de projetos;
 - Controle de acesso de usuÃ¡rios;
 - Acesso cross-contract;
 - Controle de input;
 - Controle de output;
 - Traits para conversÃ£o de tipos;

---

## Indice

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - [IdÃ©ia](#idÃ©ia)
 - [InstalaÃ§Ã£o](#instalaÃ§Ã£o)
   - [Visual Studio Code](#visual-studio-code)
   - [Rust](#rust)
   - [Near-CLI](#near-cli)
 - [Comandos Bash: CompilaÃ§Ã£o](#comandos-bash-compilaÃ§Ã£o)
   - [DocumentaÃ§Ã£o](#documentaÃ§Ã£o)
   - [Testes](#testes)
   - [CriaÃ§Ã£o de Sub-contas para Smart Contracts](#criaÃ§Ã£o-de-sub-contas-para-smart-contracts)
   - [CriaÃ§Ã£o de Sub-contas para Sensores](#criaÃ§Ã£o-de-sub-conta-para-sensores)
   - [Deletar Sub-conta](#deletar-sub-conta)
 - [Contrato](#contrato)
   - [InicializaÃ§Ã£o](#inicializaÃ§Ã£o)
   - [allow_user](#allow_user)
   - [remove_user](#remove_user)
   - [set_format](#set_format)
   - [new_entry](#new_entry)
     - [Exemplos](#exemplos-new_entry)
     - [PÃ¢nico](#pÃ¢nico-new_entry)
   - [list_update_entries](#list_update_entries)
     - [Exemplos](#exemplos-list_update_entries)
     - [PÃ¢nico](#pÃ¢nico-list_update_entries)
   - [clear_entries](#clear_entries)
     - [Argumentos](#argumentos-clear_entries)
     - [Exemplo](#exemplo-clear_entries)
     - [PÃ¢nico](#pÃ¢nico-clear_entries)
   - [view_get_format](#view_get_format)
   - [view_get](#view_get)
     - [Argumentos](#argumentos-view_get)
     - [Exemplo](#exemplo-view_get)
 - [ImplementaÃ§Ã£o](#implementaÃ§Ã£o)
   - [DocumentaÃ§Ã£o de Projetos](#documentaÃ§Ã£o-de-projetos)
     - [ComentÃ¡rios sobre Arquivo](#comentÃ¡rios-sobre-arquivo)
     - [ComentÃ¡rios e DocumentaÃ§Ã£o](#comentÃ¡rios-e-documentaÃ§Ã£o)
     - [Exemplos/Testes em DocumentaÃ§Ã£o](#exemplostestes-em-documentaÃ§Ã£o)
   - [OrganizaÃ§Ã£o de MÃ³dulos](#organizaÃ§Ã£o-de-mÃ³dulos)
   - [Controle de Acesso de UsuÃ¡rios](#controle-de-acesso-de-usuÃ¡rios)
   - [Acesso Cross-Contract](#acesso-cross-contract)
   - [Controle de Output](#controle-de-output)
   - [Controle de Input](#controle-de-input)
   - [ImplementaÃ§Ã£o de Traits](#implementaÃ§Ã£o-de-traits)
 - [Fim](#fim)

---

## IdÃ©ia

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Na seÃ§Ã£o anterior, foram descritos enums e como utilizar instruÃ§Ãµes match. AlÃ©m das funcionalidades descritas, tambÃ©m podemos utilizar enums para controlar a entrada/saida de dados. 

Digamos que um desenvolvedor de aplicativos embarcados (embedded) quer monitorar os dados de diversos termÃ´metros simultaneamente. Logo de inÃ­cio, foram notadas as seguintes restriÃ§Ãµes:

 - **Conectar** todos os dispositivos a um computador Ã© inviÃ¡vel.
 - **Manter** a mÃ¡quina como servidor 24 horas recebendo input dos sensores tambÃ©m Ã© inviÃ¡vel.
 - **Criar** um servidor nuvem como aws tambÃ©m Ã© inviÃ¡vel porque o desenvolvedor nÃ£o quer patrocinar o foguete de algum bilhonÃ¡rio.

Portanto, o desenvolvedor decide criar um smart contract para armazenar os dados. A vantagem de uma alternativa dessas sÃ£o:

 - **FÃ¡cil de implementar**. O usuÃ¡rio sÃ³ precisa de uma conta para armazenar o smart contract. Uma conta para cada sensor utilizado.
 - **FÃ¡cil de automatizar**. A Ãºnica coisa que muda entre cada aplicaÃ§Ã£o Ã© o nome dos contratos. Com bons scripts, desenvolvedores podem implementar o sistema em minutos.
 - **FÃ¡cil de expandir**. Este exemplo utiliza valores de temperatura. Mas o contrato pode ser facilmente alterado para receber qualquer tipo de dados.

Mas o contrato apenas coleta dados? NÃ£o executa nenhuma computaÃ§Ã£o sobre os dados? A computaÃ§Ã£o de dados pode ser executada localmente pelo desenvolvedor. NÃ£o hÃ¡ necessidade de desperdiÃ§ar gÃ¡s em operaÃ§Ãµes que podem ser facilmente executadas localmente.

O contrato resolve o problema de implantaÃ§Ã£o e comunicaÃ§Ã£o entre os dispositivos. JÃ¡ existem bibliotecas eficientes para ciÃªncia de dados. NÃ£o hÃ¡ necessidade de reinventar a roda. 

Resumindo. Sensores enviam dados para o smart contract. O Smart Contract armazena os dados de acordo com o nome do sensor, formato de temperatura, data e tempo de recebimento. A mÃ¡quina do usuÃ¡rio acessa o contrato e coleta os dados armazenados para processamento.

---

## InstalaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - Visual Studio Code;
 - Rust;
 - Near-cli;

### Visual Studio Code

 - Link para instalaÃ§Ã£o: https://code.visualstudio.com/ ;
 - Instale a extensÃ£o para rust: https://marketplace.visualstudio.com/items?itemName=Zerotaskx.rust-extension-pack ;

**Opcional**: O pacote de extensÃ£o acima instala uma extensÃ£o para a linguagem rust chamada ```Rust```. Esta extensÃ£o pode causar bugs de linting, principalmente quando analizando bibliotecas webassembly. Eu, pessoalmente, costumo desativar estÃ¡ extensÃ£o e ativar outra chamada ```rust-analyzer```.

**Extra**: NÃ£o tenha ```rust``` e ```rust-analyzer``` ativos simultaneamente. ```crates``` e ```Better Toml``` podem ser mantidos com ```rust-analyzer```, porÃ©m.

---

### Rust

Um script para instalaÃ§Ã£o existe em: https://www.rust-lang.org/tools/install.

ApÃ³s executar o script em um terminal, execute a seguinte instruÃ§Ã£o para permitir compilaÃ§Ã£o para webassembly:

```bash
rustup target add wasm32-unknown-unknown
```

Para desinstalar rust e todas as ferramentas associadas:

```bash
rustup self uninstall
```

---

### Near-cli

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

[(Mais detalhes)](https://docs.near.org/docs/tools/near-cli)

Ã‰ uma ferramenta npm. **Instale npm e node**. Ã‰ recomendado instalar atravÃ©s da ferramenta **npx**, para manter controle sobre diversas versÃµes no mesmo sistema. Existem diversos tutoriais para windows e linux. NÃ£o explicarei em mais detalhes.

Com **npm** e **node** instalado, instale **near-cli** globalmente com o seguinte comando:

```bash
npm install -g near-cli
```

---

## Comandos Bash: CompilaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Compile o projeto com o comando:

```bash
cargo build --target wasm32-unknown-unknown --release -p lesson_6_2_thermometer
```
 - ```--target wasm32-unknown-unknown```: Compila para webassembly;
 - ```--release```: Otimizado para produÃ§Ã£o;
 - ```-p```: Esta crate pertence ao workspace lesson_6_enums. Este comando especifica apenas lesson_6_2_thermometer para ser compilado;

---

### DocumentaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

DocumentaÃ§Ã£o sobre contrato implementada. Gere um website com todos os mÃ³dulos executando o comando:

```bash
cargo doc --open -p lesson_6_2_thermometer
```

 - p: Como o projeto estÃ¡ incluido como componente de workspace da liÃ§Ã£o "lesson_6_enums". Ã© necessÃ¡rio especificar a crate.

---

### Testes

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Execute testes de unidade com a instruÃ§Ã£o:

```bash
cargo test -p lesson_6_2_thermometer
```

Isso irÃ¡ testar os exemplos na documentaÃ§Ã£o tambÃ©m.

---

### CriaÃ§Ã£o de Sub-contas para Smart Contracts

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Onde o contrato serÃ¡ implantado. Substitua ```your-main-account.testnet``` pelo nome de sua conta NEAR. Substitua ```your-account-name``` pelo nome da conta que quiser para armazenamento do seu contrato.

```bash
near create-account your-account-name.your-main-account.testnet --masterAccount your-main-account.testnet --initialBalance 90
```

 - ```--masterAccount```: Conta "mestre", que tem permissÃµes administrativas sobre a sub-conta.
 - ```--initialBalance```: Quantidade de NEAR transferido pela conta "mestre" na criaÃ§Ã£o desta sub-conta.

---

### CriaÃ§Ã£o de sub-conta para Sensores

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

NÃ£o haverÃ£o contratos nessas sub-contas. Mas serÃ£o usadas pelos dispositivos para comunicar com a conta mestre. Substitua:

 - ```your-sub-account```: nome da conta do sensor;
 - ```your-account-name```: nome da sub-conta que possuirÃ¡ o contrato;
 - ```your-main-account```: nome da sua conta mestre;

```bash
near create-account your-sub-account.your-account-name.your-main-account.testnet --masterAccount your-account-name.your-main-account.testnet --initialBalance 10
```

 - ```--masterAccount```: Conta "mestre", que tem permissÃµes administrativas sobre a sub-conta.
 - ```--initialBalance```: Quantidade de NEAR transferido pela conta "mestre" na criaÃ§Ã£o desta sub-conta.

**RecomendaÃ§Ã£o**: Como exercÃ­cio de prÃ¡tica, aprimore este contrato fazendo com que o contrato crie/delete as sub-contas automaticamente ao executar as funÃ§Ãµes ```allow_user```/```remove_user```. NÃ£o existe documentaÃ§Ã£o sobre isso na versÃ£o "3.1.0". TerÃ¡ que clonar manualmente o repositÃ³rio, gerar documentaÃ§Ã£o com o comando ```cargo doc --open``` e encontrar a seÃ§Ã£o do mÃ³dulo ```env``` com detalhes sobre a instruÃ§Ã£o de criaÃ§Ã£o de conta. Boa sorte!

---

### Deletar sub-conta

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Ã‰ recomendado deletar as sub-contas dos sensores antes do smart contract. O primeiro argumento Ã© a conta a deletar, o segundo argumento Ã© a conta que irÃ¡ receber todo o NEAR armazenado.

```bash
near delete sub-conta-a-deletar.testnet conta-a-receber.testnet
```

 - ```sub-conta-a-deletar.testnet```: nome da sub-conta que pretende deletar;
 - ```conta-a-receber.testnet```: nome da sub-conta que irÃ¡ receber os fundos. Se o nome for invÃ¡lido, todos os fundos armazenados serÃ£o perdidos permanentemente;

---

## Contrato

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Antes de observar o funcionamento das funÃ§Ãµes. Vale saber que apÃ³s implantaÃ§Ã£o, o contrato apenas permite execuÃ§Ã£o de chamadas "call" para o dono (owner). Portanto, as chamadas call administrativas devem ser assinadas com o mesmo nome de conta do Smart Contract.

Outros usuÃ¡rios (os sensores) podem ser incluÃ­dos na lista de usuÃ¡rios permitidos. Cada usuÃ¡rio possuirÃ¡ a prÃ³pria lista de armazenamento de dados.

---

### InicializaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

O contrato inicializa automaticamente com o formato de temperatura Kelvin. O Ãºnico usuÃ¡rio incluido na lista de permissÃµes Ã© o dono (owner).

---

### allow_user:

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

```bash
near call my-contract allow_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```

FunÃ§Ã£o call. Apenas owner tem permissÃ£o de executar esta funÃ§Ã£o. NÃ£o pode ser cross-contract.

Inclui o id de conta informado na lista de usuÃ¡rios permitidos.

Argumentos:

 - account_id: String. Nome de usuÃ¡rio para incluir na lista de permissÃµes.

PÃ¢nico:

 - Se for uma chamada cross-contract;
 - Se nÃ£o for owner;
 - Se id de conta for um id invÃ¡lido.
 - Se usuÃ¡rio ja estiver incluido.

---

### remove_user:

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

```bash
near call my-contract remove_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```

FunÃ§Ã£o call. Apenas owner tem permissÃ£o de executar esta funÃ§Ã£o. NÃ£o pode ser cross-contract.

Exclui o id de conta informado da lista de usuÃ¡rios permitidos. Todos os dados armazenados relacionados a este usuÃ¡rio sÃ£o perdidos.

Owner nÃ£o pode ser removido.

Argumentos:

 - account_id: String. Nome de usuÃ¡rio para excluir da lista de permissÃµes.

PÃ¢nico:
 
 - Se for uma chamada cross-contract;
 - Se o usuÃ¡rio chamando a funÃ§Ã£o nÃ£o for owner;
 - Se o nome de usuÃ¡rio for invÃ¡lido;
 - Se o usuÃ¡rio informado nÃ£o existir na lista de permissÃµes;
 - Se o nome de usuÃ¡rio informado for o owner;

---

### set_format

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

```bash
near call my-contract set_format '{"temp_format": "Fahrenheit}' --accountId my-contract
```

```bash
near call my-contract set_format '{"temp_format": "Kelvin}' --accountId my-contract
```

```bash
near call my-contract set_format '{"temp_format": "Celsius}' --accountId my-contract
```

FunÃ§Ã£o call. Apenas owner pode executar esta funÃ§Ã£o. NÃ£o pode ser cross-contract.

Altera o formato de temperatura do sistema para o formado. 

Todo input de temperatura Ã© convertido para o formato do sistema. Isso permite que diversos sensores diferentes podem ser usados simultaneamente.

Alterar o formato de temperatura nÃ£o irÃ¡ alterar os valores armazenados anteriormente.

 - A funÃ§Ã£o call ```list_update_entries``` converte os valores armazenados antes de retornar.
 - A funÃ§Ã£o de coleta view ```view_get``` retorna os valores armazenados sem conversÃ£o de valores.

PÃ¢nico:
 - Se o nome de usuÃ¡rio for invÃ¡lido;
 - Se o usuÃ¡rio informado nÃ£o existir na lista de permissÃµes;
 - Se o nome de usuÃ¡rio informado for o owner;

---

### new_entry

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ã£o call. Todos usuÃ¡rios permitidos podem executar esta funÃ§Ã£o. Pode ser cross-contract. Adiciona um input de temperatura associado ao usuÃ¡rio que executou a funÃ§Ã£o.

Argumentos:
 - **time**: Opcional. Tupla com estrutura ```(u8, u8, f32)``` com os valores para hora minuto e segundo, respectivamente. Se omitido, o contrato utilizarÃ¡ o valor do momento em que a funÃ§Ã£o foi executada (UTC).
 - **date**: Opcional. Tupla com estrutura ```(i32, String, u8)``` com os valores para ano, mÃªs e dia, respectivamente. Se omitido, o contrato utilizarÃ¡ o dia em que a funÃ§Ã£o foi executada.
 - **temp_value**: f32, o valor de temperatura coletado. NÃ£o pode ser menor do que zero absoluto.
 - **temp_format**: Opcional, String. Se omitido, o contrato utilizarÃ¡ o formato de temperatura do sistema. Se o formato for diferente do formato do sistema, realizarÃ¡ conversÃ£o da temperatura antes de armazenar.

#### Exemplos new_entry

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

O comando abaixo armazena uma temperatura de 100.0 utilizando o formato de temperatura do sistema, no dia do sistema, no horÃ¡rio do sistema.

```bash
near call my-contract new_entry '{"temp_value": 100 }' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 100 Celsius. Utiliza o dia do recebimento da mensagem. Utiliza o horÃ¡rio do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 100, "temp_format": "Celsius"}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 50.5 Fahrenheit. Dia 11 de fevereiro, 2022. HorÃ¡rio do recebimento da mensagem. **NÃ£o causarÃ¡ panic se a data for diferente da atual**.

```bash
near call my-contract new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 11.5 Fahrenheit. Data 27 de marÃ§o, 2018. HorÃ¡rio 10:50:9.3453.

```bash
near call my-contract new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de -45.4 Celsius. HorÃ¡rio 23:41:4.443. Data do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 44.13 Kelvin. HorÃ¡rio do recebimento da mensagem. Data atual do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}' --accountID my-sensor-id
```

#### PÃ¢nico new_entry

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - Se o **usuÃ¡rio** nÃ£o tem permissÃ£o de acesso;
 - Se **hora** (time) nÃ£o for um valor negativo ou maior do que 23;
 - Se **minuto** (time) nÃ£o for um valor negativo ou maior do que 59;
 - Se **segundo** (time) for um valor negativo ou maior do que 59.9999...;
 - Se **dia** (date) for um valor invÃ¡lido para o mÃªs e ano;
 - Se **mÃªs** (date) for um String invÃ¡lido para mÃªs;
 - Se **temp_format** for um String invÃ¡lido;

---

### list_update_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ã£o call. Pode ser cross-contract. Retorna todas as entries associadas a um id de conta.

Todos os usuÃ¡rios permitidos podem acessar os prÃ³prios dados. Mas apenas owner tem permissÃ£o de acessar dados de outros usuÃ¡rios. Essa restriÃ§Ã£o existe para manter controle sobre consumo de gÃ¡s no contrato. Outros usuÃ¡rios ainda podem coletar os dados utilizando a funÃ§Ã£o view.

Argumentos:
 - account_id: Opcional. String. ID de usuÃ¡rio a ser coletado. Se omitido, retornarÃ¡ os dados do usuÃ¡rio que executou a funÃ§Ã£o.

**Retorna**: Vec com todas as entries associadas ao id de conta.

#### Exemplos list_update_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

O exemplo abaixo retorna todas as entries associadas ao usuÃ¡rio "my-sensor-id".

```bash
near call my-contract list_update_entries '{}' --accountID my-sensor-id
```

O exemplo abaixo retorna todas as entries associadas a outro usuÃ¡rio. Apenas owner tem permissÃ£o para isso.

```bash
near call my-contract list_update_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### PÃ¢nico list_update_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - Se usuÃ¡rio nÃ£o tiver permissÃ£o de acesso;
 - Se usuÃ¡rio nÃ£o for owner e estiver tentando atualizar as entries de outro usuÃ¡rio.
 - Se usuÃ¡rio nÃ£o for encontrado;

---

### clear_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ã£o call. Apenas owner pode chamar esta funÃ§Ã£o. Pode ser cross-contract. Apaga todas as entries associadas a um usuÃ¡rio.

O motivo da funÃ§Ã£o permitir cross-contract Ã© para facilitar automaÃ§Ã£o de contrato. Contratos externos nÃ£o podem incluir ou remover usuÃ¡rios permitidos. Mas podem adicionar entries, podem coletar dados e remover dados.

UsuÃ¡rios nÃ£o tem permissÃ£o de utilizar essa funÃ§Ã£o para evitar aÃ§Ãµes suspeitas. Caso um dos sensores for acessado por um terceiro, este terÃ¡ o acesso mais limitado possivel ao sistema. Sensores deste projeto existem apenas para incluir entries. Nada mais.

#### Argumentos clear_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - **account_id**: Opcional. String. ID de usuÃ¡rio para remover todas as entries. Se omitido, remove todas as entries do owner.

#### Exemplo clear_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

O exemplo abaixo remove todas as entries associadas ao id "my-sensor-id".

```rust
near call my-contract clear_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### PÃ¢nico clear_entries

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - Se o usuÃ¡rio nÃ£o for owner;
 - Se id de conta nÃ£o for encontrado;

---

### view_get_format

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ã£o view. Retorna o formato de temperatura armazenado como String.

```bash
near view my-contract view_get_format '{}'
```

--- 

### view_get

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ã£o view. Retorna um ou mais valores associados a um id de conta.

Note que esta funÃ§Ã£o Ã© uma funÃ§Ã£o view. NÃ£o realiza computaÃ§Ã£o. E ainda assim retorna dois tipos de resultado possiveis.

O tipo ```ViewGet``` Ã© declarado em './src/utils.rs'.

```rust
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

Com esta declaraÃ§Ã£o, percebe-se:

 - serde Ã© usado para serializar e deserializar o tipo para json;
 - ```#[serde(untagged)]``` faz a serializaÃ§Ã£o mostrar os valores contidos nas tuplas no json. Neste caso ```Entry``` ou ```Vec<Entry>```.

Dessa forma, o desenvolvedor pode usar as vantagens de um enum sem afetar a experiÃªncia do usuÃ¡rio. Que apenas vÃª o resultado.

**Aviso**: Este exemplo existe apenas para demonstrar a possibilidade de retornar diversos tipos. Implementar isso em outras linguagens pode aumentar a complexidade de cÃ³digo desnecessariamente. Tome cuidado com as necessidades do sistema.

#### Argumentos view_get

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

 - index: u64. Opcional. Index da entry a ser retornada. Se omitida, retorna todas as entries.
 - account_id: String. ID de usuÃ¡rio para retornar entries.

#### Exemplo view_get

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

A instruÃ§Ã£o abaixo retorna o primeiro elemento (se existir) associado a conta de usuÃ¡rio "sensor-id".

```bash
near view my-contract view_get '{"index": 0, "account_id": "sensor-id.testnet"}'
```

A instruÃ§Ã£o abaixo retorna todas as entries associadas ao id de conta "sensor-id".

```bash
near view my-contract view_get '{"account_id": "sensor-id.testnet"}'
```

---

## ImplementaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Esta seÃ§Ã£o explicarÃ¡ como as funcionalidades descritas acimas foram alcanÃ§adas.

 - DocumentaÃ§Ã£o de projetos;
 - OrganizaÃ§Ã£o de mÃ³dulos;
 - Controle de acesso de usuÃ¡rios;
 - Acesso cross-contract;
 - Controle de input;
 - Controle de output;
 - ImplementaÃ§Ã£o de traits;

---

### DocumentaÃ§Ã£o de projetos

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Como descrito [acima](#documentaÃ§Ã£o) o comando:

```bash
cargo doc --open --lesson_6_2_thermometer
```

Gera um website com a toda a documentaÃ§Ã£o do nosso projeto. A seguir serÃ£o descritos alguns detalhes sobre documentaÃ§Ã£o:

---

#### ComentÃ¡rios sobre arquivo

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Se o comentÃ¡rio Ã© iniciado com ```//! ```, a documentaÃ§Ã£o descreve sobre todo o arquivo ```.rs```, ou seja, o mÃ³dulo.

Abaixo vemos um fragmento do inicio do mÃ³dulo ```Day```, localizado no caminho ```./src/entry/schedule/date/day.rs```.

```rust
//! MÃ³dulo com todas as funcionalidades necessÃ¡rias para a 
//! representaÃ§Ã£o de dia no contrato.
//! 
//! Usamos um inteiro u8 para representar um dia. Mas 
//! precisamos garantir que este valor Ã© vÃ¡lido.
//! 
//! Devido a isso, o tipo Day Ã© representado por um struct 
//! tupla Day(u8).
//! 
//! Quando serializado para json, o valor Ã© visto como um 
//! nÃºmero u8. Ou seja, o usuÃ¡rio nÃ£o perceberÃ¡ essa 
//! complexidade.
//! 
```

ComentÃ¡rios como este devem existir no inÃ­cio do arquivo.

Recomenda-se que estes comentÃ¡rios tenha um resumo sobre toda funcionalidade disponivel no mÃ³dulo.

---

#### ComentÃ¡rios e DocumentaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

ComentÃ¡rios com "// " nÃ£o sÃ£o incluidos na documentaÃ§Ã£o. ComentÃ¡rios com "/// " descrevem o tipo abaixo.

Como exemplo, abaixo estÃ¡ a implementaÃ§Ã£o da funÃ§Ã£o ```Day::assert_valid```, que Ã© uma funÃ§Ã£o privada.

```rust
/// # Panics
/// Se dia for invalido.
fn assert_valid(&self, current_month: &Month, current_year: &Year) {
    let &Day(day) = self;

    // Coleta o valor do ano.
    let mut current_year: i32 = current_year.get();

    // Se for negativo, converte para positivo
    if current_year < 0 {
        current_year = -current_year;
    }

    // A cada 4 anos, o mÃªs de janeiro possui 29 dias, ao invez de 28.
    // true se for um "leap year".
    let leap_year: bool = (current_year % 4) == 0;
    // converte true para 1, false para 0.
    let leap_year: u8 = leap_year as u8;

    // source: https://www.rapidtables.com/calc/time/months-of-year.html
    let max_day: u8 = match current_month {
        &Month::January(_) => 31,
        &Month::February(_) => 28 + leap_year,
        &Month::March(_) => 31,
        &Month::April(_) => 30,
        &Month::May(_) => 31,
        &Month::June(_) => 30,
        &Month::July(_) => 31,
        &Month::August(_) => 31,
        &Month::September(_) => 30,
        &Month::October(_) => 31,
        &Month::November(_) => 30,
        &Month::December(_) => 31,
    };

    // panic se o valor do dia for maior que o valor referente ao mÃªs.
    assert!(day <= max_day,
        "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
            day,
            current_month,
            current_year,
            max_day,
    )
}
```

A funÃ§Ã£o acima impede que um usuÃ¡rio escolha um dia incorreto.

 - Se for informado o dia 31 para outubro, nÃ£o ocorrerÃ¡ erro;
 - Se for informado o dia 31 setembro, haverÃ¡ erro. Pois nÃ£o existe o dia 31 de setembro;
 - Se for informado o dia 29 de fevereiro em 2024, nÃ£o haverÃ¡ erro por ser ano bissexto (leap year);
 - Se for informado o dia 29 de fevereiro em 2025, haverÃ¡ erro por nÃ£o ser ano bissexto (leap year);

Note que os comentÃ¡rios escritos com "//" descrevem a implementaÃ§Ã£o do cÃ³digo e nÃ£o aparecem na documentaÃ§Ã£o.

Note como os comentÃ¡rios escritos com "///" descrevem o elemento abaixo (neste caso, a funÃ§Ã£o ```assert_valid```). Este exemplo apenas descreve que a funÃ§Ã£o entra em pÃ¢nico caso o dia seja invÃ¡lido. FunÃ§Ãµes privadas nÃ£o serÃ£o usadas por outros, entÃ£o nÃ£o hÃ¡ necessidade de documentar com extremo detalhe.

A seguir hÃ¡ um exemplo da funÃ§Ã£o ```Month::new``` no caminho ```./src/entry/schedule/month/Month.rs```.

```rust
/// Constroi uma instÃ¢ncia de MÃªs:
/// 
/// Os possiveis valores de String na esquerda sÃ£o 
/// convertidos para os seguintes valores na direita:
/// 
///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
///  - "march", "mar", "marÃ§o", "marzo" => Month::March("March")
///  - "april", "apr", "abril", "abr" => Month::April("April")
///  - "may", "maio", "mayo" => Month::May("May")
///  - "june", "jun", "junho", "junio" => Month::June("June")
///  - "july", "jul", "julho", "julio" => Month::July("July")
///  - "august", "aug", "agosto", "ago" => Month::August("August")
///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
/// 
/// # Panics
/// Se o argumento nÃ£o for nenhum dos possiveis acima.
/// 
pub fn new(month: &str) -> Self {
    let lower_case: String = month.to_ascii_lowercase();
    
    match &lower_case[..]{
        "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
        "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
        "march" | "mar" | "marÃ§o" | "marzo" => Month::March(String::from("March")),
        "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
        "may" | "maio" | "mayo" => Month::May(String::from("May")),
        "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
        "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
        "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
        "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
        "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
        "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
        "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
        invalid => panic!("Invalid value for month: {}.", invalid),
    }
}
```

A documentaÃ§Ã£o da funÃ§Ã£o acima Ã© detalhado. Isso porque, nÃ£o apenas os usuÃ¡rios necessitam de informaÃ§Ã£o sobre como mÃªs Ã© reconhecido como argumento, assim como Ã© essencial que desenvolvedores tenham acesso ao mÃ¡ximo de informaÃ§Ã£o possivel caso queiram modificar/adaptar este projeto para outros casos de uso.

Resumidamente, mÃªs Ã© convertido de uma String. VÃ¡rios Strings sÃ£o vÃ¡lidos para cada possivel valor. Por exemplo: "january", "jan", "JAN", "Janeiro", "enero" e "ene" sÃ£o todos possiveis Strings que convertem para um ```Month::January(String::from("January"))```. NÃ£o Ã© case-sensitive.

---

#### Exemplos/Testes em DocumentaÃ§Ã£o

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Exemplos existentes em documentaÃ§Ã£o sÃ£o incluidos nos testes. Segue adiante um fragmento da documentaÃ§Ã£o para o mÃ³dulo no caminho "./src/entry/schedule/date/day.rs"

```rust

//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
```

O bloco acima Ã© testado sempre que testes de unidade sÃ£o executados. 

O objetivo deste exemplo Ã© demonstrar as implementaÃ§Ãµes de traits implementadas ao tipo Day.

Linhas com "#" nÃ£o aparecem na documentaÃ§Ã£o. Existem para permitir o funcionamento correto dos testes. Assim como reduzem a complexidade do exemplo.

---

### OrganizaÃ§Ã£o de MÃ³dulos

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Ao analizar a organizaÃ§Ã£o dos arquivos. Um desenvolvedor pode ficar confuso sobre como os mÃ³dulos foram organizados. Alguns diretÃ³rios possuem um arquivo de nome "mod.rs" e outros nÃ£o. Isso Ã© porque duas formas diferentes de declarar mÃ³dulos foram usadas.

A pergunta a ser feita Ã© "Como um diretÃ³rio pode ser considerado um mÃ³dulo?". Existem duas respostas:

 - Um arquivo rust com o nome do diretÃ³rio existindo no mesmo caminho que o diretÃ³rio.
 - O arquivo rust com nome "mod.rs" dentro do diretÃ³rio.

Como exemplo:

 - O mÃ³dulo "entry" se encontra no caminho ```./src/entry/mod.rs```;
 - O mÃ³dulo "date" se encontra no caminho ```./src/schedule/date.rs```. O diretÃ³rio se encontra no mesmo caminho ```./src/schedule/```;
 - O mÃ³dulo "temperature" se encontra no caminho ```./src/temperature/mod.rs```;
 - O mÃ³dulo "time" se encontra no caminho ```./src/schedule/time.rs```. O diretÃ³rio se encontra no mesmo caminho;

---

### Controle de Acesso de UsuÃ¡rios

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

FunÃ§Ãµes call precisam ser assinadas por uma conta NEAR. Podemos controlar o acesso checando o nome da conta que fez a chamada. Quando o contrato Ã© inicializado, apenas o owner tem permissÃ£o de acessar o contrato. Outras contas podem ser incluidas atravÃ©s da funÃ§Ã£o ```Contract::allow_user```.

Cada conta adicionada nÃ£o terÃ¡ permissÃµes administrativas. Mas terÃ£o o prÃ³prio espaÃ§o de armazenamento de dados. TerÃ£o permissÃ£o para incluir entries. E terÃ£o permissÃ£o para atualizar os valores armazenados em uma conta.

O motivo da limitaÃ§Ã£o de acesso de outras contas Ã© devido a possibilidade de terceiros conseguirem acesso aos dispositivos sem permissÃ£o e usÃ¡-los para acessar o smart contract. Caso isso aconteÃ§a, a unica aÃ§Ã£o que um dispositivo infringido pode fazer Ã© incluir e listar entries. Uma aÃ§Ã£o que Ã© limitada pela quantidade de gÃ¡s disponÃ­vel na conta do usuÃ¡rio sensor.

As funÃ§Ãµes que controlam acesso ao contrato sÃ£o as funÃ§Ãµes privadas:

 - ```Contract::assert_owner_only```: Entra em pÃ¢nico se o caller nÃ£o for o owner. Owner Ã© a mesma conta em que o contrato foi implantado (deployed).
 - ```Contract::assert_user_allowed```: Entra em pÃ¢nico se o caller nÃ£o for um usuÃ¡rio incluido na lista de permitidos. Owner se encontra na lista de permitidos.

```rust
// Garante que apenas owner estÃ¡ chamando a funÃ§Ã£o.
fn assert_owner_only(&self){
    let predecessor: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = AccountId::from(env::current_account_id());

    assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
}

// Garante que apenas usuÃ¡rios permitidos podem chamar funÃ§Ãµes.
fn assert_user_allowed(&self) {
    let predecessor_id: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = env::current_account_id();

    // Se a conta dono do contrato estÃ¡ chamando a funÃ§Ã£o.
    if owner_id == predecessor_id {
        return;
    }

    // Se nÃ£o for a conta dono, e nÃ£o estiver incluido na lista de permitidos, causa panic.
    assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
}
```

AtravÃ©s do mÃ³dulo ```near_sdk::env```, temos acesso a informaÃ§Ãµes relacionadas ao ambiente da mÃ¡quina virtual, e informaÃ§Ãµes sobre a mensagem recebida. Segue a descriÃ§Ã£o de alguns dados disponibilizados pelo mÃ³dulo:

 - ```env::predecessor_account_id```: ID da ultima conta que assinou a chamada call;
 - ```env::signer_account_id```: ID da primeira conta que assinou a chamada call;
 - ```env::current_account_id```: ID da conta atual. A conta que possui o contrato;

Nas situaÃ§Ãµes mais comuns, "**predecessor_account_id**" e "**signer_account_id**" sÃ£o a mesma conta. Mas contratos podem chamar outros contratos (chamadas "cross-contract"), cada conta assina a chamada seguinte. Por exemplo, digamos que uma conta **A** chame um contrato **B**, que chama um contrato **C**, que chama um contrato **D**:

```
A -> B -> C -> D
```

Na situaÃ§Ã£o acima. Para todas as chamadas, o "**signer_account_id**" Ã© a conta A. 
O "**predecessor_account_id**" Ã©:
 
 - Para o ambiente **B**, o "**predecessor_account_id**" Ã© **A**;
 - Para o ambiente **C**, o "**predecessor_account_id**" Ã© **B**;
 - Para o ambiente **D**, o "**predecessor_account_id**" Ã© **C**;

Para ambos exemplos acimas. Coletamos "**owner_account_id**" e "**predecessor_account_id**". Se ambos sÃ£o iguais, o **chamador** Ã© o "**owner**". Se "**predecessor_account_id**" estiver incluido na lista de permitidos, entÃ£o Ã© um usuÃ¡rio permitido.

Poderiamos ter usado "**signer_account_id**". Mas isso anularia a possibilidade de chamadas cross-contract. Um desenvolvedor pode decidir adicionar mais funcionalidades a este contrato. Esta decisÃ£o manterÃ¡ a oportunidade de integraÃ§Ã£o com a funcionalidade de outros contratos.

---

### Acesso Cross-Contract

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Como descrito acima. Chamada "cross-contract" Ã© quando um contrato faz uma chamada "call" para um outro contrato. Cada conta assina a chamada seguinte. Em alguns casos isso nÃ£o Ã© desejado. Como funÃ§Ãµes que fazem alteraÃ§Ãµes crÃ­ticas ou caras no sistema. FunÃ§Ãµes em que o desenvolvedor nÃ£o deseja que sejam chamadas automaticamente.

Isso Ã© implementado atravÃ©s da funÃ§Ã£o ```Contract::no_cross_contract```. Descrito a seguir:

```rust
// Garante que o chamado Ã© direto. NÃ£o pode ser um contrato chamando outro contrato.
fn assert_no_cross_contract(&self){
    let signer_id: AccountId = env::signer_account_id();
    let predecessor_id: AccountId = env::predecessor_account_id();
    assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
}
```

Basta garantir que o "signer_account_id" Ã© o mesmo que o "predecessor_account_id".

Isto Ã© usado nas funÃ§Ãµes ```Contract::allow_user```, ```Contract::remove_user``` e ```Contract::set_format```. Usado na funÃ§Ã£o ```Contract::set_format``` . As outras funÃ§Ãµes porque sÃ£o operaÃ§Ãµes administrativas que podem incluir usuÃ¡rios indesejados, ou remover usuÃ¡rios e grande quantidade de dados do sistema.
 
 - ```Contract::set_format```: pode resultar em altos consumos de gÃ¡s para uma grande quantidade de dados;
 - ```Contract::allow_user```: pode incluir usuÃ¡rios indesejados ao sistema. Ã‰ uma funÃ§Ã£o pouco usada, mas essencial;
 - ```Contract::remove_user```: pode remover usuÃ¡rios e todos os dados associados a um respectivo usuÃ¡rio. Mal uso dessa funÃ§Ã£o pode causar danos irreversiveis aos dados;

---

### Controle de Output

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Uma mesma funÃ§Ã£o pode retornar tipos diferentes atravÃ©s do uso de enums. Para isso, primeiro criamos o enum que representa todos os possiveis tipos que podem ser retornados:

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

 - ```#[derive(Deserialize, Serialize)]``` aplica as traits ```near_sdk::serde::Deserialize``` e ```near_sdk::serde::Serialize``` ao enum. SÃ£o necessÃ¡rias para converter um json para o tipo (deserializar), e converter um tipo para json (serializar).
 - ```#[serde(crate) = "near_sdk::serde"]``` irÃ¡ informar o compilador que a crate "serde" se encontra em "near_sdk::serde". Sem essa instruÃ§Ã£o, o compilador tentarÃ¡ encontrar "serde" em uma crate Ãºnica.
 - ```#[serde(untagged)]``` Ã© um atributo da crate "serde" que informa Ã  crate para nÃ£o usar tags para este enum. Sem este atributo, o valor Ã© descrito como ```{ Single: valor }``` ou ```{ Multiple: [valor1, valor2, ...] }```. Com este atributo o valor Ã© descrito como ```valor```, ou ```[valor1, valor2, ...]```, respectivamente.

Mais detalhes sobre serde e configuraÃ§Ãµes no [site oficial](https://serde.rs/enum-representations.html) da crate.

Com o enum declarado e configurado. Basta retornar o tipo em uma funÃ§Ã£o de contrato:

```rust
pub fn view_get(
    &self, 
    index: Option<u64>, 
    account_id: String,
) -> ViewGet {
    match index{
        None => {
            let result = self.entries
                .get(&account_id)
                .unwrap()
                .to_vec();

            ViewGet::Multiple(result)
        },
        Some(index) => {
            let result = self.entries
                .get(&account_id)
                .unwrap()
                .get(index)
                .unwrap();

            ViewGet::Single(result)
        }
    }
}
```

Note que a funÃ§Ã£o acima Ã© uma funÃ§Ã£o view. ConversÃ£o de estado para json Ã© preparado durante compilaÃ§Ã£o. Ou seja, nÃ£o consome gÃ¡s.

A funÃ§Ã£o simplesmente retorna o enum ```ViewGet``` declarado anteriormente. Se o argumento "index" existe no json, retorna ```ViewGet::Single(valor)``` com o "valor" encontrado. Se argumento "index" foi omitido, retorna ```ViewGet::Multiple(valores)``` com os "valores" encontrados.

Uso do tipo Option para argumentos Ã© descrito logo a seguir.

---

### Controle de Input

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

Note a funÃ§Ã£o abaixo. Existem vÃ¡rios argumentos da funÃ§Ã£o do tipo ```Option```.

```rust
pub fn new_entry(
    &mut self, 
    time: Option<(u8, u8, f32)>,
    date: Option<(i32, String, u8)>,
    temp_value: f32, 
    temp_format: Option<String>,
){
    self.assert_user_allowed();
    let user: AccountId = env::predecessor_account_id();

    log("Called new_entry.");

    log("Creating Entry.");
    let entry: Entry = Entry::new(time, date, &self.temp_format, temp_value, temp_format);

    log("Acquiring entries for this user.");
    let mut entries = match self.entries.get(&user){
        None => panic!("Unexpected Behavior: Failed to find entries for this user."),
        Some(value) => value,
    };
    
    log("Pushing entry to Vector.");
    entries.push(&entry);
    assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

    log("Operation Successful.");
}
```

Option Ã© um tipo da biblioteca standard que pode ter duas alternativas, ```Some(valor)``` ou ```None```. Se usarmos este tipo nos argumentos das nossas funÃ§Ãµes, o usuÃ¡rio nÃ£o precisa incluir este argumento na chamada de funÃ§Ã£o.

 - Se incluir, o valor do argumento Ã© ```Some(valor)```;
 - Se nÃ£o incluir, o valor do argumento Ã© ```None```;

Usamos instruÃ§Ãµes match para considerar as duas possibilidades. Por exemplo, o ``` account_id``` Ã© opcional para a maioria das funÃ§Ãµes de contrato.

```rust
// ./src/contract.rs

pub fn list_update_entries(
    &mut self, 
    account_id: Option<String>,
) -> Vec<Entry> {
    self.assert_user_allowed();

    // let account_id: AccountId = env::predecessor_account_id();
    let account_id = match account_id{
        None => {
            env::predecessor_account_id()
        },
        Some(value) => {
            let predecessor = env::predecessor_account_id();
```

O fragmento da funÃ§Ã£o ```Contract::list_update_entries``` acima possui o argumento ```account_id``` que Ã© um Option. Se o valor para ```account_id``` existir na mensagem, usa-o. SenÃ£o usa o ```account_id``` da conta que chamou o contrato. Essa operaÃ§Ã£o Ã© repetida em diversos outras funÃ§Ãµes.

No tÃ³pico sobre [controle de output](#controle-de-output) acima. Foi descrito como usar um enum para possuir diversos tipos diferentes para o mesmo retorno de funÃ§Ã£o. Podemos usar um enum com as mesmas configuraÃ§Ãµes para aceitar diversos tipos de input tambÃ©m. NÃ£o Ã© necessÃ¡rio incluir nenhuma configuraÃ§Ã£o serde adicional.

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

Basta alterar os valores internos do enum de acordo com suas necessidades, e usar o tipo como argumento da funÃ§Ã£o de contrato.

---

### ImplementaÃ§Ã£o de Traits

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

O "dia", contido em "data", contido em "schedule" Ã© representado da seguinte forma.

```rust
// ./src/schedule/date/day.rs

#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);
```

Ã‰ apenas um ```u8``` contido em um tipo prÃ³prio. Embora esse tipo tenha sido criado para aplicarmos as limitaÃ§Ãµes que o valor de dia pode possuir. Queremos utilizar este valor como um nÃºmero nos outros casos. Para isso, aplicamos as seguintes traits:

```rust
/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Usado para converter o struct para String. Se usarmos instruÃ§Ãµes como format!, println! ou panic!, esta trait Ã© usada.
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}
```

A trait ```From``` permite a conversÃ£o de um tipo para outro. Devido a essas implementaÃ§Ãµes, para uma variÃ¡vel Day com nome day, Ã© possivel converter para u8 e String, respectivamente, com ```u8::from(&day)``` e ```String::from(&day)```.

A trait ```std::fmt::Display``` parece complicado, mas simplesmente permite o uso do tipo em macros como ```panic```, ```format``` e ```println```. Sem esta implementaÃ§Ã£o, uma instruÃ§Ã£o como ```println!("O valor de day Ã© {}", day)``` resultaria em pÃ¢nico.

---

## Fim

[topo](#liÃ§Ã£o-6---2-termÃ´metro)

A [prÃ³xima seÃ§Ã£o](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/) mostrarÃ¡ aplicaÃ§Ãµes Ãºteis para Result.

A prÃ³xima liÃ§Ã£o serÃ¡ sobre traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/contract.rs ---
//! MÃ³dulo de Contrato.
//! 
//! 

use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        Vector,
        LookupMap, 
        UnorderedSet,
    },
    env,
    json_types::ValidAccountId,
    near_bindgen,
};

near_sdk::setup_alloc!();

use crate::{
    temperature::temp_format::TempFormat,
    utils::{
        log,
        ViewGet,
    },
    entry::Entry,
};

/// Utilizado para acessar o armazenamento do contrato.
/// 
/// Cada nova instÃ¢ncia de Vector, LookupMap ou UnorderedSet precisa de um valor Ãºnico de key.
/// 
/// Usamos este enum como key.
/// 
#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    Entries,
    Users,
    UserEntry(String),
}

/// API de contrato:
/// 
/// Apenas usuÃ¡rios permitidos (ou owner) podem executar funÃ§Ãµes call ao contrato.
///
/// FunÃ§Ãµes:
///  - **allow_user**: inclui um usuÃ¡rio na lista de permissÃµes de input;
///  - **remove_user**: exclui um usuÃ¡rio da lista de permissÃµes de input;
///  - **set_format**: converte o formato de temperatura para outro;
///  - **new_entry**: inclui uma entry de temperatura;
///  - **list_update_entries**: atualiza todas as entries de um usuÃ¡rio ao formato do sistema, retornando os valores;
///  - **clear_entries**: apaga todas as entries associadas Ã  um usuÃ¡rio;
///  - **view_get_format**: funÃ§Ã£o view. Retorna formato armazenado;
///  - **view_get**: funÃ§Ã£o view. Retorna uma entry se index especificado, retorna todos os valores armazenados por um usuÃ¡rio se nÃ£o especificado;
/// 
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    temp_format: TempFormat,
    entries: LookupMap<AccountId, Vector<Entry>>,
    users: UnorderedSet<AccountId>,
    temp_length: u32,
}

// Na inicializaÃ§Ã£o de contrato,
// inclui dono na lista de usuÃ¡rios permitidos.
impl Default for Contract {
    fn default() -> Self {
        let temp_format = TempFormat::default();

        let mut entries = LookupMap::new(StorageKey::Entries);

        let owner_account: String = env::current_account_id();
        let owner_vector: Vector<Entry> = Vector::new(StorageKey::UserEntry(String::from(&owner_account)));
        let inserting = entries.insert(&owner_account, &owner_vector);
        assert!(inserting.is_none(), "Something impossible just happened. Created a LookupMap that already had a value stored.");

        let users: UnorderedSet<AccountId> = UnorderedSet::new(StorageKey::Users);

        Contract{
            temp_format,
            entries,
            users,
            temp_length: 0,
        }
    }
}

#[near_bindgen]
impl Contract{

    // Garante que apenas owner estÃ¡ chamando a funÃ§Ã£o.
    fn assert_owner_only(&self){
        let predecessor: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = AccountId::from(env::current_account_id());

        assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
    }

    // Garante que o chamado Ã© direto. NÃ£o pode ser um contrato chamando outro contrato.
    fn assert_no_cross_contract(&self){
        let signer_id: AccountId = env::signer_account_id();
        let predecessor_id: AccountId = env::predecessor_account_id();
        assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
    }

    // Garante que apenas usuÃ¡rios permitidos podem chamar funÃ§Ãµes.
    fn assert_user_allowed(&self) {
        let predecessor_id: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        // Se a conta dono do contrato estÃ¡ chamando a funÃ§Ã£o.
        if owner_id == predecessor_id {
            return;
        }

        // Se nÃ£o for a conta dono, e nÃ£o estiver incluido na lista de permitidos, causa panic.
        assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
    }

    /// Inclui usuÃ¡rio na lista de permissÃµes, cria um Vector para armazenamento de entries para este usuÃ¡rio.
    /// 
    /// Apenas owner tem permissÃ£o de chamar esta funÃ§Ã£o.
    /// 
    /// # Panics
    ///  - Se for uma chamada cross-contract;
    ///  - Se nÃ£o for owner;
    ///  - Se **account_id** for um ID de conta invÃ¡lido;
    ///  - Se usuÃ¡rio ja estiver incluido;
    /// 
    pub fn allow_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called allow_user.");

        // Testa se o nome de usuario Ã© vÃ¡lido.
        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        // Se usuario ja estiver contido na lista de permissÃµes, causa panic.
        log("Checking if user already exists.");
        let contains: bool = self.users.contains(&account_id);
        assert!(!contains, "User {} is already included in allowed list.", &account_id);
        
        // Cria um vetor para entries e inclui ao mapa.
        log("New user detected. Storing User.");
        let user_vector: Vector<Entry> = Vector::new(StorageKey::UserEntry(String::from(&account_id)));
        let inserting = self.entries.insert(&account_id, &user_vector);
        
        // A asserÃ§Ã£o abaixo deve ser impossivel de falhar. Se esta falhar, o cÃ³digo possui um erro de implementaÃ§Ã£o.
        // Porque Ã© esperado que a asserÃ§Ã£o acima sempre falhe antes desta.
        assert!(inserting.is_none(), "Unexpected behavior. User is already included in entries.");

        // Insere nome de usuÃ¡rio na lista de usuÃ¡rios permitidos.
        self.users.insert(&account_id);
    }

    /// Remove usuÃ¡rio da lista de permissÃµes.
    /// 
    /// Apenas owner tem permissÃ£o de chamar esta funÃ§Ã£o.
    /// 
    /// # Panics
    ///  - Se for cross-contract;
    ///  - Se nÃ£o for owner;
    ///  - Se o nome de usuÃ¡rio for invÃ¡lido;
    ///  - Se usuÃ¡rio informado nÃ£o existir na lista de permissÃµes;
    ///  - Se o nome de usuÃ¡rio informado for o owner;
    /// 
    pub fn remove_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        // Conta dono Ã© criada na inicializaÃ§Ã£o de contrato. A possibilidade de remover a conta dono seria um problema.
        let owner_id: AccountId = AccountId::from(env::current_account_id());
        assert_ne!(&owner_id[..], &account_id[..], "Owner account can't be removed from contract.");

        log("Called remove_user");

        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        // Se usuario nÃ£o estiver contido na lista de permissÃµes, causa panic.
        log("Checking if user exists.");

        let contains: bool = self.users.contains(&account_id);
        assert!(contains, "User {} not found.", &account_id);

        // Remove vetor de entries referente ao usuario.
        let entries: Option<Vector<Entry>> = self.entries.remove(&account_id);
        assert!(entries.is_some(), "Unexpected Behavior. Found user, but didn't find entry list for user.");

        // Ownership do vetor veio do LookupMap para aqui.
        // Limpa o vetor para garantir seguranÃ§a de memÃ³ria.
        // Vetor serÃ¡ liberado da memÃ³ria no fim desta funÃ§Ã£o.
        let mut entries: Vector<Entry> = entries.unwrap();
        entries.clear();

        match self.users.remove(&account_id){
            true => {
                log("User successfully removed.");
            },
            false => {
                log("Unexpected Behavior. Account exists in entries but doesn't exist in user list.");
            },
        };
    }

    
    /// Altera formato de temperatura para o valor informado.
    /// 
    /// NÃ£o modifica entries armazenadas. Estas sÃ£o alteradas quando retornadas pela funÃ§Ã£o list_update_entries.
    /// 
    /// Apenas owner tem permissÃ£o de chamar esta funÃ§Ã£o.
    /// 
    /// # Panics
    ///  - Se for cross-contract;
    ///  - Se o usuÃ¡rio informado nÃ£o for encontrado na lista de permissÃµes;
    ///  - Se o usuÃ¡rio nÃ£o for owner;
    /// 
    pub fn set_format(&mut self, temp_format: String) {
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called set_format");

        let temp_format = TempFormat::new(&temp_format);

        log(
            &format!("Setting default temperature format to {}", &temp_format)
        );

        self.temp_format = temp_format;
    }
    

    // Exemplo de argumento para esta funÃ§Ã£o: '{"time": [11, 32, 10, 0.85], "date": [2022, "feb", 11], "value": 127, "arg_temp": "k" }'

    /// Armazena um valor de temperatura associado Ã  conta de usuÃ¡rio.
    /// 
    /// Date e time sÃ£o opcionais. Caso nÃ£o informados, o sistema usarÃ¡ a data e horÃ¡rios do recebimento da mensagem.
    /// 
    /// format Ã© opcional. Se nÃ£o informado, usarÃ¡ o formato de temperatura do sistema.
    /// 
    /// # Panics
    ///  - Se usuÃ¡rio nÃ£o tem permissÃ£o de acesso;
    ///  - Se hora (time) for um valor negativo ou maior do que 23;
    ///  - Se minuto (time) for um valor negativo ou maior do que 59;
    ///  - Se segundo (time) for um valor negativo ou maior do que 59.99999....
    ///  - Se dia (date) for um valor invÃ¡lido para o mÃªs e ano;
    ///  - Se mÃªs (date) for um String invÃ¡lido para mÃªs;
    ///  - Se temp_format for um String invÃ¡lido;
    /// 
    /// # Exemplos (bash)
    ///  - new_entry '{"temp_value": 100 }'
    ///  - new_entry '{"temp_value": 100, "temp_format": "Celsius"}'
    ///  - new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}'
    ///  - new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}'
    ///  - new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}'
    ///  - new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}'
    /// 
    pub fn new_entry(
        &mut self, 
        time: Option<(u8, u8, f32)>,
        date: Option<(i32, String, u8)>,
        temp_value: f32, 
        temp_format: Option<String>,
    ){
        self.assert_user_allowed();
        let user: AccountId = env::predecessor_account_id();

        log("Called new_entry.");

        log("Creating Entry.");
        let entry: Entry = Entry::new(time, date, &self.temp_format, temp_value, temp_format);

        log("Acquiring entries for this user.");
        let mut entries = match self.entries.get(&user){
            None => panic!("Unexpected Behavior: Failed to find entries for this user."),
            Some(value) => value,
        };
        
        log("Pushing entry to Vector.");
        entries.push(&entry);
        assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

        log("Operation Successful.");
    }

    /// Retorna a lista de entries associadas ao usuÃ¡rio, atualiza os valores com os do sistema, caso diferentes.
    /// 
    /// Se account_id for omitido, retorna as entries do usuÃ¡rio que chamou.
    /// 
    /// Apenas owner tem permissÃ£o de acessar e atualizar as entries de outros usuÃ¡rios.
    /// 
    /// # Panics
    ///  - Se usuÃ¡rio nÃ£o tiver permissÃ£o de acesso;
    ///  - Se usuÃ¡rio nÃ£o for owner e estiver tentando atualizar as entries de outros;
    ///  - Se usuÃ¡rio nÃ£o for encontrado;
    /// 
    pub fn list_update_entries(
        &mut self, 
        account_id: Option<String>,
    ) -> Vec<Entry> {
        self.assert_user_allowed();

        // let account_id: AccountId = env::predecessor_account_id();
        let account_id = match account_id{
            None => {
                env::predecessor_account_id()
            },
            Some(value) => {
                let predecessor = env::predecessor_account_id();

                if predecessor != value {
                    let signer_id: AccountId = env::signer_account_id();
                    let owner_id: AccountId = AccountId::from(env::current_account_id());

                    assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
                }

                value
            }
        };
        
        let mut entries: Vector<Entry> = match self.entries.get(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(value) => value,
        };

        let mut entries_vec = entries.to_vec();

        let temp_format: TempFormat = self.temp_format.clone();
        let mut changed: bool = false;
        let mut index: u64 = 0;

        // entries.to_vec()
        for entry in entries_vec.iter_mut(){
            if entry.update_temp_format(&temp_format) {
                changed = true;
                entries.replace(index, &entry);
            };

            index += 1;
        };

        if changed {
            self.entries.insert(&account_id, &entries);
        }
        
        entries_vec
    }

    /// Apaga todas as entries associadas a um usuÃ¡rio.
    /// 
    /// Se account_id for omitido, apaga as entries do usuÃ¡rio que chamou a funÃ§Ã£o.
    /// 
    /// Apenas owner tem permissÃ£o de chamar esta funÃ§Ã£o.
    /// 
    /// # Panics
    ///  - Se usuÃ¡rio nÃ£o for owner;
    ///  - Se id de conta nÃ£o estiver na lista de permitidos;
    /// 
    pub fn clear_entries(
        &mut self, 
        account_id: Option<String>,
    ){
        self.assert_owner_only();
        
        let account_id: String = match account_id {
            None => env::predecessor_account_id(),
            Some(value) => {
                log("Validating user account.");

                match ValidAccountId::try_from(value){
                    Ok(account_id) => String::from(account_id),
                    Err(err) => panic!("Invalid user account id: {}.", err),
                }
            }
        };

        assert!(self.users.contains(&account_id), "Account {} not found.", &account_id);
        
        let entries: Vector<Entry> = match self.entries.remove(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(mut value) => {
                value.clear();
                value
            },
        };

        assert!(
            self.entries.insert(&account_id, &entries).is_none(),
            "Unexpected behavior, attempted to remove the vector for {}, but it still exists after removing.", 
            &account_id,
        );

        log(&format!("Successfully removed all entries for {}.", &account_id));
    }

    // View Functions

    /// Retorna formato de temperatura.
    pub fn view_get_format(&self) -> String {
        String::from(&self.temp_format)
    }

    /// Retorna Entry para usuario.
    /// 
    /// Se index nÃ£o for especificado, retorna todos os valores associados ao usuÃ¡rio.
    /// 
    /// NÃ£o converte as temperaturas armazenadas (caso seja diferente do sistema.)
    /// 
    pub fn view_get(
        &self, 
        index: Option<u64>, 
        account_id: String,
    ) -> ViewGet {
        match index{
            None => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .to_vec();

                ViewGet::Multiple(result)
            },
            Some(index) => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .get(index)
                    .unwrap();

                ViewGet::Single(result)
            }
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/entry/mod.rs ---
//! Entry representa um Ãºnico input de um dos usuÃ¡rios.
//! 
//! Periodicamente cada sensor enviarÃ¡ o valor de temperatura coletado. O contrato armazenarÃ¡ cada entry associada ao tempo recebido.
//! 
//! Cada Entry possui os seguintes atributos:
//!  - temperature: Um valor de temperatura (f32), associado a um formato de temperatura (Kelvin, Celsius, Fahrenheit);
//!  - schedule: Momento de recebimento do input. Formato de tempo Ã© UTC. Que tal implementar suporte a diversos fuso-horarios depois?
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use crate::{
    schedule::Schedule,
    temperature::{
        Temperature,
        temp_format::TempFormat,
    }
};

/// Representa um momento de temperatura e tempo.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Entry{
    schedule: Schedule,
    temperature: Temperature,
}

impl Entry{
    /// Constroi uma instÃ¢ncia de Entry.
    /// 
    ///  - Se time (horario) for omitido. O valor serÃ¡ o momento da chamada da mensagem.
    ///  - Se date (data) for omitida. O valor serÃ¡ o dia da chamada da mensagem.
    ///  - Se o formato de temperatura for omitido, utilizarÃ¡ o formato de temperatura do sistema.
    ///  - value representa o valor de temperatura.
    /// 
    ///  # Panics
    ///  - se temperatura for menor que zero absoluto;
    ///  - se dia for invÃ¡lido;
    ///  - se mÃªs for invÃ¡lido;
    /// 
    pub fn new(
            time: Option<(u8, u8, f32)>,
            date: Option<(i32, String, u8)>,
            temp_format: &TempFormat, 
            value: f32, 
            arg_temp: Option<String>,
        ) -> Self {
        
        let schedule: Schedule = Schedule::new(date, time);
        let temperature: Temperature = Temperature::new(value, temp_format, arg_temp);

        Entry { 
            schedule, 
            temperature,
        }
    }

    /// Se new_format for um formato de temperatura diferente do atual. Atualiza e realiza a conversÃ£o de valores.
    pub fn update_temp_format(&mut self, new_format: &TempFormat) -> bool{
        self.temperature.update_temp_format(new_format)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/lib.rs ---
// NÃ£o queremos que este mÃ³dulo apareÃ§a na documentaÃ§Ã£o. MÃ³dulo Ã© pÃºblico apenas internamente.
pub(crate) mod contract;
pub mod entry;
pub mod schedule;
pub mod temperature;
pub mod utils;

pub use contract::Contract;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date.rs ---
//! MÃ³dulo que representa data.
//! 
//! Usado por Schedule.
//! 
//! Composto por Day, Month e Year.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod day;
pub mod month;
pub mod year;

use day::Day;
use month::Month;
use year::Year;

/// Representa uma data (Dia, MÃªs, Ano).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Date{
    day: Day,
    month: Month,
    year: Year,
}

impl Date{
    /// ConstrÃ³i uma instÃ¢ncia de data.
    /// 
    /// # Panics
    ///  - Se Day for negativo;
    ///  - Se Day maior do que o limite para o mÃªs e ano;
    ///  - Se Month for um String invÃ¡lido;
    /// 
    pub fn new(day: u8, month: &str, year: i32) -> Date {
        // Cria uma instÃ¢ncia de tipo representando ano.
        let year: Year = Year::new(year);
        // Cria uma instÃ¢ncia de tipo representando mÃªs.
        let month: Month = Month::new(month);
        // Cria uma instÃ¢ncia de tipo representando dia.
        let day: Day = Day::new(day, &month, &year);

        Date{
            day,
            month,
            year,
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/day.rs ---
//! MÃ³dulo com todas as funcionalidades necessÃ¡rias para a 
//! representaÃ§Ã£o de dia no contrato.
//! 
//! Usamos um inteiro u8 para representar um dia. Mas 
//! precisamos garantir que este valor Ã© vÃ¡lido.
//! 
//! Devido a isso, o tipo Day Ã© representado por um struct 
//! tupla Day(u8).
//! 
//! Quando serializado para json, o valor Ã© visto como um 
//! nÃºmero u8. Ou seja, o usuÃ¡rio nÃ£o perceberÃ¡ essa 
//! complexidade.
//! 
//! O tipo Day pode ser construido atravÃ©s da funÃ§Ã£o 
//! associada Day::new. Esta funÃ§Ã£o precisa do mÃªs e ano 
//! para saber o limite mÃ¡ximo e se Ã© leap year, 
//! respectivamente. Seguem outras utilidades:
//!  - u8::from(day) nos permite converter um Day para u8;
//!  - String::from(day) nos permite converter um Day para 
//! String;
//!  - std::fmt::Display Ã© implementado, portanto podemos 
//! usar o tipo para macros como println!("{}", day) 
//! ou panic!("{}", day) .
//! 
//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Serialize, Deserialize },
};

use crate::schedule::date::{
    month::Month,
    year::Year,
};

/// Representa um valor de dia.
/// 
/// Quando serializado, este tipo Ã© visto como um u8.
/// 
/// Garante que Ã© um dia vÃ¡lido para o mÃªs e ano.
/// 
/// Deve ser positivo e menor do que 28-31 dependendo do mÃªs e ano.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);

impl Day{
    /// Constroi uma instÃ¢ncia de dia.
    ///  - day: dia, valor entre 1 e 31, dependendo do mÃªs/ano.
    ///  - current_month: mÃªs atual, para validaÃ§Ã£o.
    ///  - current_year: ano atual, para validaÃ§Ã£o.
    /// 
    /// # Panics
    /// Se dia for invÃ¡lido.
    /// 
    pub fn new(day: u8, current_month: &Month, current_year: &Year) -> Self {
        let day = Day(day);
        day.assert_valid(current_month, current_year);

        day
    }

    /// # Panics
    /// Se dia for invalido.
    fn assert_valid(&self, current_month: &Month, current_year: &Year) {
        let &Day(day) = self;

        // Coleta o valor do ano.
        let mut current_year: i32 = current_year.get();

        // Se for negativo, converte para positivo
        if current_year < 0 {
            current_year = -current_year;
        }

        // A cada 4 anos, o mÃªs de janeiro possui 29 dias, ao invez de 28.
        // true se for um "leap year".
        let leap_year: bool = (current_year % 4) == 0;
        // converte true para 1, false para 0.
        let leap_year: u8 = leap_year as u8;

        // source: https://www.rapidtables.com/calc/time/months-of-year.html
        let max_day: u8 = match current_month {
            &Month::January(_) => 31,
            &Month::February(_) => 28 + leap_year,
            &Month::March(_) => 31,
            &Month::April(_) => 30,
            &Month::May(_) => 31,
            &Month::June(_) => 30,
            &Month::July(_) => 31,
            &Month::August(_) => 31,
            &Month::September(_) => 30,
            &Month::October(_) => 31,
            &Month::November(_) => 30,
            &Month::December(_) => 31,
        };

        // panic se o valor do dia for maior que o valor referente ao mÃªs.
        assert!(day <= max_day,
            "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
                day,
                current_month,
                current_year,
                max_day,
        )
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Usado para converter o struct para String. Se usarmos instruÃ§Ãµes como format!, println! ou panic!, esta trait Ã© usada.
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/month.rs ---
//! MÃ³dulo com todas as funcionalidades necessÃ¡rias para a 
//! representaÃ§Ã£o de mÃªs no contrato.
//! 
//! Para uma fÃ¡cil implementaÃ§Ã£o rust, utilizamos um enum 
//! com todos os possiveis valores de mÃªs.
//! Mas para representaÃ§Ã£o json, a melhor opÃ§Ã£o Ã© utilizar 
//! um String, ou nÃºmero.
//! 
//! Configurando serde, podemos utilizar o melhor de ambos 
//! os casos. Primeiro, declaramos o enum da seguinte forma:
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Se o valor de Month for 
//! Month::December(String::from("December")), 
//! por exemplo, o valor de estado aparecerÃ¡ 
//! como month: {December: "December"}.
//! 
//! Mas, se incluirmos o atributo macro 
//! serde(untagged), da seguinte forma:
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! #[serde(untagged)]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Um valor de mÃªs 
//! Month::december(String::from("December")), 
//! irÃ¡ aparecer simplesmente como month: "December". 
//! O que Ã© muito mais user-friendly.
//! 
//!  - u8::from(&month) converte um mÃªs para um inteiro 
//! de 0 a 11. NÃ£o consome o mÃªs;
//!  - Month::from(a_u8_var) converte um valor u8 
//! informado para Month. Panic se nÃ£o for um valor 
//! entre 0 a 11.
//!  - String::from(&month) constroi uma String com 
//! o mesmo valor de Month.
//!  - String::from(month) consome o Month, convertendo-o 
//! para um String.
//!  - std::fmt::Display Ã© implementado para Month. 
//! Podendo ser utilizado em macros como println!, 
//! format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um mÃªs.
/// 
/// Devido a instruÃ§Ã£o "serde(untagged)" o valor deste 
/// enum Ã© representado por um String.
/// 
/// Pode ser convertido de/para um String.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Month{
    January(String),
    February(String),
    March(String),
    April(String),
    May(String),
    June(String),
    July(String),
    August(String),
    September(String),
    October(String),
    November(String),
    December(String),
}

impl Month{
    /// Constroi uma instÃ¢ncia de MÃªs:
    /// 
    /// Os possiveis valores de String na esquerda sÃ£o 
    /// convertidos para os seguintes valores na direita:
    /// 
    ///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
    ///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
    ///  - "march", "mar", "marÃ§o", "marzo" => Month::March("March")
    ///  - "april", "apr", "abril", "abr" => Month::April("April")
    ///  - "may", "maio", "mayo" => Month::May("May")
    ///  - "june", "jun", "junho", "junio" => Month::June("June")
    ///  - "july", "jul", "julho", "julio" => Month::July("July")
    ///  - "august", "aug", "agosto", "ago" => Month::August("August")
    ///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
    ///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
    ///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
    ///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
    /// 
    /// # Panics
    /// Se o argumento nÃ£o for nenhum dos possiveis acima.
    /// 
    pub fn new(month: &str) -> Self {
        let lower_case: String = month.to_ascii_lowercase();
        
        match &lower_case[..]{
            "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
            "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
            "march" | "mar" | "marÃ§o" | "marzo" => Month::March(String::from("March")),
            "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
            "may" | "maio" | "mayo" => Month::May(String::from("May")),
            "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
            "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
            "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
            "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
            "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
            "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
            "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
            invalid => panic!("Invalid value for month: {}.", invalid),
        }
    }

    // jan 31
    // feb 59
    // mar 90
    // apr 120
    // may 151
    // jun 181
    // jul 212
    // aug 243
    // sep 273
    // octo 304
    // nov 334
    // dec 365

    /// Recebe um valor entre 0 e 365. Retorna o mÃªs e 
    /// dia do ano, baseado no dia do ano.
    /// 
    /// Se is_leap_year Ã© true. Aceita uma valor entre 
    /// 0 e 366. 29 fev Ã© uma possibilidade de data.
    /// 
    pub fn new_from_days(mut days: u64, is_leap_year: bool) -> (String, u8) {
        // 0 false 1 true
        let leap_year: u64 =  is_leap_year as u64;
        assert!(days < 365 + leap_year, "Unexpected Behavior. Days should be lower than {}. Got {}.", 365 + leap_year, days);
        // day 0 = jan 1
        days += 1;

        if days <= 31 {
            return (String::from("jan"), days as u8);
        }
        if days <= 59 + leap_year {
            // inclui feb 29 se for leap year
            return (String::from("feb"), days as u8 - 31);
        }
        if days <= 90 + leap_year {
            return (String::from("mar"), (days - 59 - leap_year) as u8);
        }
        if days <= 120 + leap_year {
            return (String::from("apr"), (days - 90 - leap_year) as u8);
        }
        if days <= 151 + leap_year {
            return (String::from("may"), (days - 120 - leap_year) as u8);
        }
        if days <= 181 + leap_year {
            return (String::from("jun"), (days - 151 - leap_year) as u8);
        }
        if days <= 212 + leap_year {
            return (String::from("jul"), (days - 181 - leap_year) as u8);
        }
        if days <= 243 + leap_year {
            return (String::from("aug"), (days - 212 - leap_year) as u8);
        }
        if days <= 273 + leap_year {
            return (String::from("sep"), (days - 243 - leap_year) as u8);
        }
        if days <= 304 + leap_year {
            return (String::from("oct"), (days - 273 - leap_year) as u8);
        }
        if days <= 334 + leap_year {
            return (String::from("nov"), (days - 304 - leap_year) as u8);
        }

        (String::from("dec"), (days - 334 - leap_year) as u8)  
    }

    /// Retorna uma representaÃ§Ã£o String deste MÃªs.
    pub fn get(&self) -> String {
        match self {
            Month::January(value) => value.clone(),
            Month::February(value) => value.clone(),
            Month::March(value) => value.clone(),
            Month::April(value) => value.clone(),
            Month::May(value) => value.clone(),
            Month::June(value) => value.clone(),
            Month::July(value) => value.clone(),
            Month::August(value) => value.clone(),
            Month::September(value) => value.clone(),
            Month::October(value) => value.clone(),
            Month::November(value) => value.clone(),
            Month::December(value) => value.clone(),
        }
    }
}

/// Nos permite utilizar u8::from(&nossoMonth) para 
/// conver um mÃªs para u8.
impl From<&Month> for u8 {
    fn from(month: &Month) -> u8 {
        match month {
            Month::January(_) => 0,
            Month::February(_) => 1,
            Month::March(_) => 2,
            Month::April(_) => 3,
            Month::May(_) => 4,
            Month::June(_) => 5,
            Month::July(_) => 6,
            Month::August(_) => 7,
            Month::September(_) => 8,
            Month::October(_) => 9,
            Month::November(_) => 10,
            Month::December(_) => 11,
        }
    }
}

/// Nos permite utilizar Month::from(nossou8) para 
/// converter um valor u8 para Month.
impl From<u8> for Month {
    fn from(month: u8) -> Month {
        match month{
            0 => Month::new("jan"),
            1 => Month::new("feb"),
            2 => Month::new("mar"),
            3 => Month::new("apr"),
            4 => Month::new("may"),
            5 => Month::new("jun"),
            6 => Month::new("jul"),
            7 => Month::new("aug"),
            8 => Month::new("sep"),
            9 => Month::new("oct"),
            10 => Month::new("nov"),
            11 => Month::new("dec"),
            invalid => panic!("Invalid value for month: {}. Number value must be positive, lower than 12.", invalid),
        }
    }
}

/// Nos permite usar String::from(nossoMonth)
impl From<&Month> for String{
    fn from(month: &Month) -> String {
        month.get()
    }
}

/// Nos permite usar String::from(nossoMonth)
impl From<Month> for String{
    fn from(month: Month) -> String {
        String::from(&month)
    }
}

/// Usado para converter o struct para String. Se 
/// usarmos instruÃ§Ãµes como format!, println! ou panic!, 
/// esta trait Ã© usada.
impl std::fmt::Display for Month {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

#[cfg(test)]
mod tests{
    use crate::utils::log;
    use crate::schedule::Month;

    #[test]
    /// Testa a funÃ§Ã£o Month::new_from_days para todos 
    /// os dias do ano, leap year e nÃ£o leap year.
    fn new_from_days(){

        /// usado por testing year. Argumentos:
        ///  - days: valor entre 0 e 365. 0 e 366 se 
        /// is_leap_year = true.
        ///  - is_leap_year: true se for leap year
        ///  - expected_month: mes esperado, valor entre 
        /// 0 e 12.
        ///  - expected_day: dia esperado, valor entre 
        /// 0 e 31, depende do mÃªs e leap year.
        /// 
        fn util_day_constructor(days: u64, is_leap_year: bool, expected_month: u8, expected_day: u8) {
            let (month_str, day) = Month::new_from_days(days, is_leap_year);
            let month_number = u8::from(&Month::new(&month_str));
    
            assert_eq!(
                month_number, 
                expected_month, 
                "Comparison error when constructing day. Expected month: {}, number: {}. Got {}.", 
                Month::from(expected_month), 
                expected_month, 
                month_number,
            );

            assert_eq!(
                day, 
                expected_day, 
                "Comparison error when constructing day. Expected day: {}. Got: {}.", 
                expected_day, 
                day,
            );
        }

        /// Usa util_day_constructor para testar todos 
        /// os dias do ano.
        fn testing_year(is_leap_year: bool){
            let leap_year = is_leap_year as u64;

            #[allow(unused_mut)]
            let mut day_number;
            #[allow(unused_mut)]
            let mut month_number;

            for day in 0..(365 + leap_year) {
                if day < 31 { 
                    day_number = day;
                    month_number = 0; 
                } else if day < 59 + leap_year{ 
                    day_number = day - 31;
                    month_number = 1; 
                } else if day < 90 + leap_year { 
                    day_number = day - 59 - leap_year;
                    month_number = 2;  
                } else if day < 120 + leap_year{ 
                    day_number = day - 90 - leap_year;
                    month_number = 3; 
                } else if day < 151 + leap_year{ 
                    day_number = day - 120 - leap_year;
                    month_number = 4; 
                } else if day < 181 + leap_year { 
                    day_number = day - 151 - leap_year;
                    month_number = 5; 
                } else if day < 212 + leap_year{ 
                    day_number = day - 181 - leap_year;
                    month_number = 6; 
                } else if day < 243 + leap_year{ 
                    day_number = day - 212 - leap_year;
                    month_number = 7; 
                } else if day < 273 + leap_year{ 
                    day_number = day - 243 - leap_year;
                    month_number = 8; 
                } else if day < 304 + leap_year{ 
                    day_number = day - 273 - leap_year;
                    month_number = 9; 
                } else if day < 334 + leap_year{ 
                    day_number = day - 304 - leap_year;
                    month_number = 10; 
                } else { 
                    day_number = day - 334 - leap_year;
                    month_number = 11; 
                }

                // Primeiro dia do mÃªs Ã© 1. 
                util_day_constructor(day, is_leap_year, month_number, day_number as u8 + 1)
             }
        }

        // Testa a construÃ§Ã£o de day para todos os dias do ano. NÃ£o Ã© leap year.
        log("Testing for non leap year.");
        testing_year(false);

        // Testa a construÃ§Ã£o de day para todos os dias do ano. Ã‰ leap year.
        log("Testing for leap year.");
        testing_year(true);
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/year.rs ---
//! MÃ³dulo com todas as funcionalidades necessÃ¡rias para o 
//! funcionamento de um ano no contrato.
//! 
//! Ano Ã© representado por uma tupla com um inteiro e um 
//! String.
//! 
//! - String::from(year) converte um Year para String;
//! - String::from(&year) converte uma referÃªncia para 
//! String;
//! - std::fmt::Display Ã© implementado. Portanto pode 
//! ser usado em macros como format!, println! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tupla representando um valor de ano. 
/// 
/// O primeiro valor (i32) Ã© um inteiro para computaÃ§Ã£o.
///  
/// O segundo Ã© um String representando o valor formatado.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Year(i32, String);

impl Year{
    /// ConstrÃ³i uma instÃ¢ncia de Year.
    pub fn new(mut value: i32) -> Year {
        let is_negative = value < 0;
        if is_negative{
            value = -value;
        }

        let text: &str = match is_negative{
            false => {
                "BC"
            },
            true => {
                "AD"
            }
        };

        let text: String = format!("{} {}", value, text);
        if is_negative {
            value = -value;
        }

        Year(value, text)
    }

    /// Retorna ano como i32.
    pub fn get(&self) -> i32 {
        // Year Ã© uma tupla, .0 acessa o primeiro valor da tupla.
        // i32 implementa copy, entÃ£o nÃ£o precisamos de escrever self.0.clone()
        self.0
    }
}

/// Nos permite usar String::from(&nossoYear)
impl From<&Year> for String{
    fn from(year: &Year) -> String {
        year.1.clone()
    }
}

/// Nos permite usar String::from(nossoYear)
impl From<Year> for String{
    fn from(year: Year) -> String {
        String::from(&year)
    }
}

// Usado para converter o struct para String. Se usarmos instruÃ§Ãµes como format!, println! ou panic!, esta trait Ã© usada.
impl std::fmt::Display for Year {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/mod.rs ---
//! MÃ³dulo para um schedule (cronograma).
//! 
//! Um valor de temperatura nÃ£o possui muita utilidade sem um tempo associado. Este Ã© o objetivo desse tipo.
//! 
//! Composto por Date e Time. Usado em Entry.
//! 
//! Pode ser fornecido como parÃ¢metro ou gerado automaticamente com o momento do sistema.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub mod date;
pub mod time;

use date::Date;
use time::Time;

use self::date::month::Month;

use crate::utils::log;

/// Representa o momento de recebimento da temperatura.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Schedule{
    date: Date,
    time: Time,
}

impl Schedule{
    
    fn remainder_from_value(mut value: u64, max: u64) -> (u64, u64) {
        let remainder: u64 = value % max;
        value = (value - remainder) / max;

        (value, remainder)
    }

    fn time_from_nanoseconds(nano: u64) -> (u8, u8, f32) {
        // recolhe toda a porÃ§Ã£o menor do que um dia.
        let (_, remainder) = Self::remainder_from_value(nano, 24 * 60 * 60 * 1_000_000_000);
        let (hours, remainder) = Self::remainder_from_value(remainder, 60 * 60 * 1_000_000_000);
        let (minutes, seconds) = Self::remainder_from_value(remainder, 60 * 1_000_000_000);

        (hours as u8, minutes as u8, seconds as f32 / 1_000_000_000.)
    }

    fn date_from_nanoseconds(nano: u64) -> (i32, String, u8) {
        // Somamos 2 anos ao valor de nanosegundos. Dessa forma estarÃ¡ sincronizado com os leap years, em 1968, em vez de 1970.
        let nano: u64 = nano + 2 * 365 * 24 * 60 * 60 * 1_000_000_000;

        let max: u64 = (365.25 as f64 * 24. * 60. * 60. * 1_000_000_000.) as u64;
        let (year, remainder) = Self::remainder_from_value(nano, max);

        let is_leap_year = year % 4 == 0;

        let max = 24 * 60 * 60 * 1_000_000_000;

        // full_days Ã© uma quantidade de dias entre 366 e 0.
        // O valor remainder (Horas, minutos, segundos) Ã© descartado.
        let (full_days, _) = Self::remainder_from_value(remainder, max);
        let (month, day) = Month::new_from_days(full_days, is_leap_year);
        
        // No inicio do calculo de data por nanosegundos. Somamos 2 anos ao valor recebido, para garantir que estÃ¡ em sincronia com os leap years.
        (year as i32 + 1968, month, day)
    }

    /// Construtor de schedule (data e horario).
    /// 
    /// date: tupla com estrutura (year, month, day).
    /// time: tupla com estrutura (hour, minute, second).
    /// 
    pub fn new(date: Option<(i32, String, u8)>, time: Option<(u8, u8, f32)>) -> Self {
        
        // Retorna o momento exato da chamada dessa instruÃ§Ã£o.
        // Valor em nanosegundos. Quantos nanosegundos desde: 1, jan, 1970.
        let block_time: u64 = env::block_timestamp();
        let (year, month, day) = match date{
            Some(value) => value,
            None => {
                log("Date wasn't specified, using current date.");
                Self::date_from_nanoseconds(block_time)
            },
        };
        
        let (hour, minute, second) = match time{
            Some(value) => value,
            None => {
                log("Time wasn't specified, using current time");
                Self::time_from_nanoseconds(block_time)
            }
        };

        log(&format!("Epoch time is {}.", block_time));
        log(&format!("Day: {}, Month: {}, Year: {}", day, &month, year));
        log(&format!("Hour: {}, Minute: {}, Second: {}", hour, minute, second));

        let date: Date = Date::new(day, &month, year);
        let time: Time = Time::new(hour, minute, second);

        Schedule { 
            date,
            time,
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time.rs ---
//! MÃ³dulo que representa tempo.
//! 
//! Usado por Schedule.
//! 
//! Composto por por Hour, Minute, Second.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod hour;
pub mod minute;
pub mod second;

use hour::Hour;
use minute::Minute;
use second::Second;

/// Representa tempo (hora, minuto, segundo).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Time{
    hour: Hour,
    minute: Minute,
    second: Second,
}

impl Time {
    /// Constroi uma instÃ¢ncia de Time.
    /// 
    /// # Panics
    ///  - se hora >= 24;
    ///  - se minute >= 60;
    ///  - se second >= 60. ;
    ///  - se second < 0. ;
    /// 
    pub fn new(hour: u8, minute: u8, second: f32) -> Time{
        let hour: Hour = Hour::new(hour);
        let minute: Minute = Minute::new(minute);
        let second: Second = Second::new(second);

        Time{
            hour,
            minute,
            second
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/hour.rs ---
//! MÃ³dulo para hora.
//! 
//! O formato json desse tipo Ã© apenas um u8.
//! 
//!  - u8::from(&hour) converte essa referÃªncia para um u8;
//!  - u8::from(hour) converte este Hour para um u8;
//!  - Hour::from(esteu8) converte um valor u8 para  Hour;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tipo que representa hora.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Hour(u8);

impl Hour{
    pub fn new(hour: u8) -> Hour {
        assert!(hour < 24, "Invalid value for hour. Must be lower than 24. Current: {}.", hour);

        Hour(hour)
    }
}

/// Nos permite usar u8::from(&nossoHour)
impl From<&Hour> for u8{
    fn from(hour: &Hour) -> u8 {
        let &Hour(result) = hour;

        result
    }
}

/// Nos permite usar u8::from(nossoHour)
impl From<Hour> for u8{
    fn from(hour: Hour) -> u8 {
        u8::from(&hour)
    }
}

/// Nos permite usar Hour::from(nossou8)
impl From<u8> for Hour{
    fn from(hour: u8) -> Hour {
        Hour::new(hour)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/minute.rs ---
//! MÃ³dulo para minuto.
//! 
//! O formato json desse tipo Ã© apenas um u8.
//! 
//!  - u8::from(&minute) converte essa referÃªncia para um u8;
//!  - u8::from(minute) converte este Minute para um u8;
//!  - Minute::from(esteu8) converte um valor u8 para Minute;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um valor de minuto.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Minute(u8);

impl Minute {
    /// ConstrÃ³i uma instÃ¢ncia de minuto.
    /// 
    /// # Panics
    /// 
    /// Se valor Ã© menor do que 60.
    /// 
    pub fn new(minute: u8) -> Minute{
        assert!(minute < 60, "Invalid value for minute. Must be lower than 60. Current: {}.", minute);

        Minute(minute)
    }
}

/// Nos permite usar u8::from(&nossoMinute)
impl From<&Minute> for u8{
    fn from(minute: &Minute) -> u8 {
        let &Minute(result) = minute;

        result
    }
}

/// Nos permite usar u8::from(nossoMinute)
impl From<Minute> for u8{
    fn from(minute: Minute) -> u8 {
        u8::from(&minute)
    }
}

/// Nos permite usar Minute::from(nossou8)
impl From<u8> for Minute{
    fn from(minute: u8) -> Minute {
        Minute::new(minute)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/second.rs ---
//! MÃ³dulo para segundo.
//! 
//! O formato json desse tipo Ã© apenas um f32.
//! 
//!  - f32::from(&second) converte essa referÃªncia para um f32;
//!  - f32::from(second) converte este Minute para um f32;
//!  - Minute::from(estef32) converte um valor f32 para Second;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um valor de segundo.
/// 
/// Serializado, este tipo Ã© apenas um f32.
/// 
/// # Panics
/// 
///  - Se valor for maior ou igual a 60;
///  - Se o valor for negativo;
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Second(f32);

impl Second {
    pub fn new(second: f32) -> Second{
        assert!(second < 60., "Invalid value for second. Must be lower than 60. Current: {}.", second);
        assert!(second >= 0., "Invalid value for second. Can't be negative. Current: {}.", second);

        Second(second)
    }
}

/// Nos permite usar f32::from(&nossoSecond)
impl From<&Second> for f32{
    fn from(second: &Second) -> f32 {
        let &Second(result) = second;

        result
    }
}

/// Nos permite usar f32::from(nossoSecond)
impl From<Second> for f32{
    fn from(second: Second) -> f32 {
        f32::from(&second)
    }
}

/// Nos permite usar Second::from(nossof32)
impl From<f32> for Second{
    fn from(second: f32) -> Second {
        Second::new(second)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/temperature/mod.rs ---
//! MÃ³dulo que representa temperatura.
//! 
//! Composto por um valor (value) e um formato de temperatura (temp_format).
//! 
//! O contrato armazena um formato de temperatura do sistema.
//! 
//! Se a mensagem nÃ£o informar formato de temperatura, utiliza o do sistema.
//! 
//! Se o formato de temperatura for diferente do formato da mensagem, converte a temperatura da mensagem antes de armazenar/retornar.
//! 

pub mod temp_format;

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use temp_format::TempFormat;
use crate::utils::log;

/// Representa temperatura.
/// 
/// Possui um valor f32 para valor.
/// 
/// Possui um TempFormat para formato (Kelvin, Celsius ou Fahrenheit).
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Temperature {
    value: f32,
    temp_format: TempFormat,
}

impl Temperature {
    /// ConstrÃ³i uma instÃ¢ncia de temperatura. 
    /// 
    /// # Panics
    /// Se o valor for menor do que zero absoluto.
    /// 
    fn new_assert_temp(value: f32, temp_format: TempFormat) -> Self {
        let (minimum, name) = match &temp_format {
            TempFormat::Celsius(t_format) => {(-273.15, t_format)},
            TempFormat::Fahrenheit(t_format) => {(-459.67, t_format)},
            TempFormat::Kelvin(t_format) => {(0., t_format)},
        };
        assert!(value >= minimum, "For temperature type {}, temperature value can not be lower than {}. Current: {}.", name, minimum, value);
        
        Temperature { 
            value, 
            temp_format,
        }
    }

    /// Cria uma instÃ¢ncia de temperatura. O formato serÃ¡ definido pelo formato de sistema "temp_format".
    /// 
    /// "arg_temp" Ã© o formato de temperatura da mensagem recebida.
    /// 
    /// Se arg_temp for diferente de temp_format. SeguirÃ¡ estes passos:
    ///  - Cria uma instÃ¢ncia de temperatura no formato de arg_temp;
    ///  - Converte seu formato para temp_format;
    ///  - Retorna a temperatura;
    /// 
    pub fn new(value: f32, temp_format: &TempFormat, arg_temp: Option<String>) -> Self {
        match arg_temp {
            None => {
                let temp_format = temp_format.clone();

                Temperature::new_assert_temp(value, temp_format)
            },
            Some(arg_string) => {
                let arg_format = TempFormat::new(&arg_string);

                let mut arg_temp = Temperature::new_assert_temp(value, arg_format);

                // Converte a temperatura da mensagem para a temperatura do sistema.
                arg_temp.convert(temp_format);
                arg_temp
            }
        }

    }

    /// Atualiza temperatura se o formato for diferente. 
    /// 
    /// Retorna true se houver mudanÃ§a.
    /// 
    pub fn update_temp_format(&mut self, temp_format: &TempFormat) -> bool {
        let comparison = self.temp_format == *temp_format;

        if !comparison {
            self.convert(temp_format);
        }

        !comparison
    }
    
    /// Converte o formato de temperatura para o argumento.
    pub fn convert(&mut self, temp_format: &TempFormat){
        let current: TempFormat = self.temp_format.clone();

        let value = self.value;
        log(&format!("Converting temperature to system format. System: {}, Current: {}.", temp_format, &current));

        match (current, temp_format) {
            (TempFormat::Kelvin(_), &TempFormat::Celsius(_)) => {
                // C = K âˆ’ 273.15
                self.value = value - 273.15;    
                self.temp_format = TempFormat::new("c");
            },
            (TempFormat::Kelvin(_), &TempFormat::Fahrenheit(_)) => {
                // F = (K â€“ 273.15) Ã— 9â„5 + 32
                self.value = (value - 273.15) * 9.0 / 5.0 + 32.0;
                self.temp_format = TempFormat::new("f");
            },
            (TempFormat::Celsius(_), &TempFormat::Kelvin(_)) => {
                // K = C + 273.15
                self.value = value + 273.15;
                self.temp_format = TempFormat::new("k");
            },
            (TempFormat::Celsius(_), &TempFormat::Fahrenheit(_)) => {
                // F = C(9â„5) + 32
                self.value = value * (9.0 / 5.0) + 32.0;
                self.temp_format = TempFormat::new("f");
            },
            (TempFormat::Fahrenheit(_), &TempFormat::Kelvin(_)) => {
                // K = (F âˆ’ 32) Ã— 5â„9 + 273.15
                self.value = (value - 32.0) * 5.0 / 9.0 + 273.15;
                self.temp_format = TempFormat::new("k");
            },
            (TempFormat::Fahrenheit(_), &TempFormat::Celsius(_)) => {
                // C = (F âˆ’ 32) Ã— 5â„9
                self.value = (value - 32.0) * 5.0 / 9.0;
                self.temp_format = TempFormat::new("c");
            },
            (_, _) => {
                // Todas alternativas diferentes foram consideradas. Isso considera todas as situaÃ§Ãµes em que os tipos sÃ£o iguais.
                // Portanto, nÃ£o fazemos nada.
                return;
            }
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/temperature/temp_format.rs ---
//! MÃ³dulo que representa formato de temperatura.
//! 
//! Pode ser Kelvin, Celsius ou Fahrenheit.
//! 
//! O contrato Ã© inicializado com formato Kelvin.
//! 
//! A instruÃ§Ã£o #[serde(untagged)] faz com que o enum seja serializado como String em json.
//! 
//!  - Default Ã© implementado. Valor inicial Ã© Celsius::Kelvin;
//!  - PartialEq e Eq implementados. Permitindo comparaÃ§Ãµes entre TempFormats a == b;
//!  - String::from(&formato) converte uma referÃªncia &TempFormat para String;
//!  - String::from(formato) converte um TempFormat para String;
//!  - TempFormat::from("a str") para converter um &str para TempFormat;
//!  - TempFormat::from(aString) para converter um String para TempFormat;
//!  - TempFormat::from(&aString) para converter uma referÃªncia &String para TempFormat;
//!  - std::fmt::Display implementado. Permitindo o uso desses tipos em macros como println!, format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa formato de temperatura (Kelvin, Celsius ou Fahrenheit).
/// 
/// Usado para controle de formato. Podemos ter diversos sensores com diferentes formatos.
/// 
/// Isso garante que todas as possibilidades sÃ£o aceitas.
/// 
/// Este enum Ã© visto como uma String no formato json.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum TempFormat{
    Celsius(String),
    Fahrenheit(String),
    Kelvin(String),
}

impl TempFormat{
    /// Constroi uma instÃ¢ncia de TempFormat. 
    /// 
    /// NÃ£o Ã© case-sensitive. Os valores de String (esquerda) resultam em (direita):
    /// 
    ///  - "celsius", "c" => TempFormat::Celsius("Celsius")
    ///  - "fahrenheit", "f" => TempFormat::Fahrenheit("Fahrenheit")
    ///  - "kelvin", "k" => TempFormat::Kelvin("Kelvin")
    /// 
    /// # Panics
    /// 
    /// Se argumento for invÃ¡lido.
    /// 
    pub fn new(temp_format: &str) -> Self{
        // Essa conversÃ£o de &str para TempFormat Ã© possivel devido a implementaÃ§Ã£o "impl From<&str> for TempFormat{..." abaixo.
        // TempFormat::from(temp_format)

        let lower_case: String = temp_format.to_ascii_lowercase();
        
        let new_format: TempFormat = match &lower_case[..] {
            "celsius" | "c" => TempFormat::Celsius(String::from("Celsius")),
            "fahrenheit" | "f" => TempFormat::Fahrenheit(String::from("Fahrenheit")),
            "kelvin" | "k" => TempFormat::Kelvin(String::from("Kelvin")),
            invalid => panic!("Invalid String for temperature type ({}). Valid args: ['Celsius', 'c', 'Fahrenheit', 'f', 'Kelvin', 'k']", invalid),
        };

        new_format
    }
}

/// O formato padrÃ£o de contrato Ã© inicializado como Kelvin. 
/// 
/// Pode ser alterado depois da inicializaÃ§Ã£o de contrato.
/// 
impl Default for TempFormat{
    fn default() -> Self {
        TempFormat::new("k")
    }
}

// Permite comparaÃ§Ã£o parcial entre os tipos TempFormat.
//
// A = B nÃ£o Garante B = A
//
// A = B e A = C nÃ£o garante B = C
//
impl PartialEq for TempFormat {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (TempFormat::Celsius(_), TempFormat::Celsius(_)) => true,
            (TempFormat::Fahrenheit(_), TempFormat::Fahrenheit(_)) => true,
            (TempFormat::Kelvin(_), TempFormat::Kelvin(_)) => true,
            (_, _) => false,
        }
    }
}

// ApÃ³s implementaÃ§Ã£o acima, esta trait permite comparaÃ§Ã£o total entre os tipos TempFormat.
//
// A = B garante B = A
//
// A = B e A = C garante B = C
//
impl Eq for TempFormat {}

/// Nos permite utilizar String::from(&esteTipo) para converter o tipo para String.
impl From<&TempFormat> for String{
    fn from(temp_format: &TempFormat) -> String {
        match &temp_format{
            &TempFormat::Celsius(value) => (*value).clone(),
            &TempFormat::Kelvin(value) => (*value).clone(),
            &TempFormat::Fahrenheit(value) => (*value).clone(),
        }
    }
}

/// Nos permite utilizar String::from(esteTipo) para converter o tipo para String.
impl From<TempFormat> for String {
    fn from(temp_format: TempFormat) -> String {
        String::from(&temp_format)
    }
}

/// Nos permite utilizar TempFormat::from("estestr") para converter um &str para TempFormat.
impl From<&str> for TempFormat{
    fn from(temp_format: &str) -> TempFormat {
        TempFormat::new(temp_format)
    }
}

/// Nos permite utilizar Tempformat::from(&esteString) para converter uma referÃªncia &String para TempFormat.
impl From<&String> for TempFormat{
    fn from(temp_format: &String) -> TempFormat {
        TempFormat::from(&temp_format[..])
    }
}

/// Nos permite utilizar TempFormat::from(esteString) para converter um String para TempFormat.
impl From<String> for TempFormat{
    fn from(temp_format: String) -> TempFormat{
        TempFormat::from(&temp_format[..])
    }
}

/// Usado para converter o enum para String. Se usarmos macros como format!, println! ou panic!, esta trait Ã© usada.
impl std::fmt::Display for TempFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let temp_format = String::from(self);

        write!(f, "{}", temp_format)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/utils.rs ---
//! MÃ³dulo com ferramentas de suporte.
//! 
//!  - log: Imprime a mesma mensagem em ambientes de teste e em produÃ§Ã£o.
//!  - ViewGet: Um tipo de saida para a funÃ§Ã£o de contrato view_get. Permite retorno de dois tipos diferentes na mesma funÃ§Ã£o.
//! 

use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[allow(unused_imports)]
use near_sdk::env;

/// Imprime com env::log em produÃ§Ã£o. Imprime com println em testes.
#[cfg(test)]
pub fn log(msg: &str){
    println!("{}", msg);
}

/// Imprime com env::log em produÃ§Ã£o. Imprime com println em testes.
#[cfg(not(test))]
pub fn log(msg: &str) {
    env::log(msg.as_bytes());
}

/// Usado para saida da funÃ§Ã£o de contrato view_get.
/// 
///  - Se argumento possuir um index. Retorna um Entry.
///  - Se index for omitido. Retorna um Vec com todas as Entries para aquele usuÃ¡rio.
/// 
/// NÃ£o Ã© eficiente quando o contrato possuir muitas entries para cada usuÃ¡rio. 
/// 
/// Mas esperasse que o usuÃ¡rio colete localmente e remova valores antigos para evitar custos desnecessÃ¡rios de computaÃ§Ã£o e armazenamento.
/// 
/// A instruÃ§Ã£o #[serde(untagged)] faz com que o enum nÃ£o apareÃ§a no json de saida.
/// 
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/Cargo.toml ---
[package]
name = "lesson_6_3_game_score"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/Readme.md ---
# Lesson 6 - 3 Game Score

[(Back)](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/)

In this example, we will see how to easily escape errors using 
the macro ```#[handle_result]```, and a way to update data 
about several users at each update (highscores in this case).

This lesson is a simple simulation of a possible browser 
"rogue-like" game. "Rogue-likes" are games where your 
character goes through a series of randomly generated 
arenas, with randomly generated rewards. A few examples 
of popular games like this are "The Binding of Isaac", by 
Edmund McMillen and Florian Himsl and "Hades", by Supergiant 
Games.

This contract can't be used (yet) for running a real game. 
But it has much of the structure that could be used for a 
game as such. We will discuss the structure of this contract, 
and I would love to have a feedback from readers about their 
thoughts about this example.

Each player store each of their characters. Have information 
on each of their highscores, and there is a global (limited) 
highscore that can be updated whenever a new one is achieved. 
How to best save gas doing these operations is still an open 
question, but I left my suggestions on this example.

If you're interested only in the error Management part of this 
example. Please check it in the index below.

## Building

This crate belongs to the workspace at lesson_6_enums. Cargo commands will affect all the crates of the workspace. To specify only this crate, include the option ```-p lesson_6_3_game_score```.

Build with:

```cargo build -p lesson_6_3_game_score --target wasm32-unknown-unknown --release```

Test with:

```cargo test -p lesson_6_3_game_score --nocapture```

```--nocapture``` will show output of each test.

## Index

[(back to top)](#lesson-6---3-game-score)

 - [Contract Api](#contract-api)
 - [How the Contract is Intended to be Used](#how-the-contract-is-intended-to-be-used)
 - [Error Management](#error-management)
 - [What Each Module Does](#what-each-module-does)
   - [Chapter](#chapter)
     - [Chapter Reward](#chapter-reward)
   - [Character](#character)
     - [Class](#class)
     - [Stats](#stats)
   - [Player](#player)
     - [View](#view)
   - [Score](#score)
     - [HighScore](#highscore)
     - [Ranking](#ranking)
 - [Next Section](#next-section) 

## Contract API

[(back to top)](#lesson-6---3-game-score)

```rust
// /src/lib.rs

/// Update the player state.
/// 
/// This is going to be replaced by direct pointer access later.
/// 
fn save_player(&mut self, player: &Player) -> Result<(), Errors>;

/// If user does not exist in the database. Ask for registry.
fn load_player(&self) -> Result<Player, Errors>;

/// A user that is not registered can't access the smart contract.
/// 
/// Add the predecessor to the smart contract.
#[handle_result]
pub fn register_user(&mut self) -> Result<(), Errors>

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors>;

/// Loads and returns an instance of player.
#[handle_result]
pub fn check_status(&self) -> Result<player_view, Errors>;

/// Load a character with the given name and return it.
#[handle_result]
pub fn load_character(&self, name: String) -> Result<Character, Errors>;

/// Get current ranking.
pub fn get_ranking(&self) -> Ranking;

/// Get information about the next match.
#[handle_result]
pub fn start_match(&mut self) -> Result<Chapter, Errors>;

/// Report the match finished.
/// 
/// Some validations should be done about it.
/// 
/// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
/// 
/// A report should be a replay of the entire match. Including the AI of non-player-characters.
/// 
#[handle_result]
pub fn report_match(
    &mut self, 
    character: CharacterName, 
    score: Score, 
    // validation_report: ValidationReport,
) -> Result<bool, Errors>;

/// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
#[handle_result]
pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>;
```

## How the contract is intended to be used

[(back to top)](#lesson-6---3-game-score)

We're considering that the game is running on a users' 
browser. We can't update the game real time like most online 
games because of latency and costs. But, when it comes to 
rogue-like games, each arena is small, and is intended to be 
finished in a short time. Something like 1 minute or 2 for each 
arena. We could require, as in-game mechanics, for the arenas 
to run for a limited time. As the player completes each of 
these small chapters, the browsers sends a report, a small 
replay, to the smart contract. The smart contract validates this 
report, and only then, updates the player's state.

Since the game isn't developed yet. This implementation will 
not receive a report and will always consider the validation 
successful. Maybe in next chapter we can try implementing a 
simple game to check how expensive it can be. You're free to 
use this code in your own games. If it makes you rich, send me 
a couple of NEAR please xD.

When it comes to the ranking of players. I decided to store it 
as a small Vector. This is because computing the ranking will 
become exponentially more expensive the higher the number of 
players. So we limit it to something like 100 or 1000 players. 
And sort the Vector whenever a new entry is achieved.

The first step a browser has to take is call ```register_user``` 
so the user is included in the state. 

 - Calling ```check_status``` will return information about 
the current player.
 - Calling ```get_ranking``` will return the current ranking 
between players.
 - Calling ```create_character``` will create a new character 
associated with that player.
 - Calling ```load_character``` will return a character owned 
by that player, with the given name.
 - Calling ```start_match``` will return information about the 
current chapter, then reset a timer.
 - Calling ```report_match``` with your chapter report will 
validate your replay, if successful, give rewards to your 
character, update highscores and move to the next chapter.
 - The owner of the smart contract accound can call 
```set_max_highscore_players``` to change the max number of 
players that can exist in ranking.

## Error Management

[(back to top)](#lesson-6---3-game-score)

In ```/src/model/errors.rs``` we have this enum.

```rust
// /src/model/errors.rs

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
```

Each possible value for this enum represents an error that 
might happen in our project. The trait ```std::fmt::Display``` 
is used for turning a type into a String when we use macros 
like ```println!``` and ```format!```. We also derive a new 
trait called ```FunctionError```.

Thanks to this type. We don't need to manually can 
```env::panic_str``` or assert statements whenever something 
in the code might break. We just return the error and the 
deserializer will raise the error for us. Here is how it is 
used.

```rust
// /src/lib.rs

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
/// 
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
    log!("Create Character function called.");
    
    let class: Class = Class::new(&class)?;
    let character: Character = Character::new(name, class)?;
    let mut player: Player = self.load_player()?;

    player.assign_character(character)?;

    self.save_player(&player)?;

    log!("Character successfully created.");

    Ok(())
}
```

In this example for creating character, notice these 3 things:
 - The function returns ```Result<(), Errors>```;
 - ```#[handle_result]``` macro on top of the contract function;
 - ```?``` operators;

The ```?``` operator is useful for both Option and Result enums.
 - If we use it in an ```Option```, unwrap the value or panic if 
it's ```None```.
 - If we use it in a ```Result```, unwrap the value or return the 
error type as ```Err```.

Notice that the return type of each of the functions with ```?``` 
operator is a ```Result``` with the same ```Err``` type as this 
function (which is ```Errors```).

This is a very clean way of handling errors. Don't you agree? We 
know where the errors are coming from. And we are not cluttering 
our code with error checking.

Having one enum to represent all the errors in the entire smart 
contract could easily get bloated in large projects. But that's 
easy to fix. Just have errors within errors. An enum that contains 
another enum. Create a method that wraps the smaller error into the 
larger error that encompasses all the others.

## What each module does

[(back to top)](#lesson-6---3-game-score)

To help users get to know what is happening in each module. I 
will offer a brief explanation of each of those ahead.

Some of these modules are very simple and can be easily 
expanded. The intention of this lesson is to offer an example 
of a game architecture. Not the game itself. To offer inspiration 
on this uncharted web3 territory. The less specific the game 
mechanics are, the easier it is to incorporate to multiple 
different games.

### Chapter

[(back to top)](#lesson-6---3-game-score)

This module represents a single chapter of the game. Each chapter 
should be a small arena that the player should stay for a 
limited time (e.g. 2 minutes). Rogue-like games include randomly 
generated elements in each chapter. Like random enemies, random 
bonuses for the player, random rewards...

The type Chapter can be seen below: 

```rust
// /src/model/chapter/mod.rs

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}
```

Each possible for Chapter represents a unique "arena". The value 
within the tuple is used to count match length. 

When a player calls the function "start_match", the tuple stores 
when the match started. When the player calls "report_match", 
the chapter will use the 
```(time_when_finished - time_when_started)``` to make sure that 
the game wasn't run by a machine. Here is an example:

Imagine the player calls ```start_match``` then, 2 seconds later, 
call ```validate_match``` with a report that technically lasted 
2 minutes.

The smart contract can't allow that. So, if the time in the 
report is greater than the time it took since the match started, 
the contract will panic. That's the only reason for storing the 
time in chapter.

If the validation is successful. Returns the reward for the 
character.

#### Chapter Reward

[(back to top)](#lesson-6---3-game-score)

Chapter Reward is a calculator for how much "exp (experience)" 
was earned from a chapter. Each game is different, so you will 
probably change rewards to something more interesting than this.

```rust
// /src/model/chapter/reward.rs

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}
```

 - ```exp```: How much base EXP is earned from this match. Regardless
 of player performance, they will always receive at least this amount.
 - ```expected_level```: What level the player is expected to be 
before starting this chapter. Lower levels means harder matches, so
higher rewards.
 - ```level_multiplier```: For each level of difference, this will be 
multiplied an extra time. Up to 5 times. Check the values in the 
tests to see some examples.
 - ```score_multiplier```: The higher the score, more exp. This is a 
 multiplier that will apply to the achieved score.

Check the implementation of ```Chapter::compute_reward``` for more 
information on how the bonuses are implemented.

### Character

[(back to top)](#lesson-6---3-game-score)

Contains basic information about a game character. Each player has 
their own list of characters.

```rust
// /src/model/character/mods.rs

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}
```

 - ```name```: character's name. Will be show on high scores.
 - ```class```: class is a model for how a character is built and 
what it can do later. We don't go deep into this topic here. It's 
just an example.
 - ```level```: character's progression is marked by it's level. Exp 
raises this value automatically.
 - ```xp```: how much exp this character has. Each new level resets 
this value.
 - ```stats```: character actions are determined by their stats. Class
has information on how stats increase based on level.
 - ```high_score```: the highest score achieved by the player in any 
chapter. If a new highscore is achieved, it will be sent for a 
comparison with the ranking of players.

#### Class

[(back to top)](#lesson-6---3-game-score)

A few examples of classes just to show how each could affect stats in 
a unique way.

```rust
// /src/model/character/class.rs

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}
```

We implement a constructor:

```rust
impl Class{
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }
}
```

Notice how this returns a Result where the error is of type 
```Errors```. This is because we use the ```?``` operator in the 
contract methods. There's no need to manually raise errors in the 
implementation. Just return a ```Result::Err``` instead.

Some type conversions below:

```rust
// /src/model/character/class.rs

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}
```

These are trait implementations for converting one type to another.

```From<&String> for Class``` will allow us to pick a string, then 
attempt to convert it into a class through the function ```from```. 
Here is an example:

```rust
let a = "Druid";
let b: Class = Class::from(a);
```

The example above we create an ```&str``` with value "Druid" then 
create a class using that string as reference. We implement for 
owned Strings. Then references of String. Then we implement 
conversion from a reference Class to a String (the reverse way).

#### Stats

[(back to top)](#lesson-6---3-game-score)

Stats represent what your character can do in the arena. The success 
rate of each of their actions. To be used in chapter validation.

Because of the classes shown above. We want to show that each 
affect the stats in a unique way. So we chose these 3 basic 
stats: dexterity, strength and inteligence.

```rust
// /model/character/stats.rs

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}
```

Base is the minimum value for that stat. Rate is how much that stat 
grows with each level. By calling the method ```Stats::update``` we 
update the value of each stat whenever the character levels up.

### Player

[(back to top)](#lesson-6---3-game-score)

Each user represents one instance of ```Player```.

```rust
// /src/model/player/mod.rs

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}
```

 - ```name```: name of the player;
 - ```high_score```: high score achieved by the player. It is None 
 - if no chapter has been played yet;
 - ```characters```: all characters owned by this player;
 - ```character_names```: list of character names owned by the player;
 - ```latest_chapter```: the next chapter the player is about to play;

The ```LookupMap``` is O(1) for getting and inserting values. The ```UnorderedSet``` is used for iterating through the names. Both are updated simultaneously.

#### View

[(back to top)](#lesson-6---3-game-score)

The collections for ```characters``` and ```character_names``` 
can't be serialized to readable json. So we create this type 
just to use as a return type.

```rust
// /src/model/

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}
```

We only get player name, highscore and a list of characters for 
the view. Which is all the player will need.

Vec is a collection that can be serialized with serde. It is 
updated every time the list of characters change. It gets 
exponentially more expensive the higher the number of characters. 
So limiting the number of characters is recommended.

### Score

There are two types in this module: HighScore and Ranking.

#### HighScore

[(back to top)](#lesson-6---3-game-score)

Represents a character or player's highscore.

```rust
// /src/model/score/high_score.rs

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}
```

The most important topic to discuss for this type is the following method:

```rust
// /src/model/score/high_score.rs

/// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
pub fn update_highscore(
    current_highscore: &mut Option<HighScore>,
    new_high_score: Option<HighScore>,
) -> Result<Option<HighScore>, Errors> {

    // This match will stop assigning the new highscore if one has not been achieved.
    match (&current_highscore, &new_high_score) {
        (_, None) => { 
            // No highscore was achieved by the character.
            return Ok(None); 
        },
        (None, Some(_)) => {},
        (Some(old_high_score), Some(new_high_score)) => {
            // A character achieved a highscore
            // there is a highscore recorded.
            // makes a comparison and maintain the highest.
            if old_high_score > new_high_score {
                return Ok(None);
            }
        },
    }

    // assign the new highscore
    *current_highscore = new_high_score.clone();

    return Ok(new_high_score);
}
```

So, this happens for player and character. Both store an 
```Option<HighScore>```. So, instead of making functions that 
receive ```HighScore``` as arguments. We have one that receives 
```Option<HighScore>``` instead.

When a report is validated. A highscore for the character may be 
achieved. 

If this happens, we make a comparison with all the player highscores 
to see if a highscore for the player was achieved.

If this happens as well, we check if the player highscore is among 
the ranking of top highscores.

Notice how ranking is only calculated when player achieve their 
highest score. That saves a lot of computing.

So, ```HighScore::update_highscore``` receives the current highscore 
and the latest possible highscore. If latest is higher than the 
current, updates the current, then return a copy of the same.

There is the possibility of any of the values being ```None```. 
Maybe no highscore was achieved. Maybe there were no highscores 
before this one. The function considers both cases.

#### Ranking

[(back to top)](#lesson-6---3-game-score)

Ranking is stored a vector of ```HighScore```. The maximum 
number of elements stored is limited to reduce sorting costs.

```rust
// /src/model/score/ranking.rs

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}
```

When a player achieves a new ```HighScore```, the following 
method is run:

```rust
// /src/model/score/ranking.rs

pub fn check_highscore(
    &mut self, 
    high_score: &Option<HighScore>,
) -> bool {
    match high_score {
        None => { 
            // Player didn't achieve a high score.
            false
        },
        Some(high_score) => {
            log!("New High Score for this Player.");

            // Compiler will apply branchless optimization to all these if/else statements.
            if self.lowest_high_score.is_none() {
                // This is the first entry, so just include it.
                self.new_entry(high_score.clone());

                return true;
            } else {
                // This is not the first entry.
                // The list may be full or not.
                let ranking_is_full: bool = self.values.len() == self.max_size;

                if !ranking_is_full {
                    // If the list is not full, just include it.
                    self.new_entry(high_score.to_owned());

                    return true;
                } else {
                    // .unwrap will never panic because of the first "if" above. It is always Some.
                    // We are cloning because unwrap will take ownership of this mutable reference.
                    let lowest_high_score = self.lowest_high_score
                        .clone()
                        .unwrap();

                    if lowest_high_score < *high_score {
                        self.new_entry(high_score.clone());

                        return true;
                    }
                    
                    false
                }
            }
        }
    }
}
```

In summary, what this method does is:
 - If a new HighScore is not achieved, do nothing.
 - If the list is empty, just include the entry.
 - If the list is not full, just include the entry.
 - If the list is full, before including the entry, 
only include if the value is higher than the lowest 
entry in the list.

Each inclusion in the list will result in the 
list being sorted. Comparison with the lowest entry 
helps reduce computing costs.

## Next Section

[(back to top)](#lesson-6---3-game-score)

The next lesson will be about traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/lib.rs ---
use near_sdk::{
    AccountId,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        LookupMap, 
    },
    env,
    log,
    near_bindgen,
};

mod model;

use crate::{
    model::{
        character::{
            Character,
            Class,
            Name as CharacterName,
        },
        Errors,
        Chapter,
        player_view,
        Player,
        score::{
            HighScore,
            Score,
            Ranking,
        },
        StorageKey,
    }
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    players: LookupMap<AccountId, Player>,

    ranking: Ranking,
}

// Na inicializaÃ§Ã£o de contrato,
// inclui dono na lista de usuÃ¡rios permitidos.
impl Default for Contract {
    fn default() -> Self {
        let players: LookupMap<AccountId, Player> = LookupMap::new(StorageKey::Players);
        let ranking: Ranking = Ranking::default();

        Contract{
            players,
            ranking,
        }
    }
}

#[near_bindgen]
impl Contract{

    fn is_owner() -> bool {
        let predecessor_account_id: AccountId =  env::predecessor_account_id();
        let current_account_id: AccountId = env::current_account_id();

        predecessor_account_id == current_account_id
    }

    /// Guarantees that the user is not registered.
    fn assert_user_not_registered(&self) -> Result<(), Errors> {
        let predecessor_account_id = env::predecessor_account_id();

        if self.players.contains_key(&predecessor_account_id) ||  Self::is_owner() {
            // Panic because account already exists.
            return Err(Errors::AccountIsAlreadyRegistered(predecessor_account_id));
        }

        Ok(())
    }

    fn assert_user_registered(&self) -> Result<(), Errors> {
        if Self::is_owner(){
            return Ok(());
        }

        let predecessor_account_id = env::predecessor_account_id();

        if ! self.players.contains_key(&predecessor_account_id) {
            // Panic because account already exists.
            return Err(Errors::AccountIsNotRegistered(predecessor_account_id));
        }

        Ok(())
    }

    /// Update the player state.
    /// 
    /// This is going to be replaced by direct pointer access later.
    /// 
    fn save_player(&mut self, player: &Player) -> Result<(), Errors>{
        self.assert_user_registered()?;

        let predecessor_account_id: AccountId = env::predecessor_account_id();

        self.players.insert(&predecessor_account_id, player).unwrap();

        Ok(())
    }

    /// If user does not exist in the database. Ask for registry.
    fn load_player(&self) -> Result<Player, Errors>{
        let predecessor_account_id = env::predecessor_account_id();

        match self.players.get(&predecessor_account_id){
            None => Err(Errors::UserNotRegistered(predecessor_account_id)),
            Some(player) => Ok(player),
        }
    }

    

    /// A user that is not registered can't access the smart contract.
    /// 
    /// Add the predecessor to the smart contract.
    #[handle_result]
    pub fn register_user(&mut self) -> Result<(), Errors> {
        log!("Register User function called.");
        self.assert_user_not_registered()?;

        // While technically we are calling env::predecessor_account_id twice, LLVM compiler will optimize it away.
        // We can write both low level and high level code efficiently in rust. 
        // We just need to decide when a function represents a low level or high level need.
        let predecessor_account_id = env::predecessor_account_id();
        let player = Player::default();
        assert!(self.players.insert(&predecessor_account_id, &player).is_none(), "Smart contract error: Expected None after asserting user is not registered. Got some.");

        log!("User successfully registered.");
        
        Ok(())
    }

    /// User must be registered before using this.
    /// 
    /// Create a character with given name and class.
    /// 
    /// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
    /// 
    #[handle_result]
    pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
        log!("Create Character function called.");
        
        let class: Class = Class::new(&class)?;
        let character: Character = Character::new(name, class)?;
        let mut player: Player = self.load_player()?;

        player.assign_character(character)?;

        self.save_player(&player)?;

        log!("Character successfully created.");

        Ok(())
    }

    /// Loads and returns an instance of player.
    #[handle_result]
    pub fn check_status(&self) -> Result<player_view, Errors>{
        log!("Check Player Status function called.");

        Self::load_player(&self)?
            .get_view()
    }

    /// Load a character with the given name and return it.
    #[handle_result]
    pub fn load_character(&self, name: String) -> Result<Character, Errors> {
        let player = self.load_player()?;

        player.load_character(name)
    }

    /// Get current ranking.
    pub fn get_ranking(&self) -> Ranking {
        self.ranking.clone()
    }

    /// Get information about the next match.
    #[handle_result]
    pub fn start_match(&mut self) -> Result<Chapter, Errors> {
        log!("Start Match function called.");

        let mut player = self
            .load_player()?;

        let chapter = player.start_match();

        self.save_player(&player)?;

        Ok(chapter)
    }

    /// Report the match finished.
    /// 
    /// Some validations should be done about it.
    /// 
    /// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
    /// 
    /// A report should be a replay of the entire match. Including the AI of non-player-characters.
    /// 
    #[handle_result]
    pub fn report_match(
        &mut self, 
        character: CharacterName, 
        score: Score, 
        // validation_report: ValidationReport,
    ) -> Result<bool, Errors>{
        log!("Report Match function called.");

        let mut player: Player = self.load_player()?;

        let high_score: Option<HighScore> = player.report_match(character, score)?;

        self.save_player(&player)?;

        // So, if player didn't achieve a highscore of their own, it won't checked in the rankings. 
        // This is to stop a few players from overwhelming the ranking with their name.
        Ok(self.ranking.check_highscore(&high_score))
    }

    /// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
    #[handle_result]
    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors> {
        if env::signer_account_id() != env::current_account_id() {
            return Result::Err(Errors::OwnerOnly);
        }

        self.ranking.set_max_highscore_players(max_size)?;

        Ok(())
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/mod.rs ---
mod reward;

use near_sdk::{
    borsh,
    borsh::{ BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub use reward::ChapterReward;
use crate::model::{
    character::{
        Character,
        EXP,
    },
    score::Score,
    Errors,
};

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}

impl Default for Chapter{
    fn default() -> Self {
        Chapter::Chapter1(None)
    }
}

impl Chapter {
    fn get_time(&self) -> Option<u64> {
        match self{
            Chapter::Chapter1(value) => value.clone(),
            Chapter::Chapter2(value) => value.clone(),
            Chapter::Chapter3(value) => value.clone(),
        }
    }

    /// Used by Self::clear_time and Self::start_time. Change the value of the last time a match was started.
    fn set_time(&mut self, value: Option<u64>) {
        *self = match self{
            Chapter::Chapter1(_) => Self::Chapter1(value),
            Chapter::Chapter2(_) => Self::Chapter2(value),
            Chapter::Chapter3(_) => Self::Chapter3(value),
        };
    }

    /// Used after reporting. Means that no match is going at the moment.
    fn stop_time(&mut self) {
        self.set_time(None);
    }

    /// Used when loading a chapter. Get the latest time for starting the match. Report can't have a longer time than this.
    fn start_time(&mut self) {
        let current_time_ms: u64 = env::block_timestamp_ms();

        self.set_time(Some(current_time_ms));
    }

    /// Returns the multipliers for each chapter reward.
    pub fn check_reward(&self) -> ChapterReward {
        match self {
            Chapter::Chapter1(_) => {
                ChapterReward::new(
                    10, 
                    0.9, 
                    1, 
                    0.9,
                )
            },
            Chapter::Chapter2(_) => {
                ChapterReward::new(
                    100, 
                    0.9, 
                    5, 
                    0.9,
                )
            },
            Chapter::Chapter3(_) => {
                ChapterReward::new(
                    1000, 
                    0.9, 
                    10, 
                    0.9,
                )
            },
        }
    }

    
    /// Doesn't do anything in this tutorial.
    /// 
    /// The idea is that the user will send a report that includes everything that happened during the match.
    /// 
    /// The contract guarantees that the user didn't attempt to cheat at the game.
    /// 
    fn validate_get_reward(
        &self,
        _character: &Character,
        _score: &Score,
        // Validation_report: EncryptedValidationType,
    ) -> Result<ChapterReward, Errors> {

        if self.get_time().is_none(){
            return Err(Errors::ChapterNotStarted);
        }

        // Do something with the validation_report and given character and score.
        // validation_report should be a block of bytes signed with a public key owned by the smart contract.
        // The report should have information about everything that happened in the match.
        // Since the gameplay happens in the browser. It's very easy for the user to cheat and send a fake report.
        // So maybe the report should be an entire replay of the match.
        //
        // One useful check that could be done is making sure that the match between start and report can't

        
        Result::Ok(
            Self::check_reward(&self)
        )
    }

    /// Can only be called after the timer has started (with Self::start_match). Receives a chapter report and validates it before returning rewards.
    pub fn validate_match(
        &mut self, 
        character: &Character, 
        score: &Score,
        // Validation_report: ValidationReport,
    ) -> Result<EXP, Errors> {
        let reward = self.validate_get_reward(character, score)?;

        self.stop_time();
        Ok(reward.compute_reward(character.get_level(), score))
    }

    /// Go to the next chapter and stop the timer.
    pub fn next_match(&mut self) {
        *self = match self {
            Chapter::Chapter1(_) => Chapter::Chapter2(None),
            Chapter::Chapter2(_) => Chapter::Chapter3(None),
            Chapter::Chapter3(_) => Chapter::Chapter1(None),
        };
    }

    /// Start match timer. Needed for validation.
    pub fn start_match(&mut self) -> Self {
        self.start_time();

        self.clone()
    }

}

#[cfg(test)]
mod tests{
    use super::Chapter;

    fn new_chapter_1() -> Chapter{
        Chapter::default()
    }

    fn new_chapter_2() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter
    }

    fn new_chapter_3() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter.next_match();
        chapter
    }

    fn assert_chapter_number(chapter: &Chapter, number: u8) {
        if number < 1 && number > 3 {
            panic!("Invalid argument for test. Chapter can only be 1, 2 or 3.")
        }

        match chapter {
            Chapter::Chapter1(_) => assert!(number == 1),
            Chapter::Chapter2(_) => assert!(number == 2),
            Chapter::Chapter3(_) => assert!(number == 3),
        }
    }

    #[test]
    fn chapter_next_chapter() {
        let (chapter1, chapter2, chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        assert_chapter_number(&chapter1, 1);
        assert_chapter_number(&chapter2, 2);
        assert_chapter_number(&chapter3, 3);
    }

    #[test]
    fn chapter_clear_timer() {
        
        let (mut chapter1, mut chapter2, mut chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        chapter1.start_match();
        chapter2.start_match();
        chapter3.start_match();

        assert!(chapter1.get_time().is_some());
        assert!(chapter2.get_time().is_some());
        assert!(chapter3.get_time().is_some());

        chapter1.stop_time();
        chapter2.stop_time();
        chapter3.stop_time();

        assert!(chapter1.get_time().is_none());
        assert!(chapter2.get_time().is_none());
        assert!(chapter3.get_time().is_none());
    }

}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/reward.rs ---
use crate::model::{
    character::{
        EXP,
        Level,
    },
    score::Score,
};

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}

impl ChapterReward{
    
    /// Returns the proportion of extra EXP based on level difference.
    /// 
    /// Max difference is 5.
    /// 
    /// If level is higher than expected, receive less EXP.
    /// 
    /// If level is lower, receive more EXP.
    /// 
    fn compute_level_multiplier(
        mut multiplier: f32, 
        level: Level, 
        expected_level: Level,
    ) -> f32{
        let mut difference = level as f32 - expected_level as f32;

        let result: f32 = 1.0;

        // As example, if proportion is 0.9, having a lower level will multiply the bonus by 1.1 per level (up to 5)
        // 0.8 would multiply the bonus by 1.2/level (up to 5).
        if difference < 0. {
            multiplier = 2. - multiplier;
            difference *= -1.;
        }

        if difference >= 5. {
            return result * multiplier * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 4. {
            return result * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 3. {
            return result * multiplier * multiplier * multiplier
        }
        if difference >= 2. {
            return result * multiplier * multiplier
        }

        if difference >= 1. {
            return result * multiplier
        }

        result
    }

    pub fn new(
        exp: EXP,
        score_multiplier: f32,
        expected_level: Level,
        level_multiplier: f32,
    ) -> Self {

        ChapterReward { 
            exp, 
            score_multiplier, 
            expected_level, 
            level_multiplier,
        }
    }

    pub fn compute_reward(
        &self, 
        character_level: Level,
        score: &Score,
    ) -> EXP {
        let exp = self.exp;
        let score_bonus = self.score_multiplier * *score as f32;

        let expected_level = self.expected_level;
        let level_multiplier = self.level_multiplier;

        let computed_multiplier = Self::compute_level_multiplier(
            level_multiplier, 
            character_level,
            expected_level,
        );

        ((exp as f32 + score_bonus as f32) * computed_multiplier) as EXP
    }
}

#[cfg(test)]
mod tests{
    use super::ChapterReward;

    fn setup_test() -> ChapterReward {
        let (
            exp,
            score_multiplier,
            expected_level,
            level_multiplier,
        ) = (10, 0.8, 10, 0.9);

        ChapterReward::new(exp, score_multiplier, expected_level, level_multiplier)
    }

    #[test]
    fn chapter_reward_new(){
        
        let chapter_reward: ChapterReward = setup_test();

        assert_eq!(chapter_reward.exp, 10);
        assert_eq!(chapter_reward.score_multiplier, 0.8);
        assert_eq!(chapter_reward.expected_level, 10);
        assert_eq!(chapter_reward.level_multiplier, 0.9);
    }

    #[test]
    fn chapter_reward_compute_reward(){
        let chapter_reward: ChapterReward = setup_test();

        // Lower level means more exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(9, &100), 99);
        assert_eq!(chapter_reward.compute_reward(8, &100), 108);
        assert_eq!(chapter_reward.compute_reward(7, &100), 119);
        assert_eq!(chapter_reward.compute_reward(6, &100), 131);
        assert_eq!(chapter_reward.compute_reward(5, &100), 144);
        assert_eq!(chapter_reward.compute_reward(4, &100), 144);
        assert_eq!(chapter_reward.compute_reward(3, &100), 144);
        assert_eq!(chapter_reward.compute_reward(2, &100), 144);

        // Higher level means less exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(11, &100), 81);
        assert_eq!(chapter_reward.compute_reward(12, &100), 72);
        assert_eq!(chapter_reward.compute_reward(13, &100), 65);
        assert_eq!(chapter_reward.compute_reward(14, &100), 59);
        assert_eq!(chapter_reward.compute_reward(15, &100), 53);
        assert_eq!(chapter_reward.compute_reward(16, &100), 53);
        assert_eq!(chapter_reward.compute_reward(17, &100), 53);
        assert_eq!(chapter_reward.compute_reward(18, &100), 53);
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/class.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use near_sdk::env;

use crate::model::{
    character::Stats,
    Errors,
};

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}

impl Class {
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }

    /// Return base stats for given class, used by Character;
    pub fn get_stats(&self) -> Stats {

        let (
            dexterity_base,
            strength_base,
            inteligence_base,
            strength_rate,
            dexterity_rate,
            inteligence_rate,
        ) = match self{
            Class::Druid => (
                5,
                7,
                7,
                1,
                2,
                2,
            ),
            Class::Priest => (
                4,
                5,
                7,
                1,
                2,
                1,
            ),
            Class::Rogue => (
                8,
                4,
                4,
                2,
                1,
                1,
            ),
            Class::Warrior => (
                4,
                8,
                4,
                1,
                2,
                1,
            ),
        };

        Stats::new(
            dexterity_base,
            dexterity_rate,
            strength_base,
            strength_rate,
            inteligence_base,
            inteligence_rate,
        )
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/mod.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self,},
    env,
    serde::{ Deserialize, Serialize },
};

mod class;
mod stats;

pub(crate) use class::Class;
pub(crate) use stats::Stats;

use crate::model::{
    Errors,
    score::{
        Score,
        // HighScore,
    },
};

use super::score::HighScore;

pub type Name = String;
pub type EXP = u32;
pub type Level = u32;

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}

impl Character {

    fn update_level(&mut self) {
        let level: u32 = self.level;

        // just an exponential function to work as an example of how level scaling could work.
        // It gets exponentially higher each level. Level 1 requirement is 100.
        let next_level: u32 = 100 + level * 10 + 3 * level * level;

        if self.xp >= next_level { 
            self.level += 1;
            self.xp -= next_level;
            self.stats.update(self.level);
        }
    }

    /// Create a new character to be used by the player.
    pub fn new(name: Name, class: Class) -> Result<Character, Errors> {
        let level: Level = 1;
        let xp: EXP = 0;
        let stats: Stats = Stats::from(&class);
        let high_score: Score = 0;

        let first_character = &name[0..1];
        match first_character{
            "" => Err(Errors::InvalidCharacterName(name)),
            _ => Ok(Character {
                name,
                class,
                level,
                xp,
                stats,
                high_score,
            })
        }

        
    }

    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    pub fn get_class(&self) -> Class {
        self.class.clone()
    }

    pub fn get_level(&self) -> Level {
        self.level.clone()
    }

    pub fn get_xp(&self) -> EXP {
        self.xp.clone()
    }

    pub fn get_stats(&self) -> Stats {
        self.stats.clone()
    }

    pub fn get_high_score(&self) -> Score {
        self.high_score.clone()
    }

    pub fn reward_exp(&mut self, exp: EXP) {
        self.xp += exp;
        self.update_level();
    }

    /// Makes a comparison with the highscore. 
    /// 
    /// 
    /// If a highscore is achieved, return it.
    /// 
    /// Else return None.
    /// 
    pub fn check_highscore(&mut self, score: Score) -> Option<HighScore> {

        if score > self.high_score {
            self.high_score = score;
            let player = env::predecessor_account_id();

            let high_score: HighScore = HighScore::new(score, &self, player);

            return Some(high_score);
        }

        None
    }

}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/stats.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use crate::model::character::Class;

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}

impl Stats{
    pub fn new(
        dexterity_base: u32,
        dexterity_rate: u32,
        strength_base: u32,
        strength_rate: u32,
        intelligence_base: u32,
        intelligence_rate: u32,
    ) -> Self {
        let (dexterity, strength, intelligence) = (dexterity_base, strength_base, intelligence_base);

        Stats { 
            dexterity, 
            dexterity_rate,
            dexterity_base,
            strength,
            strength_rate,
            strength_base,
            intelligence,
            intelligence_rate,
            intelligence_base,
        }
    }

    pub fn update(&mut self, level: u32) {
        // dexterity, strength, inteligence
        // all these temporary variables won't exist in the machine code.
        // LLVM compiler optimizes these things away.
        // So don't worry about making your code more readable.

        let dexterity: u32 = self.dexterity_base + self.dexterity_rate * level;
        let strength: u32 = self.strength_base + self.strength_rate * level;
        let inteligence: u32 = self.intelligence_base + self.intelligence_rate * level;

        self.dexterity = dexterity;
        self.strength = strength;
        self.intelligence = inteligence;
    }
}

impl From<&Class> for Stats {
    fn from(class: &Class) -> Stats {
        class.get_stats()
    }
}

impl From<Class> for Stats {
    fn from(class: Class) -> Stats {
        Stats::from(&class)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/errors.rs ---
use near_sdk::{
    AccountId,
    borsh::{ self, BorshSerialize },
    FunctionError,
};

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/mod.rs ---

mod player;
mod chapter;
mod errors;
mod storage;

pub mod character;
pub mod score;

pub(crate) use player::Player;
pub(crate) use player::View as player_view;
pub(crate) use errors::Errors;
pub(crate) use chapter::Chapter;
pub(crate) use storage::StorageKey;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/player/mod.rs ---
use near_sdk::{
    AccountId,
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    collections::{
        LookupMap,
        UnorderedSet,
    },
    env,
};

mod view;

use crate::model::{
    chapter::Chapter,
    character,
    character::Character,
    score::HighScore,
    score::Score,
    Errors,
};

use crate::StorageKey;

pub type Name = AccountId;

pub use view::View;

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}

// Initial state of the player.
impl Default for Player{
    fn default() -> Self {
        let name = env::predecessor_account_id();

        let high_score = None;
        let characters = 
            LookupMap::new(
                StorageKey::Characters(name.clone())
            );

        let character_names: UnorderedSet<character::Name> = UnorderedSet::new(
            StorageKey::CharacterNames(name.clone())
        );

        let latest_chapter: Chapter = Chapter::default();
        
        Player{
            name,
            high_score,
            characters,
            character_names,
            latest_chapter,
        }
    }
}

impl Player{
    /// Will panic if a character with that name already exists.
    fn assert_character_doesnt_exist(&self, character_name: &character::Name) -> Result<(), Errors> {
        if self.characters.contains_key(character_name) {
            return Err(Errors::CharacterAlreadyExists(character_name.clone()));
        }

        Ok(())
    }

    fn assert_character_exists(&self, character_name: &character::Name) -> Result<(), Errors> {
        if !self.characters.contains_key(character_name) {
            return Err(Errors::CharacterNotFound(character_name.clone()));
        }

        Ok(())
    }

    /// Returns the character state. Should be replaced by pointer access later.
    pub fn load_character(&self, name: character::Name) -> Result<Character, Errors> {
        match self.characters.get(&name){
            None => Err(Errors::CharacterNotFound(name.to_string())),
            Some(character) => Ok(character),
        }
    }

    /// This should be replaced by pointer access later.
    fn save_character(&mut self, character: &Character) -> Result<(), Errors> {
        let character_name = character.get_name();

        self.assert_character_exists(&character_name)?;

        self.characters.insert(&character_name, character).unwrap();

        Ok(())
    }

    pub fn assign_character(&mut self, character: Character) -> Result<(), Errors> {
        let character_name = character.get_name();
        
        self.assert_character_doesnt_exist(&character_name)?;

        // If this error happens. It's an unexpected server error. That means that something else is going wrong.
        // It should be reported.
        assert!(self.characters.insert(&character_name, &character).is_none(), "Server error: Character doesn't exist. Please Report.");
        self.character_names.insert(&character_name);

        Ok(())
    }

    /// Move to the next chapter.
    pub fn next_match(&mut self){
        self.latest_chapter.next_match();
    }

    /// Start timer and return the current chapter.
    pub fn start_match(&mut self) -> Chapter {
        self.latest_chapter.start_match()
    }

    /// End the timer and reward the character. Then update highscores.
    /// 
    /// Returns a HighScore if it was achieved,
    pub fn report_match(
        &mut self,
        character: String,
        score: Score,
        // validation_report: ValidationReport,
    ) -> Result<Option<HighScore>, Errors> {
        let mut character: Character = self.load_character(character)?;

        let exp: character::EXP = self.latest_chapter.validate_match(
            &character, 
            &score,
        )?;

        let new_character_highscore: Option<HighScore> = character.check_highscore(score);

        let high_score: Option<HighScore> = HighScore::update_highscore(
            &mut self.high_score, 
            new_character_highscore,
        );

        character.reward_exp(exp);
        self.save_character(&character)?;

        Ok(high_score)
    }

    /// Get characters' name.
    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    /// Returns information about this player as json.
    /// 
    /// LookupMap and UnorderedSet can't be serialized into json. We create a View with serializable data types and return it instead.
    pub fn get_view(&self) -> Result<View, Errors> {
        let name: Name = self.name.clone();
        let high_score: Option<HighScore> = self.high_score.clone();
        let mut characters: Vec<Character> = Vec::with_capacity(self.character_names.len() as usize);

        for character_name in self.character_names.iter() {
            let character: Character = self.load_character(character_name)?;
            characters.push(character);
        };

        Ok(View { name, high_score, characters })
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/player/view.rs ---
//! When a user loads a player type. This type is what they will receive.
//! 
//! 

use near_sdk::{
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    player,
    score::HighScore,
};

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/high_score.rs ---
use near_sdk::{
    AccountId,
    borsh::{ BorshDeserialize, BorshSerialize, self },
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    score::Score,
};

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}

// Used for ordering HighScores within a Vec
impl Ord for HighScore {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.score.cmp(&other.score)
    }
}

// Required by Ord.
impl PartialOrd for HighScore {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

// Used for partial comparisons between HighScores. Required by Ord and Eq.
//
// A = B sometimes doesn't mean B = A.
impl PartialEq for HighScore {
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

// Used for comparisons between HighScores. Required by Ord.
//
// This implies that A = B means B = A.
impl Eq for HighScore {}

impl HighScore{
    /// Returns a new instance of Highscore.
    pub fn new(
        score: Score,
        character: &Character,
        player: AccountId,
    ) -> Self {

        HighScore{
            score,
            character: character.clone(),
            player,
        }
    }

    /// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
    pub fn update_highscore(
        current_highscore: &mut Option<HighScore>,
        new_high_score: Option<HighScore>,
    ) -> Option<HighScore> {

        // This match will stop assigning the new highscore if one has not been achieved.
        match (&current_highscore, &new_high_score) {
            (_, None) => { 
                // No highscore was achieved by the character.
                return None; 
            },
            (None, Some(_)) => {},
            (Some(old_high_score), Some(new_high_score)) => {
                // A character achieved a highscore
                // there is a highscore recorded.
                // makes a comparison and maintain the highest.
                if old_high_score > new_high_score {
                    return None;
                }
            },
        }

        // assign the new highscore
        *current_highscore = new_high_score.clone();

        return new_high_score;
    }

    /// Returns score achieved.
    pub fn get_score(&self) -> Score {
        self.score
    }

    /// Returns character for this highscore.
    pub fn get_character(&self) -> Character {
        self.character.clone()
    }

}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/mod.rs ---
mod high_score;
mod ranking;

pub(crate) use high_score::HighScore;
pub(crate) use ranking::Ranking;
pub type Score = u32;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/ranking.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self},
    env,
    log, 
    serde::{Deserialize, Serialize},
};

use crate::model::{
    score::HighScore,
    Errors,
    // StorageKey,
};

// Just for this exampÄºe, we just want max 10 values in the ranking.
// const RANKSIZE: usize = 10;

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}

impl Serialize for Ranking {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: near_sdk::serde::Serializer {

        serializer.collect_seq(self.values.iter().map(|x| x))
    }
}

impl Default for Ranking{
    fn default() -> Self {
        // let values: Vec<HighScore> = Vector::new(StorageKey::Ranking);
        let max_size: usize = 10;
        let values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = None;

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Clone for Ranking{
    fn clone(&self) -> Self {
        let max_size: usize = self.max_size.clone();
        let mut values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = self.lowest_high_score.clone();
        
        for value in self.values.iter(){
            values.push(value.clone());
        }

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Ranking{

    fn sort_and_resize(&mut self) {
        self.values.sort();
        self.values.truncate(self.max_size);
    }

    /// This is only called when the ranking list is full.
    /// Add the entry to the list, sort it, then remove all the excess elements.
    /// Finally, set the lowest high score value to the element at the end of the list.
    fn new_entry(&mut self, entry: HighScore) {
        self.values.push(entry);

        // Sort the highscores and resize it to RANKSIZE (If it has more values than RANKSIZE)
        self.sort_and_resize();

        let lowest_high_score = self.values.last();

        match lowest_high_score {
            None => env::panic_str("Smart contract implementation error. This should never happen. Called Ranking::new_entry and got a None."),
            Some(lowest) => {
                self.lowest_high_score = Some(lowest.clone());
            }
        }
    }

    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>{
        let limit = 1000;

        if max_size > limit {
            return Err(Errors::ExcessiveMaxRankingPlayers(limit, max_size));
        }

        self.max_size = max_size;

        Ok(())
    }

    pub fn check_highscore(
        &mut self, 
        high_score: &Option<HighScore>,
    ) -> bool {
        match high_score {
            None => { 
                // Player didn't achieve a high score.
                false
            },
            Some(high_score) => {
                log!("New High Score for this Player.");

                // Compiler will apply branchless optimization to all these if/else statements.
                if self.lowest_high_score.is_none() {
                    // This is the first entry, so just include it.
                    self.new_entry(high_score.clone());

                    return true;
                } else {
                    // This is not the first entry.
                    // The list may be full or not.
                    let ranking_is_full: bool = self.values.len() == self.max_size;

                    if !ranking_is_full {
                        // If the list is not full, just include it.
                        self.new_entry(high_score.to_owned());

                        return true;
                    } else {
                        // .unwrap will never panic because of the first "if" above. It is always Some.
                        // We are cloning because unwrap will take ownership of this mutable reference.
                        let lowest_high_score = self.lowest_high_score
                            .clone()
                            .unwrap();

                        if lowest_high_score < *high_score {
                            self.new_entry(high_score.clone());

                            return true;
                        }
                        
                        false
                    }
                }
            }
        }
    }

}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/storage.rs ---
use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshSerialize},
};

/// Keys used for storing values in trie. Required for collections like UnorderedSet and LookupMap.
/// 
/// We have to make sure that each collection has a unique prefix.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    // Holds no argument because only one LookupMap for Players in the entire smart contract.
    Players,
    
    // Holds an account Id because Each player has one UnorderedSet for the characters. The AccountId is used to tell these types apart.
    Characters(AccountId),

    // Same for character names. It's an UnorderedSet that is different between each player. 
    // So we use the AccountId (unique for each player) within the tuple.
    CharacterNames(AccountId),
}
'''
'''--- PT-BR/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- PT-BR/static/tutorials/cargo.md ---
# IntroduÃ§Ã£o a Cargo

Cargo Ã© a ferramenta que usamos para administrar nossos projetos da linguagem rust. DocumentaÃ§Ã£o completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que Ã© crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informaÃ§Ãµes meta sobre este diretÃ³rio. CaracterÃ­sticas como nome e versÃ£o, mas tambÃ©m configuraÃ§Ãµes sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrÃ£o. Identico ao Cargo.toml da liÃ§Ã£o 1.](../images/cargo.png)

NÃ£o Ã© necessÃ¡rio saber tudo sobre essas configuraÃ§Ãµes. As configuraÃ§Ãµes que precisaremos alterar sÃ£o ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tÃ³picos principais:
 - **package**: ConfiguraÃ§Ãµes sobre a crate. Nome, versÃ£o, licensa, ediÃ§Ã£o do Rust, etc; 
 - **lib**: Isso determina que esta crate nÃ£o Ã© um executÃ¡vel. E sim Ã© uma biblioteca que serÃ¡ acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configuraÃ§Ãµes.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrÃ£o Ã© vindo do site "crates.io", mas podemos tambÃ©m incluir crates locais; podemos incluir atravÃ©s de um link github, etc.
 - **profile.release**: ConfiguraÃ§Ã£o para projetos compilados para "release". NÃ£o Ã© necessÃ¡rio entender cada instruÃ§Ã£o. Simplesmente fala para o compilador tentar optimizar o mÃ¡ximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que Ã© crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretÃ³rio com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretÃ³rio "target" com o arquivo compilado. Mas se criarmos um workspace, que Ã© um conjunto de vÃ¡rias crates compartilhando um "Cargo.toml", os arquivos compilados sÃ£o todos agrupados na mesma pasta. Para mais detalhes, cheque a liÃ§Ã£o sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

DependÃªncias como ```near_sdk``` sÃ£o baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condiÃ§Ã£o**: Deve ser open-source.

O site intencionalmente nÃ£o disponibiliza opÃ§Ã£o para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versÃ£o do registry usando o comando "yank", projetos nÃ£o poderÃ£o mais baixar a versÃ£o, mas ainda continuarÃ£o funcionando se tiverem a versÃ£o baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

SÃ³ isso. Existem vÃ¡rios outros comandos que podemos executar com cargo. Mas nÃ£o sÃ£o necessÃ¡rios para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilaÃ§Ã£o feitas para auxiliar o debug e otimiza o cÃ³digo para produÃ§Ã£o
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estarÃ¡ no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instruÃ§Ã£o irÃ¡ resultar em **erro** se nÃ£o instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instruÃ§Ã£o (apenas uma vez para cada instalaÃ§Ã£o de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma funÃ§Ã£o possui o marcador ```#[test]```, essa funÃ§Ã£o serÃ¡ executada.

Testes de unidade simplesmente procuram por situaÃ§Ãµes de pÃ¢nico. Se um pÃ¢nico inesperado acontece, ou um pÃ¢nico esperado nÃ£o acontece, o teste falha.

Macros como panic, assert e assert_eq sÃ£o usados para garantir nossas condiÃ§Ãµes.
 - ```panic!("Mensagem");```: Causa pÃ¢nico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pÃ¢nico se a condiÃ§Ã£o for falsa. EstÃ¡ "garantindo" que a condiÃ§Ã£o serÃ¡ verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pÃ¢nico com a dada mensagem.

Exemplo de situaÃ§Ã£o em que nÃ£o esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 Ã© sempre igual a 2. EntÃ£o nunca haverÃ¡ panic.

Exemplo de situaÃ§Ã£o em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este Ã© um exemplo da "liÃ§Ã£o 4 - mÃ³dulos". A funÃ§Ã£o ```this_will_panic()``` Ã© uma funÃ§Ã£o que eu criei que sempre causa pÃ¢nico.

```#[should_panic]``` significa que o teste vai falhar se nÃ£o entrar em panic. ```expected``` especifica qual a mensagem de pÃ¢nico esperada.

Isso Ã© tudo sobre testes para contrato. Para simular a comunicaÃ§Ã£o entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma pÃ¡gina de web com a documentaÃ§Ã£o do projeto. Muito fÃ¡cil de compartilhar. A pagina de web estarÃ¡ no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
IrÃ¡ abrir a pagina de web no navegador padrÃ£o.

![](../images/cargodoc.png)

Clique em Contract para ver as funÃ§Ãµes implementadas:

![](../images/cargodoccontract.png)

ComentÃ¡rios com ```//``` nÃ£o aparecem na documentaÃ§Ã£o.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

'''
'''--- PT-BR/static/tutorials/nearcli.md ---
# IntroduÃ§Ã£o a near-cli

Near CLI ("command line interface") Ã© a ferramenta que utilizamos para interagir com o protocolo blockchain. DocumentaÃ§Ã£o completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funÃ§Ãµes em contratos inteligentes de outras contas, criar chaves de acesso com certas permissÃµes, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas nÃ£o Ã© obrigatÃ³rio para que essa exista. Cada conta ou sub-conta NEAR sÃ³ pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissÃµes administrativas) de vÃ¡rias sub-contas.

Ou seja, quando precisarmos de implementar vÃ¡rios contratos, podemos distribui-los em uma hierarquia de diversas contas com maior seguranÃ§a. As subcontas sÃ³ precisam das permissÃµes necessÃ¡rias para seus objetivos. As subcontas sÃ³ precisam da quantidade de gas necessÃ¡rias para se manterem em operaÃ§Ã£o.

**gas**: Ã‰ NEAR gasto para computaÃ§Ã£o, armazenamento de dados, criaÃ§Ã£o de contas, etc. A cada clock de computaÃ§Ã£o, uma fraÃ§Ã£o de NEAR Ã© consumida da conta. As mÃ¡quinas que mantÃ©m nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** Ã© consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando InicializaÃ§Ã£o Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar FunÃ§Ãµes de Contrato](#executando-funÃ§Ãµes-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando Ã  plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

NÃ£o Ã© a nossa mÃ¡quina que executa as funÃ§Ãµes de contrato descentralizadas. A nossa conta na blockchain que faz isso. NÃ³s conectamos a uma conta testnet com este comando.

**testnet**: Ã© uma plataforma de teste NEAR. Os tokens nÃ£o tem valor e nÃ£o Ã© possivel comercializÃ¡-los. A plataforma oficial Ã© a **mainnet**. Garanta que nÃ£o hÃ¡ riscos no contrato antes de implementar para produÃ§Ã£o.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. Ã‰ informaÃ§Ã£o pÃºblica.

![Imagem de terminal apÃ³s o uso do comando acima.](../images/nearstate.png)

Lembrar que esta Ã© uma conta **testnet**. NÃ£o Ã© dinheiro de verdade. Os atributos que conseguimos sÃ£o estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10Â²â´ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de cÃ³digo for uma sequÃªncia de "1", entÃ£o nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informaÃ§Ãµes sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviarÃ¡ 10 NEAR para a subconta;

Para criar uma conta de topo nÃ­vel, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

ApÃ³s compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato serÃ¡ a trait ```Default``` que implementamos no cÃ³digo rust. Essa trait nÃ£o recebe parÃ¢metros para inicializaÃ§Ã£o. Se quisermos usar um construtor com parÃ¢metros de inicializaÃ§Ã£o, precisamos de seguir dois passos:

O primeiro passo Ã© declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da funÃ§Ã£o ```new``` nÃ£o Ã© obrigatÃ³rio. Mas Ã© convenÃ§Ã£o criar construtores com este nome.

O segundo passo Ã© incluir os parÃ¢metros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a funÃ§Ã£o e argumentos, respectivamente.

O comando de implantaÃ§Ã£o poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicializaÃ§Ã£o sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` Ã© um requisito para o funcionamento do contrato, mesmo se nÃ£o pretendermos utilizÃ¡-la. Se a inicializaÃ§Ã£o com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pÃ¢nico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" sÃ£o descritos a seguir:

Na implementaÃ§Ã£o de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaraÃ§Ã£o de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funÃ§Ãµes do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funÃ§Ãµes de contrato:
 - **view**: NÃ£o realiza computaÃ§Ã£o e nÃ£o altera estado do contrato. NÃ£o consome gÃ¡s. Ou seja, Ã© de graÃ§a.
 - **call**: Todos os outros tipos de funÃ§Ã£o. Consomem gÃ¡s. Podem necessitar um pagamento. A implementaÃ§Ã£o da funÃ§Ã£o pode incluir outras restriÃ§Ãµes, como restriÃ§Ãµes de chave, restriÃ§Ãµes de usuÃ¡rio, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos sÃ£o publicos.

Se uma funÃ§Ã£o simplesmente retorna um valor armazenado no estado, entÃ£o pode ser uma funÃ§Ã£o view. FunÃ§Ãµes view nÃ£o consomem gÃ¡s, e nÃ£o precisam de pagamento.

FunÃ§Ãµes view nÃ£o podem realizar nenhum cÃ¡lculo, e nÃ£o podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo sÃ£o exemplos vÃ¡lidos para funÃ§Ãµes view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String nÃ£o implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicaÃ§Ã£o sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cÃ³pia desse tipo com o mÃ©todo ```clone()```. Se um tipo implementar Copy, a cÃ³pÃ­a serÃ¡ feita automaticamente quando necessÃ¡rio. A instruÃ§Ã£o seguinte para i32:

```rust
return self.counter;
```

Se counter nÃ£o implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereÃ§o de variÃ¡vel para outro lugar. Counter nÃ£o teria um valor, pois a "ownership" foi perdida. O compilador nÃ£o irÃ¡ permitir essa transferÃªncia.

O exemplo a seguir **nÃ£o** pode ser funÃ§Ã£o view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a funÃ§Ã£o simplesmente retorna um nÃºmero, Ã© ainda considerada computaÃ§Ã£o. Relembrando, funÃ§Ãµes view apenas retornam o valor de um estado do contrato (que Ã© informaÃ§Ã£o pÃºblica).

#### Executando uma funÃ§Ã£o view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de funÃ§Ã£o que nÃ£o Ã© ```view```, Ã© ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de funÃ§Ã£o ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "liÃ§Ã£o 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a funÃ§Ã£o da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento Ã© o nome da sub-conta a deletar. O segundo argumento Ã© o nome da conta que irÃ¡ receber todo o NEAR armazenado.

'''
'''--- PT-BR/static/tutorials/rust.md ---
# InstalaÃ§Ã£o Rust

Este tutorial descreve a instalaÃ§Ã£o das ferramentas recomendadas para criaÃ§Ã£o de projetos NEAR em Rust.

 - [Scripts de InstalaÃ§Ã£o](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos vÃ¡rias ferramentas diferentes com uma Ãºnica linha de comando. Ã€s que destacaremos nesse tutorial sÃ£o: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o cÃ³digo rust para linguagem de mÃ¡quina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentaÃ§Ã£o, realizar testes de unidade, executar projeto como binÃ¡rio.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versÃµes. rustup controla estas versÃµes.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

Ã‰ apenas uma analogia, existem algumas diferenÃ§as que serÃ£o encontradas em pratica.

## Scripts de instalaÃ§Ã£o
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalaÃ§Ã£o de Rust. A primeira Ã© recomendada para estudo, a segunda Ã© recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessÃ¡rias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositÃ³rio](https://github.com/rust-lang/rustlings) e siga as instruÃ§Ãµes de instalaÃ§Ã£o.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalaÃ§Ã£o
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissÃµes de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessÃ¡rias.

'''
'''--- PT-BR/static/tutorials/setup-nearcli.md ---
# InstalaÃ§Ã£o NEAR CLI

NEAR CLI (NEAR Command Line Interface) Ã© utilizado para fazer login e interagir com contas NEAR.

Uma explicaÃ§Ã£o detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos sÃ£o descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descriÃ§Ãµes do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versÃ£o 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- Readme.md ---
# Rust tutorial

 - [Para Portugues](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR)
 - [For English](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN)
 - [Para espaÃ±ol](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES)  -- WIP

'''